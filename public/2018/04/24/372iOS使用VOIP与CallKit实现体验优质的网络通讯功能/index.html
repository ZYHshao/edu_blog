<script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script> 
<script>
　　let models = [
    "https://unpkg.com/live2d-widget-model-chitose@1.0.5/assets/chitose.model.json",
    "https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json",
    "https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json",
    "https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json",
    "https://unpkg.com/live2d-widget-model-miku@1.0.5/assets/miku.model.json",
    "https://unpkg.com/live2d-widget-model-z16@1.0.5/assets/z16.model.json"
];
let m = models[Math.round(Math.random()*5)];
　　L2Dwidget.init({ 
　　"model": {jsonPath:m,"scale": 1 }, 
　　"display": { "position": "left", "width": 200, "height": 300,"hOffset": 0, "vOffset": -20 }, 
　　"mobile": { "show": true, "scale": 0.5 }, 
　　"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });
</script> 
<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="珲少的技术博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://huishao.cc">
    <!--SEO-->

<meta name="description" content="珲少的技术博客">



<meta name="keywords" content="珲少">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>iOS使用VOIP与CallKit实现体验优质的网络通讯功能 | 珲少的技术博客</title>


    <link rel="alternate" href="/atom.xml" title="珲少的技术博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    





    
</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner.png)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='珲少'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 学如逆水行舟 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://huishao.cc">珲少的技术博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>主页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>归档</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="iOS使用VOIP与CallKit实现体验优质的网络通讯功能">
            
	            iOS使用VOIP与CallKit实现体验优质的网络通讯功能
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/iOS逻辑初窥">
            iOS逻辑初窥
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/04/24</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="iOS使用VOIP与CallKit实现体验优质的网络通讯功能"><a href="#iOS使用VOIP与CallKit实现体验优质的网络通讯功能" class="headerlink" title="iOS使用VOIP与CallKit实现体验优质的网络通讯功能"></a>iOS使用VOIP与CallKit实现体验优质的网络通讯功能</h2><pre><code>VOIP是Apple提供给开发者的网络电话功能接口。简单来说，其可以让你的应用程序在完全杀死的情况下被服务端唤醒。CallKit是iOS10引入的新框架，使用它可以让你的应用程序调用系统的通话和通话记录界面。试想一下，用户可以在锁屏，应用被杀死，应用在后台等情况下收到通讯请求并且弹出系统的通话界面进行交互是多么酷的一件事。
</code></pre><h3 id="一、创建VOIP推送证书"><a href="#一、创建VOIP推送证书" class="headerlink" title="一、创建VOIP推送证书"></a>一、创建VOIP推送证书</h3><pre><code>VOIP说是一种网络电话服务，其实质是一种特殊的长连接，使用它每个网络电话类APP不需要自己单独进行保活维护，在进行通话请求时，只需要发送一条VOIP推送，VOIP推送会将应用程序拉起，之后由应用程序处理通讯逻辑。VOIP也是Push的一种，只是其是一种特殊的Push，普通的Push当应用被杀死后可以收到，但是用户点击Push消息前应用程序是不会被激活的，VOIP则不然，可以直接激活应用。

VOIP推送证书的创建方式与普通推送证书的创建方式基本一致，首先需要生成certSigningRequest文件，打开钥匙串应用：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0423/141531_jLCt_2340880.png" alt></p>
<p>在证书助理栏选择从证书颁发机构申请证书：</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0423/141604_ashA_2340880.png" alt></p>
<p>填写相关资料后，将生成的文件保存：</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0423/141636_splB_2340880.png" alt></p>
<p>在Apple开发者中心创建新的证书，证书类型选择生产环境的VOIP服务证书：</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0423/141942_vfAz_2340880.png" alt></p>
<p>需要注意，普通的推送分开发环境和生产环境，VOIP证书不进行区分，生产环境和开发环境是通用的。之后选择一个AppID并且上传前面生成的certSigningRequest文件来完成VOIP证书的创建。</p>
<pre><code>创建完成后，在证书列表可以看到多了一个VOIP服务证书，可以加载此证书进行VOIP推送。
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0423/142407_sOzY_2340880.png" alt></p>
<h3 id="二、PushKit详析"><a href="#二、PushKit详析" class="headerlink" title="二、PushKit详析"></a>二、PushKit详析</h3><pre><code>我们知道，客户端若想要接收普通的Push消息，是需要注册Token，通过Token来进行个推的。VOIP推送也是一样的，只是这类推送需要使用PushKit框架。

首先需要用到PKPushRegistey类，这个类进行推送的相关配置和Token的申请：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PKPushRegistry</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">//代理对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>,<span class="keyword">weak</span>,<span class="keyword">nullable</span>) <span class="keyword">id</span>&lt;PKPushRegistryDelegate&gt; delegate;</span><br><span class="line"><span class="comment">//目标推送类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PK_EXPORT PKPushType const PKPushTypeVoIP NS_AVAILABLE_IOS(8_0);//VOIP推送</span></span><br><span class="line"><span class="comment">PK_EXPORT PKPushType const PKPushTypeComplication NS_AVAILABLE_IOS(9_0);//Watch更新</span></span><br><span class="line"><span class="comment">PK_EXPORT PKPushType const PKPushTypeFileProvider NS_AVAILABLE_IOS(11_0);//文件传输</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>,<span class="keyword">copy</span>,<span class="keyword">nullable</span>) <span class="built_in">NSSet</span>&lt;PKPushType&gt; *desiredPushTypes;</span><br><span class="line"><span class="comment">//获取本地缓存的Token  申请Token执行回调后 这个方法可以直接获取缓存</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)pushTokenForType:(PKPushType)type;</span><br><span class="line"><span class="comment">//初始化，并设置工作线程</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithQueue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>PKPushRegistryDelegate相关函数意义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请Token更新后回调</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PKPushCredentials是证书对象，其中属性如下：</span></span><br><span class="line"><span class="comment">@property (readonly,copy) PKPushType type;//推送类型</span></span><br><span class="line"><span class="comment">@property (readonly,copy) NSData *token; //Token</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)pushRegistry:(PKPushRegistry *)registry didUpdatePushCredentials:(PKPushCredentials *)pushCredentials forType:(PKPushType)type;</span><br><span class="line"><span class="comment">//收到推送后执行的回调</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PKPushPayload为推送信息 其中属性如下：</span></span><br><span class="line"><span class="comment">@property (readonly,copy) PKPushType type; //推送类型</span></span><br><span class="line"><span class="comment">@property (readonly,copy) NSDictionary *dictionaryPayload; //服务端发来的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)pushRegistry:(PKPushRegistry *)registry didReceiveIncomingPushWithPayload:(PKPushPayload *)payload forType:(PKPushType)type <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">8</span>_0, <span class="number">11</span>_0);</span><br><span class="line"><span class="comment">//作用同上，最后的block需要在逻辑处理完成后主动回调</span></span><br><span class="line">- (<span class="keyword">void</span>)pushRegistry:(PKPushRegistry *)registry didReceiveIncomingPushWithPayload:(PKPushPayload *)payload forType:(PKPushType)type withCompletionHandler:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">11</span>_0);</span><br><span class="line"><span class="comment">//Token失效的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)pushRegistry:(PKPushRegistry *)registry didInvalidatePushTokenForType:(PKPushType)type;</span><br></pre></td></tr></table></figure>
<p>如果配置成功，在收到VOIP推送时，无论应用程序是否活跃，都会执行代理函数，我们便可以在其中进行逻辑处理。</p>
<h3 id="三、关于CallKit框架"><a href="#三、关于CallKit框架" class="headerlink" title="三、关于CallKit框架"></a>三、关于CallKit框架</h3><pre><code>CallKit框架是iOS10后系统提供的一套网络电话UI和交互相关接口，应用程序可以调用系统的电话界面来进行逻辑传递。下图比较形象的表达了应用程序与CallKit的关系：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0423/150352_MOMA_2340880.png" alt></p>
<p>以收到网络电话为例，如果应用程序在前台，客户端可以直接处理通讯逻辑，如果应用程序不在前台，服务端可以发送一条VOIP推送唤醒APP，之后APP通知CallKit框架来唤起系统的通讯界面。CXProvider类主要负责系统服务于APP之间的交互。例如可以通过它来更新通话界面，显示通话的来自方，当用户点击通话界面的某些按钮后，也通过它来通知APP做逻辑处理。</p>
<pre><code>需要注意，上图在CallKit和System之间有两个双向的白色箭头，这描述了CallKit和系统交互的四个方向。

首先，App想要和系统交互，例如接收到VOIP通知后弹出通话界面，需要使用CXProvider通过CXCallUpdate来进行控制。如下图：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0423/222253_IDKX_2340880.png" alt></p>
<pre><code>之后系统会将一些用户操作通过CSAction传递会APP，如下：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0423/222346_nXGZ_2340880.png" alt></p>
<pre><code>APP中进行的操作如果需要通知系统，需要使用CXCallController通过CXTransaction传递。例如App内的通讯需要添加到系统的历史通话列表。如下：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0423/223200_XVBF_2340880.png" alt></p>
<h4 id="1-先来看CXProvider类"><a href="#1-先来看CXProvider类" class="headerlink" title="1.先来看CXProvider类"></a>1.先来看CXProvider类</h4><pre><code>CXProvider类用来对系统通话界面进行一些配置操作，并处理回调逻辑，解析如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化方法 使用CXProviderConfiguration来进行配置 后面会介绍</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithConfiguration:(CXProviderConfiguration *)configuration <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"><span class="comment">//设置代理与代理函数所工作的线程</span></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;CXProviderDelegate&gt;)delegate queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue;</span><br><span class="line"><span class="comment">//向系统发起一个新的通话请求</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UUID为此通话请求的标识 可以使用它来关闭通话</span></span><br><span class="line"><span class="comment">update设置界面的更新参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)reportNewIncomingCallWithUUID:(<span class="built_in">NSUUID</span> *)UUID update:(CXCallUpdate *)update completion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *_Nullable error))completion;</span><br><span class="line"><span class="comment">//结束某个通话 使用上面的UUID作为标识</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//通话结束的原因设置</span></span><br><span class="line"><span class="comment">typedef NS_ENUM(NSInteger, CXCallEndedReason) &#123;</span></span><br><span class="line"><span class="comment">    CXCallEndedReasonFailed = 1, // 通话服务失败</span></span><br><span class="line"><span class="comment">    CXCallEndedReasonRemoteEnded = 2, // 对方挂断</span></span><br><span class="line"><span class="comment">    CXCallEndedReasonUnanswered = 3, // 超时 对方为接听</span></span><br><span class="line"><span class="comment">    CXCallEndedReasonAnsweredElsewhere = 4, // 通话在其他设备接听</span></span><br><span class="line"><span class="comment">    CXCallEndedReasonDeclinedElsewhere = 5, // 通话在其他设备拒绝</span></span><br><span class="line"><span class="comment">&#125; API_AVAILABLE(ios(10.0));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)reportCallWithUUID:(<span class="built_in">NSUUID</span> *)UUID endedAtDate:(<span class="keyword">nullable</span> <span class="built_in">NSDate</span> *)dateEnded reason:(CXCallEndedReason)endedReason;</span><br><span class="line"><span class="comment">//更新通话对方的信息</span></span><br><span class="line">- (<span class="keyword">void</span>)reportCallWithUUID:(<span class="built_in">NSUUID</span> *)UUID updated:(CXCallUpdate *)update;</span><br><span class="line"><span class="comment">//调用这个函数来进行通话呼出开始</span></span><br><span class="line">- (<span class="keyword">void</span>)reportOutgoingCallWithUUID:(<span class="built_in">NSUUID</span> *)UUID startedConnectingAtDate:(<span class="keyword">nullable</span> <span class="built_in">NSDate</span> *)dateStartedConnecting;</span><br><span class="line"><span class="comment">//调用这个函数来进行通话呼出连接完成</span></span><br><span class="line">- (<span class="keyword">void</span>)reportOutgoingCallWithUUID:(<span class="built_in">NSUUID</span> *)UUID connectedAtDate:(<span class="keyword">nullable</span> <span class="built_in">NSDate</span> *)dateConnected;</span><br><span class="line"><span class="comment">//配置对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) CXProviderConfiguration *configuration;</span><br><span class="line"><span class="comment">//调用此函数来将通话失效</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br><span class="line"><span class="comment">//所有未完成的事物</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;CXTransaction *&gt; *pendingTransactions;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;__kindof CXCallAction *&gt; *)pendingCallActionsOfClass:(Class)callActionClass withCallUUID:(<span class="built_in">NSUUID</span> *)callUUID;</span><br></pre></td></tr></table></figure>
<h4 id="2-在看CXProviderConfiguration类"><a href="#2-在看CXProviderConfiguration类" class="headerlink" title="2.在看CXProviderConfiguration类"></a>2.在看CXProviderConfiguration类</h4><pre><code>这个类用来进行Provider的配置，例如设置通讯服务名称，铃声，图标，是否支持组等。解析如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置服务名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *localizedName;</span><br><span class="line"><span class="comment">//设置铃声  资源必须在 app的 bundle里</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *ringtoneSound;</span><br><span class="line"><span class="comment">//设置应用图标</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSData</span> *iconTemplateImageData;</span><br><span class="line"><span class="comment">//设置最大支持的组数 默认为2</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maximumCallGroups;</span><br><span class="line"><span class="comment">//设置最大的每组人数 默认为5</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maximumCallsPerCallGroup;</span><br><span class="line"><span class="comment">//设置是否将通话记录保存进最近通话列表</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> includesCallsInRecents;</span><br><span class="line"><span class="comment">//设置是否支持视频通话</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> supportsVideo;</span><br><span class="line"><span class="comment">//设置支持的操作类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSSet</span>&lt;<span class="built_in">NSNumber</span> *&gt; *supportedHandleTypes;</span><br></pre></td></tr></table></figure>
<p>当App接收到来电VOIP通知时，可以使用CXCallUpdate来更新状态唤出通话界面。</p>
<h4 id="3-CXCallUpdate类"><a href="#3-CXCallUpdate类" class="headerlink" title="3.CXCallUpdate类"></a>3.CXCallUpdate类</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//远程操作对象 如果是接收方 则此为呼叫方 如果是呼叫方 则此为接收方</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) CXHandle *remoteHandle;</span><br><span class="line"><span class="comment">//名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *localizedCallerName;</span><br><span class="line"><span class="comment">//是否支持暂时挂起</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> supportsHolding;</span><br><span class="line"><span class="comment">//是否支持组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> supportsGrouping;</span><br><span class="line"><span class="comment">//是否支持非组通话</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> supportsUngrouping;</span><br><span class="line"><span class="comment">//是否支持DTMF</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> supportsDTMF;</span><br><span class="line"><span class="comment">//是否包含视频</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> hasVideo;</span><br></pre></td></tr></table></figure>
<p>CXHandle中来定义操作的类型，解析如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef NS_ENUM(NSInteger, CXHandleType) &#123;</span></span><br><span class="line"><span class="comment">    CXHandleTypeGeneric = 1,//通用</span></span><br><span class="line"><span class="comment">    CXHandleTypePhoneNumber = 2,//电话</span></span><br><span class="line"><span class="comment">    CXHandleTypeEmailAddress = 3,//邮箱地址</span></span><br><span class="line"><span class="comment">&#125; API_AVAILABLE(ios(10.0));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) CXHandleType type;</span><br><span class="line"><span class="comment">//值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *value;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithType:(CXHandleType)type value:(<span class="built_in">NSString</span> *)value <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure>
<p>下面给出了简单的当被叫收到VOIP后调起通话界面的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CXCallUpdate * callUpdate = [[CXCallUpdate alloc]init];</span><br><span class="line">callUpdate.supportsGrouping = <span class="literal">YES</span>;</span><br><span class="line">callUpdate.supportsDTMF = <span class="literal">YES</span>;</span><br><span class="line">callUpdate.hasVideo = <span class="literal">YES</span>;</span><br><span class="line">callUpdate.supportsHolding = <span class="literal">YES</span>;</span><br><span class="line">[callUpdate setLocalizedCallerName:nickName];</span><br><span class="line">CXHandle * handle = [[CXHandle alloc]initWithType:CXHandleTypePhoneNumber value:from];</span><br><span class="line">callUpdate.remoteHandle = handle;</span><br><span class="line"> [[<span class="keyword">self</span> shareInstance].callProvider reportNewIncomingCallWithUUID:[<span class="keyword">self</span> shareInstance].uuid update:callUpdate completion:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">     LOG(<span class="string">@"吊起界面"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>锁屏和应用程序在后台的效果分别如下所示：</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0423/215747_SILb_2340880.jpeg" alt>               <img src="https://static.oschina.net/uploads/space/2018/0423/215800_wlPB_2340880.jpeg" alt></p>
<p><img src="https://static.oschina.net/uploads/space/2018/0423/215816_JJGo_2340880.jpeg" alt></p>
<h4 id="4-CXProviderDelegate相关函数解析"><a href="#4-CXProviderDelegate相关函数解析" class="headerlink" title="4.CXProviderDelegate相关函数解析"></a>4.CXProviderDelegate相关函数解析</h4><pre><code>CXProviderDelegate中的相关函数用来处理系统通话界面的某些操作回调给应用程序。
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当接收到呼叫重置时 调用的函数，这个函数必须被实现，其不需做任何逻辑，只用来重置状态</span></span><br><span class="line">- (<span class="keyword">void</span>)providerDidReset:(CXProvider *)provider;</span><br><span class="line"><span class="comment">//呼叫开始时回调 </span></span><br><span class="line">- (<span class="keyword">void</span>)providerDidBegin:(CXProvider *)provider;</span><br><span class="line"><span class="comment">//音频会话激活状态的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider didActivateAudioSession:(<span class="built_in">AVAudioSession</span> *)audioSession;</span><br><span class="line"><span class="comment">//音频会话停用的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider didDeactivateAudioSession:(<span class="built_in">AVAudioSession</span> *)audioSession;</span><br><span class="line"><span class="comment">//行为超时的回调 </span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider timedOutPerformingAction:(CXAction *)action;</span><br><span class="line"><span class="comment">//有事务被提交时调用 </span></span><br><span class="line"><span class="comment">//如果返回YES 则表示事务被捕获处理 后面的回调都不会调用 如果返回NO 则表示事务不被捕获，会回调后面的函数</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)provider:(CXProvider *)provider executeTransaction:(CXTransaction *)transaction;</span><br><span class="line"><span class="comment">//点击开始按钮的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider performStartCallAction:(CXStartCallAction *)action;</span><br><span class="line"><span class="comment">//点击接听按钮的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider performAnswerCallAction:(CXAnswerCallAction *)action;</span><br><span class="line"><span class="comment">//点击结束按钮的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider performEndCallAction:(CXEndCallAction *)action;</span><br><span class="line"><span class="comment">//点击保持通话按钮的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider performSetHeldCallAction:(CXSetHeldCallAction *)action;</span><br><span class="line"><span class="comment">//点击静音按钮的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider performSetMutedCallAction:(CXSetMutedCallAction *)action;</span><br><span class="line"><span class="comment">//点击组按钮的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider performSetGroupCallAction:(CXSetGroupCallAction *)action;</span><br><span class="line"><span class="comment">//DTMF功能回调</span></span><br><span class="line">- (<span class="keyword">void</span>)provider:(CXProvider *)provider performPlayDTMFCallAction:(CXPlayDTMFCallAction *)action;</span><br></pre></td></tr></table></figure>
<p>需要注意，上面的最后几个回调中CXStartCallAction都会提供一个fullfill的函数，当处理完成回调逻辑后，开发者需要手动调用此函数来通知系统。同样，其中还有一个fail和timeout函数，调用它要通知系统此行为执行失败和超时。</p>
<h4 id="5-CXCallController解析"><a href="#5-CXCallController解析" class="headerlink" title="5.CXCallController解析"></a>5.CXCallController解析</h4><pre><code>当用户在应用程序内部进行的通讯操作时，可以使用这个类来通知系统。
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithQueue:(<span class="built_in">dispatch_queue_t</span>)queue;</span><br><span class="line"><span class="comment">//通讯监听</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) CXCallObserver *callObserver;</span><br><span class="line"><span class="comment">//发起一个事务请求 CXProvider之后会接收到请求 进行逻辑</span></span><br><span class="line">- (<span class="keyword">void</span>)requestTransaction:(CXTransaction *)transaction completion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *_Nullable error))completion;</span><br><span class="line"><span class="comment">//通过行为发起事务</span></span><br><span class="line">- (<span class="keyword">void</span>)requestTransactionWithActions:(<span class="built_in">NSArray</span>&lt;CXAction *&gt; *)actions completion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *_Nullable error))completion API_AVAILABLE(ios(<span class="number">11.0</span>));</span><br><span class="line">- (<span class="keyword">void</span>)requestTransactionWithAction:(CXAction *)action completion:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *_Nullable error))completion API_AVAILABLE(ios(<span class="number">11.0</span>));</span><br></pre></td></tr></table></figure>
<h4 id="6-CXTransaction类"><a href="#6-CXTransaction类" class="headerlink" title="6.CXTransaction类"></a>6.CXTransaction类</h4><pre><code>CXTransaction是封装了行为的事务。
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唯一 ID</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSUUID</span> *UUID;</span><br><span class="line"><span class="comment">//行为完成后的回调</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isComplete) <span class="built_in">BOOL</span> complete;</span><br><span class="line"><span class="comment">//行为数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof CXAction *&gt; *actions;</span><br><span class="line"><span class="comment">//初始化函数</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithActions:(<span class="built_in">NSArray</span>&lt;CXAction *&gt; *)actions;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAction:(CXAction *)action;</span><br><span class="line"><span class="comment">//添加行为</span></span><br><span class="line">- (<span class="keyword">void</span>)addAction:(CXAction *)action;</span><br></pre></td></tr></table></figure>
<h3 id="四、进行来电拦截与号码识别"><a href="#四、进行来电拦截与号码识别" class="headerlink" title="四、进行来电拦截与号码识别"></a>四、进行来电拦截与号码识别</h3><pre><code>上面我们介绍了使用CallKit框架来实现的通讯功能，有通讯功能就难免需要进行联系人识别与黑名单。CallKit框架中还有一部分内容可以结合Call Directory Extension来实现号码拦截与识别。

首先创建一个扩展Target，选择Call Directory Extension：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0424/134623_xk7W_2340880.png" alt></p>
<p>创建好Target工程后，其实需要的核心代码Xcode已经帮我们都生成。</p>
<pre><code>第一步，需要在主APP中进行号码服务的验证和更新，
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_manager = [[CXCallDirectoryManager alloc]init];</span><br><span class="line">   [_manager getEnabledStatusForExtensionWithIdentifier:<span class="string">@"jaki.CallKitTest.Ex"</span> completionHandler:^(CXCallDirectoryEnabledStatus enabledStatus, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">       <span class="keyword">if</span> (enabledStatus==CXCallDirectoryEnabledStatusEnabled) &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"允许"</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"请开启"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br><span class="line">   [_manager reloadExtensionWithIdentifier:<span class="string">@"jaki.CallKitTest.Ex"</span> completionHandler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"刷新配置"</span>);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>通常情况下，当用户在主APP中进行添加联系人，登录，切换账户等操作后，需要通知扩展程序进行号码库的更新，当然，一般在号码库更新时需要从主APP传递数据给扩展，我们可以通过Group来实现，这里不再展开。</p>
<pre><code>工程运行后，会在用户的“设置-&gt;电话-&gt;来电组织与身份识别”项目中看到扩展程序：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0424/141037_h53V_2340880.jpeg" alt></p>
<p>当用户打开此服务或者调用上面的reloadExtension时，会从执行扩展程序的相关方法来重新加载号码库。需要注意，reloadExtension函数中的id参数为扩展项目的bundleID，不是主项目的。</p>
<pre><code>在扩展工程的info.plist文件中，默认配置好了处理来电的操作类，如果要自定义，需要开发者手动修改：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2018/0424/142700_MYdl_2340880.png" alt></p>
<p>默认的CallDirectoryHandler类为来电拦截与身份识别的操作类，其集成自CXCallDirectoryProvider类，当收到加载号码库的请求时，会执行下面的函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)beginRequestWithExtensionContext:(CXCallDirectoryExtensionContext *)context &#123;</span><br><span class="line">    context.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">//是否支持增量更新</span></span><br><span class="line">    <span class="keyword">if</span> (context.isIncremental) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addOrRemoveIncrementalBlockingPhoneNumbersToContext:context];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> addOrRemoveIncrementalIdentificationPhoneNumbersToContext:context];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> addAllBlockingPhoneNumbersToContext:context];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> addAllIdentificationPhoneNumbersToContext:context];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成更新操作</span></span><br><span class="line">    [context completeRequestWithCompletionHandler:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是Xcode默认提供的实现，十分优雅，在iOS11后，号码库的更新支持增量，所以这里进行的区分。</p>
<pre><code>CXCallDirectoryExtensionContext是一个操作上下文，通过它可以像号码库中添加删除数据。解析如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否支持增量更新</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isIncremental) <span class="built_in">BOOL</span> incremental API_AVAILABLE(ios(<span class="number">11.0</span>));</span><br><span class="line"><span class="comment">//添加一个黑名单号码</span></span><br><span class="line">- (<span class="keyword">void</span>)addBlockingEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber;</span><br><span class="line"><span class="comment">//移除一个黑名单号码</span></span><br><span class="line">- (<span class="keyword">void</span>)removeBlockingEntryWithPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber API_AVAILABLE(ios(<span class="number">11.0</span>));</span><br><span class="line"><span class="comment">//移除所有的黑名单号码</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllBlockingEntries API_AVAILABLE(ios(<span class="number">11.0</span>));</span><br><span class="line"><span class="comment">//添加一个身份识别</span></span><br><span class="line">- (<span class="keyword">void</span>)addIdentificationEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber label:(<span class="built_in">NSString</span> *)label;</span><br><span class="line"><span class="comment">//移除一个身份识别</span></span><br><span class="line">- (<span class="keyword">void</span>)removeIdentificationEntryWithPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber API_AVAILABLE(ios(<span class="number">11.0</span>));</span><br><span class="line"><span class="comment">//移除所有身份识别</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllIdentificationEntries API_AVAILABLE(ios(<span class="number">11.0</span>));</span><br><span class="line"><span class="comment">//完成操作后 需要手动调用此函数</span></span><br><span class="line">- (<span class="keyword">void</span>)completeRequestWithCompletionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> expired))completion;</span><br></pre></td></tr></table></figure>
<p>添加了黑名单后，用户将收不到此号码的电话，同样，设置了身份识别后，当用户播出前，会显示设置的身份信息(需要注意，大陆号码需要前面带86)，如下：</p>
<p><img src="https://static.oschina.net/uploads/space/2018/0424/150928_C7Dl_2340880.jpeg" alt></p>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © 微信：15137348047
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/06/09/373iOS-JSON转OC属性小工具/" class="pre-post btn btn-default" title='iOS:JSON转OC属性小工具能'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">iOS:JSON转OC属性小工具能</span>
        </a>
    
    
        <a href="/2018/04/20/371Masonry源码解析/" class="next-post btn btn-default" title='Masonry源码解析'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Masonry源码解析</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
<div id="lv-container" data-id="city" data-uid="MTAyMC8zNzY0Ny8xNDE3OA==">
  <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];
         if (typeof LivereTower === 'function') { return; }
         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;
         e.parentNode.insertBefore(j, e);
     })(document, 'script');
  </script>
</div>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS使用VOIP与CallKit实现体验优质的网络通讯功能"><span class="toc-text">iOS使用VOIP与CallKit实现体验优质的网络通讯功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、创建VOIP推送证书"><span class="toc-text">一、创建VOIP推送证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、PushKit详析"><span class="toc-text">二、PushKit详析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、关于CallKit框架"><span class="toc-text">三、关于CallKit框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-先来看CXProvider类"><span class="toc-text">1.先来看CXProvider类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-在看CXProviderConfiguration类"><span class="toc-text">2.在看CXProviderConfiguration类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CXCallUpdate类"><span class="toc-text">3.CXCallUpdate类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-CXProviderDelegate相关函数解析"><span class="toc-text">4.CXProviderDelegate相关函数解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-CXCallController解析"><span class="toc-text">5.CXCallController解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-CXTransaction类"><span class="toc-text">6.CXTransaction类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、进行来电拦截与号码识别"><span class="toc-text">四、进行来电拦截与号码识别</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2018
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>