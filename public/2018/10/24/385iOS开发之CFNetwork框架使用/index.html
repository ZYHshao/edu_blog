<script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script> 
<script>
　　let models = [
    "https://unpkg.com/live2d-widget-model-chitose@1.0.5/assets/chitose.model.json",
    "https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json",
    "https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json",
    "https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json",
    "https://unpkg.com/live2d-widget-model-miku@1.0.5/assets/miku.model.json",
    "https://unpkg.com/live2d-widget-model-z16@1.0.5/assets/z16.model.json"
];
let m = models[Math.round(Math.random()*5)];
　　L2Dwidget.init({ 
　　"model": {jsonPath:m,"scale": 1 }, 
　　"display": { "position": "left", "width": 200, "height": 300,"hOffset": 0, "vOffset": -20 }, 
　　"mobile": { "show": true, "scale": 0.5 }, 
　　"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });
</script> 
<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="珲少的技术博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://huishao.cc">
    <meta name="referrer" content="no-referrer">
    <!--SEO-->

<meta name="description" content="珲少的技术博客">



<meta name="keywords" content="珲少">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>iOS开发之CFNetwork框架使用 | 珲少的技术博客</title>


    <link rel="alternate" href="/atom.xml" title="珲少的技术博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    





    
</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner.png)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='珲少'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 学如逆水行舟 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://huishao.cc">珲少的技术博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>主页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>归档</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="iOS开发之CFNetwork框架使用">
            
	            iOS开发之CFNetwork框架使用
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/iOS逻辑初窥">
            iOS逻辑初窥
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/10/24</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="iOS开发之CFNetwork框架使用"><a href="#iOS开发之CFNetwork框架使用" class="headerlink" title="iOS开发之CFNetwork框架使用"></a>iOS开发之CFNetwork框架使用</h2><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><pre><code>在iOS应用开发中，CFNetwork框架其实并不是非常常用的，相对NSURLSession框架而言，这是一个相对底层的网络工作框架。官方文档中的下图描述了CFNetwork在整个网络体系中的位置：
</code></pre><p><img src="https://oscimg.oschina.net/oscnet/3d1f42aabe7e50ae4311ccfb378624023e5.jpg" alt></p>
<p>CFNetwork与CoreFoundation关系密切，其实基于CoreFoundation框架的，结构如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/2e9543e4dc18f178e22b55322933b44a737.jpg" alt></p>
<p>本篇博客中不会过多的设计CoreFoundation框架中的内容，主要总结和介绍CFNetwork的相关内容与简单应用。</p>
<h3 id="二、使用CFNetwork进行简单的网络请求"><a href="#二、使用CFNetwork进行简单的网络请求" class="headerlink" title="二、使用CFNetwork进行简单的网络请求"></a>二、使用CFNetwork进行简单的网络请求</h3><pre><code>CFNetwork是使用C语言实现的一套网络访问框架，进行一个简单的网络请求示例代码如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建请求方法字符串    </span></span><br><span class="line"><span class="built_in">CFStringRef</span> method = <span class="built_in">CFSTR</span>(<span class="string">"GET"</span>);</span><br><span class="line"><span class="comment">//创建请求URL字符串</span></span><br><span class="line"><span class="built_in">CFStringRef</span> urlStr = <span class="built_in">CFSTR</span>(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"><span class="comment">//创建请求URL对象</span></span><br><span class="line"><span class="built_in">CFURLRef</span> url = <span class="built_in">CFURLCreateWithString</span>(kCFAllocatorDefault, urlStr, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//创建HTTP消息对象</span></span><br><span class="line"><span class="built_in">CFHTTPMessageRef</span> request = <span class="built_in">CFHTTPMessageCreateRequest</span>(kCFAllocatorDefault, method, url, kCFHTTPVersion1_1);</span><br><span class="line"><span class="comment">//进行请求头的设置</span></span><br><span class="line"><span class="built_in">CFHTTPMessageSetHeaderFieldValue</span>(request, <span class="built_in">CFSTR</span>(<span class="string">"key"</span>), <span class="built_in">CFSTR</span>(<span class="string">"Value"</span>));</span><br><span class="line"><span class="comment">//创建读取流对象</span></span><br><span class="line"><span class="built_in">CFReadStreamRef</span> readStream = <span class="built_in">CFReadStreamCreateForHTTPRequest</span>(kCFAllocatorDefault, request);</span><br><span class="line"><span class="comment">//定义读取流上下文</span></span><br><span class="line"><span class="built_in">CFStreamClientContext</span> ctxt = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="comment">//设置读取的客服端 即回调相关</span></span><br><span class="line"><span class="built_in">CFReadStreamSetClient</span>(readStream, kCFStreamEventHasBytesAvailable|kCFStreamEventEndEncountered|kCFStreamEventOpenCompleted|kCFStreamEventCanAcceptBytes|kCFStreamEventErrorOccurred, myCallBack, &amp;ctxt);</span><br><span class="line"><span class="comment">//将读取流加入runloop中</span></span><br><span class="line"><span class="built_in">CFReadStreamScheduleWithRunLoop</span>(readStream, <span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopCommonModes);</span><br><span class="line"><span class="comment">//开启流</span></span><br><span class="line">printf(<span class="string">"%d"</span>,<span class="built_in">CFReadStreamOpen</span>(readStream));</span><br></pre></td></tr></table></figure>
<p>实现myCallBack回调函数如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myCallBack (<span class="built_in">CFReadStreamRef</span> stream,<span class="built_in">CFStreamEventType</span> type,<span class="keyword">void</span> *clientCallBackInfo)&#123;</span><br><span class="line">    <span class="comment">//流中有可读数据的回调  </span></span><br><span class="line">    <span class="keyword">if</span> (type == kCFStreamEventHasBytesAvailable) &#123;      </span><br><span class="line">        <span class="comment">//将流中的数据存入到数组中</span></span><br><span class="line">        <span class="built_in">UInt8</span> buff [<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">CFReadStreamRead</span>(stream, buff, <span class="number">1024</span>);</span><br><span class="line">        printf(<span class="string">"%s"</span>,buff);</span><br><span class="line">    <span class="comment">//流打开完成的回调</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type==kCFStreamEventOpenCompleted)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"open"</span>);</span><br><span class="line">    <span class="comment">//流异常的回调</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type==kCFStreamEventErrorOccurred)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error:%@"</span>,<span class="built_in">CFErrorCopyDescription</span>( <span class="built_in">CFReadStreamCopyError</span>(stream)));</span><br><span class="line">    <span class="comment">//可以接收写数据时调用</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type==kCFStreamEventCanAcceptBytes)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"kCFStreamEventCanAcceptBytes"</span>);</span><br><span class="line">    <span class="comment">//读取结束回调</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type==kCFStreamEventEndEncountered)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        <span class="built_in">CFReadStreamClose</span>(stream);</span><br><span class="line">        <span class="comment">//将流从runloop中移除</span></span><br><span class="line">        <span class="built_in">CFReadStreamUnscheduleFromRunLoop</span>(stream, <span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopCommonModes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面演示了简单的GET请求，如果使用的请求方法为POST，则可以进行请求体的设置，上面示例代码中，CFStringRef、CFURLRef、CFReadStreamRef等相关的类为CoreFoundation框架中的，这里暂不深究，简单使用即可。后面我们将详细的探讨CFNetwork中相关类的使用。</p>
<h3 id="三、CFHTTPMessageRef详解"><a href="#三、CFHTTPMessageRef详解" class="headerlink" title="三、CFHTTPMessageRef详解"></a>三、CFHTTPMessageRef详解</h3><pre><code>在基于C的框架中，类对象都是使用结构体指针描述的，CFHTTPMessageRef是HTTP消息的封装，其可以是一个HTTP请求，也可以是一个HTTP回执。与其相关的方法解析如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回CGHTTPMessageRef的类型ID</span></span><br><span class="line"><span class="built_in">CFTypeID</span> <span class="built_in">CFHTTPMessageGetTypeID</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//创建一个HTTP请求消息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">alloc为内存管理器 一般使用默认的kCFAllocatorDefault</span></span><br><span class="line"><span class="comment">requestMethod为请求方法</span></span><br><span class="line"><span class="comment">url为请求的路径</span></span><br><span class="line"><span class="comment">httpVersion为请求的HTTP版本</span></span><br><span class="line"><span class="comment">HTTP版本定义如下：</span></span><br><span class="line"><span class="comment">kCFHTTPVersion1_0</span></span><br><span class="line"><span class="comment">kCFHTTPVersion1_1</span></span><br><span class="line"><span class="comment">kCFHTTPVersion2_0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CFHTTPMessageRef</span> <span class="built_in">CFHTTPMessageCreateRequest</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="built_in">CFStringRef</span> requestMethod, <span class="built_in">CFURLRef</span> url, <span class="built_in">CFStringRef</span> httpVersion);</span><br><span class="line"><span class="comment">//创建一个HTTP回执消息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">alloc内存管理器</span></span><br><span class="line"><span class="comment">statusCode 请求回执状态码</span></span><br><span class="line"><span class="comment">statusDescription 请求回执状态描述</span></span><br><span class="line"><span class="comment">httpVersion HTTP版本号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CFHTTPMessageRef</span> <span class="built_in">CFHTTPMessageCreateResponse</span>(<span class="built_in">CFAllocatorRef</span>  __<span class="keyword">nullable</span> alloc,<span class="built_in">CFIndex</span>         statusCode,<span class="built_in">CFStringRef</span>     __<span class="keyword">nullable</span> statusDescription,<span class="built_in">CFStringRef</span>     httpVersion);</span><br><span class="line"><span class="comment">//创建一个空的HTTP消息 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">isRequest 如果传入kCFBooleanTrue 则为请求类型 否则为回执类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CFHTTPMessageRef</span> <span class="built_in">CFHTTPMessageCreateEmpty</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, Boolean isRequest);</span><br><span class="line"><span class="comment">//复制一个HTTP消息</span></span><br><span class="line"><span class="built_in">CFHTTPMessageRef</span> <span class="built_in">CFHTTPMessageCreateCopy</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="built_in">CFHTTPMessageRef</span> message);</span><br><span class="line"><span class="comment">//判断一个HTTP消息是请求 还是 回执</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPMessageIsRequest</span>(<span class="built_in">CFHTTPMessageRef</span> message);</span><br><span class="line"><span class="comment">//获取HTTP版本</span></span><br><span class="line"><span class="built_in">CFStringRef</span> <span class="built_in">CFHTTPMessageCopyVersion</span>(<span class="built_in">CFHTTPMessageRef</span> message);</span><br><span class="line"><span class="comment">//获取消息体内容 请求体或者回执体</span></span><br><span class="line"><span class="built_in">CFDataRef</span> <span class="built_in">CFHTTPMessageCopyBody</span>(<span class="built_in">CFHTTPMessageRef</span> message);</span><br><span class="line"><span class="comment">//设置消息体内容</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFHTTPMessageSetBody</span>(<span class="built_in">CFHTTPMessageRef</span> message, <span class="built_in">CFDataRef</span> bodyData);</span><br><span class="line"><span class="comment">//获取某个消息头内容</span></span><br><span class="line"><span class="built_in">CFStringRef</span> <span class="built_in">CFHTTPMessageCopyHeaderFieldValue</span>(<span class="built_in">CFHTTPMessageRef</span> message, <span class="built_in">CFStringRef</span> headerField);</span><br><span class="line"><span class="comment">//获取所有消息头字段</span></span><br><span class="line"><span class="built_in">CFDictionaryRef</span> <span class="built_in">CFHTTPMessageCopyAllHeaderFields</span>(<span class="built_in">CFHTTPMessageRef</span> message);</span><br><span class="line"><span class="comment">//设置消息头</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFHTTPMessageSetHeaderFieldValue</span>(<span class="built_in">CFHTTPMessageRef</span> message, <span class="built_in">CFStringRef</span> headerField, <span class="built_in">CFStringRef</span> __<span class="keyword">nullable</span> value);</span><br><span class="line"><span class="comment">//向空消息中追加序列化的数据</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPMessageAppendBytes</span>(<span class="built_in">CFHTTPMessageRef</span> message, <span class="keyword">const</span> <span class="built_in">UInt8</span> *newBytes, <span class="built_in">CFIndex</span> numBytes);</span><br><span class="line"><span class="comment">//返回消息头数据是否准备完成</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPMessageIsHeaderComplete</span>(<span class="built_in">CFHTTPMessageRef</span> message);</span><br><span class="line"><span class="comment">//将一个消息对象序列化成数据</span></span><br><span class="line"><span class="built_in">CFDataRef</span> <span class="built_in">CFHTTPMessageCopySerializedMessage</span>(<span class="built_in">CFHTTPMessageRef</span> message);</span><br><span class="line"><span class="comment">/*=================下面这些方法针对于请求类型的消息=====================*/</span></span><br><span class="line"><span class="comment">//获取消息中的url</span></span><br><span class="line"><span class="built_in">CFURLRef</span> <span class="built_in">CFHTTPMessageCopyRequestURL</span>(<span class="built_in">CFHTTPMessageRef</span> request);</span><br><span class="line"><span class="comment">//获取消息的请求方法</span></span><br><span class="line"><span class="built_in">CFStringRef</span> <span class="built_in">CFHTTPMessageCopyRequestMethod</span>(<span class="built_in">CFHTTPMessageRef</span> request);</span><br><span class="line"><span class="comment">//添加认证信息</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPMessageAddAuthentication</span>(<span class="built_in">CFHTTPMessageRef</span>   request,<span class="built_in">CFHTTPMessageRef</span>   __<span class="keyword">nullable</span> authenticationFailureResponse,<span class="built_in">CFStringRef</span>        username,<span class="built_in">CFStringRef</span>        password,<span class="built_in">CFStringRef</span>        __<span class="keyword">nullable</span> authenticationScheme,Boolean            forProxy);</span><br><span class="line"><span class="comment">/*=================下面这些方法针对于绘制类型的消息=====================*/</span></span><br><span class="line"><span class="comment">//获取回执状态码</span></span><br><span class="line"><span class="built_in">CFIndex</span> <span class="built_in">CFHTTPMessageGetResponseStatusCode</span>(<span class="built_in">CFHTTPMessageRef</span> response);</span><br><span class="line"><span class="comment">//获取回执状态行信息</span></span><br><span class="line"><span class="built_in">CFStringRef</span> <span class="built_in">CFHTTPMessageCopyResponseStatusLine</span>(<span class="built_in">CFHTTPMessageRef</span> response);</span><br></pre></td></tr></table></figure>
<h3 id="四、进行请求与回调处理"><a href="#四、进行请求与回调处理" class="headerlink" title="四、进行请求与回调处理"></a>四、进行请求与回调处理</h3><pre><code>CFHTTPMessageRef的主要用途是构建出HTTP的请求或回执对象，请求的相关发起与回调方法都封装在CFHTTPStream.h这个头文件中，解析如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过一个HTTP请求创建一个读取流对象</span></span><br><span class="line"><span class="built_in">CFReadStreamRef</span> <span class="built_in">CFReadStreamCreateForHTTPRequest</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="built_in">CFHTTPMessageRef</span> request);</span><br><span class="line"><span class="comment">//通过一个HTTP请求创建读取流对象 但是请求的body会被忽略 取requestBody作为请求体</span></span><br><span class="line"><span class="built_in">CFReadStreamRef</span> <span class="built_in">CFReadStreamCreateForStreamedHTTPRequest</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="built_in">CFHTTPMessageRef</span> requestHeaders, <span class="built_in">CFReadStreamRef</span> requestBody);</span><br><span class="line"><span class="comment">//设置读取流是否自动重定向</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFHTTPReadStreamSetRedirectsAutomatically</span>(<span class="built_in">CFReadStreamRef</span> httpStream, Boolean shouldAutoRedirect);</span><br></pre></td></tr></table></figure>
<h3 id="五、关于请求的证书验证"><a href="#五、关于请求的证书验证" class="headerlink" title="五、关于请求的证书验证"></a>五、关于请求的证书验证</h3><pre><code>有时，客户端在向服务端进行请求时收到状态为401的回执，这时往往表明需要客户端提供用户凭证，在CFNetWork框架中，用户凭证与证书验证相关方法封装在CFHTTPAuthentication.h头文件中。解析如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取CFHTTPAuthentication类ID</span></span><br><span class="line"><span class="built_in">CFTypeID</span> <span class="built_in">CFHTTPAuthenticationGetTypeID</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过一个401或者407的请求回执创建一个 用户认证对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CFHTTPAuthenticationRef</span> <span class="built_in">CFHTTPAuthenticationCreateFromResponse</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="built_in">CFHTTPMessageRef</span> response);</span><br><span class="line"><span class="comment">//获取一个用户认证对象是否有效</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPAuthenticationIsValid</span>(<span class="built_in">CFHTTPAuthenticationRef</span> auth, <span class="built_in">CFStreamError</span> * __<span class="keyword">nullable</span> error);</span><br><span class="line"><span class="comment">//获取某个用户认证对象是否是某个请求的</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPAuthenticationAppliesToRequest</span>(<span class="built_in">CFHTTPAuthenticationRef</span> auth, <span class="built_in">CFHTTPMessageRef</span> request);</span><br><span class="line"><span class="comment">//获取某个用户认证是否必须有序进行</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPAuthenticationRequiresOrderedRequests</span>(<span class="built_in">CFHTTPAuthenticationRef</span> auth);</span><br><span class="line"><span class="comment">//使用给定的用户名和密码执行证书验证方法</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPMessageApplyCredentials</span>(<span class="built_in">CFHTTPMessageRef</span> request,<span class="built_in">CFHTTPAuthenticationRef</span> auth,<span class="built_in">CFStringRef</span>  __<span class="keyword">nullable</span> username,<span class="built_in">CFStringRef</span>  __<span class="keyword">nullable</span>    password,<span class="built_in">CFStreamError</span> *   __<span class="keyword">nullable</span>    error);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此方法和上面方法作用一致 不同的是使用字典来进行用户名和密码的设置 字段的键如下：</span></span><br><span class="line"><span class="comment">kCFHTTPAuthenticationUsername 用户名键</span></span><br><span class="line"><span class="comment">kCFHTTPAuthenticationPassword 密码键</span></span><br><span class="line"><span class="comment">kCFHTTPAuthenticationAccountDomain 账户域</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPMessageApplyCredentialDictionary</span>(<span class="built_in">CFHTTPMessageRef</span> request,<span class="built_in">CFHTTPAuthenticationRef</span>   auth,<span class="built_in">CFDictionaryRef</span> dict,<span class="built_in">CFStreamError</span> * __<span class="keyword">nullable</span>  error);</span><br><span class="line"><span class="comment">//返回用户凭证的账户域</span></span><br><span class="line"><span class="built_in">CFStringRef</span> <span class="built_in">CFHTTPAuthenticationCopyRealm</span>(<span class="built_in">CFHTTPAuthenticationRef</span> auth);</span><br><span class="line"><span class="comment">//返回一组账户域</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> <span class="built_in">CFHTTPAuthenticationCopyDomains</span>(<span class="built_in">CFHTTPAuthenticationRef</span> auth);</span><br><span class="line"><span class="comment">//返回用户凭证的验证方法</span></span><br><span class="line"><span class="built_in">CFStringRef</span> <span class="built_in">CFHTTPAuthenticationCopyMethod</span>(<span class="built_in">CFHTTPAuthenticationRef</span> auth);</span><br><span class="line"><span class="comment">//获取用户凭证验证是否需要用户名和密码</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPAuthenticationRequiresUserNameAndPassword</span>(<span class="built_in">CFHTTPAuthenticationRef</span> auth);</span><br><span class="line"><span class="comment">//获取是否需要账户域</span></span><br><span class="line">Boolean <span class="built_in">CFHTTPAuthenticationRequiresAccountDomain</span>(<span class="built_in">CFHTTPAuthenticationRef</span> auth);</span><br></pre></td></tr></table></figure>
<h3 id="六、进行FTP协议的数据交换"><a href="#六、进行FTP协议的数据交换" class="headerlink" title="六、进行FTP协议的数据交换"></a>六、进行FTP协议的数据交换</h3><pre><code>CFNetWork框架也支持与FTP协议的服务端进行数据交互，方法解析如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据URL创建FTP读取流对象 用来进行文件下载</span></span><br><span class="line"><span class="built_in">CFReadStreamRef</span> <span class="built_in">CFReadStreamCreateWithFTPURL</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="built_in">CFURLRef</span> ftpURL);</span><br><span class="line"><span class="comment">//解析文件或目录的格式化数据</span></span><br><span class="line"><span class="built_in">CFIndex</span> <span class="built_in">CFFTPCreateParsedResourceListing</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="keyword">const</span> <span class="built_in">UInt8</span> *buffer, <span class="built_in">CFIndex</span> bufferLength, <span class="built_in">CFDictionaryRef</span> __<span class="keyword">nullable</span> *  __<span class="keyword">nullable</span> parsed);</span><br><span class="line"><span class="comment">//根据URL创建一个FTP写入流对象 用来进行文件上传</span></span><br><span class="line"><span class="built_in">CFWriteStreamRef</span> <span class="built_in">CFWriteStreamCreateWithFTPURL</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="built_in">CFURLRef</span> ftpURL);</span><br></pre></td></tr></table></figure>
<p>对于FTP写入和读取流来说，可以使用CFReadStreamSetProperty()函数或者CFWriteStreamSetProperty()函数来进行属性的设置，可设置的属性列举如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">kCFStreamPropertyFTPUserName <span class="comment">//设置用户名</span></span><br><span class="line">kCFStreamPropertyFTPPassword <span class="comment">//设置密码</span></span><br><span class="line">kCFStreamPropertyFTPUsePassiveMode <span class="comment">//布尔值  设置是否被动模式</span></span><br><span class="line">kCFStreamPropertyFTPResourceSize  <span class="comment">//资源大小</span></span><br><span class="line">kCFStreamPropertyFTPFileTransferOffset <span class="comment">//记录文件位置 用来断点续传</span></span><br><span class="line">kCFStreamPropertyFTPAttemptPersistentConnection <span class="comment">//是否重用连接</span></span><br><span class="line">kCFStreamPropertyFTPProxy  <span class="comment">//设置代理字典</span></span><br><span class="line">kCFStreamPropertyFTPFetchResourceInfo <span class="comment">//资源详情字典</span></span><br><span class="line"><span class="comment">//下面为代理字典中可以定义的键</span></span><br><span class="line">kCFStreamPropertyFTPProxyHost  <span class="comment">//代理主机</span></span><br><span class="line">kCFStreamPropertyFTPProxyPort  <span class="comment">//代理端口</span></span><br><span class="line">kCFStreamPropertyFTPProxyUser  <span class="comment">//代理用户名</span></span><br><span class="line">kCFStreamPropertyFTPProxyPassword <span class="comment">//代理密码</span></span><br><span class="line"><span class="comment">//下面是资源详情字典中可以定义的键</span></span><br><span class="line">kCFFTPResourceMode  <span class="comment">//资源模式</span></span><br><span class="line">kCFFTPResourceName <span class="comment">//资源名</span></span><br><span class="line">kCFFTPResourceOwne <span class="comment">//资源所有者</span></span><br><span class="line">kCFFTPResourceGroup <span class="comment">//资源组</span></span><br><span class="line">kCFFTPResourceLink  <span class="comment">//资源链接</span></span><br><span class="line">kCFFTPResourceSize  <span class="comment">//资源尺寸</span></span><br><span class="line">kCFFTPResourceType  <span class="comment">//资源类型</span></span><br><span class="line">kCFFTPResourceModDate <span class="comment">//修改时间</span></span><br></pre></td></tr></table></figure>
<h3 id="七、主机地址相关操作"><a href="#七、主机地址相关操作" class="headerlink" title="七、主机地址相关操作"></a>七、主机地址相关操作</h3><pre><code>CFNetWork中也封装了与主机地址域名相关的操作方法，例如，我们可以通过域名进行DNS解析出IP地址，示例代码如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="built_in">CFStringRef</span> hostString = <span class="built_in">CFSTR</span>(<span class="string">"www.baidu.com"</span>);</span><br><span class="line"><span class="built_in">CFHostRef</span> host = <span class="built_in">CFHostCreateWithName</span>(<span class="built_in">CFAllocatorGetDefault</span>(), hostString);</span><br><span class="line"><span class="built_in">CFHostStartInfoResolution</span>(host, kCFHostAddresses, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CFArrayRef</span> addresses = <span class="built_in">CFHostGetAddressing</span>(host, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">CFArrayGetCount</span>(addresses); i++) &#123;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in * ip;</span><br><span class="line">    ip = (<span class="keyword">struct</span> sockaddr_in *)<span class="built_in">CFDataGetBytePtr</span>(<span class="built_in">CFArrayGetValueAtIndex</span>(addresses, i));</span><br><span class="line">    printf(<span class="string">"%s\n"</span>,inet_ntoa(ip-&gt;sin_addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CFHostRef对象操作相关方法解析如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类型ID</span></span><br><span class="line"><span class="built_in">CFTypeID</span> <span class="built_in">CFHostGetTypeID</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="comment">//根据域名创建CFHostRef对象</span></span><br><span class="line"><span class="built_in">CFHostRef</span> <span class="built_in">CFHostCreateWithName</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> allocator, <span class="built_in">CFStringRef</span> hostname);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据地址创建CFHostRef对象</span></span><br><span class="line"><span class="comment">addr参数为sockaddr结构体数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">CFHostRef</span> <span class="built_in">CFHostCreateWithAddress</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> allocator, <span class="built_in">CFDataRef</span> addr);</span><br><span class="line"><span class="comment">//CFHostRef对象的复制</span></span><br><span class="line"><span class="built_in">CFHostRef</span> <span class="built_in">CFHostCreateCopy</span>(<span class="built_in">CFAllocatorRef</span> __<span class="keyword">nullable</span> alloc, <span class="built_in">CFHostRef</span> host);</span><br><span class="line"><span class="comment">//对指定主机进行信息预查找 返回值标明是否查找成功</span></span><br><span class="line">Boolean <span class="built_in">CFHostStartInfoResolution</span>(<span class="built_in">CFHostRef</span> theHost, <span class="built_in">CFHostInfoType</span> info, <span class="built_in">CFStreamError</span> * __<span class="keyword">nullable</span> error);</span><br><span class="line"><span class="comment">//获取主机的地址列表 数组中为sockaddr结构体数据</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> <span class="built_in">CFHostGetAddressing</span>(<span class="built_in">CFHostRef</span> theHost, Boolean * __<span class="keyword">nullable</span> hasBeenResolved);</span><br><span class="line"><span class="comment">//获取主机名列表</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> <span class="built_in">CFHostGetNames</span>(<span class="built_in">CFHostRef</span> theHost, Boolean * __<span class="keyword">nullable</span> hasBeenResolved);</span><br><span class="line"><span class="comment">//获取主机可达性信息</span></span><br><span class="line"><span class="built_in">CFDataRef</span> <span class="built_in">CFHostGetReachability</span>(<span class="built_in">CFHostRef</span> theHost, Boolean * __<span class="keyword">nullable</span> hasBeenResolved);</span><br><span class="line"><span class="comment">//取消未完成的解析</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析类型枚举</span></span><br><span class="line"><span class="comment">typedef CF_ENUM(int, CFHostInfoType) &#123;</span></span><br><span class="line"><span class="comment">  //地址</span></span><br><span class="line"><span class="comment">  kCFHostAddresses              = 0,</span></span><br><span class="line"><span class="comment">  //主机名</span></span><br><span class="line"><span class="comment">  kCFHostNames                  = 1,</span></span><br><span class="line"><span class="comment">  //可达性信息</span></span><br><span class="line"><span class="comment">  kCFHostReachability           = 2</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFHostCancelInfoResolution</span>(<span class="built_in">CFHostRef</span> theHost, <span class="built_in">CFHostInfoType</span> info);</span><br><span class="line"><span class="comment">//设置客户端回调</span></span><br><span class="line">Boolean <span class="built_in">CFHostSetClient</span>(<span class="built_in">CFHostRef</span> theHost, <span class="built_in">CFHostClientCallBack</span> __<span class="keyword">nullable</span> clientCB, <span class="built_in">CFHostClientContext</span> * __<span class="keyword">nullable</span> clientContext);</span><br><span class="line"><span class="comment">//注册进Runloop</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFHostScheduleWithRunLoop</span>(<span class="built_in">CFHostRef</span> theHost, <span class="built_in">CFRunLoopRef</span> runLoop, <span class="built_in">CFStringRef</span> runLoopMode);</span><br><span class="line"><span class="comment">//从Runloop中注销</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFHostUnscheduleFromRunLoop</span>(<span class="built_in">CFHostRef</span> theHost, <span class="built_in">CFRunLoopRef</span> runLoop, <span class="built_in">CFStringRef</span> runLoopMode);</span><br></pre></td></tr></table></figure>
<h3 id="八、后续"><a href="#八、后续" class="headerlink" title="八、后续"></a>八、后续</h3><pre><code>上面介绍的内容更多还是关于使用CFNetWork框架进行HTTP或FTP请求的相关方法，其实CFNetWork框架中还提供了复杂的Bonjour服务功能，其与CFNetService相关，这部分内容后面有时间再进行整理总结吧。
</code></pre><blockquote>
<p>欢迎交流  珲少 QQ 316045346</p>
</blockquote>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © 微信：15137348047
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2018/12/22/386iOS开发之CoreImage框架使用/" class="pre-post btn btn-default" title='iOS开发之CoreImage框架使用'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">iOS开发之CoreImage框架使用</span>
        </a>
    
    
        <a href="/2018/10/16/384 GCC编译过程记/" class="next-post btn btn-default" title='GCC编译过程记'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">GCC编译过程记</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
<div id="lv-container" data-id="city" data-uid="MTAyMC8zNzY0Ny8xNDE3OA==">
  <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];
         if (typeof LivereTower === 'function') { return; }
         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;
         e.parentNode.insertBefore(j, e);
     })(document, 'script');
  </script>
</div>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS开发之CFNetwork框架使用"><span class="toc-text">iOS开发之CFNetwork框架使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、引言"><span class="toc-text">一、引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、使用CFNetwork进行简单的网络请求"><span class="toc-text">二、使用CFNetwork进行简单的网络请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、CFHTTPMessageRef详解"><span class="toc-text">三、CFHTTPMessageRef详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、进行请求与回调处理"><span class="toc-text">四、进行请求与回调处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、关于请求的证书验证"><span class="toc-text">五、关于请求的证书验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、进行FTP协议的数据交换"><span class="toc-text">六、进行FTP协议的数据交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、主机地址相关操作"><span class="toc-text">七、主机地址相关操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#八、后续"><span class="toc-text">八、后续</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2018
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>