{"meta":{"title":"珲少的技术博客","subtitle":"专注技术 有趣生活","description":"珲少的技术博客","author":"珲少","url":"http://huishao.cc"},"pages":[],"posts":[{"title":"iOS NSTimer 定时器用法总结","slug":"10iOS NSTimer 定时器用法总结","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:37:50.677Z","comments":true,"path":"2015/04/10/10iOS NSTimer 定时器用法总结/","link":"","permalink":"http://huishao.cc/2015/04/10/10iOS NSTimer 定时器用法总结/","excerpt":"","text":"NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下： 一、初始化方法：有五种初始化方法，分别是 + (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个Invocation对象 NSInvocation * invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(init)]]; [invo setTarget:self]; [invo setSelector:@selector(myLog)]; NSTimer * timer = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES]; //加入主循环池中 [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; //开始循环 [timer fire];&#125; + (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 1 NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES]; + (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:NO] + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:@&quot;123&quot; repeats:YES] - (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep 12 NSTimer * timer = [[NSTimer alloc]initWithFireDate:[NSDate distantPast] interval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; 注意：这五种初始化方法的异同： 1、参数repeats是指定是否循环执行，YES将循环，NO将只执行一次。 2、timerWithTimeInterval这两个类方法创建出来的对象如果不用 addTimer: forMode方法手动加入主循环池中，将不会循环执行。并且如果不手动调用fair，则定时器不会启动。 3、scheduledTimerWithTimeInterval这两个方法不需要手动调用fair，会自动执行，并且自动加入主循环池。 4、init方法需要手动加入循环池，它会在设定的启动时间启动。 二、成员变量 @property (copy) NSDate *fireDate; 这是设置定时器的启动时间，常用来管理定时器的启动与停止 1234 //启动定时器 timer.fireDate = [NSDate distantPast]; //停止定时器 timer.fireDate = [NSDate distantFuture]; @property (readonly) NSTimeInterval timeInterval; 这个是一个只读属性，获取定时器调用间隔时间。 @property NSTimeInterval tolerance; 这是7.0之后新增的一个属性，因为NSTimer并不完全精准，通过这个值设置误差范围。 @property (readonly, getter=isValid) BOOL valid; 获取定时器是否有效 @property (readonly, retain) id userInfo; 获取参数信息 三、关于内存释放 如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。所以我们需要这样做： 123456789101112131415161718-(void)dealloc&#123; NSLog(@&quot;dealloc:%@&quot;,[self class]);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; timer= [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(btn) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;-(void)btn&#123; if (timer.isValid) &#123; [timer invalidate]; &#125; timer=nil; [self dismissViewControllerAnimated:YES completion:nil];&#125; 在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSTimer","slug":"NSTimer","permalink":"http://huishao.cc/tags/NSTimer/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSInvocation应用与理解","slug":"09iOS NSInvocation应用与理解","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:36:47.104Z","comments":true,"path":"2015/04/10/09iOS NSInvocation应用与理解/","link":"","permalink":"http://huishao.cc/2015/04/10/09iOS NSInvocation应用与理解/","excerpt":"","text":"IOS中有一个类型是SEL，它的作用很相似与函数指针，通过performSelector:withObject:函数可以直接调用这个消息。但是perform相关的这些函数，有一个局限性，其参数数量不能超过2个，否则要做很麻烦的处理，与之相对，NSInvocation也是一种消息调用的方法，并且它的参数没有限制。这两种直接调用对象消息的方法，在IOS4.0之后，大多被block结构所取代，只有在很老的兼容性系统中才会使用，简单用法总结如下： 一、初始化与调用 在官方文档中有明确说明，NSInvocation对象只能使用其类方法来初始化，不可使用alloc/init方法。它执行调用之前，需要设置两个方法：setSelector: 和setArgument:atIndex： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog); //创建一个函数签名，这个签名可以是任意的,但需要注意，签名函数的参数数量要和调用的一致。 NSMethodSignature * sig = [NSNumber instanceMethodSignatureForSelector:@selector(init)]; //通过签名初始化 NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; //设置target [invocatin setTarget:self]; //设置selecteor [invocatin setSelector:myMethod]; //消息调用 [invocatin invoke]; &#125;-(void)myLog&#123; NSLog(@&quot;MyLog&quot;);&#125; 注意：签名函数的参数数量要和调用函数的一致。测试后发现，当签名函数参数数量大于被调函数时，也是没有问题的。 调用多参数的方法，我们可以这样写： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 注意：1、这里设置参数的Index 需要从2开始，因为前两个被selector和target占用。下面这样写也没有任何问题： 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); SEL myMethod2 = @selector(myLog); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; ViewController * view = self; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 2、这里的传参方式必须是传递参数地址。 二、NSInvocation的返回值 NSInvocation对象，是可以有返回值的，然而这个返回值，并不是其所调用函数的返回值，需要我们手动设置： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; ViewController * view = self; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; //我们将c的值设置为返回值 [invocatin setReturnValue:&amp;c]; int d; //取这个返回值 [invocatin getReturnValue:&amp;d]; NSLog(@&quot;%d&quot;,d); &#125;-(int)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c); return a+b+c;&#125; 注意：这里的操作传递的都是地址。如果是OC对象，也是取地址。 三、关于内存 可以注意到- (void)retainArguments;这个方法，它会将传入的所有参数以及target都retain一遍。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSInvocation","slug":"NSInvocation","permalink":"http://huishao.cc/tags/NSInvocation/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS 中block结构的简单用法","slug":"08iOS 中block结构的简单用法","date":"2015-04-08T16:00:00.000Z","updated":"2021-05-31T03:35:27.069Z","comments":true,"path":"2015/04/09/08iOS 中block结构的简单用法/","link":"","permalink":"http://huishao.cc/2015/04/09/08iOS 中block结构的简单用法/","excerpt":"","text":"自从block出现之后，很多API都开始采用这样的结构，由此可见，block确实有许多优势存在，这里将一些简单用法总结如下： 一、如何声明一个block变量 我们通过^符号来声明block类型，形式如下： void (^myBlock)(); 其中第一个void是返回值，可以是任意类型，中间括号中^后面的是这个block变量的名字，我把它命名为myBlock，最后一个括号中是参数，如果多参数，可以写成如下样式： int (^myBlock)(int,int); 同样，你也可以给参数起名字： int (^myBlock)(int a,int b); 很多时候，我们需要将我们声明的block类型作为函数的参数，也有两种方式： 1、-(void)func:(int (^)(int a,int b))block； 第二种方式是通过typedef定义一种新的类型，这也是大多数情况下采用的方式： 2、typedef int (^myBlock)(int a,int b) ; -(void)func:(myBlock)block ; 二、如何实现一个block 既然block可以被声明为变量，那么就一定可以实现它，就像其他类型变量的赋值。我自己对block的理解为它是一断代码块，所以给它赋值赋便是一段代码段： 1234567891011121314151617typedef int (^myBlock)(int,int) ;@interface ViewController ()&#123; myBlock block1;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. block1 =^(int a, int b)&#123; return a+b; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 这里打印的结果是2，从这里可以发现block和函数的功能很像。 注意：1、在上面的代码里 block1是一个对象，如果直接打印将打印对象地址 2、block()，加上后面的括号才是执行block语句块 三、block中访问对象的微妙关系 1、如果你在一个block块中仅仅访问对象，而不是对他进行修改操作，是没有任何问题的： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; int count= tem+1; return count; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 而如果我在block块中直接修改，编译器会报错： 1234 block1 = ^(int a,int b)&#123; tem+=1; return tem+1; &#125;; 为什么会出现这样的情况，根据猜测，可能是block内部将访问的变量都备份了一份，如果我们在内部修改，外部的变量并不会被修改，我们可以通过打印变量的地址来证明这一点： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; int tem=2; NSLog(@&quot;%p&quot;,&amp;tem); block1 = ^(int a,int b)&#123; NSLog(@&quot;%p&quot;,&amp;tem); return tem+1; &#125;; NSLog(@&quot;%d&quot;,block1(1,1)); &#125; 打印结果如下： 可以看出，变量的地址已经改变。 2、__block 做了什么 为了可以在block块中访问并修改外部变量，我们常会把变量声明成__block类型，通过上面的原理，可以发现，其实这个关键字只做了一件事，如果在block中访问没有添加这个关键字的变量，会访问到block自己拷贝的那一份变量，它是在block创建的时候创建的，而访问加了这个关键字的变量，则会访问这个变量的地址所对应的变量。我们可以通过代码来证明： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; tem=4; NSLog(@&quot;%d&quot;,block1(1,1)); block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; __block int tem2=2; tem2=4; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 结果： 3、一点点扩展 由此，我们可以理解，如果block中操作的对象是指针，那么直接可以进行修改，这包括OC对象，如果不是，则需要用__block关键字修饰。 4、关于引用计数 在block中访问的对象，会默认retain： 1234567 UIImage * number; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 结果如下： 而添加__block的对象不会被retain; 注意：如果我们访问类的成员变量，或者通过类方法来访问对象，那么这些对象不会被retain，而类对象会被return，最常见的时self: 1234567891011121314151617181920212223242526272829303132typedef void(^myBlock)(int,int) ;@interface ViewController2 ()&#123; myBlock block1; __block UIImage * number; &#125;@end@implementation ViewController2-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number));&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; //block1(1,1); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 打印结果： 可以看出，UIImage对象没有被retain,而self也将循环引用，造成内存泄露。解决方法如下： 1234567 number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIImage * im = number; block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)im)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 打印结果： 注意：根据这个机制，如果我们将block用来传值，在block不用时，务必要置为nil,而在实现block的方法里，务必要释放;我们通过代码来解释： 首先，创建三个ViewController，为ViewController1，ViewController2，ViewController3； 1、在ViewController1中创建一个按钮，跳转ViewController2 2、在ViewController2中： 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController2.h&quot;#import &quot;ViewController3.h&quot;@interface ViewController2 ()&#123; UIButton * im;&#125;@end@implementation ViewController3-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(300, 300, 100, 100); btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; im = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; im.backgroundColor=[UIColor blackColor]; [im addTarget:self action:@selector(rele) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:im];&#125;-(void)rele&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController3 alloc]init]; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 3、在ViewController3中： 12345678910111213141516171819202122#import &quot;ViewController3.h&quot;void (^myBlock)();@implementation ViewController3-(void)setBlock:(void(^)())block&#123; myBlock = [block copy];&#125;-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; myBlock(); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 通过打印信息，我们会发现，ViewController2不被释放，原因是其成员变量im被block中retain没有释放，我们这样做： 1234567891011121314151617@interface ViewController2 ()&#123; UIButton * im; ViewController3 * tem;&#125;-(void)rele&#123; [tem setBlock:nil]; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController2 alloc]init]; tem=con; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 这样就解决了内存问题。 四、关于block的作用域 应避免将花括号中的block用于外面，如果需要，你可以将这个block声明为全局的。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"Block","slug":"Block","permalink":"http://huishao.cc/tags/Block/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中使用NSAttributedString灵活创建标签","slug":"07iOS中使用NSAttributedString灵活创建标签","date":"2015-04-07T16:00:00.000Z","updated":"2021-05-31T03:33:47.188Z","comments":true,"path":"2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","link":"","permalink":"http://huishao.cc/2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","excerpt":"","text":"灵活使用NSAttributedString可以更轻松的创建出内容复杂的标签。需要注意一点：如果一个label设置了这个属性，那它其他的设置都将失效。 首先，我们初始化一个NSMutableAttributedString对象。 12345678//通过字符串初始化//- (instancetype)initWithString:(NSString *)str;//通过字符串和属性字典直接初始化//- (instancetype)initWithString:(NSString *)str attributes:(NSDictionary *)attrs;//通过自身对象初始化//- (instancetype)initWithAttributedString:(NSAttributedString *)attrStr; NSMutableAttributedString * attribute = [[NSMutableAttributedString alloc]initWithString:@&quot;123!@#你好么QWE&quot;]; 可以通过下面两个函数对attrebute字符串进行设置与修改 123456//可以替换字符- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;//属性设置- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;//设置一定范围内字符属性- (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; 字典的键值对应如下： 123456789101112131415161718//kCTFontAttributeName 这个键是字体的名称 必须传入CTFont对象//kCTKernAttributeName 这个键设置字体间距 传入必须是数字对象 默认为0//kCTLigatureAttributeName 这个键设置连字方式 必须传入CFNumber对象//kCTParagraphStyleAttributeName 段落对其方式//kCTForegroundColorAttributeName 字体颜色 必须传入CGColor对象//kCTStrokeWidthAttributeName 笔画宽度 必须是CFNumber对象//kCTStrokeColorAttributeName 笔画颜色//kCTSuperscriptAttributeName 控制垂直文本定位 CFNumber对象//kCTUnderlineColorAttributeName 下划线颜色[attribute addAttribute:(NSString*)kCTKernAttributeName value:@5 range:NSMakeRange(0, 5)];[attribute addAttribute:(NSString *)kCTFontAttributeName value:(id)CFBridgingRelease(CTFontCreateWithName((CFStringRef)[UIFont boldSystemFontOfSize:14].fontName, 14, NULL)) range:NSMakeRange(0, 4)]; [attribute addAttribute:(NSString *)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; 通过测试，发现上面有些键值并没有作用，可以替换下面的方法，效果相同，不同的地方在于其传值的类型不同，下面的方法更加方便（使用UIFont UIColor NSString 和一些系统枚举） 1234567891011121314151617181920 NSParagraphStyleAttributeNameNSForegroundColorAttributeNameNSBackgroundColorAttributeNameNSLigatureAttributeNameNSKernAttributeNameNSStrikethroughStyleAttributeNameNSUnderlineStyleAttributeNameNSStrokeColorAttributeName NSStrokeWidthAttributeName NSShadowAttributeName NSTextEffectAttributeNameNSAttachmentAttributeName NSLinkAttributeName NSBaselineOffsetAttributeName NSUnderlineColorAttributeNameNSStrikethroughColorAttributeNameNSObliquenessAttributeName NSExpansionAttributeName NSWritingDirectionAttributeNameNSVerticalGlyphFormAttributeName 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://huishao.cc/tags/NSAttributedString/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS6中横屏的处理方法","slug":"05iOS6中横屏的处理方法","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:33:03.710Z","comments":true,"path":"2015/04/07/05iOS6中横屏的处理方法/","link":"","permalink":"http://huishao.cc/2015/04/07/05iOS6中横屏的处理方法/","excerpt":"","text":"IOS6以后，若想在项目中支持横屏，我们首先需要在plist文件中添加支持横屏的设置，否则有些代码设置将会失效。 有来那个方式设置： 1、在pilist的Supported interface orientations 字段中添加 2、在Xcode的设置中勾选 现在我们来看决定屏幕方向的几个函数： 在IOS6之前，我们只需通过一个函数 - (BOOL) shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation { return (toInterfaceOrientation == UIInterfaceOrientationLandscapeRight);} 就可以支持指定控制器的旋转。通过新的文档，我们可以看到： 1234// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);//这个方法在6.0之后被标记为过时的 我们通过下面两个方法来代替： //是否允许屏幕旋转 -(BOOL)shouldAutorotate{ return YES;}//支持的方向- (NSUInteger)supportedInterfaceOrientations { return UIInterfaceOrientationMaskLandscapeRight;}这是个枚举 123456789101112131415typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown=(1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125;; 通过这两个函数，如果我们需要某个控制器强制方向，我们可以设置支持单一的方向，即可达到目的。 注意： 如果你们项目中的RootViewController是导航，你会发现，你在Push出来的视图中添加刚才的代码并没有起作用，原因是导航，并没有进行设置，我们创建一个文件，继承于NavigationController。在里面重写刚才的方法，这么做后，屏幕确实横了过来，并且这个导航push的所有子界面都将横屏，这也不是我们想要的效果。我们想自由的控制每个push出来的界面的屏幕方向，可以在导航里这么做： 1234567-(BOOL)shouldAutorotate&#123; return [self.topViewController shouldAutorotate];&#125;//支持的方向- (NSUInteger)supportedInterfaceOrientations &#123; return [self.topViewController supportedInterfaceOrientations];;&#125; 我们还需要做一些处理，经过我的测试，导航必须在pop后才会重新调用这些函数，所以我的方法是这样做：弹出一个中间控制器后再POP回来 1234567@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController pushViewController:[[ViewController3 alloc]init] animated:YES];&#125; 1234567@implementation ViewController3- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController popViewControllerAnimated:YES];&#125; 这样做，我们就可以自由的控制每个视图控制器的方向了。 同理，如果根视图控制器是tabBar，则我们需要在tabBar中做操作。 如果我们大多是的视图控制器都是一个方向的，只有偶尔的几个会不同，这时候，我们其实可以采取presentationController的方式，然后直接在弹出的控制器中写那两个方法即可。这是最简单的途径了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"横屏","slug":"横屏","permalink":"http://huishao.cc/tags/横屏/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS UILabe及UIFont用法总结","slug":"06iOS UILabe及UIFont用法总结","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:32:56.548Z","comments":true,"path":"2015/04/07/06iOS UILabe及UIFont用法总结/","link":"","permalink":"http://huishao.cc/2015/04/07/06iOS UILabe及UIFont用法总结/","excerpt":"","text":"初始化一个UILabel对象，并初始化大小 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置显示的文字 label.text=@”123”; 和字体相关的一个类，字号大小默认17 @property(nonatomic,retain) UIFont*font; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//7.0之后可用 设置字体风格// NSString *const UIFontTextStyleHeadline; 用于标题的风格// NSString *const UIFontTextStyleSubheadline;用于副标题的风格// NSString *const UIFontTextStyleBody;用于正文的字体// NSString *const UIFontTextStyleFootnote;用于脚注的字体// NSString *const UIFontTextStyleCaption1;用于标准字幕字体// NSString *const UIFontTextStyleCaption2;用于替换字幕字体 label.font=[UIFont preferredFontForTextStyle:UIFontTextStyleCaption2];//说实话，没看出什么太大的差别//设置字体和字体大小+ (UIFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize;//返回所有字体的字体家族名称数组+ (NSArray *)familyNames;//按字体家族名称返回字体名称数组+ (NSArray *)fontNamesForFamilyName:(NSString *)familyName;//设置普通字体字号大小+ (UIFont *)systemFontOfSize:(CGFloat)fontSize;//设置加粗字体字号大小+ (UIFont *)boldSystemFontOfSize:(CGFloat)fontSize;//设置斜体字号大小+ (UIFont *)italicSystemFontOfSize:(CGFloat)fontSize;//一些只读属性//字体家族名称@property(nonatomic,readonly,retain) NSString *familyName;//字体名称@property(nonatomic,readonly,retain) NSString *fontName;//字号大小@property(nonatomic,readonly) CGFloat pointSize;//字体设计模型，表示距离最高点偏移余量@property(nonatomic,readonly) CGFloat ascender;//底部的模型偏移量@property(nonatomic,readonly) CGFloat descender;//字体模型的头高信息@property(nonatomic,readonly) CGFloat capHeight;//字体模型的xHeight信息@property(nonatomic,readonly) CGFloat xHeight;//字体行高@property(nonatomic,readonly) CGFloat lineHeight NS_AVAILABLE_IOS(4_0);//模型主体信息@property(nonatomic,readonly) CGFloat leading;//创建一个新字体与当前字体相同，除了指定的大小- (UIFont *)fontWithSize:(CGFloat)fontSize;//通过描述信息返回字体 7.0后可用+ (UIFont *)fontWithDescriptor:(UIFontDescriptor *)descriptor size:(CGFloat)pointSize NS_AVAILABLE_IOS(7_0);//返回字体的描述信息，7.0后可用- (UIFontDescriptor *)fontDescriptor NS_AVAILABLE_IOS(7_0); 设置字体颜色 label.textColor=[UIColor redColor]; 设置阴影偏移量 label.shadowOffset=CGSizeMake(20, 20); 设置阴影颜色 label.shadowColor=[UIColor blackColor]; 设置对齐模式 label.textAlignment=NSTextAlignmentJustified; 1234567891011enum &#123; //沿左边沿对齐文本 NSTextAlignmentLeft = 0, //中心对齐 NSTextAlignmentCenter = 1, //右边沿对齐 NSTextAlignmentRight = 2, //最后一行自然对齐 NSTextAlignmentJustified = 3, //默认对齐 NSTextAlignmentNatural = 4,&#125;;typedef NSInteger NSTextAlignment; 多行文本设置 label.lineBreakMode=NSLineBreakByCharWrapping; 12345678910111213enum &#123; //文本边缘处理 NSLineBreakByWordWrapping = 0, //提前处理不合适的字符 NSLineBreakByCharWrapping, //简单线性处理 NSLineBreakByClipping, //丢失的开头用省略号表示 NSLineBreakByTruncatingHead, //丢失的文本在末尾显示省略号 NSLineBreakByTruncatingTail, //丢失的文本在中间显示省略号 NSLineBreakByTruncatingMiddle &#125;;typedef NSUInteger NSLineBreakMode 使用attributedText绘制 @property(nonatomic,copy) NSAttributedString *attributedText 设置高亮的字体颜色 label.highlightedTextColor=[UIColor blueColor]; //设置是否高亮 label.highlighted=YES; 用户交互 默认关闭 label.userInteractionEnabled=NO; 是否有效，默认是YES，无效为灰色 label.enabled=NO; 显示的行数，0为无限 @property(nonatomic) NSInteger numberOfLines; 宽度自适应大小 默认是NO @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 字符适应宽度：不赞成使用 @property(nonatomic) BOOL adjustsLetterSpacingToFitWidth 最小适应大小2.0-6.0 @property(nonatomic) CGFloat minimumFontSize 最小适应大小 6.0 之后 @property(nonatomic) CGFloat minimumScaleFactor 垂直方向的调整 @property(nonatomic) UIBaselineAdjustment baselineAdjustment; 1234567typedef enum &#123; //调整文本对应基线位置 UIBaselineAdjustmentAlignBaselines, //调整文本相对其边框的中心 UIBaselineAdjustmentAlignCenters, //调整文本相对于边界的左上角 默认的 UIBaselineAdjustmentNone,&#125; UIBaselineAdjustment; 返回文本绘制矩形 - (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines; 文本绘制函数 - (void)drawTextInRect:(CGRect)rect 文本自动布局参数 @property(nonatomic) CGFloat preferredMaxLayoutWidth 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UILabel","slug":"UILabel","permalink":"http://huishao.cc/tags/UILabel/"},{"name":"UIFont","slug":"UIFont","permalink":"http://huishao.cc/tags/UIFont/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS SEL的理解与使用","slug":"04iOS SEL的理解与使用","date":"2015-04-04T16:00:00.000Z","updated":"2021-05-28T10:11:35.356Z","comments":true,"path":"2015/04/05/04iOS SEL的理解与使用/","link":"","permalink":"http://huishao.cc/2015/04/05/04iOS SEL的理解与使用/","excerpt":"","text":"有很多人，认为block的推广可取代代理设计模式，其实block并不能取代代理，代理的模式可以让代码逻辑性更强，更整洁，也会有更高的可读性和可扩展性。相比之下，我觉得block更多的是取代了选择器@selector。 @selector是什么？我们要首先明白SEL，SEL并不是一种对象类型，我们通过xCode的字体颜色就可以判断出来，它是一个关键字，就像int，long一样，它声明了一种类型：类方法指针。其实就可以理解为一个函数指针。比如，我们生命一个叫myLog的函数指针： 1234567#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end 声明出了这个指针，我们该如何给它传递这个函数呢？有两种方式： 1、在编译时，使用@selector来取得函数 现在，我们应该明白@selector是什么了，它是一个编译标示，我们通过它来取到相应函数。 12345678910111213141516171819@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = @selector(myLogL); //通过performSelector来执行方法 [self performSelector:myLog];//打印 “myLog” &#125;-(void)myLogL&#123; NSLog(@&quot;myLog&quot;);&#125; 2、在运行时，通过NSSelectorFromString方法来取到相应函数： 12345678910111213141516171819202122#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = NSSelectorFromString(@&quot;myLogN&quot;); [self performSelector:myLog]; &#125;-(void)myLogN&#123; NSLog(@&quot;myLog&quot;);&#125; 这两种方式的差别在于，编译时的方法如果没有找到相应函数，xcode会报错，而运行时的方法不会。 至于SEL的应用，我相信最广泛的便是target——action设计模式了。我们来简单模拟一下系统button的工作原理： 我们先创建一个继承于UIButton的类： .h文件： 12345#import &lt;UIKit/UIKit.h&gt;@interface Mybutton : UIButton-(void)addMyTarget:(id)target action:(SEL)action;@end .m文件 1234567891011121314151617#import &quot;Mybutton.h&quot;@implementation Mybutton&#123; SEL _action; id _target;&#125;-(void)addMyTarget:(id)target action:(SEL)action&#123; _target=target; _action=action;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_target performSelector:_action];&#125;@end 在外部： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; Mybutton * btn = [[Mybutton alloc]initWithFrame:CGRectMake(100, 100, 60, 60)]; btn.backgroundColor=[UIColor redColor]; [btn addMyTarget:self action:@selector(click)]; [self.view addSubview:btn];&#125;-(void)click&#123; NSLog(@&quot;点击了btn&quot;);&#125; 当然，如果要调用参数，系统提供的默认参数不超过两个，如果参数很多，一种是我们可以通过字典传参，另一种方法比较复杂，在这里先不讨论。 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"SEL","slug":"SEL","permalink":"http://huishao.cc/tags/SEL/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS事件响应控制","slug":"03iOS事件响应控制","date":"2015-04-03T16:00:00.000Z","updated":"2021-05-28T10:09:54.887Z","comments":true,"path":"2015/04/04/03iOS事件响应控制/","link":"","permalink":"http://huishao.cc/2015/04/04/03iOS事件响应控制/","excerpt":"","text":"以前遇到一个项目，一个UIImageView对象上面有一个UIButton对象，然而项目的需求需要在点击 button的同时，UIImageView也接收到点击事件，在不使用代理和通知方法的前提下，通过事件响应链的原理，我们也可以很便捷的解决这个问题。 在处理这个问题之前，我们应该先清楚IOS的事件响应机制到底是个什么样的原理。 首先，这个事件响应的机制是分为两个部分的。 1、先在视图层级关系中找到应该响应事件的那个视图。 这一步是什么意思，其实很简单，就是找到你所触摸点对应的那个最上层的视图，它的工作原理是这样的：当用户发出事件后，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会取出队列中最前面的事件，发消息给UIWindow，然后UIWindow会对其所有子视图调用hitTest:withEvent:这个方法，这个方法会返回一个UIView的对象，这个方法在执行的时候，它会调用当前视图的pointInside:withEvent:这个方法，如果触摸事件在当前视图范围内，pointInside:withEvent:会返回YES，否则会返回NO；如果返回YES，则会遍历当前视图的所有子视图，统统发送hitTest:withEvent:这个消息，如果返回NO,则hitTest:withEvent:方法返回nil； 上面说起来有些绕，其实就是：hitTest:withEvent:方法会一层一层的向上找，若最上层响应的子视图pointInside:withEvent:返回YES，则返回此子视图，如果所有的都返回nil，则返回当前视图本身self。 例如：我们建两个文件，一个继承于UIButton，一个继承于UIImageView，我们在UIImageView里的代码如下： 12345678910111213141516171819#import &quot;MyImageView.h&quot;@implementation MyImageView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor=[UIColor redColor]; &#125; return self;&#125;//在这里，我们重写了这个方法，让它直接返回自身，而不是继续向下寻找应该响应事件的视图-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;点击了Image&quot;);&#125; 然后将他们创建在一个View上： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; // Do any additional setup after loading the view, typically from a nib.&#125; 我们运行，点击这个Btn，会打印如下的信息： 可以证明，在事件视图寻找中，UIImageView我们重写hitTest:withEvent:方法后，切断了寻找链，如果我们这个做： 123-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return nil;&#125; 你会发现，UIImageView也不再接收事件。2、寻找到应该响应的视图后，会进行消息处理，这个处理的方式是通过消息处理链来做的。如果它自身不能处理消息，会通过nextResponder将消息传递给下一个处理者，默认只要有一个view将消息处理了，这个消息处理传递链将不再传递。 现在，我们把刚才UIimageView里重写的hitTest:withEvent:方法注释掉，给btn添加一个点击方法，同时将用户交互关闭： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; image.userInteractionEnabled=YES; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click&#123; NSLog(@&quot;btn被点击了&quot;);&#125; 这样，我们的UIImageView又可以响应事件了，原因是事件处理传递链向下传递了。 现在，在回到我们刚开始的问题，如何让btn响应的同时imageView也响应，我们这样做： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; image.userInteractionEnabled=YES; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click:(UIButton *)btn&#123; NSLog(@&quot;btn被点击了&quot;); //响应链继续传递 [btn.nextResponder touchesBegan:nil withEvent:nil]; &#125; 结果如下： 虽然最终，我们完成了这个需求，可是我建议你最好不要这么干，因为这样的逻辑是违背现实生活中人们的行为认知的，更重要的是，我们的项目最后也确实改掉了这样的逻辑~~~ 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"事件","slug":"事件","permalink":"http://huishao.cc/tags/事件/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中DES与MD5加密方案","slug":"02MD","date":"2015-04-02T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/03/02MD/","link":"","permalink":"http://huishao.cc/2015/04/03/02MD/","excerpt":"","text":"MD5算法和DES算法是常见的两种加密算法。 MD5：MD5是一种不可逆的加密算法，按我的理解，所谓不可逆，就是不能解密，那么它有什么用的，它的用处大了，大多数的登录功能都会使用到这种算法。后面根据我的项目经验来介绍。 DES：一种使用密钥加密的块算法，所以，使用它加密时，需要一个密钥，加上一些设置和你需要加密的文段。 在IOS中，使用这两种加密算法非常简单，系统的&lt;CommonCrypto/CommonCrypto.h&gt;库给我们提供的边界的接口。在很多移动项目中，安卓平台和IOS平台的后台服务是统一的，比如一个登录功能是这样的流程： 1、客户端向服务端请求密钥，请求的参数是双方约定好的一个MD5加密的字符串。我们可以通过下面的进行第一步加密： 1234567891011121314- (NSString *)MD5Digest&#123; //要进行UTF8的转码 const char* input = [self UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(input, (CC_LONG)strlen(input), result); NSMutableString *digest = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) &#123; [digest appendFormat:@&quot;%02x&quot;, result[i]]; &#125; return digest;&#125; 通过这样的方法，我们可以很容易的得到一串MD5加密字符串，但是一定要和后台约定好，MD5加密的位数是16位还是32位，用上述方法加密出来的时32位，当然他们之间是有联系的，通过下面的方法可以将其转成16为： 1234567+(NSString *)trransFromMD532ToMD516:(NSString *)MD532&#123; NSString * string; for (int i=0; i&lt;24; i++) &#123; string=[MD532 substringWithRange:NSMakeRange(8, 16)]; &#125; return string;&#125; 还有一点需要注意，加密后的大小写也要对应。 2、服务端将得到的MD5串和以约定好的MD5串进行对比，如果一致，可以放行，返回密钥。 3、客户端取到密钥，将密钥再进行一次MD5加密，然后通过DES将要传送的数据加密发给服务器。 这一步至关重要，我们先看DES的加密代码 12345678910111213141516171819202122232425262728293031+(NSString *) encryptUseDES:(NSString *)clearText key:(NSString *)key andiv:(NSString *)iv&#123; //这个iv 是DES加密的初始化向量，可以用和密钥一样的MD5字符 NSData * date = [iv dataUsingEncoding:NSUTF8StringEncoding]; NSString *ciphertext = nil; NSUInteger dataLength = [clearText length]; NSData *textData = [clearText dataUsingEncoding:NSUTF8StringEncoding]; unsigned char buffer[1024]; memset(buffer, 0, sizeof(char)); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,//加密模式 kCCDecrypt 代表解密 kCCAlgorithmDES,//加密方式 kCCOptionPKCS7Padding,//填充算法 [key UTF8String], //密钥字符串 kCCKeySizeDES,//加密位数 [date bytes],//初始化向量 [textData bytes] , dataLength, buffer, 1024, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; NSLog(@&quot;DES加密成功&quot;); NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted]; Byte* bb = (Byte*)[data bytes]; ciphertext = [Base64 parseByteArray2HexString:bb]; &#125;else&#123; NSLog(@&quot;DES加密失败&quot;); &#125; return ciphertext;&#125; 几点注意： （1）加密方式，IOS官方提供的是如下几种 12345678910enum &#123; kCCAlgorithmAES128 = 0, kCCAlgorithmAES = 0, kCCAlgorithmDES, kCCAlgorithm3DES, kCCAlgorithmCAST, kCCAlgorithmRC4, kCCAlgorithmRC2, kCCAlgorithmBlowfish &#125;; （2）填充算法 123456enum &#123; /* options for block ciphers */ kCCOptionPKCS7Padding = 0x0001, kCCOptionECBMode = 0x0002 /* stream ciphers currently have no options */&#125;; 我们可以发现，官方提供的只有这两种，然而JAVA使用的却是 1kCCOptionPKCS7Padding 但是不用担心，在密钥是8位的时候，这两种填充算法加密出来的结果试一模一样的。 4、服务器通过相同的方式，解密出密文，通配安卓端。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"加密","slug":"加密","permalink":"http://huishao.cc/tags/加密/"},{"name":"DES","slug":"DES","permalink":"http://huishao.cc/tags/DES/"},{"name":"MD5","slug":"MD5","permalink":"http://huishao.cc/tags/MD5/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"AFNetWorking用法及缓存处理","slug":"01AF","date":"2015-04-01T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/02/01AF/","link":"","permalink":"http://huishao.cc/2015/04/02/01AF/","excerpt":"","text":"AFNetWorking 在IOS开发中是一个经常会用的第三方开源库，其最好处是维护及时，源码开源。 常用GET与POST请求方法： POST请求： 123456789//初始化一个请求对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; //dic 为参数字典 [manager POST:url parameters:dic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; GET请求： 1234567AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; 这里有一个地方需要注意， 1[AFHTTPRequestOperationManager manager] 这个类方法我们点进源码可以发现： 123+ (instancetype)manager &#123; return [[self alloc] initWithBaseURL:nil];&#125; 这里初始化了一个返回了一个新的对象，并不是单例。 使用这样的下载方法，下载完成后的数据AFNetWorking会帮我们自动解析，但是有时候服务器给的数据并不标准，这时我们需要加上这个设置： manager.responseSerializer = [AFHTTPResponseSerializer serializer]; 这样我们将得到原始的HTTP返回给我们数据。 我们再来探究一下，下载成功后，回调方法里的参数到底是什么东西 1success:^(AFHTTPRequestOperation *operation, id responseObject) 其中，第二个参数 responseObject 是下载下来的data数据，可直接进行JSON等解析。 第一个参数，是个AFHTTPRequestOperation对象，来看源文件 123456789@interface AFHTTPRequestOperation : AFURLConnectionOperation@property (readonly, nonatomic, strong) NSHTTPURLResponse *response;@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;@property (readonly, nonatomic, strong) id responseObject;@end 可以发现，里面有一个成员便是responseObject，同时，AFHTTPRequestOperation是继承于AFURLConnectionOperation,我们在看看AFURLConnectionOperation这个类： 123456789101112131415161718192021222324252627282930313233343536373839@interface AFURLConnectionOperation : NSOperation &lt;NSURLConnectionDelegate, NSURLConnectionDataDelegate, NSSecureCoding, NSCopying&gt;@property (nonatomic, strong) NSSet *runLoopModes;@property (readonly, nonatomic, strong) NSURLRequest *request;@property (readonly, nonatomic, strong) NSURLResponse *response;@property (readonly, nonatomic, strong) NSError *error;@property (readonly, nonatomic, strong) NSData *responseData;@property (readonly, nonatomic, copy) NSString *responseString;@property (readonly, nonatomic, assign) NSStringEncoding responseStringEncoding;@property (nonatomic, assign) BOOL shouldUseCredentialStorage;@property (nonatomic, strong) NSURLCredential *credential;@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;@property (nonatomic, strong) NSInputStream *inputStream;@property (nonatomic, strong) NSOutputStream *outputStream;@property (nonatomic, strong) dispatch_queue_t completionQueue;@property (nonatomic, strong) dispatch_group_t completionGroup;@property (nonatomic, strong) NSDictionary *userInfo;- (instancetype)initWithRequest:(NSURLRequest *)urlRequest NS_DESIGNATED_INITIALIZER;- (void)pause;- (BOOL)isPaused;- (void)resume; 看到这里，就离AFNETWorking封装的源头很近了，里面的成员非常多，其中包含了大部分我们需要的信息，可以通过点语法取到，其中有输入输出流，错误信息，请求到的Data数据，以及请求到的字符串数据 1responseString 我们可以通过 1NSLog ( @&quot;operation: %@&quot; , operation. responseString ); 来打印查看请求到的原始信息。 几点注意： 1.关于崩溃url为nil 大多数这样的原因是url中有特殊字符或者中文字符，AFNETWorking并没有做UTF8的转码，需要： 1url = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 2.添加HttpHead字段的方法 1234 //为这个下载任务HTTP头添加@&quot;User-Agent&quot;字段 [manager.requestSerializer setValue:_scrData forHTTPHeaderField:@&quot;User-Agent&quot;]; //打印头信息 NSLog(@&quot;%@&quot;,manager.requestSerializer.HTTPRequestHeaders); 在下载请求中，经常会请求一些不长变化的数据，如果每次APP启动都进行请求，会消耗许多资源，并且有时候缓存的处理，可以大大改善用户体验。 在AFNETWorking中，并没有提供现成的缓存方案，我们可以通过写文件的方式，自行做缓存。 在下载方法中： 1234567[manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //写缓存 NSString *cachePath = @&quot;你的缓存路径&quot;;// /Library/Caches/MyCache [data writeToFile:cachePath atomically:YES]; succsee(data); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; &#125;]; 然后在每次下载前，进行如下判断： 12345 NSString * cachePath = @&quot;你的缓存路径&quot;; if ([[NSFileManager defaultManager] fileExistsAtPath:cachePath]) &#123; //从本地读缓存文件 NSData *data = [NSData dataWithContentsOfFile:cachePath]; &#125; 有时，我们的下载请求可能是用户的动作触发的，比如一个按钮。我们还应该做一个保护机制的处理， 123456789101112131415//初始化一个下载请求数组NSArray * requestArray=[[NSMutableArray alloc]init];//每次开始下载任务前做如下判断for (NSString * request in requestArray) &#123; if ([url isEqualToString:request]) &#123; return; &#125; &#125; [requestArray addObject:url]; //下载成功或失败后 [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [requestArray removeObject:url] &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [requestArray removeObject:url] &#125;]; 至此，一个比较完成AFNETWorking请求使用流程就完成了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://huishao.cc/tags/网络/"},{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"AFNetWorking","slug":"AFNetWorking","permalink":"http://huishao.cc/tags/AFNetWorking/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]}]}