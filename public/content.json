{"meta":{"title":"珲少的技术博客","subtitle":"专注技术 有趣生活","description":"珲少的技术博客","author":"珲少","url":"http://huishao.cc"},"pages":[],"posts":[{"title":"Swift中的异步编程方式","slug":"479Swift中的异步编程方式","date":"2023-09-21T16:00:00.000Z","updated":"2023-09-22T07:45:32.639Z","comments":true,"path":"2023/09/22/479Swift中的异步编程方式/","link":"","permalink":"http://huishao.cc/2023/09/22/479Swift中的异步编程方式/","excerpt":"","text":"Swift中的异步编程方式引说到异步编程，我们很容易想到的编译回调。无论是需要并行的耗时任务，还是允许串行的简单任务，都通过回调的方式返回结果。回调也是在开发中使用最为广泛的一种异步编程方式。回想一下，通常的网络请求，文件操作等函数都会提供一个回调参数。回调使用起来虽然方便，但其并不利于进行程序流程的控制，仅仅从代码层面看，也很难组织清楚代码的执行顺序和逻辑。 Swift从代码层面提供了结构化的方式来支持异步编程，在Swift5.5中引入了async和await相关的关键字。需要注意，异步和并行本身是两个概念，在Swift中，异步编程模型已经建立在线程调度之上，这也就是说，我们无需关心其中线程的调用，异步的函数本身就是在子线程中并行执行的，线程切换和调度全有语言本身控制。但是Swift不会保证函数会在哪个特定的线程上执行。 异步函数在尝试Swift中提供的异步编程方式外，可以先回想下对于异步并行的场景，之前是如何处理的，例如下面的代码： 1234567891011func test(callback: @escaping (_ success: Bool)-&gt;Void) &#123; DispatchQueue.global().async &#123; print(\"Test任务完成\", Thread.current) callback(true) &#125;&#125;print(\"Begin\", Thread.current)test &#123; success in print(\"EndTest\")&#125;print(\"End\", Thread.current) 其中test函数所执行的任务是手动放在全局队列中执行的，DispatchQueue会自动的进行线程的调度，将其分配到空闲的子线程来执行。打印结果如下： 1234Begin &lt;_NSMainThread: 0x600002310100&gt;&#123;number = 1, name = main&#125;End &lt;_NSMainThread: 0x600002310100&gt;&#123;number = 1, name = main&#125;Test任务完成 &lt;NSThread: 0x600002300300&gt;&#123;number = 5, name = (null)&#125;EndTest 上面的示例代码比较简单，如果有更多的异步任务是依赖test任务的，则闭包回调的写法就会变得非常丑陋，代码难以阅读和维护。 在Swift5.5之后，我们可以使用async关键字来定义异步函数，编程模型会自动分配线程执行，例如： 1234567891011121314func test1() async -&gt; Bool &#123; print(\"ts1\", Thread.current) return true&#125;func test2() async -&gt; Bool &#123; print(\"ts2\", Thread.current) return true&#125;print(\"Begin\", Thread.current)async let a = test1()async let b = test2()print(\"End\", Thread.current) 上面代码中，async关键字将函数标记为异步的，异步函数是一种特殊的函数，其支持在执行过程中被暂时的挂起，即暂停。对于普通的函数来说，会有3种状态： 1. 执行完成 2. 抛出异常 3. 永不返回 异步函数对应的也会有这3种状态，不同的是，当需要做某些等待操作时，其可以暂时的挂起。运行上面的代码，打印效果如下： 1234Begin &lt;_NSMainThread: 0x60000329c3c0&gt;&#123;number = 1, name = main&#125;End &lt;_NSMainThread: 0x60000329c3c0&gt;&#123;number = 1, name = main&#125;ts1 &lt;NSThread: 0x60000328cc40&gt;&#123;number = 4, name = (null)&#125;ts2 &lt;NSThread: 0x600003282d40&gt;&#123;number = 6, name = (null)&#125; 可以看到，test1和test2两个任务是异步执行，且被分配在了不同的线程。需要注意，理论上在异步函数中是不允许使用Thread相关接口的，因为任务的挂起和恢复所在线程都是由系统调度的，逻辑上开发者无需关心线程问题，在Swift6版本中继续这样使用将会报错。 上面演示的代码中，test1和test2任务的执行并不依赖关系，如果test2和执行是需要test1执行结束的，则可以直接使用await关键字来将运行挂起，直到结果返回。例如： 1234567891011121314func test1() async -&gt; Bool &#123; print(\"ts1\", Thread.current) return true&#125;func test2() async -&gt; Bool &#123; print(\"ts2\", Thread.current) return true&#125;print(\"Begin\", Thread.current)let a = await test1()let b = await test2()print(\"End\", Thread.current) 打印效果如下： 1234Begin &lt;_NSMainThread: 0x600002180140&gt;&#123;number = 1, name = main&#125;ts1 &lt;NSThread: 0x600002198100&gt;&#123;number = 6, name = (null)&#125;ts2 &lt;NSThread: 0x6000021accc0&gt;&#123;number = 8, name = (null)&#125;End &lt;_NSMainThread: 0x600002180140&gt;&#123;number = 1, name = main&#125; 使用await关键字标记的地方为程序的挂起点，此时会停止当前线程上代码的执行，并等待异步函数的返回，在程序中，支持await进行挂起的场景包括： 1.异步的方法，属性或函数中。 2.main代码块中。 3.非结构化的子任务代码块中。 通常，我们直接使用await调用异步函数时，当前执行会被挂起，更多时候可以使用如下方式来同时执行多个异步函数，使用await来最终获得结果： 12345678910111213141516func test1() async -&gt; Bool &#123; print(\"ts1\", Thread.current) return true&#125;func test2() async -&gt; Bool &#123; print(\"ts2\", Thread.current) return true&#125;print(\"Begin\", Thread.current)async let a = test1()async let b = test2()let res = await [a ,b]print(res)print(\"End\", Thread.current) 异步序列Swift中的迭代也支持异步返回，通过AsyncIteratorProtocol协议来定义异步的迭代器，示例如下： 12345678910111213141516171819202122232425262728293031323334struct Group: AsyncSequence &#123; typealias Element = Int let limit: Int struct AsyncIterator : AsyncIteratorProtocol &#123; let limit: Int var current = 1 mutating func next() async -&gt; Int? &#123; guard !Task.isCancelled else &#123; return nil &#125; guard current &lt;= limit else &#123; return nil &#125; let result = current current += 1 return result &#125; &#125; func makeAsyncIterator() -&gt; AsyncIterator &#123; return AsyncIterator(limit: limit) &#125;&#125;print(\"Begin\")let group = Group(limit: 10)for await i in group &#123; print(i)&#125;print(\"End\") 在对异步迭代器进行遍历时，需要使用for await in的语法方式。 任务组与任务当有多个异步任务需要执行时，可以将其添加到一个任务组中，当任务组所有任务完成后再进行统一的返回。例如： 1234567891011121314151617let res = await withTaskGroup(of: Bool.self, returning: [Bool].self, body: &#123; taskGroup in taskGroup.addTask &#123; let a = await test1() return a &#125; taskGroup.addTask &#123; let b = await test1() return b &#125; var datas:[Bool] = [] for await data in taskGroup &#123; datas.append(data) &#125; return datas&#125;)print(res) 其中，withTaskGroup方法将创建一个异步的父任务，其中可以添加多个子任务，任务组之间有非常明确的关系，这种编程方式也被称为结构化编程，当然，Swift也提供了非结构化的编程方式，即需要开发者处理任务之间的关系。这非常有用，有时我们需要在非并发的环境中调用异步函数，例如在iOS Application中ViewController的viewDidLoad方法中调用一个异步的函数，此时就需要为其包装一个并发环境，使用Task来创建任务即可： 12345678910111213141516171819202122class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() Task(priority: .background) &#123; await test() self.view.backgroundColor = .red print(\"Finish\") &#125; // 上面task的执行不会影响当前线程 print(\"Continue\") &#125; func test() async &#123; try? await Task.sleep(for: .seconds(10)) &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; print(\"touch\") print(Thread.current) &#125;&#125; 这里再强调一下，所谓执行任务的挂起和线程的阻塞完全不同，当并发环境中当前任务被挂起时，线程资源会被释放去执行其他任务，直到异步任务有结果后，在恢复执行。上面代码中并没有记录Task实例，其实此实例可以控制任务的取消，获取任务返回值等操作，例如： 1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() let task = Task(priority: .background) &#123; await test() self.view.backgroundColor = .red print(\"Finish\") return \"result\" &#125; // 上面task的执行不会影响当前线程 print(\"Continue\") // 取消任务 task.cancel()&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://huishao.cc/categories/Swift/"}],"tags":[],"keywords":[{"name":"Swift","slug":"Swift","permalink":"http://huishao.cc/categories/Swift/"}]},{"title":"Mac部署AIGC图片生成服务——基于stable-diffusion","slug":"478Mac部署AIGC图片生成服务——基于stable-diffusion","date":"2023-07-29T16:00:00.000Z","updated":"2023-07-30T08:49:12.358Z","comments":true,"path":"2023/07/30/478Mac部署AIGC图片生成服务——基于stable-diffusion/","link":"","permalink":"http://huishao.cc/2023/07/30/478Mac部署AIGC图片生成服务——基于stable-diffusion/","excerpt":"","text":"Mac部署AIGC图片生成服务——基于stable-diffusionAIGC即人工智能内容生成，是目前非常火的一个概念。随着各种大模型的问世，通过AI来生成内容的能已经越来越强大。本文将从应用实践方面进行介绍如何在自己的PC电脑上部署一个强大的AI图片生成服务。 关于AI绘图，我相信你一定不太陌生，现在很多宣传图，插图其实都是有AI根据输入的文本信息来进行生成的。stable-diffusion就是这样的一种图片生成AI系统，更重要的是他是开源的，通过它我们可以快速的部署自己的AI图片生成服务。 首先，我们可以从Github上下载一个开源的基于stable-diffusion的网页端应用程序，地址如下： https://github.com/AUTOMATIC1111/stable-diffusion-webui 此服务的运行依赖Python环境，需要在个人电脑上安装Python3.10.6的版本。 之后需要安装Pytorch，Pytorch是一款基于Python的机器学习库，我们需要根据自己电脑的系统来选择安装命令，Pytorch网址如下： https://pytorch.org/get-started/locally/ 如下图所示： 要验证Pytorch是否安装成功也很简单，直接进入Python可交互环境，输入： 1import torch 如果没有任何报错，则说明已经安装成功，如下图所示： 现在我们还需要一个训练好的AI模型来指导生成效果，在如下网站中可以下载到很多训练好的模型： https://civitai.com/ 选择一个感兴趣的模型，下载好的，将模型文件放入工程目录下的models/Stable-diffusion文件夹下面即可。 下面可以尝试运行下此Web项目，在工程目录下执行： 1./webui.sh 执行完成后，在浏览器打开如下地址： http://127.0.0.1:7860/ 页面如下所示： 可以看到，界面上左上角的位置可以选择要使用的模型，支持文字生成图片，图片生成图片，并可以进行图片生成的参数调整。下面可以尝试输入一个prompt来进行图片生成，需要注意，prompt分为两部分，上面输入正向词汇，下面输入负向词汇。 需要注意，如果你无法访问https://civitai.com/网站，也可以尝试在[https://huggingface.co/](https://huggingface.co/)上面找一些训练好的生成图片的模型进行使用。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（22）——将其他三方模型转换成CoreML模型","slug":"477iOS MachineLearning 系列（22）——将其他三方模型转换成CoreML模型","date":"2023-07-25T16:00:00.000Z","updated":"2023-07-26T08:08:46.470Z","comments":true,"path":"2023/07/26/477iOS MachineLearning 系列（22）——将其他三方模型转换成CoreML模型/","link":"","permalink":"http://huishao.cc/2023/07/26/477iOS MachineLearning 系列（22）——将其他三方模型转换成CoreML模型/","excerpt":"","text":"iOS MachineLearning 系列（22）——将其他三方模型转换成CoreML模型本篇文章将是本系列文章的最后一篇。本专题将iOS中有关Machine Learning的相关内容做了整体梳理。下面是专题中的其他文章地址，希望如果你有需要，本专题可以帮助到你。 iOS MachineLearning 系列（1）—— 简介 iOS MachineLearning 系列（2）—— 静态图像分析之矩形识别 iOS MachineLearning 系列（3）—— 静态图像分析之区域识别 iOS MachineLearning 系列（4）—— 静态图像分析之物体识别与分类 iOS MachineLearning 系列（5）—— 视频中的物体运动跟踪 iOS MachineLearning 系列（6）—— 视频中的物体轨迹分析 iOS MachineLearning 系列（7）—— 图片相似度分析 iOS MachineLearning 系列（8）—— 图片热区分析 iOS MachineLearning 系列（9）—— 人物蒙版图生成 iOS MachineLearning 系列（10）—— 自然语言分析之文本拆解 iOS MachineLearning 系列（11）—— 自然语言识别与文本分析 iOS MachineLearning 系列（12）—— 自然语言之词句相似性分析 iOS MachineLearning 系列（13）—— 语音与音频相关的 AI 能力 iOS MachineLearning 系列（14）—— 使用官方模型进行预测 iOS MachineLearning 系列（15）—— 可进行个性化更新的 CoreML 模型 iOS MachineLearning 系列（16）—— 几个常用的图片分类 CoreML 模型 iOS MachineLearning 系列（17）—— 几个常用的对象识别 CoreML 模型 iOS MachineLearning 系列（18）—— PoseNet，DeeplabV3 与 FCRN-DepthPrediction 模型 iOS MachineLearning 系列（19）—— 分析文本中的问题答案 iOS MachineLearning 系列（20）—— 训练生成 CoreML 模型 iOS MachineLearning 系列（21）——CoreML 模型的更多训练模板 专题中，从iOS中Machine Learning相关的API开始介绍，后续扩展到如何使用模型进行预测，如何自定义的训练模型。其实CoreML框架只是Machine Learning领域内的一个框架而已，市面上还有许多流行的用来训练模型的框架。如TensorFlow，PyTorch，LibSVM等。在iOS平台中直接使用这些框架训练完成的模型是比较困难的，但是Core ML Tools提供了一些工具可以方便的将这些模型转换成CoreML模型进行使用，大大降低了模型的训练成本。 此工具官网： https://coremltools.readme.io/docs 首先需要有安装Python运行环境，从Core ML Tools4.1版本开始将不再支持Python2，因此建议直接使用Python3。安装Python会默认安装pip工具，使用如下命令来安装Core ML Tools: 1pip install coremltools coremltools模块并不包含三方库（如TensorFlow），因此安装会比加快。 要使用三方的模型，需要做如下几步操作： 下载三方模型。 将三方模型转换为CoreML格式。 设置CoreML模型的元数据。 进行测试验证。 存储模型，之后在Xcode中进行使用即可。 其中最核心的是模型的转换和元数据的写入。 以TensorFlow的MobileNetV2模型为例，我们下面尝试将其转换成CoreML模型。要转换TensorFlow格式的模型，首先需要安装对应的框架，使用pip来安装如下依赖： 1pip install tensorflow h5py pillow 第一步，下载三方模型，使用tensorflow框架提供的API可以将模型加载的到内存中去，代码如下： 1234567import tensorflow as tf keras_model = tf.keras.applications.MobileNetV2( weights=\"imagenet\", input_shape=(224, 224, 3,), classes=1000,) 其中applications.MobileNetV2是tensorflow框架中提供好的API，在此文档中可以查看这个API的更多用法： https://www.tensorflow.org/api_docs/python/tf/keras/applications/mobilenet_v2/MobileNetV2 同时我们还需要下载一个索引文件，此文件定义了模型所能预测的标签数据，Python代码如下： 123456789import urllib# 模型对应的索引文件地址label_url = 'https://storage.googleapis.com/download.tensorflow.org/data/ImageNetLabels.txt'class_labels = urllib.request.urlopen(label_url).read().splitlines()class_labels = class_labels[1:]assert len(class_labels) == 1000for i, label in enumerate(class_labels): if isinstance(label, bytes): class_labels[i] = label.decode(\"utf8\") 下面进行模型的转换，直接使用coremltools模块提供的API即可，如下： 123456789101112131415import coremltools as ct# 定义输入image_input = ct.ImageType(shape=(1, 224, 224, 3,), bias=[-1,-1,-1], scale=1/127)# 设置可预测的标签classifier_config = ct.ClassifierConfig(class_labels)# 进行模型转换model = ct.convert( keras_model, inputs=[image_input], classifier_config=classifier_config,) 这一步做完成，实际上已经完整了核心的转换部分，我们还需要为model实例追加一些元数据，你应该还记得，将CoreML模型引入Xcode工程后，可以在Xcode中看到模型的简介和使用方法等信息，这些信息就是通过追加元数据写入的。上面实例代码中，默认将其转换成neuralnetwork（神经网络）模式的模型，转换模型时我们也可以选择了添加conver_to参数为mlprogram，这表示将模型转换成CoreML程序模式的。 写入元数据实例代码如下： 123456789101112131415# 写入元数据model.input_description[\"input_1\"] = \"输入要分类的图片\"model.output_description[\"classLabel\"] = \"最可靠的结果\"# 模型作者model.author = \"TensorFlow转换\"# 许可model.license = \"Please see https://github.com/tensorflow/tensorflow for license information, and https://github.com/tensorflow/models/tree/master/research/slim/nets/mobilenet for the original source of the model.\"# 描述model.short_description = \"图片识别模型\"# 版本号model.version = \"1.0\" 最后，就可以进行模型的导出了，代码如下： 12# 存储模型model.save(\"MobileNetV2.mlmodel\") 需要注意，此时导出的模型格式，与前面转换成设置的模型类型有关，转换为mlprogram模式的模型需要导出mlpackage格式的，转换为neuralnetwork的模型需要导出为mlmodel格式的。 完整的Python文件代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import tensorflow as tf # 加载模型keras_model = tf.keras.applications.MobileNetV2( weights=\"imagenet\", input_shape=(224, 224, 3,), classes=1000,)import urllib# 模型对应的索引文件地址label_url = 'https://storage.googleapis.com/download.tensorflow.org/data/ImageNetLabels.txt'class_labels = urllib.request.urlopen(label_url).read().splitlines()class_labels = class_labels[1:]assert len(class_labels) == 1000for i, label in enumerate(class_labels): if isinstance(label, bytes): class_labels[i] = label.decode(\"utf8\")import coremltools as ct# 定义输入image_input = ct.ImageType(shape=(1, 224, 224, 3,), bias=[-1,-1,-1], scale=1/127)# 设置可预测的标签classifier_config = ct.ClassifierConfig(class_labels)# 进行模型转换model = ct.convert( keras_model, inputs=[image_input], classifier_config=classifier_config,)# 写入元数据model.input_description[\"input_1\"] = \"输入要分类的图片\"model.output_description[\"classLabel\"] = \"最可靠的结果\"# 模型作者model.author = \"TensorFlow转换\"# 许可model.license = \"Please see https://github.com/tensorflow/tensorflow for license information, and https://github.com/tensorflow/models/tree/master/research/slim/nets/mobilenet for the original source of the model.\"# 描述model.short_description = \"图片识别模型\"# 版本号model.version = \"1.0\"# 存储模型model.save(\"XMobileNetV2.mlmodel\") 运行此Python脚本，如果没有报错，则会在当前脚本的同级目录下生成模型文件，下面我们可以将此模型文件引入到Xcode中，如下： 下面可以尝试下此模型的预测效果，如下： 可以看到，将三方模型转成成CoreML模型非常简单，同理对于PyTroch，LibSVM等模型也类似，安装对应的三方模块，读取模型后进行转换即可。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（21）——CoreML模型的更多训练模板","slug":"476iOS MachineLearning 系列（21）——CoreML模型的更多训练模板","date":"2023-07-24T16:00:00.000Z","updated":"2023-07-25T07:16:18.157Z","comments":true,"path":"2023/07/25/476iOS MachineLearning 系列（21）——CoreML模型的更多训练模板/","link":"","permalink":"http://huishao.cc/2023/07/25/476iOS MachineLearning 系列（21）——CoreML模型的更多训练模板/","excerpt":"","text":"iOS MachineLearning 系列（21）——CoreML模型的更多训练模板前面文章中，有介绍如何训练生成定制化需求的 CoreML 模型，以图像分类为例做了演示，文章地址： https://my.oschina.net/u/2340880/blog/9377371 Create ML工具还提供了更多训练模版，本篇文章将系统的对其用法进行介绍。 一.Object Detection类的模型训练之前我们也有使用过Object Detection类的模型，Object Detection，顾名思义为对象识别。即可以将一张图片中的某个对象识别出来，分析出对象的标签以及标识处对象所在图片中的位置。Object Detection最常用的模型有人脸识别模型，交通信号灯识别模型，动物识别模型等。当然，已经训练好的这些模型不一定能够满足我们需求，还以动漫角色为例，假如我们的应用需要能识别出某个图片中的某个动漫角色人物，并分析出其所在图片的位置，就可以自主来训练Object Detection类的模型。 使用Create ML工具时，视觉类模型训练的步骤基本都是一致的，我们只需要提供一组训练数据和一组测试数据，在进行一些参数配置即可。详情可以参考本系列的上一篇文章。在训练某个模型时，我们最需要关注的其实就是数据的输入格式和参数的配置。 Object Detection类的模型训练大致可以分为如下几步： 收集数据足够多，且差异性覆盖足够的一组图片集（大部分数据类模型的训练都需要）。 对数据集进行处理，为每张训练图片进行注解，注解包括此图中对象的标签以及所在位置（收集到数据后，一般都需要处理才能进行训练）。 按照固定的格式来整理文件和目录结构，进行训练。 下面我们来详细的介绍这几个步骤。 数据的收集无需做过多介绍，只需要指定一组正常格式的图片文件即可，将这些文件放入到一个文件夹中。我们通常会将用来训练的数据集的文件夹命名为Training Data。比较重要的一步是构建annotation.json文件，这个文件的文件名是固定的，必须命名为annotation.json，且与训练图片放入同一个文件夹中，其用来为每张训练图片进行标注。每个注解对象的结构如下： 1234567891011121314&#123; \"imagefilename\": \"图片文件的名字\", \"annotation\": [ &#123; \"coordinates\": &#123; \"y\": 0.0, \"x\": 0.0, \"height\": 199.0, \"width\": 199.0 &#125;, \"label\": \"标签名\" &#125; ]&#125; 其中，annotation可以配置为一个数组，这也就是说，Object Detection是支持一张图片中包含多个要识别的对象的，只需要正确的标志位置和标签即可。coordinates用来标记对象所在的位置和尺寸。x，y分别是相对于原点的横纵坐标位置，width和height分别设置对象的宽高。（需要注意，此处的原点为图片左上角点）。默认的尺寸坐标为像素，也支持使用比例，只需要将值都设置为0到1之间的浮点数即可。例如： 1234567891011121314&#123; \"imagefilename\": \"图片文件的名字\", \"annotation\": [ &#123; \"coordinates\": &#123; \"y\": 0.1, \"x\": 0.1, \"height\": 0.9, \"width\": 0.9 &#125;, \"label\": \"标签名\" &#125; ]&#125; 之后，设置Training Data进行训练即可。 二.Style Transfer类型的模型训练Style Transfer类型的模型用来转换图片或视频的风格，这个模型也很常用，相机和视频滤镜经常会使用到此类模型。使用这个训练模版，我们可以训练出一个自定义的图片或视频滤镜。 Style Transfer类型的模型训练需要准备一组训练图集，并提供一张样本风格的图片，在训练时，有两个参数可以进行调节：Strength和Density。 Strength参数高，则生成的模型在应用时会保留原图更少的内容，而应用更多的样式。 Density参数设置的越高，则学习风格的精细程度越高。 三. Hand Pose Classification类型的模型训练此类型的模型与Image Classification的模型训练方式是一致的，提供一个数据集，其中按照文件夹命名来对图片进行分类，进行训练即可。 四.ActionClassification，Hand Action Calssification类型的模型训练这两类模型主要是用来进行动作的识别，要识别动作，简单的静态图片是无法实现的，因此训练时，需要提供视频数据，参数配置帧率，动作时长等。 五.SoundClassifier类型模型的训练SoundClassifier类型模型用来进行声音的分类，训练此模型与训练Image Classification的模型类似，将数据集的声音按照类型进行分类，分别放在不同的文件夹下，文件夹的名字即是声音的类别，即可进行训练。 六.文本分析类型的模型训练文本分析类型的模型的训练，主要能够训练出进行文本分类的模型。在Create ML工具中，提供了两个模版，TextClassifier和WordTager。TextClassifier模型用来进行文本分类，例如之前有使用的文本的积极性分析，只需要将本文文件（txt）放入对应的标签文件夹中，将文件夹组成数据集进行训练即可。WordTager类型的模型训练也很简单，提供一组词汇，并且进行标签标记，之前使用的词性分析即是这类方式训练出来的模型。 除了上面提到的这些标准模板外，Create ML工具还提供了训练数据表格化模型的模板。并且，上面所有提到的模型的训练，除了直接使用Create ML可视化工具外，我们也可以通过编写代码的方式来进行训练，此工具使用到的接口在CroreML框架中都有提供。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（20）—— 训练生成CoreML模型","slug":"475iOS MachineLearning 系列（20）—— 训练生成CoreML模型","date":"2023-05-28T16:00:00.000Z","updated":"2023-05-28T11:15:07.142Z","comments":true,"path":"2023/05/29/475iOS MachineLearning 系列（20）—— 训练生成CoreML模型/","link":"","permalink":"http://huishao.cc/2023/05/29/475iOS MachineLearning 系列（20）—— 训练生成CoreML模型/","excerpt":"","text":"iOS MachineLearning 系列（20）—— 训练生成CoreML模型本系列前面的文章详细的介绍了在iOS中与AI能力相关的API的使用，也介绍了如何使用训练好的CoreML模型来实现更强大的AI能力。然而，无论是成熟的API提供的能力，还是各种各样的三方模型，有时候都并不能满足某一领域内的定制化需求。当我们拥有很多的课训练数据，且需要定制化的AI能力时，其实就可以自己训练生成CoreML模型，将此定制化的模型应用到工程中去。 如果安装了Xcode开发工具，会自动安装Create ML工具，在Xcode的Develop Tool选项中，可以找到此工具： Create ML工具默认提供了许多模型训练模板，如图片分析类的，文本分析类的，音频分析类的等，如下图所示： 每种模板对应的训练方式不同，我们可以根据需求来选择要使用的模板。 1 - 自己训练一个图片分类模型图片分类属于图片识别类的模型，当我们输入一个图像时，其会自动分析并进行标签分类。要训练模型，首先我们需要有一定数量的已经分类好的图片。本示例中，我们使用火影忍者中的鸣人和佐助的图片作为素材来进行训练，实现一个能够自动识别鸣人或佐助的模型。 首先新建一个Create ML工程，这里我们将名称设置为YHImageClassifier。模板使用Image Classification。基础信息如下图所示： 之后我们需要准备训练数据和测试数据，训练数据需要每个类别至少10张图片，图片的格式可以是JPEG或PNG，尺寸无需特别规定，尽量使用299*299尺寸的图片，数据集的数据越多，训练出的模型将越健壮和强大，每张素材图片应尽量的从不同的角度和光照方向来描述事物，并且需要注意，每个类别的素材数量应尽量保持平衡。这里为了演示方便，我们直接使用10张鸣人的图片和10张佐助的图片来作为训练素材，将他们按照标签分类放入对应的文件夹中，如下： 其中，Training Data文件夹中有两个子文件夹，分别对应鸣人和佐助两个标签，鸣人和佐助这两个子文件夹中各有10张分类好的图片。Testing Data文件夹中结构与Training Data中的一致，只是每个子文件夹中只有一张用来测试的图片，且测试的图片不在训练集中。使用测试数据可以快速的检查我们的训练结果，如果我们有非常大量的训练数据，则可以考虑将其中的20%用来作为测试数据来进行模型可用性的评估，这里同样为了演示方便，我们每个标签只选择一张图片作为测试数据。 之后，将Training Data文件夹拖入到工程的Training Data项中，Testing Data文件夹拖入到工程的Testing Data项中，我们也可以对一些训练参数进行设置，如迭代次数，是否对图片增加一些处理等，这里我们选择迭代次数为1，不选择任何额外参数，如下： 之后点击Train按钮来进行训练，因为我们的输入数据很少，训练会非常快，训练按成后，会自动使用测试数据进行测试，本示例的测试结果如下图所示： 如果测试的结果能够让我们满意，则可以将此模型导出，如下所示： 可以看到，此模型的大小只有17k，通过Create ML，训练出一个生产可用的CoreML模型真的是非常简单方便。 2 - 尝试使用YHImageClassifier模型前面我们导出了YHImageClassifier模型，此模型可以简单的对火影忍者中的佐助或鸣人进行识别。需要注意，由于在训练时我们使用的数据量很小，因此在进行识别时，我们应尽量的选择与训练数据集类似的图片。 YHImageClassifier模型的使用和前面文章介绍的官方模型的使用没有区别，我们可以再选两张鸣人和佐助的图片（不在训练集中也不在测试集中的），Demo代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import UIKitimport CoreMLclass CustomModelViewController: UIViewController &#123; let image = UIImage(named: \"mingren\")! let image2 = UIImage(named: \"zuozhu\")! lazy var imageView: UIImageView = &#123; let v = UIImageView() v.image = image return v &#125;() lazy var imageView2: UIImageView = &#123; let v = UIImageView() v.image = image2 return v &#125;() lazy var label: UILabel = &#123; let l = UILabel() l.numberOfLines = 0 l.font = .systemFont(ofSize: 18) l.text = \"\" return l &#125;() lazy var label2: UILabel = &#123; let l = UILabel() l.numberOfLines = 0 l.font = .systemFont(ofSize: 18) l.text = \"\" return l &#125;() override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .white let width = view.frame.width / 2 let scale = image.size.width / image.size.height let scale2 = image2.size.width / image2.size.height imageView.frame = CGRect(x: 0, y: 100, width: width, height: width / scale) view.addSubview(imageView) imageView2.frame = CGRect(x: 0, y: 100 + imageView.frame.height, width: width, height: width / scale2) view.addSubview(imageView2) label.frame = CGRect(x: width, y: 100, width: view.frame.width, height: 50) view.addSubview(label) label2.frame = CGRect(x: width, y: 100 + imageView.frame.height, width: view.frame.width, height: 50) view.addSubview(label2) let model = try! YHImageClassifier(configuration: MLModelConfiguration()) let input1 = try! YHImageClassifierInput(imageWith: image.cgImage!) let input2 = try! YHImageClassifierInput(imageWith: image2.cgImage!) let output1 = try! model.prediction(input: input1) let output2 = try! model.prediction(input: input2) label.text = output1.classLabel label2.text = output2.classLabel &#125; &#125; 效果如下图所示： 提示：最好使用真机来进行模型测试，不要使用模拟器。 使用Create ML，我们可以训练处一些定制化强，非常有用的图片识别器。例如某个生产的产品是否合格，某个生成的图片是否合格等，只要有大量的数据支持，模型的预测可以非常准确。 文中涉及到的示例可以在如下地址下载： https://github.com/ZYHshao/MachineLearnDemo 欢迎留言交流！","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（19）—— 分析文本中的问题答案","slug":"474iOS MachineLearning 系列（19）—— 分析文本中的问题答案","date":"2023-05-27T16:00:00.000Z","updated":"2023-05-27T16:14:30.306Z","comments":true,"path":"2023/05/28/474iOS MachineLearning 系列（19）—— 分析文本中的问题答案/","link":"","permalink":"http://huishao.cc/2023/05/28/474iOS MachineLearning 系列（19）—— 分析文本中的问题答案/","excerpt":"","text":"iOS MachineLearning 系列（19）—— 分析文本中的问题答案本篇文章将介绍Apple官方推荐的唯一的一个文本处理模型：BERT-SQuAD。此模型用来分析一段文本，并根据提供的问题在文本中寻找答案。需要注意，BERT模型不会生成新的句子，它会从提供的文本中找到最有可能的答案段落或句子。 BERT模型的使用比较复杂，大致可以分为如下几步： 将词汇表导入。 将问题和原文档分解为Token序列。 使用词汇表将Token序列转换成id序列。 将id序列转换成模型需要的多维数组进行输入。 根据分析的结果解析答案序列。 根据词汇表将答案序列转换为可读的字符串。 我们一步一步来进行介绍。 1 - 词汇表词汇表没有过多需要讲的，其中定义了每个词汇对应的id，在本文末尾会有示例代码工程，工程中自带了需要使用的词汇表。此词汇表包含了3万余个词汇，每个词汇独占一行，其行号即表示当前词汇的id值。 加载词汇表的示例代码如下： 12345678910111213141516var tokensDic = Dictionary&lt;Substring, Int&gt;()func readDictionary() &#123; // 读取文件中的数据 let fileName = \"bert-base-uncased-vocab\" guard let url = Bundle.main.url(forResource: fileName, withExtension: \"txt\") else &#123; fatalError(\"Vocabulary file is missing\") &#125; guard let rawVocabulary = try? String(contentsOf: url) else &#123; fatalError(\"Vocabulary file has no contents.\") &#125; // 按行进行分割 let words = rawVocabulary.split(separator: \"\\n\") let values = 0..&lt;words.count // 加载到字典 tokensDic = Dictionary(uniqueKeysWithValues: zip(words, values))&#125; 2 - 将问题和原文档分解为Token序列在本系列前面的文章中，有介绍过NaturalLanguage这个框架，其实用来进行自然语言处理的，当然也包含文本的Token分解功能。示例代码如下： 123456789101112131415161718192021var wordTokens = [Substring]()let tagger = NLTagger(tagSchemes: [.tokenType])// 全部转换成小写tagger.string = content.lowercased()tagger.enumerateTags(in: tagger.string!.startIndex ..&lt; tagger.string!.endIndex, unit: .word, scheme: .tokenType, options: [.omitWhitespace]) &#123; (_, range) -&gt; Bool in wordTokens.append(tagger.string![range]) return true&#125;var questionTokens = [Substring]()tagger.string = question.lowercased()tagger.enumerateTags(in: tagger.string!.startIndex ..&lt; tagger.string!.endIndex, unit: .word, scheme: .tokenType, options: [.omitWhitespace]) &#123; (_, range) -&gt; Bool in questionTokens.append(tagger.string![range]) return true&#125; 3 - 将Token序列转换成ID序列第三步，根据词汇表来将Token序列转换成ID序列，如下： 12345678910// 加载词汇表readDictionary()// 转换问题Token序列let questionTokenIds = questionTokens.compactMap &#123; token in tokensDic[token]&#125;// 转换原文档Token序列let contentTokenIds = wordTokens.compactMap &#123; token in tokensDic[token]&#125; 4 - 将ID序列转换为模型的输入这一步略微复杂，首先我们先看下BERT-SQuAD模式的输入输出： 需要注意，其输入有两个，wordIDs是ID序列二维数组，其中包含问题，源文档，使用特殊的分隔符进行分割。wordTypes也是一个二维数组，对应的标记wordIDs数组中每个元素的意义。示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 开始标记，使用特殊数值101let startToken = 101// 分隔符标记，使用特殊数值102let separatorToken = 102// 补位标记，使用特殊数值0let padToken = 0// 输入wordIDsvar inputTokens:[Int] = []// 先拼入开始标记inputTokens.append(startToken)// 拼入问题ID序列inputTokens.append(contentsOf: questionTokenIds)// 拼入分隔符标记inputTokens.append(separatorToken)// 拼入源文档ID序列inputTokens.append(contentsOf: contentTokenIds)// 拼入分隔符标记inputTokens.append(separatorToken)// 不够384位，则用0补齐while inputTokens.count &lt; 384 &#123; inputTokens.append(padToken)&#125;// 输入wordTypesvar inputTokenTypes:[Int] = []// 开始标记，分隔符，和补位标对应的数据位设0inputTokenTypes.append(0)// 问题内容位设1inputTokenTypes.append(contentsOf: Array(repeating: 1, count: questionTokenIds.count))inputTokenTypes.append(0)// 源文档内容位设1inputTokenTypes.append(contentsOf: Array(repeating: 1, count: contentTokenIds.count))inputTokenTypes.append(0)while inputTokenTypes.count &lt; 384 &#123; inputTokenTypes.append(0)&#125;// 构造MLMultiArray二维数组，其结构为1*384的二维结构var tokenMultiArray = try! MLMultiArray(shape: [1, 384], dataType: .int32)for (index, inputToken) in inputTokens.enumerated() &#123; tokenMultiArray[[0, NSNumber(integerLiteral: index)]] = NSNumber(integerLiteral: inputToken)&#125;var typesMultiArray = try! MLMultiArray(shape: [1, 384], dataType: .int32)for (index, inputToken) in inputTokenTypes.enumerated() &#123; typesMultiArray[[0, NSNumber(integerLiteral: index)]] = NSNumber(integerLiteral: inputToken)&#125; 5 - 使用模型进行预测准备好了输入数据，这一步就非常简单，示例如下： 1234let model = try! BERTSQUADFP16(configuration: MLModelConfiguration())let input = BERTSQUADFP16Input(wordIDs: tokenMultiArray, wordTypes: typesMultiArray)let output = try! model.prediction(input: input)handleOutput(output: output) 6 - 处理输出BERT-SQuAD模型的输出为两个1*1*384*1的四位数组，指定了答案的起始位置与结束位置。虽然输出数据为4维的，但是其有3各维度都只有1个元素，因此我们可以将其提取为一维的，定义方法如下： 1234567extension MLMultiArray &#123; func doubleArray() -&gt; [Double] &#123; let unsafeMutablePointer = dataPointer.bindMemory(to: Double.self, capacity: count) let unsafeBufferPointer = UnsafeBufferPointer(start: unsafeMutablePointer, count: count) return [Double](unsafeBufferPointer) &#125;&#125; 处理输出数据如下： 123456789101112131415161718192021222324func handleOutput(output: BERTSQUADFP16Output) &#123; // 值越大，表示当前索引为答案的开始位置的可能性越大，找到最可能的答案开始位置 var startIndex = 0 for p in startIndex ..&lt; output.startLogits.doubleArray().count &#123; if output.startLogits.doubleArray()[p] &gt; output.startLogits.doubleArray()[startIndex] &#123; startIndex = p &#125; &#125; // 同理，找到最可能得答案结束位置，这里我们设置答案长度不超过5个Token var endIndex = startIndex for p in endIndex ..&lt; startIndex + 5 &#123; if output.endLogits.doubleArray()[p] &gt; output.endLogits.doubleArray()[startIndex] &#123; endIndex = p &#125; &#125; // 获取答案ID序列 let subs = inputTokens[startIndex ..&lt; endIndex] // 将ID序列转回字符串 for i in subs &#123; for item in tokensDic where item.value == i &#123; print(item.key) &#125; &#125;&#125; 代码运行效果如下图所示： 本中所涉及到的代码，都可以在如下 Demo 中找到： https://github.com/ZYHshao/MachineLearnDemo 本系列文章到此已经将Apple官方所推荐的模型都做了介绍，当然这些模式的训练都是广泛的，不一定会适用于你的应用场景，CoreML框架也提供了更加强大的模型训练能力，我们可以根据自己的场景并提供有针对性的数据进行个性化的模型训练，在后续文章中会再详细讨论。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（18）—— PoseNet，DeeplabV3与FCRN-DepthPrediction模型","slug":"473iOS MachineLearning 系列（18）—— PoseNet，DeeplabV3与FCRN-DepthPrediction模型","date":"2023-05-24T16:00:00.000Z","updated":"2023-05-25T14:45:26.253Z","comments":true,"path":"2023/05/25/473iOS MachineLearning 系列（18）—— PoseNet，DeeplabV3与FCRN-DepthPrediction模型/","link":"","permalink":"http://huishao.cc/2023/05/25/473iOS MachineLearning 系列（18）—— PoseNet，DeeplabV3与FCRN-DepthPrediction模型/","excerpt":"","text":"iOS MachineLearning 系列（18）—— PoseNet，DeeplabV3与FCRN-DepthPrediction模型本篇文章将再介绍三个官方的CoreML模型：PoseNet，DeeplabV3和FCRN-DepthPrediction。 PoseNet是人体姿势分析模型，可以识别图片中的人体部分，然后以17个基准点来描述人体的姿势。关于人体姿势的识别，其实Vision框架本来就有此能力，本文主要介绍使用自定义的模型如何实现。Vision框架的用法可以参见如下文章： https://my.oschina.net/u/2340880/blog/8681809 DeeplabV3是一个图像分割模型，主要用来实现抠图需求，Vision框架中也有对应的能力，可参加如下文章： https://my.oschina.net/u/2340880/blog/8695980 FCRN-DepthPrediction模型用来进行图片景深的预测，这是Vision框架所不具备的能力。 在此地址可以下载到这三个模型： https://developer.apple.com/machine-learning/models/ 1 - PoseNet模型PoseNet模型可以检测17个人体的关键部位或关节，通过这些关键点来构建出完整的人体姿势。 PoseNet最大的模型在6MB左右，相比Vision框架提供的姿势识别，直接使用模型来做会比较麻烦，但是Vision框架也有局限性，其姿势识别的API是在iOS 14之后引入的，如果要支持更低的版本，还是需要我们自己来实现。 首先观察下PoseNet模型在Xcode中的介绍，我们主要专注在输入输出部分： 其中输入部分比较简单，为图片数据。输出部分我们需要关注的是offsets和heatmap两个。其中offsets存储了特征点的位置信息，heatmap存储了特征点的可信度信息。 从模型介绍可以看出，这是一个17*33*33的多维数组。其中最外层的一维17分别对应了人体的17个特征位置，每个特征位置对应一个33*33的矩阵，这就好比，把原始图片横纵等距的画上32条分割线，将图片在水平方向和竖直方向上各均分成33个部分，这里存储的数据即是此人体特征点在当前图片部分上的可信度是多少。换句话说，我们其实就是遍历第一维的数据（17个特征点），然后分别找到每个特征点可信度最大的区块位置即可。要找到特征点的具体位置，需要使用返回的offsets数据，此属性是一个34*33*33的多维数组，也很好理解，对第一维来说，前17个元素表示的是每个特征点的y方向偏移，后17个元素表示的是每个特征点的x方向的偏移。每个元素都是一个33*33的矩阵，我们需要查找第一步找到的可信度最高的区块内的偏移。首先封装一些数据模型类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// 人体特征点类class Joint &#123; // 特征点名字枚举，这里的顺序和模型多维数组中的顺序是一致的 enum Name: Int, CaseIterable &#123; case nose case leftEye case rightEye case leftEar case rightEar case leftShoulder case rightShoulder case leftElbow case rightElbow case leftWrist case rightWrist case leftHip case rightHip case leftKnee case rightKnee case leftAnkle case rightAnkle &#125; // 名字 let name: Name // 可信度 var confidence: Double // 所在图片上的位置 var position: CGPoint init(name: Name, position: CGPoint = .zero, confidence: Double = 0) &#123; self.name = name self.position = position self.confidence = confidence &#125;&#125;class PoseModel &#123; // 共17个特征点 let jointCount = 17 // 此模型会将图片分割成33*33的区块 let xBlocks = 33 let yBlicks = 33 // 所有特征组成的字典 var joints: [Joint.Name: Joint] = [ .nose: Joint(name: .nose), .leftEye: Joint(name: .leftEye), .leftEar: Joint(name: .leftEar), .leftShoulder: Joint(name: .leftShoulder), .leftElbow: Joint(name: .leftElbow), .leftWrist: Joint(name: .leftWrist), .leftHip: Joint(name: .leftHip), .leftKnee: Joint(name: .leftKnee), .leftAnkle: Joint(name: .leftAnkle), .rightEye: Joint(name: .rightEye), .rightEar: Joint(name: .rightEar), .rightShoulder: Joint(name: .rightShoulder), .rightElbow: Joint(name: .rightElbow), .rightWrist: Joint(name: .rightWrist), .rightHip: Joint(name: .rightHip), .rightKnee: Joint(name: .rightKnee), .rightAnkle: Joint(name: .rightAnkle) ] var data: PoseNetMobileNet100S16FP16Output // 每个区块的宽高 var blockWidth: Double var blockHeight: Double // 使用此输出模型来解析 init(data: PoseNetMobileNet100S16FP16Output, width: Double, height: Double) &#123; self.data = data self.blockWidth = width self.blockHeight = height // 对每个节点进行解析 joints.values.forEach &#123; joint in cofigure(joint: joint) &#125; joints.values.forEach &#123; joint in // 打印每个特征点的可信度 print(joint.name, joint.confidence) &#125; &#125; func cofigure(joint: Joint) &#123; // 解析出可信度最高的block 记录可信度和区块位置 var bastConfidence = 0.0 var bastBlockX = 0 var bastBlockY = 0 for x in 0 ..&lt; xBlocks &#123; for y in 0 ..&lt; yBlicks &#123; let multiArrayIndex = [NSNumber(integerLiteral: joint.name.rawValue), NSNumber(integerLiteral: y), NSNumber(integerLiteral: x)] let confidence = data.heatmap[multiArrayIndex].doubleValue if confidence &gt; bastConfidence &#123; bastConfidence = confidence bastBlockX = x bastBlockY = y &#125; &#125; &#125; joint.confidence = bastConfidence // 获取详细的坐标位置，offsets多维数组中存放的是对应特征点的偏移位置，前17个为y偏移，后17个为x偏移。 let yOffsetIndex = [NSNumber(integerLiteral: joint.name.rawValue), NSNumber(integerLiteral: bastBlockY), NSNumber(integerLiteral: bastBlockX)] let xOffsetIndex = [NSNumber(integerLiteral: joint.name.rawValue + jointCount), NSNumber(integerLiteral: bastBlockY), NSNumber(integerLiteral: bastBlockX)] let offsetX = data.offsets[xOffsetIndex].doubleValue let offsetY = data.offsets[yOffsetIndex].doubleValue // 通过偏移量加上区块的起始位置来确定最终位置 joint.position = CGPoint(x: Double(bastBlockX) * blockWidth + offsetX, y: Double(bastBlockY) * blockHeight + offsetY) &#125;&#125; 可以看到，整个解析的过程还是比较复杂，一旦搞定了解析，其使用逻辑就非常简单了，示例如下： 123456789101112131415161718192021222324252627282930313233343536class PoseModelViewController: UIViewController &#123; let image = UIImage(named: \"man\")! lazy var imageView: UIImageView = &#123; let v = UIImageView() v.image = image return v &#125;() override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .white let scale = image.size.width / image.size.height imageView.frame = CGRect(x: 0, y: 100, width: view.frame.width, height: view.frame.width / scale) view.addSubview(imageView) // 这些模型都是Xcode自动生成的 let model = try! PoseNetMobileNet100S16FP16(configuration: MLModelConfiguration()) let input = try! PoseNetMobileNet100S16FP16Input(imageWith: image.cgImage!) let output = try! model.prediction(input: input) handleOutPut(outPut: output) &#125; func handleOutPut(outPut: PoseNetMobileNet100S16FP16Output) &#123; let pose = PoseModel(data: outPut, width: Double(imageView.frame.width) / 33, height: Double(imageView.frame.height) / 33) for joint in pose.joints.values &#123; let v = UIView() v.frame = CGRect(x: joint.position.x - 3, y: joint.position.y - 3, width: 6, height: 6) v.backgroundColor = .red v.layer.cornerRadius = 3 imageView.addSubview(v) &#125; &#125;&#125; 效果如下图所示： 2 - DeeplabV3模型DeeplabV3模型用来检测物体的轮廓，简单来说，其是一个用来进行抠图应用的模型。 同样DeeplabV3模型的使用也不像Vision框架那么方便，其模型介绍如下： 我们只关注其输入和输出，可以看到，此模型会将输入的图片格式化成513*513的点阵，输出的也是一个513*513的二维点阵，当这些点的取值要么是0要么是1，我们转换到原图按照0和1的排布进行有色和无色的渲染即可得到蒙层图。使用示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import UIKitimport CoreMLclass SegModelViewController: UIViewController &#123; let image = UIImage(named: \"seg.jpeg\")! lazy var imageView: UIImageView = &#123; let v = UIImageView() v.image = image return v &#125;() lazy var imageView2: UIImageView = &#123; let v = UIImageView() v.image = image return v &#125;() override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .white let scale = image.size.width / image.size.height imageView.frame = CGRect(x: 0, y: 100, width: view.frame.width, height: view.frame.width / scale) view.addSubview(imageView) imageView2.frame = CGRect(x: 0, y: 100 + imageView.frame.height, width: view.frame.width, height: view.frame.width / scale) view.addSubview(imageView2) // 创建模型 let model = try! DeepLabV3(configuration: MLModelConfiguration()) // 创建输入数据结构 let input = try! DeepLabV3Input(imageWith: image.cgImage!) // 进行处理 let output = try! model.prediction(input: input) // 对输出做解析 handleOutPut(outPut: output) &#125; func handleOutPut(outPut: DeepLabV3Output) &#123; let width = imageView2.frame.width / 513 let height = imageView2.frame.height / 513 let shape = CAShapeLayer() shape.frame = CGRect(x: 0, y: 0, width: imageView2.frame.width, height: imageView2.frame.height) shape.anchorPoint = CGPoint(x: 0.5, y: 0.5) imageView2.layer.addSublayer(shape) var path = CGMutablePath() // 对513*513的点阵进行行列遍历 for line in 0 ..&lt; 513 &#123; for column in 0 ..&lt; 513 &#123; // 从模型的返回结果中来取值 let black = outPut.semanticPredictions[[NSNumber(integerLiteral: line), NSNumber(integerLiteral: column)]] if black == 0 &#123; path.addRect(CGRect(x: CGFloat(column) * width, y: CGFloat(line) * height, width: width, height: height)) &#125; &#125; &#125; shape.fillColor = UIColor.black.cgColor shape.path = path &#125;&#125; 3 - FCRN-DepthPredictio模型 FCRN模型进行图片的景物深度预测，即对于平面的图片，此模型可以预测出其中物体离我们的远近。iOS的Vision框架中并没有提供类似的功能接口，因此如果需要分析景深，使用FCRN模型是不错的选择。其实，景深分析在增强现实方面有着很重要的应用。首先，我们还是先看此模型的输入输出： 可以看到，其讲输入一张图片，并将图片分割成128*160的点阵，将每个点的预测深度返回，其返回的结果越大表示离我们越近，越小则表示离我们越远。完整的示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import UIKitimport CoreMLclass DeppModelViewController: UIViewController &#123; let image = UIImage(named: \"deep2\")! lazy var imageView: UIImageView = &#123; let v = UIImageView() v.image = image return v &#125;() lazy var imageView2: UIImageView = &#123; let v = UIImageView() v.image = image return v &#125;() override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .white let scale = image.size.width / image.size.height imageView.frame = CGRect(x: 0, y: 100, width: view.frame.width, height: view.frame.width / scale) view.addSubview(imageView) imageView2.frame = CGRect(x: 0, y: 100 + imageView.frame.height, width: view.frame.width, height: view.frame.width / scale) view.addSubview(imageView2) // 使用模型进行分析 let model = try! FCRN(configuration: MLModelConfiguration()) let input = try! FCRNInput(imageWith: image.cgImage!) let output = try! model.prediction(input: input) handleOutPut(outPut: output) &#125; func handleOutPut(outPut: FCRNOutput) &#123; let width = imageView2.frame.width / 160 let height = imageView2.frame.height / 128 // 遍历点阵，根据景深来绘制不同的颜色 for line in 0 ..&lt; 128 &#123; for column in 0 ..&lt; 160 &#123; let black = outPut.depthmap[[NSNumber(integerLiteral: 0), NSNumber(integerLiteral: line), NSNumber(integerLiteral: column)]].doubleValue let v = UIView() v.frame = CGRect(x: CGFloat(column) * width, y: CGFloat(line) * height, width: width, height: height) // 这里除2是为了将数据映射到0-1之间 v.backgroundColor = UIColor(red: black / 2, green: black / 2, blue: black / 2, alpha: 1) imageView2.addSubview(v) &#125; &#125; &#125;&#125; 图中颜色越深的区域表示离我们越近。 FCRN模型虽然补充了iOS Vision框架的能力，但其模型大小超过200M，也将会对应用的包体积造成额外的负担。 到此，我们将官方推荐的一些CoreML模型中与视觉有关的就介绍完了，在官方的CoreML模型库中，还提供了一个与文本处理相关的模型，我们将在后续文章中介绍。 本中所涉及到的代码，都可以在如下 Demo 中找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（17）—— 几个常用的对象识别 CoreML 模型","slug":"472iOS MachineLearning 系列（17）—— 几个常用的对象识别 CoreML 模型","date":"2023-05-21T16:00:00.000Z","updated":"2023-05-22T15:18:12.182Z","comments":true,"path":"2023/05/22/472iOS MachineLearning 系列（17）—— 几个常用的对象识别 CoreML 模型/","link":"","permalink":"http://huishao.cc/2023/05/22/472iOS MachineLearning 系列（17）—— 几个常用的对象识别 CoreML 模型/","excerpt":"","text":"iOS MachineLearning 系列（17）—— 几个常用的对象识别 CoreML 模型上一篇文章中，我们介绍了几个官方的图片分类的模型，图片分类模型的应用场景在于将图片中最主要的事物进行识别，在已有的词库中找到最可能得事物。而对象识别则要更高级一些。再之前的文章，我们介绍过可以使用官方提供的API来进行矩形识别，文本识别，二维码识别以及人脸识别等，这类识别功能的特点是我们不仅可以将图片中的物体位置和尺寸分析出来，还可以对其进行类别的分类。 本篇文章，我们将介绍使用官方提供的两个CoreML模型来进行对象识别，这两个模型可以很好的补充系统API的不足，助力业务场景功能的开发。 1 - TOLOv3模型TOLOv3是一个快速识别物体的神经网络模型。关于物体识别，Vision框架提供的有VNRecognizedObjectObservation，此类即描述了识别出的结果。使用自定义的CoreML模型进行对象识别，也会使用到此类。前面我们在使用图片分类的模型时，可以直接使用Xcode帮我们生成的代码，TOLOv3模型则不再适用此方式，我们需要使用Vision框架的接口来实现功能。 其实过程也比较简单，首先加载模型： 12let url = URL(fileURLWithPath: Bundle.main.path(forResource: \"YOLOv3\", ofType: \"mlmodelc\")!)lazy var visionModel = try! VNCoreMLModel(for: MLModel(contentsOf: url)) 这里需要注意，我们拖入Xcode工程中的模型名字为YOLOv3.mlmodel，但是经过Xcode的编译，实际在IPA包中的模型文件的后缀为mlmodelc，这里一定要注意不要写错。 下面创建一个图片分析请求的处理类： 1234// 图像分析请求处理类lazy var imageRequestHandler = VNImageRequestHandler(cgImage: image.cgImage!, orientation: .up, options: [:]) 这一步我们应该相当熟悉了，前面文章介绍Vision框架时，几乎每个示例都会使用到这个类。之后来创建识别请求： 12345678let objectRecognition = VNCoreMLRequest(model: visionModel, completionHandler: &#123; (request, error) in DispatchQueue.main.async(execute: &#123; // perform all the UI updates on the main queue if let results = request.results &#123; self.handleOutPut(outPut: results as! [VNRecognizedObjectObservation]) &#125; &#125;)&#125;) 这里使用了Vision框架中的VNCoreMLRequest类，这个类通过CoreML模型来创建请求。最后发起请求即可： 1try? imageRequestHandler.perform([objectRecognition]) 关于请求的结果的处理，其实就是对VNRecognizedObjectObservation数据的处理，示例如下： 1234567891011121314151617181920212223func handleOutPut(outPut: [VNRecognizedObjectObservation]) &#123; for objectObservation in outPut &#123; // 获取可信度最高的结果 let topLabelObservation = objectObservation.labels[0] // 获取位置和尺寸 var box = objectObservation.boundingBox box.origin.y = 1 - box.origin.y - box.size.height let size = imageView.frame.size let v = UIView() v.frame = CGRect(x: box.origin.x * size.width, y: box.origin.y * size.height, width: box.size.width * size.width, height: box.size.height * size.height) v.backgroundColor = .clear v.layer.borderColor = UIColor.red.cgColor v.layer.borderWidth = 2 imageView.addSubview(v) let label = UILabel() label.font = .boldSystemFont(ofSize: 18) label.text = \"\\(topLabelObservation.identifier):\" + String(format: \"%0.2f\", topLabelObservation.confidence) label.frame = CGRect(x: v.frame.origin.x, y: v.frame.origin.y - 18, width: 200, height: 18) label.textColor = .red imageView.addSubview(label) &#125;&#125; 代码运行效果如下图所示： 可以看到，这个识别模型对交通工具和信号灯的识别度很高，其用来做辅助驾驶或导航会非常好用。 2 - TOLOv3Tiny模型TOLOv3模型很好用，但其尺寸也很大，32位的模型大小为248.4MB，最算最小的8位模型也要62.2MB。更多时候将这么大的一个模型引入应用中是要付出成本的，最直观的成本就是应用的包体积会增大，增加用户的下载难度。TOLOv3还提供了一个精简版的模型TOLOv3Tiny，从功能上来说，其与TOLOv3所能支持的识别的词库一样，但其只有35.4MB，并且最小的8位模型只有8.9MB。其用法与TOLOv3一样，对同一张图片，其识别效果如下： 可以看到，相比起来，精简版的模型对物体的边界分析能力要略差一些。识别的精度也更低一些。 这两个模型都可以在如下地址下载： https://developer.apple.com/machine-learning/models/ 示例代码可在此Demo中查看： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（16）—— 几个常用的图片分类CoreML模型","slug":"471iOS MachineLearning 系列（16）—— 几个常用的图片分类CoreML模型","date":"2023-05-12T16:00:00.000Z","updated":"2023-05-13T10:25:23.037Z","comments":true,"path":"2023/05/13/471iOS MachineLearning 系列（16）—— 几个常用的图片分类CoreML模型/","link":"","permalink":"http://huishao.cc/2023/05/13/471iOS MachineLearning 系列（16）—— 几个常用的图片分类CoreML模型/","excerpt":"","text":"iOS MachineLearning 系列（16）—— 几个常用的图片分类CoreML模型在本系列的前面文章中，有介绍使用Vision框架中的VNClassifyImageRequest进行图片物体识别。Apple也推荐了几个常用的图像分类模型可供开发者使用。可以在如下地址直接下载： https://developer.apple.com/machine-learning/models/ 1 - 几个模型的简单介绍对于图片识别分类的模型来说，其输入和输出都一样，输入都为图像参数，输入为两部分，一部分为最佳预测结果，一部分为可能得预测结果及其可信度。 Resnet50Resnet50是一种神经网络分类模型，其大小为102.6M左右，其可以从1000种类别中检测输入图像中的主要元素，包括树木，动物，食物，车辆和人等。其测量的误差率为7.8%。 MobileNetV2MobileNetV2是一种神经网络分类模型，其大小约为24.7M，其同样能从千余种类别中检测图像里的主要元素。其测量的准确率为74.7%。 SqueezeNetSqueezeNet也是一种神经网络分类模型，其最大的特点是非常小巧，参数可以减少50倍。我们直接使用的模型大小仅有5M左右。 整体来说，Resnet50体积最大，其预测的精准度也相比会更好，但是对于图片比较清晰，内容比较单一的图像，这些模型都可以满足我们的正常需求。 2 - 使用示例关于CoreML模型的使用，之前的文章有做详细的介绍，这里并没有额外需要注意的地方。我们直接将模型下载下来引入到Xcode工程中，Xcode会自动帮我们生成模型的使用代码，分别初始化3个模型的操作对象如下： 123456// mobileNet2模型let mobileNet2 = try! MobileNetV2(configuration: MLModelConfiguration())// resent50模型let resnet50 = try! Resnet50(configuration: MLModelConfiguration())// squeezeNet 模型let squeezeNet = try! SqueezeNet(configuration: MLModelConfiguration()) 对应的，创建输入参数： 123let mobileNet2Input = try! MobileNetV2Input(imageWith: image.cgImage!)let resnet50Input = try! Resnet50Input(imageWith: image.cgImage!)let squeezeNetInput = try! SqueezeNetInput(imageWith: image.cgImage!) 进行预测： 12345678// 进行图像识别let mobileOutput = try! mobileNet2.prediction(input: mobileNet2Input)let resnetOutput = try! resnet50.prediction(input: resnet50Input)let squeezeOutput = try! squeezeNet.prediction(input: squeezeNetInput)label.text = label.text?.appending(\"mobileNet2模型预测结果：\\n最可能：\\(mobileOutput.classLabel)\\n\\n\")label.text = label.text?.appending(\"resnet50模型预测结果：\\n最可能：\\(resnetOutput.classLabel)\\n\\n\")label.text = label.text?.appending(\"squeeze模型预测结果：\\n最可能：\\(squeezeOutput.classLabel)\\n\\n\") 结果如下图所示： 可以看到，3种模型都正确的对图片进行了分类，正确的检测出了图片中的“猕猴”。 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（15）—— 可进行个性化更新的CoreML模型","slug":"470iOS MachineLearning 系列（15）—— 可进行个性化更新的CoreML模型","date":"2023-05-10T16:00:00.000Z","updated":"2023-05-11T06:48:17.908Z","comments":true,"path":"2023/05/11/470iOS MachineLearning 系列（15）—— 可进行个性化更新的CoreML模型/","link":"","permalink":"http://huishao.cc/2023/05/11/470iOS MachineLearning 系列（15）—— 可进行个性化更新的CoreML模型/","excerpt":"","text":"iOS MachineLearning 系列（15）—— 可进行个性化更新的CoreML模型上一篇文章，介绍了使用官方提供的CoreML模型来实现手写数字识别。其实，更多时候我们需要一个更加个性化的模型，对于手写图像来说，每个人的写法可能风格各异，如果可以在用户的使用过程中不断的更新模型，适应更加个性化的场景，就更完美了。幸运的是，CoreML正提供了这样的功能。我们可以创建一个可更新的模型来实现个性化Learning，同样，本文暂无设计模型的训练，我们通过官方的UpdatableDrawingClassifier模型来演示可更新模型的使用。 1 - 关于UpdatableDrawingClassifier模型UpdatableDrawingClassifier是Apple官方提供的一个训练好的并且支持更新迭代的手绘识别模型。其尺寸大小约为394KB，从其大小也可以看出，其本身并没太多的识别能力，我们需要在iOS应用内对其进行更新，使其能够识别个性化的手绘事物。 此处可以下载到此模型： https://developer.apple.com/machine-learning/models/ 首先，我们可以在Xcode中观察下模型的概要信息： 相比之前使用的MNIST模型，其多了Updates一栏。我们主要关注Predictions和Updates栏目，其中Predictions说明了使用模型预测时的参数和返回数据，Updates则说明了模型更新时的参数。如下图： Predictions输入参数为图片（需要黑色背景，白色前景），输入有数据有两个，一个是字符串类型的最佳预测结果，一个是字典类型的可能的预测结果。 Updates输入参数为图片（需要黑色背景，白色前景），以及此图片对应的预测文本。 2 - UpdatableDrawingClassifier使用示例以前面文章的手写数字为例，之前使用此模型进行预测，会发现其并不能识别出数字。下面我们尝试让其对此图像进行Learning。 首先定义两个模型操作类实例，分别用来承载原模型与更新后的模型： 1234// 更新后的模型var updatedDrawingClassifier: UpdatableDrawingClassifier?// 原模型var baseDrawingClassifier: UpdatableDrawingClassifier? 其中UpdatableDrawingClassifier类是Xcode自动生成的，此类文件前一篇文章有过详细的介绍，这里不再赘述。 我们首先使用原始的模型对图像进行预测，如下： 1234567baseDrawingClassifier = try! UpdatableDrawingClassifier(configuration: MLModelConfiguration())// 未更新前的模型进行测试let output = try! baseDrawingClassifier.prediction(input: UpdatableDrawingClassifierInput(drawingWith: UIImage(named: \"3\")!.cgImage!))print(\"未更新前的预测：'\\(output.label)'\")label.text = label.text!.appending(\"模型未更新前的预测结果：\\(output.label)\\n\") 不出意外，你将得到“unknow”的结果。 下面我们让模型以此图像作为输入进行Learning，先定义一些要使用到的路径URL： 123456789// 原模型路径let defaultModelURL = UpdatableDrawingClassifier.urlOfModelInThisBundle// 用户目录let appDirectory = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!// 临时模型文件路径lazy var tempUpdatedModelURL = appDirectory.appendingPathComponent(\"personalized_tmp.mlmodelc\")// 更新后的模型文件路径lazy var updatedModelURL = appDirectory.appendingPathComponent(\"personalized.mlmodelc\") 如下代码演示了对模型进行更新的过程： 12345678910111213141516171819202122232425262728// 定义预期的预测结果let outputValue = MLFeatureValue(string: \"手写数字3\")// 更新的输入参数名let inputName = \"drawing\" // 图片参数let labelName = \"label\" // 预测结果参数// 获取模型的描述let description = baseDrawingClassifier.model.modelDescription// 获取输入参数的描述let imageInputDescription = description.inputDescriptionsByName[inputName]!// 获取图片约束字段let imageConstraint = imageInputDescription.imageConstraint!// 将图片封装成特征对象let imageFeatureValue = try! MLFeatureValue(cgImage: UIImage(named: \"3\")!.cgImage!, constraint: imageConstraint)// 组合预期结果与对应的特征对象let dataPointFeatures: [String: MLFeatureValue] = [inputName: imageFeatureValue, labelName: outputValue]// 定义特征Provider对象let provider = try! MLDictionaryFeatureProvider(dictionary: dataPointFeatures)// 使用一组provider创建更新任务let updateTask = try? MLUpdateTask(forModelAt: defaultModelURL, trainingData: MLArrayBatchProvider(array: [provider]), configuration: nil, completionHandler: updateModelCompletionHandler)// 执行更新任务updateTask!.resume() 需要注意，通常为了增加模型的预测能力，我们不会仅仅使用一组输入来进行更新，以手写数字为例，我们可以让用户多写几次同样的数字，再进行更新。代码中的updateModelCompletionHandler是更新的回调函数，实现如下： 123456789101112131415161718192021222324252627282930func updateModelCompletionHandler(updateContext: MLUpdateContext) &#123; saveUpdatedModel(updateContext) print(\"更新完成\") // 重新预测 updatedDrawingClassifier = try! UpdatableDrawingClassifier(contentsOf: updatedModelURL) let output = try! updatedDrawingClassifier.prediction(input: UpdatableDrawingClassifierInput(drawingWith: UIImage(named: \"3\")!.cgImage!)) print(\"更新后的预测：'\\(output.label)'\") DispatchQueue.main.async &#123; self.label.text = self.label.text!.appending(\"新的预测结果：\\(output.label)\\n\") &#125;&#125;// 存储更新后的模型func saveUpdatedModel(_ updateContext: MLUpdateContext) &#123; let updatedModel = updateContext.model let fileManager = FileManager.default do &#123; // Create a directory for the updated model. try fileManager.createDirectory(at: tempUpdatedModelURL, withIntermediateDirectories: true, attributes: nil) try updatedModel.write(to: tempUpdatedModelURL) _ = try fileManager.replaceItemAt(updatedModelURL, withItemAt: tempUpdatedModelURL) &#125; catch let error &#123; return &#125;&#125; 运行代码效果如下图所示，可以看到对同样的图片，新的模型已经可以正确识别了。 最后，我们再来总结下可更新模型的使用流程： 准备要更新的物料数据，包括模型的输入数据，以及预期的输出数据。（通常提供一组） 将输入与预期结果对应起来创建MLDictionaryFeatureProvider对象。 通过一组MLDictionaryFeatureProvider对象来创建MLUpdateTask更新任务对象。 执行更新任务，并在回调中存储更新后的模型。 使用新的模型进行预测。 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（14）—— 使用官方模型进行预测","slug":"469iOS MachineLearning 系列（14）—— 使用官方模型进行预测","date":"2023-05-09T16:00:00.000Z","updated":"2023-05-10T05:50:39.313Z","comments":true,"path":"2023/05/10/469iOS MachineLearning 系列（14）—— 使用官方模型进行预测/","link":"","permalink":"http://huishao.cc/2023/05/10/469iOS MachineLearning 系列（14）—— 使用官方模型进行预测/","excerpt":"","text":"iOS MachineLearning 系列（14）—— 使用官方模型进行预测本系列的前面文章，详细介绍了iOS原生框架中提供的与AI相关的API的使用，使用这些API基本可以满足大多视觉，文字，语音等通用化的AI需求。但是这些API并不是万能的，对于某些定制化较强的需求，这些内置的模型可能并不能满足需求。这时就需要涉及到我们本系列文章的核心了：Core ML。Core ML是iOS种提供的Machine Learning相关框架，配套的还有训练模型的开发者工具。 1 - 关于Core ML通常，遇到比较定制化的AI需求时，我们会使用大量的数据进行训练，生成模型后接入到iOS应用中，之后可以在实际的应用场景中对模型进行更新与微调。之前所介绍的相关功能性API，大多是对Core ML的上层封装，Core ML本身则构建于更底层的Accelerate and BNNS 和 Metal Performance Shaders。（神经网络，大规模计算等）。结构如下图： Core ML支持多种类型的Machine Learning模型，如神经网络，树集合，向量机，广义线性模型等。Core ML所使用的模型以mlmodel为后缀名。我们可以使用Apple提供的工具进行模型创建，训练，更新等操作，也可以将其他流行的模型训练库创建的模型转换成Core ML格式的，关于模型的训练和转换，本系列的后面文章会再具体介绍。本文，我们先来探讨下模型的使用。 2 - 将模型集成进应用程序Apple官方提供了许多现成的模型可以直接使用，地址如下： https://developer.apple.com/machine-learning/models/ 其中模型大多是与视觉相关的，如下图： 我们可以以MNIST模型为例，将此模型下载下来，之后添加到Xcode工程中。 之后再Xcode种可以查看此模型的相关信息，其中包括模型的名字，简介，预测的输入输出等信息，如下： 其中，比较重要的是Predictions模块，其中包含了模型的输入输出的信息，如下： 可以看到，对于MNIST模型，其输入要求的是图片，输出为labelProbabilities和classLabel，其中labelProbabilities为一组预测值，对应每个预测值的可信度，classLabel为最可信的预测值。MNIST本身是用来识别手写数字的，其最终会输出0到9之间的数。 当模型被添加进Xcode工程后，Xcode会根据模型的信息自动的生成代码，我们只需要引入Core ML模块，即可直接使用生成的代码。MNIST模型的名字是MNISTClassifier，我们可以在代码中直接生成实例： 12// MNISTClassifier为模型的名字，是Xcode自动生成的let model = try? MNISTClassifier(configuration: MLModelConfiguration()) MNIST要求输入的图片是黑色背景，白色的前景的手写体数字图片，首先定义输入实例： 12// 创建输入模型，此类也是Xcode自动生成的let input = try! MNISTClassifierInput(imageWith: image.cgImage!) 下面可以对此输入进行预测，获取到输出值： 123456789101112// prediction方法对输入进行预测let outPut = try? model?.prediction(input: input) // 展示结果 let label = UILabel(frame: CGRect(x: 0, y: imageView.frame.origin.y + imageView.frame.height, width: view.frame.width, height: 400))label.numberOfLines = 0view.addSubview(label) label.text = \"最优结果：\\(outPut?.classLabel)\\n其他可能：\\n\"for item in outPut?.labelProbabilities ?? [:] &#123; label.text = label.text?.appendingFormat(\"%d:%.2f\\n\", item.key, item.value)&#125; 预测效果如下图所示： MNIST模型的大小只有398K，可以看到其效果还是非常可观。 3 - 深入理解Core ML的使用上面的演示代码非常简单，这是因为关于模型的加载，特征值的提取等逻辑都被Xcode自动生成的代码封装好了。MNISTClassifier本质上是对模型的加载和使用模型进行预测的方法进行了封装，可以看下其中定义的几个初始化方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MNISTClassifier &#123; let model: MLModel /// URL of model assuming it was installed in the same bundle as this class class var urlOfModelInThisBundle : URL &#123; let bundle = Bundle(for: self) return bundle.url(forResource: \"MNISTClassifier\", withExtension:\"mlmodelc\")! &#125; // 加载MLModel模型 init(model: MLModel) &#123; self.model = model &#125; convenience init(configuration: MLModelConfiguration) throws &#123; try self.init(contentsOf: type(of:self).urlOfModelInThisBundle, configuration: configuration) &#125; convenience init(contentsOf modelURL: URL) throws &#123; try self.init(model: MLModel(contentsOf: modelURL)) &#125; convenience init(contentsOf modelURL: URL, configuration: MLModelConfiguration) throws &#123; try self.init(model: MLModel(contentsOf: modelURL, configuration: configuration)) &#125; class func load(configuration: MLModelConfiguration = MLModelConfiguration(), completionHandler handler: @escaping (Swift.Result&lt;MNISTClassifier, Error&gt;) -&gt; Void) &#123; return self.load(contentsOf: self.urlOfModelInThisBundle, configuration: configuration, completionHandler: handler) &#125; class func load(configuration: MLModelConfiguration = MLModelConfiguration()) async throws -&gt; MNISTClassifier &#123; return try await self.load(contentsOf: self.urlOfModelInThisBundle, configuration: configuration) &#125; class func load(contentsOf modelURL: URL, configuration: MLModelConfiguration = MLModelConfiguration(), completionHandler handler: @escaping (Swift.Result&lt;MNISTClassifier, Error&gt;) -&gt; Void) &#123; MLModel.load(contentsOf: modelURL, configuration: configuration) &#123; result in switch result &#123; case .failure(let error): handler(.failure(error)) case .success(let model): handler(.success(MNISTClassifier(model: model))) &#125; &#125; &#125; class func load(contentsOf modelURL: URL, configuration: MLModelConfiguration = MLModelConfiguration()) async throws -&gt; MNISTClassifier &#123; let model = try await MLModel.load(contentsOf: modelURL, configuration: configuration) return MNISTClassifier(model: model) &#125;&#125; 可以看到，其中除了init(model: MLModel)方法外，其他都是加载沙盒路径中的模型。 进行预测的代码也很好理解，其就是调用了MLModel的prediction方法： 1234func prediction(input: MNISTClassifierInput, options: MLPredictionOptions) throws -&gt; MNISTClassifierOutput &#123; let outFeatures = try model.prediction(from: input, options:options) return MNISTClassifierOutput(features: outFeatures)&#125; 对于模型的输入类MNISTClassifierInput，其也是Xcode自动生成的，如果我们要自己实现，只需要定义一个输入类，将其对MLFeatureProvider协议进行实现即可，这个协议的定义非常简单，如下： 123456public protocol MLFeatureProvider &#123; // 提供特征的名字 var featureNames: Set&lt;String&gt; &#123; get &#125; // 提供对应特征的值 func featureValue(for featureName: String) -&gt; MLFeatureValue?&#125; 前面通过看MNIST描述信息可以看到，其输入的参数只有一个image，因此对于输入类，其featureNames之需要返回一个“image”，可见MNISTClassifierInput的实现如下： 12345var featureNames: Set&lt;String&gt; &#123; get &#123; return [\"image\"] &#125;&#125; featureValue为对应的特征提供数据，MNISTClassifierInput需要提供图片数据，其实现如下： 123456func featureValue(for featureName: String) -&gt; MLFeatureValue? &#123; if (featureName == \"image\") &#123; return MLFeatureValue(pixelBuffer: image) &#125; return nil&#125; MNISTClassifierInput类的核心这有这两个，其他方法都是对易用性的封装。 同样，对于模型预测的输出，其也是对MLFeatureProvider协议的实现，MNIST模型的输入有两个，分别为labelProbabilities和classLabel，其中labelProbabilities为字典类型，classLabel为Int64类型，MNISTClassifierOutput对输出进行了封装，方便我们对这两个输出特征进行取值： 1234567// provider是封装的原始输出var labelProbabilities: [Int64 : Double] &#123; return self.provider.featureValue(for: \"labelProbabilities\")!.dictionaryValue as! [Int64 : Double]&#125;var classLabel: Int64 &#123; return self.provider.featureValue(for: \"classLabel\")!.int64Value&#125; 可以看到，Xcode自动生成的代码将Core ML根据模型描述进行了易用性的封装，使用非常方便。 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（13）—— 语音与音频相关的AI能力","slug":"468iOS MachineLearning 系列（13）—— 语音与音频相关的AI能力","date":"2023-05-07T16:00:00.000Z","updated":"2023-05-08T07:57:39.020Z","comments":true,"path":"2023/05/08/468iOS MachineLearning 系列（13）—— 语音与音频相关的AI能力/","link":"","permalink":"http://huishao.cc/2023/05/08/468iOS MachineLearning 系列（13）—— 语音与音频相关的AI能力/","excerpt":"","text":"iOS MachineLearning 系列（13）—— 语音与音频相关的AI能力在语音分析方面，iOS中提供了原生的Speech框架，这个框架可以实时的将语音解析成文本。这个能力非常强大，使用它我们可以实现类似实时翻译的功能。对于非语音的音频，也有一些原生的AI能力可以使用，例如分析语音的类型。SoundAnalysis框架能够识别300多种声音，我们也可以使用自己训练的模型来处理定制化的音频识别需求。 1 - 进行语音识别使用Speech框架来进行语音识别非常简单，并且其支持多种语言。使用此功能前，我们需要先请求用户授予权限。在Info.plist文件中新增如下key: 1NSSpeechRecognitionUsageDescription 此key设置的值为字符串文案，会在使用Speech框架时弹窗展示。 需要注意，Speech框架提供的并非是完全依赖本地的AI能力，其需要连接Apple的服务器来实现功能，因此在使用时要确保网络的正常。 首先需要定义个识别器对象，如下： 1let recognizer = SFSpeechRecognizer(locale: Locale(identifier: \"zh-Hants\")) 其中locale参数设置所识别为的语言。 之后需要创建一个语音识别请求，并发起识别任务，如下： 1234567891011121314// 这里使用本地的语音文件let path = Bundle.main.path(forResource: \"12168\", ofType: \".wav\")let url = URL(fileURLWithPath: path!)// 创建请求对象let request = SFSpeechURLRecognitionRequest(url: url)let label = UILabel(frame: CGRect(x: 0, y: 100, width: view.frame.width, height: 400))label.numberOfLines = 0view.addSubview(label)// 发起请求任务recognizer?.recognitionTask(with: request, resultHandler: &#123; result, error in print(result?.bestTranscription.formattedString, error) label.text = result?.bestTranscription.formattedString&#125;) 运行上面的代码，如果提供的音频文件是正常的语音文件，即可看到识别效果。上面的结果回调会根据音频的长度来多次回调，每次都会根据上下文进行之前识别结果的矫正。 Speech框架不仅支持语音文件的识别，也支持实时进行语音数据流的识别。只需要创建不同的Request类即可。我们可以先来看下语音分析请求的父类SFSpeechRecognitionRequest： 123456789101112open class SFSpeechRecognitionRequest : NSObject &#123; // 设置语音识别的类型 open var taskHint: SFSpeechRecognitionTaskHint // 设置是否在解析过程中返回中间值，默认true，如果设置false则只有当整个语音文件解析完成再返回结果 open var shouldReportPartialResults: Bool // 设置一组自定义的短语，这些短语可能不在词汇表中，针对场景的加强识别的准确性 open var contextualStrings: [String] // 是否进行纯本地的解析，这种场景下不会发送语音到apple服务器，但是会降低准确性，某些语言不可用 open var requiresOnDeviceRecognition: Bool // 设置识别结果中是否增加标点，iOS16之后可用 open var addsPunctuation: Bool&#125; 其中taskHint属性用来设置识别类型，此枚举定义如下： 123456public enum SFSpeechRecognitionTaskHint : Int, @unchecked Sendable &#123; case unspecified = 0 // 未指定明确类型 case dictation = 1 // 一般的听写风格 case search = 2 // 搜索请求风格 case confirmation = 3 // 短语&#125; 要对语音文件进行分析，使用SFSpeechURLRecognitionRequest子类，如果要实时识别语音流，则使用SFSpeechAudioBufferRecognitionRequest子类即可，SFSpeechAudioBufferRecognitionRequest定义如下： 12345678910open class SFSpeechAudioBufferRecognitionRequest : SFSpeechRecognitionRequest &#123; // 利于识别的音频格式 open var nativeAudioFormat: AVAudioFormat &#123; get &#125; // 添加AVAudioPCMBuffer数据 open func append(_ audioPCMBuffer: AVAudioPCMBuffer) // 添加CMSampleBuffer数据 open func appendAudioSampleBuffer(_ sampleBuffer: CMSampleBuffer) // 调用此方法标识语音流数据添加完成 open func endAudio()&#125; SFSpeechRecognizer类用来发起语音识别请求，定义如下： 123456789101112131415161718192021222324252627282930313233open class SFSpeechRecognizer : NSObject &#123; // 所支持的语言 open class func supportedLocales() -&gt; Set&lt;Locale&gt; // 用户授权状态 open class func authorizationStatus() -&gt; SFSpeechRecognizerAuthorizationStatus // 请求用户授权 open class func requestAuthorization(_ handler: @escaping (SFSpeechRecognizerAuthorizationStatus) -&gt; Void) // 构造方法，使用当前系统语言 public convenience init?() // 构造方法，设置语言 public init?(locale: Locale) // 功能是否可用 open var isAvailable: Bool &#123; get &#125; // 使用的语言 open var locale: Locale &#123; get &#125; // 获取是否支持纯本地的请求 open var supportsOnDeviceRecognition: Bool // 代理 weak open var delegate: SFSpeechRecognizerDelegate? // 设置发起请求默认的类型 open var defaultTaskHint: SFSpeechRecognitionTaskHint // 发起请求任务 open func recognitionTask(with request: SFSpeechRecognitionRequest, resultHandler: @escaping (SFSpeechRecognitionResult?, Error?) -&gt; Void) -&gt; SFSpeechRecognitionTask open func recognitionTask(with request: SFSpeechRecognitionRequest, delegate: SFSpeechRecognitionTaskDelegate) -&gt; SFSpeechRecognitionTask // 回调所使用的队列 open var queue: OperationQueue&#125;// SFSpeechRecognizerDelegate协议public protocol SFSpeechRecognizerDelegate : NSObjectProtocol &#123; // 可用性变化时回调 optional func speechRecognizer(_ speechRecognizer: SFSpeechRecognizer, availabilityDidChange available: Bool)&#125; 如果使用闭包的方式来发起请求，则结果会在闭包回调中给到，如果采用代理的方式，则会通过代理回调返回。SFSpeechRecognitionTaskDelegate协议如下： 1234567891011121314public protocol SFSpeechRecognitionTaskDelegate : NSObjectProtocol &#123; // 首次检测到语音时调用 optional func speechRecognitionDidDetectSpeech(_ task: SFSpeechRecognitionTask) // 每次有中间结果时调用 optional func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didHypothesizeTranscription transcription: SFTranscription) // 最终识别完成时调用 optional func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishRecognition recognitionResult: SFSpeechRecognitionResult) // 识别任务结束后调用 optional func speechRecognitionTaskFinishedReadingAudio(_ task: SFSpeechRecognitionTask) // 识别任务取消时调用 optional func speechRecognitionTaskWasCancelled(_ task: SFSpeechRecognitionTask) // 识别任务完整成功后调用 optional func speechRecognitionTask(_ task: SFSpeechRecognitionTask, didFinishSuccessfully successfully: Bool)&#125; 其中SFTranscription类用来描述识别中间结果，如下： 12345678910open class SFTranscription : NSObject, NSCopying, NSSecureCoding &#123; // 格式化后的字符串 open var formattedString: String &#123; get &#125; // 片段数组 open var segments: [SFTranscriptionSegment] &#123; get &#125; // 语音速度，每秒单词数 open var speakingRate: Double &#123; get &#125; // 单词间的平均停顿 open var averagePauseDuration: TimeInterval &#123; get &#125;&#125; 其中SFTranscriptionSegment是具体的词组，里面封装了更多详细的信息： 12345678910111213141516open class SFTranscriptionSegment : NSObject, NSCopying, NSSecureCoding &#123; // 词组 open var substring: String &#123; get &#125; // 在原字符串中的位置 open var substringRange: NSRange &#123; get &#125; // 在原音频中的时间点 open var timestamp: TimeInterval &#123; get &#125; // 在音频中的时长 open var duration: TimeInterval &#123; get &#125; // 测量的可信度，0到1，越大表示越可信 open var confidence: Float &#123; get &#125; // 对此音频片段的更多可能结果 open var alternativeSubstrings: [String] &#123; get &#125; // 发声特性对象 open var voiceAnalytics: SFVoiceAnalytics? &#123; get &#125;&#125; SFSpeechRecognitionResult类描述了分析的结果，实际上是一组SFTranscription的聚合。定义如下： 12345678910open class SFSpeechRecognitionResult : NSObject, NSCopying, NSSecureCoding &#123; // 最完美的结果片段（如果分析结果，此为完整的） @NSCopying open var bestTranscription: SFTranscription &#123; get &#125; // 所有分析结果（根据可信度来排序） open var transcriptions: [SFTranscription] &#123; get &#125; // 是否分析结束 open var isFinal: Bool &#123; get &#125; // 音频元数据信息 open var speechRecognitionMetadata: SFSpeechRecognitionMetadata? &#123; get &#125;&#125; SFSpeechRecognitionMetadata中封装了语音的基础数据： 12345678910111213141516171819202122open class SFSpeechRecognitionMetadata : NSObject, NSCopying, NSSecureCoding &#123; // 语音速度，每分钟单词数 open var speakingRate: Double &#123; get &#125; // 平均语速，每个单词平均秒数 open var averagePauseDuration: TimeInterval &#123; get &#125; // 语音在音频中的开始时间 open var speechStartTimestamp: TimeInterval &#123; get &#125; // 语音的持续时间 open var speechDuration: TimeInterval &#123; get &#125; // 音频分析数据 open var voiceAnalytics: SFVoiceAnalytics? &#123; get &#125;&#125;open class SFVoiceAnalytics : NSObject, NSCopying, NSSecureCoding &#123; // 人声稳定性 @NSCopying open var jitter: SFAcousticFeature &#123; get &#125; @NSCopying open var shimmer: SFAcousticFeature &#123; get &#125; // 人声高低 @NSCopying open var pitch: SFAcousticFeature &#123; get &#125; // 语音概率 @NSCopying open var voicing: SFAcousticFeature &#123; get &#125;&#125; 发起语音请求后，会返回一个SFSpeechRecognitionTask对象，此任务对象可以对当次分析过程进行控制，如下： 1234567891011121314151617181920212223open class SFSpeechRecognitionTask : NSObject &#123; // 当前任务状态 open var state: SFSpeechRecognitionTaskState &#123; get &#125; // 是否完成 open var isFinishing: Bool &#123; get &#125; // 手动完成任务 open func finish() // 是否取消 open var isCancelled: Bool &#123; get &#125; // 手动取消任务 open func cancel() // 异常数据 open var error: Error? &#123; get &#125;&#125;// 任务状态枚举定义如下public enum SFSpeechRecognitionTaskState : Int, @unchecked Sendable &#123; case starting = 0 // 开始 case running = 1 // 运行中 case finishing = 2 // 结束 case canceling = 3 // 取消 case completed = 4 //完成&#125; 2 - 音频类别识别iOS内置API的音频分析能力可以方便的对音频进行分类，例如人声，乐器声等等。内置的SoundAnalysis框架能够分析识别300余种音效，当然其也支持使用自定义的模型来进行分析，本篇文章将只涉及到API的使用。 SNAudioFileAnalyzer类是音频分析的处理类，例如： 1let analyzer = try! SNAudioFileAnalyzer(url: URL(fileURLWithPath: Bundle.main.path(forResource: \"12168\", ofType: \".wav\")!)) SNAudioFileAnalyzer在实例化时会包装一个音频文件地址，后续将对此音频进行分析。首先需要创建一个分析请求，如下： 1let request = try! SNClassifySoundRequest(classifierIdentifier: .version1) 其参数设置使用的算法版本。 通过如下方法来向SNAudioFileAnalyzer实例中添加一个请求，并设置请求过程的监听： 1try! analyzer.add(request, withObserver: self) 之后调用analyze方法来触发请求的执行： 1analyzer.analyze() 对请求过程的监听对象需要实现SNResultsObserving协议，如下： 12345678public protocol SNResultsObserving : NSObjectProtocol &#123; // 分析到请求结果时调用的回调，一段音频分析中会持续调用 func request(_ request: SNRequest, didProduce result: SNResult) // 请求失败 optional func request(_ request: SNRequest, didFailWithError error: Error) // 请求完成 optional func requestDidComplete(_ request: SNRequest)&#125; 请求的结果数据为SNResult，这个是基础协议，真正将返回的对象是SNClassificationResult类型的，定义如下： 123456789101112131415open class SNClassificationResult : NSObject, SNResult &#123; // 分析出的类别 open var classifications: [SNClassification] &#123; get &#125; // 在音频中的时间范围 open var timeRange: CMTimeRange &#123; get &#125; // 返回指定标识符的类别 open func classification(forIdentifier identifier: String) -&gt; SNClassification?&#125;open class SNClassification : NSObject &#123; // 当前类别的标识符 open var identifier: String &#123; get &#125; // 可信度 open var confidence: Double &#123; get &#125;&#125; SoundAnalysis框架本身比较简单，我们再来看下分析请求类，SNRequest是请求类的基类，为了便于后续framework的升级，我们使用SNClassifySoundRequest类创建请求： 123456789101112open class SNClassifySoundRequest : NSObject, SNRequest &#123; // 模型对固定大小的音频块进行分析时的重叠量，影响分析准确性 open var overlapFactor: Double // 缓冲窗口的持续时间 open var windowDuration: CMTime // 设置一组类别，分析结果将从此组中选择 open var knownClassifications: [String] &#123; get &#125; // 使用自定义的模型进行分析 public init(mlModel: MLModel) // 使用内置模型进行分析 public init(classifierIdentifier: SNClassifierIdentifier)&#125; 最后Analyzer相关的类主要用来对请求进行控制，并决定要分析的音频。SoundAnalysis框架支持直接对音频文件进行分析，也支持对音频数据流进行分析，使用的类如下： 123456789101112131415161718192021222324252627282930313233// 分析音频文件open class SNAudioFileAnalyzer : NSObject &#123; // 构造方法 public init(url: URL) throws // 添加一个请求和对应的监听实例 open func add(_ request: SNRequest, withObserver observer: SNResultsObserving) throws // 移除一个请求 open func remove(_ request: SNRequest) // 移除所有请求 open func removeAllRequests() // 开启同步分析（会阻塞线程） open func analyze() // 异步进行分析 open func analyze(completionHandler: @escaping (Bool) -&gt; Void) // 异步分析 open func analyze() async -&gt; Bool // 取消分析任务 open func cancelAnalysis()&#125;// 分析音频流open class SNAudioStreamAnalyzer : NSObject &#123; // 构造方法 public init(format: AVAudioFormat) open func add(_ request: SNRequest, withObserver observer: SNResultsObserving) throws // 请求控制方法 open func remove(_ request: SNRequest) open func removeAllRequests() // 对数据流做分析 open func analyze(_ audioBuffer: AVAudioBuffer, atAudioFramePosition audioFramePosition: AVAudioFramePosition) // 完成数据流分析 open func completeAnalysis()&#125; 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（12）—— 自然语言之词句相似性分析","slug":"467iOS MachineLearning 系列（12）—— 自然语言之词句相似性分析","date":"2023-05-05T16:00:00.000Z","updated":"2023-05-06T07:26:59.290Z","comments":true,"path":"2023/05/06/467iOS MachineLearning 系列（12）—— 自然语言之词句相似性分析/","link":"","permalink":"http://huishao.cc/2023/05/06/467iOS MachineLearning 系列（12）—— 自然语言之词句相似性分析/","excerpt":"","text":"iOS MachineLearning 系列（12）—— 自然语言之词句相似性分析本篇文章将介绍如何使用NaturalLanguage框架来对词句的相似性进行分析。文本相似性的分析在实际开发中应用很多，比如我们可以通过查找与用户输入相似的词来进行内容推荐。 分析语句的相似性需要进行大量的训练，NaturalLanguage已经内置了许多语言的训练模型，使用非常方便。 1 - 文本相似性分析的示例需要创建NLEmbedding实例来进行词句的相似性分析。例如： 12let embedding = NLEmbedding.wordEmbedding(for: .english)!let embedding2 = NLEmbedding.sentenceEmbedding(for: .english)! 其中，使用wordEmbedding创建出的实例用来进行单词分析，sentenceEmbedding创建出的实例用来进行句子分析。其参数设置所分析的语言，需要注意，并非所有语言都支持进行相似性分析。 下面示例代码演示了如何对单词，句子的相似性进行分析，并能够自动根据传入的单词来进行相近的词的推荐： 12345678910111213141516171819202122232425262728let label = UILabel(frame: CGRect(x: 0, y: 100, width: view.frame.width, height: 500))label.numberOfLines = 0label.text = \"\"view.addSubview(label)let word = \"dog\"let word2 = \"cat\"let word3 = \"teacher\"// 计算单词间的矢量距离let distance = embedding.distance(between: word, and: word2)let distance2 = embedding.distance(between: word, and: word3)label.text = label.text!.appending(\"单词1：\\(word)\\n单词2：\\(word2)\\n单词3：\\(word3)\")label.text = label.text!.appending(\"\\n\\n单词1与单词2间的距离：\\(distance)\\n单词1与单词3间的距离：\\(distance2)\")// 获取相似的词embedding.enumerateNeighbors(for: word3, maximumCount: 5, using: &#123; item, distance in label.text = label.text!.appending(\"\\n与单词3相近的词：\\(item) - \\(distance)\") return true&#125;)let sen = \"Hello, Xiao.\"let sen2 = \"Hi, Xiao.\"let sen3 = \"My name is Xiao.\"// 计算句子间的矢量距离let distance3 = embedding2.distance(between: sen, and: sen2)let distance4 = embedding2.distance(between: sen, and: sen3)label.text = label.text!.appending(\"\\n\\n\\n句子1：\\(sen)\\n句子2：\\(sen2)\\n句子3：\\(sen3)\")label.text = label.text!.appending(\"\\n\\n句子1与句子2间的距离：\\(distance3)\\n句子1与句子3间的距离：\\(distance4)\") 计算出的矢量距离越大，标明词句间的差异越大，即相似性越差。效果如下图所示： 通常矢量距离小于1的词句相似性较高。取值范围为0-2之间。 2 - 关于NLEmbedding类要进行词句的相似性分析，需要NLEmbedding类来完成： 1234567891011121314151617181920212223242526272829303132333435363738open class NLEmbedding : NSObject &#123; // 创建分析单词的实例 open class func wordEmbedding(for language: NLLanguage) -&gt; NLEmbedding? open class func wordEmbedding(for language: NLLanguage, revision: Int) -&gt; NLEmbedding? // 创建分析句子的实例 open class func sentenceEmbedding(for language: NLLanguage) -&gt; NLEmbedding? open class func sentenceEmbedding(for language: NLLanguage, revision: Int) -&gt; NLEmbedding? // 判断词汇表是否包含参数字符串 open func contains(_ string: String) -&gt; Bool // 向量空间维数 open var dimension: Int &#123; get &#125; // 词汇表单词数量 open var vocabularySize: Int &#123; get &#125; // 所使用的语言 open var language: NLLanguage? &#123; get &#125; // 所使用的算法版本 open var revision: Int &#123; get &#125; // 获取所支持的算法版本 open class func supportedRevisions(for language: NLLanguage) -&gt; IndexSet open class func supportedSentenceEmbeddingRevisions(for language: NLLanguage) -&gt; IndexSet // 当前默认的算法版本 open class func currentRevision(for language: NLLanguage) -&gt; Int open class func currentSentenceEmbeddingRevision(for language: NLLanguage) -&gt; Int // 计算两个字符串之间的向量距离 public func distance(between firstString: String, and secondString: String, distanceType: NLDistanceType = .cosine) -&gt; NLDistance // 计算参数字符串的空间向量数据 public func vector(for string: String) -&gt; [Double]? // 获取相似的词句，maxCount控制最大返回个数 public func enumerateNeighbors(for string: String, maximumCount maxCount: Int, distanceType: NLDistanceType = .cosine, using block: (String, NLDistance) -&gt; Bool) public func neighbors(for string: String, maximumCount maxCount: Int, distanceType: NLDistanceType = .cosine) -&gt; [(String, NLDistance)] // 通过空间向量数据来获取相似的词句 public func enumerateNeighbors(for vector: [Double], maximumCount maxCount: Int, distanceType: NLDistanceType = .cosine, using block: (String, NLDistance) -&gt; Bool) public func neighbors(for vector: [Double], maximumCount maxCount: Int, distanceType: NLDistanceType = .cosine) -&gt; [(String, NLDistance)]&#125; 其中NLDistance是Double类型的一个别名。直接使用这些API实际上并不能很好的支持中文，NaturalLanguage也支持我们使用自定义的模型，关于模型的使用和训练，我们后面文章会再介绍。 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（11）—— 自然语言识别与文本分析","slug":"466iOS MachineLearning 系列（11）—— 自然语言识别与文本分析","date":"2023-05-04T16:00:00.000Z","updated":"2023-05-05T08:44:05.911Z","comments":true,"path":"2023/05/05/466iOS MachineLearning 系列（11）—— 自然语言识别与文本分析/","link":"","permalink":"http://huishao.cc/2023/05/05/466iOS MachineLearning 系列（11）—— 自然语言识别与文本分析/","excerpt":"","text":"iOS MachineLearning 系列（11）—— 自然语言识别与单词分析在上一篇文章中，我们介绍了使用NaturalLanguage框架来进行自然语言的拆解，可以将一段文本按照单词，句子或段落的模式进行拆解。并且，在进行拆解时，其可以自动的识别所使用的语言。 其实，NaturalLanguage框架本身也提供了语言识别的能力，其可以分析一段文本所对应的语言，同样对于包含多种语言的文本，其可以分析出各种语言的占比。语言识别是其他高级自然语言处理任务的基础，本篇文章还将介绍NaturalLanguage关于文本分析的能力，其能够对文本中的人名，地名和组织名进行识别，也可以对词性进行分析，如动词，名词。甚至我们还可以分析文本的积极或消极程度来推测内容的取向，从而帮助开发者开发出更加智能的应用。 1 - 语言识别NLLanguageRecognizer类用来进行语言识别，其可以对输入的文本所使用的语言进行推断，使用非常简单。 首先初始化一个NLLanguageRecognizer实例，如下： 1let recognizer = NLLanguageRecognizer() 可以定义一些示例的字符串来测试识别能力，如： 123let string1 = \"世界，你好！\"let string2 = \"Hello World!\"let string3 = \"こんにちは中国\" 调用NLLanguageRecognizer实例的processString方法即可对字符串进行解析，这个方法是同步的，解析完成后，通过dominantLanguage属性即可获取到这段文本所使用的最接近的语言，例如上面的示例字符串中，string1和string2是比较单纯的中文和英文，string3是日语，日语中很多字是和中文一样的，因此对其进行识别可能会出现误差，我们也可以使用languageHypotheses方法来获取可能识别出的语言，返回的结果中会对识别出的每种语言的可信度进行标记。上面的字符串识别效果如下： 其中，zh-Hant为汉语，en为英语，ja为日语。 NLLanguageRecognizer类的使用很简单，其中封装属性和方法列举如下： 1234567891011121314open class NLLanguageRecognizer : NSObject &#123; // 类方法，直接对字符串进行主要语言识别 open class func dominantLanguage(for string: String) -&gt; NLLanguage? // 对一个字符串进行识别任务 open func processString(_ string: String) // 重置状态 open func reset() // 最近一次识别任务的结果 open var dominantLanguage: NLLanguage? &#123; get &#125; // 设置说支持的语言，可以设置只支持某些语言的识别 open var languageConstraints: [NLLanguage] // 获取所有可能的语言，参数可以设置最多返回的结果个数，结果中value约接近1的语言可信度越高 public func languageHypotheses(withMaximum maxHypotheses: Int) -&gt; [NLLanguage : Double]&#125; NLLanguag是描述语言的结构体，支持的语言列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118extension NLLanguage &#123; // 不确定的 public static let undetermined: NLLanguage // 阿姆哈拉语 public static let amharic: NLLanguage // 阿拉伯语 public static let arabic: NLLanguage // 亚美尼亚 public static let armenian: NLLanguage // 孟加拉语 public static let bengali: NLLanguage // 保加利亚 public static let bulgarian: NLLanguage // 缅甸语 public static let burmese: NLLanguage // 加泰罗尼亚语 public static let catalan: NLLanguage // 切罗基 public static let cherokee: NLLanguage // 克罗地亚 public static let croatian: NLLanguage // 捷克 public static let czech: NLLanguage // 丹麦语 public static let danish: NLLanguage // 荷兰 public static let dutch: NLLanguage // 英语 public static let english: NLLanguage // 芬兰语 public static let finnish: NLLanguage // 法语 public static let french: NLLanguage // 格鲁吉亚 public static let georgian: NLLanguage // 德语 public static let german: NLLanguage // 希腊语 public static let greek: NLLanguage // 古吉拉特语 public static let gujarati: NLLanguage // 希伯来语 public static let hebrew: NLLanguage // 印地语 public static let hindi: NLLanguage // 匈牙利 public static let hungarian: NLLanguage // 冰岛语 public static let icelandic: NLLanguage // 印度尼西亚语 public static let indonesian: NLLanguage // 意大利语 public static let italian: NLLanguage // 日语 public static let japanese: NLLanguage // 埃纳德语 public static let kannada: NLLanguage // 高棉语 public static let khmer: NLLanguage // 韩国语 public static let korean: NLLanguage // 老挝 public static let lao: NLLanguage // 马来语 public static let malay: NLLanguage // 马拉雅拉姆语 public static let malayalam: NLLanguage // 马拉地语 public static let marathi: NLLanguage // 蒙古语 public static let mongolian: NLLanguage // 挪威语 public static let norwegian: NLLanguage // 奥里亚语 public static let oriya: NLLanguage // 波斯语 public static let persian: NLLanguage // 波兰语 public static let polish: NLLanguage // 葡萄牙语 public static let portuguese: NLLanguage // 旁遮普语 public static let punjabi: NLLanguage // 罗马尼亚语 public static let romanian: NLLanguage // 俄语 public static let russian: NLLanguage // 简体中文 public static let simplifiedChinese: NLLanguage // 锡兰语 public static let sinhalese: NLLanguage // 斯洛伐克语 public static let slovak: NLLanguage // 西班牙语 public static let spanish: NLLanguage // 瑞典语 public static let swedish: NLLanguage // 泰米尔语 public static let tamil: NLLanguage // 泰卢固语 public static let telugu: NLLanguage // 泰语 public static let thai: NLLanguage // 藏语 public static let tibetan: NLLanguage // 繁体中文 public static let traditionalChinese: NLLanguage // 土耳其语 public static let turkish: NLLanguage // 乌克兰语 public static let ukrainian: NLLanguage // 乌尔都语 public static let urdu: NLLanguage // 越南语 public static let vietnamese: NLLanguage // 哈萨克语 public static let kazakh: NLLanguage&#125; 2 - 文本分析文本分析支持对单词进行分析，也支持对句子和段落进行分析。针对不同的需求场景，可以使用不同的方案来分析。在NaturalLanguage框架中，使用NLTagScheme结构体来定义分析方案，支持的方案列举如下： 123456789101112131415161718extension NLTagScheme &#123; // 按元素类型进行标记 可以分析出单词，标点符号，空白符 public static let tokenType: NLTagScheme // 比tokenType方案更进一步，还能分析出词性，如动词，名词等 public static let lexicalClass: NLTagScheme // 名称分析方案，如分析出人名，地名，组织名 public static let nameType: NLTagScheme // nameType和lexicalClass的聚合 public static let nameTypeOrLexicalClass: NLTagScheme // 分析词干，如reading分析词干为read public static let lemma: NLTagScheme // 标记元素的语言 public static let language: NLTagScheme // 标记元素的ISO规范的脚本 public static let script: NLTagScheme // 分析内容的消极/积极 public static let sentimentScore: NLTagScheme&#125; 文本分析的结果会被封装为NLTag结构体，此结构体会包含一个字符串类型的原始值，对于lemma，language，script，sentimentScore分析方案，其结果会直接包装成字符串，其他的分析方案的结果则进行了定义，如下： 123456789101112131415161718192021222324252627282930313233extension NLTag &#123; // tokenType方案对应的结果 public static let word: NLTag // 单词 public static let punctuation: NLTag // 标点 public static let whitespace: NLTag // 空白符 public static let other: NLTag // 其他 // lexicalClass方案对应的结果 public static let noun: NLTag // 名词 public static let verb: NLTag // 动词 public static let adjective: NLTag // 形容词 public static let adverb: NLTag // 副词 public static let pronoun: NLTag // 代词 public static let determiner: NLTag // 限定词 public static let particle: NLTag // 小品词 public static let preposition: NLTag // 介词 public static let number: NLTag // 数词 public static let conjunction: NLTag // 连词 public static let interjection: NLTag // 感叹词 public static let classifier: NLTag // 分类词 public static let idiom: NLTag // 惯用语 public static let otherWord: NLTag // 其他单词 public static let sentenceTerminator: NLTag // 语句终止符 public static let openQuote: NLTag // 开引号 public static let closeQuote: NLTag // 闭引号 public static let openParenthesis: NLTag // 开括号 public static let closeParenthesis: NLTag // 闭括号 public static let wordJoiner: NLTag // 连字符 public static let dash: NLTag // 破折号 public static let otherPunctuation: NLTag // 其他标点 public static let paragraphBreak: NLTag // 段落中断 public static let otherWhitespace: NLTag // 其他空白符&#125; 下面，我们来对每种分析方案进行介绍。 tokenTypetokenType方法非常简单，直接对元素类型进行简单分类，效果如下图所示： lexicalClasslexicalClass方法相比tokenType更加高级，能够更加细致的单词进行分类，但是需要注意，lexicalClass方案只对英文支持较好。效果如下： nameType此方案用来解析文本中的组织名，地名，人名。同样对英文支持较好，如下： 可以看到，其中国家的名字，人名和城市名都正确的解析了出来。 nameTypeOrLexicalClass此方案无需做过多的解释，只是两种方法的聚合。 lemma此方案用来分析词干，主要也是针对英文，效果如下： language与script这两个方案都是分析元素的语言相关。 sentimentScore此方案只能用来进行句子和段落的分析，可以推测出文案内容的积极程度，结果越接近1，标明内容的积极性越高，越接近-1表示越消极。例如： 可以看到其对积极和消极的判定还是比较准确，通过测试，目前也只针对英文有效。 最后，我们再来介绍下用来触发文本分析的NLTagger类，在进行分析前，首先需要实例化此类： 1let tagger = NLTagger(tagSchemes: [.lexicalClass, .tokenType, .lemma, .nameType, .script, .nameTypeOrLexicalClass, .sentimentScore, .language]) 此实例化方法中传入的参数表示要支持的分析方案。使用如下代码来触发分析： 12345tagger.string = stringtagger.enumerateTags(in: string.startIndex ..&lt; string.endIndex, unit: .paragraph, scheme: .sentimentScore) &#123; tag, range in resultLabel.text = (resultLabel.text ?? \"\").appending(\"【[\\(string[range])]-[\\(tag?.rawValue ?? \"\")]】\") return true&#125; NLTagger类定义如下： 1234567891011121314151617181920212223242526272829303132333435open class NLTagger : NSObject &#123; // 初始化方法，设置支持的分析方案 public init(tagSchemes: [NLTagScheme]) open var tagSchemes: [NLTagScheme] &#123; get &#125; // 要进行分析的字符串 open var string: String? // 获取支持的方案（对不同的拆解方式和语言，所能支持的方案不同） open class func availableTagSchemes(for unit: NLTokenUnit, language: NLLanguage) -&gt; [NLTagScheme] // 输入文本的主语言 open var dominantLanguage: NLLanguage? &#123; get &#125; // 使用自定义模型来定义方案 open func setModels(_ models: [NLModel], forTagScheme tagScheme: NLTagScheme) open func models(forTagScheme tagScheme: NLTagScheme) -&gt; [NLModel] open func setGazetteers(_ gazetteers: [NLGazetteer], for tagScheme: NLTagScheme) open func gazetteers(for tagScheme: NLTagScheme) -&gt; [NLGazetteer] // 如果availableTagSchemes没有支持的方案，可能是有资源为加载到设备，使用此方法尝试请求资源 open class func requestAssets(for language: NLLanguage, tagScheme: NLTagScheme, completionHandler: @escaping (NLTagger.AssetsResult, Error?) -&gt; Void) open class func requestAssets(for language: NLLanguage, tagScheme: NLTagScheme) async throws -&gt; NLTagger.AssetsResult // 获取元素所在字符串范围 public func tokenRange(at index: String.Index, unit: NLTokenUnit) -&gt; Range&lt;String.Index&gt; public func tokenRange(for range: Range&lt;String.Index&gt;, unit: NLTokenUnit) -&gt; Range&lt;String.Index&gt; // 对某个位置的元素进行解析 public func tag(at index: String.Index, unit: NLTokenUnit, scheme: NLTagScheme) -&gt; (NLTag?, Range&lt;String.Index&gt;) // 对某个位置的元素进行解析，返回肯能的结果 public func tagHypotheses(at index: String.Index, unit: NLTokenUnit, scheme: NLTagScheme, maximumCount: Int) -&gt; ([String : Double], Range&lt;String.Index&gt;) // 进行完整解析 public func enumerateTags(in range: Range&lt;String.Index&gt;, unit: NLTokenUnit, scheme: NLTagScheme, options: NLTagger.Options = [], using block: (NLTag?, Range&lt;String.Index&gt;) -&gt; Bool) // 进行范围解析 public func tags(in range: Range&lt;String.Index&gt;, unit: NLTokenUnit, scheme: NLTagScheme, options: NLTagger.Options = []) -&gt; [(NLTag?, Range&lt;String.Index&gt;)] // 手动设置语言 public func setLanguage(_ language: NLLanguage, range: Range&lt;String.Index&gt;) public func setOrthography(_ orthography: NSOrthography, range: Range&lt;String.Index&gt;)&#125; 其中availableTagSchemes获取到的可用方案不一定准确，有可能是资源未加载，使用requestAssets可以请求资源，如果最终不能支持，可以从其返回的结果判断： 12345678public enum AssetsResult : Int, @unchecked Sendable &#123; // 可用 case available = 0 // 不可用 case notAvailable = 1 // 异常 case error = 2&#125; enumerateTags方法中有一个options参数，此参数可以对分析的过程进行配置，支持的配置项如下： 1234567891011121314public struct Options : OptionSet, @unchecked Sendable &#123; // 忽略单词类型标记 public static var omitWords: NLTagger.Options &#123; get &#125; // 忽略标点类型标记 public static var omitPunctuation: NLTagger.Options &#123; get &#125; // 忽略空白符标记 public static var omitWhitespace: NLTagger.Options &#123; get &#125; // 忽略其他类型元素标记 public static var omitOther: NLTagger.Options &#123; get &#125; // 拼接多单词的名称 public static var joinNames: NLTagger.Options &#123; get &#125; // 拼接缩进 public static var joinContractions: NLTagger.Options &#123; get &#125;&#125; 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（10）—— 自然语言分析之文本拆解","slug":"465iOS MachineLearning 系列（10）—— 自然语言分析之文本拆解","date":"2023-05-03T16:00:00.000Z","updated":"2023-05-04T09:19:53.552Z","comments":true,"path":"2023/05/04/465iOS MachineLearning 系列（10）—— 自然语言分析之文本拆解/","link":"","permalink":"http://huishao.cc/2023/05/04/465iOS MachineLearning 系列（10）—— 自然语言分析之文本拆解/","excerpt":"","text":"iOS MachineLearning 系列（10）—— 自然语言分析之文本拆解本系列的前几篇文章介绍了iOS中有关图像和视频处理的API，视觉处理主要有Vision框架负责，本篇起，将介绍在iOS中Machine Learning领域相关的自然语言处理框架：NaturalLanguage。 1 - 简介NaturalLanguage是iOS种提供的一种处理自然语言的内置框架，使用它不会使应用的包体积增大，不会为应用带来额外的负担，且可以实现非常强大的语言处理功能。 NaturalLanguage默认支持多种语言，拥有如下能力： 检测一段文本所使用的语言。 将一段文本按照词组，句子，段落进行拆解。 进行词性分析。 进行语义分析。 本篇，我们主要介绍其文本拆解能力，及如何使用这些API。 2 - 拆解文本我们先从一个简单的示例来看如何使用NaturalLanguage框架中的API进行文本拆解。 首先准备一段测试文本，如下： 最近，随着Chat-GPT4的发布，人工智能相关的资讯和话题再次火热了起来😄。 有了人工智能的加持，对人们的生活以及各行各业的工作都将带来效率的极大提升。目前，各种大模型的发布层出不穷。这些大模型虽然功能非常强大（如文本理解，绘图等），但对于个人来说，要跑起这样一个模型来对外提供服务还是比较困难的，其需要有非常强大的算力支持。 这段文案有两个段落组成。我们可以先尝试对其内的单词进行拆解。 使用NLTokenizer来解析文本，定义NLTokenizer实例如下： 1let tokenizer = NLTokenizer(unit: .word) 其参数unit确定要解析的元素类型，枚举如下： 12345678910public enum NLTokenUnit : Int, @unchecked Sendable &#123; // 以单词为基础进行拆解 case word = 0 // 以句子为基础进行拆解 case sentence = 1 // 以段落为基础进行拆解 case paragraph = 2 // 以文档为基础，此模式下会返回原字符串 case document = 3 &#125; 调用如下的方法即可进行拆解任务： 12345tokenizer.enumerateTokens(in: string.startIndex ..&lt; string.endIndex) &#123; range, attribute in let word = string[range] self.showWord(string: String(word), type: attribute) return true&#125; 在回调block中，如果需要停止解析，返回false即可。解析的结果会将元素属性，所在原字符串中的范围进行返回。其中元素属性结构体定义如下： 1234567891011public struct Attributes : OptionSet, @unchecked Sendable &#123; public init(rawValue: UInt) // 包含数值 public static var numeric: NLTokenizer.Attributes &#123; get &#125; // 包含符号 public static var symbolic: NLTokenizer.Attributes &#123; get &#125; // 包含表情 public static var emoji: NLTokenizer.Attributes &#123; get &#125;&#125; 如果上面定义的3个静态值都没有命中，则表示当前元素只包含简单文本。 showWord方法简单实现如下： 12345678910func showWord(string: String, type: NLTokenizer.Attributes) &#123; var t = \"\" if type.contains(.emoji) &#123; t.append(\"[emoji]\") &#125; if type.contains(.numeric) &#123; t.append(\"[num]\") &#125; if type.contains(.symbolic) &#123; t.append(\"[sym]\") &#125; if t.isEmpty &#123; t = \"txt\" &#125; resultLabel.text = (resultLabel.text ?? \"\").appending(\"【\\(string) - \\(t)】\")&#125; 分别以单词，句子和段落的模式进行拆解，效果如下所示： 可以看到，整体来说NaturalLanguage对于中文的解析能力还是比较强大的。 3 - 再看NLTokenizer 类NLTokenizer类专门用来对文本进行拆解，本身比较简单。其中的NLTokenUnit用来设置拆解模式，内部Attributes结构体可以标记出所拆解出的元素所包含的属性。NLTokenizer类本身定义如下： 123456789101112131415161718open class NLTokenizer : NSObject &#123; // 初始化方法，设置拆解模式 public init(unit: NLTokenUnit) // 拆解单元模式 open var unit: NLTokenUnit &#123; get &#125; // 进行处理的字符串 open var string: String? // 设置文本所使用的语言，如果不设置可以自行解析 open func setLanguage(_ language: NLLanguage) // 解析文本某个位置的元素 public func tokenRange(at index: String.Index) -&gt; Range&lt;String.Index&gt; // 解析文本某个范围的元素 public func tokenRange(for range: Range&lt;String.Index&gt;) -&gt; Range&lt;String.Index&gt; // 枚举出所有元素 public func enumerateTokens(in range: Range&lt;String.Index&gt;, using block: (Range&lt;String.Index&gt;, NLTokenizer.Attributes) -&gt; Bool) // 解析所有元素 public func tokens(for range: Range&lt;String.Index&gt;) -&gt; [Range&lt;String.Index&gt;]&#125; 拆解往往是自然语言分析的第一步，通常我们会将长文本进行拆解，之后在对每个元素进行语言类型分析或语义分析，以及词汇的词性分析等，后面的文章会具体再做介绍。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（8）—— 图片热区分析","slug":"463iOS MachineLearning 系列（8）—— 图片热区分析","date":"2023-04-28T16:00:00.000Z","updated":"2023-04-27T10:43:25.165Z","comments":true,"path":"2023/04/29/463iOS MachineLearning 系列（8）—— 图片热区分析/","link":"","permalink":"http://huishao.cc/2023/04/29/463iOS MachineLearning 系列（8）—— 图片热区分析/","excerpt":"","text":"iOS MachineLearning 系列（8）—— 图片热区分析对图片进行热区分析可以帮助我们图片中可能会受关注的区域，也可以获取到图片中需要被关注的事物的区域。 Vision框架中提供了两种热区分析的方式。 关注区分析 对象区分析 1 - 关注区分析关注区分析请求使用VNGenerateAttentionBasedSaliencyImageRequest创建，此类没有特殊需要配置的，其继承自VNImageBasedRequest类，因此可以直接使用VNImageRequestHandler句柄来进行发起。返回的分析结果为VNSaliencyImageObservation对象，定义如下： 1234open class VNGenerateAttentionBasedSaliencyImageRequest : VNImageBasedRequest &#123; // 关注区对象 open var results: [VNSaliencyImageObservation]? &#123; get &#125;&#125; VNSaliencyImageObservatio定义如下： 123open class VNSaliencyImageObservation : VNPixelBufferObservation &#123; open var salientObjects: [VNRectangleObservation]? &#123; get &#125;&#125; 下图展示了关注区分析的效果： 可以看到，分析出的关注区基本是图片中内容最丰富的区域，也是我们在观察图片时最先关注到的。需要注意，分析出的关注区不一定会完整的包含图片中的物体。 2 - 物体区分析物体区分析与关注区分析唯一的区别在于请求的创建，物体区分析使用VNGenerateObjectnessBasedSaliencyImageRequest类进行创建。下图演示了物体区分析的效果。 可以看到，针对猫狗的那张图片，关注区分析得到的结果是相对居中的位置，物体区分析得到的结果会完整的包含猫狗的边界。 在实际应用中，我们可以通过这些分析能力来对图像的部分进行视觉增强。 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo 备注：Vision框架中的很多AI能力可能无法在模拟器上很好的进行。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（9）—— 人物蒙版图生成","slug":"464iOS MachineLearning 系列（9）—— 人物蒙版图生成","date":"2023-04-28T16:00:00.000Z","updated":"2023-04-27T15:14:05.949Z","comments":true,"path":"2023/04/29/464iOS MachineLearning 系列（9）—— 人物蒙版图生成/","link":"","permalink":"http://huishao.cc/2023/04/29/464iOS MachineLearning 系列（9）—— 人物蒙版图生成/","excerpt":"","text":"iOS MachineLearning 系列（9）—— 人物蒙版图生成人物蒙版图能力是Vision框架在iOS 15中新增的功能，这个功能可以将图片中的人物按照轮廓生成无光蒙版。无光蒙版在实际业务中非常有用，使用此蒙版可以方便的将人物从图片中提取出来，然后和其他的背景图进行合成。 1 - 人物蒙版的提取首先，人物蒙版的提取非常简单，使用VNGeneratePersonSegmentationRequest创建蒙版分析请求，如下： 12345678private lazy var personRequest: VNGeneratePersonSegmentationRequest = &#123; let request = VNGeneratePersonSegmentationRequest &#123; request, error in DispatchQueue.main.async &#123; self.drawTask(request: request as! VNGeneratePersonSegmentationRequest) &#125; &#125; return request&#125;() 使用VNImageRequestHandler来触发请求即可： 1234567// 要分析的图片资源let image = UIImage(named: \"image7\")!// 图像分析请求lazy var imageRequestHandler = VNImageRequestHandler(ciImage: CIImage(cgImage: image.cgImage!), orientation: .up, options: [:]) 请求的结果VNPixelBufferObservation中会封装蒙版图片CVPixelBuffer数据，如下： 123456open class VNPixelBufferObservation : VNObservation &#123; // 分析出的蒙版数据 open var pixelBuffer: CVPixelBuffer &#123; get &#125; // 分析所使用的模型 open var featureName: String? &#123; get &#125;&#125; 处理请求结果如下： 1234567891011121314151617181920private func drawTask(request: VNGeneratePersonSegmentationRequest) &#123; for result in request.results ?? [] &#123; // 创建CIImage实例 let ciImage = CIImage(cvPixelBuffer: result.pixelBuffer) // 默认返回的蒙版为黑白两色，这里讲所有黑色替换成透明色 let filter = CIFilter(name: &quot;CIMaskToAlpha&quot;, parameters: [kCIInputImageKey: ciImage]) guard let outputImage = filter?.outputImage else &#123; return &#125; let context = CIContext(options: nil) let cgImage = context.createCGImage(outputImage, from: outputImage.extent) let uiImage = UIImage(cgImage: cgImage!) let v = UIImageView(image: uiImage) v.frame = imageView.frame v.backgroundColor = .black v.frame.origin.y += imageView.frame.height v.image = uiImage view.addSubview(v) &#125;&#125; 效果如下图： 2 - 进行人物提取获取到了蒙版，提取人物将很简单，修改上述代码如下： 123456789101112131415161718192021222324252627282930313233343536private func drawTask(request: VNGeneratePersonSegmentationRequest) &#123; for result in request.results ?? [] &#123; print(result.pixelBuffer) let ciImage = CIImage(cvPixelBuffer: result.pixelBuffer) let filter = CIFilter(name: \"CIMaskToAlpha\", parameters: [kCIInputImageKey: ciImage]) guard let outputImage = filter?.outputImage else &#123; return &#125; let context = CIContext(options: nil) let cgImage = context.createCGImage(outputImage, from: outputImage.extent) let uiImage = UIImage(cgImage: cgImage!) let v = UIImageView(image: uiImage) v.frame = imageView.frame v.backgroundColor = .blue v.frame.origin.y += imageView.frame.height v.image = uiImage view.addSubview(v) let v2 = UIImageView(image: image) v2.frame = v.frame v2.frame.origin.y += v.frame.height let mask = UIImageView(image: uiImage) mask.frame = CGRect(x: 0, y: 0, width: v2.frame.size.width, height: v2.frame.size.height) mask.backgroundColor = .clear // 使用蒙版截取 v2.mask = mask view.addSubview(v2) &#125;&#125; 效果如下： 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo VNGeneratePersonSegmentationRequest结合CIFilter的使用，可以方便的进行背景合成。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（7）—— 图片相似度分析","slug":"462iOS MachineLearning 系列（7）—— 图片相似度分析","date":"2023-04-27T16:00:00.000Z","updated":"2023-04-27T08:42:27.885Z","comments":true,"path":"2023/04/28/462iOS MachineLearning 系列（7）—— 图片相似度分析/","link":"","permalink":"http://huishao.cc/2023/04/28/462iOS MachineLearning 系列（7）—— 图片相似度分析/","excerpt":"","text":"iOS MachineLearning 系列（7）—— 图片相似度分析图片相似度分析是Vision框架中提供的高级功能。其本质是计算图片的特征值，通过特征值的比较来计算出图片特征差距，从而可以获取到图片的相似程度。在实际应用中，图片的相似度分析有着广泛的应用。如人脸对比识别，相似物品的搜索和识别等。 进行图片相似度计算前，首先需要对图片的特征值进行分析。使用VNGenerateImageFeaturePrintRequest类创建图片特征分析请求。定义如下： 123456open class VNGenerateImageFeaturePrintRequest : VNImageBasedRequest &#123; // 图片的裁切和缩放配置 open var imageCropAndScaleOption: VNImageCropAndScaleOption // 结果列表 open var results: [VNFeaturePrintObservation]? &#123; get &#125;&#125; VNFeaturePrintObservatio结果实例中封装了特征数据： 12345678910open class VNFeaturePrintObservation : VNObservation &#123; // 特征类型 open var elementType: VNElementType &#123; get &#125; // 特征元素数量 open var elementCount: Int &#123; get &#125; // 特征数据 open var data: Data &#123; get &#125; // 进行差距比较 open func computeDistance(_ outDistance: UnsafeMutablePointer&lt;Float&gt;, to featurePrint: VNFeaturePrintObservation) throws&#125; 其中computeDistance方法即用来进行两个分析结果的特征差距计算。对于完全一样的图片，计算的差距为0，差距越大，表明图片的相似度越小。 下面提供了完整的Demo代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import UIKitimport Visionclass ImageFeatureViewController: UIViewController &#123; let image1 = UIImage(named: \"cat1\")! let image2 = UIImage(named: \"cat2\")! let image3 = UIImage(named: \"dog1\")! let image4 = UIImage(named: \"dog2\")! lazy var imageView1 = UIImageView(image: image1) lazy var imageView2 = UIImageView(image: image2) lazy var imageView3 = UIImageView(image: image3) lazy var imageView4 = UIImageView(image: image4) override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .white view.addSubview(imageView1) view.addSubview(imageView2) view.addSubview(imageView3) view.addSubview(imageView4) let width = (self.view.frame.width - 60) / 2 let h1 = width / (image1.size.width / image1.size.height) let h2 = width / (image2.size.width / image2.size.height) let h3 = width / (image3.size.width / image3.size.height) let h4 = width / (image4.size.width / image4.size.height) imageView1.frame = CGRect(x: 20, y: 100, width: width, height: h1) imageView2.frame = CGRect(x: width + 40, y: 100, width: width, height: h2) imageView3.frame = CGRect(x: 20, y: max(h1, h2) + 120, width: width, height: h3) imageView4.frame = CGRect(x: width + 40, y: max(h1, h2) + 120, width: width, height: h4) // 进行特征值分析 sendRequest(image: image1, number: 1) sendRequest(image: image2, number: 2) sendRequest(image: image3, number: 3) sendRequest(image: image4, number: 4) &#125; func sendRequest(image: UIImage, number: Int) &#123; let handler = VNImageRequestHandler(cgImage: image.cgImage!, orientation: .up) let request = VNGenerateImageFeaturePrintRequest &#123; result, error in guard error == nil else &#123; print(error!) return &#125; let r = result as! VNGenerateImageFeaturePrintRequest if number == 1 &#123; self.result1 = r.results?.first &#125; if number == 2 &#123; self.result2 = r.results?.first &#125; if number == 3 &#123; self.result3 = r.results?.first &#125; if number == 4 &#123; self.result4 = r.results?.first &#125; if let result1 = self.result1, let result2 = self.result2, let result3 = self.result3, let result4 = self.result4 &#123; // 进行相似性对比 var distance12 = Float(0) try! result1.computeDistance(&amp;distance12, to: result2) var distance13 = Float(0) try! result1.computeDistance(&amp;distance13, to: result3) var distance34 = Float(0) try! result3.computeDistance(&amp;distance34, to: result4) print(\"图1与图2相似差距:\", distance12) print(\"图1与图3相似差距:\", distance13) print(\"图3与图4相似差距:\", distance34) DispatchQueue.main.async &#123; let l = UILabel() l.text = \"图1与图2相似差距:\\(distance12)\\n图1与图3相似差距:\\(distance13)\\n图3与图4相似差距:\\(distance34)\" l.font = .boldSystemFont(ofSize: 22) self.view.addSubview(l) l.frame = CGRect(x: 0, y: max(self.imageView3.frame.height, self.imageView4.frame.height) + self.imageView3.frame.origin.y, width: self.view.frame.width, height: 100) l.numberOfLines = 0 &#125; &#125; &#125; try? handler.perform([request]) &#125; var result1: VNFeaturePrintObservation? var result2: VNFeaturePrintObservation? var result3: VNFeaturePrintObservation? var result4: VNFeaturePrintObservation?&#125; 可以看到，上面两只猫的相似差距为12，猫和狗的相似差距为26，两只狗的相似差距为8。 完整的示例代码可以在如下地址找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（6）—— 视频中的物体轨迹分析","slug":"461iOS MachineLearning 系列（6）—— 视频中的物体轨迹分析","date":"2023-04-26T16:00:00.000Z","updated":"2023-04-27T04:50:45.936Z","comments":true,"path":"2023/04/27/461iOS MachineLearning 系列（6）—— 视频中的物体轨迹分析/","link":"","permalink":"http://huishao.cc/2023/04/27/461iOS MachineLearning 系列（6）—— 视频中的物体轨迹分析/","excerpt":"","text":"iOS MachineLearning 系列（6）—— 视频中的物体轨迹分析轨迹分析是比物体追踪更上层的一种应用。Vision框架中提供了检测视频中多个物体的运动轨迹等能力，在健身，体育类应用中非常有用。 轨迹检测需要一系列的运动状态来分析，因此这类的请求是有状态的，有状态的请求可以被句柄多次调用，其会自动记录之前的状态，从而进行轨迹路径分析。需要注意，在进行轨迹检测时，要保证摄像机的相对静止，镜头的移动可能会影响检测的准确性。 在日常生活中，我们可以使用轨迹检测来进行投球的矫正，球类落点的推测等等。 1 - 解析视频中的物体飞行轨迹轨迹检测需要保存状态，因此其传入的图像分析参数需要为包含CMTime信息的CMSampleBuffer数据。对于一个视频文件，我们首先要做的是将其中的图像帧解析出来，即获取到CMSampleBuffer数据。示例代码如下： 12345678910111213141516171819202122232425262728293031323334func detectTrajectories() &#123; // 视频资源url let videoURL = URL(fileURLWithPath: Bundle.main.path(forResource: \"video2\", ofType: \".mov\")!) // 读取视频资源 let asset = AVAsset(url: videoURL) guard let videoTrack = asset.tracks(withMediaType: .video).first else &#123; return &#125; // 获取帧率 let frameRate = videoTrack.nominalFrameRate // 获取总时长 let frameDuration = CMTime(seconds: 1 / Double(frameRate), preferredTimescale: CMTimeScale(NSEC_PER_SEC)) // 解析参数 let assetReaderOutputSettings: [String: Any] = [ kCVPixelBufferPixelFormatTypeKey as String: kCVPixelFormatType_32BGRA ] // 解析输出类实例 let assetReaderOutput = AVAssetReaderTrackOutput(track: videoTrack, outputSettings: assetReaderOutputSettings) // 创建视频reader实例 let assetReader = try! AVAssetReader(asset: asset) // 添加输出对象 assetReader.add(assetReaderOutput) // 开始解析 if assetReader.startReading() &#123; // 读取帧 while let sampleBuffer = assetReaderOutput.copyNextSampleBuffer() &#123; autoreleasepool &#123; if CMSampleBufferDataIsReady(sampleBuffer) &#123; let timestamp = CMSampleBufferGetPresentationTimeStamp(sampleBuffer) // 进行轨迹分析 processFrame(sampleBuffer, atTime: timestamp, withDuration:frameDuration) &#125; &#125; &#125; &#125;&#125; processFram方法进行轨迹分析，实现如下： 123456func processFrame(_ sampleBuffer: CMSampleBuffer, atTime time : CMTime, withDuration duration : CMTime) &#123; // 创建句柄 let handler = VNImageRequestHandler(cmSampleBuffer: sampleBuffer, orientation: .up) // 发起分析请求 try? handler.perform([request])&#125; request对象的构建如下： 123456789lazy var request: VNDetectTrajectoriesRequest = &#123; let req = VNDetectTrajectoriesRequest(frameAnalysisSpacing:.zero, trajectoryLength: 10) &#123; result, error in if let error &#123; print(error) &#125; self.handleResult(request: result as! VNDetectTrajectoriesRequest) &#125; return req&#125;() 这里的参数后面会详细解释。 在示例中，我们可以添加一个AVPlayer来播放原视频，然后将分析出的轨迹绘制到视频对应的位置上进行对比。handleResult方法示例如下： 123456789101112131415161718192021func handleResult(request: VNDetectTrajectoriesRequest) &#123; for res in request.results ?? [] &#123; // 校正后的轨迹点 let points = res.projectedPoints for p in points &#123; DispatchQueue.main.async &#123; let v = UIView() // 视频宽高比 let scale = self.image.size.width / self.image.size.height let width = self.view.frame.width let height = width / scale let size = CGSize(width: width, height:height) v.backgroundColor = .red // 播放器充满页面，居中播放视频的y轴偏移 let offsetY = self.view.frame.height / 2 - height / 2 v.frame = CGRect(x: p.x * size.width, y: (1 - p.y) * size.height + offsetY, width: 4, height: 4) self.view.addSubview(v) &#125; &#125; &#125;&#125; 轨迹分析效果如下所示： 2 - VNDetectTrajectoriesRequest与VNTrajectoryObservation 类VNDetectTrajectoriesRequest类一种有状态的分析请求类，继承自VNStatefulRequest，VNDetectTrajectoriesRequest定义如下： 123456789101112131415161718192021open class VNDetectTrajectoriesRequest : VNStatefulRequest &#123; // 构造方法 // frameAnalysisSpacing参数设置采样间隔 // trajectoryLength设置确定一条轨迹的点数 最小为5 public init(frameAnalysisSpacing: CMTime, trajectoryLength: Int, completionHandler: VNRequestCompletionHandler? = nil) // 轨迹点数 open var trajectoryLength: Int &#123; get &#125; // 设置要检测的对象的最小半径 open var objectMinimumNormalizedRadius: Float open var minimumObjectSize: Float // 设置要检测对象的最大半径 open var objectMaximumNormalizedRadius: Float open var maximumObjectSize: Float // 检测的目标帧的时间 open var targetFrameTime: CMTime // 分析结果 open var results: [VNTrajectoryObservation]? &#123; get &#125;&#125; VNTrajectoryObservatio类是轨迹分析的结果类，其内封装了组成轨迹的点。定义如下： 12345678910open class VNTrajectoryObservation : VNObservation &#123; // 检测出的未处理前的原始点 open var detectedPoints: [VNPoint] &#123; get &#125; // 矫正后的轨迹点 open var projectedPoints: [VNPoint] &#123; get &#125; // 描述轨迹的抛物线方程 open var equationCoefficients: simd_float3 &#123; get &#125; // 测量的物体的半径平均值 open var movingAverageRadius: CGFloat &#123; get &#125;&#125; 其中equationCoefficients属性是模拟出的抛物线方程，即下面的公式： y = ax^2 + bx + c simd_float3结构中会封装a，b和c的值。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（5）—— 视频中的物体运动追踪","slug":"460iOS MachineLearning 系列（5）—— 视频中的物体运动追踪","date":"2023-04-25T16:00:00.000Z","updated":"2023-04-26T08:10:37.622Z","comments":true,"path":"2023/04/26/460iOS MachineLearning 系列（5）—— 视频中的物体运动追踪/","link":"","permalink":"http://huishao.cc/2023/04/26/460iOS MachineLearning 系列（5）—— 视频中的物体运动追踪/","excerpt":"","text":"iOS MachineLearning 系列（5）—— 视频中的物体运动追踪本系列的前面几篇文章中，我们将静态图片分析相关的API做了详尽的介绍。在Vision框架中，还提供了视频中物体追踪的能力。 仔细想来，其实视频的分析和静态图片的分析本质上并无太大的区别，我们可以将视频拆解成图片帧，之后再对图片进行静态分析。将所有图片帧的分析结果反馈到视频上，即实现了对视频的分析能力。 视频中物体运动的跟踪常在一些AR游戏中应用，这些现实增强类的应用常常需要实时追踪显示中的物体。 1 - 先看一个简单的示例我们以矩形区域追踪为例，与前面文章介绍的静态分析类似，运动追踪实现的核心点也只有三个： 1. 请求操作句柄。 2. 构建请求。 3. 处理分析请求的回调。 首先我们先来构建操作句柄： 1lazy var handler = VNSequenceRequestHandler() 构建请求： 12345678910111213lazy var request: VNTrackRectangleRequest = &#123; let req = VNTrackRectangleRequest(rectangleObservation: observation) &#123; result, error in // 处理结果 if let error &#123; print(error) &#125; // 处理结果 self.handleResult(request: result as! VNTrackRectangleRequest) &#125; // 选择快速模式 req.trackingLevel = .fast return req&#125;() 在构建请求时，需要我们传入一个初始的描述矩形区域的VNRectangleObservation对象，之后的追踪会以参数为对象。VNRectangleObservation的构建示例如下： 12// 预检测得到的var observation = VNRectangleObservation(boundingBox: CGRect(x: 0.3728713095188141, y: 0.833836019039154, width: 0.16493645310401917, height: 0.07572066783905029)) 需要注意，这里的数据是我使用静态分析预先处理视频首帧得到的，实际应用中，我们也可以先对首帧进行静态分析，找到要追踪的矩形区域。 之外，我们还需要对视频资源进行一些处理，简单来说，即是解析视频帧，之后逐帧进行分析，示例代码如下： 1234567891011121314151617181920212223242526272829func readVideo() &#123; // 视频路径 let videoURL = URL(fileURLWithPath: Bundle.main.path(forResource: \"video1\", ofType: \".mp4\")!) // 读取视频资源 let videoAsset = AVURLAsset(url: videoURL) // 创建视频资源解析器 let videoProcessor = AVAssetImageGenerator(asset: videoAsset) videoProcessor.requestedTimeToleranceBefore = CMTime.zero videoProcessor.requestedTimeToleranceAfter = CMTime.zero // 获取视频时长 let durationSeconds: Float64 = CMTimeGetSeconds(videoAsset.duration) // 存储要截取的视频帧时间点 var times = [NSValue]() // 以每秒60帧为标准，获取总帧数 let totalFrames: Float64 = durationSeconds * 60 // 定义 CMTime 即请求缩略图的时间间隔 for i in 0...Int(totalFrames) &#123; let timeFrame = CMTimeMake(value: Int64(i), timescale: 60) let timeValue = NSValue(time: timeFrame) times.append(timeValue) &#125; // 进行图片解析 videoProcessor.generateCGImagesAsynchronously(forTimes: times) &#123; time, cgImage, actualTime, resultCode, error in if let cgImage = cgImage &#123; let image = UIImage(cgImage: cgImage) self.images.append(image) &#125; &#125;&#125; 当所有视频帧处理完成后，我们即可以对其进行矩形追踪，示例方法如下： 12345678910111213141516171819202122func start() &#123; var count = 0 // 这里定时器的作用是逐帧的刷新页面，同时进行追踪 Timer.scheduledTimer(withTimeInterval: 0.03, repeats: true) &#123; t in if count &lt; self.images.count &#123; // 设置页面展示的图片 self.imageView.image = self.images[count] // 将inputObservation设置为上一次的分析结果 self.request.inputObservation = self.observation // 进行追踪分析 try? self.handler.perform([self.request], on: self.images[count].cgImage!, orientation: .up) count += 1 &#125; else &#123; // 当循环结束时，设置isLastFrame表情请求已经到了最后一帧 self.request.isLastFrame = true // 停止定时器 t.invalidate() print(\"end\") &#125; &#125; print(images.count)&#125; 需要注意，追踪分析的本质是对矩形区域的前后状态进行比较，将其运行情况进行分析。因此，每次进行分析请求时需要将上一次的结果作为inputObservation进行输入，当视频结束时，设置起isLastFrame来结束分析，释放资源。 最后，分析结果的处理很简单： 1234567891011121314151617func handleResult(request: VNTrackRectangleRequest) &#123; print(request.results) for r in request.results ?? [] &#123; guard let result = r as? VNRectangleObservation else &#123; return &#125; observation = result var box = result.boundingBox // 坐标系转换 box.origin.y = 1 - box.origin.y - box.size.height print(\"box:\", result.boundingBox) DispatchQueue.main.async &#123; let size = self.imageView.frame.size self.boxView.frame = CGRect(x: box.origin.x * size.width, y: box.origin.y * size.height, width: box.size.width * size.width, height: box.size.height * size.height) &#125; &#125;&#125; 其中，box是我们定义好的一个UIView蒙层，用来表示追踪的结果，效果如下GIF图所示： 其中，白色的色块是原始视频中的矩形物体，红色的色块是我们的追踪结果。 2 - 几个重要的类VNSequenceRequestHandle类无需多说了，它的作用就是发起请求，其与VNImageRequestHandler类的最大区别在于VNSequenceRequestHandle在创建对象时无需设置一个图片资源，VNSequenceRequestHandle主要是用来分析一系列图片的，因此其是在请求执行时设置图片资源的。 VNTrackRectangleRequest类用来创建矩形区域追踪请求，继承自VNTrackingRequest类，VNTrackingRequest的定义如下： 12345678open class VNTrackingRequest : VNImageBasedRequest &#123; // 输入追踪区域的Observation对象 每次根据中要刷新 open var inputObservation: VNDetectedObjectObservation // 追踪模式 open var trackingLevel: VNRequestTrackingLevel // 是否是最后一帧，如果设置为true，将停止后续分析 open var isLastFrame: Bool&#125; 其中trackingLevel用了设置追踪的算法模式： 123456public enum VNRequestTrackingLevel : UInt, @unchecked Sendable &#123; // 精准优先 case accurate = 0 // 速度优先 case fast = 1&#125; 更多时候，我们要追踪的物体可能不是规则的矩形，也可能是会进行翻转和形变的物体，例如行驶中的汽车，飞行中的足球，奔跑中的人等。对于这类需求，我们需要使用VNTrackObjectRequest来进行追踪，其用法与VNTrackRectangleRequest几乎完全一致，这里就不再赘述，示例代码可以在下面找到： https://github.com/ZYHshao/MachineLearnDemo","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（4）—— 静态图像分析之物体识别与分类","slug":"459iOS MachineLearning 系列（4）—— 静态图像分析之物体识别与分类","date":"2023-04-24T16:00:00.000Z","updated":"2023-04-25T08:54:54.208Z","comments":true,"path":"2023/04/25/459iOS MachineLearning 系列（4）—— 静态图像分析之物体识别与分类/","link":"","permalink":"http://huishao.cc/2023/04/25/459iOS MachineLearning 系列（4）—— 静态图像分析之物体识别与分类/","excerpt":"","text":"iOS MachineLearning 系列（4）—— 静态图像分析之物体识别与分类本系列的前几篇文件，详细了介绍了Vision框架中关于静态图片区域识别的内容。本篇文章，我们将着重介绍静态图片中物体的识别与分类。物体识别和分类也是Machine Learning领域重要的应用。通过大量的图片数据进行训练后，模型可以轻易的分析出图片的属性以及图片中物体的属性。 1 - 文字识别文字识别是应用非常广泛的一种图片识别技术。在Vision框架中，使用VNRecognizeTextRequest来进行文字识别，并且其支持多种语言，且有不错的识别精度。VNRecognizeTextRequest的创建示例如下： 1234567891011121314151617private lazy var recognizeTextRequest: VNRecognizeTextRequest = &#123; let textDetectionRequest = VNRecognizeTextRequest &#123; request, error in DispatchQueue.main.async &#123; self.drawTask(request: request as! VNRecognizeTextRequest) &#125; &#125; // 设置语言 textDetectionRequest.recognitionLanguages = [\"zh-Hans\"] // 设置识别级别 accurate为最精准 fast为最快速 textDetectionRequest.recognitionLevel = .accurate // 设置是否使用语言矫正 textDetectionRequest.usesLanguageCorrection = true // 获取所支持的语言 let set = try? textDetectionRequest.supportedRecognitionLanguages() print(set) return textDetectionRequest&#125;() 可以通过对VNRecognizeTextRequest实例进行配置来调整识别精度，识别的语言，是否进行矫正的选项，VNRecognizeTextRequest类的定义如下： 1234567891011121314151617181920open class VNRecognizeTextRequest : VNImageBasedRequest, VNRequestProgressProviding &#123; // 所支持的语言列表 open class func supportedRecognitionLanguages(for recognitionLevel: VNRequestTextRecognitionLevel, revision requestRevision: Int) throws -&gt; [String] open func supportedRecognitionLanguages() throws -&gt; [String] // 识别过程中所使用的语言 open var recognitionLanguages: [String] // 自定义的词汇，在识别单词时，自定义的词汇优先级会高于默认词典 open var customWords: [String] // 识别等级，精度优先会更加消耗性能 // accurate: 精度优先 fast: 速度优先 open var recognitionLevel: VNRequestTextRecognitionLevel // 设置是否使用自动矫正，自动矫正会更加消耗性能 open var usesLanguageCorrection: Bool // 设置是否自动识别语言类型，当不确定输入的语种时，可以设置其自动识别，会更消耗性能 open var automaticallyDetectsLanguage: Bool // 设置可识别文本的最小高度（为相对原图的比例值） open var minimumTextHeight: Float // 结果数组 open var results: [VNRecognizedTextObservation]? &#123; get &#125;&#125; VNRecognizeTextRequest的识别结果为VNRecognizedTextObservation类，此类也是继承自VNRectangleObservation的，因此我们也同时可以获取到所识别的文本所在原图的位置。VNRecognizedTextObservation类的定义如下： 1234open class VNRecognizedTextObservation : VNRectangleObservation &#123; // 获取候选结果 open func topCandidates(_ maxCandidateCount: Int) -&gt; [VNRecognizedText]&#125; topCandidate会返回一组候选结果，其参数设置最多返回的候选结果个数，需要注意此参数所支持的最大值为10。候选结果是指对于同一段文字，可能会识别出多个相似的结果，最终识别的文本结果VNRecognizedText类的定义如下： 123456open class VNRecognizedText : NSObject, NSCopying, NSSecureCoding, VNRequestRevisionProviding &#123; // 识别出的文本字符串 open var string: String &#123; get &#125; // 本次识别结果的可信度（0-1之间） open var confidence: VNConfidence &#123; get &#125;&#125; 对于confidence可信度属性来说，越接近1，可信度越高。 下图演示了照片中文本的识别效果： 可以看到，Vision对于中文印刷体的识别能力还是比较准确的。 目前，所支持识别的语种列举如下： 1234567891011121314en-US：美式英语fr-FR：法语it-IT：意大利语de-DE：德语es-ES：西班牙语pt-BR：葡萄牙语zh-Hans：简体中文zh-Hant：繁体中文yue-Hans：粤语简体yue-Hant：粤语繁体ko-KR：韩语ja-JP：日语ru-RU：俄语uk-UA：乌克兰语 2 - 动物识别虽说是动物识别，但其实目前的API仅仅支持猫和狗的识别。使用VNRecognizeAnimalsRequest类来创建动物识别请求： 1234567open class VNRecognizeAnimalsRequest : VNImageBasedRequest &#123; // 获取所支持识别的动物种类 open class func knownAnimalIdentifiers(forRevision requestRevision: Int) throws -&gt; [VNAnimalIdentifier] open func supportedIdentifiers() throws -&gt; [VNAnimalIdentifier] // 结果列表 open var results: [VNRecognizedObjectObservation]? &#123; get &#125;&#125; 识别的结果VNRecognizedObjectObservation类也是继承自VNDetectedObjectObservation，其会包装所识别的动物所在图片中的区域，且VNRecognizedObjectObservation类中会封装一组VNClassificationObservation对象，如下： 1234open class VNRecognizedObjectObservation : VNDetectedObjectObservation &#123; // 识别的动物标签 open var labels: [VNClassificationObservation] &#123; get &#125;&#125; VNClassificationObservatio类即表示识别出的物体具体的标签，定义如下： 1234open class VNClassificationObservation : VNObservation &#123; // 标签字符串 open var identifier: String &#123; get &#125;&#125; 对于VNRecognizeAnimalsRequest请求来说，此标签的值可能为Cat或Dog。识别效果如下图： 3 - 图片物体分类图片物体分类是指对静态图片继续分析，将其中可能存在的物体分析出来。使用VNClassifyImageRequest创建图片物体分析请求。此类非常简单，没有太多需要配置的，定义如下： 1234567open class VNClassifyImageRequest : VNImageBasedRequest &#123; // 获取支持识别的物体 open class func knownClassifications(forRevision requestRevision: Int) throws -&gt; [VNClassificationObservation] open func supportedIdentifiers() throws -&gt; [String] // 结果数组 open var results: [VNClassificationObservation]? &#123; get &#125;&#125; VNClassifyImageRequest所支持识别的物体种类非常多，有千余种，这里就不再列举。其识别后的结果也是VNClassificationObservation类，其内部的identifier表示所识别出的物体的标签。 需要注意，对于略微复杂的图片来说，识别的结果可能非常多，我们需要根据需求来设置一个可信度的阈值，只有达到此可信度的才被采用，例如： 123456789private func drawTask(request: VNClassifyImageRequest) &#123; boxViews.forEach &#123; v in v.removeFromSuperview() &#125; for result in request.results ?? [] where result.confidence &gt; 0.8 &#123; // 解析出文本 textView.text = textView.text.appending(result.identifier + \"\\n\") &#125;&#125; 识别效果如下图所示： 可以看到，我们选择了大于0.8可信度的结果，所识别出的关键字有：建筑，加工木材，动物，哺乳动物，犬类，狗，博美。（不知为何对猫的识别度很差） 本中所涉及到的代码，都可以在如下 Demo 中找到： https://github.com/ZYHshao/MachineLearnDemo 到此，我们已经将静态图片的分析做了详尽的介绍，相信很多AI能力都是开发中会使用到的。本系列后面文章，将介绍对象追踪的相关API的用法。","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（3）—— 静态图像分析之区域识别","slug":"458iOS MachineLearning 系列（3）—— 静态图像分析之区域识别","date":"2023-04-21T16:00:00.000Z","updated":"2023-04-22T12:33:25.027Z","comments":true,"path":"2023/04/22/458iOS MachineLearning 系列（3）—— 静态图像分析之区域识别/","link":"","permalink":"http://huishao.cc/2023/04/22/458iOS MachineLearning 系列（3）—— 静态图像分析之区域识别/","excerpt":"","text":"iOS MachineLearning 系列（3）—— 静态图像分析之区域识别本系列的前一篇文章介绍了如何使用iOS中自带的API对图片中的矩形区域进行分析。在图像静态分析方面，矩形区域分析是非常基础的部分。API还提供了更多面向应用的分析能力，如文本区域分析，条形码二维码的分析，人脸区域分析，人体分析等。本篇文章主要介绍这些分析API的应用。关于矩形识别的基础文章，链接如下： https://my.oschina.net/u/2340880/blog/8671152 1 - 文本区域分析文本区域分析相比矩形区域分析更加上层，其API接口也更加简单。分析请求的创建示例如下： 12345678910private lazy var textDetectionRequest: VNDetectTextRectanglesRequest = &#123; let textDetectRequest = VNDetectTextRectanglesRequest &#123; request, error in DispatchQueue.main.async &#123; self.drawTask(request: request as! VNDetectTextRectanglesRequest) &#125; &#125; // 是否报告字符边框区域 textDetectRequest.reportCharacterBoxes = true return textDetectRequest&#125;() 其请求的发起方式，回调结果的处理与矩形分析一文中介绍的一致，这里就不再赘述。唯一不同的是，其分析的结果中新增了characterBoxes属性，用来获取每个字符的所在区域。 文本区域识别效果如下图所示： 2 - 条形码二维码识别条形码和二维码在生活中非常常见，Vision框架中提供的API不仅支持条码区域的检测，还可以直接将条码的内容识别出来。 条码分析请求使用VNDetectBarcodesRequest类创建，如下： 12345678open class VNDetectBarcodesRequest : VNImageBasedRequest &#123; // 类属性，获取所支持的条码类型 open class var supportedSymbologies: [VNBarcodeSymbology] &#123; get &#125; // 设置分析时要支持的条码类型 open var symbologies: [VNBarcodeSymbology] // 结果列表 open var results: [VNBarcodeObservation]? &#123; get &#125;&#125; 如果我们不对symbologies属性进行设置，则默认会尝试识别所有支持的类型。示例代码如下： 12345678910private lazy var barCodeDetectionRequest: VNDetectBarcodesRequest = &#123; let barCodeDetectRequest = VNDetectBarcodesRequest &#123;[weak self] request, error in guard let self else &#123;return&#125; DispatchQueue.main.async &#123; self.drawTask(request: request as! VNDetectBarcodesRequest) &#125; &#125; barCodeDetectRequest.revision = VNDetectBarcodesRequestRevision1 return barCodeDetectRequest&#125;() 需要注意，实测需要将分析所使用的算法版本revision设置为VNDetectBarcodesRequestRevision1。默认使用的版本可能无法分析出结果。 条码分析的结果类VNBarcodeObservation中会封装条码的相关数据，如下： 12345678open class VNBarcodeObservation : VNRectangleObservation &#123; // 当前条码的类型 open var symbology: VNBarcodeSymbology &#123; get &#125; // 条码的描述对象，不同类型的条码会有不同的子类实现 open var barcodeDescriptor: CIBarcodeDescriptor? &#123; get &#125; // 条码内容 open var payloadStringValue: String? &#123; get &#125;&#125; VNBarcodeObservation类也是继承自VNRectangleObservation类的，因此其也可以分析出条码所在的区域，需要注意，对于条形码来说其只能分析出条码的位置，对于二维码来说，其可以准确的识别出二维码的区域，如下图所示： 注：互联网上有很多可以生成条码的工具，例如： https://www.idcd.com/tool/barcode/encode 3 - 轮廓检测相比前面两种图像分析能力，轮廓检测的能力要更加复杂也更加强大一些。其可以通过图片的对比度差异来对内容轮廓进行分析。轮廓分析使用VNDetectContoursRequest类来创建请求。此类主要功能列举如下： 123456789101112open class VNDetectContoursRequest : VNImageBasedRequest &#123; // 轮廓检测时的对比度设置，取值0-3之间，此值越大，检测结果越精确（对于高对比度图片） open var contrastAdjustment: Float // 作为对比度分界的像素，取值0-1之间，默认0.5，会取居中值 open var contrastPivot: NSNumber? // 设置检测时是否是检测暗色对象，默认为true，即认为背景色浅。设置为false则会在暗色图中检测明亮的对象轮廓 open var detectsDarkOnLight: Bool // 设置检测图片时的缩放，轮廓检测会将图片进行压缩，此值取值范围为[64..NSUIntegerMax]，取最大值时表示使用原图 open var maximumImageDimension: Int // 结果数组 open var results: [VNContoursObservation]? &#123; get &#125;&#125; 其检测结果VNContoursObservation类中封装了轮廓的路径信息，在进行轮廓检测时，最外层的轮廓可能有很多内层轮廓组成，这些信息也封装在此类中。如下： 1234567891011121314open class VNContoursObservation : VNObservation &#123; // 内部轮廓个数 open var contourCount: Int &#123; get &#125; // 获取指定的轮廓对象 open func contour(at contourIndex: Int) throws -&gt; VNContour // 顶级轮廓个数 open var topLevelContourCount: Int &#123; get &#125; // 顶级轮廓数组 open var topLevelContours: [VNContour] &#123; get &#125; // 根据indexPath获取轮廓对象 open func contour(at indexPath: IndexPath) throws -&gt; VNContour // 路径，会包含内部所有轮廓 open var normalizedPath: CGPath &#123; get &#125;&#125; 需要注意，其返回的CGPath路径依然是以单位矩形为参照的，我们要将其绘制出来，需要对其进行转换，转换其实非常简单，现对其进行方法，并进行x轴方向的镜像反转，之后向下进行平移一个标准单位即可。示例如下： 12345678910111213141516171819private func drawTask(request: VNDetectContoursRequest) &#123; boxViews.forEach &#123; v in v.removeFromSuperview() &#125; for result in request.results ?? [] &#123; let oriPath = result.normalizedPath var transform = CGAffineTransform.identity.scaledBy(x: imageView.frame.width, y: -imageView.frame.height).translatedBy(x: 0, y: -1) let layer = CAShapeLayer() let path = oriPath.copy(using: &amp;transform) layer.bounds = self.imageView.bounds layer.anchorPoint = CGPoint(x: 0, y: 0) imageView.layer.addSublayer(layer) layer.path = path layer.strokeColor = UIColor.blue.cgColor layer.backgroundColor = UIColor.white.cgColor layer.fillColor = UIColor.gray.cgColor layer.lineWidth = 1 &#125;&#125; 原图与绘制的轮廓图如下所示： 原图： 轮廓： 可以通过VNContoursObservation对象来获取其内的所有轮廓对象，VNContour定义如下： 123456789101112131415161718open class VNContour : NSObject, NSCopying, VNRequestRevisionProviding &#123; // indexPath open var indexPath: IndexPath &#123; get &#125; // 子轮廓个数 open var childContourCount: Int &#123; get &#125; // 子轮廓对象数组 open var childContours: [VNContour] &#123; get &#125; // 通过index获取子轮廓 open func childContour(at childContourIndex: Int) throws -&gt; VNContour // 描述轮廓的点数 open var pointCount: Int &#123; get &#125; // 轮廓路径 open var normalizedPath: CGPath &#123; get &#125; // 轮廓的纵横比 open var aspectRatio: Float &#123; get &#125; // 简化的多边形轮廓，参数设置简化的阈值 open func polygonApproximation(epsilon: Float) throws -&gt; VNContour&#125; 理论上说，我们对所有的子轮廓进行绘制，也能得到一样的路径图像，例如： 123456789101112131415161718192021private func drawTask(request: VNDetectContoursRequest) &#123; boxViews.forEach &#123; v in v.removeFromSuperview() &#125; for result in request.results ?? [] &#123; for i in 0 ..&lt; result.contourCount &#123; let contour = try! result.contour(at: i) var transform = CGAffineTransform.identity.scaledBy(x: imageView.frame.width, y: -imageView.frame.height).translatedBy(x: 0, y: -1) let layer = CAShapeLayer() let path = contour.normalizedPath.copy(using: &amp;transform) layer.bounds = self.imageView.bounds layer.anchorPoint = CGPoint(x: 0, y: 0) imageView.layer.addSublayer(layer) layer.path = path layer.strokeColor = UIColor.blue.cgColor layer.backgroundColor = UIColor.clear.cgColor layer.fillColor = UIColor.clear.cgColor layer.lineWidth = 1 &#125; &#125;&#125; 效果如下图： 4 - 文档区域识别文档识别可以分析出图片中的文本段落，使用VNDetectDocumentSegmentationRequest来创建分析请求，VNDetectDocumentSegmentationRequest没有额外特殊的属性，其分析结果为一组VNRectangleObservation对象，可以获取到文档所在的矩形区域。这里不再过多解说。 5 - 人脸区域识别人脸识别在生活中也有着很广泛的应用，在进行人脸对比识别等高级处理前，我们通常需要将人脸的区域先提取出来，Vision框架中也提供了人脸区域识别的接口，使用VNDetectFaceRectanglesRequest类来创建请求即可。VNDetectFaceRectanglesRequest类本身比较加单，继承自VNImageBasedRequest类，无需进行额外的配置即可使用，其分析的结果为一组VNFaceObservation对象，分析效果如下图所示： VNFaceObservation类本身是继承自VNDetectedObjectObservation类的，因此我们可以直接获取到人脸的区域。VNFaceObservation中还有许多其他有用的信息： 12345678910open class VNFaceObservation : VNDetectedObjectObservation &#123; // 面部特征对象 open var landmarks: VNFaceLandmarks2D? &#123; get &#125; // 人脸在z轴的旋转度数，取值为-PI到PI之间 open var roll: NSNumber? &#123; get &#125; // 人脸在y轴的旋转度数，取值为-PI/2到PI/2之间 open var yaw: NSNumber? &#123; get &#125; // 人脸在x轴的旋转度数，取值为-PI/2到PI/2之间 open var pitch: NSNumber? &#123; get &#125;&#125; 通过roll，yaw和pitch这3个属性，我们可以获取到人脸在空间中的角度相关信息。landmarks属性则比较复杂，其封装了人脸的特征点。并且VNDetectFaceRectanglesRequest请求是不会分析面部特征的，此属性会为nil，关于面部特征，我们后续介绍。 人脸特征分析请求使用VNDetectFaceLandmarksRequest创建，其返回的结果中会有landmarks数据，示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142private func drawTask(request: VNDetectFaceLandmarksRequest) &#123; boxViews.forEach &#123; v in v.removeFromSuperview() &#125; for result in request.results ?? [] &#123; var box = result.boundingBox // 坐标系转换 box.origin.y = 1 - box.origin.y - box.size.height let v = UIView() v.backgroundColor = .clear v.layer.borderColor = UIColor.red.cgColor v.layer.borderWidth = 2 imageView.addSubview(v) let size = imageView.frame.size v.frame = CGRect(x: box.origin.x * size.width, y: box.origin.y * size.height, width: box.size.width * size.width, height: box.size.height * size.height) // 进行特征绘制 let landmarks = result.landmarks // 拿到所有特征点 let allPoints = landmarks?.allPoints?.normalizedPoints let faceRect = result.boundingBox // 进行绘制 for point in allPoints ?? [] &#123; //faceRect的宽高是个比例，我们对应转换成View上的人脸区域宽高 let rectWidth = imageView.frame.width * faceRect.width let rectHeight = imageView.frame.height * faceRect.height // 进行坐标转换 // 特征点的x坐标为人脸区域的比例， // 1. point.x * rectWidth 得到在人脸区域内的x位置 // 2. + faceRect.minX * imageView.frame.width 得到在View上的x坐标 // 3. point.y * rectHeight + faceRect.minY * imageView.frame.height获得Y坐标 // 4. imageView.frame.height - 的作用是y坐标进行翻转 let tempPoint = CGPoint(x: point.x * rectWidth + faceRect.minX * imageView.frame.width, y: imageView.frame.height - (point.y * rectHeight + faceRect.minY * imageView.frame.height)) let subV = UIView() subV.backgroundColor = .red subV.frame = CGRect(x: tempPoint.x - 2, y: tempPoint.y - 2, width: 4, height: 4) imageView.addSubview(subV) &#125; &#125;&#125; VNFaceLandmarks2D中封装了很多特征信息，上面的示例代码会将所有的特征点进行绘制，我们也可以根据需要取部分特征点： 12345678910111213141516171819202122232425262728open class VNFaceLandmarks2D : VNFaceLandmarks &#123; // 所有特征点 open var allPoints: VNFaceLandmarkRegion2D? &#123; get &#125; // 只包含面部轮廓的特征点 open var faceContour: VNFaceLandmarkRegion2D? &#123; get &#125; // 左眼位置的特征点 open var leftEye: VNFaceLandmarkRegion2D? &#123; get &#125; // 右眼位置的特征点 open var rightEye: VNFaceLandmarkRegion2D? &#123; get &#125; // 左眉特征点 open var leftEyebrow: VNFaceLandmarkRegion2D? &#123; get &#125; // 右眉特征点 open var rightEyebrow: VNFaceLandmarkRegion2D? &#123; get &#125; // 鼻子特征点 open var nose: VNFaceLandmarkRegion2D? &#123; get &#125; // 鼻尖特征点 open var noseCrest: VNFaceLandmarkRegion2D? &#123; get &#125; // 中间特征点 open var medianLine: VNFaceLandmarkRegion2D? &#123; get &#125; // 外唇特征点 open var outerLips: VNFaceLandmarkRegion2D? &#123; get &#125; // 内唇特征点 open var innerLips: VNFaceLandmarkRegion2D? &#123; get &#125; // 左瞳孔特征点 open var leftPupil: VNFaceLandmarkRegion2D? &#123; get &#125; // 右瞳孔特征点 open var rightPupil: VNFaceLandmarkRegion2D? &#123; get &#125;&#125; VNFaceLandmarkRegion2D类中具体封装了特征点位置信息，需要注意，特征点的坐标是相对人脸区域的比例值，要进行转换。 主要提示：特征检测在模拟器上可能不能正常工作，可以使用真机测试。 默认人脸特征分析会返回76个特征点，我们可以通过设置VNDetectFaceLandmarksRequest请求实例的constellation属性来修改使用的检测算法，枚举如下： 1234567public enum VNRequestFaceLandmarksConstellation : UInt, @unchecked Sendable &#123; case constellationNotDefined = 0 // 使用65个特征点的算法 case constellation65Points = 1 // 使用73个特征点的算法 case constellation76Points = 2&#125; 效果如下图： Vision框架的静态区域分析中与人脸分析相关的还有一种，使用VNDetectFaceCaptureQualityRequest请求可以分析当前捕获到的人脸的质量，使用此请求分析的结果中会包含如下属性： 1234extension VNFaceObservation &#123; // 人脸捕获的质量 @nonobjc public var faceCaptureQuality: Float? &#123; get &#125;&#125; faceCaptureQualit值越接近1，捕获的人脸效果越好。 6 - 水平线识别VNDetectHorizonReques用来创建水平线分析请求，其可以分析出图片中的水平线位置。此请求本身比较简单，其返回的结果对象为VNHorizonObservation，如下： 1234open class VNHorizonObservation : VNObservation &#123; // 角度 open var angle: CGFloat &#123; get &#125;&#125; 分析结果如下图所示： 7 - 人体相关识别人体姿势识别也是Vision框架非常强大的一个功能，其可以将静态图像中人体的关键节点分析出来，通过这些关键节点，我们可以对人体当前的姿势进行推断。在运动矫正，健康检查等应用中应用广泛。人体姿势识别请求使用VNDetectHumanBodyPoseRequest类创建，如下： 12345678open class VNDetectHumanBodyPoseRequest : VNImageBasedRequest &#123; // 获取所支持检查的关键节点 open class func supportedJointNames(forRevision revision: Int) throws -&gt; [VNHumanBodyPoseObservation.JointName] // 获取所支持检查的关键节组 open class func supportedJointsGroupNames(forRevision revision: Int) throws -&gt; [VNHumanBodyPoseObservation.JointsGroupName] // 分析结果 open var results: [VNHumanBodyPoseObservation]? &#123; get &#125;&#125; VNHumanBodyPoseObservatio分析结果类中封装的有各个关键节点的坐标信息，如下： 12345678910open class VNHumanBodyPoseObservation : VNRecognizedPointsObservation &#123; // 可用的节点名 open var availableJointNames: [VNHumanBodyPoseObservation.JointName] &#123; get &#125; // 可用的节点组名 open var availableJointsGroupNames: [VNHumanBodyPoseObservation.JointsGroupName] &#123; get &#125; // 获取某个节点坐标 open func recognizedPoint(_ jointName: VNHumanBodyPoseObservation.JointName) throws -&gt; VNRecognizedPoint // 获取某个节点组 open func recognizedPoints(_ jointsGroupName: VNHumanBodyPoseObservation.JointsGroupName) throws -&gt; [VNHumanBodyPoseObservation.JointName : VNRecognizedPoint]&#125; 下面示例代码演示了如何对身体姿势节点进行解析： 1234567891011121314private func drawTask(request: VNDetectHumanBodyPoseRequest) &#123; boxViews.forEach &#123; v in v.removeFromSuperview() &#125; for result in request.results ?? [] &#123; for point in result.availableJointNames &#123; if let p = try? result.recognizedPoint(point) &#123; let v = UIView(frame: CGRect(x: p.x * imageView.bounds.width - 2, y: (1 - p.y) * imageView.bounds.height - 2.0, width: 4, height: 4)) imageView.addSubview(v) v.backgroundColor = .red &#125; &#125; &#125;&#125; 效果如下图： 所有支持的身体节点名和节点组名列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 身体节点extension VNHumanBodyPoseObservation.JointName &#123; // 鼻子节点 public static let nose: VNHumanBodyPoseObservation.JointName // 左眼节点 public static let leftEye: VNHumanBodyPoseObservation.JointName // 右眼节点 public static let rightEye: VNHumanBodyPoseObservation.JointName // 左耳节点 public static let leftEar: VNHumanBodyPoseObservation.JointName // 右耳节点 public static let rightEar: VNHumanBodyPoseObservation.JointName // 左肩节点 public static let leftShoulder: VNHumanBodyPoseObservation.JointName // 右肩节点 public static let rightShoulder: VNHumanBodyPoseObservation.JointName // 脖子节点 public static let neck: VNHumanBodyPoseObservation.JointName // 左肘节点 public static let leftElbow: VNHumanBodyPoseObservation.JointName // 右肘节点 public static let rightElbow: VNHumanBodyPoseObservation.JointName // 左腕节点 public static let leftWrist: VNHumanBodyPoseObservation.JointName // 右腕节点 public static let rightWrist: VNHumanBodyPoseObservation.JointName // 左髋节点 public static let leftHip: VNHumanBodyPoseObservation.JointName // 右髋节点 public static let rightHip: VNHumanBodyPoseObservation.JointName // 身体节点 public static let root: VNHumanBodyPoseObservation.JointName // 左膝节点 public static let leftKnee: VNHumanBodyPoseObservation.JointName // 右膝节点 public static let rightKnee: VNHumanBodyPoseObservation.JointName // 左踝节点 public static let leftAnkle: VNHumanBodyPoseObservation.JointName // 右踝节点 public static let rightAnkle: VNHumanBodyPoseObservation.JointName&#125;// 节点组extension VNHumanBodyPoseObservation.JointsGroupName &#123; // 面部节点组 public static let face: VNHumanBodyPoseObservation.JointsGroupName // 躯干节点组 public static let torso: VNHumanBodyPoseObservation.JointsGroupName // 左臂节点组 public static let leftArm: VNHumanBodyPoseObservation.JointsGroupName // 右臂节点组 public static let rightArm: VNHumanBodyPoseObservation.JointsGroupName // 左腿节点组 public static let leftLeg: VNHumanBodyPoseObservation.JointsGroupName // 右腿节点组 public static let rightLeg: VNHumanBodyPoseObservation.JointsGroupName // 所有节点 public static let all: VNHumanBodyPoseObservation.JointsGroupName&#125; 与人体姿势识别类似，VNDetectHumanHandPoseRequest用来对手势进行识别，VNDetectHumanHandPoseRequest定义如下： 12345678910open class VNDetectHumanHandPoseRequest : VNImageBasedRequest &#123; // 支持的手势节点 open class func supportedJointNames(forRevision revision: Int) throws -&gt; [VNHumanHandPoseObservation.JointName] // 支持的手势节点组 open class func supportedJointsGroupNames(forRevision revision: Int) throws -&gt; [VNHumanHandPoseObservation.JointsGroupName] // 设置最大支持的检测人手数量，默认2，最大6 open var maximumHandCount: Int // 识别结果 open var results: [VNHumanHandPoseObservation]? &#123; get &#125;&#125; VNHumanHandPoseObservation类的定义如下： 1234567891011open class VNHumanHandPoseObservation : VNRecognizedPointsObservation &#123; // 可用的节点名 open var availableJointNames: [VNHumanHandPoseObservation.JointName] &#123; get &#125; // 可用的节点组名 open var availableJointsGroupNames: [VNHumanHandPoseObservation.JointsGroupName] &#123; get &#125; // 获取坐标点 open func recognizedPoint(_ jointName: VNHumanHandPoseObservation.JointName) throws -&gt; VNRecognizedPoint open func recognizedPoints(_ jointsGroupName: VNHumanHandPoseObservation.JointsGroupName) throws -&gt; [VNHumanHandPoseObservation.JointName : VNRecognizedPoint] // 获取手性 open var chirality: VNChirality &#123; get &#125;&#125; chiralit属性用来识别左右手，枚举如下： 12345678@frozen public enum VNChirality : Int, @unchecked Sendable &#123; // 未知 case unknown = 0 // 左手 case left = -1 // 右手 case right = 1&#125; 在手势识别中，可用的节点名列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748extension VNHumanHandPoseObservation.JointName &#123; // 手腕节点 public static let wrist: VNHumanHandPoseObservation.JointName // 拇指关节节点 public static let thumbCMC: VNHumanHandPoseObservation.JointName public static let thumbMP: VNHumanHandPoseObservation.JointName public static let thumbIP: VNHumanHandPoseObservation.JointName public static let thumbTip: VNHumanHandPoseObservation.JointName // 食指关节节点 public static let indexMCP: VNHumanHandPoseObservation.JointName public static let indexPIP: VNHumanHandPoseObservation.JointName public static let indexDIP: VNHumanHandPoseObservation.JointName public static let indexTip: VNHumanHandPoseObservation.JointName // 中指关节节点 public static let middleMCP: VNHumanHandPoseObservation.JointName public static let middlePIP: VNHumanHandPoseObservation.JointName public static let middleDIP: VNHumanHandPoseObservation.JointName public static let middleTip: VNHumanHandPoseObservation.JointName // 无名指关节节点 public static let ringMCP: VNHumanHandPoseObservation.JointName public static let ringPIP: VNHumanHandPoseObservation.JointName public static let ringDIP: VNHumanHandPoseObservation.JointName public static let ringTip: VNHumanHandPoseObservation.JointName // 小指关节节点 public static let littleMCP: VNHumanHandPoseObservation.JointName public static let littlePIP: VNHumanHandPoseObservation.JointName public static let littleDIP: VNHumanHandPoseObservation.JointName public static let littleTip: VNHumanHandPoseObservation.JointName&#125;extension VNHumanHandPoseObservation.JointsGroupName &#123; // 拇指 public static let thumb: VNHumanHandPoseObservation.JointsGroupName // 食指 public static let indexFinger: VNHumanHandPoseObservation.JointsGroupName // 中指 public static let middleFinger: VNHumanHandPoseObservation.JointsGroupName // 无名指 public static let ringFinger: VNHumanHandPoseObservation.JointsGroupName // 小指 public static let littleFinger: VNHumanHandPoseObservation.JointsGroupName // 全部 public static let all: VNHumanHandPoseObservation.JointsGroupName&#125; 效果如下图： 如果我们只需要识别人体的躯干部位，则使用VNDetectHumanRectanglesRequest会非常方便，VNDetectHumanRectanglesRequest定义如下： 123456open class VNDetectHumanRectanglesRequest : VNImageBasedRequest &#123; // 设置是否仅仅检测上半身，默认为true open var upperBodyOnly: Bool // 分析结果 open var results: [VNHumanObservation]? &#123; get &#125;&#125; 人体躯干识别的结果用法与矩形识别类似，效果如下： 需要注意：人体姿势识别和手势识别的API在模拟器上可能无法正常的工作。 本篇文章，我们介绍了许多关于静态图像区域分析和识别的API，这些接口功能强大，且设计的非常简洁。文本中所涉及到的代码，都可以在如下Demo中找到： https://github.com/ZYHshao/MachineLearnDemo 专注技术，懂的热爱，愿意分享，做个朋友","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning 系列（2）—— 静态图像分析之矩形识别","slug":"457iOS MachineLearning 系列（2）—— 静态图像分析之矩形识别","date":"2023-04-17T16:00:00.000Z","updated":"2023-04-18T11:44:41.944Z","comments":true,"path":"2023/04/18/457iOS MachineLearning 系列（2）—— 静态图像分析之矩形识别/","link":"","permalink":"http://huishao.cc/2023/04/18/457iOS MachineLearning 系列（2）—— 静态图像分析之矩形识别/","excerpt":"","text":"iOS MachineLearning 系列（2）—— 静态图像分析之矩形识别本系列文章将完整的介绍iOS中Machine Learning相关技术的应用。本篇文章开始，我们将先介绍一些与Machine Learning相关的API的应用。使用这些API可以快速方便的实现很多如图像识别，分析等复杂功能，且不会增加应用安装包的体积。 本篇将首先介绍如何分析出静态图片中的矩形区域。矩形区域的是被非常重要，其通常用来对要分析的图片进行预处理，例如通过矩形分析截取其中的二维码，条形码部分后再进行精准的识别。 1 - 矩形分析示例与视觉相关的大部分AI能力都封装在Vision框架中，本文要介绍的是通过发起矩形分析请求来分析图片，得到分析结果后将分析出来的矩形区域绘制回原图像上。 首先定义一些属性： 12345678910111213141516171819202122232425262728// 要分析的图片资源let image = UIImage(named: \"image2\")!lazy var imageView = UIImageView(image: image)// 绘制的矩形区域var boxViews: [UIView] = []// 图像分析请求句柄lazy var imageRequestHandler = VNImageRequestHandler(cgImage: image.cgImage!, orientation: .up, options: [:])// 图像分析请求实例private lazy var rectangleDetectionRequest: VNDetectRectanglesRequest = &#123; let rectDetectRequest = VNDetectRectanglesRequest &#123; request, error in DispatchQueue.main.async &#123; self.drawTask(request: request as! VNDetectRectanglesRequest) &#125; &#125; // 自定义一些配置项 // 设置要分析的最大结果个数（矩形个数） rectDetectRequest.maximumObservations = 0 // 设置最低接受的可信值 rectDetectRequest.minimumConfidence = 0 // 设置最小接受的纵横比 rectDetectRequest.minimumAspectRatio = 0.1 return rectDetectRequest&#125;() 其中VNDetectRectanglesRequest即是核心的图片分析请求类，VNImageRequestHandler是请求句柄，用来发起请求。后面我们会详细介绍。在开始请求分析之前，我们还需要定义个方法，用来进行矩形区域绘制： 12345678910111213141516171819private func drawTask(request: VNDetectRectanglesRequest) &#123; // 将之前绘制的删除 boxViews.forEach &#123; v in v.removeFromSuperview() &#125; // 遍历分析结果 for result in request.results ?? [] &#123; var box = result.boundingBox // 坐标系转换 box.origin.y = 1 - box.origin.y - box.size.height let v = UIView() v.backgroundColor = .clear v.layer.borderColor = UIColor.black.cgColor v.layer.borderWidth = 1 imageView.addSubview(v) let size = imageView.frame.size v.frame = CGRect(x: box.origin.x * size.width, y: box.origin.y * size.height, width: box.size.width * size.width, height: box.size.height * size.height) &#125;&#125; 需要注意，Vision框架中的坐标系与CoreGraphics框架中的坐标系是一致的，其以左下角点为（0， 0）点，在UIKit框架中则是以左上角点为（0，0）点，记得进行坐标系的转换。 最后，使用下面的代码来发起请求，静态图像的分析将会是一个耗时的过程，因此建议在非主线程中进行： 123456789DispatchQueue.global(qos: .userInitiated).async &#123; do &#123; // 发起分析请求 try self.imageRequestHandler.perform([self.rectangleDetectionRequest]) &#125; catch let error as NSError &#123; print(\"Failed to perform image request: \\(error)\") return &#125;&#125; 分析的结果会在定义VNDetectRectanglesRequest时传入的回调中返回。 你可以用几张图片来实验下检测效果，如下图： 上面图片中的黑色边框就是我们检测出的结果绘制的。 2 - 关于VNDetectRectanglesRequest类VNDetectRectanglesRequest类用来对核心的分析请求进行定义，并且设置结果回调。VNDetectRectanglesRequest类是专门创建矩形区域识别的请求类，继承自VNImageBasedRequest，VNImageBasedRequest类是静态图像分析请求的基类，继承自VNRequest类。 我们先来看VNRequest类： 123456789101112131415161718192021222324252627282930313233@available(iOS 11.0, *)open class VNRequest : NSObject, NSCopying &#123; // 构造方法，无处理回调 public convenience init() // 构造方法其中回调参数定义如下 // (VNRequest, Error?) -&gt; Void // VNRequest为当前实例本身 error是异常（如果有） public init(completionHandler: VNRequestCompletionHandler? = nil) // 是否开启后台线程模式，此模式会占用更少的内存，CPU，GPU资源，给用户更好的渲染体验，但是会以耗时为代价 open var preferBackgroundProcessing: Bool // 是否允许使用GPU进行加速 open var usesCPUOnly: Bool // 分析结果列表，VNObservation是结果基类，不同的子类实现不同的功能 open var results: [VNObservation]? &#123; get &#125; // 处理回调，此回调中会传入当前Request对象，通过内部的results拿到结果 open var completionHandler: VNRequestCompletionHandler? &#123; get &#125; // 进行分析的特定算法版本 open var revision: Int // 所支持的算法版本集合 open class var supportedRevisions: IndexSet &#123; get &#125; // 默认的版本 open class var defaultRevision: Int &#123; get &#125; // 当前使用的算法版本 open class var currentRevision: Int &#123; get &#125; // 取消分析请求 open func cancel()&#125; 在VNRequest类中封装了一组VNObservation对象，当成功的完成了图像分析任务后，结果会被封装成VNObservation对象，不同的分析任务对应的结果对象也不同，VNObservation是这些结果的基类，其中封装了基础的信息，如下： 123456789101112@available(iOS 11.0, *)open class VNObservation : NSObject, NSCopying, NSSecureCoding, VNRequestRevisionProviding &#123; // 唯一标识id open var uuid: UUID &#123; get &#125; // 此结果的可信度，取值0到1之间 open var confidence: VNConfidence &#123; get &#125; // 此结果的有效时间 @available(iOS 14.0, *) open var timeRange: CMTimeRange &#123; get &#125;&#125; VNImageBasedReques类是VNRequest的一个子类，其是静态图片分析请求类的基类，其中只封装了一个属性： 12345@available(iOS 11.0, *)open class VNImageBasedRequest : VNRequest &#123; // 矩形被标准化处理后的尺寸，默认为&#123;&#123; 0, 0 &#125;, &#123; 1, 1 &#125;&#125; open var regionOfInterest: CGRect&#125; regionOfInterest属性非常有用，其默认会把我们要处理的图像标准化为单位矩形，返回的结果中的坐标是以此单位矩形为标准的。 最后，我们再来看下VNDetectRectanglesRequest类，这个类即使我们进行矩形区域识别的请求配置类，如下： 1234567891011121314151617181920212223@available(iOS 11.0, *)open class VNDetectRectanglesRequest : VNImageBasedRequest &#123; // 设置检测接受的矩形最小的纵横比 VNAspectRatio是Float类型的别名，取值0-1之间 open var minimumAspectRatio: VNAspectRatio // 设置检测所接受的最大的纵横比，取值0-1之间 open var maximumAspectRatio: VNAspectRatio // 设置矩形角度可以偏离90度的最大角度，取值0-45之间 open var quadratureTolerance: VNDegrees // 设置允许检测到的最小的矩形尺寸，设置为相对原图像比例值0-1之间 open var minimumSize: Float // 设置能够接受的最小可信度，0到1之间，小于此可信度的检测结果不会被返回 open var minimumConfidence: VNConfidence // 设置允许检测出的最多结果数，默认为1，设置为0表示不限制，但是Vision框架目前最多支持16 open var maximumObservations: Int // 结果数组 open var results: [VNRectangleObservation]? &#123; get &#125;&#125; 需要注意，设置最大最小纵横比时，会总是以长的一边作为纵，短的一边作为横。 3 - 关于VNRectangleObservation类VNRectangleObservatio是矩形区域分析请求的结果类，继承自VNDetectedObjectObservation类，VNDetectedObjectObservation类是VNObservation的子类，其通常与对象的识别有关，其封装了与识别相关的属性，如下： 1234567@available(iOS 11.0, *)open class VNDetectedObjectObservation : VNObservation &#123; // 检测出的区域，注意原点在左下角 open var boundingBox: CGRect &#123; get &#125; // 缓冲区的图像数据 open var globalSegmentationMask: VNPixelBufferObservation? &#123; get &#125;&#125; VNRectangleObservation类则封装了与矩形相关的属性数据： 1234567891011@available(iOS 11.0, *)open class VNRectangleObservation : VNDetectedObjectObservation &#123; // 左上角位置 open var topLeft: CGPoint &#123; get &#125; // 右上角位置 open var topRight: CGPoint &#123; get &#125; // 左下角位置 open var bottomLeft: CGPoint &#123; get &#125; // 右下角位置 open var bottomRight: CGPoint &#123; get &#125;&#125; 理解了请求配置类与分析结果类的用法，剩下的就是请求句柄了。 4 - 关于VNImageRequestHandler类VNImageRequestHandler类是请求句柄类，更通俗的说，其为分析请求提供了图像数据源，并触发请求。其支持的构造方法如下： 12345678910111213141516@available(iOS 11.0, *)open class VNImageRequestHandler : NSObject &#123; // 构造方法 public init(cvPixelBuffer pixelBuffer: CVPixelBuffer, options: [VNImageOption : Any] = [:]) public init(cvPixelBuffer pixelBuffer: CVPixelBuffer, orientation: CGImagePropertyOrientation, options: [VNImageOption : Any] = [:]) public init(cgImage image: CGImage, options: [VNImageOption : Any] = [:]) public init(cgImage image: CGImage, orientation: CGImagePropertyOrientation, options: [VNImageOption : Any] = [:]) public init(ciImage image: CIImage, options: [VNImageOption : Any] = [:]) public init(ciImage image: CIImage, orientation: CGImagePropertyOrientation, options: [VNImageOption : Any] = [:]) public init(url imageURL: URL, options: [VNImageOption : Any] = [:]) public init(url imageURL: URL, orientation: CGImagePropertyOrientation, options: [VNImageOption : Any] = [:]) public init(data imageData: Data, options: [VNImageOption : Any] = [:]) public init(data imageData: Data, orientation: CGImagePropertyOrientation, options: [VNImageOption : Any] = [:]) public init(cmSampleBuffer sampleBuffer: CMSampleBuffer, options: [VNImageOption : Any] = [:]) public init(cmSampleBuffer sampleBuffer: CMSampleBuffer, orientation: CGImagePropertyOrientation, options: [VNImageOption : Any] = [:])&#125; VNImageRequestHandler类的构造方法很多，但归根结底是要提供三部分内容： 图片数据源。 图片的方向。 额外参数。 其中，图片的数据源可以从二进制数据加载，可以从网络加载，可以从CoreImage或CoreGraphics框架的图片对象加载等等，这里不多赘述。 图片的方向需要在构造句柄实例对象时进行提供，枚举如下： 12345678910111213141516171819@frozen public enum CGImagePropertyOrientation : UInt32, @unchecked Sendable &#123; case up = 1 // 正向 case upMirrored = 2 // 水平镜像 case down = 3 // 180度旋转 case downMirrored = 4 // 竖直镜像 case leftMirrored = 5 // 顺时针旋转90度后镜像 case right = 6 // 顺时针旋转90度 case rightMirrored = 7 // 逆时针旋转90度后镜像 case left = 8 // 逆时针旋转90度&#125; 额外参数可以配置为一个字典对象，提供更多图片数据，支持配置的字段如下： properties：此键可配置为一个属性字典，参考CGImageSourceCopyPropertiesAtIndex。 cameraIntrinsics：相机内部数据配置。 ciContex：CIContext配置。 最后，调用VNImageRequestHandler类的如下方法即可开始静态图像处理： 1open func perform(_ requests: [VNRequest]) throws 同一个图像句柄可以同时发起多种图像处理请求。 注：本文所介绍的示例代码可在如下仓库获取： https://github.com/ZYHshao/MachineLearnDemo 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"iOS MachineLearning系列（1）——简介","slug":"456iOS MachineLearning系列（1）——简介","date":"2023-04-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.400Z","comments":true,"path":"2023/04/14/456iOS MachineLearning系列（1）——简介/","link":"","permalink":"http://huishao.cc/2023/04/14/456iOS MachineLearning系列（1）——简介/","excerpt":"","text":"iOS MachineLearning系列（1）——简介最近，随着Chat-GPT的发布，人工智能相关的资讯和话题再次火热了起来。有了人工智能的加持，对人们的生活以及各行各业的工作都将带来效率的极大提升。目前，各种大模型的发布层出不穷，这些大模型虽然功能非常强大（如文本理解，绘图等），但对于个人来说，要跑起这样一个模型来对外提供服务还是比较困难的，其需要有非常强大的算力支持。 本系列博客，主旨在讨论使用分布式的方式来运行ML或AI相关的服务功能，在iOS平台中，系统本身就提供了ML相关的框架以及内置API接口，使用内置接口已经可以实现非常强大的AI功能，且不需要引入额外的模型，不会增大App的体积。如果有更高级的AI需求，我们也可以使用CoreML框架来运行第三方的模型，非常强大。更甚一步，如果有非常定制化的AI需求，我们也可以通过Xcode工具来自己训练模型，使用自己训练的模型来实现更加复杂的功能。 在结构上，本系列博客将从应用的角度由浅入深的进行介绍，先介绍系统API的功能，再介绍如何使用三方模型，最后讨论如何自己训练模型。希望这些文章可以起到抛砖引玉的效果，帮助你打开在iOS平台上AI应用的新思路，并充分的利用用户的设备来实现AI功能，而不是中心服务器。 1 - 关于Machine LearningCoreML是iOS系统提供的机器Learning核心框架，其可以将训练好的模型轻松的集成到我们的应用中，至于模型，我们可以使用自己训练的，也可以使用三方训练好的，甚至可以将其他框架的模型转换成CoreML所需要的类型进行使用。 iOS中的Machine Learning能力可以概括为以下几个方面： Machine Learning APIS Create ML Use Models ML Converters 2 - Machine Learning APIS我们知道，iOS系统本身就有一些AI功能，例如人脸识别，语音识别等，这些系统内置的功能其实也开发了API供开发者使用，我们只需要很少的代码，即可在应用中集成这些功能，包括： 视觉：分析图像和视频的相关功能。 自然语言：处理和理解文本相关的。 语音：语音内容识别相关的。 音频：音频类型识别相关的。 与视觉相关的API功能包括有： 图片分类：自动识别图像中的内容。 图片增强：将图像的关键部分进行突出。 图像对齐：处理图像边缘对齐。 图像相似性对比：生成特征对比图像相似性。 目标检测：在图像中找到目标物。 对象跟踪：跟踪视频中的移动对象。 轨迹检测：检测视频中运动物体的轨迹。 轮廓检测：检测图像或视频中物体的轮廓。 文本检测：检测图像中的文本区域。 文本识别：识别图像中的文本，提取文本。 人脸检测：检测图像中的人脸。 人脸追踪：实时追踪相机视频流中的人脸。 面部特征提取：检测面部特征提取人脸特征。 人脸捕获质量：比较一组图中的人脸捕获质量。 人体检测：在图片中查找人体。 身体姿势分析：分析图像中的人体姿势。 手部姿势识别：在图像中识别手部姿势。 动物识别：识别图像中的猫狗。 条形码识别：识别条形码。 矩形检测：查找图片中的矩形区域。 地平线检测：分析图片中的地平线角度。 光电流：分析对象在连续视频帧之间的运动模式。 人像细分：为图片中的人物生成无光图像。 文档分析：检测图像中包含的文本矩形区域。 与自然语言处理相关API有： token化：枚举文本字符串中的单词。 语言识别：识别文本的主体语言。 打标签：对文本中的实体进行标签化。 词性标注：标注文本中实体的词性。 单词嵌入：嵌入相近词。 句子嵌入：嵌入相近句。 情绪分析：分析文本的情绪。 与语音识别API有： 语音识别：将语音提取成文字。 与音频处理相关的API有： 声音分类：将声音进行分类。 本系列的后续文章会对这些API的使用多详细介绍。 2 - Create MLCreate ML是Mac上提供的一种模型训练方式，其训练完成后的模型可以直接在CoreML框架上进行使用。降低了模型训练的复杂性。 Create ML支持对多种类型的数据为内容进行训练，包括图片，视频，活动，声音，文本和表格等。如果安装了Xcode，则自动也将安装Create ML工具，其中自带了很多训练模板，如下图所示： 关于模型的训练，也将在后续文章中做介绍。 3 - Use Models自己训练模型是有一定的成本的，比如首先要有大量的用于训练的数据。Core ML社区也为开发者提供了一些训练好的模型，可以直接下载使用。可以在如下网站进行下载： https://developer.apple.com/machine-learning/models/ 这些模型的功能还是很强大的，比如进行图像的深度预测，数字手写体识别，绘图分类，物体识别，像素分割，人类关节分析，以及查找问题的答案等等。 后续文章会介绍如何使用这些模型。 4. ML ConvertersCore ML本身是Apple提供的模型框架，我们知道还有很多第三方的训练库，我们也可以将其他框架训练的模型转换为Core ML模型，从而集成进iOS应用。支持的库和框架包括： TenscrFlow PyTorch XGboost scikit-learn LIBSVM 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}],"tags":[],"keywords":[{"name":"从机器学习到AI","slug":"从机器学习到AI","permalink":"http://huishao.cc/categories/从机器学习到AI/"}]},{"title":"StoreKit：iOS应用内推广其他App","slug":"455StoreKit：iOS应用内推广其他App","date":"2023-03-23T16:00:00.000Z","updated":"2023-04-22T12:32:21.991Z","comments":true,"path":"2023/03/24/455StoreKit：iOS应用内推广其他App/","link":"","permalink":"http://huishao.cc/2023/03/24/455StoreKit：iOS应用内推广其他App/","excerpt":"","text":"StoreKit：iOS应用内推广其他App在iOS应用中，要推广其他App有两种途径，一种是直接跳转到AppStore软件的对应App商品页，还有一种是在当前应用内内嵌一个App商品页。相比第一种方式，第二种方式的体验更好，并且不会打断用户对当前应用的使用。 本篇文章，我们主要介绍StoreKit框架中的相关接口，使用StoreKit可以轻松的在当前应用内推广其他App。 · 在应用内打开其他App的商品页StoreKit框架中提供了一个名为SKStoreProductViewController的类，此类事继承自UIViewController的，因此我们可以像使用普通视频控制器一样来使用它。只要我们提供了某个应用的ITunes ID，就可以轻松的在应用中打开其AppStore商品页。 例如下面的代码： 12345678910// 创建视图控制器let appStoreController = SKStoreProductViewController()// 设置代理appStoreController.delegate = self// 定义参数let params = [SKStoreProductParameterITunesItemIdentifier: \"387682726\"]// 加载应用信息appStoreController.loadProduct(withParameters: params)// 将页面弹出self.present(appStoreController, animated: true) 上面代码中使用了淘宝应用的ITunes ID，代码执行效果如下图所示： 可以看到，我们直接在应用内就弹起了”淘宝“的详情页，可以直接进行下载/更新操作。 需要注意，上面代码只能在真机上进行测试，且默认页面的弹出方式为浮层样式。 下面我们再来详细看下SKStoreProductViewController这个类的用法，SKStoreProductViewController本身比较简单，创建出实例后，只需要使用loadProduct来加载指定的应用即可，其所传的参数字典中，可配置的选项如下： 12345678910111213141516171819202122232425// 应用的iTunes ID @available(iOS 6.0, *)public let SKStoreProductParameterITunesItemIdentifier: String// 内购商品的SKU码，如果配置了，则会显示内购商品信息 @available(iOS 11.0, *)public let SKStoreProductParameterProductIdentifier: String// 自定义商品页的ID@available(iOS 15.0, *)public let SKStoreProductParameterCustomProductPageIdentifier: String// 机构token@available(iOS 8.0, *)public let SKStoreProductParameterAffiliateToken: String@available(iOS 8.0, *)public let SKStoreProductParameterCampaignToken: String// 用来分析提供者的token@available(iOS 8.3, *)public let SKStoreProductParameterProviderToken: String// 广告伙伴token@available(iOS 9.3, *)public let SKStoreProductParameterAdvertisingPartnerToken: String 其中，SKStoreProductParameterITunesItemIdentifier键是必传的。 SKStoreProductViewController中也定义了一个delegate属性，设置代理可以对商品页的关闭行为进行监听，如下： 12345extension ViewController: SKStoreProductViewControllerDelegate &#123; func productViewControllerDidFinish(_ viewController: SKStoreProductViewController) &#123; print(\"商品页关闭\") &#125;&#125; 此代理方法是可选实现的。 · 一些小技巧如何获取公开应用的ITunes ID？ 现在，我们以及知道了如何在应用内打开其他App的详情页，如何获取ITunes参数呢，其实是有官方的渠道可查的。地址如下： https://tools.applemediaservices.com/ 在其中输入我们要查询的应用名称，即可获取到与此应用相关的推广信息，如下图所示： 可以看到，图中有一段Content Link，这其中就包含了应用的ITunes ID信息，只是其是被URL encode后的，将其复制出来，可以在如下网站进行URL Decode，即可得到原始的ITunes ID。 http://www.jsons.cn/urlencode/ 对内嵌商品页弹起的高度，文本风格颜色进行配置？ 虽然SKStoreProductViewController提供的接口很少，但我们依然有办法对其做一定程度上的定制，比如其中按钮的风格颜色，浮层的弹起高度。 新建一个继承于SKStoreProductViewController的类，实现如下： 1234567891011121314151617import UIKitimport StoreKitclass MyStoreProductController: SKStoreProductViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 设置页面内部分元素的风格颜色 view.tintColor = .red &#125; override func viewWillLayoutSubviews() &#123; super.viewWillLayoutSubviews() // 这里可以控制页面弹起的高度 view.frame = CGRect(x: 0, y: 400, width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height - 400) &#125;&#125; 运行效果如下图所示： · 使用应用挂件SKStoreProductViewController打开的是一个完整的产品详情页，有时候，我们更期望要推广的应用只是占据一个挂件的位置，在iOS 14及之后的版本中，StoreKit框架中提供了SKOverlay类来实现应用挂件。 示例代码如下： 1234567// 创建配置，传入要渲染的应用的ITunes IDlet config = SKOverlay.AppConfiguration(appIdentifier: \"387682726\", position: .bottom)let overlay = SKOverlay(configuration: config)// 指定展示在Scene上if let scene = UIApplication.shared.windows.first?.windowScene &#123; overlay.present(in: scene)&#125; 效果如下图所示： 可以看到，在窗口底部会出现一个应用挂件。 AppConfiguration实例可配置的属性不多，列举如下： 12345678910111213141516171819202122232425262728293031323334@available(iOS 14.0, *)public class AppConfiguration : SKOverlay.Configuration &#123; // 初始化方法 public init(appIdentifier: String, position: SKOverlay.Position) // ITunes ID open var appIdentifier: String // 一些额外的Token open var campaignToken: String? open var providerToken: String? // 自定义页面的ID @available(iOS 15.0, *) open var customProductPageIdentifier: String? // 设置要展示最近版本 @available(iOS 15.0, *) open var latestReleaseID: String? // 挂件的位置，可枚举bottom和bottomRaised 差别不大 open var position: SKOverlay.Position // 是否允许用户关闭 open var userDismissible: Bool // 启动附加数据 open func setAdditionalValue(_ value: Any?, forKey key: String) open func additionalValue(forKey key: String) -&gt; Any? // 广告体验配置 @available(iOS 16.0, *) open func setAdImpression(_ impression: SKAdImpression)&#125; 整体来说，SKOverlay不太灵活，对其出现的位置并不能精准的进行控制，SKOverlayDelegate定义了一些方法来监听其行为，如下： 123456789101112public protocol SKOverlayDelegate : NSObjectProtocol &#123; // 产品加载失败的回调 optional func storeOverlayDidFailToLoad(_ overlay: SKOverlay, error: Error) // 挂件将要开始弹出的回调 optional func storeOverlayWillStartPresentation(_ overlay: SKOverlay, transitionContext: SKOverlay.TransitionContext) // 挂件以及弹出的回调 optional func storeOverlayDidFinishPresentation(_ overlay: SKOverlay, transitionContext: SKOverlay.TransitionContext) // 挂件将要消失的回调 optional func storeOverlayWillStartDismissal(_ overlay: SKOverlay, transitionContext: SKOverlay.TransitionContext) // 挂件已经消失的回调 optional func storeOverlayDidFinishDismissal(_ overlay: SKOverlay, transitionContext: SKOverlay.TransitionContext)&#125; 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}]},{"title":"理解iOS端的WebView同层组件","slug":"454理解iOS端的WebView同层组件","date":"2022-12-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.400Z","comments":true,"path":"2022/12/30/454理解iOS端的WebView同层组件/","link":"","permalink":"http://huishao.cc/2022/12/30/454理解iOS端的WebView同层组件/","excerpt":"","text":"理解iOS端的WebView同层组件一 起始同层渲染是利用原生技术来优化Web渲染一种技术，很多人了解它是起于微信开放社区发布的一篇关于小程序渲染原理剖析的文章。我将链接附上： https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813 大部分的Web应用，所有的元素和组件都是渲染在WebView内部的，有时候这导致我们无法充分利用原生的强大能力，例如音视频播放，地图功能等。因此，在微信小程序开发框架中，还提供了一些以”cover-“开头的组件，这些组件本身是原生的，只是贴在了WebView上面。借助原生组件，可以极大的提高应用的性能体验，但是也有一些弊端。 原生组件的层级在WebView之上，因此无法在Web中通过标签的层级来调整组件的z轴位置。 原生组件与WebView文档流是完全脱离的，这使得布局的控制变得困难。 同层组件的出现正为解决这些问题。 二 原理同层组件的目标是将原生组件渲染在与其他Web组件同一层级中。在iOS中，我们使用WKWebView来创建Web视图，WKWebView在进行解析渲染时，会将Web组件渲染到WKCompositingView上，这个View是一个原生的UIView子类，通常WKWebView内核会将多个组件共同渲染到同一个WKCompositingView上，但是如果某个HTML标签的style设置了overflow: scroll属性，并且内容超出容器的大小，WKWebView就会为其单独的创建一个WKChildScrollView，因此如果我们可以找到这个View，并和对应的Web组件一一关联起来，就可以将原生的组件渲染到这个View中，从而实现同层渲染。 我们可以先写一个简单的Web示例页面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"\"&gt; &lt;style type=\"text/css\"&gt; .block &#123; width: 80%; height: 300pt; margin-top: 50pt; background-color: red; &#125; .content &#123; display: flex; flex-direction: column; align-items: center; width: 100%; &#125; .title &#123; width: 100%; text-align: center; &#125; .toast &#123; position: fixed; width: 250pt; height: 100pt; background-color: gray; line-height: 100pt; text-align: center; color: white; top: 50%; left: 50%; font-size: 50pt; transform: translate(-50%,-50%); &#125; .native &#123; width: 80%; height: 350pt; margin-top: 50pt; background-color: blue; overflow: scroll; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 标题 --&gt; &lt;h1 class=\"title\"&gt;H5页面Demo&lt;/h1&gt; &lt;!-- 内容 --&gt; &lt;div class=\"content\"&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;!-- 特殊组件 --&gt; &lt;div class=\"native\"&gt; &lt;div style=\"width: 101%; height: 101%\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;div class=\"block\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 弹框 --&gt; &lt;div class=\"toast show\"&gt;弹窗提示&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面代码中，蓝色的色块就是同层组件容器。 在iOS中加载此页面如下： 12345678910111213141516171819202122232425@interface ViewController ()@property (nonatomic, strong) WKWebView *webView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self.view addSubview:self.webView]; NSString *html = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"web\" ofType:@\"html\"] encoding: NSUTF8StringEncoding error:nil]; [self.webView loadHTMLString:html baseURL:nil]; &#125;- (WKWebView *)webView &#123; if (!_webView) &#123; _webView = [[WKWebView alloc] initWithFrame:self.view.frame]; &#125; return _webView;&#125;@end 使用Xcode调试工具进行查看，层级如下图所示： 可以看到对于蓝色的色块，WKWebView单独创建了一个WKChildScrollView来承载。 三 尝试了解了同层组件原理后，我们可以在iOS平台上做下尝试，体验同层组件的渲染效果。首先在HTML文件中补充下面的JS代码： 1234567891011121314151617181920212223&lt;script&gt; function insertNativeComponents() &#123; var ct = document.getElementsByClassName(\"native\")[0]; var id = ct.getAttribute(\"id\"); var frame = ct.getBoundingClientRect(); var args = &#123; \"frame\": &#123; \"y\": frame.top, \"x\": frame.left, \"width\": frame.width, \"height\": frame.height &#125;, \"id\": id &#125;; return args &#125; setTimeout(()=&gt;&#123; window.webkit.messageHandlers.nativeViewHandler.postMessage(&#123; \"command\": \"nativeViewInsert\", \"args\": insertNativeComponents() &#125;); &#125;, 1000);&lt;/script&gt; 上面的insertNativeComponents函数用来找到要插入原生组件的插槽，将其id等信息传递给原生端，我们这里为了演示方便，只传递了很少的数据，实际上可以根据组件的需求向原生端传递非常丰富的数据，原生端根据这些参数来渲染和设置原生组件。 在原生端，需要对WKWebView注册一个JS交互handle，如下： 1[_webView.configuration.userContentController addScriptMessageHandler:self name:@\"nativeViewHandler\"]; 对应的，实现协议方法如下： 123- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; [self insertNativeView:message];&#125; 核心的逻辑方法是inserNativeView，这个方法中要实现对JS交互指令的解析，以及原生组件的创建，插槽容器的寻找等，如下： 12345678910111213141516171819202122232425262728293031- (void)insertNativeView:(WKScriptMessage *)message &#123; NSDictionary *params = message.body[@\"args\"]; NSLog(@\"%@\", params); // 这里创建一个UILabel 做演示 UIView *v = [self findView:self.webView str:@\"\" ids:params[@\"id\"]]; UIView *c = [[UIView alloc] initWithFrame:v.bounds]; UILabel *l = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, v.frame.size.width, 100)]; l.backgroundColor = UIColor.orangeColor; l.font = [UIFont systemFontOfSize:40]; l.text = [NSString stringWithFormat:@\"组件ID为：%@的原生同层组件\", params[@\"id\"]]; l.textAlignment = NSTextAlignmentCenter; [c addSubview:l]; UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem]; [button setTitle:@\"按钮\" forState:UIControlStateNormal]; [button setTitleColor:UIColor.whiteColor forState:UIControlStateNormal]; button.frame = CGRectMake(0, 200, v.frame.size.width, 100); button.titleLabel.font = [UIFont systemFontOfSize:40]; [c addSubview:button]; if (v) &#123; // 查目标容器 for (UIView *sub in v.subviews) &#123; if ([sub isKindOfClass:NSClassFromString(@\"WKChildScrollView\")]) &#123; c.frame = sub.bounds; [sub addSubview:c]; &#125; &#125; &#125;&#125; 上面我们创建了一个UILabel和UIButton的原生组件做示例，插槽位置的寻找可以采用递归的方式，如下： 1234567891011121314151617- (UIView *)findView:(UIView *)root str:(NSString *)pre ids:(NSString *)ids &#123; if (!root) &#123; return nil; &#125; NSLog(@\"%@%@,%@\",pre ,root.class, root.layer.name); if ([root.layer.name containsString:[NSString stringWithFormat:@\"id='%@'\", ids]]) &#123; return root; &#125; for (UIView *v in root.subviews) &#123; UIView *res = [self findView:v str:[NSString stringWithFormat:@\"%@ - \", pre] ids: ids]; if (res) &#123; return res; &#125; &#125; return nil;&#125; 我们从JS交互命令可以拿到要插入原生组件的容器id，WKWebView在创建WKCompositingView时，其Layer的name会包含id信息，这从打印的信息上可以清楚的看到，如下图： 我们能找到对应的容器，就是靠这个Layer的name属性。现在你可以尝试运行下项目，效果如下图所示： 可以看到，原生组件已经正常渲染到了WebView中，且层级是受CSS控制的，其会出现在Web弹窗组件之下。 四 交互原生组件渲染成功了，并非完事大吉，如果你为按钮增加了点击事件，会发现其并不会触发，这是因为WebView将事件都进行了拦截。要处理交互问题也非常简单，首先需要先关闭WebView的拦截，在WebView加载完成后，使用如下代码来找到WKContentView，并将其手势拦截关闭： 12345678910111213- (void)handleGestrues &#123; UIScrollView *webViewScrollView = self.webView.scrollView; if ([webViewScrollView isKindOfClass:NSClassFromString(@\"WKScrollView\")]) &#123; UIView *_WKContentView = webViewScrollView.subviews.firstObject; if (![_WKContentView isKindOfClass:NSClassFromString(@\"WKContentView\")]) return; NSArray *gestrues = _WKContentView.gestureRecognizers; for (UIGestureRecognizer *gesture in gestrues) &#123; gesture.cancelsTouchesInView = NO; gesture.delaysTouchesBegan = NO; gesture.delaysTouchesEnded = NO; &#125; &#125;&#125; 需要注意，这个方法的调用要在WebView加载完成后。另外，我们需要将原生组件的容器组件做些修改，例如新建一个ContainerView类，如下： 1234567891011121314@interface ContainerView : UIView@end@implementation ContainerView- (BOOL)conformsToProtocol:(Protocol *)aProtocol &#123; if (aProtocol == NSProtocolFromString(@\"WKNativelyInteractible\")) &#123; return YES; &#125; return [super conformsToProtocol:aProtocol];&#125;@end 之后，将此View作为原生组件的容器，渲染到WebView中，即可实现原生组件的事件交互。 五 随想本文从原理出发，介绍了Web同层组件在iOS端的实现方式。相比直接使用原生组件，同层组件的好处是显而易见的，其既拥有了原生组件强大的能力，又可以被大部分CSS属性进行影响，方便层级和组件间位置控制。本文中也实现了一个简单的Demo来演示同层组件，Demo非常捡漏，希望起到抛砖引玉，帮助你打开创新的思路。下面是一些建议，有兴趣你可以尝试下在iOS端实现一套完整的同层组件渲染框架。 JS与原生的交互命令可以定制一套完整的协议，如组件插入，组件更新，组件删除等。 传递的数据可以定义的完整丰富，例如要插入的组件类型，可能是视频，音频，地图等，各种组件在原生端的属性配置等映射。 原生端的交互与更新行为也需要通过JS传递到Web。 原生端可能需要一个容器池来维护被插入的同层组件，方便通过id寻找来进行更新等。 某些CSS属性对于同层组件可能并不能生效，也是需要通过JS传递数据到原生端处理。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}]},{"title":"在iOS中使用NSURLProtocol进行网络代理","slug":"453在iOS中使用NSURLProtocol进行网络代理","date":"2022-11-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.400Z","comments":true,"path":"2022/11/27/453在iOS中使用NSURLProtocol进行网络代理/","link":"","permalink":"http://huishao.cc/2022/11/27/453在iOS中使用NSURLProtocol进行网络代理/","excerpt":"","text":"在iOS中使用NSURLProtocol进行网络代理一 引言网络能力是互联网应用程序必不可少的功能。随着应用程序的复杂，对网络的依赖性也会逐渐增高。如何统一的处理请求头，统一的处理回执数据，统一的进行网络请求过程的监控和修改等都是开发者要考虑的处理的问题。 通常，对于新项目，我们会统一封装网络框架在处理应用中的请求，整个网络的发起和收到回执的过程都可以很好的在底层的框架中进行监控和数据处理。但是这种方式对于网络请求不统一的老项目可能成本较高，要统一的修改网络框架，且对于WebView中的网络请求也需要单独处理，比较繁琐。这种情况下，不妨试一试Foundation框架中自带的NSURLProtocol来进行网络代理，完全无侵入的实现网络全过程的监控和修改处理。 二 牛刀小试在系统的介绍NSURLProtocol之前，我们先来通过一个小例子体验下其使用过程。 首先，NSURLProtocol虽然名字中有Protocol，但是它并不是一个协议，其是继承于NSObject的类。其次，虽然其实一个继承为NSObejct的类，但它更像是一个抽象类，我们不会直接拿这个类进行使用，而是会通过子类的方式来实现它，并且其内的很多方法也都是抽象的，必须由子类来实现。 我们新建一个测试工程，先实现一个简单的GET请求，如下： 12345NSURL *url = [NSURL URLWithString: @\"https://www.baidu.com\"];[[[NSURLSession sharedSession] dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@\"%@\", response);&#125;] resume] ; 运行代码，通过控制台的输出，可以看到能够正常的获取到回执数据。 新建一个命名为NetworkProtocl的类，使其继承自NSURLProtocol，实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#import \"NetworkProtcol.h\"@implementation NetworkProtcol// 网络请求的代理需要注册，在load方法中进行注册+ (void)load &#123; [NSURLProtocol registerClass:self];&#125;// 1. 这个方法是第一步，需要判断是否要拦截当前的请+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123; NSLog(@\"canInitWithRequest: %@\", request.URL.absoluteString); // 根据标记判断，如果处理过了就不再拦截了 if ([self propertyForKey:@\"Handle\" inRequest:request]) &#123; return false; &#125; return YES;&#125;// 2. 处理请求，这里可以返回一个新的Request对象，可以对原Request进行修改+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123; NSLog(@\"canonicalRequestForRequest: %@\", request.URL.absoluteString); return request;&#125;// 3. 这个方法处理拦截后的行为，可以做数据修改，本地mock或请求其他接口- (void)startLoading &#123; NSLog(@\"startLoading\"); [NSURLProtocol setProperty:@YES forKey:@\"Handle\" inRequest:self.request]; [[[NSURLSession sharedSession] dataTaskWithRequest:self.request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed]; [self.client URLProtocolDidFinishLoading:self]; &#125;] resume];&#125;// 整个代理行为结束回调- (void)stopLoading &#123; NSLog(@\"stopLoading\");&#125;@end 再次运行，通过控制台的打印，可以看到网络代理已经可以正常的工作，如上面的示例代码所示，整个代理过程最重要的即是三步： 1. 判断某个请求是否要进行代理拦截。 2. 处理请求，可以进行修改。 3. 执行真正的拦截行为，并通过回调来返回结果给原请求方。 三 NSURLProtocol详解NSURLProtocol本身比较简单，其暴露的接口和属性也比较简洁，解释如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@interface NSURLProtocol : NSObject// 初始化方法- (instancetype)initWithRequest:(NSURLRequest *)request cachedResponse:(nullable NSCachedURLResponse *)cachedResponse client:(nullable id &lt;NSURLProtocolClient&gt;)client;- (instancetype)initWithTask:(NSURLSessionTask *)task cachedResponse:(nullable NSCachedURLResponse *)cachedResponse client:(nullable id &lt;NSURLProtocolClient&gt;)client;// SessionTask对象@property (nullable, readonly, copy) NSURLSessionTask *task// 客户端对象，用来回调原请求方@property (nullable, readonly, retain) id &lt;NSURLProtocolClient&gt; client;// 当前处理的请求对象@property (readonly, copy) NSURLRequest *request;// Response缓存@property (nullable, readonly, copy) NSCachedURLResponse *cachedResponse;// 这个方法必须子类实现，用来判断是否要拦截某个请求+ (BOOL)canInitWithRequest:(NSURLRequest *)request;+ (BOOL)canInitWithTask:(NSURLSessionTask *)task;// 这个方法必须子类实现，用来对请求进行修改+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request;// 这个方法用来判断是否要使用缓存请求，判断要进行的请求与缓存的是否相同+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b;// 开始拦截行为- (void)startLoading;// 整个拦截行为结束- (void)stopLoading;// 用来给某个请求打标签，可以防止请求拦截出现递归+ (void)setProperty:(id)value forKey:(NSString *)key inRequest:(NSMutableURLRequest *)request;// 获取标签+ (nullable id)propertyForKey:(NSString *)key inRequest:(NSURLRequest *)request;// 删除标签+ (void)removePropertyForKey:(NSString *)key inRequest:(NSMutableURLRequest *)request;// 注册网络代理类+ (BOOL)registerClass:(Class)protocolClass;// 注销注册的代理+ (void)unregisterClass:(Class)protocolClass;@end 其中，client属性用来与原请求方交互，其协议的方法如下： 1234567891011121314151617181920@protocol NSURLProtocolClient &lt;NSObject&gt;// 触发客户端的重定向回调- (void)URLProtocol:(NSURLProtocol *)protocol wasRedirectedToRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)redirectResponse;// 触发客户端的缓存有效性回调- (void)URLProtocol:(NSURLProtocol *)protocol cachedResponseIsValid:(NSCachedURLResponse *)cachedResponse;// 触发客户端的接收回执回调- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveResponse:(NSURLResponse *)response cacheStoragePolicy:(NSURLCacheStoragePolicy)policy;// 触发客户端的接收数据回调- (void)URLProtocol:(NSURLProtocol *)protocol didLoadData:(NSData *)data;// 触发客户端的请求完成回调- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)protocol;// 触发客户端的请求失败回调- (void)URLProtocol:(NSURLProtocol *)protocol didFailWithError:(NSError *)error;// 触发客户端的用户认证回调- (void)URLProtocol:(NSURLProtocol *)protocol didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;// 触发客户端的取消用户认证回调- (void)URLProtocol:(NSURLProtocol *)protocol didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;@end 四 对网页视图的网络请求进行拦截如果是使用UIWebView加载网页，则NSURLProtocol默认支持拦截，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#import \"NetworkProtcol.h\"@interface NetworkProtcol ()&lt;NSURLSessionDelegate&gt;@property (atomic,strong,readwrite) NSURLSessionDataTask *task;@property (nonatomic,strong) NSURLSession *session;@end@implementation NetworkProtcol+ (void)load &#123; [NSURLProtocol registerClass:self];&#125;+ (BOOL)canInitWithRequest:(NSURLRequest *)request&#123; //只处理http和https请求 NSString *scheme = [[request URL] scheme]; if ( ([scheme caseInsensitiveCompare:@\"http\"] == NSOrderedSame || [scheme caseInsensitiveCompare:@\"https\"] == NSOrderedSame)) &#123; //看看是否已经处理过了，防止无限循环 if ([NSURLProtocol propertyForKey:@\"Handle\" inRequest:request]) &#123; return NO; &#125; return YES; &#125; return NO;&#125;+ (NSURLRequest *) canonicalRequestForRequest:(NSURLRequest *)request &#123; return request;&#125;- (void)startLoading&#123; NSMutableURLRequest *mutableReqeust = [[self request] mutableCopy]; //打标签，防止无限循环 [NSURLProtocol setProperty:@YES forKey:@\"Handle\" inRequest:mutableReqeust]; NSURLSessionConfiguration *configure = [NSURLSessionConfiguration defaultSessionConfiguration]; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; self.session = [NSURLSession sessionWithConfiguration:configure delegate:self delegateQueue:queue]; self.task = [self.session dataTaskWithRequest:mutableReqeust]; [self.task resume];&#125;- (void)stopLoading&#123; [self.session invalidateAndCancel]; self.session = nil;&#125;- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; if (error != nil) &#123; [self.client URLProtocol:self didFailWithError:error]; &#125;else &#123; [self.client URLProtocolDidFinishLoading:self]; &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123; [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; completionHandler(NSURLSessionResponseAllow);&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; [self.client URLProtocol:self didLoadData:data];&#125;@end 如果使用的是WKWebView，则无法直接被拦截，需要做如下的额外处理： 12345678910111213Class cls = [[[WKWebView new] valueForKey:@\"browsingContextController\"] class];SEL sel = NSSelectorFromString(@\"registerSchemeForCustomProtocol:\");if ([cls respondsToSelector:sel]) &#123; // 通过 http 和 https 的请求，同理可通过其他的 Scheme 但是要满足 URL Loading System [cls performSelector:sel withObject:@\"http\"]; [cls performSelector:sel withObject:@\"https\"];&#125;WKWebView *web = [[WKWebView alloc] initWithFrame:self.view.frame];[self.view addSubview:web];NSURL *url = [NSURL URLWithString: @\"https://www.baidu.com\"];[web loadRequest:[NSURLRequest requestWithURL:url]]; 需要注意，这里会涉及到一些私有属性和方法，可能会存在提审风险。 五 一些思考NSURLProtocol的使用非常简单，但是可以做的事情却并不少。例如我们可以用其来做统一的网络处理，来做无侵入的网络监控等。 作为底层工具，统一的为Request添加通用Header字段。 统一的进行自定义用户认证。 做为环境切换工具，根据环境做URL的映射。 请求参数的整理和修改，统一增加通用参数。 统一修改或增加Response Header数据。 根据需求，做为本地的Mock工具，访问到本地服务或Mock远程数据。 监控端到端的网络请求性能，进行时间统计。 等等… 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}]},{"title":"对Swift中some和any关键字的理解","slug":"452对Swift中some和any关键字的理解","date":"2022-10-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.399Z","comments":true,"path":"2022/10/31/452对Swift中some和any关键字的理解/","link":"","permalink":"http://huishao.cc/2022/10/31/452对Swift中some和any关键字的理解/","excerpt":"","text":"对Swift中some和any关键字的理解在最新Swift版本中（Xcode14,Swift5.7），如果协议中有使用泛型，则如果要将此协议作为参数类型，必须使用any关键字进行修饰。其实在Swift5.1中也引入过一个some关键字，any和some都适用于协议，这两个关键字从语义上和写法上对泛型的使用进行了优化。 1. any我们知道，协议中会规定一些属性和方法，用来约束其他结构的实现。举个简单的例子，我们可以使用协议定义了一个可飞行的实例需要实现的方法和属性，如下： 1234567891011121314151617protocol Fly &#123; var name:String &#123;get set&#125; func fly()&#125;class Bird:Fly &#123; var name = \"Bird\" func fly() &#123; print(name + \"Fly\") &#125;&#125;func test(f: Fly) &#123; f.fly()&#125;test(f: Bird()) 这个程序当前运行的很好，语义也很明确，即test的函数的参数需要是实现了Fly协议的任意类型，其实在此中情况下，虽然在调用是我们传入的是Bird实例，但是由于协议类型的约束较弱，在函数执行时编译器会将其解释成了Fly类型，实际上产生了类型丢失。尤其是当协议中有使用泛型时，此时上面的写法在最新的Xcode版本中会提示错误，需要我们添加any关键字。any关键字的意义其实就是实现上述的语义，将参数类型定义为遵守某个协议的任意类型，如下： 12345678910111213141516171819202122import Foundationprotocol Fly &#123; associatedtype T var name:T &#123;get set&#125; func fly()&#125;class Bird:Fly &#123; typealias T = String var name = \"Bird\" func fly() &#123; print(name + \"Fly\") &#125;&#125;func test(f: any Fly) &#123; f.fly()&#125;let f = test(f: Bird()) 2.some针对于上面代码的应用场景，我们只需要约束参数的类型是遵守Fly协议的即可，但是有时候这并不够，有时协议中的函数会需要多个参数，我们需要使用泛型约束其参数的类型一致，例如： 12345678910111213141516171819202122232425262728import Foundationprotocol Fly &#123; associatedtype T var name:T &#123;get set&#125; func fly() func add(a:T, b:T)&#125;class Bird:Fly &#123; typealias T = String var name = \"Bird\" func fly() &#123; print(name + \"Fly\") &#125; func add(a: String, b: String) &#123; &#125;&#125;func test(f: any Fly) &#123; f.fly() // 这里会报错 因为any Fly类型在运行时无法确定成某个具体的类型 f.add(a: f.name, b: f.name)&#125;test(f: Bird()) 可以看到，上面的代码中，test函数会报错，核心的原因在于any Fly类型的语音是任意实现了Fly协议的类型，无论是编译时还是运行时，编译器都无法推导出此f参数的类型。要解决上面的问题，可以采用泛型的方式来改写，如下： 1234func test&lt;T:Fly&gt;(f: T) &#123; f.fly() f.add(a: f.name, b: f.name)&#125; 此时代码则没有任何问题了，some关键字其实也是用于这一种场景，其表示的是一种透明类型，在运行时编译器知道其具体的类型是什么，只是对调用方来说是抽象的。下面的写法与上面使用泛型的写法作用完全一致： 1234func test(f: some Fly) &#123; f.fly() f.add(a: f.name, b: f.name)&#125; 整体看来，相对与泛型那种写法，使用some的写法语义更加清晰，风格上也与any刚好一致。 最后，我们再来总结下，整体看来，any和some都是用来描述语义的关键字，any和协议一起使用，表示的是语义比较传统，及遵守了某个协议的类型，具体什么类型编译器也不知道。而some和协议一起使用表示的是具象的一个类型，此类型编译时不知道，调用时也开发者来说也是透明的，但是编译器自己是知道的，它就是具体的一个类型。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Swift","slug":"Swift","permalink":"http://huishao.cc/categories/Swift/"}],"tags":[],"keywords":[{"name":"Swift","slug":"Swift","permalink":"http://huishao.cc/categories/Swift/"}]},{"title":"iOS分享扩展支持自定义联系人","slug":"450iOS分享扩展支持自定义联系人","date":"2022-08-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.399Z","comments":true,"path":"2022/08/17/450iOS分享扩展支持自定义联系人/","link":"","permalink":"http://huishao.cc/2022/08/17/450iOS分享扩展支持自定义联系人/","excerpt":"","text":"iOS分享扩展支持自定义联系人iOS可以通过添加Share Extension来扩展系统的分享组件，能够支持将网页，图片，音乐或任何接入了系统分享组件功能的应用分享到我们自己的App内。分享Extension的介绍可以在如下文章中查看： https://my.oschina.net/u/2340880/blog/485656 如果你有使用过抖音，你会发现抖音不仅提供了分享扩展，也提供了更加便捷的分享到联系人的功能，在系统的分享面板中可以看到推荐的抖音联系人信息，如下图所示： 通过联系人推荐入口，我们可以快速的将内容分享到指定的联系人，非常方便。 要向系统分享组件中添加推荐联系人功能也非常简单，只将分享扩展需要结合INSendMessageIntent进行使用即可。简单来说，分为3步： 1. 为应用工程添加一个Share Extension的扩展。 2. 声明对INSendMessageIntent意图类型的支持。 3. 使用代码注入一些INSendMessageIntent意图到扩展中。 首先，我们先来做第一步，新建一个Share Extension，选择如下图的Target插件即可： 暂时我们先不编写任何额外的代码。 之后，在宿主App工程的Info.plist文件中添加如下键值： 在Extension的Info.plist中添加如下键值： 需要注意，宿主App和扩展插件中的Info.plist文件都要处理，缺一不可。 最后，我们在宿主App中执行如下代码即可注入意图： 123456789101112// 联系人名字INSpeakableString *groupName = [[INSpeakableString alloc] initWithSpokenPhrase:@\"珲少\"];// 联系人图片INImage *image = [INImage imageWithImageData:UIImagePNGRepresentation([UIImage imageNamed:@\"aa\"])];// 创建意图对象INSendMessageIntent *intent = [[INSendMessageIntent alloc] initWithRecipients:nil content:nil speakableGroupName:groupName conversationIdentifier:@\"huishao.id\" serviceName:nil sender:nil];[intent setImage:image forParameterNamed:@\"groupName\"];// 进行注入self.interaction = [[INInteraction alloc] initWithIntent:intent response:nil];[self.interaction donateInteractionWithCompletion:^(NSError * _Nullable error) &#123; &#125;]; 之后，运行App，在系统的分享面板中可以看到我们注入的推荐联系人信息了，如图： 参考文档： https://developer.apple.com/documentation/foundation/app_extension_support/supporting_suggestions_in_your_app_s_share_extension?language=objc 专注技术，热爱生活，交流技术，也做朋友。 —— 珲少 QQ 群：203317592","categories":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}]},{"title":"聊聊iOS中的Mach-O","slug":"451[iOS研习记]聊聊iOS中的Mach-O","date":"2022-08-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.399Z","comments":true,"path":"2022/08/17/451[iOS研习记]聊聊iOS中的Mach-O/","link":"","permalink":"http://huishao.cc/2022/08/17/451[iOS研习记]聊聊iOS中的Mach-O/","excerpt":"","text":"聊聊iOS中的Mach-O一 关于Mach-OMach-O的全称为Mach Object，是OS X与iOS上的一种可执行文件格式。Mach本身指一种操作系统的微内核标准，被用于OS X与iOS系统的内核中。相信对于移动端的iOS开发者来说，对Mach-O文件一定不陌生，我们编译打包的iOS IPA文件，内部其实就有一个可执行的Mach-O文件，我们开发的framework和.a等动态库静态库中，也会包含Mach-O文件，本篇文章，我们就来详细看看Mach-O中究竟放的是什么，Mach-O的结构是怎样的。 二 Mach-O头信息Mach-O是一种文件格式，我们知道很多文件类型有包含有文件头，例如图片文件头中可能会包含图片的格式，编码方式等，压缩文件的文件头中包含压缩参数等等。相比，Mach-O是一种更加复杂的文件，其文件头中提供的信息也更多。我们可以在Github上找到一款开源的Mach-O文件阅读软件：MachOView。可以尝试用其打开任意一个编译好的IPA包中的Mach-O文件，例如： 可以看到，格式化后的文件内容中，有一项是Mach64 Header，这一项内容也是在Mach-O文件的最前部，这里就是Mach-O文件头。 关于Mach-O头部，我们可以在usr/include/mach-o/Loader.h文件中找到对应的定义，如下： 123456789101112131415161718192021// 32位的Mach-O头struct mach_header &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */&#125;;// 64位的Mach-O头struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; 可以看到，32位的Mach-O和64位的Mach-O最大的区别只在于64位的多了一个reserved字段，此字段当前并没有特殊意义，其预留给未来使用。下面我们来详细看下这些字段的意义。 1.magic 从其数据类型uint32_t也可以看出，magic占32个二进制位。顾名思义，这个字段是一个魔数，用来区分当前Mach-O是32位的还是64位的，有两个宏对此魔数的值进行了定义： 1234// 32位#define MH_MAGIC 0xfeedface// 64位#define MH_MAGIC_64 0xfeedfacf 你可以看下MachOView软件格式化后的此字段的值，是否和这些宏是对应的。 2.cputype 此字段占32个二进制位，用来描述CPU类型，相关宏定义在mach/machine.h头文件中，如下： 123456789101112131415161718#define CPU_TYPE_ANY ((cpu_type_t) -1)#define CPU_TYPE_VAX ((cpu_type_t) 1)#define CPU_TYPE_MC680x0 ((cpu_type_t) 6)// 模拟器和Maac一般为此类型#define CPU_TYPE_X86 ((cpu_type_t) 7)#define CPU_TYPE_I386 CPU_TYPE_X86 #define CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)#define CPU_TYPE_MC98000 ((cpu_type_t) 10)#define CPU_TYPE_HPPA ((cpu_type_t) 11)// iPhone真机一般为此类型#define CPU_TYPE_ARM ((cpu_type_t) 12)#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)#define CPU_TYPE_ARM64_32 (CPU_TYPE_ARM | CPU_ARCH_ABI64_32)#define CPU_TYPE_MC88000 ((cpu_type_t) 13)#define CPU_TYPE_SPARC ((cpu_type_t) 14)#define CPU_TYPE_I860 ((cpu_type_t) 15)#define CPU_TYPE_POWERPC ((cpu_type_t) 18)#define CPU_TYPE_POWERPC64 (CPU_TYPE_POWERPC | CPU_ARCH_ABI64) 其中的cpu_type_t其实就是int类型的别名。 3.cpusubtype CPU子类型，定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#define CPU_SUBTYPE_MASK 0xff000000 #define CPU_SUBTYPE_LIB64 0x80000000 #define CPU_SUBTYPE_PTRAUTH_ABI 0x80000000 #define CPU_SUBTYPE_ANY ((cpu_subtype_t) -1)#define CPU_SUBTYPE_MULTIPLE ((cpu_subtype_t) -1)#define CPU_SUBTYPE_LITTLE_ENDIAN ((cpu_subtype_t) 0)#define CPU_SUBTYPE_BIG_ENDIAN ((cpu_subtype_t) 1)// VAX的子类型#define CPU_SUBTYPE_VAX_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_VAX780 ((cpu_subtype_t) 1)#define CPU_SUBTYPE_VAX785 ((cpu_subtype_t) 2)#define CPU_SUBTYPE_VAX750 ((cpu_subtype_t) 3)#define CPU_SUBTYPE_VAX730 ((cpu_subtype_t) 4)#define CPU_SUBTYPE_UVAXI ((cpu_subtype_t) 5)#define CPU_SUBTYPE_UVAXII ((cpu_subtype_t) 6)#define CPU_SUBTYPE_VAX8200 ((cpu_subtype_t) 7)#define CPU_SUBTYPE_VAX8500 ((cpu_subtype_t) 8)#define CPU_SUBTYPE_VAX8600 ((cpu_subtype_t) 9)#define CPU_SUBTYPE_VAX8650 ((cpu_subtype_t) 10)#define CPU_SUBTYPE_VAX8800 ((cpu_subtype_t) 11)#define CPU_SUBTYPE_UVAXIII ((cpu_subtype_t) 12)// MC680子类型#define CPU_SUBTYPE_MC680x0_ALL ((cpu_subtype_t) 1)#define CPU_SUBTYPE_MC68030 ((cpu_subtype_t) 1)#define CPU_SUBTYPE_MC68040 ((cpu_subtype_t) 2)#define CPU_SUBTYPE_MC68030_ONLY ((cpu_subtype_t) 3)// I386子类型#define CPU_SUBTYPE_INTEL(f, m) ((cpu_subtype_t) (f) + ((m) &lt;&lt; 4))#define CPU_SUBTYPE_I386_ALL CPU_SUBTYPE_INTEL(3, 0)#define CPU_SUBTYPE_386 CPU_SUBTYPE_INTEL(3, 0)#define CPU_SUBTYPE_486 CPU_SUBTYPE_INTEL(4, 0)#define CPU_SUBTYPE_486SX CPU_SUBTYPE_INTEL(4, 8) // 8 &lt;&lt; 4 = 128#define CPU_SUBTYPE_586 CPU_SUBTYPE_INTEL(5, 0)#define CPU_SUBTYPE_PENT CPU_SUBTYPE_INTEL(5, 0)#define CPU_SUBTYPE_PENTPRO CPU_SUBTYPE_INTEL(6, 1)#define CPU_SUBTYPE_PENTII_M3 CPU_SUBTYPE_INTEL(6, 3)#define CPU_SUBTYPE_PENTII_M5 CPU_SUBTYPE_INTEL(6, 5)#define CPU_SUBTYPE_CELERON CPU_SUBTYPE_INTEL(7, 6)#define CPU_SUBTYPE_CELERON_MOBILE CPU_SUBTYPE_INTEL(7, 7)#define CPU_SUBTYPE_PENTIUM_3 CPU_SUBTYPE_INTEL(8, 0)#define CPU_SUBTYPE_PENTIUM_3_M CPU_SUBTYPE_INTEL(8, 1)#define CPU_SUBTYPE_PENTIUM_3_XEON CPU_SUBTYPE_INTEL(8, 2)#define CPU_SUBTYPE_PENTIUM_M CPU_SUBTYPE_INTEL(9, 0)#define CPU_SUBTYPE_PENTIUM_4 CPU_SUBTYPE_INTEL(10, 0)#define CPU_SUBTYPE_PENTIUM_4_M CPU_SUBTYPE_INTEL(10, 1)#define CPU_SUBTYPE_ITANIUM CPU_SUBTYPE_INTEL(11, 0)#define CPU_SUBTYPE_ITANIUM_2 CPU_SUBTYPE_INTEL(11, 1)#define CPU_SUBTYPE_XEON CPU_SUBTYPE_INTEL(12, 0)#define CPU_SUBTYPE_XEON_MP CPU_SUBTYPE_INTEL(12, 1)#define CPU_SUBTYPE_INTEL_FAMILY(x) ((x) &amp; 15)#define CPU_SUBTYPE_INTEL_FAMILY_MAX 15#define CPU_SUBTYPE_INTEL_MODEL(x) ((x) &gt;&gt; 4)#define CPU_SUBTYPE_INTEL_MODEL_ALL 0// X86子类型#define CPU_SUBTYPE_X86_ALL ((cpu_subtype_t)3)#define CPU_SUBTYPE_X86_64_ALL ((cpu_subtype_t)3)#define CPU_SUBTYPE_X86_ARCH1 ((cpu_subtype_t)4)#define CPU_SUBTYPE_X86_64_H ((cpu_subtype_t)8)#define CPU_THREADTYPE_INTEL_HTT ((cpu_threadtype_t) 1)// MIPS子类型#define CPU_SUBTYPE_MIPS_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_MIPS_R2300 ((cpu_subtype_t) 1)#define CPU_SUBTYPE_MIPS_R2600 ((cpu_subtype_t) 2)#define CPU_SUBTYPE_MIPS_R2800 ((cpu_subtype_t) 3)#define CPU_SUBTYPE_MIPS_R2000a ((cpu_subtype_t) 4) /* pmax */#define CPU_SUBTYPE_MIPS_R2000 ((cpu_subtype_t) 5)#define CPU_SUBTYPE_MIPS_R3000a ((cpu_subtype_t) 6) /* 3max */#define CPU_SUBTYPE_MIPS_R3000 ((cpu_subtype_t) 7)// MC98000子类型#define CPU_SUBTYPE_MC98000_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_MC98601 ((cpu_subtype_t) 1)// HPPA子类型#define CPU_SUBTYPE_HPPA_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_HPPA_7100 ((cpu_subtype_t) 0) /* compat */#define CPU_SUBTYPE_HPPA_7100LC ((cpu_subtype_t) 1)// MC88000子类型#define CPU_SUBTYPE_MC88000_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_MC88100 ((cpu_subtype_t) 1)#define CPU_SUBTYPE_MC88110 ((cpu_subtype_t) 2)// SPARC子类型#define CPU_SUBTYPE_SPARC_ALL ((cpu_subtype_t) 0)// I860子类型#define CPU_SUBTYPE_I860_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_I860_860 ((cpu_subtype_t) 1)// PowerPC子类型#define CPU_SUBTYPE_POWERPC_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_POWERPC_601 ((cpu_subtype_t) 1)#define CPU_SUBTYPE_POWERPC_602 ((cpu_subtype_t) 2)#define CPU_SUBTYPE_POWERPC_603 ((cpu_subtype_t) 3)#define CPU_SUBTYPE_POWERPC_603e ((cpu_subtype_t) 4)#define CPU_SUBTYPE_POWERPC_603ev ((cpu_subtype_t) 5)#define CPU_SUBTYPE_POWERPC_604 ((cpu_subtype_t) 6)#define CPU_SUBTYPE_POWERPC_604e ((cpu_subtype_t) 7)#define CPU_SUBTYPE_POWERPC_620 ((cpu_subtype_t) 8)#define CPU_SUBTYPE_POWERPC_750 ((cpu_subtype_t) 9)#define CPU_SUBTYPE_POWERPC_7400 ((cpu_subtype_t) 10)#define CPU_SUBTYPE_POWERPC_7450 ((cpu_subtype_t) 11)#define CPU_SUBTYPE_POWERPC_970 ((cpu_subtype_t) 100)// ARM子类型#define CPU_SUBTYPE_ARM_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_ARM_V4T ((cpu_subtype_t) 5)#define CPU_SUBTYPE_ARM_V6 ((cpu_subtype_t) 6)#define CPU_SUBTYPE_ARM_V5TEJ ((cpu_subtype_t) 7)#define CPU_SUBTYPE_ARM_XSCALE ((cpu_subtype_t) 8)#define CPU_SUBTYPE_ARM_V7 ((cpu_subtype_t) 9) /* ARMv7-A and ARMv7-R */#define CPU_SUBTYPE_ARM_V7F ((cpu_subtype_t) 10) /* Cortex A9 */#define CPU_SUBTYPE_ARM_V7S ((cpu_subtype_t) 11) /* Swift */#define CPU_SUBTYPE_ARM_V7K ((cpu_subtype_t) 12)#define CPU_SUBTYPE_ARM_V8 ((cpu_subtype_t) 13)#define CPU_SUBTYPE_ARM_V6M ((cpu_subtype_t) 14) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V7M ((cpu_subtype_t) 15) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V7EM ((cpu_subtype_t) 16) /* Not meant to be run under xnu */#define CPU_SUBTYPE_ARM_V8M ((cpu_subtype_t) 17) /* Not meant to be run under xnu */// ARM64子类型#define CPU_SUBTYPE_ARM64_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_ARM64_V8 ((cpu_subtype_t) 1)#define CPU_SUBTYPE_ARM64E ((cpu_subtype_t) 2)#define CPU_SUBTYPE_ARM64_PTR_AUTH_MASK 0x0f000000#define CPU_SUBTYPE_ARM64_PTR_AUTH_VERSION(x) (((x) &amp; CPU_SUBTYPE_ARM64_PTR_AUTH_MASK) &gt;&gt; 24)// ARM64_32子类型#define CPU_SUBTYPE_ARM64_32_ALL ((cpu_subtype_t) 0)#define CPU_SUBTYPE_ARM64_32_V8 ((cpu_subtype_t) 1) 4.filetype 此字段标记Mach-O文件的具体类型，例如当前Mach-O是可执行文件还是库文件等，此字段占32个二进制位，值定义如下： 123456789101112131415161718192021222324// 可重定位的目标文件，编译源码得到的中间结果#define MH_OBJECT 0x1 // 可执行的二进制文件，iOS应用IPA包中的可执行Mach-O就是此类型的#define MH_EXECUTE 0x2// 修复后的VM共享库文件#define MH_FVMLIB 0x3// 核心转储文件#define MH_CORE 0x4 // 预加载的可执行文件#define MH_PRELOAD 0x5// 动态库文件#define MH_DYLIB 0x6 // 动态链接器文件#define MH_DYLINKER 0x7 // 插件文件，非独立的二进制文件#define MH_BUNDLE 0x8// 仅用于静态链接的共享库文件#define MH_DYLIB_STUB 0x9// 辅助的符号文件及调试信息#define MH_DSYM 0xa// 内核扩展#define MH_KEXT_BUNDLE 0xb// 其他Mach-O组成的集合#define MH_FILESET 0xc 5.ncmds 此字段描述需要加载的命令条数，与Mach-O文件中的Load Commands段中的数据对应。 6.sizeofcmds 与Mach-O文件中的Load Commands段中的数据对应，标记Load Commands段的长度。 7.flags 标志位字段，标记当前Mach-O文件的一些重要信息，这些flags是以二进制位或的关系定义的，也就是说可以同时拥有多个标记。定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 未带未定义的符号，没有进一步的链接依赖关系#define MH_NOUNDEFS 0x1 // 目标文件是增量链接的输出，不能再次被链接#define MH_INCRLINK 0x2 // 目标文件是动态链接器的输入，不能再次静态链接#define MH_DYLDLINK 0x4// 加载时，对象文件的未定义引用由动态链接器绑定#define MH_BINDATLOAD 0x8// 该文件预先绑定了其动态未定义引用#define MH_PREBOUND 0x10// 目标文件的只读段与可读写段进行了区分#define MH_SPLIT_SEGS 0x20// 延迟init#define MH_LAZY_INIT 0x40// 两层名称绑定#define MH_TWOLEVEL 0x80// 扁平名称绑定#define MH_FORCE_FLAT 0x100// 子image中没有多定义的符号#define MH_NOMULTIDEFS 0x200// 不要让dyld将此可执行文件通知预绑定代理#define MH_NOFIXPREBINDING 0x400// 二进制文件不是预绑定的，但可以重新进行预绑定#define MH_PREBINDABLE 0x800 // 指示此二进制文件绑定到其依赖库的所有两级命名空间模块#define MH_ALLMODSBOUND 0x1000#define MH_SUBSECTIONS_VIA_SYMBOLS 0x2000// 二进制文件已被规范化为非绑定操作#define MH_CANONICAL 0x4000// 二进制文件使用了弱符号#define MH_WEAK_DEFINES 0x8000// 最终链接的image使用了弱符号#define MH_BINDS_TO_WEAK 0x10000// 允许栈可执行#define MH_ALLOW_STACK_EXECUTION 0x20000// 当设置此位时，二进制文件声明它可以安全地用于uid为零的进程#define MH_ROOT_SAFE 0x40000 // 当设置该位时，二进制文件声明它可以在issetugid为true的进程中安全使用#define MH_SETUID_SAFE 0x80000 // 当在dylib上设置此位时，静态链接器不需要检查依赖的dylib，以查看是否有重新导出的依赖dylib#define MH_NO_REEXPORTED_DYLIBS 0x100000// 对可执行文件启用地址空间布局随机化#define MH_PIE 0x200000 // 仅适用于dylibs。当链接到设置了此位的dylib时，如果没有从dylib引用符号，则静态链接器将自动不对dylib创建LC_LOAD_dylib加载命令#define MH_DEAD_STRIPPABLE_DYLIB 0x400000#define MH_HAS_TLV_DESCRIPTORS 0x800000// 将堆标记为不可执行#define MH_NO_HEAP_EXECUTION 0x1000000// 扩展应用中使用#define MH_APP_EXTENSION_SAFE 0x02000000// nlist符号表中列出的外部符号不包括dyld信息中列出的所有符号#define MH_NLIST_OUTOFSYNC_WITH_DYLDINFO 0x04000000#define MH_SIM_SUPPORT 0x08000000// 仅适用于dylibs。设置该位时，dylib是dyld共享缓存的一部分，而不是文件系统中的松散缓存。#define MH_DYLIB_IN_CACHE 0x80000000 Mach-O文件头的内容大致就只有这些，上面我们提到过，ncmds和sizeofcmds描述了加载命令的条数和加载命令的内容大小，下面我们就来看下加载命令。 三 加载命令在Mach-O文件中，加载命令段紧跟在Mach-O头数据后面，头数据中的字段告知了我们加载命令的条数和大小，通过这两个字段来具体的进行命令的解析和执行。 我们现在MachOView中简单浏览下这部分的数据结构，如下图： 可以看到，每条加载命令的开头结构都是一样的，即命令类型和当前命令的长度大小。其实，在loader.h头文件中有定义一个结构体来描述加载命令，如下： 1234struct load_command &#123; uint32_t cmd; uint32_t cmdsize; &#125;; 可以看到，每条加载命令在解析时，首先会获取到cmd和cmdsize，cmd用来标记加载命令是什么，cmdsize指明当前加载命令的字节长度，通过这两个字段，可以对命令进行完整的解析。 下面列举了常见的命令类型，对应的宏定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 将文件中的段（32位）映射到进程地址空间中#define LC_SEGMENT 0x1// 将文件中的段（64位）映射到进程地址空间中#define LC_SEGMENT_64 0x19// 链接编辑stab符号表信息#define LC_SYMTAB 0x2// 链接编辑gdb符号表信息#define LC_SYMSEG 0x3// 开启一个Mach线程，不开辟栈#define LC_THREAD 0x4// 开启一个UNIX线程#define LC_UNIXTHREAD 0x5// 加载指定的固定VM共享库#define LC_LOADFVMLIB 0x6 // 修复了VM共享库标识#define LC_IDFVMLIB 0x7// 对象标识信息#define LC_IDENT 0x8// 固定VM文件包含#define LC_FVMFILE 0x9// prepage命令#define LC_PREPAGE 0xa// 动态链接编辑符号表信息 #define LC_DYSYMTAB 0xb// 加载动态链接的共享库#define LC_LOAD_DYLIB 0xc// 动态链接共享库标识#define LC_ID_DYLIB 0xd// 加载动态链接器#define LC_LOAD_DYLINKER 0xe// 动态链接器标识#define LC_ID_DYLINKER 0xf// 动态预绑定的模块#define LC_PREBOUND_DYLIB 0x10// 下面的命令与链接共享库有关// image routines#define LC_ROUTINES 0x11 /* image routines */#define LC_ROUTINES_64 0x1a#define LC_SUB_FRAMEWORK 0x12 /* sub framework */#define LC_SUB_UMBRELLA 0x13 /* sub umbrella */#define LC_SUB_CLIENT 0x14 /* sub client */#define LC_SUB_LIBRARY 0x15 /* sub library */#define LC_TWOLEVEL_HINTS 0x16 /* two-level namespace lookup hints */#define LC_PREBIND_CKSUM 0x17 /* prebind checksum */// 加载允许丢失的动态链接共享库#define LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)// 唯一的UUID，表示当前二进制文件#define LC_UUID 0x1b// 进行本地代码签名#define LC_CODE_SIGNATURE 0x1d// 本地拆分段#define LC_SEGMENT_SPLIT_INFO 0x1e // 加载并重新导出dylib#define LC_REEXPORT_DYLIB (0x1f | LC_REQ_DYLD)// 将dylib加载延迟至首次使用#define LC_LAZY_LOAD_DYLIB 0x20// 加密的段信息#define LC_ENCRYPTION_INFO 0x21#define LC_ENCRYPTION_INFO_64 0x2C// 压缩的dyld信息#define LC_DYLD_INFO 0x22// 仅限压缩的dyld信息#define LC_DYLD_INFO_ONLY (0x22|LC_REQ_DYLD)// 向上加载dylib#define LC_LOAD_UPWARD_DYLIB (0x23 | LC_REQ_DYLD)// 为MacOSX最小操作系统版本构建#define LC_VERSION_MIN_MACOSX 0x24// 为iOS最小操作系统版本构建#define LC_VERSION_MIN_IPHONEOS 0x25// 为TVOS最小操作系统版本构建#define LC_VERSION_MIN_TVOS 0x2F// 为WATCHOS最小操作系统版本构建#define LC_VERSION_MIN_WATCHOS 0x30// 压缩的函数起始地址表#define LC_FUNCTION_STARTS 0x26// dyld要像环境变量一样处理的字符串#define LC_DYLD_ENVIRONMENT 0x27// 同LC_UNIXTHREAD#define LC_MAIN (0x28|LC_REQ_DYLD)// __text段中的非说明表#define LC_DATA_IN_CODE 0x29// 用于生成二进制文件的源代码版本#define LC_SOURCE_VERSION 0x2A// 从链接的dylibs复制的代码签名DR#define LC_DYLIB_CODE_SIGN_DRS 0x2B// MH_OBJECT文件中的链接器选项#define LC_LINKER_OPTION 0x2D // MH_OBJECT文件中的优化提示#define LC_LINKER_OPTIMIZATION_HINT 0x2E// Mach-O文件中包含的任意数据#define LC_NOTE 0x31// 为平台最小操作系统版本构建#define LC_BUILD_VERSION 0x32// 与linkedit_data_command一起使用#define LC_DYLD_EXPORTS_TRIE (0x33 | LC_REQ_DYLD)#define LC_DYLD_CHAINED_FIXUPS (0x34 | LC_REQ_DYLD)// 与fileset_entry_command一起使用#define LC_FILESET_ENTRY (0x35 | LC_REQ_DYLD) 在加载命令段，通过解析出每条命令的类型和大小，就可以方便的获取到命令中具体的值，准确来说，一条加载命令是由类型，大小和值三部分组成的。不同类型的命令对应的值解析出来的结构也不同，下面我们来介绍几个常见的命令。 1.LC_SEGMENT/LS_SEGMENT_64 通过我们编译的iOS空项目的Mach-O文件可以看到，其中包含了很多条LS_SEGMENT_64加载命令，此命令描述了内核应该如何设置当前应用进行的内存空间，这些段将直接从Mach-O文件中对应的位置加载到内存里。LS_SEGMENT_64命令的值的结构定义如下： 123456789101112131415161718192021222324252627struct segment_command &#123; /* for 32-bit architectures */ uint32_t cmd; /* LC_SEGMENT */ uint32_t cmdsize; /* includes sizeof section structs */ char segname[16]; /* segment name */ uint32_t vmaddr; /* memory address of this segment */ uint32_t vmsize; /* memory size of this segment */ uint32_t fileoff; /* file offset of this segment */ uint32_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;;struct segment_command_64 &#123; /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; // 段的名称 uint64_t vmaddr; // 虚拟物理地址 uint64_t vmsize; // 为此段分配的虚拟内存大小 uint64_t fileoff; // 此段在文件中的偏移量 uint64_t filesize; // 此段在文件中占用的字节数 vm_prot_t maxprot; // 段的页面所需要的最高内存保护 vm_prot_t initprot; // 段页面初始时的内存保护 uint32_t nsects; // 段中区（section）的数量 uint32_t flags; // 标记位&#125;; 可以看到，每个段加载命令中都提供了段的基本信息，包括名称，偏移地址，字节数，以及段有包含的分区的个数，通过此命令，进程虚拟内存的设置就变得很简单，只需要根据指令来读取信息并加载到内存即可。关于段的分析我们会在后面小节做具体的介绍。 2.LC_MAIN/LS_UNIXTHREAD 当所有库加载完成后，此命令用来进行二进制程序的主线程启动。 3.LC_CODE_SIGNATURE Mach-O包含的数字签名，如果此签名与代码不匹配，则进程会被强制关闭。LC_CODE_SIGNATURE命令的结构如下： 1234567891011struct linkedit_data_command &#123; uint32_t cmd; /* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO, LC_FUNCTION_STARTS, LC_DATA_IN_CODE, LC_DYLIB_CODE_SIGN_DRS, LC_LINKER_OPTIMIZATION_HINT, LC_DYLD_EXPORTS_TRIE, or LC_DYLD_CHAINED_FIXUPS. */ uint32_t cmdsize; /* sizeof(struct linkedit_data_command) */ uint32_t dataoff; // 地址偏移量 uint32_t datasize; // 字节数&#125;; 此命令的结构是一个复用的结构，很多命令都能解析成此结构，其中dataoff标记从文件的何处开始读取签名，datasize标记签名所占字节数。我们可以通过一个Mach-O文件来验证下，首先在加载命令段找到LC_CODE_SIGNATURE命令，如下： 可以看到，其offset为E8A0，size为4B00，相加后为133A0，因此我们可以得知，签名所在的位置为偏移地址为E8A0的地方，最终结束的地址为133A0，找到Code Signature段进行验证，如下： 可以看到，Code Signature段的起始偏移位置就是E8A0，最后4个字节的偏移位置为13390，再加上最后的4个字节，结尾的位置刚好为133A0，和我们计算的一致。 并非只有LC_CODE_SIGNATURE命令是采用偏移量和字节数的方式来进行加载，这种值结构的命令都是一样的逻辑，这里就不再赘述。 4.LC_SYMTAB 此命令用来加载此Mach-O文件的符号表，此命令中包含了symbol table和string table在Mach-O文件中的位置，LC_SYMTAB命令的值定义如下： 12345678struct symtab_command &#123; uint32_t cmd; /* LC_SYMTAB */ uint32_t cmdsize; /* sizeof(struct symtab_command) */ uint32_t symoff; // 符号表起始位置的偏移量 uint32_t nsyms; // 符号表的字节数 uint32_t stroff; // 字符串表起始位置的偏移量 uint32_t strsize; // 字符串表的字节数&#125;; 关于符号表和字符串表段，我们后面再详细介绍。 4.LC_DYSYMTAB 此命令用来加载动态库的符号表，对应的是Dynamic Symbol Table段的数据，此命令的值结构较复杂，定义如下： 12345678910111213141516171819202122232425262728293031323334353637struct dysymtab_command &#123; uint32_t cmd; /* LC_DYSYMTAB */ uint32_t cmdsize; /* sizeof(struct dysymtab_command) */ // 本地符号，用来调试 uint32_t ilocalsym; // 本地符号的位置 uint32_t nlocalsym; // 本地符号的字节数 // 定义的外部符号 uint32_t iextdefsym; // 定义的外部符号位置 uint32_t nextdefsym; // 定义的外部符号字节数 // 未定义的符号 uint32_t iundefsym; // 未定义的符号位置 uint32_t nundefsym; // 未定义的符号字节数 // 动态绑定相关 uint32_t tocoff; /* file offset to table of contents */ uint32_t ntoc; /* number of entries in table of contents */ uint32_t modtaboff; /* file offset to module table */ uint32_t nmodtab; /* number of module table entries */ uint32_t extrefsymoff; /* offset to referenced symbol table */ uint32_t nextrefsyms; /* number of referenced symbol table entries */ // 间接符号表 uint32_t indirectsymoff; /* file offset to the indirect symbol table */ uint32_t nindirectsyms; /* number of indirect symbol table entries */ // 重定位相关 uint32_t extreloff; /* offset to external relocation entries */ uint32_t nextrel; /* number of external relocation entries */ // 本地条目相关 uint32_t locreloff; /* offset to local relocation entries */ uint32_t nlocrel; /* number of local relocation entries */&#125;; 5.LC_LOAD_DYLINKER 此命令告知内核需要调用的动态链接器的位置，值结构定义如下： 123456struct dylinker_command &#123; uint32_t cmd; /* LC_ID_DYLINKER, LC_LOAD_DYLINKER or LC_DYLD_ENVIRONMENT */ uint32_t cmdsize; /* includes pathname string */ union lc_str name; // 包含链接器的路径名称字符串起始位置的偏移，真正的动态链接器一般为/usr/lib/dyld&#125;; 6.LC_UUID 此命令加载时可以读取到一个128位的UUID值，结构如下： 12345struct uuid_command &#123; uint32_t cmd; /* LC_UUID */ uint32_t cmdsize; /* sizeof(struct uuid_command) */ uint8_t uuid[16]; /* the 128-bit uuid */&#125;; 7.LC_LOAD_DYLIB 此命令用来加载额外的动态库，这也是一个非常重要的命令，最简单的iOS应用也离不开动态库的使用，通过真实的Mach-O文件我们也可以看到，通常会有多条LC_LOAD_DYLIB命令，每条命令指定一个要加载的动态库。此命令的值结构定义如下： 12345678910111213struct dylib_command &#123; uint32_t cmd; /* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB, LC_REEXPORT_DYLIB */ uint32_t cmdsize; /* includes pathname string */ struct dylib dylib; // 动态库结构体&#125;;struct dylib &#123; union lc_str name; // 动态库所在路径字符串的起始位置（相对与当前命令起始的偏移字节） uint32_t timestamp; // 库编译时的时间戳 uint32_t current_version; // 动态库版本号 uint32_t compatibility_version; // 兼容版本号&#125;; 以UIKit为例，一般的iOS应用都会使用到这个动态库，此命令如下： 8.LC_RPATH 此命令用来进行@rpath外部路径变量的映射，我们知道，除了系统本身提供了一些动态共享库外，我们也可以使用外部自定义的动态库，这类外部动态库在加载的时候也需要一个明确的路径，通常在加载外部动态库的命令中，库的路径是以@rpath开头的，Xcode的编译选项中可以自定义设置外部库的寻找路径，同时使用此命令进行解析。此命令的值结构如下： 12345struct rpath_command &#123; uint32_t cmd; /* LC_RPATH */ uint32_t cmdsize; /* includes string */ union lc_str path; &#125;; 关于动态库这部分的内容，可以参考之前的一篇文章，其中有更详细的介绍。 https://my.oschina.net/u/2340880/blog/5323143 9.LC_FUNCTION_STARTS 此命令的结构与LC_CODE_SIGNATURE一致，用来描述函数表段所在的起始位置和字节数。关于函数表，后面会具体介绍。 四 段与分区前面，我们将常见的加载命令进行了介绍，也有提到LS_SEGMENT是非常重要的一个命令，其指导着内核如果将Mach-O文件中的各个段数据加载到内存里。此命令的结构中有一个名为segname的字段，其表示要加载的段的名字，常用宏定义如下： 12345678#define SEG_PAGEZERO \"__PAGEZERO\" // 空指针异常捕获段#define SEG_TEXT \"__TEXT\" // 代码段#define SEG_DATA \"__DATA\" // 数据段#define SEG_OBJC \"__OBJC\" // OC运行时段#define SEG_ICON \"__ICON\" // ICON段#define SEG_LINKEDIT \"__LINKEDIT\" // 链接器使用的符号和其他表段 #define SEG_UNIXSTACK \"__UNIXSTACK\" // unix栈段#define SEG_IMPORT \"__IMPORT\" // dyld段 其中，__PAGEZERO段在进入虚拟内存时是不会分配真实的物理地址的，其只是告诉开发者此段虚拟内存不能使用，最大的作用是如果产生了空指针，会访问到此段中的地址，会直接被捕获报错。 __TEXT段为代码段，其中又包含多个区，命令中的nsects字段描述了当前段有多少个区，区的信息也在命令中进行读取，结构如下： 1234567891011121314struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; // 分区名 char segname[16]; // 段名 uint64_t addr; // 分区地址 uint64_t size; // 字节数 uint32_t offset; // 分区在文件中的偏移量 uint32_t align; // 对齐方式 uint32_t reloff; // 重定位条目在文件中的偏移量 uint32_t nreloc; // 重定位条目数 uint32_t flags; // 分区标记 uint32_t reserved1; // 预留 uint32_t reserved2; // 预留 uint32_t reserved3; // 预留&#125;; 通过这些信息可以在Mach-O文件中找到具体的分区所在的位置，将其加载进内存。 __TEXT段下，常见的区列举如下： __text：主程序代码区 __stubs：动态链接桩区 __objc_methname：Objective-C方法名区 __objc_classname：Objective-C类名区 __objc_methtype：Objective-C方法类型区 __cstring：硬编码的C语言字符串区 __entitlements：配置文件区 __DATA_CONST段下，常见的分区列举如下： __got：Non-Lazy Symbol Pointers区 __cfstring：程序中使用的CFStringRef区 __objc_classlist：Objective-C类列表区 __objc_protolist：Objective-C原型列表区 __objc_imginfo：Objective-C镜像信息区 __DATA段下，常见的分区列举如下： __objc_const：Objective-C常量区 __objc_selrefs：Objective-C自引用区 __objc_classrefs：Objective-C类引用区 __objc_supperrefs：Objective-C超类引用区 五 Mach-O的”加载“到底加载的是什么现在，我们对Mach-O文件的整体架构已经有了清晰的了解，如果将一个Mach-O文件比作一个完成的工程产品，则文件头好比是此产品的信息表，记录了产品的一些基础信息。加载命令则是产品的组装说明书，用来具体指导此工程产品的组装，之后的内容就是一个个独立的工程组件，我们只需要按照说明书的描述进行组装即可。下面我们对几个核心的区进行介绍。 1.代码段代码区首先，对于一个iOS应用的Mach-O文件来说，__TEXT段__text分区是必不可少的，其便是程序的核心代码区，通过可视化的工具可以看到，其中数据就是汇编指令，如下： 2.代码段动态链接桩区__TEXT段__text区中的代码在调用的动态链接函数需要进行绑定，__TEXT段的__stubs区便是留的动态链接的桩，其具体的解析在Dynamic Symbol Table动态符号表段中。举个例子，__stubs区的符号解析结果如下： 可以看到，可视化工具中，这些桩已经被解析成了具体的符号，那么是如何解析的呢。其实也很简单，首先每6个字节对应一个符号，之所以是6个字节，是LC_SEGMENT命令中的Size of Stubs字段约定的，如下： 具体的符号定义在Dynamic Symbol Table里面，从前往后与__stubs中的桩一一对应，可以观察下Dynamic Symbol Table表中的数据，如下： 可视化工具已经帮我们将符号进行了解析，实际上动态符号表中存放的只是符号所在位置的下标，并非是符号本身，所有符号都记录在Symbol Table中，以动态符号表中的第一个符号为例，其存储的值为0xB7，转成10进制为183，表示符号表中的第183个符号，找到Symbol Table中下标为183的符号，如下： 事实上，Symbol Table中记录的是一种标准化的符号结构，其并不会存具体的符号字符串，所有字符串都存在字符串表中，以便节省内存。可以看到，Symbol Table中第183个符号记录其在字符串表中的位置为0xCE，我们在找到String Table，其起始位置为0xD0A0，加上这里的偏移量0xCE为0xD16E，说明要解析的符号存放在0xD16E的位置，String Table中记录的符号是以0x00为分割的，此处的后一个符号刚好就是_NSStringFromClass，如下： 到此，动态链接桩被解析完成。其实除了__TEXT段的__stubs区，__DATA_CONST段的__got区也是通过类似的方式来绑定符号的，只是__got区的符号需要链接时绑定，而__stubs区的符号允许运行时绑定，这里后面就不再赘述。 现在，让我们总结上符号绑定的完整过程。首先代码区中的符号需要到__stubs区或__got区进行绑定，__stubs区和__got区对应的加载命令记录了这两个去对应的符号解析的字节数以及在Dynamic Symbol Table表中的起始位置，Dynamic Symbol Table表中记录了当前符号在Symbol Table表中的下标，Symbol表记录了具体的符号实体，其中会包含当前符号在String Table中的位置，符号类型等信息，从String Table中找到具体的符号字符串。 3.Objective-C方法名区，Objective-C类名区，Objective-C方法类型区，C语言字符串区__TEXT段的的__objc_methname区顾名思义，记录了应用中所有的Objective-C方法名，直接以字符串的方式存储。 __TEXT段的的__objc_classname区顾名思义，记录了应用中(非动态库)所有的Objective-C类名，直接以字符串的方式存储。 __TEXT段的的__objc_methtype区顾名思义，记录了应用中所有的Objective-C方法的类型，直接以字符串的方式存储。 __TEXT段的的__cstring区顾名思义，记录了应用中所有的C语言字符串，直接以字符串的方式存储。 六 通过otool工具解析Mach-O整体看来，Mach-O文件的结构还是比较复杂的，如果没有可视化的工具，要解析此文件还是有些困难。除了MachOView工具外，我们还可以使用原生的otool命令来获取Mach-O文件中的而一些内容。文章的最后，我们来介绍几个常用的命令。 1.查看Mach-O文件头命令：otool -h MachOTest.app/MachOTest 或 otool -hV MachOTest.app/MachOTest hV参数的命令会自动进行可视化。 示例结果： 2.查看Mach-O的加载命令命令：otool -lV MachOTest.app/MachOTest 示例结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439MachOTest.app/MachOTest:Load command 0 cmd LC_SEGMENT_64 cmdsize 72 segname __PAGEZERO vmaddr 0x0000000000000000 vmsize 0x0000000100000000 fileoff 0 filesize 0 maxprot --- initprot --- nsects 0 flags (none)Load command 1 cmd LC_SEGMENT_64 cmdsize 712 segname __TEXT vmaddr 0x0000000100000000 vmsize 0x0000000000004000 fileoff 0 filesize 16384 maxprot r-x initprot r-x nsects 8 flags (none)Section sectname __text segname __TEXT addr 0x0000000100001fb0 size 0x000000000000051d offset 8112 align 2^4 (16) reloff 0 nreloc 0 type S_REGULARattributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS reserved1 0 reserved2 0Section sectname __stubs segname __TEXT addr 0x00000001000024ce size 0x000000000000003c offset 9422 align 2^1 (2) reloff 0 nreloc 0 type S_SYMBOL_STUBSattributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS reserved1 0 (index into indirect symbol table) reserved2 6 (size of stubs)Section sectname __objc_methname segname __TEXT addr 0x000000010000250a size 0x0000000000000dec offset 9482 align 2^0 (1) reloff 0 nreloc 0 type S_CSTRING_LITERALSattributes (none) reserved1 0 reserved2 0Section sectname __objc_classname segname __TEXT addr 0x00000001000032f6 size 0x0000000000000070 offset 13046 align 2^0 (1) reloff 0 nreloc 0 type S_CSTRING_LITERALSattributes (none) reserved1 0 reserved2 0Section sectname __objc_methtype segname __TEXT addr 0x0000000100003366 size 0x0000000000000b29 offset 13158 align 2^0 (1) reloff 0 nreloc 0 type S_CSTRING_LITERALSattributes (none) reserved1 0 reserved2 0Section sectname __cstring segname __TEXT addr 0x0000000100003e8f size 0x0000000000000016 offset 16015 align 2^0 (1) reloff 0 nreloc 0 type S_CSTRING_LITERALSattributes (none) reserved1 0 reserved2 0Section sectname __entitlements segname __TEXT addr 0x0000000100003ea5 size 0x000000000000010e offset 16037 align 2^0 (1) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Section sectname __unwind_info segname __TEXT addr 0x0000000100003fb4 size 0x0000000000000048 offset 16308 align 2^2 (4) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Load command 2 cmd LC_SEGMENT_64 cmdsize 472 segname __DATA_CONST vmaddr 0x0000000100004000 vmsize 0x0000000000004000 fileoff 16384 filesize 16384 maxprot rw- initprot rw- nsects 5 flags SG_READ_ONLYSection sectname __got segname __DATA_CONST addr 0x0000000100004000 size 0x0000000000000060 offset 16384 align 2^3 (8) reloff 0 nreloc 0 type S_NON_LAZY_SYMBOL_POINTERSattributes (none) reserved1 10 (index into indirect symbol table) reserved2 0Section sectname __cfstring segname __DATA_CONST addr 0x0000000100004060 size 0x0000000000000020 offset 16480 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Section sectname __objc_classlist segname __DATA_CONST addr 0x0000000100004080 size 0x0000000000000018 offset 16512 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes NO_DEAD_STRIP reserved1 0 reserved2 0Section sectname __objc_protolist segname __DATA_CONST addr 0x0000000100004098 size 0x0000000000000020 offset 16536 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Section sectname __objc_imageinfo segname __DATA_CONST addr 0x00000001000040b8 size 0x0000000000000008 offset 16568 align 2^2 (4) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Load command 3 cmd LC_SEGMENT_64 cmdsize 632 segname __DATA vmaddr 0x0000000100008000 vmsize 0x0000000000004000 fileoff 32768 filesize 16384 maxprot rw- initprot rw- nsects 7 flags (none)Section sectname __objc_const segname __DATA addr 0x0000000100008000 size 0x0000000000001368 offset 32768 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Section sectname __objc_selrefs segname __DATA addr 0x0000000100009368 size 0x0000000000000018 offset 37736 align 2^3 (8) reloff 0 nreloc 0 type S_LITERAL_POINTERSattributes NO_DEAD_STRIP reserved1 0 reserved2 0Section sectname __objc_classrefs segname __DATA addr 0x0000000100009380 size 0x0000000000000010 offset 37760 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes NO_DEAD_STRIP reserved1 0 reserved2 0Section sectname __objc_superrefs segname __DATA addr 0x0000000100009390 size 0x0000000000000008 offset 37776 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes NO_DEAD_STRIP reserved1 0 reserved2 0Section sectname __objc_ivar segname __DATA addr 0x0000000100009398 size 0x0000000000000008 offset 37784 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Section sectname __objc_data segname __DATA addr 0x00000001000093a0 size 0x00000000000000f0 offset 37792 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Section sectname __data segname __DATA addr 0x0000000100009490 size 0x0000000000000180 offset 38032 align 2^3 (8) reloff 0 nreloc 0 type S_REGULARattributes (none) reserved1 0 reserved2 0Load command 4 cmd LC_SEGMENT_64 cmdsize 72 segname __LINKEDIT vmaddr 0x000000010000c000 vmsize 0x0000000000008000 fileoff 49152 filesize 29600 maxprot r-- initprot r-- nsects 0 flags (none)Load command 5 cmd LC_DYLD_CHAINED_FIXUPS cmdsize 16 dataoff 49152 datasize 680Load command 6 cmd LC_DYLD_EXPORTS_TRIE cmdsize 16 dataoff 49832 datasize 216Load command 7 cmd LC_SYMTAB cmdsize 24 symoff 50072 nsyms 203 stroff 53408 strsize 6144Load command 8 cmd LC_DYSYMTAB cmdsize 80 ilocalsym 0 nlocalsym 175 iextdefsym 175 nextdefsym 8 iundefsym 183 nundefsym 20 tocoff 0 ntoc 0 modtaboff 0 nmodtab 0 extrefsymoff 0 nextrefsyms 0 indirectsymoff 53320 nindirectsyms 22 extreloff 0 nextrel 0 locreloff 0 nlocrel 0Load command 9 cmd LC_LOAD_DYLINKER cmdsize 32 name /usr/lib/dyld (offset 12)Load command 10 cmd LC_UUID cmdsize 24 uuid 05EC375B-F3C2-3C5A-99D2-28FB938FF144Load command 11 cmd LC_BUILD_VERSION cmdsize 32 platform IOSSIMULATOR minos 15.5 sdk 15.5 ntools 1 tool LD version 764.0Load command 12 cmd LC_SOURCE_VERSION cmdsize 16 version 0.0Load command 13 cmd LC_MAIN cmdsize 24 entryoff 8672 stacksize 0Load command 14 cmd LC_LOAD_DYLIB cmdsize 88 name /System/Library/Frameworks/Foundation.framework/Foundation (offset 24) time stamp 2 Thu Jan 1 08:00:02 1970 current version 1860.0.0compatibility version 300.0.0Load command 15 cmd LC_LOAD_DYLIB cmdsize 56 name /usr/lib/libobjc.A.dylib (offset 24) time stamp 2 Thu Jan 1 08:00:02 1970 current version 228.0.0compatibility version 1.0.0Load command 16 cmd LC_LOAD_DYLIB cmdsize 56 name /usr/lib/libSystem.B.dylib (offset 24) time stamp 2 Thu Jan 1 08:00:02 1970 current version 1311.120.1compatibility version 1.0.0Load command 17 cmd LC_LOAD_DYLIB cmdsize 96 name /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (offset 24) time stamp 2 Thu Jan 1 08:00:02 1970 current version 1860.0.0compatibility version 150.0.0Load command 18 cmd LC_LOAD_DYLIB cmdsize 80 name /System/Library/Frameworks/UIKit.framework/UIKit (offset 24) time stamp 2 Thu Jan 1 08:00:02 1970 current version 5610.0.0compatibility version 1.0.0Load command 19 cmd LC_RPATH cmdsize 40 path @executable_path/Frameworks (offset 12)Load command 20 cmd LC_FUNCTION_STARTS cmdsize 16 dataoff 50048 datasize 24Load command 21 cmd LC_DATA_IN_CODE cmdsize 16 dataoff 50072 datasize 0Load command 22 cmd LC_CODE_SIGNATURE cmdsize 16 dataoff 59552 datasize 19200 3.查看依赖的动态库命令：otool -L MachOTest.app/MachOTest 示例结果： 123456MachOTest.app/MachOTest: /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1860.0.0) /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1311.120.1) /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1860.0.0) /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 5610.0.0) 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS之逻辑初窥","slug":"iOS之逻辑初窥","permalink":"http://huishao.cc/categories/iOS之逻辑初窥/"}]},{"title":"理解JavaScript中的“面向对象”","slug":"449理解JavaScript中的“面向对象”","date":"2022-08-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.399Z","comments":true,"path":"2022/08/05/449理解JavaScript中的“面向对象”/","link":"","permalink":"http://huishao.cc/2022/08/05/449理解JavaScript中的“面向对象”/","excerpt":"","text":"理解JavaScript中的“面向对象”一 引子面向对象，是程序开发者再熟悉不过的一个概念。一说到它，你首先会想到的是什么？类？继承？方法与属性？不同技术栈的开发者或许有不同的第一反应。面向对象本身只是一种编程方式，支持面向对象的语言很多，但其实现原理却并不都一样。大多数语言的面向对象特性都是基于“类”来实现的，例如C++，Objective-C，Java，Python等。在这些语言中，类是面向对象的基础，面向对象的继承，多态，封装也是通过类来实现的。 本篇文章，我们要讲的是编程语言中的一个异类：JavaScript。JavaScript不仅是面向对象语言，而且是实实在在的面向对象，除了基础类型，你所用到的一些数据实例都是对象，包括函数。但是，JavaScript中的面向对象却并不是基于类来实现的，这对熟悉其他编程语言的开发者来说，是有些反直觉的。完全了解JavaScript中的面向对象， 能够帮助你更好的理解JavaScript这门语言的工作原理。现在，TypeScript越来越热门，越来越多的应用框架开始以TypeScript作为首选语言，TypeScript只是JavaScript基于编译层面的封装，因此了解了JavaScript的原理，也能让你更好更高效的使用TypeScript。 二 “面向对象”的编程方式是如何演进而来的什么是面向对象编程？我们可以从其3个特点说起： 封装 封装是将数据和逻辑捆绑到一起，对象的某些数据和逻辑方法可以是私有的，不能被外界访问，以此实现对数据和逻辑方法不同级别的访问权限。防止了程序相互依赖性而带来的变动影响，面向对象的封装比传统语言的封装更为清晰、更为有力。有效实现了两个目标：对数据和行为的包装和信息隐藏。 继承 继承简单地说就是一种层次模型，这种层次模型能够被重用。层次结构的上层具有通用性，但是下层结构则具有特殊性。在继承的过程中类则可以从最顶层的部分继承一些方法和变量。类除了可以继承以外同时还能够进行修改或者添加。通过这样的方式能够有效提高工作效率。 多态 多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。 封装，继承，多态组成了面向对象编程的基本特性，各种面向对象语言的设计也是围绕这3个特性展开的。 我们可以通过一个简单的例子来理解。例如我们需要编写程序来计算一个圆的面积，我们知道，计算圆的面积需要两个参数，圆周率与半径。按照面向过程的思路，最原始的代码可能是这样的： 1234567let radius = 2;let pi = 3.14;function area()&#123; return pi * radius * radius;&#125;console.log(area()); 此时，数据和逻辑非常分散且独立，为了更好的实现编程的封装性，我们可以将计算圆面积所使用的变量和方法都聚合到一个对象中，通过对象来整合数据与调用方法，如下： 123456789let circle = &#123; radius:2, pi:3.14, s:function()&#123; return this.pi * this.radius * this.radius &#125;&#125;console.log(circle.s()); 这样，我们其实就已经将面向过程的编程方式转换成了面向对象的编程方式。封装本身也是一种对现实生活事物的抽象，如上代码中所示，circle对象从意义上已经能够描述图形圆这样一种事物，它拥有半径，占有面积。从变量和函数到属性和方法，编程方式已经发生了转变。但是，直接创建对象的方式实现封装依然非常低级，思考一下，现实生活中会有各种各样的圆，半径不同的圆不可胜数，同样在程序中我们也会使用到各种各样的“圆”对象，每次都如此创建对象非常繁琐，且如果逻辑有了修改，所有的对象都要修改，代码将逐渐变得不可维护。因此，我们想到使用模板方法来创建对象“圆”，使得此对象的创建逻辑更加聚合，修改和扩展都将更方便。优化上面的代码如下： 1234567891011121314function Circle(radius) &#123; let circle = &#123;&#125;; circle.radius = radius; circle.pi = 3.14; circle.s = function() &#123; return this.radius * this.radius * this.pi; &#125; return circle;&#125;var c1 = Circle(1);var c2 = Circle(2);console.log(c1.s());console.log(c2.s()); 上面示例代码中对圆对象的创建进行了封装，这就好像Circle是一个模板，使用此模板我们可快速的创建出各种半径不同的圆对象，从另一个角度理解，Circle也可以理解为是一种类型，通过此类型生成的对象都是“圆”对象。引入了“类”的思想，编程便能更好的模拟现实事物了。到此，你会发现，在JavaScript中，“类”是可以通过函数的方式来实现的。那么现在，我们再来更深入的讨论基于“类”的更多优化技巧。 通过函数实现“类”的编程方式已经进步了很多，但是还不够优秀。我们知道，无论是数据还是函数，都是要在内存中占据空间的，对象中有包装属性和方法，其实就是存储数据和函数，对于数据来说，每个对象中存储的可能不同，例如上面的圆半径，也可能所有对象存储的都一样，例如上面的圆周率。对于方法来说，应该是所有对象所共享的，就像所有圆的计算面积的方法都是一样的。如果每个对象中都存储完整的函数方法，则这不仅非常多余，更是增加了无谓的内存消耗。如何优化这一点呢，我们可以想到，设计模式中的原型模式正是为处理此类问题而生的。 将方法放入原型对象中，通过对原型对象的引用来让所有实例对象共享原型对象中封装的方法。修改代码如下： 1234567891011121314151617181920var prototype = &#123; s:function () &#123; return this.radius * this.radius * this.pi; &#125;&#125;function Circle(radius) &#123; let circle = &#123;&#125;; circle.radius = radius; circle.pi = 3.14; circle.s = prototype.s return circle;&#125;var c1 = Circle(1);var c2 = Circle(2);console.log(c1.s());console.log(c2.s());// trueconsole.log(c1.s === c2.s); 修改后的代码，无论生成多少对象，方法都是共享的。其他语言中如果要共享属性，通常提供的有类属性或静态属性的语法，核心原理是将共享的属性绑定到类上而不是对象上，JavaScript中也可以这么做，如下： 12345678910111213var prototype = &#123; s:function () &#123; return this.radius * this.radius * Circle.pi; &#125;&#125;function Circle(radius) &#123; let circle = &#123;&#125;; circle.radius = radius; Circle.pi = 3.14; circle.s = prototype.s return circle;&#125; 最后，我们还要想办法实现继承和多态，这样才算比较完善的面向对象。多态比较简单，我们只要确定父子类方法的优先级关系，即可通过方法覆写实现多态，继承也很好理解，通过一种方式将父类的属性和方法关联到子类中，即可实现继承。我们可以编写如下代码： 1234567891011121314function RedUnitCircle() &#123; let circle = &#123;&#125;; circle.parent = Circle(1); circle.radius = 1; circle.color = \"red\"; return circle;&#125;var c3 = RedUnitCircle();if (c3.s === undefined) &#123; console.log(c3.parent.s());&#125; else &#123; console.log(c3.s());&#125; 红色单位圆类是对圆类的一种派生，其内部增加了color属性，同样它也有计算面积的方法，我们使用parent属性来承接，实际上，在调用方法时，首先需要在当前对象上找，如果不存在，在向继承链上一层一层的递归寻找，直到最上层的基类。事实上，在JavaScript中，是通过原型链来实现继承关系的，我们下面将会介绍。 三 this究竟指向哪里在使用JavaScript编程中，我们经常会使用到this，在JavaScript函数调用时，函数内部会默认被传入一个隐含的this参数，此this参数指向一个对象，我们可以称之为上下文对象，那么如何确定this指向的对象究竟是谁呢？可以分为如下几种情况来讨论。 1. 当函数被直接调用时，this指向golbal全局对象（node.js中），如果是在浏览器环境运行，则指向window对象。 例如： 12345function testFunc() &#123; console.log(this);&#125;// global对象testFunc(); 2. 当函数作为方法被调用时，this指向调用方法的对象。 例如： 12345678var obj = &#123; name:\"name\", log:function()&#123; console.log(this.name); &#125;&#125;// nameobj.log(); 3. 当被作为构造函数被执行时，this指向新创建的对象。 例如： 123456function CreateObj() &#123; this.name = \"name\";&#125;var obj = new CreateObj();// nameconsole.log(obj.name); 4. 使用bind，apply和call函数，能够显式的指定函数中的this指向。 例如： 1234567891011121314151617181920var obj = &#123; name:\"name\"&#125;function log(p) &#123; console.log(this.name, p);&#125;function log2(p) &#123; console.log(this.name, p);&#125;function log3(p) &#123; console.log(this.name, p);&#125;// name Paramlog.call(obj,'Param')// name Paramlog2.apply(obj,['Param']);var newLog3 = log3.bind(obj);// name ParamnewLog3('Param'); 其中，call和apply函数的作用基本一致，只是其传参的类型不同，bind函数用来生成一个新的函数，此函数中的this是被绑定到对应的对象上的。 由于JavaScript的这种特性，我们在函数中使用this时，常常会收到运行时的调用环境影响。在ES6中提供了箭头函数的支持，在箭头函数中，this会被绑定为函数定义时的this指向，例如： 123456789101112131415function create()&#123; return function() &#123; console.log(this); &#125;&#125;function create2()&#123; return () =&gt; &#123; console.log(this); &#125;&#125;var f = &#123;name:\"name\", log:create(),log2:create2()&#125;;//&#123;name: 'name', log: ƒ, log2: ƒ&#125;f.log();// globalf.log2(); TypeScript或其他支持EX6的编译器也会将箭头函数编译成如下样式，非常清楚的描述了this在箭头函数中的指向： 123456function create2() &#123; var _this = this; return function () &#123; console.log(_this); &#125;;&#125; 四 理解JavaScript中的面向对象前面说了这么多，我们终于要涉及到JavaScript是如何实现面向对象的特性了。前面有提到，我们可以使用函数来模拟类，构建出对象，继承和多态特性则是通过原型设计模式实现。JavaScript本身其实就有这样的一套能力，任何一个函数，当我们使用new关键字进行调用时，其都会被当成构造函数。构造函数的执行过程可以分为如下3步： 1. 创建一个空的对象，并让构造函数内的this指向此对象。 2. 将空对象的__proto__指向构造函数的prototype对象。 3. 执行构造函数，如果构造函数结果返回的是基本数据类型（包括无返回语句），则会被忽略，直接返回创建的对象。如果返回的是对象类型，则忽略之前创建的对象。 在使用对象访问属性或方法时，会先从当前对象中查找，如果没有找到，会再向原型__proto__中进行查找，一层层向上，直到找到对应的属性方法或没有更上层的原型对象。例如： 1234567891011function People(name) &#123; this.name = name;&#125;People.prototype.sayHi = function()&#123; console.log(\"Hello I am \" + this.name);&#125;var jaki = new People(\"Jaki\");// Hello I am Jakijaki.sayHi(); 要实现继承，可以通过修改原型来实现，如下： 123456789101112131415161718192021222324252627282930function People(name) &#123; this.name = name;&#125;People.prototype.sayHi = function()&#123; console.log(\"Hello I am \" + this.name);&#125;function Teacher(name, subject) &#123; People.call(this, name); this.subject = subject;&#125;// 修改子类原生指向function TeacherPrototype()&#123; // 重写父类的方法 this.sayHi = function() &#123; // 调用父类方法 TeacherPrototype.prototype.sayHi.call(this); // 子类自己的实现 console.log(\"教学：\"+this.subject); &#125;&#125;// 子类原型设置TeacherPrototype.prototype = People.prototypeTeacher.prototype = new TeacherPrototype()var teacher = new Teacher(\"Jaki\", \"JavaScript\");//Hello I am Jaki//教学：JavaScriptteacher.sayHi(); 从效果可以看到，JavaScript虽然没有类，但依然完成了面向对象的核心特性功能。 五 再来深入理解下原型链当我们创建一个空对象时，实际上是调用了Object构造方法，因此空对象的__proto__原型是指向Object函数的prototype的，如下： 123456var a = &#123;&#125;;var b = new Object();// &#123;&#125; &#123;&#125;console.log(a, b);// trueconsole.log(a.__proto__ === Object.prototype); 在JavaScript中，函数本身也是对象，函数对象的原型是Function的prototype，如下： 123456var f = function()&#123;&#125;var f2 = new Function();console.log(f, f2);// trueconsole.log(f.__proto__ === Function.prototype); Object本身也是一个函数，因此Object的__proto__原型指向Function的prototype，同理，Function也是一种对象，因此Function的__proto__指向Object的prototype，在向上Object的prototype对象的__proto__就是null了，例如： 12345678// trueconsole.log(Object.__proto__ === Function.prototype);// trueconsole.log(Function.__proto__ === Function.prototype);// trueconsole.log(Function.prototype.__proto__ === Object.prototype);// nullconsole.log(Object.prototype.__proto__); 原型链看上去有些复杂，借用网上的一张描述图，可以清晰的看出其间关系： 专注技术，热爱生活，交流技术，也做朋友。 —— 珲少 QQ：316045346 同时，如果本篇文章让你觉得有用，欢迎分享给更多朋友，请标明出处。","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS单元测试的那些事儿","slug":"448 iOS单元测试的那些事儿","date":"2022-07-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.398Z","comments":true,"path":"2022/07/21/448 iOS单元测试的那些事儿/","link":"","permalink":"http://huishao.cc/2022/07/21/448 iOS单元测试的那些事儿/","excerpt":"","text":"iOS单元测试的那些事儿作为客户端开发，很多时候我们过多的关注于功能的测试，而忽略标准的单元测试。其实，单元测试是保障项目稳定性的最有效且成本最低的测试方式。越偏向底层服务的代码，越需要使用单元测试来对可靠性进行保障。一旦单元测试覆盖完成，则之后再进行代码优化和迭代的时候则会有引入新问题的几率会大为减小。 Xcode提供了完整的单元测试功能，系统预置的单元测试类和断言也非常方便开发者编写测试代码。除了函数功能测试，性能测试外，也支持进行UI上的单元测试。本篇文章，我们就将介绍iOS中关于单元测试的那些事。 一 先看一个简单的单元测试例子首先可以新建一个iOS测试工程，在工程中任意添加一个示例类文件，例如命名为ViewModel类，实现如下: 123456789101112131415161718192021222324//ViewModel.h文件#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ViewModel : NSObject- (NSInteger)getSegementCount:(NSString *)string;@endNS_ASSUME_NONNULL_END//ViewModel.m文件#import \"ViewModel.h\"@implementation ViewModel- (NSInteger)getSegementCount:(NSString *)string &#123; return [string componentsSeparatedByString:@\":\"].count;&#125;@end 这个类本身非常简单，只提供了一个获取字符串分段数的方法。此方法只要有明确的输入就会有明确的输出，非常适合用来做单元测试。之后，使用Xcode新建一个Unit Testing Bundle的Target模块，如下图： 之后默认会生成一个测试文件，其只有.m文件，没有.h文件，我们的主要测试代码也都将编写到这个.m文件中。 生成的测试文件中默认实现了setUp，tearDown，testExample和testPerformanceExample这些方法，等下我们会对这些方法进行介绍，修改此测试文件如下： 1234567891011121314151617181920212223242526272829#import &lt;XCTest/XCTest.h&gt;#import \"ViewModel.h\"@interface UnitTestDemoTests : XCTestCase@property (nonatomic, strong) ViewModel *viewModel;@end@implementation UnitTestDemoTests- (void)setUp &#123; self.viewModel = [[ViewModel alloc] init];&#125;- (void)tearDown &#123; self.viewModel = nil;&#125;- (void)testExample &#123; NSInteger count = [self.viewModel getSegementCount:@\"127:0:0:1\"]; XCTAssertEqual(count, 4);&#125;- (void)testPerformanceExample &#123; [self measureBlock:^&#123; NSLog(@\"---\"); &#125;];&#125;@end 其中setUp方法是当前测试类的初始化方法，我们可以将一些资源准备工作在这个方法中完成，tearDown方式在测试结束后会调用，用来进行资源的清理。测试函数都需要以text开头，testExample是默认生成的一个测试用例函数，我们在其中检查getSegmentCount方法的工作是否正常，XCTAssertEqual是XCTest框架提供的众多测试断言中的一种，用来进行相等断言，如果getSegmentCount方法执行的结果与我们预期不一致，则会命中此断言，从而使当前测试用例失败。testPerformanceExample是性能测试的一个案例，其内的measureBlock里的代码会被默认执行10次，最终输出每次执行的时间消耗报告。 下面，我们可以执行下此测试类，在Xcode的测试导航中点击此测试类右边的执行按钮即可： 每个测试方法的结果会在右侧展示，绿的的对号表示此测试用例通过。也可以直接在测试类文件中执行单个的测试用例，如下： 对于性能测试用例，其测试完成后会自动生成一个性能报告，对每个性能测试函数，我们都可以为其设置一个基准值，其会分析性能优于或劣于基准值多少。如下图： 二 关于XCTestCase类XCTestCase可以理解为一个测试用例类，其中可以定义多个测试用例函数。通常最佳的实践是一个功能类对应一个XCTestCase测试类，在此测试类中对相应的功能类进行覆盖测试。 要定义一个测试用例类非常简单，遵循如下的步骤即可： 1. 创建一个XCTestCase的子类。 2. 自定义以test开头的实例方法，作为独立的测试用例。 3. 可以定义一些需要保持状态的变量或属性作为测试物料。 4. 某些需要初始化的状态在setup方法中设置。 5. 测试完成后的清理工作在tearDown方法中设置。 对于自定义的测试实例方法，有3个非常重要的原则，符合这3个原则的方法才会被系统识别为测试用例，即：没有入参，没有返回值，以test开头。 XCTestCase也支持进行更多定制化配置，例如超时时间，测试异常的记录等。XCTestCase类中提供的初始化方法如下： 1234567891011// 通过invocation构造测试类+ (instancetype)testCaseWithInvocation:(nullable NSInvocation *)invocation;// 实例的初始化方法- (instancetype)initWithInvocation:(nullable NSInvocation *)invocation;// 通过selector构造测试类+ (nullable instancetype)testCaseWithSelector:(SEL)selector;// 实例方法- (instancetype)initWithSelector:(SEL)selector; 通常，如果我们需要定制XCTestCase的属性，可以在子类中重写initWithInvocation方法，如下： 12345678910- (instancetype)initWithInvocation:(nullable NSInvocation *)invocation &#123; self = [super initWithInvocation:invocation]; if (self) &#123; self.continueAfterFailure = NO; [self addTeardownBlock:^&#123; NSLog(@\"TTT\"); &#125;]; &#125; return self;&#125; XCTestCase类中封装的属性和方法解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940// 测试用例执行时 调用的invocation@property (strong, nullable) NSInvocation *invocation;// 执行测试，此方法应该由系统框架调用，不能主动调用- (void)invokeTest;// 设置当某个测试用例方法没通过时，是否继续执行其后的逻辑@property BOOL continueAfterFailure;// 测试用例不通过后，会回调此方法，子类可以重写来自定义异常报告- (void)recordIssue:(XCTIssue *)issue;// 每个测试用例所对应的NSInvocation@property (class, readonly, copy) NSArray&lt;NSInvocation *&gt; *testInvocations;// 添加一个自定义的tearDown回调- (void)addTeardownBlock:(void (^)(void))block;// 添加一个异步执行的tearDown回调- (void)addAsyncTeardownBlock:(void (^)(void (^completion)(NSError * _Nullable error)))block;// 用例执行超时时间 默认10min@property NSTimeInterval executionTimeAllowance;// 性能测试方法，将要测试性能的逻辑代码放入block即可- (void)measureBlock:(XCT_NOESCAPE void (^)(void))block;// 性能测试方法，在block中需要手动启动和结束性能测试 配套下面两个方法使用- (void)measureMetrics:(NSArray&lt;XCTPerformanceMetric&gt; *)metrics automaticallyStartMeasuring:(BOOL)automaticallyStartMeasuring forBlock:(XCT_NOESCAPE void (^)(void))block;// 开启性能测试- (void)startMeasuring;// 结束性能测试- (void)stopMeasuring;// 默认的测试组，每个测试方法都是一个独立的测试用例，当前测试类可以定义一组@property (class, readonly) XCTestSuite *defaultTestSuite;// 每个测试方法执行前都会执行的setup步骤+ (void)setUp;// 每个测试方法执行前都会执行的teardown步骤+ (void)tearDown; XCTestCase也实现了XCTActivity协议，允许直接向测试用例对象中添加附件，方法如下： 1- (void)addAttachment:(XCTAttachment *)attachment; 被添加的附件会被Xcode持有，并根据策略保存到测试报告中去。附件有时候对测试来说非常重要，例如要保存失败测试的案例数据，以便开发进行追溯，这是就可以将数据作为附件保存。例如： 12345678- (void)testExample &#123; NSInteger count = [self.viewModel getSegementCount:@\"127:0:0:1\"]; XCTAssertEqual(count, 4); XCTAttachment *attachment = [XCTAttachment attachmentWithString:@\"我是附件\"]; attachment.lifetime = XCTAttachmentLifetimeKeepAlways; [self addAttachment:attachment]; NSLog(@\"xxx\");&#125; 执行测试后，在测试报告中可以查看用例的附件文件，如下图： 关于附件的相关内容，后面会在介绍。最后，关于XCTestCase的性能测试，可以通过设置Option参数来控制循环次数，例如： 1234567- (void)testPerformanceExample &#123; XCTMeasureOptions *op = [[XCTMeasureOptions alloc] init]; op.iterationCount = 20; [self measureWithOptions:op block:^&#123; NSLog(@\"---\"); &#125;];&#125; 此时，性能测试代码将被循环执行20次。 三 测试附件前面说过，附件可以用来保存测试执行时的案例数据，帮助开发者后续回溯。XCTAttachment类封装的常用属性和方法列举如下： 123456789101112131415161718192021222324252627282930313233343536373839// 初始化相关- (instancetype)initWithUniformTypeIdentifier:(nullable NSString *)identifier name:(nullable NSString *)name payload:(nullable NSData *)payload userInfo:(nullable NSDictionary *)userInfo;+ (instancetype)attachmentWithUniformTypeIdentifier:(nullable NSString *)identifier name:(nullable NSString *)name payload:(nullable NSData *)payload userInfo:(nullable NSDictionary *)userInfo;// 文件标识符@property (readonly, copy) NSString *uniformTypeIdentifier;// 附件名@property (copy, nullable) NSString *name;// 用户附加数据@property (copy, nullable) NSDictionary *userInfo;// 附件的生存时间/*typedef NS_ENUM(NSInteger, XCTAttachmentLifetime) &#123; // 一直存在 XCTAttachmentLifetimeKeepAlways = 0, // 测试用例通过后将附件删除 XCTAttachmentLifetimeDeleteOnSuccess = 1&#125;;*/@property XCTAttachmentLifetime lifetime;// 通过指定类型的数据直接创建附件+ (instancetype)attachmentWithData:(NSData *)payload;+ (instancetype)attachmentWithData:(NSData *)payload uniformTypeIdentifier:(NSString *)identifier;+ (instancetype)attachmentWithString:(NSString *)string;+ (instancetype)attachmentWithArchivableObject:(id&lt;NSSecureCoding&gt;)object;+ (instancetype)attachmentWithArchivableObject:(id&lt;NSSecureCoding&gt;)object uniformTypeIdentifier:(NSString *)identifier;+ (instancetype)attachmentWithPlistObject:(id)object;+ (instancetype)attachmentWithContentsOfFileAtURL:(NSURL *)url;+ (instancetype)attachmentWithContentsOfFileAtURL:(NSURL *)url uniformTypeIdentifier:(NSString *)identifier;+ (instancetype)attachmentWithCompressedContentsOfDirectoryAtURL:(NSURL *)url;+ (instancetype)attachmentWithImage:(UIImage *)image;+ (instancetype)attachmentWithImage:(UIImage *)image quality:(XCTImageQuality)quality; 四 测试断言测试用例的通过与否是由断言决定的，XCTest框架中提供的断言宏列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 无条件的异常断言XCTFail(...)// 空断言，当表达式不是空时测试失败XCTAssertNil(expression, ...)// 非空断言，当表达式为空时测试失败XCTAssertNotNil(expression, ...)// 布尔断言，当表达式为false时测试失败XCTAssert(expression, ...)// 布尔断言，当表达式为false时测试失败XCTAssertTrue(expression, ...)// 布尔断言，当表达式为true时测试失败XCTAssertFalse(expression, ...)// 相等断言，当两个表达式结果不相等时测试失败 使用equal方法XCTAssertEqualObjects(expression1, expression2, ...)// 不相等断言，当两个表达式结果相等时测试失败 使用equal方法XCTAssertNotEqualObjects(expression1, expression2, ...)// 相等断言，当两个表达式结果不相等时测试失败 使用 ==XCTAssertEqual(expression1, expression2, ...)// 相等断言，当两个表达式结果相等时测试失败 使用 ==XCTAssertNotEqual(expression1, expression2, ...)// 实例断言，当两个表达式结果为不相同的类实例时，测试失败XCTAssertIdentical(expression1, expression2, ...)// 实例断言，当两个表达式结果为相同的类实例时，测试失败XCTAssertNotIdentical(expression1, expression2, ...) // 差异断言，两表达式结果的差异大于设置阈值时测试失败XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, ...)// 差异断言，两表达式结果的差异不大于设置阈值时测试失败XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, ...)// 大于断言，表达式1的值小于等于表达式2时测试失败XCTAssertGreaterThan(expression1, expression2, ...)// 大于等于断言，表达式1的值小于表达式2时测试失败XCTAssertGreaterThanOrEqual(expression1, expression2, ...)// 小于断言，表达式1的值大于等于表达式2时测试失败XCTAssertLessThan(expression1, expression2, ...)// 小于等于断言，表达式1的值大于表达式2时测试失败XCTAssertLessThanOrEqual(expression1, expression2, ...)// 异常断言，当表达式没有抛出异常时测试失败XCTAssertThrows(expression, ...)// 特殊异常断言，当表达式抛出的异常不是指定的类时测试失败XCTAssertThrowsSpecific(expression, exception_class, ...)// 特殊异常断言，当表达式抛出的异常不是指定的类和名字时测试失败XCTAssertThrowsSpecificNamed(expression, exception_class, exception_name, ...)// 无异常断言，当表达式有异常抛出时测试失败XCTAssertNoThrow(expression, ...)// 无特殊异常断言，当表达式有指定的异常抛出时测试失败XCTAssertNoThrowSpecific(expression, exception_class, ...)// 无特殊异常断言，当表达式有指定的异常抛出时测试失败XCTAssertNoThrowSpecificNamed(expression, exception_class, exception_name, ...) 五 代码覆盖率与单元测试相关的，还有一个重要的概念：代码覆盖率。代码覆盖率是指在整个测试执行过程中，覆盖到的功能函数与所有功能函数的比例。覆盖率越高说明测试涉及的功能越全。 测试完成后，可以直接在Xcode中查看代码覆盖率，如下图所示： 单元测试保持较高的覆盖率是非常重要的，其从另一个方面也是测试质量的保障。 六 异步函数的测试前面我们演示的测试用例所执行的逻辑都是同步的，但在实际的项目中，异步的操作很多，XCTest框架中也提供了异步逻辑的测试方式。例如对如下业务方法进行测试： 1234567- (void)requestData:(void (^)(BOOL))complete &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; if (complete) &#123; complete(YES); &#125; &#125;);&#125; 测试用例如下： 12345678910- (void)testAsync &#123; XCTestExpectation *except = [self expectationWithDescription:@\"异步请求测试用例\"]; [self.viewModel requestData:^(BOOL success) &#123; XCTAssertTrue(success); [except fulfill]; &#125;]; [self waitForExpectationsWithTimeout:10 handler:^(NSError * _Nullable error) &#123; &#125;];&#125; XCTestExpectation可以理解为一个期望对象，当使用此对象调用fulfill方法后，表示异步逻辑完成，XCTestCase类本身与异步测试相关的方法列举如下： 123456// 创建一个XCTestExpectation对象- (XCTestExpectation *)expectationWithDescription:(NSString *)description;// 等待异步操作结果，可以设置超时时间- (void)waitForExpectationsWithTimeout:(NSTimeInterval)timeout handler:(nullable XCWaitCompletionHandler)handler;- (void)waitForExpectations:(NSArray&lt;XCTestExpectation *&gt; *)expectations timeout:(NSTimeInterval)seconds;- (void)waitForExpectations:(NSArray&lt;XCTestExpectation *&gt; *)expectations timeout:(NSTimeInterval)seconds enforceOrder:(BOOL)enforceOrderOfFulfillment; XCTestExpectation类中封装的常用属性和方法列举如下： 1234567891011// 初始化方法，描述参数会在测试报告中包含- (instancetype)initWithDescription:(NSString *)expectationDescription;// 描述文案@property (copy) NSString *expectationDescription;// 设置是否行为反向@property (getter=isInverted) BOOL inverted;// 设置期望的完成次数@property (nonatomic) NSUInteger expectedFulfillmentCount;@property (nonatomic) BOOL assertForOverFulfill;// 触发一次完成动作- (void)fulfill; 七 关于单元测试的几点建议 我们先不涉及到UI方面的自动化测试，只针对逻辑代码的单元测试，下面这些建议可供参考： 1. 在编码时，要尽量按照MVVM的模式进行开发，相比MVC模式，MVVM的逻辑代码都封装在VM里面，更利于进行脱离UI的测试。可以设想，如果将逻辑方法都写在View或ViewController中，则执行测试用例时就不得不引入很多额外的页面UI组件。 2. 编写测试用例时，有3个核心要考虑的点，即输入，输出和结果判定。我们通过输入来设置测试用例的初始状态，通过对输出的结果判定来决定测试用例是否通过。 3. 在开发中，编写的函数要尽量符合下面的特性：功能单一，有输入有输出。 4. 某些场景下，函数的功能是对输入的参数进行修改，而并没有返回值，则这种场景编写测试用例时，要判断的是执行函数操作后的原始变量是否符合预期。例如： 功能函数： 12345- (void)removeAllObj:(NSMutableArray *)array &#123; if ([array isKindOfClass:NSMutableArray.class]) &#123; [array removeAllObjects]; &#125;&#125; 测试用例： 12345- (void)testRemoveObj &#123; NSMutableArray *array = [NSMutableArray arrayWithObjects:@\"1\", @\"2\", nil]; [self.viewModel removeAllObj:array]; XCTAssertEqual(array.count, 0);&#125; 5. 某些场景下，功能函数可能没有参数也没有返回值，其作用只是执行一段逻辑操作，例如存储文件，修改文件等。这时我们可以修改下功能函数，在函数内返回操作成功或失败的结果，测试用例使用此结果来作为是否通过的标准。 八 XCTest框架中的UI测试相比逻辑功能测试，UI测试通常会麻烦一些。XCTest框架中也集成了UI测试相关的接口。通常在编写测试用例时，我们会将功能测试和UI测试分开编写。创建UI Test Bundle如下： 生成的模板代码中会自带启动性能测试用例，如下： 12345678- (void)testLaunchPerformance &#123; if (@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *)) &#123; // This measures how long it takes to launch your application. [self measureWithMetrics:@[[[XCTApplicationLaunchMetric alloc] init]] block:^&#123; [[[XCUIApplication alloc] init] launch]; &#125;]; &#125;&#125; 其中，XCTApplicationLaunchMetric对象配置为冷启动指标，其会计算从App启动到首帧渲染完成的时间。XCUIApplication用来实例化一个App应用实例，调用launch方法进行启动。默认其会启动当前应用，也可以通过设置bundleId来让其启动其他App进行测试，例如： 123456789- (void)testLaunchPerformance &#123; if (@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *)) &#123; // This measures how long it takes to launch your application. [self measureWithMetrics:@[[[XCTApplicationLaunchMetric alloc] init]] block:^&#123; XCUIApplication *application = [[XCUIApplication alloc] initWithBundleIdentifier:@\"huishao.UnitTestDemo\"]; [application launch]; &#125;]; &#125;&#125; 在UI测试中，我们通常会关注下面几项： 1. 检查页面某些元素是否存在 2.通过代码操作某些元素的交互 3.检查交互后的结果 因此，在UI测试中，如何查询到页面的元素是最重要的，这些工作由XCUIElementQuery类来完成，这个类相关的用法非常繁杂，例如我们要查找页面中标题为btn的按钮并进行点击操作，可以这么做： 1234567- (void)testExample &#123; // UI tests must launch the application that they test. XCUIApplication *app = [[XCUIApplication alloc] init]; [app launch]; XCUIElement *btn = app.staticTexts[@\"btn\"]; [btn tap];&#125; 如果页面查找不到此按钮，则此用例会执行失败。虽然页面元素的查找和定位非常繁琐，幸运的是Xcode提供了用户行为录制功能，我们可以将要测试的操作路径录制下来，点击Xcode的如下按钮即可： 录制完成后，此测试用例中会自动生成查找元素和操作的相关代码，之后执行此用例时将按照录制的步骤进行，如果页面元素没有按照预期出现，则用例会失败。 九 设备性能相关数据测试前面我们有提到一个冷启动时间性能测试的配置项：XCTApplicationLaunchMetric。除此之外，XCTest框架中也默认提供了如CPU，内存等设备性能测试配置。例如： 12345678910111213141516171819- (void)testCPUPerformance &#123; if (@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *)) &#123; // This measures how long it takes to launch your application. [self measureWithMetrics:@[[[XCTCPUMetric alloc] init]] block:^&#123; XCUIApplication *application = [[XCUIApplication alloc] initWithBundleIdentifier:@\"huishao.UnitTestDemo\"]; [application launch]; &#125;]; &#125;&#125;- (void)testMemoryPerformance &#123; if (@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *)) &#123; // This measures how long it takes to launch your application. [self measureWithMetrics:@[[[XCTMemoryMetric alloc] init]] block:^&#123; XCUIApplication *application = [[XCUIApplication alloc] initWithBundleIdentifier:@\"huishao.UnitTestDemo\"]; [application launch]; &#125;]; &#125;&#125; 测试执行完成后，报告中会有详细的性能数据，如下图： 专注技术，热爱生活，交流技术，也做朋友。 —— 珲少 QQ：316045346 同时，如果本篇文章让你觉得有用，欢迎分享给更多朋友，请标明出处。","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"追根问底：Objective-C关联属性原理分析","slug":"447追根问底：Objective-C关联属性原理分析","date":"2022-07-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.398Z","comments":true,"path":"2022/07/17/447追根问底：Objective-C关联属性原理分析/","link":"","permalink":"http://huishao.cc/2022/07/17/447追根问底：Objective-C关联属性原理分析/","excerpt":"","text":"追根问底：Objective-C关联属性原理分析一.引子Objective-C是一种动态性很强的语言，所谓动态能力，也可以理解为运行时能力。对于Objective-C开发者来说，动态性所带来的编程便利无处不在。例如通过Category类别来扩展已有类的功能。可以使已有类拥有新的方法和属性。但是，如果你有使用Category来扩展类的属性，你一定了解并非简单的使用@property进行声明即可。例如下面的代码： 12345678910111213141516171819202122232425262728#import &lt;Foundation/Foundation.h&gt;@interface MyObject : NSObject@end@implementation MyObject@end@interface MyObject (Property)@property (nonatomic, copy) NSString *addProperty;@end@implementation MyObject (Property)@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyObject *object = [[MyObject alloc] init]; object.addProperty = @\"HelloWorld\"; NSLog(@\"%@\", object.addProperty); &#125; return 0;&#125; 代码在编译时不会有任何问题，但是如果运行，就会出现未定义的方法异常。因此如果要扩展类的属性，我们通常会这样实现： 123456789101112131415#import &lt;objc/runtime.h&gt;@implementation MyObject (Property)static NSString *kAddPropertyKey = @\"kAddPropertyKey\";- (void)setAddProperty:(NSString *)addProperty &#123; objc_setAssociatedObject(self, kAddPropertyKey, addProperty, OBJC_ASSOCIATION_COPY);&#125;- (NSString *)addProperty &#123; return objc_getAssociatedObject(self, kAddPropertyKey);&#125;@end 再次运行，就可以正常的对addProperty属性进行存取值了。这里其实就使用到了Objective-C运行时的特性，在Objective-C中，类对象在创建时其所占用的内存空间就已经确定，那么你有没有想过，通过objc_setAssociatedObject这个运行时方法所存储的属性值是如何与当前对象关联起来的，这些数据又是存在哪里的？幸运的时，从objc源码可以清楚的了解关联属性的实现逻辑，这也是我们本篇文章要讨论的重点，了解这里的原理可能不能对你使用关联属性提供多大的帮助，但是这种设计思路定会使你在日常开发中受益匪浅。 二. objc_setAssociatedObject方法的核心原理通过objc的runtime源码，我们可以看到objc_setAssociatedObject的方法实现如下： 12345voidobjc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)&#123; _object_set_associative_reference(object, key, value, policy);&#125; 这一步无需过多解释，只是调用了一个内部函数，_object_set_associative_reference内部函数是关联属性实现的核心，此函数解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void_object_set_associative_reference(id object, const void *key, id value, uintptr_t policy)&#123; // 1.安全性检查，要关联的对象和要关联的值不能为空 if (!object &amp;&amp; !value) return; // 2.检查当前对象是否不允许关联属性，某些类不允许其实例有关联属性 if (object-&gt;getIsa()-&gt;forbidsAssociatedObjects()) _objc_fatal(\"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects\", object, object_getClassName(object)); // 3.创建一个包装对象指针的结构对象，存储要关联的对象指针 DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;; // 4.创建一个包装关联策略和被关联值的对象 ObjcAssociation association&#123;policy, value&#125;; // 5.根据关联策略来对值进行引用（retain或copy） association.acquireValue(); bool isFirstAssociation = false; &#123; // 6.获取关联管理器及其中的关联表对象 AssociationsManager manager; AssociationsHashMap &amp;associations(manager.get()); // 7.值如果存在，则进行关联 if (value) &#123; // 8.尝试向表中插入当前要关联的对象和值，如果已经存在，则什么都不做 auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;); // 9. 检查try_emplace方法的插入结果，如果做了插入操作，则标记首次关联为true if (refs_result.second) &#123; isFirstAssociation = true; &#125; // 10.将表中存储的值与key进行关联 auto &amp;refs = refs_result.first-&gt;second; auto result = refs.try_emplace(key, std::move(association)); // 11.如果key已经存在，则进行关联策略和关联值的交换 if (!result.second) &#123; association.swap(result.first-&gt;second); &#125; // 12. 要关联的值为nil，则为清除操作 &#125; else &#123; // 13. 查找到关联到此对象的属性对 auto refs_it = associations.find(disguised); if (refs_it != associations.end()) &#123; // 14.有关联属性，获取存储key的表 auto &amp;refs = refs_it-&gt;second; // 15.查找对应key是否存在 auto it = refs.find(key); if (it != refs.end()) &#123; // 16.存在则进行关联数据的替换，包括关联策略和值，此时实际上是将值清空了 association.swap(it-&gt;second); // 17.相关擦除操作 refs.erase(it); if (refs.size() == 0) &#123; associations.erase(refs_it); &#125; &#125; &#125; &#125; &#125; // 18.判断是否为此类实例对象的第一次关联，如果是，则修改标记位，标明已经有关联属性 if (isFirstAssociation) object-&gt;setHasAssociatedObjects(); // 19.将旧的值进行release，如果需要的话 association.releaseHeldValue();&#125; 可以看到，整个关联属性的过程非常清晰，对于新值是否需要retain以及旧值是否需要release，是由关联策略决定的： 123456789enum &#123; OBJC_ASSOCIATION_SETTER_ASSIGN = 0, // assgin属性 OBJC_ASSOCIATION_SETTER_RETAIN = 1, // 设置值的时候需要retain OBJC_ASSOCIATION_SETTER_COPY = 3, // 设置值的时候需要copy OBJC_ASSOCIATION_GETTER_READ = (0 &lt;&lt; 8), // readonly的属性 OBJC_ASSOCIATION_GETTER_RETAIN = (1 &lt;&lt; 8), // 获取值的时候需要retain OBJC_ASSOCIATION_GETTER_AUTORELEASE = (2 &lt;&lt; 8), // 获取值的时候需要autorelease OBJC_ASSOCIATION_SYSTEM_OBJECT = _OBJC_ASSOCIATION_SYSTEM_OBJECT, // 1 &lt;&lt; 16&#125;; acquireValue方法实现如下，其只是判断是否需要retain和copy，之后调用对应的函数： 123456789101112inline void acquireValue() &#123; if (_value) &#123; switch (_policy &amp; 0xFF) &#123; case OBJC_ASSOCIATION_SETTER_RETAIN: _value = objc_retain(_value); break; case OBJC_ASSOCIATION_SETTER_COPY: _value = ((id(*)(id, SEL))objc_msgSend)(_value, @selector(copy)); break; &#125; &#125;&#125; 在上面第8步中，有调用try_emplace方法来将数据插入到表结构中，此函数插入时会判断要插入的数据是否存在，其返回值会告知调用者是否产生了插入操作，如果已经存在，则此函数会什么都不做。 三. 获取和移除关联属性的原理现在，我们已经基本清楚了关联属性是如何设置和存储的，再来理解如果获取和移除就非常容易了。 获取关联属性的值是使用objc_getAssociatedObject运行时方法实现的，此方法实现如下： 12345idobjc_getAssociatedObject(id object, const void *key)&#123; return _object_get_associative_reference(object, key);&#125; 我们还是主要来解析下其调用的_object_get_associative_reference内部方法： 1234567891011121314151617181920212223242526id_object_get_associative_reference(id object, const void *key)&#123; // 1.创建关联对象结构 ObjcAssociation association&#123;&#125;; &#123; // 2.获取关联管理器及全局的Hash表 AssociationsManager manager; AssociationsHashMap &amp;associations(manager.get()); // 3.尝试查找当前传入对象的关联属性 AssociationsHashMap::iterator i = associations.find((objc_object *)object); if (i != associations.end()) &#123; // 4.如果当前对象有关联属性，尝试查找存储key的列表中是否存在传入的key ObjectAssociationMap &amp;refs = i-&gt;second; ObjectAssociationMap::iterator j = refs.find(key); if (j != refs.end()) &#123; // 5.如果可以查到，对association进行赋值 association = j-&gt;second; // 6.根据关联策略来决定是否对返回的值进行retain association.retainReturnedValue(); &#125; &#125; &#125; // 7.根据返回策略来决定是否需要autorelease，如果没有查到，会返回nil值 return association.autoreleaseReturnedValue();&#125; 对于已经关联了属性的对象，我们也可以调用objc_removeAssociatedObjects方法来将关联的所有属性进行移除，此方法实现如下： 1234567void objc_removeAssociatedObjects(id object) &#123; // 对象存在，并且已经标记过关联属性 if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123; _object_remove_assocations(object, /*deallocating*/false); &#125;&#125; _object_remove_assocation内部函数的实现也不复杂，解析如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void_object_remove_assocations(id object, bool deallocating)&#123; // 1.创建关联对象 ObjectAssociationMap refs&#123;&#125;; &#123; // 2.获取关联管理器及Hash表 AssociationsManager manager; AssociationsHashMap &amp;associations(manager.get()); // 3.查找传入对象的关联属性 AssociationsHashMap::iterator i = associations.find((objc_object *)object); if (i != associations.end()) &#123; // 4.查找到后，用空值进行交换 refs.swap(i-&gt;second); // 5.如果是系统对象，则需要保留关联 bool didReInsert = false; if (!deallocating) &#123; for (auto &amp;ref: refs) &#123; if (ref.second.policy() &amp; OBJC_ASSOCIATION_SYSTEM_OBJECT) &#123; i-&gt;second.insert(ref); didReInsert = true; &#125; &#125; &#125; // 6.无需保留关联，则直接清除数据 if (!didReInsert) associations.erase(i); &#125; &#125; // 7.对旧值进行release操作 SmallVector&lt;ObjcAssociation *, 4&gt; laterRefs; for (auto &amp;i: refs) &#123; if (i.second.policy() &amp; OBJC_ASSOCIATION_SYSTEM_OBJECT) &#123; // If we are not deallocating, then RELEASE_LATER associations don't get released. if (deallocating) laterRefs.append(&amp;i.second); &#125; else &#123; i.second.releaseHeldValue(); &#125; &#125; for (auto *later: laterRefs) &#123; later-&gt;releaseHeldValue(); &#125;&#125; 四. 关联属性如何进行内存管理？通过前面的介绍，我们知道在关联属性时，可以通过关联策略来设置一些和内存管理相关的选项，在设置关联属性时，如果需要的话，其内部会根据内存管理策略对旧值进行release操作，但是你是否有想过，当对象正常的生命周期结束后，这些关联属性占用的的内存是如何回收的？这就需要我们从系统的dealloc方法中寻找答案了。 系统对象在销毁时，dealloc方法最终会执行到一个名为objc_destructInstance的内部函数，此函数实现如下： 1234567891011121314void *objc_destructInstance(id obj) &#123; if (obj) &#123; bool cxx = obj-&gt;hasCxxDtor(); // 通过标记获取此对象是否有关联属性 bool assoc = obj-&gt;hasAssociatedObjects(); if (cxx) object_cxxDestruct(obj); // 移除掉此对象的关联属性 if (assoc) _object_remove_assocations(obj, /*deallocating*/true); obj-&gt;clearDeallocating(); &#125; return obj;&#125; 其中会判断要销毁的对象是否有关联属性，如果有，又会调用到_object_remove_assocation函数来进行关联属性的移除，这个函数前面介绍过，内部会处理内存管理问题。 五.关联管理器与表的创建时机在整个关联属性实现方案中，还有一点我们没有闭环介绍，即全局的关联管理器和Hash表是怎么创建的，何时创建的。我们目前只看到，当要设置或获取关联属性时，直接拿到管理器和Hash表进行使用，并无初始化。其实，这些全局数据结构的创建在runtime初始化时就已经完成，流程路径如下： 1. 调用runtime入口函数_objc_init 2. 通知调用map_images函数 3. 调用map_images_nolock函数 map_images_nolock其中会调用arr_init函数，此函数实现如下： 12345678void arr_init(void) &#123; AutoreleasePoolPage::init(); SideTablesMap.init(); _objc_associations_init(); if (DebugScanWeakTables) startWeakTableScan();&#125; 可以看到，此函数会进行自动释放池，关联属性等逻辑的初始化。 专注技术，热爱生活，交流技术，也做朋友。 —— 珲少 QQ：316045346 同时，如果本篇文章让你觉得有用，欢迎分享给更多朋友，请标明出处。","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"Clang代码覆盖率检测（插桩技术）","slug":"446Clang代码覆盖率检测（插桩技术）","date":"2022-06-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.398Z","comments":true,"path":"2022/06/19/446Clang代码覆盖率检测（插桩技术）/","link":"","permalink":"http://huishao.cc/2022/06/19/446Clang代码覆盖率检测（插桩技术）/","excerpt":"","text":"Clang代码覆盖率检测（插桩技术）Clang的全称是C Language Family Frontend for LLVM，即基于LLVM的C系列语言的前端编译器。iOS应用的前端编译，即是采用Clang完成的。本篇文章，我们主要介绍Clang内置的一个简单的代码覆盖率检测功能，对于iOS开发来说，此功能更多用于Objective-C的方法插桩，为二进制重排提供支持，优化应用启动速度。但代码覆盖率检测功能并不仅仅只能应用与二进制重排，其本质是对于函数级、基本块级或代码边缘级插入回调，我们可以基于这一原理更灵活的实现所需要的功能。 1. Tracing PCs with guards开启Clang代码覆盖率检查功能，需要配置-fsanitize-coverage编译参数，你可以创建一个iOS模板工程做测试，在Build Settings-&gt;Apple Clang - Custom Complier Flags-&gt;Other C Flags下面配置。如图： trace-pc-guard模式下，所有代码块首部都会被插入如下回调函数： void __sanitizer_cov_trace_pc_guard(uint32_t *guard) 此回调函数是需要开发者自定义的，除此之外，还需要实现对应初始化的回调函数： void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) 在示例工程的main.m文件中定义这两个回调如下： 123456789101112131415void __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123; void *PC = __builtin_return_address(0); Dl_info info; dladdr(PC, &amp;info); printf(\"%s \\n\",info.dli_sname);&#125;void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) &#123; static uint64_t N; if (start == stop || *start) return; for (uint32_t *x = start; x &lt; stop; x++) &#123; *x = ++N; &#125; printf(\"INIT Count: %llu \\n\", N);&#125; 其中，__sanitizer_cov_trace_pc_guard_init为初始化回调，通过其中参数可以获取到符号个数，__sanitizer_cov_trace_pc_guard是插桩函数，每个代码块开始调用时，都会首先调用此插桩函数。 直接运行代码，控制台输出如下： 1234567891011121314INIT Count: 14 main -[AppDelegate application:didFinishLaunchingWithOptions:] -[SceneDelegate window] -[SceneDelegate setWindow:] -[SceneDelegate window] -[SceneDelegate window] -[SceneDelegate scene:willConnectToSession:options:] -[SceneDelegate window] -[SceneDelegate window] -[SceneDelegate window] -[ViewController viewDidLoad] -[SceneDelegate sceneWillEnterForeground:] -[SceneDelegate sceneDidBecomeActive:] 可以看到，输出的结果就是按照项目中方法的调用顺序排序的。你可能看到有许多重复的符号，这是由于trace-pc-guard设定的，其会对源码中任意的代码块开始执行时进行插桩函数回调，包括if判断，while循环以及Block调用等，例如你可以尝试在ViewController.m文件的viewDidLoad方法中添加一些代码，如下： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; printf(\"开始Block==================\\n\"); void(^block)(void) = ^&#123; &#125;; block(); printf(\"开始循环==================\\n\"); int n = 3; while (n &gt; 0) &#123; n--; &#125; printf(\"开始分支判断==================\\n\"); if (n &lt; 10) &#123; n++; &#125;&#125; 运行项目，输出效果如下： 12345678910111213141516171819202122INIT Count: 18 main -[AppDelegate application:didFinishLaunchingWithOptions:] -[SceneDelegate window] -[SceneDelegate setWindow:] -[SceneDelegate window] -[SceneDelegate window] -[SceneDelegate scene:willConnectToSession:options:] -[SceneDelegate window] -[SceneDelegate window] -[SceneDelegate window] -[ViewController viewDidLoad] 开始Block==================__29-[ViewController viewDidLoad]_block_invoke 开始循环==================-[ViewController viewDidLoad] -[ViewController viewDidLoad] -[ViewController viewDidLoad] 开始分支判断==================-[ViewController viewDidLoad] -[SceneDelegate sceneWillEnterForeground:] -[SceneDelegate sceneDidBecomeActive:] 有时候并非所有的代码块都需要插桩，例如做二进制重排时，只需要方法和函数的插桩，也有配置方式，我们后面介绍。 2. Inline 8bit-counters此模式需要配置成： 1-fsanitize-coverage=inline-8bit-counters 此模式与trace-pc-guard类似，只是其在代码块开始时不会进行回调，而是简单的增加内置计数器的计数。同样，在此模式下，用户需要实现如下自定义函数： 1234void __sanitizer_cov_8bit_counters_init(char *start, char *end) &#123; // [start,end) is the array of 8-bit counters created for the current DSO. // Capture this array in order to read/modify the counters.&#125; 此函数对应计数器的初始化。 3. Inline bool-flag此模式与inline-8bit-counters模式类似，需要配置成： 1-fsanitize-coverage=inline-bool-flag 在此模式下，在代码块开始时会将一个内置的布尔值置为true，而不是增加计数器的计数。需要实现如下函数来捕获此变量： 1234void __sanitizer_cov_bool_flag_init(bool *start, bool *end) &#123; // [start,end) is the array of boolean flags created for the current DSO. // Capture this array in order to read/modify the flags.&#125; 4. Tracing PCs此模式在代码块的开始出会回调__sanitizer_cov_trace_pc() 函数，也是插桩回调，此模式可配置为： 1-fsanitize-coverage=trace-pc 对应实现自定义的插桩函数如下： 1234567void __sanitizer_cov_trace_pc(void*a) &#123; void *PC = __builtin_return_address(0); Dl_info info; dladdr(PC, &amp;info); printf(\"%s %p \\n\",info.dli_sname, info.dli_saddr); printf(\"__sanitizer_cov_trace_pc:%p\\n\",a);&#125; 对于此模式，我们可以配置一个额外的参数来区别间接调用，例如修改ViewController.m文件中的代码如下： 1234567891011121314151617181920212223242526272829303132#import \"ViewController.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; printf(\"开始Block==================\\n\"); void(^block)(void) = ^&#123; &#125;; block(); printf(\"开始循环==================\\n\"); int n = 3; while (n &gt; 0) &#123; n--; &#125; printf(\"开始分支判断==================\\n\"); if (n &lt; 10) &#123; n++; &#125; [self log];&#125;- (void)log &#123; &#125;@end 新定义了一个log函数，并在ViewDidLoad中进行了调用，配置编译选项如下： 1-fsanitize-coverage=trace-pc,indirect-calls 对应实现间接调用的插桩回调如下： 123void __sanitizer_cov_trace_pc_indir(void *callee) &#123; printf(&quot;__sanitizer_cov_trace_pc_indirect:%p\\n&quot;,callee);&#125; 运行代码，控制台输出如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647main 0x105f5dee0 __sanitizer_cov_trace_pc:0x1-[AppDelegate application:didFinishLaunchingWithOptions:] 0x105f5dae0 __sanitizer_cov_trace_pc:0x6000019241f0-[SceneDelegate window] 0x105f5e200 __sanitizer_cov_trace_pc:0x600001b1ffc0-[SceneDelegate setWindow:] 0x105f5e240 __sanitizer_cov_trace_pc:0x600001b1ffc0-[SceneDelegate window] 0x105f5e200 __sanitizer_cov_trace_pc:0x600001b1ffc0-[SceneDelegate window] 0x105f5e200 __sanitizer_cov_trace_pc:0x600001b1ffc0-[SceneDelegate scene:willConnectToSession:options:] 0x105f5df80 __sanitizer_cov_trace_pc:0x600001b1ffc0-[SceneDelegate window] 0x105f5e200 __sanitizer_cov_trace_pc:0x600001b1ffc0-[SceneDelegate window] 0x105f5e200 __sanitizer_cov_trace_pc:0x600001b1ffc0-[SceneDelegate window] 0x105f5e200 __sanitizer_cov_trace_pc:0x600001b1ffc0-[ViewController viewDidLoad] 0x105f5d940 __sanitizer_cov_trace_pc:0x7fec54f08490-[ViewController viewDidLoad] 0x105ffa2c8 __sanitizer_cov_trace_pc_indirect:0x7fff20183600开始Block==================-[ViewController viewDidLoad] 0x105ffa2c8 __sanitizer_cov_trace_pc_indirect:0x105f5da80__29-[ViewController viewDidLoad]_block_invoke 0x105f5da80 __sanitizer_cov_trace_pc:0x105f60040开始循环==================-[ViewController viewDidLoad] 0x105f5d940 __sanitizer_cov_trace_pc:0x7fff864ab328-[ViewController viewDidLoad] 0x105f5d940 __sanitizer_cov_trace_pc:0x7fff864ab328-[ViewController viewDidLoad] 0x105f5d940 __sanitizer_cov_trace_pc:0x7fff864ab328开始分支判断==================-[ViewController viewDidLoad] 0x105f5d940 __sanitizer_cov_trace_pc:0x7fff864ab328-[ViewController viewDidLoad] 0x105ffa2c8 __sanitizer_cov_trace_pc_indirect:0x7fff201833c0-[ViewController log] 0x105f5dab0 __sanitizer_cov_trace_pc:0x7fec54f08490-[SceneDelegate sceneWillEnterForeground:] 0x105f5e140 __sanitizer_cov_trace_pc:0x600001b1ffc0-[SceneDelegate sceneDidBecomeActive:] 0x105f5e080 __sanitizer_cov_trace_pc:0x600001b1ffc0 5. 不同级别的检测前面我们介绍的编译模式，会对函数，Block和逻辑代码块进行检测，有时候我们不需要这个细粒度的检测，例如在二进制重排时，我们仅仅想检测方法和函数，只想对方法函数进行插桩，此时就可以配置检测级别参数，支持的级别参数有三种： 1. edge：默认的级别，细粒度最高的级别，函数，Block和代码块都会被插桩。 2. bb：基础的块级代码会被插桩。 3. func：仅仅函数块会被插桩。 通常我们在做二进制重排时，更关注的是函数的调用顺序，使用func等级即可，编译设置如下： 1-fsanitize-coverage=trace-pc,func 专注技术，热爱生活，交流技术，也做朋友。 —— 珲少 QQ：316045346 同时，如果本篇文章让你觉得有用，欢迎分享给更多朋友，请标明出处。","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"前端自动化构建之Gulp","slug":"445前端自动化构建之Gulp","date":"2022-06-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.398Z","comments":true,"path":"2022/06/18/445前端自动化构建之Gulp/","link":"","permalink":"http://huishao.cc/2022/06/18/445前端自动化构建之Gulp/","excerpt":"","text":"前端自动化构建之Gulp本篇文章的核心是介绍一款强大的任务流工具Gulp，之所以题目叫做“前端自动化构建之Gulp”，是因为Gulp本身是使用JS编写的运行在Node环境的一个npm包，并且大部分开发者也都使用它来作为前端项目的自动化构建工具。不过，从本质上说，Gulp并非只能做前端自动化构建，后端构建发布自动化，脚本工具集自动化，测试流程自动化等都可以使用Gulp。所以，无论你是哪个技术栈的开发者，学习使用Gulp都会对你大有裨益。 这边文章能够带给你： Gulp工具的安装 Gulp工作原理 创建自动化流程中的独立任务 任务的串行与并行 使用管道处理数据流 监听文件变更 简易前端自动化构建DEMO流程 本篇文章虽然无法将Gulp所有的细节都介绍到，但总体上来说挑选了其中最核心的部分，也是最实用的部分进行了介绍，并且通过一个前端DEMO的示例，演示使用Gulp进行[环境初始化-&gt;代码合并-&gt;代码压缩-&gt;启动服务器-&gt;监听文件-&gt;热更新浏览器]的完整自动化流程。 一.Gulp基础好像任何技术栈的开发者，都会遇到耗费时间且让人痛苦不堪的流程问题。除了基础的研发，测试，部署流程外，往往中间还需要根据需求执行额外的任务，例如代码检查，代码压缩，代码混淆等。这些流程虽然与研发无关，但是却是产品上线的必备过程，繁琐的流程不仅会消耗开发者额外的精力，对于团队来说，也很难控制所有开发者所执行的流程都一致且完整，例如某些成员可能由于疏忽大意而忘记做代码压缩就直接将项目发布上线了。因此，将流程自动化不仅可以解放人力，更是项目稳定性的保障。Gulp就是为解决这样问题而发现的一款简单，高效且生态完整的自动化工具。 1.安装GulpGulp是运行在Node环境中的，因此你需要先安装Node.js，这里不再赘述。 Gulp工具分两部分构成，全局Gulp CLI和本地Gulp。关于他们之间的关系，后面我们再详细介绍。首先先来安装全局的Gulp CLI工具，在终端执行如下指令： 1sudo npm install -g gulp-cli 安装完成后，要检查是否安装成功，可以键入如下指令： 1gulp -v 此时，你应该可以看到如下的输出： 12CLI version: 2.3.0Local version: Unknown 其中，第一行表示我们安装的全局的Gulp CLI工具的版本号，第二行表示本地Gulp版本号，本地Gulp是安装在具体的项目目录中的，此时我们尚未安装。下面我们可以创建一个项目目录，例如创建名为gulp-demo文件夹，在目录下使用下面的指令来初始化Node模块： 1npm init 在当前目录下使用如下指令来安装本地Gulp： 1npm install --save-dev gulp 安装完成后，再次执行gulp -v，可以看到本地Gulp的版本，如下： 12CLI version: 2.3.0Local version: 4.0.2 需要注意，你在测试时，要使用4.x及以上的本地Gulp版本。 2.Gulp的工作原理前面，我们安装了Gulp CLI和本地Gulp，现在是时候来介绍下Gulp的工作原理了。在使用Gulp时，我们需要编写一个名为Gulpfile.js的文件，这个文件是Gulp工作的核心，其中会定义各种任务及任务流。Gulp CLI工具是启动Gulp的入口，其通过指令来调用项目中的本地Gulp，本地Gulp会调用Gulpfile.js文件，加载和执行定义好的任务，在Gulpfile.js文件中，通常又需要调用本地Gulp模块中提供的API方法，以及本地Gulp插件或自定义函数的功能从而实现任务。工作原理如下图所示： 3.编写Gulpfile.js文件在学习编程语言时，第一个程序通常都是HelloWorld，Gulp的学习也不例外，我们先来测试下Gulp的HelloWorld程序。在工程目录下新建一个命名为Gulpfile.js的文件，在其中编写如下代码： 12345678// 引入本地Gulp模块var gulp = require('gulp');// 调用task方法来定义任务gulp.task('gulp', function(done)&#123; console.log(\"Hello Gulp!\"); done();&#125;); 其中，task函数用来定义任务，其第1个参数为任务名，第2个参数为要执行的任务方法，这里我们传入了一个自定义的函数，此函数中会传入一个回调done参数，当任务逻辑代码结束后，要调用此回调通知Gulp此任务已经结束，否则会阻塞Gulp后续任务的执行。 在当前目录下，执行如下终端指令： 1gulp gulp 此指令的作用是让全局Gulp CLI工具调用本地Gulp来执行Gulpfile.js中定义的名为gulp的任务。执行后，终端输出如下： 1234[09:37:18] Using gulpfile ~/Desktop/gulp-demo/gulpfile.js[09:37:18] Starting &apos;gulp&apos;...Hello Gulp![09:37:18] Finished &apos;gulp&apos; after 2.55 ms 可以看到，正确输出的Hello Gulp!，并且执行任务的开始时间和结束时间都有记录，任务耗时也有记录。 二.Gulp任务链与数据流我们已经知道如何通过Gulp来执行独立的任务，但更多实际场景中，自动化的流程都不是简单独立的任务可以完成的，我们需要将任务组成任务链。例如我们模拟这几个任务： 123456789101112131415161718192021222324gulp.task('clean', function(done)&#123; console.log(\"清理构建目录\"); done();&#125;);gulp.task('copy', function(done)&#123; console.log(\"复制模板文件\"); done();&#125;);gulp.task('build', function(done)&#123; console.log(\"编译代码\"); done();&#125;);gulp.task('server', function(done)&#123; console.log(\"启动开发服务器\"); done();&#125;);gulp.task('watch', function(done)&#123; console.log(\"监听文件变化持续热更新\"); done();&#125;); 上面5个任务模拟了前端自动化构建的基本流程，这些任务间有些是有依赖关系的，比如清理构建目录任务来在复制模板文件和编译代码之前，不然可能刚编译好的代码就又被清掉了，启动开发服务器则要在复制模板文件和编译代码之后，但是复制模板文件和编译代码这两个任务是可以并行进行的。使用Gulp任务链，可以非常方便的实现任务间依赖处理。 1.series和parallelseries意为串行，parallel意为并行。通过Gulp中的这两个API，可以方便的将任务组合成串行链或并行链，任务链也可以作为一个独立的任务在组合进其他的任务链，这样就是Gulp任务的组合变得非常灵活。按照前面描述的需求添加一个任务链如下： 123456gulp.task('dev', gulp.series( 'clean', gulp.parallel('copy', 'build'), 'server', 'watch')); 在终端中键入gulp dev，输出情况如下： 123456789101112131415161718[10:38:08] Using gulpfile ~/Desktop/gulp-demo/gulpfile.js[10:38:08] Starting &apos;dev&apos;...[10:38:08] Starting &apos;clean&apos;...清理构建目录[10:38:08] Finished &apos;clean&apos; after 915 μs[10:38:08] Starting &apos;copy&apos;...[10:38:08] Starting &apos;build&apos;...复制模板文件[10:38:08] Finished &apos;copy&apos; after 349 μs编译代码[10:38:08] Finished &apos;build&apos; after 423 μs[10:38:08] Starting &apos;server&apos;...启动开发服务器[10:38:08] Finished &apos;server&apos; after 180 μs[10:38:08] Starting &apos;watch&apos;...监听文件变化持续热更新[10:38:08] Finished &apos;watch&apos; after 153 μs[10:38:08] Finished &apos;dev&apos; after 5.57 ms 从输出可以看到，任务间的串行和并行关系已经可以满足我们的需求，使用Gulp处理任务依赖就是这么简单。 我们再回过头来看一下series和parallel两个方法，其内可以传入不限个数个参数，参数可以是字符串，可以是函数，也可以是其他的任务链组合。当参数为字符串时，其会被当成任务名来调用指定任务，当参数为函数时，会执行此函数，当参数为任务链组合时，会执行对应的任务链。当参数为函数时要特别注意，必须回调通知Gulp任务完成，否则会阻塞任务链。如下： 12345678910gulp.task('dev', gulp.series( 'clean', function(done)&#123; console.log('custom method'); done(); &#125;, gulp.parallel('copy', 'build'), 'server', 'watch')); 执行后，终端输出如下： 123456789101112131415161718192021[10:46:31] Using gulpfile ~/Desktop/gulp-demo/gulpfile.js[10:46:31] Starting &apos;dev&apos;...[10:46:31] Starting &apos;clean&apos;...清理构建目录[10:46:31] Finished &apos;clean&apos; after 738 μs[10:46:31] Starting &apos;&lt;anonymous&gt;&apos;...custom method[10:46:31] Finished &apos;&lt;anonymous&gt;&apos; after 238 μs[10:46:31] Starting &apos;copy&apos;...[10:46:31] Starting &apos;build&apos;...复制模板文件[10:46:31] Finished &apos;copy&apos; after 520 μs编译代码[10:46:31] Finished &apos;build&apos; after 490 μs[10:46:31] Starting &apos;server&apos;...启动开发服务器[10:46:31] Finished &apos;server&apos; after 168 μs[10:46:31] Starting &apos;watch&apos;...监听文件变化持续热更新[10:46:31] Finished &apos;watch&apos; after 117 μs[10:46:31] Finished &apos;dev&apos; after 7.16 ms 你或许发现了，执行到自定义的函数时，终端显示的任务名是anonymous，表示匿名的，更好的方式是我们使用具名函数，这样方便对任务执行状态进行回溯，如下： 12345678910gulp.task('dev', gulp.series( 'clean', function customMethod(done)&#123; console.log('custom method'); done(); &#125;, gulp.parallel('copy', 'build'), 'server', 'watch')); 2.关于Gulp数据流从宏观上了解了Gulp任务的串行与并行，现在我们再来关注下更具体的问题。本地Gulp本身提供了许多强大的API，像前面用到的task，series，parallel都是API其中之一。自动化构建，本质上是对文件的扫描和处理，因此Gulp中也封装了与文件操作相关的API。 首先，读取文件流和输出文件流的两个API分别是src和dest。 src方法用来创建一个文件数据流，可以从文件系统读取文件数据到虚拟文件对象，虚拟文件对象是Gulp中的一个概念，其会将文件的名称，信息，数据等抽象成一个虚拟的对象，之后文件的操作都在内存中进行，速度很快，直到处理完成后在输出到指定文件。例如开发时，我们的模板代码通常在src目录下，编译打包后会将处理后的文件放入dest目录下，这就涉及到文件的拷贝处理。 在工程目录下创建一个名为src的子文件夹，在其中创建一个简单的HTML文件，修改下copy任务如下： 1234gulp.task('copy', function(done)&#123; return gulp.src('src/*.html'). pipe(gulp.dest('dest'));&#125;); 再次执行整个任务流，可以看到项目根目录中自动生成了一个dest文件夹，并且已经将HTML文件拷贝了进去。在这个copy任务的实现函数中，我们并没有调用done回调，这是因为gulp的API已经实现了Gulp任务接口规范，直接返回结果即可。 src方法读取文件数据流时，可以指定具体的文件或通配符，如上代码所示，表示将src文件夹下所有的HTML文件选中，创建成数据流，数据流提供的主要API是pipe方法，这个方法用来连接各个处理数据流的节点，可以将它理解为一个管道，输入从一端流入，处理后从另一端流出，如果需要继续进行其他处理，还可以连接其他管道。这种责任链的设计模式，可以非常灵活的连接各个处理插件。以前端代码合并压缩处理为例，流程如下： 文件系统—-&gt;src[虚拟文件流]—&gt;文件合并模块[合并后的虚拟文件流]—&gt;代码压缩模块[压缩有的虚拟文件流]—&gt;dest[回写到文件系统]—&gt;文件系统 三.实践：简易前端自动化构建流程前面我们逻辑上模拟了前端自动化构建过程，只是在实现上，都是用的log进行模拟，这并不十分有趣。使其，使用Gulp搭建一个简易的前端构建自动化流程并不复杂，几分钟就可以搞定。 1.安装几个Gulp插件Gulp有着非常丰富的生态，本质上，任意npm模块我们都可以直接使用，除此之外，还有4000多个专门为Gulp设计的插件，可以方便的支持各种文件处理，代码检查等需求。插件地址如下： https://gulpjs.com/plugins/ 本次实践，需要使用到2个Gulp插件和2个npm模块，分别进行文件合并，代码压缩，文件删除和浏览器测试热更新。在项目目录下使用如下指令来安装这些模块： 1234npm install --save-dev gulp-concat npm install --save-dev gulp-uglify npm install --save-dev del npm install --save-dev browser-sync 在Gulpfile.js中引入这些模块： 12345var gulp = require('gulp');var concat = require ('gulp-concat');var uglify = require('gulp-uglify');var del = require('del')var bSync = require('browser-sync').create(); 2.实现自动化构建流程中的几个任务首先我们先来实现clean任务，修改代码如下： 123gulp.task('clean', function(done)&#123; return del(['dest'])&#125;); 上面代码的作用是将dest文件夹删除，每次初始构建，我们都将旧的目录删掉，以免缓存的文件对最终的软件包造成影响。 copy任务的实现方法不变，直接将HTML文件模板拷贝到指定的构建目录即可： 1234gulp.task('copy', function(done)&#123; return gulp.src('src/*.html'). pipe(gulp.dest('dest'));&#125;); 编译的过程主要涉及到CSS相关的SASS或LESS编译，或TS，CoffeeScript的编译等等，为了简单起见，我们只做JS文件的合并和压缩，如下： 123456gulp.task('build', function(done)&#123; return gulp.src('src/*.js') .pipe(concat('main.js')) .pipe(uglify()) .pipe(gulp.dest('dest'))&#125;); 上面代码的作用是将src文件夹下所有的JS文件合并到一个名为main.js的文件中，并进行代码压缩，最后输出到dest文件夹。 实现server任务如下： 123456gulp.task('server', function(done)&#123; bSync.init(&#123; server:'./dest', &#125;); done();&#125;); 上面代码会启动本地服务器，并引导chrome项目页面。 对于监听本地文件的变化，Gulp中自带对应的API，实现watch任务如下： 123456789gulp.task('watch', function(done)&#123; gulp.watch(['src/*.js'],gulp.parallel('build')); gulp.watch(['src/*.html'],gulp.parallel('copy')); gulp.watch(['dest/**/*'],function(done)&#123; bSync.reload('index.html'); done() &#125;); done();&#125;); 这里需要注意，由于我们对JS文件的编译和HTML模板的拷贝任务是分开的，因此监听也可以分开，当发现JS文件发生了变化时，只进行编译任务即可，当发现HTML文件变化时，只进行模板拷贝任务即可，当构建文件夹有变更时，重新刷新浏览器，从而实现开发过程中的测试热更新。 最后，我们可以写一些测试文件了，在src文件夹下新建两个js文件和一个html文件，代码分别如下： file1.js文件中代码： 1234function mlog(msg) &#123; console.log(Date(),': 自定义输出 -',msg);&#125;mlog(\"hello\"); file2.js文件中代码： 1234var a = 1;var b = 2;var c = a + b;console.log(c); index.html文件中代码： 123456789&lt;html&gt;&lt;header&gt; &lt;script type=\"text/javascript\" src=\"./main.js\"&gt;&lt;/script&gt;&lt;/header&gt;&lt;body&gt; &lt;h1&gt;标题11&lt;/h1&gt;&lt;/body&gt; &lt;/html&gt; 使用gulp dev来开启自动化构建流程，你可以打开chome的控制台，查看控制台的输出，尝试修改下src文件夹中的HTML文件和JS文件，保存后可以看到对应的页面也会发生更新。 到此，我们已经实现了一个简单的前端开发自动化构建流程，Gulp不负你所望吧！ 温馨提示：在子进程结束之前，Gulp进程是不会自动结束的，因此其会一直监听文件的变更刷新页面，要关闭开发服务器，只需control+c即可。 四.结语最后，虽然大多数情况下Gulp会用在前端自动化构建中，但是这并不是Gulp唯一的用途，任何开发工作流都可以使用Gulp来构建，npm包的丰富极大的扩展了Gulp的应用场景。希望本篇文章可以帮你打开技术视野，能够探索出Gulp的更多应用场景，帮助你简化工作流程。 专注技术，热爱生活，交流技术，也做朋友。 —— 珲少 QQ：316045346 同时，如果本篇文章让你觉得有用，欢迎分享给更多朋友，请标明出处。","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"自上而下的理解网络（6）——终篇！ARP与Ethernet Ⅱ","slug":"444自上而下的理解网络（6）——终篇！ARP与Ethernet Ⅱ","date":"2022-03-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.398Z","comments":true,"path":"2022/03/30/444自上而下的理解网络（6）——终篇！ARP与Ethernet Ⅱ/","link":"","permalink":"http://huishao.cc/2022/03/30/444自上而下的理解网络（6）——终篇！ARP与Ethernet Ⅱ/","excerpt":"","text":"自上而下的理解网络（6）——终篇！ARP与Ethernet Ⅱ本篇是本系列博客的最后一篇，回顾此系列文章的介绍过程，我们介绍了： 1.网上冲浪的第一步：DNS域名解析协议 https://my.oschina.net/u/2340880/blog/5272671 2.离我们最近的应用层协议：HTTP https://my.oschina.net/u/2340880/blog/5308979 3.高安全性，高可靠性的应用层协议：HTTPS https://my.oschina.net/u/2340880/blog/5373824 4.可靠的传输层协议：TCP https://my.oschina.net/u/2340880/blog/5420433 5.涉及路由与寻址的网络层协议：IP https://my.oschina.net/u/2340880/blog/5465312 我们一步步的接近了网络传输的底层真相，大千世界，天涯咫尺。看似神奇的网络通信其实就是在这中分层的思想下变得纯粹和简单。本篇之所以是此系列文章的终篇，原因之一是到IP协议这一层后，我们基本已经从逻辑上可以清楚的理解了网络传输的过程，物理层的具体数据传输方式并不会影响我们逻辑上的理解。除此之外，更重要的原因是笔者学识薄浅，对链路层及以下的知识确实不甚了解，因此我们就到此为止。 一. 为什么我们需要MAC地址本篇文章要从MAC地址说起，如果你认为当要传输的数据被完整的封装成IP报文，明确了源IP地址和目的IP地址后就万事大吉了，那只能说你还太年轻了。我们使用Wireshark来抓一个简单的TCP协议报文来看。如下图： 可以看到，在IP协议这一层，是只关注IP地址的，但是再向下，到封装成数据链路层的数据帧时，已经被转换成了源MAC地址和目的MAC地址。你可能会有疑惑，按照我们前面的理解，通过IP地址已经可以唯一的定位到要进行网络通信的两端，为何要多此一举的又使用MAC地址呢？这样做究竟是什么目的又有什么必要性呢？本篇文章就来帮你解惑。 1. 什么是MAC地址首先我们需要先了解下什么是MAC地址，MAC地址全称为Media Access Control Address，通常也将其叫做以太网地址或物理地址，是一个用来确定设备网络位置的地址。我们平时使用的可连接互联网的设备中，都会有一个网卡元件，每个网卡都会有一个全球唯一的MAC地址，是由网络设备制造商生产时烧录在元件内部的。 MAC地址的长度为48位，即6个字节。一般在表示时，我们会以字节为组表示，中间使用冒号进行分割。你也可以查看下当前设备的MAC地址，如下图： 当数据报在网络中输出时，可能需要经过多个中间节点的转发才能最终到达目标节点，在初始节点，我们需要将目标节点的IP映射到中间节点的MAC地址，之后第二个节点根据IP来映射到下一个节点的MAC地址，依次进行映射，直到最终达到目标。因此，数据传输的关键是IP地址到MAC地址的映射，ARP协议就是来做这件事情的。 2. 有了IP地址，为什么还需要MAC地址？我想，这个问题是初次了解到MAC地址的同学都会有的一个问题，要解答这个问题，我们首先要清楚IP地址和MAC地址间的异同之处。 IP地址和MAC地址最大的相同点是他们都是唯一的，我们主要看它们的不同之处： · IP地址是网络层使用的，MAC地址是链路层使用的这一点很容易理解，IP协议本身就是网络层的协议，虽然IP地址是唯一的，但其实基于网络拓扑而设计的，同一台设备修改IP地址很容易。MAC地址则是链路层的概念，其在硬件生产是就烧录好了，同一台设备一般无法变动。 · 长度不同IPv4版本的IP地址长度为32位，IPv6版本的IP地址长度为128位，而MAC地址的长度固定为48位。 IP地址是逻辑上的地址，我们可以理解其作用是将数据从一个逻辑上的网络传递到另一个逻辑上的网络，而MAC地址是链路上的地址，其作用是将数据从一个设备节点传递到另一个设备节点。那么是否可以去掉MAC地址，只使用IP地址呢？理论上好像可行，但实际上却不行。核心的原因也在于IP是逻辑上的，当网卡接收到一块数据时，由于链路层属于下层无法获取上层的逻辑数据，网卡无法自主来过滤这块数据是否是发给我的，需要讲给CPU去运算，上层通过IP逻辑比较来确定的数据报的归属，这会大大的影响网络传输效率，当然如果干掉了分层的概念，可能只需要一个唯一地址就可以解决问题，但是至少对于目前的互联网架构这样是不可行的，这就比如有了域名，我们为什么还需要IP地址是一样的，本质是它们工作在不同的网络分层上。 二. 如何获取目标的MAC地址现在我们知道了MAC地址是通信过程中所必须的，那么是如何获取到MAC地址呢。 1. 缓存表和IP路由类似，我们的网络设备中还会存储两个与MAC地址相关的表。一个是ARP缓存表，一个是MAC地址表。当网络层的数据将要被封装成数据链路层的数据帧时，会通过ARP缓存表来查询IP地址与MAC地址的映射关系，当然如果没有缓存的话，会通过网络层的ARP协议来解析。MAC地址表则是存储着各端口的主机源MAC地址和端口号的映射，以便交换机将数据发送到指定的端口去。 2. ARP协议上面所说的ARP缓存表，其中的数据实际上是通过ARP协议解析到的。ARP协议的核心作用是将IP地址解析成对应的MAC地址，回忆一下，这是否很像我们之前所介绍的DNS协议的作用。首先，ARP协议是IP协议簇中的成员之一，核心的工作原理是源主机在需要获取目的IP的MAC地址时，将目的IP组装成ARP数据报广播到局域网上的所有主机，并接收返回的数据，从而确定目标的MAC地址，接收到数据后，会将数据存储ARP缓存表中，下次查询时直接使用缓存，节省网络资源。这个过程就好比： 1.A想要知道B的MAC地址，其首先会向周围所有网络设备广播如下内容： IP是A的设备要想知道IP是B的设备的MAC地址，你们谁知道，请发给我？ 2.M，N，P，Q可能都收到了此询问请求，M发现自己知道B设备的MAC地址，因此会回给A： IP是A的设备，我要将IP是B的设备的MAC地址发给你，请接收。 3.A设备收到M设备的返回后，拿到自己想要的MAC地址，之后组装链路层数据帧进行发送。 通过上面的过程你也可以发现，其实ARP本身并不是一个安全的协议，任何设备在接收到广播后都可以编造一个MAC地址进行返回，从而产生ARP欺诈风险，但这也并非完全无法防范，比如使用指定的安全的ARP服务器，建立静态的IP-MAC映射表等，我们这里不再讨论。 3. 分析下ARP协议在访问网页时，你的设备可能随时会发起ARP请求和接收ARP响应，我们可以先抓一个ARP协议的请求和返回数据来简单看下ARP协议的结构，如下图： 如图中所示，抓到了两条ARP协议数据，其中第一条为ARP请求报文，第二条为ARP响应报文。可以看到请求报文的目标地址是广播地址，报文内包含硬件类型，协议类型，ARP类型，源MAC地址，源IP地址和目的IP地址。如果是响应报文，则其中还会包含目的MAC地址。相比较我们前面介绍的应用层的协议，ARP协议非常简单（越底层通常越简单与专注），协议格式如下： 其中，ARP首部占了8个字节： 前2个字节指定了硬件的类型，即链路层的协议，一般为1，表示以太网。 第3和第4个字节指定了所使用的协议类型，其中0x0800表示IPv4协议。 第5个字节表示链路层协议的地址长度，比如MAC地址长度为6个字节，这里的值是6。 第6个字节表示所使用的协议地址长度，比如IPv4的长度为4个字节，，则这里的值是4。 第7和第8个字节是Opcode码，是一个ARP操纵码，1表示ARP请求，2表示ARP响应。 ARP协议的首部是固定的，数据部分是可边长的，依次排布着源链路层地址，源逻辑层地址，目标链路层地址和目标逻辑层地址。 ARP协议本身简单，这里就不再过多阐述，还有一个与之对应的RARP协议，此协议是将MAC地址解析为IP地址，作用与ARP刚好相反，有兴趣的话，你也可以研究下。 三. 以太网链路层Ethernet Ⅱ帧最后，我们再简单了解下Ethernet Ⅱ帧的相关内容，其实拿到MAC地址后，网络传输整体架构中有关逻辑的部分就完全结束后，后面就是向数据包前拼装上链路层协议的相关数据，组装成Ethernet Ⅱ帧进行发送。从抓包工具可以看到，这一层只是向头部拼接了目标MAC地址，源MAC地址和所使用的网络层协议。有时候，在数据的最后也会加上数据帧校验序列，如下图： 在底层的原理，我们这里就不再深究了。本系列博客也将暂时告一段落，希望能对你有所帮助。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ：316045346 同时，如果本篇文章让你觉得有用，欢迎分享给更多朋友，请标明出处。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"http://huishao.cc/categories/网络技术/"}],"tags":[],"keywords":[{"name":"网络技术","slug":"网络技术","permalink":"http://huishao.cc/categories/网络技术/"}]},{"title":"自上而下的理解网络（5）——IP篇","slug":"443自上而下的理解网络（5）——IP篇","date":"2022-02-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.397Z","comments":true,"path":"2022/02/27/443自上而下的理解网络（5）——IP篇/","link":"","permalink":"http://huishao.cc/2022/02/27/443自上而下的理解网络（5）——IP篇/","excerpt":"","text":"自上而下的理解网络（5）——IP篇本系列博客到此，在理解网络这一专题中，我们已经走过了不短的路程。你或许已经发现了，由于网络分层模型的存在，每一层都有明确的任务和目的，使得每一层的工作都不太复杂，上层也不需关心下层的实现方式，整个网络结构有了更强的灵活性与扩展性。在上一篇中，我们介绍了TCP协议，这种可靠的传输协议保证了将应用层的数据准确无误的传输到目的端。从网络模型上看，TCP属性传输层的协议，传输层的TCP协议数据最终会被组成成IP数据报，开始进入真正的数据发送。本篇文章，我们将进入网络世界最核心的部分：网络层。对IP协议进行介绍。 一.谈谈IP协议IP是一种定义了网络之间如何互联的协议，是TCP/IP协议簇中的核心协议。和传输层的TCP协议相比，IP协议的最大特点是不可靠且无连接。所谓不可靠，是指IP协议并不能保证IP数据报可以成功的到达目的端，数据传输中间发生任何错误，此数据报都会被丢弃掉。无连接是指IP并不会维护任何与数据报相关的连接信息，每次数据传输都是独立的，每个数据报的路由选择也都是独立的，因此IP数据报的到达顺序也是无序的。 首先，我们可以先随便看一个网络通信过程中IP层的数据报样子，如下图所示： 我们知道，在网络模型各层中，下层协议将上层数据拿到，并且拼接上本层协议头部信息作为完整数据报传递再传递给更下层处理。上图示例的即是IP层数据头的部分字段。可以看到，我们平时使用HTTP/HTTPS等应用层协议来进行通信时，是根据域名中的路径来处理业务逻辑的，而之下的TCP协议又是根据端口号来区分应用的，到了IP协议这一层，已经没有任何域名和端口号的概念，其提供的就是端到端的网络通信功能。 1.IP数据报的头部组成IP协议的结构定义如下图所示： 可以看到，对于IP数据报来说，如果其首部没有特殊的配置选项，则其固定为20个字节长度。 第0到3位：标记了所使用的IP协议的版本，如果使用的是ipv4版本则此值为4，如果使用的是ipv6版本，则此值是6。 第4到7位：记录了IP数据报头部的长度为多少个32位的数据。 第8到15位：标记了服务的类型，会表明最小时延和最大吞吐量信息。 第16到31位：这16位数据记录了标记了整个IP数据报的总长度（字节），包括头信息和数据信息，由于其只有16位，因此其最大值为65535，一个IP数据报最大的长度为65535字节。 第32到47位：此16位数据是一个作用类似与id的标识字段，当发生了数据报分段时，此字段的值被复制到所有的分段之中，帮助接收端集中处理。 第48到50位：这3位是3个标记位，其中第1位是保留位，目前没有使用。第2位表示数据报是否可以进行分段，如果设置为1表示机器不能将此数据报进行分段。最后1位表示当前数据报是否是最后一个分段，如果存在下一个分段，则此位设置为1，否则设置为0。 第51到63位：这13位指出了分段数据在源数据报中的相对位置，如果没有分段，则此值为0。 第64到71位：生存时间字段，这个字段是一个简单的计数器，表明了数据报可以经过的最多路有数，数据报一旦经过一个路由器的处理，此值就会减少1，当值为0时，此数据报会被丢弃。 第72到79位：此字段指出了IP处理完数据后，使用什么协议来解析数据，其取值范围为0到255之间，其中常见的如1为ICMP空值协议，6为TCP协议，17为UDP协议等。 第80到95位：这个字段为投不校验和字段，占有16位，用来验证IP数据报头部的完整性。 第96到127位：这32位数据记录了源主机的IP地址。 第128位到159位：这32位数据记录了目标主机IP地址。 需要注意，上面的分析是以ipv4版本为例的，对于ipv6协议，头信息的字段意义会有一些变动，例如其源地址和目的地址都扩展为了128位。 2.IP路由选择的策略了解了IP数据报组成的基本情况，下面我们该来思考下具体网络通信的实现方式了。这就会涉及到IP路由选择的相关内容。其实，IP路由选择并没想象的那么复杂，虽然世界上网络本身错综复杂。我们可以这样来思考：任何一台设备要接入网络，都要由链路层真正的连接进网络中，以个人PC为例，一定要使用有线或无线的方式接入到互联网中，我们才能与这台PC通信。因此，如果目的主机与源主机是直接相连的，则IP数据报会从源主机直接发送到目的主机上，这没有任何难以理解的地方。略微复杂一些的地方在于，如果源主机与目的主机不是直接相连的，则此IP数据报需要做选路逻辑，简述其过程如下： 1. 源主机搜索本地路由表，寻找目的IP所在的网络，如果找到就发送给此网络，没有找到会发送给路由表配置的default地址。 2. 接收到IP数据报的设备可能是一台主机，也可能是路由器设备（其实主机也可以配置路由器功能），其首先会判断IP数据报中的目的地址是否是本机IP或者是广播地址，如果是，则解析数据报进行处理，如果不是，则表明此数据报需要被转发。如果当前设备是普通的主机，没有路由功能，则此数据报会直接被丢弃。如果当前接收的设备是路由器，则会搜索自己的路由表，执行与过程1类似的行动，将数据报转发出去。当前，转发前其也会检查数据报的生存时间是否正常。 3. 下一跳的接收设备按照步骤2进行重复，直到数据到达目的主机，或转发次数超出数据报生存时间。 上面有提到路由表，路由表是IP层维护的一份路由信息，路由表中的每一项记录都包含4个字段，分别为： 目的IP地址：此项即可以是一个完整的主机地址，也可以是一个网络地址。 下一跳IP地址：数据要被转发到的地址。 标志字段：指定此条记录中的目的IP地址是网络地址还是主机地址。也用来指明下一跳IP地址是一个路由器还是一个直接相连的接口。 传输指定的网络接口：传输数据报指定的网络接口。 如果你使用的Mac电脑，则可以在终端输入如下命令来打印本机路由表： 1netstat -nr 输出信息示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Routing tablesInternet:Destination Gateway Flags Netif Expiredefault 192.168.1.1 UGScg en0 10.8/24 10.8.0.2 UGSc utun0 10.8.0.2 10.8.0.1 UH utun0 127 127.0.0.1 UCS lo0 127.0.0.1 127.0.0.1 UH lo0 169.254 link#6 UCS en0 !192.168.1 link#6 UCS en0 !192.168.1.1/32 link#6 UCS en0 !192.168.1.1 8c:73:a0:ef:e8:11 UHLWIir en0 1174192.168.1.3/32 link#6 UCS en0 !192.168.1.3 88:66:5a:b:69:2b UHLWI lo0 224.0.0/4 link#6 UmCS en0 !224.0.0.251 1:0:5e:0:0:fb UHmLWI en0 239.255.255.250 1:0:5e:7f:ff:fa UHmLWI en0 255.255.255.255/32 link#6 UCS en0 !Internet6:Destination Gateway Flags Netif Expiredefault fe80::1%en0 UGcg en0 default fe80::%utun1 UGcIg utun1 default fe80::%utun2 UGcIg utun2 default fe80::%utun3 UGcIg utun3 default fe80::%utun4 UGcIg utun4 default fe80::%utun5 UGcIg utun5 default fe80::%utun6 UGcIg utun6 ::1 ::1 UHL lo0 2409:8a1e:2147:e770::/64 link#6 UC en0 2409:8a1e:2147:e770:1e:db2d:96a4:cf35 88:66:5a:b:69:2b UHL lo0 2409:8a1e:2147:e770:a823:bf83:873f:1241 88:66:5a:b:69:2b UHL lo0 fe80::%lo0/64 fe80::1%lo0 UcI lo0 fe80::1%lo0 link#1 UHLI lo0 fe80::%en5/64 link#4 UCI en5 fe80::aede:48ff:fe00:1122%en5 ac:de:48:0:11:22 UHLI lo0 fe80::aede:48ff:fe33:4455%en5 ac:de:48:33:44:55 UHLWIi en5 fe80::%en0/64 link#6 UCI en0 fe80::1%en0 8c:73:a0:ef:e8:11 UHLWIir en0 fe80::1cb4:b83d:af72:eebe%en0 88:66:5a:b:69:2b UHLI lo0 fe80::%awdl0/64 link#7 UCI awdl0 fe80::7c27:deff:fe56:fc75%awdl0 7e:27:de:56:fc:75 UHLI lo0 fe80::%llw0/64 link#9 UCI llw0 fe80::7c27:deff:fe56:fc75%llw0 7e:27:de:56:fc:75 UHLI lo0 fe80::%utun1/64 fe80::1f51:69aa:bba3:107%utun1 UcI utun1 fe80::1f51:69aa:bba3:107%utun1 link#15 UHLI lo0 fe80::%utun2/64 fe80::d0d1:ddd2:5699:a7eb%utun2 UcI utun2 fe80::d0d1:ddd2:5699:a7eb%utun2 link#16 UHLI lo0 fe80::%utun3/64 fe80::24c9:ab2d:b06c:ee2b%utun3 UcI utun3 fe80::24c9:ab2d:b06c:ee2b%utun3 link#17 UHLI lo0 fe80::%utun4/64 fe80::aa3:5b6:85:9502%utun4 UcI utun4 fe80::aa3:5b6:85:9502%utun4 link#18 UHLI lo0 fe80::%utun5/64 fe80::383a:6846:f4a5:7d30%utun5 UcI utun5 fe80::383a:6846:f4a5:7d30%utun5 link#20 UHLI lo0 fe80::%utun6/64 fe80::7017:7a51:2293:202%utun6 UcI utun6 fe80::7017:7a51:2293:202%utun6 link#21 UHLI lo0 ff00::/8 ::1 UmCI lo0 ff00::/8 link#4 UmCI en5 ff00::/8 link#6 UmCI en0 ff00::/8 link#7 UmCI awdl0 ff00::/8 link#9 UmCI llw0 ff00::/8 fe80::1f51:69aa:bba3:107%utun1 UmCI utun1 ff00::/8 fe80::d0d1:ddd2:5699:a7eb%utun2 UmCI utun2 ff00::/8 fe80::24c9:ab2d:b06c:ee2b%utun3 UmCI utun3 ff00::/8 fe80::aa3:5b6:85:9502%utun4 UmCI utun4 ff00::/8 fe80::383a:6846:f4a5:7d30%utun5 UmCI utun5 ff00::/8 fe80::7017:7a51:2293:202%utun6 UmCI utun6 ff01::%lo0/32 ::1 UmCI lo0 ff01::%en5/32 link#4 UmCI en5 ff01::%en0/32 link#6 UmCI en0 ff01::%awdl0/32 link#7 UmCI awdl0 ff01::%llw0/32 link#9 UmCI llw0 ff01::%utun1/32 fe80::1f51:69aa:bba3:107%utun1 UmCI utun1 ff01::%utun2/32 fe80::d0d1:ddd2:5699:a7eb%utun2 UmCI utun2 ff01::%utun3/32 fe80::24c9:ab2d:b06c:ee2b%utun3 UmCI utun3 ff01::%utun4/32 fe80::aa3:5b6:85:9502%utun4 UmCI utun4 ff01::%utun5/32 fe80::383a:6846:f4a5:7d30%utun5 UmCI utun5 ff01::%utun6/32 fe80::7017:7a51:2293:202%utun6 UmCI utun6 ff02::%lo0/32 ::1 UmCI lo0 ff02::%en5/32 link#4 UmCI en5 ff02::%en0/32 link#6 UmCI en0 ff02::%awdl0/32 link#7 UmCI awdl0 ff02::%llw0/32 link#9 UmCI llw0 ff02::%utun1/32 fe80::1f51:69aa:bba3:107%utun1 UmCI utun1 ff02::%utun2/32 fe80::d0d1:ddd2:5699:a7eb%utun2 UmCI utun2 ff02::%utun3/32 fe80::24c9:ab2d:b06c:ee2b%utun3 UmCI utun3 ff02::%utun4/32 fe80::aa3:5b6:85:9502%utun4 UmCI utun4 ff02::%utun5/32 fe80::383a:6846:f4a5:7d30%utun5 UmCI utun5 ff02::%utun6/32 fe80::7017:7a51:2293:202%utun6 UmCI utun6 上面的路由表中包含了ipv4和ipv6的路由记录，我们先只关心ipv4的。可以看到，第一条记录的目的地址及是default，我当前设备上几乎所有的网络通信都会命中这条路由信息，其对应的下一跳地址为192.168.1.1，这正是我路由器的地址，因此可以看到，对于个人电脑，网络的访问大都是通过路由器完成的转发（与网线直连的设备这里会有不同）。 对于路由表中的Flags字段，我们还可以再深入的了解一下，其共有5种标记可以配置，且可以聚合，标记列举如下： U：此标记表示该条路由记录可用。 G：表示该路由连接的是一个网关（路由器），如果没有该标记，则表示是直连。 H：表示该路由的目的地址是一个主机。如果没有该标记，表示目的地址是一个网络。 D：表示该路由是由重定向报文创建的。 M：表示该路由被重定向报文创建。 从路由转发的方式上我们也可以明白，IP的路由选择是逐跳进行的，无论是再哪个过程设备上，IP层都是无法知道完整的路由路径的（除非是源主机与目的主机直连的）。在IP数据报转发时，我们只能认定下一站路由是比当前主机更加接近目的主机的。 3.关于IP编码现在，我们再来一起回顾下IP地址的编码方式。首先，我们此次讨论的都是ipv4，，每个IP地址都包含网络号和主机号，同一个网络上的所有主机网络号都相同。为了方便适配不同容量的网络，IP地址被分为了5类。 A类：IP地址范围从1.0.0.1 - 127.255.255.254 对于A类地址来说，第一段号码为网络后，其后三个号段为主机号，因此其可分配的网络数非常少，只有126个，每个网络可以分配的主机数非常多，有16777214个。 B类：IP地址范围从128.0.0.1 - 191.255.255.254 B类地址的前两段为网络号，后两段为主机号。B类地址可以分配16384个网络，每个网络可以分配65534个主机。 C类：IP地址范围从192.0.0.1 - 223.255.255.254 C类地址中前三段为网络号，最后一段为主机号，因此其可以分配的网络数为2097152个，每个网络可以分配的主机个数为254台。 D类：IP地址范围从224.0.0.0 - 239.255.255.255 D类IP地址为组播地址。 E类：IP地址范围为240.0.0.0 - 255.255.255.255 此类为保留地址，留待特殊用途。 如果你在百度中输入IP地址，可以看到当前电脑所接入的网络被分配的IP，如下图所示： 除了上面提到的IP地址外，还有一些特殊的IP地址，比如0.0.0.0对应当前主机。255.255.255.255是当前子网的广播地址。127.0.0.1到127.255.255.255.255这些地址都是用来做回路测试的，例如127.0.0.1也可以代表本机IP。 其实，对于主机号，在应用的时候也可以将其拆为子网号和主机号，因此通过IP地址加上一个子网掩码，即可将IP地址分为网络号，子网号和主机号。 二.关于ICMP协议通过前面的介绍，我们知道IP协议是通过路由的方式一跳一跳的将数据发送到目的端，但是并不是所有发送过程都是没问题的，实际上会发生异常的概率还不小。此时发生问题的路由器或主机将通过ICMP协议来将重要信息返回给源主机。 ICMP协议被认为是IP层的组成部分之一，我们依然将其理解为是网络层的协议。ICMP协议是基于IP协议的，ICMP协议的全名为Internet Control Message Protocol，即Internet控制报文协议。其在IP主机，路由器等设备之前传递控制消息，主要包括网络是否连通，主机是否可到达，路由是否可用等信息。 1.ICMP的报文格式ICMP的报文格式如下图所示： 可以看到，ICMP报文的前4个字节是固定的。 第0到第15位：标识ICMP类型和对应的code码。其中前8位标识类型，后8位标识code码。 第16到31位：包含了正哥ICMP数据报的校验和，与IP头部的校验和作用一样。 其他位的数据格式并不统一，会根据ICPM报文类型的不同而有所差异，总之，type和code最终会确定ICMP报文的完整格式。 2.ICMP协议的类型下图完整的列举了ICMP报文所定义的类型： 可以看到，ICMP报文会在IP服务产生错误的时候将异常信息回执给源主机，但是，为了避免网络风暴的产生，并非所有异常都会产生ICMP回执，下面几种场景不会发送ICMP数据报： 1.ICMP本身的IP层错误。 2.目的地址是广播或多播地址的IP报。 3.作为链路层广播的数据报。 4.不是IP分片的第一片的数据报。 5.源地址是零地址，回环地址，广播地址或多播地址的数据报。 3.ICMP的应用ICMP是IP层必不可少的功能协议，其除了用来协助IP层处理相关逻辑外，在网络嗅探方面也有很大的应用。 1.Ping工具在前面的ICMP类型表中，有一项type为8，code为0的ICMP类型，其表示进行回显请求，即我们使用此格式的ICMP报文发送给目的主机后，要求主机将发送的数据再回发给我们。这一功能非常有用，我们可以使用它来测试目的主机是否是可达的。平时常用的Ping工具就是基于这种原理实现的。 我们可以先来体验下，可以在终端输入如下指令，发起ping请求： 1ping huishao.cc 上面指令的功能是对域名huishao.cc进行ping测试，一次完整的ping测试会产生两个ICMP数据包，一个是请求的，一个是回显的，如下图所示： 通过请求和回执的时间戳，我们可以计算出网络传输中的耗时情况，从而分析网络稳定性。 2.traceroute工具前面我们提到过，IP层中的任何一个中间设备，也包括起始设备，都不知晓完整的路由链路，有时候为了分析问题，我们需要获取网络通信中一个IP数据包在传输过程中每一跳的处理情况，这时也可以通过ICMP协议完成。你应该还记得，IP协议头中有一个标记生命时间的字段，每个中间路由器处理IP数据报后，都会将这个字段的值减1，当其为0时，路由器则不再转发，直接返回一个type为11，code为0的ICMP数据报。我们可以通过运用这一特新，依次向目标主机发送TTL递增的IP报文，从而探测从源主机到目的主机间所有路由过程。 例如在终端输入如下指令： 1traceroute huishao.cc 通过Wireshark工具的抓包，可以看到TTL递增的IP报文与对应的ICMP回执，如下所示： 可以看到，traceroute程序发起的探测包里实际是UDP格式的数据，对应的ICMP数据包中会将当前对应的IP数据头和UDP数据。 三.结尾本系列博客，核心的目的是能够直观的自上而下的理解网络。以平时最常用的网站访问开始，我们了解了域名解析的DNS协议，处理应用数据的HTTP以及更加安全的HTTPS协议，负责数据可靠性传输的TCP协议，以及本篇所涉及的网络层负责选路的IP协议。当然，文章所介绍的内容都只是起到抛砖引玉之效，其中每个细节点涉及的技术都可以扩展开来学习。目前对我们来说，整个互联网的架构正在逐步的变得清晰，但是还不完整，归根结底，网络的通信是要在实实在在的物理机上面进行，IP地址只是抽象的网络地址，那么网络设备是如何根据IP地址找到对应的物理机的？更多网络层的协议以及网络层之下又是怎样工作的，我们后面再聊！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ：316045346 同时，如果本篇文章让你觉得有用，欢迎分享给更多朋友，请标明出处。","categories":[{"name":"网络技术","slug":"网络技术","permalink":"http://huishao.cc/categories/网络技术/"}],"tags":[],"keywords":[{"name":"网络技术","slug":"网络技术","permalink":"http://huishao.cc/categories/网络技术/"}]},{"title":"自上而下的理解网络（4）——TCP篇","slug":"442自上而下的理解网络（4）——TCP篇","date":"2022-01-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.397Z","comments":true,"path":"2022/01/29/442自上而下的理解网络（4）——TCP篇/","link":"","permalink":"http://huishao.cc/2022/01/29/442自上而下的理解网络（4）——TCP篇/","excerpt":"","text":"自上而下的理解网络（4）——TCP篇本系列文章的主题是自上而下的理解网络，这里的之上而下，只要指的是基于HTTP的网络服务。我们只要从上之下的将这一过程理解透彻，对于其他的应用来说，只是协议不同，原理是相似的。通过本系列前面几篇博客的介绍，我们了解了在浏览器中输入一个域名或App通过一个域名访问后端服务接口时，域名会转换成IP地址，其实只有IP地址还不够，理论上还需要一个端口号用来确认服务主机上对应的应用程序。只是在实际的应用中，HTTP协议默认的端口号为80，HTTPS协议默认的端口号为443。 HTTP提供了应用层的数据定义结构（HTTPS又加入了安全性的保障），应用层的协议规范了不同设备，网络环境下的服务端与客户端的应用交互格式。现在，我们需要关心下这些应用数据是如何在两端间进行传输了。不知你是否还记得，我们之前有提到过网络的分层，下图描述了在TCP/IP协议簇中各个协议所属的网络层级： 可以看到，当应用层将应用数据组装好后，并不关心数据的传输，传输层来负责将数据传输到目标主机。HTTP是基于TCP的一种应用层协议，关于UDP，其与TCP还是有很大的差别，我们本篇博客暂不予讨论。 一.先空谈些理论关于TCP，大部分开发者或计算机专业的同学都不陌生，但是可能也仅仅处于只是不陌生的阶段，对其工作原理，协议内容都不甚明了。在分层网络模型中，每一层的协议都会再上一层数据的基础上增部分头信息，学习协议，其实就是学习这些头信息的意义和用法。 我最早了解到TCP是在学校的网络相关课程中，后来在工作中，重学计算机相关知识中每次也会遇到TCP相关的理论内容。几乎所有老师在介绍TCP时，都会先抛出如下定义： TCP是一种面向连接的，可靠的基于字节流的传输层通信协议。 这个定义中有一些关键字：面向连接，可靠的，基于字节流。面向连接和基于字节流是指什么？可靠性又是如何保障的？这正是本文要讨论的核心。 首先，我们先从理论上，对TCP做一些简单的介绍。 1.关于面向连接面向连接主要是指两个TCP的应用在彼此交换数据之前，都需要先建立一个TCP的连接，形象一些描述这就好比在客户端和服务端通信前先建立一条网络上的通道，之后的通信都基于这个通道进行。通道可以建立，那么同样也可以关闭，当两台通信的设备不再需要交互数据时，就可以关闭此TCP通道。后面我们将介绍连接是如何建立的又如何断开。 2.关于可靠性说到可靠性，是指上层业务无需关心数据发送过程中是否丢失了，对方是否确定完整的收到了等等。例如我们在发送HTTP请求和接收回执数据时，根本没有关心数据到达和完整性问题，只需要等待回执即可。这是因为传输的可靠性在TCP一层保证了。 TCP在发送应用数据时会将要发送的数据分成合适发送的数据块，分块进行发送。 当TCP发送了一段数据后，会等待目的端的确认收到报文，如果在一定时间内没有收到此报文，则会进入超时或重试逻辑，TCP通过确认报文来保证数据的到达可靠性。 TCP将维护一个端到端的数据校验和，用来检测在传输过程中是否产生了差错，如果发现了差错，TCP接收端将丢弃这个报文，并不发送确认报文，等待对方的超时或重发逻辑。 TCP是通过网络层的IP协议做数据传输的，IP数据报是有可能发生乱序的，因此TCP要对接收到的数据进行重排，将收到的数据以正确的顺序返回给应用层。 同样IP数据报也有可能会产生重复，TCP也会负责对重复的数据报进行去重。 最后，TCP也提供流量控制，增加传输可靠性。 3.关于基于字节流TCP在传输数据时，对应用层的数据不做任何解释，TCP也不再赢输数据字节流中插入任何标识符。这也就是说，TCP具体传输的是什么格式的应用数据在TCP层并不做解析，发送方发送的字节流数据也同样会在接收方完全相同的接收到，所有解释和理解都在应用层。 二.宏观的看TCP通信过程前面有提到，TCP在传输应用数据前首先需要建立连接，TCP建立连接的方式是通过3次通信完成，形象的被称为TCP的3次握手。 在TCP协议中，有一个Flags字段，这个字段将由始至终的贯穿我们理解TCP协议全部过程。此字段将表示当前TCP报文的类型，有如下6种： SYN:建立连接。 FIN:断开连接。 ACK:回执响应。 PSH:数据传输。 RST:连接重置。 URG:紧急指针。 这并不是说每个TCP的报文只能对应唯一的一个类型，Flags字段占6位的数据，每一位对应一个状态，报文状态是可以聚合的，比如一个TCP报文即标记是ACK由标记为PSH。通过聚合可以减少TCP报文数，提高传输效率。完整的TCP报文格式如下图所示： 完整的报文意义我们暂且按下不表，只看其中的Flags部分，可以看到它占了6位，第1位为URG位，最后一位为FIN位。 1.连接建立过程TCP通信是在网络两端间进行的，要建立连接，一端首先需要发起建连，在HTTP数据请求中，是由客户端首先发起建连。 第一步：由客户端发起SYN类型的TCP报，其中会指定目标服务器的端口号等数据。 第二步：服务端收到客户端的建连报文后，回复一个包含ACK和SYN的报文，表示收到客户端的建连请求，并且发起服务端的建连要求。 第三步：客户端收到服务端的响应报文后，再回一个ACK类型的报文表示收到，连接建立完成。 2.应用数据的发送过程连接建立完成之后，TCP的通信过程就变得相对简单。一方发送数据时，会发出类型的PSH的报文，另一方接收到后需要回复对应的ACK报文，如此循环往复，直到数据交互完成。 3.连接断开过程与连接的建立类似，断开连接也需要ACK进行确认。以HTTP请求为例： 第一步：当服务端发送完数据后，会首先发起FIN类型的报文来断开连接。 第二步：客户端收到服务端的FIN报文后，回复ACK。 第三步：客户端发送FIN报文来断开客户端连接。 第四步：服务端收到客户端的FIN报文后，回复ACK。 因此，TCP断开连接的过程也被形象的称为4次挥手。 三.深入理解下TCP的工作流程现在，虽然宏观上我们对TCP的通信过程有了大致的概念，但还是太肤浅了，许多核心点我们都还没有涉及。比如时序，可靠性，TCP首部字段意义等。本节也详细讨论下这部分内容。 1.TCP报文首部详解回到上面的那张TCP报文图示。下面我们来详细介绍下。 Source Port：源端口，占16位（两个字节），这个字段很好理解，即发出此报文的端口。 Destination Port：目的端口，占16位（两个字节），即要接收此报文的端口。 Squence Number：序列号，占32位，TCP是基于字节流传输的，这个序列号用来标识当前报文中第1个数据字节的编号，使用此序列号对发送的字节进行计数，贯穿整个通信过程。后面会详细介绍。 Acknowledgment Number：Ack序列号，占32位，表示发送ACK的一方期望接收的下个数据字节的编号。 Data Offset：数据偏移量，占4位，也可以理解为TCP头部的长度，用来标记数据配置。其表示TCP头部占了多少个4字节。由于4位的最大数为15，所以TCP报头的最大长度为4*15=60个字节。 Reserved：预留字段，长度为6位。 Flags：类型字段，占6位。从低到高依次表示FIN，SYN，RST，PSH，ACK，URG。 Window：占16位，表示滑动窗口的大小，用来告诉发送端接收端的缓存大小。达到流量控制，最大值为65535。 Checksum：校验和，占16位，用来校验TCP头信息传输过程中是否出错。 Urgent Pointer：紧急指针，类型为URG报文有效，表示第一个紧急数据字节所在位置。 Options-Padding：额外选项，长度可变，当不足32位的倍数时，使用0补齐。 Data：长度可变，传输的上层数据，可以为空。 2.时序是如何保障的保障时序是TCP可靠性的重要目标。时序的保障主要是通过TCP报文头中的SN（序列号）和AN（Ack序列号）保障的。 我们先来看SN，SN是一个相对的概念，在一个TCP连接要建立时，客户端发起的第一个SYN报文会被分配一个SN序号，这个序号为初始化序号，之后在本次TCP通信中，我们都将以这个初始化序号为标准来计算相对SN。需要注意，SYN报文也会占据一个SN序号，下次发送数据时，SN序号会被加1。 我们再来看AN，AN表示我预期要接收的下一个数据的SN号，当接收到收到了发送端的数据后，会回执Ack类型的报文，并将AN设置为发送端配置的SN号加1。 通过SN和AN，简化的通信过程如下图所以： 此图看上去是有一些绕，多分析几遍，你会对TCP的原理有相对透彻的理解。 3.有关可靠性的一些其他技术手段超时与重试 在一切顺利的情况下，TCP建连只需要3步即可完成。但是事实上，现实中的网络环境要复杂的多，建连并不总是顺利的。 一种情况是客户端要连接的端口在服务端并没有监听，此时服务端主机TCP服务会直接回执一个RST类型的报文，表示连接出错，此时发起方应直接关掉连接。 另一种情况是服务端主机处于异常状态，可能网络出现的问题，此时发起方无法等到服务端的任何回执，此时会进入TCP的建连超时逻辑，TCP的第一次建连重试会在超时约6秒时触发，第二次重试会在间隔大约24秒后触发，第三次重试会在间隔大约76秒后触发。具体遵循的超时重试算法我们这里不再展开。 RST类型的复位报文 有许多场景可能触发RST复位报文，一种是我们访问了无效端口时，服务端会返回RST报文。 另一种场景是如果连接已经被关闭，再次通过此连接发送数据，会收到RST的复位连接。这种场景很常见，例如一端由于某些原因已经重新启动，此时另一端并不知道对端发生了异常，再用旧的连接发送数据时就会收到RST报文。 四.从实践中验证理论说了这么多理论，理论部分我们已经介绍了很多，足够理解TCP的通信过程。下面我们可以通过实践来验证下。 首先可以本地编写两个简单的Socket服务端与客户端程序。关于示例程序，我们在前面的HTTP一文中已经有介绍，直接使用之前的那些示例程序即可。使用Wireshark抓取本地的TCP报文，客户端与服务端完整的TCP通信报文如下图所示： 我们程序所编写的业务逻辑如下： 1.客户端端口号为52079。 2.服务端端口号为9001。 3.由客户端先发起TCP建连。 4.由客户端发送”TCP Customer“数据到服务端。 5.服务端接收到客户端发送的数据后，发送”Hello World“数据给客户端，之后发起关闭连接。 6.客户端收到服务端返回的数据后，关闭连接。 在这一通信过程中，产生了12个TCP报文，我们可以逐个分析下。 第1个报文数据如下： 可以看到，此报文是SYN类型的建连报文，由客户端发起，SN为3069091127，AN为0。除了一些选项之外，没有包含任何业务数据。 第2个报文数据如下： 此报文是由服务端发起的Ack报文，同时也是服务端的SYN建连报文。此报文的AN为3069091128，SN为3416281738。 第3个报文数据如下： 此报文由客户端发出，类型为ACK，SN为3069091128，AN为3416281739。可以看到SN已经增加了，与第2个报文的AN是对应的。 第4个报文数据如下： 此报文类型为ACK，它是一个特殊的报文，可以看到其有服务端发送给客户端，Window字段值为6379，这个报文的用途是指定缓存大小。此报文的AN为3069091128，SN为3416281739。SN与第3个报文的AN相对应。 第5个报文数据如下： 此报文由客户端发出，类型为PSH，即它是一个数据传输报文，也可以看到，其内容带了12个字节的业务数据，这12个字节的数据即是”TCP Customer“。SN为3069091128，AN为3416281739。 第6个报文为： 此报文为服务端发出的ACK报文，用来确认客户端发出的12个字节的数据，其AN为3069091140，SN为3416281739。 第7个报文如下： 可以看到，这第7个报文即是服务端主动给客户端发的数据报文，其数据部分长度为13个字节，即”HelloWorld!\\r\\n”。其AN为3069091140，SN为3416281739。 第8个报文如下： 此报文为客户端回执的ACK报文，SN为3069091140，AN为3416281752。 第9到第12个报文为TCP断开连接的4个报文，SN与AN的逻辑与建连类似，这里不再分析。 五.结尾你可能发现了，除了初始建连报文，每个TCP报文都有ACK类型，这是因为ACK位都被置为1并无额外的数据和性能消耗。其实本文只是从理解层面介绍了TCP协议，若要将TCP讲完整，需要一本书的厚度也不为过。相信如果你之前对日常天天使用的网络技术并不理解，并且从本系列博客的首篇阅读到此，那么从应用上来讲，你一定有了更深一层的理解。后面我们将继续向下，讨论网络层的协议。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ：316045346","categories":[{"name":"网络技术","slug":"网络技术","permalink":"http://huishao.cc/categories/网络技术/"}],"tags":[],"keywords":[{"name":"网络技术","slug":"网络技术","permalink":"http://huishao.cc/categories/网络技术/"}]},{"title":"一起玩转树莓派（23）——DHT11温湿度传感器实践","slug":"441一起玩转树莓派（23）——DHT11温湿度传感器实践","date":"2021-12-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.397Z","comments":true,"path":"2021/12/25/441一起玩转树莓派（23）——DHT11温湿度传感器实践/","link":"","permalink":"http://huishao.cc/2021/12/25/441一起玩转树莓派（23）——DHT11温湿度传感器实践/","excerpt":"","text":"一起玩转树莓派（23）——DHT11温湿度传感器实践一. 引言DHT11是一款强大的复合传感器，支持环境温度和湿度的测量。其本身比较简单，但是由于其采用串行时序的方式进行数据读写，非常适合我们练习时序编程。本次实验我们使用的传感器模块如下图所示。 可以看到，此传感器模块有3个引脚，除了电源和接地引脚外，只有一个out引脚用来输出数据和传输控制指令。下面我们来介绍下如何使用此传感器模块。 二. 关于DHT11传感器模块由于DHT11传感器元件只有一个通信引脚，因此其输入和输出都需要使用同一个引脚。即此引脚是一个串行的单线双向引脚。所谓单线双向是指其只有一条信号传输线，但是可以双向通信。这有些像我们使用的对讲机，一方说话时另一方只能听。DHT11的完整使用手册地址如下： https://www.dfrobot.com.cn/image/data/DFR0067/DFR0067_DS_10.pdf 首先我们先来看DHT11所传输的信息数据的格式。根据文档介绍，DHT11一次完整的通信将传递40位数据，这40位数据包含了温度，湿度和用于校验正确性的数据。因此，我们在读取DHT11的数据时，要完整的读出40位数据后再进行计算。这40位数据的具体格式为： [8bit的湿度整数部分数据]+[8bit的湿度小数部分数据]+[8bit的温度整数部分数据]+[8bit的温度小数部分数据]+8bit校验数据 其中[8bit的湿度整数部分数据]与[8bit的湿度小数部分数据]与[8bit的温度整数部分数据]与[8bit的温度小数部分数据]的和结果应为8bit的校验数据，如果结果不等则表明此次获取的数据出现异常，应该抛弃掉重新获取。 从传感器拿到的数据格式本身比较简单，比较复杂的点在于其通信过程。整体来说，树莓派与DHT11传感器的通信过程分为3个阶段： 1. 树莓派发出开始信号，之后开始等待传感器模块的应答。 2.传感器模块收到树莓派发出的开始信号后，返回应答信号。 3.树莓派接收到应答信号后，开始进行40位数据的接收。 整体的通信过程手册中有提供一张示意图，如下： 通电后，传感器模块的总线将始终处于空闲状态或通信状态中的一种状态下。定义当空闲状态时，总线输入高电平。对于上面通信过程中的第1个阶段，树莓派先将总线电平拉低，且必须大于18毫秒以让传感器模块检测到此拉低的信号。之后树莓派再将总线拉高，表示树莓派已经发出了一次开始通信信号，1阶段结束。 传感器模块检测到树莓派发起的开始信号后，此时总线电平为被树莓派拉高状态。传感器模块通过总线发送80微秒的低电平信号，表示响应了树莓派的开始信号，之后传感器模块会将总线电平再拉高80微妙，提示树莓派准备开始接收数据，2阶段结束。 阶段1和阶段2的更详细示意图如下： 3阶段为传感器模块发送数据，树莓派接收数据的阶段。每一位数据的发送有0和1两种状态，传感器每发送50微妙的低电平信号即表示要进行1bit数据的传输，之后如果传感器发送了26微秒到28微秒的高电平，则表示发送数据位0，如果发送了70微秒的高电平则表示发送数据位1。之后再进行下一位数据的发送。在实际编程操作时，我们可能不太好精准的测量高电平的时间，但是由于数据位0和数据位1的高电平时间相差很多，我们可以通过测试循环变量的计数来大致得到一个传输数据0时的大致循环次数和传输数据1时的大致循环次数，通过循环次数来判断数据具体是0还是1。 数据位0的信号示意图如下： 数据位1的信号示意图如下： 需要注意，每次测量的时间间隔最好大于1秒，且上电后等待1秒稳定再进行测量。 如果没有接触过元件单总线时序编程，上面的文字描述，总的来说还是有些抽象，下面我们会通过代码来实践。 三. 连线编码DHT11传感器模块只有3个引脚，中间的out引脚我们可以选择任意一个树莓派额GPIO引脚来连接，这里我们选择物理编码为11的GPIO引脚。按照上面我们介绍的DHT11模块的使用方法，编写代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#coding:utf-8import RPi.GPIO as GPIOimport timeimport math# 使用物理编码为11的引脚做总线P = 11GPIO.setmode(GPIO.BOARD)print(\"开始进行DHT11测量数据获取\\n\")# 等待1s后再进行逻辑time.sleep(1)def readData(): print(\"readData\") # 先将总线引脚设置为输出模式 GPIO.setup(P, GPIO.OUT) # 将总线电平拉低，发出开始信号 GPIO.output(P, GPIO.LOW) # 手册要求至少保持18ms的低电平，我们这里保持20ms time.sleep(0.02) # 拉高电平 GPIO.output(P, GPIO.HIGH) # 之后将引脚设为输入模式，等待传感器响应 GPIO.setup(P, GPIO.IN) # 先等待80us的低电平信号 while GPIO.input(P) == GPIO.LOW: continue # 再等待80us的高电平信号 while GPIO.input(P) == GPIO.HIGH: continue # 开始接收数据 # 循环计数 i = 0 # 存放二进制位数据 data = [] # 存放中间数据 kdata = [] # 每次读取40位数据 while i &lt; 40: j = 0 # 50us的低电平表示准备传输一位数据 while GPIO.input(P) == GPIO.LOW: continue # 开始检测高电平的时间 while GPIO.input(P) == GPIO.HIGH: j+=1 if j &gt; 100: return [False, 0, 0] kdata.append(j) i+=1 print(\"--------临时数据----------\\n\") print(kdata) print(\"--------临时数据----------\\n\") # 开始整理数据 i = 0 while i &lt; 40: tmp = kdata[i] if tmp &gt; 7: data.append(1) else: data.append(0) i+=1 print(\"--------临时数据2----------\\n\") print(data) print(\"--------临时数据2----------\\n\") # 解析湿度整数部分 t1 = data[0:8] c1 = 0 i = 7 for n in t1: c1 += n * math.pow(2, i) i-=1 # 解析湿度整数部分 t2 = data[8:16] c2 = 0 i = 7 for n in t2: c2 += n * math.pow(2, i) i-=1 # 解析温度整数部分 t3 = data[16:24] c3 = 0 i = 7 for n in t3: c3 += n * math.pow(2, i) i-=1 # 解析温度整数部分 t4 = data[24:32] c4 = 0 i = 7 for n in t4: c4 += n * math.pow(2, i) i-=1 # 解析校验 t5 = data[32:40] c5 = 0 i = 7 for n in t5: c5 += n * math.pow(2, i) i-=1 # 进行校验 va = True print(\"c1:%d\\n2c:%d\\n3c:%d\\n4c:%d\\n5:%d\\n\"%(c1,c2,c3,c4,c5)) if c1 + c2 + c3 +c4 == c5: va = True else: va = False return [va, \"%d.%d\"%(c1, c2), \"%d.%d\"%(c3, c4)]while True: time.sleep(1) result = readData() if result[0]: hum = result[1] temp = result[2] print(\"当前环境湿度： %s %%, 当前环境温度：%s℃\\n\" % (hum, temp)) else: print(\"此次数据无效，已被丢弃\\n\") time.sleep(1) 上面代码中有比较详细的注释，有些地方我们还是可以再解释一下。首先，树莓派发出开始指令的过程比较简单，无需过多解释。麻烦之处在于循环40次来获取40位的二进制数据。在获取数据时，我们采用循环变量来记录高电平的时间比例，从而可以分析出传输的数据是0还是1。需要注意，不同的设备可能循环一次的时间并不完全相同，我们可以先测试下上面代码中kdata变量存储的数据，运行代码如下图： 可以看到，如果是传输数据0，循环计数基本是在3或者4。而如果传输的是数据1，则循环计数在11左右。代码中我们以7为分割，分析时，循环计数大于7时就认为当前传输数据1，否则为0。 获取到了完整的40位二进制数据后，将其转换为数值进行校验即可。最终代码运行效果如下图所示。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"自上而下的理解网络（3）——HTTPS篇","slug":"440自上而下的理解网络（3）——HTTPS篇","date":"2021-12-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.397Z","comments":true,"path":"2021/12/17/440自上而下的理解网络（3）——HTTPS篇/","link":"","permalink":"http://huishao.cc/2021/12/17/440自上而下的理解网络（3）——HTTPS篇/","excerpt":"","text":"自上而下的理解网络（3）——HTTPS篇本系列的前一篇博文中，我们介绍了一个很常用的应用层协议HTTP，在日常生活工作中，HTTP协议的应用可谓无处不在，我们浏览网页，我们使用手机App都离不开HTTP。通过前面的介绍，我们也理解了HTTP本质上只是客户端和服务端约定好的一套通信规则，使得客户端和服务端能够相互理解的进行交流。在互联网普及的前期阶段，网页主要用来展示公开的静态内容，HTTP协议并没有明显的缺陷。随着互联网的不断发展，互联网应用越来越个性化也原来越复杂，某些安全性问题就变得非常重要。HTTP向HTTPS演化就成了互联网应用的必经之路。 一.HTTP协议的安全性问题在解决问题之前，我们首先需要先发现问题。HTTP协议从根本上有如下3种安全问题： 1. 数据没有加密回忆下我们前面编写的建议的HTTP服务端与客户端程序，数据其实是明文传输的，HTTP协议本身没有涉及到数据加密的相关定义。因此我们的网络通信报文一旦为截获，用户的隐私就完全暴露了。而在互联网环境中，要截获数据实在是非常容易的一件事，运营商可以做到，代理服务器可以做到，数据传输中的各个路由节点设备也可以做到，甚至客户端的恶意程序也可以做到。想象一下，如果你使用的是一个网上银行的互联网应用，你的银行账号密码在互联网中被窥视的一清二楚，是不是一件非常恐怖的事情。当然，如果我们的客户端应用是配套的，我们也可以在HTTP协议之上约定一种加密算法，传输数据时服务端和客户端按照同样的规则加密解密来保证数据完全（实际上很多移动端应用的接口服务是这样做的）。但是这依然有很多问题，首先浏览器是第三方的，私有的加密协议无法用于浏览器应用，其次客户端的加密算法如果被破解，破解者就可以用同样的方式破解所有拦截到的数据，依然会产生安全性问题。 2. 无法验证对方的身份HTTP是基于TCP/IP协议的应用层协议，TCP协议要保证的是双方正确完整的传输数据，但是并不能验证对方的身份。例如我们在访问huishao.cc这个网站时，任何一个中间节点接收到此HTTP请求后都可以不转发而直接返回错误的数据，而客户端收到数据后，还认为是huishao.cc返回的，客户端根本无法判断返回数据的对方是谁，也无法知道返回的数据是否是真的。对应于银行业务，你的余额信息可能被任何中间人篡改，危害极大。同样，服务端在接收到客户端的请求时，也无法判断此客户端是否是正常合法的，这就可能造成任何伪装者只要截取了客户端的请求，就可以伪装成此客户端继续和服务端做更深入的通信。 3. 数据可能被篡改这一个问题实际上是数据完整性和一致性的问题。无论是客户端还是服务器，在数据发出后都会经过很多中间节点，任何一个节点都可能改动数据中的某些部分，而接受方是完全没有手段对数据是否已经被改动了做校验的，对于网页应用来说，一些恶意者可以拦截到数据后可以加入各种烦人的广告。更严重一些，拦截者可能改动某些重要数据使得客户端错误的理解了服务端的意图，而将客户端引入危害性更大的攻击网站或下载攻击代码。 二. 针对安全性问题的解决方案思考综上所述，HTTP协议在安全上有3种致命的缺陷，实际应用中，越来越需要一种更加安全，且完全兼容HTTP协议的新型通信方式。我们先来看如何解决这些安全问题。 1. 使用加密来保护明文内容对于明文传输数据的问题，我们想到的最简单的方式是对数据进行加密，如使用对称密钥加解密，流程如下： 这种对称密钥的加密方式有两个明显的问题，首先客户端与服务端使用的密钥相同，原理上用户A可以拿到密钥，攻击者B也有办法拿到此密钥，这样就失去了加密的意义。其次，即是服务端为每个客户端都分配不同的一套私钥对，维护起来是很困难的，而且客户端环境负责，在传输私钥的过程中攻击者也可能将私钥拦截，这样加密依然失去了意义。 既然对称加密有这样的问题，那么我们是否可以使用非对称加密呢，非对称加密流程如下： 在非对称加密中，密钥对分为公钥和私钥，顾名思义，公钥本身是可以公开的，所有客户端都可以得到，私钥是存在在服务器上的。相比对称加密，服务端的安全性要比客户端高很多，私钥相对是安全的。但是使用这种非对称加密的方式对数据进行保护也是有局限性的，如上图所示，在客户端发送数据给服务端时，攻击者没有服务端的私钥，此时无法解密数据。但是当服务端使用私钥加密信息后返回给客户端时，就可能被攻击者截获并使用公钥进行解密。 既然非对称加密和对称加密都无法完美的保护数据的安全，那么能否将其结合一下呢？在HTTPS的实现中，也确实是这么做的。流程如下： 非对称加密的主要问题是使用私钥加密的数据，任何拥有公钥的人都可以进行解密，我们只需要保证服务端回数据的时候不使用私钥进行加密即可。如上图所示，首先客户端使用公钥将要使用的加密算法，所使用的对称密钥加密后发送给服务端，中间节点没有服务端的私钥，无法获知客户端发送的密钥是什么。之后如果服务端同意此次协商，则使用客户端的对称密钥来加密回执数据，之后的数据通信都使用此密钥进行加密，攻击者无法解密。 好了，现在的加密方式看上去很好用，但是实际实施起来好像并不太容易，公钥如何正确的给到客户端，这又是一个棘手的问题。我们下面再看。 2. 如何验证对方的身份公钥之所以难以正确的给到客户端是因为在网络通信中，通信双方都无法验证对方的身份。例如服务端把公钥放到一个公开的网站上供客户端下载，可是客户端无法判断此网站是否真的是服务方官方的网站，此网站本身也可能已经被劫持，客户端将下载到攻击者提供的公钥。之后客户端所有的通信都将直接和攻击者进行，并且客户端还一无所知（钓鱼网站的攻击方式）。如果服务端在客户端发起会话时先将公钥发送给客户端，这同样不安全，中间节点可以直接截取服务端的公钥，将其替换成攻击者自己的公钥发给客户端。之后客户端发送的对称密钥将使用攻击者的公钥加密，攻击者可以拿到后续网络通信所使用的对称密钥，这时就更危险了，客户端和服务端都不知道自己发送的数据都被攻击者先获取到并解密成功，并且攻击者还在继续伪装成客户端/服务端与双方通信。 那么，有没有一种方式可以安全的获取服务端的公钥呢？这就需要我们解决双方身份验证的问题。而要解决身份认证的问题，本质是想办法将公钥与身份信息进行绑定，并且使其不可篡改。我们最直接的想法是对公钥也进行非对称加密，但是这样用来解密公钥的公钥如何保证正确给到客户端就又成了问题，就陷入了反反复复无穷已的逻辑循环。因此，要打破这个循环，我们就必须公认一些安全的公钥，对其进行信任。再举个例子，你要到银行取钱，必须要证明你是你，你可以说我妈可以证明我是我，但是又必须证明你妈是你妈，这样永远无法证明出你的身份真实。但是现实生活中我们不会遇到这样的困境，因为你可以使用身份证证明你是你，身份证是国家机关颁发的，所有社会机构都对其认可。将其类比到我们的网络通信场景中，各个端都需要一个证件来进行自我证明，这个证件就是证书。 证书的工作流程如下： 如上图中所示，在服务端向证书颁发机构申请证书时，需要将自己的加密公钥提交，此时证书颁发机构需要对申请者的身份进行保证，即申请者的是否是某个域名的真实运营者，验证无误后（这直接影响到证书机构的信誉，即生存底线）其使用自己的密钥对服务端的公钥进行加密，后生成证书给到服务端。证书本身是一个比较复杂的技术，其可以通过继承关系来进行有效性验证，这里我们不做过多介绍，我们只需要知道，用来解密证书的公钥一开始就已经集成进了客户端设备，当然客户端设备也可以根据需要来自己添加所信任的证书，这些客户端的证书中包含了域名信息以及对应的公钥。之后，每当客户端要与服务端发起通信时，服务端先把证书发给客户端，如果这中间有人拦截篡改，但其没有证书颁发机构加密时的私钥，篡改后的证书文件无法通过客户端的内置公钥解密，客户端会意识到遭到了攻击，中断请求即可。当客户端收到证书后，从本地找到受信任的与之配对的证书文件，用本地证书文件中的公钥来进行解密，解密成功后即可拿到正确服务端的公钥。 如此，通过证书我们解决了身份认证与防信息篡改的问题。下面，我们可以来理解HTTPS协议了。 三. HTTPS协议究竟是什么现在，我们已经有了解决HTTP安全的理论方法，说HTTPS是一种协议其实是一种误称，HTTPS的全称是Hyper Text Transfer Protocol over SecureSocket Layer，即安全套接字通道之上的HTTP协议。其本质是SSL（SecureSocket Layer）或TLS（Transport Layer Security）协议。TLS协议是SSL协议的一种升级版，本篇博客中我们以TLS为例来进行介绍，当使用其加密通信的数据格式是HTTP协议格式的时候，这种通信我们就称为HTTPS，同样，其他网络层应用协议也可以工作在TLS协议之上，例如使用TLS来使文件传输更加安全的FPTS。HTTP，TLS和HTTPS的关系如下： 下面我们来介绍TLS协议的工作方式，理解了TLS协议，HTTPS只是其传输的业务数据内容的格式是HTTP协议的而已。 1. TLS的工作流程根据我们前面的分析，客户端和服务端要安全的进行通信，需要3个部分： 客户端向服务端索要身份认证证书并验证和获取服务端公钥。 使用服务端公钥加密对话信息进行通信算法和密钥的协商。 使用协商出的算法和密钥进行数据通信。 其中前两步是TLS的握手过程，最后一步才是通信过程。我们先来看握手过程。 完成握手过程客户端和服务端间共需要4次通信。过程如下： 在握手过程中，首先由客户端发起ClientHello消息，此消息中会包含客户端支持的TLS协议版本号，一个客户端生成的随机数（后面生成密钥用），客户端支持的加密算法以及支持的压缩方法等。后面我们会具体介绍。 接收到客户端的ClientHello消息后，服务端会进行回应，此回应消息为SeverHello消息。SeverHello消息主要包含的内容有协商所使用的加密通信协议版本，一个服务端生成的随时数（后面生成密钥用），确认使用的加密方法以及服务端的证书。 客户端接收到服务端的SeverHello消息后，首先会验证服务端的证书，如果证书不是可信机构颁发的或者证书中的域名与实际访问的域名不一致，或者证书过期，客户端都需要中断此次通信（不同的浏览器可能实现不同，有些可能仅仅是警告用户不安全）。如果证书验证通过，则客户端会提取出服务端的公钥。发送回应信息给服务端，回应信息将包含一个使用服务端公钥加密的随机数，编码改变的通知，表示之后和服务端的通信将使用双方协定好的加密方法和密钥进行通信。以及客户端握手结束的通知，这时客户端会将前面所有发送内容的Hash值发给服务端，供服务端来校验中间是否有篡改。当然，如果服务端也需要验证客户端你的身份，在这一步的时候客户端也会将证书发给服务端。 最后，服务端会再次发回应消息给客户端。回应消息包括编码改变通知，表示随后发送的信息将用双方协定的加密方法和密钥进行加密。服务端也会发送服务端握手结束通知，之后客户端和服务端的数据通信将进入加密通信，原始数据的格式有HTTP是完全一致的。 2. 关于TLS的协议内容TLS的握手过程的实现主要是通过如下4种类型的子协议实现的： TLS Handshaking protocols握手协议 Alert Protocol警告协议 Application Data Procotol应用层数据协议 Change Cipher Spec Protocol密码切换协议 每个TLS协议有消息都有消息头和消息体组成，消息头是固定的，长度为5个字节40位。 消息头的第1个字节描述的是消息体的类型，枚举如下： | 类型 | 值 || 密码切换协议 | 0x14 || 警告协议 | 0x15 || 握手协议 | 0x16 || 应用程序数据协议 | 0x17 | 第2和第3个字节用来描述当前使用的TLS的版本号。 第3和第5个字节用来描述当前消息的长度，长度会包含头信息。 在头信息结束后，即是具体的消息体内容，根据不同的协议类型消息体内容不同。 握手类型的协议： 一般，一次成功的TLS握手需要客户端和服务端交互两次。握手的主要作用是协商出客户端和服务端任何的加密方法和密钥。握手类的消息由3部分组成，分别为子类型，子消息长度和具体的子消息体。 子消息类型占1个字节，枚举如下： | 类型 | 值 || HELLO_REQUEST | 0x00 || CLIENT_HELLO | 0x01 || SERVER_HELLO | 0x02 || CERTIFICATE | 0x0B || SERVER_KEY_EXCHANGE | 0x0C || SERVER_DONE | 0x0E || SERVER_REQUEST | 0x0D || CERTIFICATE_VERIFY | 0x0F || CHIENT_KEY_EXCHANGE | 0x10 || FINISHED | 0x14 | 在具体执行的时候，多条子消息可能封装进同一条TLS消息中，交给TCP层处理发送。 警告类型的协议： 在握手过程中可能会产生异常，例如客户端的加密算法服务端无法支持时，可以直接回执警告类型的子协议，警告类型的消息格式是固定的，由两个字节组成，第1个字节描述警告的等级，第2个字节描述警告的原因。 警告类型的枚举有： | 等级 | 值 || warning | 1 || fatal | 2 | 警告原因的枚举有： | 原因 | 值 || close_notify | 0 || unexpected_message | 10 || bad_record_mac | 20 || decryption_failed_RESERVED | 21 || record_overflow | 22 || decompression_failure | 30 || no_certificate_RESERVED | 41 || bad_certificate | 42 || unsupported_certificate | 43 || certificate_revoked | 44 || certificate_expired | 45 || certificate_unknown | 46 || illegal_parameter | 47 || unknown_ca | 48 || access_denied | 49 || decode_error | 50 || decrypt_error | 51 || export_restriction_RESERVED | 60 || protocol_version | 70 || insufficient_security | 71 || internal_error | 80 || user_canceled | 90 || no_renegotiation | 100 || unsupported_extension | 110 | 密码切换协议: 密码确认协议就是我们前面所说的客户端和服务端的确认回应信息，这个消息一旦发出，表示后续的通信都将可以在加密层进行了。 应用层数据协议: 这一协议的作用就是对上层的应用层协议数据进行一层加密保护后在进行传输。 3. Client Hello子消息详解当客户端要和服务端简历TLS通信时，最先发出的就是客户端的Clent Hello消息。此消息包含如下信息： client_version：客户端支持的最高的TLS协议版本号。 random：客户端生成的随机数。 sessionID：会话的id，可用于恢复会话。 cipher_suites：客户端发送所支持的密码套件列表。 compression_methods：客户端支持的压缩方法。 extensions：扩展内容，TLS协议支持方便的进行扩展，可以有多个扩展数据。 我们可以使用Wireshark来监听TLS的协议数据，Client Hello消息结构如下所示： 4. Server Hello子消息详解Server Hello消息的主要作用是根据客户端支持的密码套件来选择一个双方都满意的密码套件，Server Hello包含如下信息： server_version：服务端最终选择使用的TLS协议版本号。 random：服务端生成的随机数。 session_id：如果能够恢复会话，则和客户端传递的session_id一致。如果不能，则创建一个新的session_id返回。 ciper_suite：根据客户端支持的密码套件，服务端选择一个双方都支持的来使用。 compression_method：根据客户端提供的压缩方法，服务端选择一个双方都支持的来使用。 extensions：根据客户端传递的扩展列表，服务端来进行处理。 一个示例的Server Hello消息如下图所示： 可以看到，Server Hello消息的主要作用是对客户端提供的密码套件列表，压缩方法列表等进行选择，最终决定双方通信要使用的。 5. Server Certificate，Server Key Exchange，Server Hello Done子消息当服务端发送过Server Hello消息后，一般会立刻发送Server Certificate消息。这个消息是选发的，但是一般服务端都会发送，用来给客户端验证服务端的身份。并且将服务端的公钥安全的给到客户端。证书消息中的信息是一系列的证书链。关于证书的详细内容我们这里不过多描述。 Server Key Exchange子消息也是有条件才会发送的，某些密码套件会需要发送此消息。逻辑上，服务端发送Server Hello消息后，紧随着就会发送Server Hello Done消息，这条消息是一条空消息，表示服务端已经将要发送的东西都发送完了，客户端可以进行证书校验，密钥协商逻辑了。 这3条消息通常会保证到一个TCP报文中发送，如下图： 后面，还有一些客户端协商出密钥的消息，握手完成的消息等。这些子消息完成后，表明整个握手过程结束，后续客户端和服务端开始将数据进行加密通信。 完成了完整的握手过程后，后续的业务数据通信都会进行加密，如下图所示： 四.结尾现在，我们对网络通信在应用层的逻辑有了宏观上了理解。应用数据的逻辑理清楚了，更重要的是将这些数据安全稳定的传输给对方。这就需要传输层协议登场了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ：316045346","categories":[{"name":"网络技术","slug":"网络技术","permalink":"http://huishao.cc/categories/网络技术/"}],"tags":[],"keywords":[{"name":"网络技术","slug":"网络技术","permalink":"http://huishao.cc/categories/网络技术/"}]},{"title":"iOS研习记——聊聊野指针与僵尸对象定位","slug":"439[iOS研习记]——聊聊野指针与僵尸对象定位","date":"2021-12-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.396Z","comments":true,"path":"2021/12/04/439[iOS研习记]——聊聊野指针与僵尸对象定位/","link":"","permalink":"http://huishao.cc/2021/12/04/439[iOS研习记]——聊聊野指针与僵尸对象定位/","excerpt":"","text":"[iOS研习记]——聊聊野指针与僵尸对象定位一、从一个异常说起在iOS项目开发中，或多或少的我们都会遇到一些Crash的情况，大部分Crash抛出的异常都是NSException层的，这类异常是OC层代码问题造成的，通常堆栈信息和异常的提示信息都非常明确，可以直接定位到出问题的代码，从而使这类问题的解决并不困难。可以引起Crash的异常除了NSException外，还有Unix层和Mach层的异常。 Mach异常一般是底层内核级的异常，我们可以通过一些底层的API来对这类异常进行捕获，这不是本文的讨论内容，这里不再赘述。Unix层是指对于开发者没有捕获的Mach异常，会被转换成对应的Unix信号传递给出错线程。 如果你在iOS项目在线上收集的异常中，有类似EXC_BAD_ACCESS的异常，则大概率是由于内存问题产生的野指针引起的。这也是本文我们要讨论的核心内容。 1. 什么是野指针？当前我们在编写iOS程序时大多会采用ARC来进行内存管理，通常情况下我们无需过多的对内存管理进行关心。但是这并不代表不会产生内存问题。从原理上讲，我们在创建任何对象的时候，首先都会通过操作系统从内存中申请出一块内存空间供此对象使用，并将此内存空间的地址保存到指针中供我们在代码中方便的引用到此内存。那么当这个对象被销毁的时候，原则上我们需要做两件事，一是将这块内存还回去，之后操作系统可以重复利用这块内存分配给其他申请者使用，二是将代码中的指针清空回收。这样可以保证程序能够可持续化的健康运行。工作过程如下图所示： 但是无论在生活中还是编程中，意外总会发生，通常情况下，在向操作系统申请内存这一步很少会出现问题，操作系统本身的稳定性比应用程序要强很多。问题大多出现在内存释放的时候。问题可能有两种： 一种是已经不需要使用的对象我们将指针变量直接清除了，但却没有告诉操作系统回收这块内存，此后程序中没有地方存储这块内存的地址，这块内存将永远无法使用和回收。这种情况下，这块内存就变成了无主内存且操作系统并不知道，就产生了我们常说的内存泄露问题，随着应用的运行时间越来越长，内存泄露可能越来越多最终导致内存不够用，程序无法再正常运行。 另一种是我们告诉操作系统要回收这块内存，并且这块内存也真正的被回收了，但是程序中依然有指针变量存储着这个地址没有清空，此时这个指针就变成了也指针，因为它所指向的内存已经回收，这块内存具体是又被利用了还是依然存放着原来的数据我们都一无所知。此后如果不小心又通过这个指针使用了这块内存的数据，无论读写都将产生各种千奇百怪的问题，且我们很难定位。本文我们主要聊的就是这类野指针问题的产生原因与定位方法。 2. 野指针会产生哪些问题？开发中我们遇到的大部分的EXC_BAD_ACCESS问题都是由野指针导致的，主要有两种信号：SIGSEGV和SIGBUS。其中SIGSEGV表示操作的地址非法，访问了未分配的内存或者写入了没有写权限的内存。SIGBUS表示错误的内存类型访问。 野指针会产生的问题千奇百怪，难以定位。当程序中使用到了野指针时，可能存在两大种场景： 1&gt; 访问的内存没有被覆盖 如果原对象依赖的其他对象没有被删除，则看上去程序的运行好像任何问题，但是实际上却很危险，程序逻辑上的表现已经不可控。 如果原对象依赖的其他对象有删除情况，则内部可能还有有其他野指针生成，依然会出现各种复杂的异常场景。 2&gt; 访问的内存重新被覆盖了 这种从场景会更加麻烦，如果当前内存区域的可访问性发生了变化，则会产生许多类型的异常，例如objc_msgSend失败，SIGBUS地址类型异常，SIGFPE运算符异常，SIGILL指令异常等等。 如果当前内存是可以访问的，则可能违背我们本意的写坏其他地方在使用的内存，使其他地方在使用时产生异常。也可能要使用的数据类型和我们原对象对不上，导致未实现的选择器类的错误，查找方法类的错误，各种底层逻辑错误，以及malloc错误等。这时要排查问题就非常难了。 综上所述，野指针的危害是非常大，除了其本身会造成异常Crash外，还可能会使其他正常使用的代码产生异常，并且有不可复现性与随机性，例如你可能发现某个Crash的堆栈是调用了某个对象的某个方法找不大，但是你搜遍代码也没有找到类似的方法调用，其实就是其他地方出现了野指针问题，之后这个正确的对象刚好分配到了野指针所指向的内存，野指针将此内存的数据破坏了。对于这种Crash问题，我们几乎是束手无策的。 3. 动手造一个野指针场景试试看通过前面的介绍，我们了解了野指针问题的产生原因与危害。现在可以动手一试。使用Xcode新建一个iOS工程。在其中新建一个名为MyObject的类，为其添加一个属性，如下： 1234567#import &lt;Foundation/Foundation.h&gt;@interface MyObject : NSObject@property(copy) NSString *name;@end 在ViewController类中编写如下测试代码： 1234567891011121314151617181920212223242526#import \"ViewController.h\"#import \"MyObject.h\"@interface ViewController ()@property (nonatomic, unsafe_unretained)MyObject *object;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; MyObject *object = [[MyObject alloc] init]; self.object = object; self.object.name = @\"HelloWorld\"; void *p = (__bridge void *)(self.object); NSLog(@\"%p,%@\",self.object,self.object.name); NSLog(@\"%p,%@\",p, [(__bridge MyObject *)p name]);&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@\"%p\",self-&gt;_object); NSLog(@\"%@\",self.object.name);&#125;@end 这里我们手动的造出了一个会出现野指针问题的场景，ViewController类的object属性声明为的unsafe_unretained，这个修饰符的意思是当前属性不被ARC所管理，其所引用的对象释放后，此指针也不会被置空。上面代码我们在viewDidLoad方法中创建了一个MyObject对象，并复制给了当前控制器的object属性，由于栈内对象的生命周期为当前代码块内有效，因此当viewDidLoad方法结束后，此内存就会被回收，此时object指针就成了野指针。 我们可以在viewDidLoad方法的最后打上断点，观察当前MyOject对象的内存分配地址，如下： 可以看到，当次运行时，object对象分配的内存地址为0x600001e542d0（每次运行都会不同），后面访问对象的属性实际上就是对此内存中数据的访问，我们如果知道了内存地址，也可以直接使用地址进行访问，不一定要有变量，例如上图中通过LLDB中的po指令可以直接向内存地址发送消息，效果和通过变量调用对象方法是一样的。 之后，我们可以在运行后点击一下当前页面，大部分情况下都会出现地址异常Crash，我们可以通过LLDB输出下线程的堆栈信息，如下： 还有时候，程序可能会直接Crash到main方法中，输入更奇怪的堆栈信息，如下： 如上图所示，堆栈信息提示我们调用了数组的name方法，这其实就是因为此块内存被重新分配了。 我们只创建了一个没有任何逻辑的Demo项目，野指针的问题都如此多样，如果是在实际项目中，出了野指针问题我们更难找到问题源头。并且在ARC环境下，上面示例的场景其实很好排查到，更多产生野指针的原因是多线程不安全的读写数据造成的，结合多线程使用，野指针的问题则更加难查。 二、从原理看野指针的监控要解决由野指针产生的问题，除了编程时尽量注意一些，避免危险的写法外。更重要的是能总结出一套方案来流程化的对此类问题进行监控。由于野指针问题的特性所致，我们在内存释放时其实是并不知道是否会产生野指针问题的，发生了野指针问题后也无法回溯。因此我们要用预设的思路来找这类问题的监控方案，即假设当前内存释放后依然有野指针要访问它，在设计时，我们可以不真正的将这块内存释放，而是将这块内存标记成有问题的，之后如果又发现有对这块有问题内存的访问出现，则表明出现了野指针问题。在标记内存时，我们也可以记录一下原对象的某些信息，例如类名，这样在发生野指针问题时，无论具体Crash的堆栈情况如何，我们都可以知道是具体哪个类的对象释放问题产生的野指针，能极大的缩小问题的排查范围。 因此处理野指针问题的核心点在于两点： 1.预设标记内存，被动等待野指针问题触发。 2.记录产生野指针问题的类，从类对象的使用入手排查而不是Crash时的堆栈入手排查。 针对如上两点，我们来看下如何实现。 1. 僵尸对象将要释放的对象内存不真正回收，而是仅仅进行标记，我们会形象的成此时的对象为“僵尸对象”。Xcode默认支持开启僵尸对象，当我们向一个僵尸对象进行访问时，就会必然产生Crash，并且控制台输出相关提示信息。在Xcode中对要运行的scheme进行编辑，打开僵尸对象功能，如下所示： 再次运行工程，程序Crash后将输出如下信息： 1*** -[MyObject retain]: message sent to deallocated instance 0x600000670670 我们可以明确的知道是MyObject对象的内存问题导致了野指针崩溃。 Xcode的僵尸对象功能虽然好用，但是只能调试时使用，更多时候我们产生的野指针问题都是线上环境的，而且无法复现，这个功能就显得非常鸡肋的。我们能否不依赖Xcode来实现野指针的监控呢？首先我们需要先搞明白Xcode中僵尸对象的实现原理。 2. Apple僵尸对象的实现原理探究首先我们大致可以知道，要实现僵尸对象大概率是要对dealloc方法做些事情的，我们可以从这个方法入手找线索，查看objc的源代码，在其NSObject.m中可以看到如下代码： 1234// Replaced by NSZombies- (void)dealloc &#123; _objc_rootDealloc(self);&#125; 从注释可以看到，系统实现的僵尸对象的确是处理dealloc方法了，推测其实通过Runtime替换了NSObject的dealloc方法。在CoreFoundation的源码中也有部分关于Zombies的内容，在CFRuntime.c中可以看到如下代码： 1234extern void __CFZombifyNSObject(void); // from NSObject.mvoid _CFEnableZombies(void) &#123;&#125; 其中，_CFEnableZombies比较好理解，它应该是来表示是否开启僵尸对象功能的，应该和我们在Xcode中设置的环境变量功能一致，__CFZombifyNSObject从注释可以知道，应该是对僵尸对象的实现。我们在Xcode中添加一个__CFZombifyNSObject的符号断点，断点后内容如下所示： 看到这里的汇编，你应该不会太陌生，我们把核心的伪代码提出来，大致如下： 12345678910111213// 定义字符串define &quot;NSObject&quot;// 用来获取NSObject类objc_lookUpClass &quot;NSObject&quot;// 定义字符串define &quot;dealloc&quot;define &quot;__dealloc_zombie&quot;// 获取dealloc方法的实现class_getInstanceMethod &quot;NSObject&quot; &quot;dealloc&quot;// 获取__dealloc_zombie方法的实现class_getInstanceMethod &quot;NSObject&quot; &quot;__dealloc_zombie&quot;// 交换dealloc与__dealloc_zombie的方法实现method_exchangeImplementations &quot;dealloc&quot; &quot;__dealloc_zombie&quot; 和我们想的差不多，下面我们可以再添加一个__dealloc_zombie的符号断点，看一看__dealloc_zombie方法是怎么实现的，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768CoreFoundation`-[NSObject(NSObject) __dealloc_zombie]:-&gt; 0x10ef77c49 &lt;+0&gt;: pushq %rbp 0x10ef77c4a &lt;+1&gt;: movq %rsp, %rbp 0x10ef77c4d &lt;+4&gt;: pushq %r14 0x10ef77c4f &lt;+6&gt;: pushq %rbx 0x10ef77c50 &lt;+7&gt;: subq $0x10, %rsp 0x10ef77c54 &lt;+11&gt;: movq 0x2e04fd(%rip), %rax ; (void *)0x0000000110021970: __stack_chk_guard 0x10ef77c5b &lt;+18&gt;: movq (%rax), %rax 0x10ef77c5e &lt;+21&gt;: movq %rax, -0x18(%rbp) 0x10ef77c62 &lt;+25&gt;: testq %rdi, %rdi 0x10ef77c65 &lt;+28&gt;: js 0x10ef77d04 ; &lt;+187&gt; 0x10ef77c6b &lt;+34&gt;: movq %rdi, %rbx 0x10ef77c6e &lt;+37&gt;: cmpb $0x0, 0x488703(%rip) ; __CFConstantStringClassReferencePtr + 7 0x10ef77c75 &lt;+44&gt;: je 0x10ef77d1d ; &lt;+212&gt; 0x10ef77c7b &lt;+50&gt;: movq %rbx, %rdi 0x10ef77c7e &lt;+53&gt;: callq 0x10eff4b52 ; symbol stub for: object_getClass 0x10ef77c83 &lt;+58&gt;: leaq -0x20(%rbp), %r14 0x10ef77c87 &lt;+62&gt;: movq $0x0, (%r14) 0x10ef77c8e &lt;+69&gt;: movq %rax, %rdi 0x10ef77c91 &lt;+72&gt;: callq 0x10eff464e ; symbol stub for: class_getName 0x10ef77c96 &lt;+77&gt;: leaq 0x242db5(%rip), %rsi ; &quot;_NSZombie_%s&quot; 0x10ef77c9d &lt;+84&gt;: movq %r14, %rdi 0x10ef77ca0 &lt;+87&gt;: movq %rax, %rdx 0x10ef77ca3 &lt;+90&gt;: xorl %eax, %eax 0x10ef77ca5 &lt;+92&gt;: callq 0x10eff4570 ; symbol stub for: asprintf 0x10ef77caa &lt;+97&gt;: movq (%r14), %rdi 0x10ef77cad &lt;+100&gt;: callq 0x10eff4ab0 ; symbol stub for: objc_lookUpClass 0x10ef77cb2 &lt;+105&gt;: movq %rax, %r14 0x10ef77cb5 &lt;+108&gt;: testq %rax, %rax 0x10ef77cb8 &lt;+111&gt;: jne 0x10ef77cd7 ; &lt;+142&gt; 0x10ef77cba &lt;+113&gt;: leaq 0x2427aa(%rip), %rdi ; &quot;_NSZombie_&quot; 0x10ef77cc1 &lt;+120&gt;: callq 0x10eff4ab0 ; symbol stub for: objc_lookUpClass 0x10ef77cc6 &lt;+125&gt;: movq -0x20(%rbp), %rsi 0x10ef77cca &lt;+129&gt;: movq %rax, %rdi 0x10ef77ccd &lt;+132&gt;: xorl %edx, %edx 0x10ef77ccf &lt;+134&gt;: callq 0x10eff4a62 ; symbol stub for: objc_duplicateClass 0x10ef77cd4 &lt;+139&gt;: movq %rax, %r14 0x10ef77cd7 &lt;+142&gt;: movq -0x20(%rbp), %rdi 0x10ef77cdb &lt;+146&gt;: callq 0x10eff482e ; symbol stub for: free 0x10ef77ce0 &lt;+151&gt;: movq %rbx, %rdi 0x10ef77ce3 &lt;+154&gt;: callq 0x10eff4a5c ; symbol stub for: objc_destructInstance 0x10ef77ce8 &lt;+159&gt;: movq %rbx, %rdi 0x10ef77ceb &lt;+162&gt;: movq %r14, %rsi 0x10ef77cee &lt;+165&gt;: callq 0x10eff4b6a ; symbol stub for: object_setClass 0x10ef77cf3 &lt;+170&gt;: cmpb $0x0, 0x48867f(%rip) ; __CFZombieEnabled 0x10ef77cfa &lt;+177&gt;: je 0x10ef77d04 ; &lt;+187&gt; 0x10ef77cfc &lt;+179&gt;: movq %rbx, %rdi 0x10ef77cff &lt;+182&gt;: callq 0x10eff482e ; symbol stub for: free 0x10ef77d04 &lt;+187&gt;: movq 0x2e044d(%rip), %rax ; (void *)0x0000000110021970: __stack_chk_guard 0x10ef77d0b &lt;+194&gt;: movq (%rax), %rax 0x10ef77d0e &lt;+197&gt;: cmpq -0x18(%rbp), %rax 0x10ef77d12 &lt;+201&gt;: jne 0x10ef77d3d ; &lt;+244&gt; 0x10ef77d14 &lt;+203&gt;: addq $0x10, %rsp 0x10ef77d18 &lt;+207&gt;: popq %rbx 0x10ef77d19 &lt;+208&gt;: popq %r14 0x10ef77d1b &lt;+210&gt;: popq %rbp 0x10ef77d1c &lt;+211&gt;: retq 0x10ef77d1d &lt;+212&gt;: movq 0x2e0434(%rip), %rax ; (void *)0x0000000110021970: __stack_chk_guard 0x10ef77d24 &lt;+219&gt;: movq (%rax), %rax 0x10ef77d27 &lt;+222&gt;: cmpq -0x18(%rbp), %rax 0x10ef77d2b &lt;+226&gt;: jne 0x10ef77d3d ; &lt;+244&gt; 0x10ef77d2d &lt;+228&gt;: movq %rbx, %rdi 0x10ef77d30 &lt;+231&gt;: addq $0x10, %rsp 0x10ef77d34 &lt;+235&gt;: popq %rbx 0x10ef77d35 &lt;+236&gt;: popq %r14 0x10ef77d37 &lt;+238&gt;: popq %rbp 0x10ef77d38 &lt;+239&gt;: jmp 0x10eff44c8 ; symbol stub for: _objc_rootDealloc 0x10ef77d3d &lt;+244&gt;: callq 0x10eff443e ; symbol stub for: __stack_chk_fail 汇编内容较多，整体流程是比较清晰的，伪代码如下: 12345678910111213141516171819202122232425// 获取当前类object_getClass// 通过当前类获取当前类型class_getName// 将_NSZombie_拼接上当前类名zombiesClsName = &quot;_NSZombie_%s&quot; + className// 获取zombiesClsName类objc_lookUpClass zombiesClsName// 判断是否已经存在zombiesClsif not zombiesCls: // 如果不存在 // 现获取&quot;_NSZombie_&quot;类 cls = objc_lookUpClass &quot;_NSZombie_&quot; // 复制出一个cls类，类名为zombiesClsName objc_duplicateClass cls zombiesClsName// 字符串变量释放free zombiesClsName// objc中原本的对象销毁方法objc_destructInstance(self)// 将当前对象的类修改为zombiesClsobject_setClass zombiesCls// 判断是否开启了僵尸对象功能if not __CFZombieEnabled: // 如果没开启 将当前内存释放掉 free 上面的伪代码基本是__dealloc_zombie方法实现的整体过程，在objc源码中，NSObject类原本的dealloc方法实现路径如下： 1234567891011121314151617181920212223242526272829303132333435363738394041- (void)dealloc &#123; _objc_rootDealloc(self);&#125;void _objc_rootDealloc(id obj)&#123; ASSERT(obj); obj-&gt;rootDealloc();&#125;inline void objc_object::rootDealloc()&#123; // taggedPointer无需回收内存 if (isTaggedPointer()) return; // fixme necessary? // nonpointer为1表示不只是地址，isa中包含了其他信息 // weakly_referenced表示是否有弱引用 // has_assoc 表示是否有关联属性 // has_cxx_dtor 是否需要C++或Objc析构 // has_sidetable_rc是否有散列表计数引脚 if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc)) &#123; // 如果都没有 直接回收内存 assert(!sidetable_present()); free(this); &#125; else &#123; object_dispose((id)this); &#125;&#125;id object_dispose(id obj)&#123; if (!obj) return nil; // 进行内存回收前的销毁工作 objc_destructInstance(obj); free(obj); return nil;&#125; 可以看到，__dealloc_zombie与真正的dealloc的实现其实只差了当前内存的回收部分，objc_destructInstance方法会正常执行的，这个方法实现如下： 12345678910111213141516void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // C++ 析构 if (cxx) object_cxxDestruct(obj); // 移除关联属性 if (assoc) _object_remove_assocations(obj); // 弱引用表和散列表的清除 obj-&gt;clearDeallocating(); &#125; return obj;&#125; 通过上面的分析，我们发现，其实系统实现的僵尸对象非常安全，并不对正常代码的运行产生负面作用，唯一的影响在于内存不回收会增加内存的使用负担，但是可以通过某些策略来进行释放。 三、手动实现线上野指针问题收集理解了系统僵尸对象的实现原理，即是不依赖Debug环境，我们也可以仿照此思路来实现僵尸对象监控功能。 1. 仿照Apple的僵尸对象思路实现首先创建一个名为_YHZombie_的模板类，实现如下： 123456789101112131415161718192021// _YHZombie_.h#import &lt;Foundation/Foundation.h&gt;@interface _YHZombie_ : NSObject@end// _YHZombie_.m#import \"_YHZombie_.h\"@implementation _YHZombie_// 调用这个对象对的所有方法都hook住进行LOG- (id)forwardingTargetForSelector:(SEL)aSelector &#123; NSLog(@\"%p-[%@ %@]:%@\",self ,[NSStringFromClass(self.class) componentsSeparatedByString:@\"_YHZombie_\"].lastObject, NSStringFromSelector(aSelector), @\"向已经dealloc的对象发送了消息\"); // 结束当前线程 abort();&#125;@end 在新建一个NSObject的类别，用来替换dealloc方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// NSObject+YHZombiesNSObject.h#import &lt;Foundation/Foundation.h&gt;@interface NSObject (YHZombiesNSObject)@end// NSObject+YHZombiesNSObject.m#import \"NSObject+YHZombiesNSObject.h\"#import &lt;objc/objc.h&gt;#import &lt;objc/runtime.h&gt;@implementation NSObject (YHZombiesNSObject)+(void)load &#123; [self __YHZobiesObject];&#125;+ (void)__YHZobiesObject &#123; char *clsChars = \"NSObject\"; Class cls = objc_lookUpClass(clsChars); Method oriMethod = class_getInstanceMethod(cls, NSSelectorFromString(@\"dealloc\")); Method newMethod = class_getInstanceMethod(cls, NSSelectorFromString(@\"__YHDealloc_zombie\")); method_exchangeImplementations(oriMethod, newMethod); &#125;- (void)__YHDealloc_zombie &#123; const char *className = object_getClassName(self); char *zombieClassName = NULL; asprintf(&amp;zombieClassName, \"_YHZombie_%s\", className); Class zombieClass = objc_getClass(zombieClassName); if (zombieClass == Nil) &#123; zombieClass = objc_duplicateClass(objc_getClass(\"_YHZombie_\"), zombieClassName, 0); &#125; objc_destructInstance(self); object_setClass(self, zombieClass); if (zombieClassName != NULL) &#123; free(zombieClassName); &#125;&#125;@end 上面代码，除了一些容错判断没有加之外，思路和系统的僵尸对象一模一样。 再次运行我们的测试代码，在访问到野指针的时候将百分百的产生异常中断，并输出如下： 10x600003a8c2e0-[MyObject name]:向已经dealloc的对象发送了消息 现在，我们已经从原理上简单实现了一个不依赖于Xcode的野指针监控工具。 2. 将监控推广到C指针通过对象的僵尸化，对OC层的野指针问题可以做到很好的监控作用，但是这种方法并不实用与C层的指针，项目中如果用到C相关的指针，由于内存的管理方式不走引用计数，无法通过Hook dealloc的方式来僵尸化对象。例如，我们创建一个如下的结构体： 123typedef struct &#123; NSString *name;&#125; MyStruct; 在使用此结构体时，如果初始化之前进行了使用或内存回收后进行了使用都可能会出现野指针问题，如下： 123456789101112MyStruct *p;p = malloc(sizeof(MyStruct));// 此时内存中的数据不可控 可能是之前未擦除的printf(\"%x\\n\", *((int *)p));// 使用可能会出现野指针问题NSLog(@\"%@\", p-&gt;name);// 进行内存数据的初始化p-&gt;name = @\"HelloWorld\";// 回收内存free(p);// 此时内存中的数据不可控NSLog(@\"%@\", p-&gt;name); 我们可以思考下，出现上面野指针场景的主要原因是： 1. 获取到分配的内存后，如果此内存之前有过使用，数据此时是不可控的，当前指针直接使用此数据会有问题。 2.回收内存后，当前内存中的数据是不可控的，可能有别人或之前未清除的指针使用到。 无论是上面哪种场景，此野指针问题都有非常大的随机性，难以调试。因此我们核心要处理的地方在于把随机性改为必然性，即想办法让使用到这些有问题的内存时直接Crash，而不是可能Crash。要处理场景1很容易，我们可以hook住C中的malloc方法，分配了内存后直接将一个约定好的异常数据写入内存，这样在初始化之前使用到此数据时必然产生Crash。对于场景2，我们可以hook住C中的free方法，回收内存后将一个约定好的异常数据直接写入此内存，下次如果此内存没有被再分配，使用到它后也必然产生Crash。Xcode提供的Malloc Scribble调试功能，就是用这种思路实现的。 开启Xcode的Malloc Scribble选项，运行上面代码，效果如下图所示： 可以看到，在malloc分配内存之后，所有字节都被填入了0xAA，未初始化前使用就会必然产生Crash。这与Apple官方文档的解释是一致的，但是在free之后，内存数据获取到的可能并不是文档所说的0x55，是因为这块内存可能被其他内容覆写了。官网文档描述如下： 我们也可以手动根据Malloc Scribble的思路来实现一个将野指针问题从随机变成必然的工具，只需要重写系统的malloc相关的函数与free函数即可。对于C语言函数的Hook，我们可以直接使用fishhook库： https://github.com/facebook/fishhook 导入上面库后，新建一个命名为YHMallocScrbble的类，实现如下： 1234567891011121314151617181920212223242526272829303132333435363738// YHMallcScrbble.h#import &lt;Foundation/Foundation.h&gt;@interface YHMallcScrbble : NSObject@end// YHMallcScrbble.m#import \"YHMallcScrbble.h\"#import \"fishhook.h\"#import \"malloc/malloc.h\"void * (*orig_malloc)(size_t __size);void (*orig_free)(void * p);void *_YHMalloc_(size_t __size) &#123; void *p = orig_malloc(__size); memset(p, 0xAA, __size); return p;&#125;void _YHFree_(void * p) &#123; size_t size = malloc_size(p); memset(p, 0x55, size); orig_free(p);&#125;@implementation YHMallcScrbble+ (void)load &#123; rebind_symbols((struct rebinding[2])&#123;&#123;\"malloc\", _YHMalloc_, (void *)&amp;orig_malloc&#125;, &#123;\"free\", _YHFree_, (void *)&amp;orig_free&#125;&#125;, 2);&#125;@end 这样我们就实现了将野指针问题从随机变成必然，并且通用C指针。 相比僵尸对象方案，Malloc Scribble方法可以通用C指针，并且真正实现了对对象内存的回收，不会暂用内存。但是也有很大的弊端，比如对于free后写入的0x55在很多情况下都是无效的，因为这块内存可能又被其他地方改写了，导致Crash依然是随机的。当然我们也可以在自定义的free方法中不调用原系统的free，使得这块内存强制不能分配出去，这样其实和僵尸对象方案就比较类似了。并且相对僵尸对象方案，Malloc Scribble只能一定程度上将随机变成必然，方便问题的暴露，但是对开发者来说，并没有太多的信息告诉我们具体是什么类型的数据出的问题，排查还是有难度。 四、一些扩展上面只是简单介绍了对野指针问题监控的一些手段原理。除了僵尸对象和Malloc Scribble外，Xcode中还提供了Address Sanitizer工具来做内存问题的监控，其原理也是对malloc和free函数做了处理，但程序访问到了有问题的内存时可以及时Crash，同时这个工具可以将对象在malloc时的堆栈信息进行存储，方面我们定位问题。无论采用哪种方法，如果我们真的要在线上执行，要做的事情其实还有很多，例如数据的收集策略，僵尸对象内存的清理时机，何时判断出有问题并抓取堆栈等等。 最后，希望本文可以为你对开发中野指针问题的处理带来一些思路。本文中所编写的示例代码可以在如下地址下载： https://github.com/ZYHshao/ZombiesDemo 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"一起玩转树莓派（22）——DS1302硬件时钟实践","slug":"438一起玩转树莓派（22）——DS1302硬件时钟实践","date":"2021-11-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.396Z","comments":true,"path":"2021/11/28/438一起玩转树莓派（22）——DS1302硬件时钟实践/","link":"","permalink":"http://huishao.cc/2021/11/28/438一起玩转树莓派（22）——DS1302硬件时钟实践/","excerpt":"","text":"一起玩转树莓派（22）——DS1302硬件时钟实践不知你是否有发现，我们在使用计算机时，除了第一次启动需要同步下时间外，即是没有联网，断电重启后，计算机的时间依然是准确的。这是因为在计算机主机内部有一个自带电源的硬件时钟模块，在同步时间时将当前的时间写入模块后，此硬件时钟模块会自动的维护准确的当前时间。树莓派内部本身没有硬件时钟模块，但是在某些非联网的需求场景中，我们需要准确的记录当前的日期时间，比如之前我们介绍过许多有关气象相关的传感器，在记录气象数据时，也需要记录当时的准确时间。 1. DS1302模块简介DS1302是一款涓流充电计时芯片。其拥有实时时钟可以计算年，月，日，时，分，秒，星期等信息，可使用的时间间隔为2000年到2100年之间。除此之外，其还拥有一个31*8位的通用暂存RAM，用来存储一些临时的逻辑数据。DS1302采用同步串行通信的方式，简化了处理器的接口，理论上除了电源之外，主需要连接三根线即可实现通信功能，即CE线，I/O线和SCLK串行时钟线。 DS1302芯片有8个引脚，工作电路结构如下图所示： 每个引脚的作用如下： DS1302采用的是8位的指令命令字，在每次通信前，都需要使用命令字来启动，命令字结构如下： 如上图所示，其中第7位是写入有效控制位，为0时写入无效，为1时允许写入，每次进行数据传输时，必须将此位设置为1，一般我们在使用指令时，此为强制设置为1。 第6位控制芯片功能，为0时表示使用时钟数据，为1时表示使用RAM数据。 第1位到第5位为寄存器选择位，选择要操作的寄存器。 第0位是读写控制位，为0时表示要写数据到寄存器，为1时表示要从寄存器读数据。 了解了DS1302的指令结构，要使用它我们还需要对寄存器的功能做简单的了解，本次实验我们主要使用DS1302的时钟功能，与时钟功能相关的寄存器有7个，芯片手册中给出了示例，如下： 下面我们介绍下这些寄存器的功能和用法。 首先，指令中有5位来标识要操作的寄存器的地址，上图中直接给我了操作寄存器的读写指令。 第1个寄存器的地址为0b0，因此其读指令为0b1000 0001，写指令为0b1000 0000，转换成16进制，即上图中的0x81与0x80。此寄存器的最高位CH是一个标志位，每次上电后，我们可以读取一下这一位，如果是1表示断电后始终系统已经不工作了，我们需要重新校准时间，如果是0表示备用电源正常，始终持续正常运行。第4到第6位用来表示时间秒的十位数据，第0到第3位用来表示秒的个位数据，因为秒的十位数据最大为5，3个二进制位足够使用。 第2个寄存器的地址为0b1，其最高位为保留位，目前无用，第4位到第6位用来藐视分钟的十位，第0位到第3位表示分钟的个位，同样分钟的十位数据最大为5，3个二进制位足够使用。 第3个寄存器的地址为0b10，其最高位为1表示当前使用的是12小时制，最高位是0表示使用的是24小时制。第6位固定为0，没有意义。第5位在12小时制的模式下，为1表示的是下午，为0表示的是上午。在24小时制的模式下，第4位和第5位一起表示小时的十位。第0位到第3位表示了小时的个位。 第4个寄存器的地址为0b11，其第7位和第6位为固定的0，没有意义。第5位和第4位一起表示了日期的十位，第0位到第3位表示了日期的个位。 第5个寄存器的地址为0b100，其第5位到第7位为固定的0，没有意义。第4位表示了月的十位，第0到第3位表示月的个位。 第6个寄存器的地址为0b101，其高5位固定为0，没有意义。第3位表示了星期。 第7个寄存器的地址为0b110，高4位表示了年的十位，第4位表示了年的个位，可以表示0-99之间的值，即2000年到2099年。 第8个寄存器的地址为0b111，这是一个控制寄存器，在写数据时，这个寄存器的最高位WP必须是0，如果此位为1，则给其他寄存器的写操作都将禁止，用来做保护。 如果要使用到RAM功能，则指令的前两位必须是11，因此RAM的第一个寄存器的读写指令为0b1100 0000或0b1100 0001 ，即0xC0和0xC1。RAM存储寄存器有31个，地址为0x00到0x1F，对应的命令字从0xC0到0xFF。 无论是时钟模式，还是RAM模式，DS1302都支持采用脉冲串的方式来读写数据，时钟脉冲串指令为0xBF与0xBE，RAM脉冲串为0xFF与0xFE。数据会按照寄存器的顺序依次写入和读出。 明白了指令与寄存器的使用逻辑，下面还剩下一点需要明确，那就是如何进行数据的输入和读取。RST引脚用来控制数据读写，RTS从低电平变成高电平触发一次数据传输过程。 2. 实验连线本次实验，我们使用的是封装好的DS1302模块，如下图所示： 其中CLK对应SCLK引脚，DAT是IO功能引脚，RST对应CE功能引脚。我们选用树莓派中的16，18和22引脚（物理编码，分别对应BCM编码的23，24和25），连线如下： DS1302 树莓派 VCC 3.3V GND GND CLK GPIO23（BCM编码） DAT GPIO24（BCM编码） RST GPIO25（BCM编码） 3.实验编码现在，我们只需要按照前面介绍的模块用法进行编码即可，示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#coding:utf-8import timeimport RPi.GPIOfrom datetime import datetime# 使用物理编码SCL = 16IO = 18RST = 22# 数据读写的间隔CLK_PERIOD = 0.00001# 关闭GPIO警告RPi.GPIO.setwarnings(False)# 配置树莓派GPIO接口 使用物理编码RPi.GPIO.setmode(RPi.GPIO.BOARD)# 写入一个字节的数据def writeByte(Byte): for Count in range(8): # 将SCL置为低电平 开启一次传输 time.sleep(CLK_PERIOD) RPi.GPIO.output(SCL, 0) # 取一位数据进行写入 Bit = Byte % 2 Byte = int(Byte / 2) # 通过IO引脚进行写入 time.sleep(CLK_PERIOD) RPi.GPIO.output(IO, Bit) # 将SCL置为高电平 结束一次传输 time.sleep(CLK_PERIOD) RPi.GPIO.output(SCL, 1)# 读取一个字节的数据def readByte(): # 将IO引脚设置为输入 RPi.GPIO.setup(IO, RPi.GPIO.IN, pull_up_down=RPi.GPIO.PUD_DOWN) Byte = 0 for Count in range(8): # 先将SCL重置为高电平 time.sleep(CLK_PERIOD) RPi.GPIO.output(SCL, 1) # 将SCL置为低电平 开启一次传输 time.sleep(CLK_PERIOD) RPi.GPIO.output(SCL, 0) # 读取一位数据 time.sleep(CLK_PERIOD) Bit = RPi.GPIO.input(IO) Byte |= ((2 ** Count) * Bit) return Byte# 重置一些数据def resetDS1302(): # SCL引脚设置为输出 RPi.GPIO.setup(SCL, RPi.GPIO.OUT, initial=0) # RST引脚设置为输出 RPi.GPIO.setup(RST, RPi.GPIO.OUT, initial=0) # IO引脚设置为输出 RPi.GPIO.setup(IO, RPi.GPIO.OUT, initial=0) # SCL和IO都置为低电平 RPi.GPIO.output(SCL, 0) RPi.GPIO.output(IO, 0) time.sleep(CLK_PERIOD) # RST置为高电平 RPi.GPIO.output(RST, 1)# 结束操作def endDS1302(): # SCL引脚设置为输出 RPi.GPIO.setup(SCL, RPi.GPIO.OUT, initial=0) # RST引脚设置为输出 RPi.GPIO.setup(RST, RPi.GPIO.OUT, initial=0) # IO引脚设置为输出 RPi.GPIO.setup(IO, RPi.GPIO.OUT, initial=0) # SCL和IO都置为低电平 RPi.GPIO.output(SCL, 0) RPi.GPIO.output(IO, 0) time.sleep(CLK_PERIOD) # RST置为低电平 RPi.GPIO.output(RST, 0)# 进行时间校准def setDatetime(year, month, day, hour, minute, second, dayOfWeek): # 引脚重置 resetDS1302() # 设置写始终数据脉冲指令 writeByte(int(\"10111110\", 2)) # 开始依次写数据 # 写入秒数据，*16的作用是把十位右移4位 下面同 writeByte((second % 10) | int(second / 10) * 16) # 写入分钟数据 writeByte((minute % 10) | int(minute / 10) * 16) # 写入小时数据 writeByte((hour % 10) | int(hour / 10) * 16) # 写入日期数据 writeByte((day % 10) | int(day / 10) * 16) # 写入月份数据 writeByte((month % 10) | int(month / 10) * 16) # 写入星期数据 writeByte(dayOfWeek) # 写入年份数据 writeByte((year % 100 % 10) | int(year % 100 / 10) * 16) # 结束数据写入 writeByte(int(\"00000000\", 2)) # 结束任务 endDS1302()# 获取DS1302硬件时钟实践def getDatetime(): # 重置引脚 resetDS1302() # 0xBF指令，开始时钟脉冲串读取数据 writeByte(int(\"10111111\", 2)) Data = \"\" # 依次读取 # 先读出秒数据 Byte = readByte() second = (Byte % 16) + int(Byte / 16) * 10 # 分钟数据 Byte = readByte() minute = (Byte % 16) + int(Byte / 16) * 10 # 小时数据 Byte = readByte() hour = (Byte % 16) + int(Byte / 16) * 10 # 日期数据 Byte = readByte() day = (Byte % 16) + int(Byte / 16) * 10 # 月份数据 Byte = readByte() month = (Byte % 16) + int(Byte / 16) * 10 # 星期数据 Byte = readByte() day_of_week = (Byte % 16) # 年数据 Byte = readByte() year = (Byte % 16) + int(Byte / 16) * 10 + 2000 # 结束任务 endDS1302() return datetime(year, month, day, hour, minute, second)# 时间格式化def format_time(dt): if dt is None: return \"\" fmt = \"%m/%d/%Y %H:%M\" return dt.strftime(fmt) def parse_time(s): fmt = \"%m/%d/%Y %H:%M\" return datetime.strptime(s, fmt)# 初始化工作resetDS1302()# 写保护已关闭。writeByte(int(\"10001110\", 2))# 结束指令执行writeByte(int(\"00000000\", 2))# 涓流充电模式被关闭。writeByte(int(\"10010000\", 2))# 结束指令执行writeByte(int(\"00000000\", 2))#结束任务endDS1302() current = datetime.now()year = current.yearmonth = current.monthday = current.dayhour = current.hourminute = current.minutesecond = current.secondweek = current.weekday()setDatetime(year,month,day,hour,minute,second,week)while True: time.sleep(1) dt = getDatetime() print(dt) 上面示例代码中，无论是读数据还是写数据，我们都采用的时钟脉冲串的通信模式，这样我们只需要设置一次指令，即可按需读出所需数据，非常方便。在树莓派上运行上面的代码，效果如下图所示： 4.思考一下仿照上面的思路，是否可以改成非时钟脉冲串的通信方式来获取日期时间信息呢？试试吧！ 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"iOS研习记——谈谈静态库与动态库","slug":"437[iOS研习记]——谈谈静态库与动态库","date":"2021-11-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.396Z","comments":true,"path":"2021/11/24/437[iOS研习记]——谈谈静态库与动态库/","link":"","permalink":"http://huishao.cc/2021/11/24/437[iOS研习记]——谈谈静态库与动态库/","excerpt":"","text":"[iOS研习记]——谈谈静态库与动态库在iOS项目开发中，静态库和动态库我们时刻都在使用，离开了库的支持，我们将会举步维艰。比如，你要画界面，总离不开UIKit这个库吧，你要使用的各种基础数据结构，如NSString，NSArray等，也离不开Foundation这个基础库。除了官方的库外，开发中我们也会从Github等开源社区下载第三方的开源库进行使用。一般我们使用的第三方库或自己开发的库都采用静态库的方式使用，而系统提供的库大多是动态库，方便多进程共享。虽然我们天天在用库，但你对静态库和动态库真的了解么？静态库和动态库的结构是怎样的？静态库和动态库有什么区别？它们又是怎么应用的？本节博客，我们就来聊一聊这些问题。 1. 引言静态库与动态库有很多相似之处，当然也有很多差异。 从后缀名来说，.a为后缀名的库文件是静态库，.dylib为后缀名的库文件是动态库。在iOS开发中，更多时候我们使用的库是以.framework为后缀的。framework可以是静态库，也可以是动态库，framework本身是一种打包方式。我们知道，我们在编写代码时，编写的都是“源码”，而要让计算机理解这些源码，就需要编译器对源码进行编译，将其编译成计算机可理解的“机器码”，我们每编写的一个源码文件都会被编译成一个二进制的.o文件，无论静态库还是动态库，都是.o文件的合集。仅仅只有.o文件集合而成的库文件，对于开发者来说是不够的，在开发时我们不可能在没有头文件的情况下方便的调用库中的方法，因此还需要有头文件将库中提供的接口暴露出来，还有时候，可能还需要一些其他资源，比如和页面相关的库会有内置一些图片资源等，framework的功能就是将库文件，头文件，资源文件打包在一起，方便我们进行使用。下图描述了framework文件与库文件的关系： 2. 创建一个静态库更深入的了解静态库之前，我们可以先创建一个静态库体验下，首先使用Xcode创建一个新的工程，选择Framework，如下图所示： 创建好的framework工程模板，会生成一个和工程名相同的头文件，以及一个Resources资源文件夹，我们可以创建新的功能类文件，例如可以新建一个命名为MyLog的类和一个MyTool的类，代码如下： MyLog.h 12345678// MyLog.h#import &lt;Foundation/Foundation.h&gt;@interface MyLog : NSObject+ (void)log:(NSString *)str;@end MyLog.m 123456789#import \"MyLog.h\"@implementation MyLog+ (void)log:(NSString *)str &#123; NSLog(@\"MyLog:%@\",str);&#125;@end MyTool.h 1234567#import &lt;Foundation/Foundation.h&gt;@interface MyTool : NSObject+ (NSInteger)add:(NSInteger)a another:(NSInteger)b;@end MyTool.m 123456789#import \"MyTool.h\"@implementation MyTool+ (NSInteger)add:(NSInteger)a another:(NSInteger)b &#123; return a + b;&#125;@end 在默认生成的库头文件中，引入这两个功能头文件，如下： 12345678910#import &lt;Foundation/Foundation.h&gt;//! Project version number for MyStatic.FOUNDATION_EXPORT double MyStaticVersionNumber;//! Project version string for MyStatic.FOUNDATION_EXPORT const unsigned char MyStaticVersionString[];#import \"MyLog.h\"#import \"MyTool.h\" 在构建framewrok前，我们可以设置此framework构建成动动态库还是静态库，我们先将其构建成静态库，设置编译选项的Mach-o Type为Static Library，如下： 之后，可以让Xcode进行Build，之后在对应的Products文件夹中可以找到生成的framework文件，如下图所示： 如果你查看此framework文件的包内容，会发现其中有5类文件，如下： 其中，_CodeSignature中存放的是framework的签名文件。 Headers中存放的是头文件，需要注意，在编译framework工程时，要将需要暴露的头文件设置为public。 Info.plist文件是当前framework的配置文件。 Modules中的modulemap文件用来管理LLVM的module map，定义组件结构。 下面，我们可以尝试使用下此静态库，使用Xcode新建一个名为LibDemo的iOS工程，将前面构建的MyStatic.framework文件直接拖入此工程中，在工程的编译选项中，找到Framework Search Paths和Header Search Paths中分别将此framework的路径与头文件的路径进行配置，如下图所示： 修改测试项目的ViewController.m文件如下： 12345678910111213141516171819#import \"ViewController.h\"#import \"MyStatic.framework/Headers/MyStatic.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger a = 100; NSInteger b = 200; NSInteger c = [MyTool add:a another:b]; [MyLog log:[NSString stringWithFormat:@\"%ld\", c]];&#125;@end 运行代码，从控制台可以看到，我们的静态库已经可以正常工作了。你可能会觉得上面的头文件引入方式非常的丑陋，你完全可以在工程中新建一个文件夹，将framework包内的头文件拷贝过来，如下图： 这样你就可以像引用工程内的头文件一样的使用framework中的功能了： 123456789101112131415161718#import \"ViewController.h\"#import \"MyStatic.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger a = 100; NSInteger b = 200; NSInteger c = [MyTool add:a another:b]; [MyLog log:[NSString stringWithFormat:@\"%ld\", c]];&#125;@end 3.试试动态库吧静态库的构建和使用过程看上去非常容易，动态库应该也与其类似。我们现在就来试试吧，使用Xcode新建一个命名为MyDylib的framework工程，将编译选项中的Mach-O Type 改为Dynamic Library，创建一些简单的测试类如下： MyObjectOne.h 1234567#import &lt;Foundation/Foundation.h&gt;@interface MyObjectOne : NSObject@property(copy) NSString *name;@end MyObjectOne.m 12345#import \"MyObjectOne.h\"@implementation MyObjectOne@end MyObjectTwo.h 1234567#import &lt;Foundation/Foundation.h&gt;@interface MyObjectTwo : NSObject@property(copy) NSString *title;@end MyObjectTwo.m 12345#import \"MyObjectTwo.h\"@implementation MyObjectTwo@end 按照同样的方式，将构建好的framework文件拖入到测试工程中，配置头文件路径，添加测试代码如下： 123456789101112131415161718192021#import \"ViewController.h\"#import \"MyStatic.h\"#import \"MyDylib.framework/Headers/MyDylib.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger a = 100; NSInteger b = 200; NSInteger c = [MyTool add:a another:b]; [MyLog log:[NSString stringWithFormat:@\"%ld\", c]]; MyObjectOne *one = [[MyObjectOne alloc] init]; one.name = @\"Hello\"; [MyLog log:one.name];&#125; 试下编译运行，目前为止，看上去一切正常，但是当程序运行起来后会崩溃，控制台会输出如下信息： 1dyld[72035]: Library not loaded: @rpath/MyDylib.framework/MyDylib 产生这个异常的原因是没有找到动态库文件，静态库的动态库的区别出现了，怎么解决这个问题呢，其实很简单，我们找到当前测试工程编译的产出可执行文件，点击显示包内容，在其中新建一个Frameworks的文件夹，将MyDylib.framework文件拷贝进入，如下图所示： 现在再运行工程，你会发现程序已经可以正常执行了。但是手动拷贝动态库到可执行文件的操作非常不优雅，如果真的要在项目中使用动态库，我们更多时候会通过自动化的脚本来实现复制库文件这一步操作。 通过这些实践，我们好像能感觉到静态库和动态库之间有些什么不同，但究竟哪里不同呢？我们带着疑问继续探索。 4.静态库和动态库的不同之处Ⅰ. 载入的方式出现前面动态库无法找到的原因其实是动态库与静态库的载入方式不同。 静态库：静态库在链接时，会被完整的复制到可执行文件中，如果有多个应用使用了相同的静态库，每个应用的二进制文件中都会有一份完整的静态库代码。 动态库：程序在链接时，动态库并不会被复制进二进制文件，而是在程序运行时由系统动态加载到内存供程序进行调用。由于这种特性，动态库系统可以只加载一次，应用程序共享。 对于静态库动态库载入方式来说，我们可以再深一步。首先，静态库会被完整复制进可执行文件中，这里的完整其实是不精准的，我们在引入第三方库时，往往需要在工程的Other Linker Flags中配置-Objc选项，这一项的作用是对链接优化做设置。 默认情况下，静态库在链接的时候，并不会把所有代码都复制到可执行文件，其只会复制使用到的代码，这样可以减少最终应用包的体积，但是OC语言的动态性决定了并非代码直接引用才算使用，这种连接方式经常会产生运行时的问题。 设置-Objc选项后，链接器不管代码中有没有使用，都会将OC类和其对应的Category全部加载进来。 设置-all_load选项后，链接器会把所有目标文件都加载进来，不止局限与OC文件。 设置-force_load参数可以指定强制加载某个静态库的所有目标文件，对这个静态库来说，作用与-all_load一样。 对于动态库来说，链接器就没有办法做这样的优化动作了，因为动态库是运行时加载的，链接器不知道哪些代码会被用到，因此从这一个方面来说，静态库对包大小的优化貌似会比动态库更加优异，但是真的是这样么？我们先留下个伏笔，后面再分析。 Ⅱ.文件结构不同静态库和动态库的本质区别还是在于构建出的文件结构完全不同。可以使用MachOView工具来查看库文件。 我们先说静态库，MachOView打开的静态库结构如下： 可以看到，静态库的结构其实是比较简单的，除了库本身的一些描述文件，符号表外，基本就是其他可执行文件的集合了，在图中可以看到，每个可执行文件都会有一些头数据，这些头数据记录了可执行未见的名字，大小等信息。可以点开任意一个可执行文件，其中就是我们熟悉的各种代码段，数据段等数据了： 我们再来看动态库，其结构如下： 可以看到动态库本身就是一个可执行文件，其并不是将内部的所有.o文件做简单的集合，而是一个最终链接完成的镜像文件。由于动态库是运行时进行链接的，其无法做编译时的优化，看上去可能会增加应用包的大小，但是实际应用中，我们大多会采用-Objc参数来强制静态库链接所有OC文件，并且静态库中每一个.o文件都会有一个头信息，而动态库则省略了这部分信息，因此最终对影响应用包大小这一方面来说，并不一定静态库更优。但是有一点是确定了，静态库是编译时链接，会节省应用启动时间。往往在做优化类的项目时，没有固定的方案，我们要根据实际情况，选择最合适自己的方案。 5.动态库与运行时Ⅰ. 动态库的加载只要说到运行时，对开发者来说就大有可为之处。首先，我们先思考下，前面的测试工程，如果我们不拷贝动态库文件到IPA包内的时候，为什么程序运行会找不到这个库文件？又为什么我们需要将动态库拷贝进IPA包的Frameworks文件夹才行？别的文件夹不行么？ 要解释上面的问题，我们还是要从动态库的加载原理上来看，可以用MachOView打开测试应用包的可执行文件，找到其中的Load Commands段，如下图所示： 可以看到，其中有一些动态库的加载指令，Foundation，UIKit等都是系统的动态库，我们可以在其详情中看到详细的加载路径，如下： 对于我们自己的MyDylib库，其加载路径如下： 可以看到，这个动态库是从@rpath/MyDylib.framework/MyDylib这个路径来加载的，这个加载路径的设置在动态库编译时就已经确定，我们可以看下MyDylib这个工程，在Xcode的编译配置选项中，找到Dynamic Library Install Name选项，如下所示： 这里的@rpath实际上是一个环境变量，在应用工程中可以配置@rpath的值，在LibDemo工程的编译选项中搜rpath，可以看到这个环境变量的配置： 现在我们清楚了，其实动态库文件不一定要放入Frameworks文件夹下，修改@rpath变量的路径即可修改动态库的加载路径。 对于动态库的这种加载方式，原则上，我们可以修改此二进制文件的加载路径，也可以直接替换包内的动态库文件，实现一些逆向注入的功能，非常酷。 Ⅱ. 代码载入动态库动态库是在运行时被加载的，我们也可以在运行时使用代码动态的控制动态库的载入。可以将测试工程中引用MyDylib的地方全部删掉，将配置的头文件路径也去掉，我们将这个动态库拷贝进工程的Bundle中，如下： 修改ViewController类的代码如下： 123456789101112131415161718192021222324252627282930#import \"ViewController.h\"#import \"MyStatic.h\"#import &lt;dlfcn.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSInteger a = 100; NSInteger b = 200; NSInteger c = [MyTool add:a another:b]; [MyLog log:[NSString stringWithFormat:@\"%ld\", c]]; NSString *path = [[[NSBundle mainBundle] pathForResource:@\"MyDylib\" ofType:@\"framework\"] stringByAppendingString:@\"/MyDylib\"]; // 载入动态库 void * p = dlopen([path cStringUsingEncoding:NSUTF8StringEncoding], RTLD_LAZY); if (p) &#123; // 加载动态库成功 直接使用 Class cls = NSClassFromString(@\"MyObjectOne\"); NSObject *obj = [[cls alloc] init]; [obj performSelector:@selector(setName:) withObject:@\"Hello\"]; [MyLog log:[obj performSelector:@selector(name)]]; &#125;&#125;@end 此时，再次编译运行此工程，如果你观察测试项目的二进制文件，里面的加载命令中已经没有了MyDylib的加载，但是程序依然可以正常的执行，dlopen函数的作用就是在运行时载入动态链接库，载入成功后，我们可以借助OC的运行时方法，直接调用到动态库中的代码。通过这种方式，我们实际上可以实现插件动态下载与使用，使得应用有非常高的热更新能力，但是需要注意，动态下载动态库的方式并不允许在AppStore上架，我们只能在测试的App或企业的App中使用。 再进一步说，其实动态库的读取并不一定是从本地沙盒中，在本地调试时，你可以从任何位置读取动态库文件进行加载，这可以在本地实现很多非常酷的功能，比如Injection工具，它通过一个服务监听代码文件的变化，之后将其打包成动态库注入到程序中，再通过运行时替换类和方法，从而实现本地开发iOS项目的热更新效果，非常好用。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"一起玩转树莓派（21）——火情报警器","slug":"436一起玩转树莓派（21）——火情报警器","date":"2021-11-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.395Z","comments":true,"path":"2021/11/20/436一起玩转树莓派（21）——火情报警器/","link":"","permalink":"http://huishao.cc/2021/11/20/436一起玩转树莓派（21）——火情报警器/","excerpt":"","text":"一起玩转树莓派（21）——火情报警器很多公寓和写字楼中都有完善的防火装置，你想知道这些设备是如何对是否产生了火情进行判断的么？当有物体燃烧时，会产生火焰和烟雾，如果我们可以通过传感器对火焰和烟雾进行，实际上就可以做到检测是否有火情发生。 一. 火焰传感器物质在燃烧时产生的火焰具有离散光谱的气体辐射和连续光谱的固体辐射，虽然不同的燃烧物其产生的火焰的辐射强度，波长等各有差异，但总体来说其波长范围是有特征的，火焰传感器即是通过这一原理要检测辐射波长，来判断周围是否有火源。本次实验，我们使用的火焰传感器如下图所示： 此传感器模块有4个引脚，除了电源正负极外，还有两个输出引脚，分别会输出数字信号和模拟信号。此模块也带一个可变电阻来条件传感器的灵敏度。 二.烟雾传感器烟雾传感器是一种气体传感器，当与烟雾接触时，其表面导电率会发生变化，最终输出电压发生变化。本次实验使用的烟雾传感器模块如下图所示： 此传感器模块也有4个引脚，除了电源正负极外，另外两个输出引脚分别为数字信号输出和模拟信号输出。 三. 实验连线本次实验，我们使用的两个传感器模块都支持数字信号输出和模拟信号输出，为了处理模拟信号，我们又要使用模数转换模块了，两个传感器的模拟信号都通过PCF8591来转换。 连线方式如下： PCF8591与树莓派： PCF8591 树莓派 SCL SCL SDA SDA GND GND VCC +5V 火焰传感器连线： 火焰传感器 PCF8591 树莓派 GND GND VCC +5V DO GPIO17(BCM编码，对应物理编码11) AO AIN0 烟雾传感器连线： 烟雾传感器 PCF8591 树莓派 GND GND VCC +5V DO GPIO18(BCM编码，对应物理编码12) AO AIN1 四. 编码本次实验与本系列博客中之前介绍的实验从技术上来说，并没有什么难度，编码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#SMBus (System Management Bus,系统管理总线) import smbus #在程序中导入“smbus”模块import RPi.GPIO as GPIO import timebus = smbus.SMBus(1) #创建一个smbus实例# 通过PCF8591读取模拟信号# 火焰传感器的模拟数据def readFire(): #发送一个控制字节到设备 表示要读取AIN0通道的数据 bus.write_byte(0x48,0x40) bus.read_byte(0x48) # 空读一次，消费掉无效数据 return bus.read_byte(0x48) # 返回某通道输入的模拟值A/D转换后的数字值# 烟雾传感器的模拟数据def readSmoke(): #发送一个控制字节到设备 表示要读取AIN1通道的数据 bus.write_byte(0x48,0x41) bus.read_byte(0x48) # 空读一次，消费掉无效数据 return bus.read_byte(0x48) # 返回某通道输入的模拟值A/D转换后的数字值# 通过GPIO读取数字信号# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 数字输出引脚 BCM 17P1 = 11# 数字输出引脚 BCM 18P2 = 12# 引脚初始化GPIO.setup(P1, GPIO.IN)GPIO.setup(P2, GPIO.IN)while True: print('--------分割线----------') print('火焰传感器数字信号：', GPIO.input(P1)) data1 = readFire() print('火焰传感器模拟信号：', data1) print('烟雾传感器数字信号：', GPIO.input(P2)) data2 = readSmoke() print('烟雾传感器模拟信号：', data2) time.sleep(2) 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（20）——噪声监测","slug":"435一起玩转树莓派（20）——噪声监测","date":"2021-11-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.395Z","comments":true,"path":"2021/11/16/435一起玩转树莓派（20）——噪声监测/","link":"","permalink":"http://huishao.cc/2021/11/16/435一起玩转树莓派（20）——噪声监测/","excerpt":"","text":"一起玩转树莓派（20）——噪声监测噪声污染是非常令人讨厌的一件事，长时间暴露在噪声中，不仅会使人心烦意乱，甚至还会影响我们的身心健康。本节，借助声音传感器，我们可以开发一个小型的噪声监测工具，当环境噪音过大时，发出提醒。 一.声音传感器声音传感器模块是一种将声波转换成电信号的元件。使用它可以方便的获取环境中的声音强度。本次实验，我们使用的声音传感器模块如下图所示： 如图所示，此传感器模块有4个对外引脚，其中AO引脚是模拟引号输出引脚，DO引脚是数字引号输出引脚。G引脚用来接地，+引脚接5V电源。 此传感器模块上还有两个LED指示灯，LED1是电源指示灯，只要传感器的正负极正常连通，此指示灯就会亮。LED2是声音检测指示灯，环境声音强度没有超过一定值时，此指示灯会熄灭，环境声音强度超过了一定数值后，此指示灯会亮。具体的阈值可以通过调节图中蓝色部分的可变电阻来进行调整。 本次实验我们使用的声音传感器模块既可以输出数字信号也可以输出模拟信号，对于数字信号，我们可以直接将其接树莓派的GPIO来进行接收，由于树莓派没有内置数模转换模块，因此对于模拟信号，我们需要使用PCF8591数模转换模块来读取模拟信号。 二. 实验首先先确认下我们要使用的引脚，声音传感器的数字信号引脚可以直接连接树莓派的GPIO17(BCM编码)，模拟引号引脚连接PCF8591的AINO。如下表： PCF8591与树莓派： PCF8591 树莓派 SCL SCL SDA SDA GND GND VCC +5V 声音传感器模块与树莓派： 声音传感器 树莓派 G GND + +5V DO GPIO17(BCM编码，对应物理编码11) 声音传感器与PCF8591： 声音传感器 PCF8591 AO AIN0 编写示例代码如下： 12345678910111213141516171819202122232425262728293031323334#SMBus (System Management Bus,系统管理总线) import smbus #在程序中导入“smbus”模块import RPi.GPIO as GPIO import timebus = smbus.SMBus(1) #创建一个smbus实例# 通过PCF8591读取模拟信号# 声音强度的模拟数据def readData(): #发送一个控制字节到设备 表示要读取AIN0通道的数据 bus.write_byte(0x48,0x40) bus.read_byte(0x48) # 空读一次，消费掉无效数据 return bus.read_byte(0x48) # 返回某通道输入的模拟值A/D转换后的数字值# 通过GPIO读取数字信号# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 数字输出引脚 BCM 17P = 11# 引脚初始化GPIO.setup(P, GPIO.IN)while True: print('--------分割线----------') print('环境声音强度数字信号：', GPIO.input(P)) data = readData() print('环境声音强度模拟信号：', readData()) if data &lt; 130: print（\"噪声过大，请注意！！！！！！！！！\"） time.sleep(2) 上面代码中设置模拟信号小于130则表示环境声音过强，需要注意，如果你运行上面的程序发现数值一直很小，可能是灵敏度设置过高所致，可以调节可变电阻来得到合适的灵敏度。 代码运行效果如下图所示： 本次实验并没有特别新颖的地方，所使用到的技术本系列之前博客中都有详细的介绍。 专注技术，懂的热爱，愿意分享，做个朋友","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（19）——红外遥控控制实验","slug":"434一起玩转树莓派（19）——红外遥控控制实验","date":"2021-11-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.395Z","comments":true,"path":"2021/11/15/434一起玩转树莓派（19）——红外遥控控制实验/","link":"","permalink":"http://huishao.cc/2021/11/15/434一起玩转树莓派（19）——红外遥控控制实验/","excerpt":"","text":"一起玩转树莓派（19）——红外遥控控制实验红外遥控是生活中非常常见的电子器具，电视机，空调，音响等电器都可以通过遥控器进行控制。本篇博客，我们尝试来通过红外发生器和红外信号接受器来进行红外控制实验，在树莓派上通过红外遥控的按键来处理LED灯的控制。 一. 实验前的准备本次实验，我们将使用一个红外遥控器来LED灯，需要准备的元件有：红外遥控器，红外收接器和一个双色LED灯。分别如下图所示： 红外遥控只要安装了电池，之后我们点击任意按键的时候就会触发红外信号，红外收接模块可以收接此红外信号，双色LED我们已经十分熟悉了，后面只需根据红外信号来控制LED的亮灭即可。 首先，我们可以先将红外收接传感器连接到树莓派，方便我们测试红外线的收接功能，连线如下： 树莓派 红外收接器 5V VCC GND GND GPIO27(BCM编码) DO 接着，我们需要在树莓派上安装红外驱动库lirc和Python-lirc，在树莓派终端执行如下指令： 1234567sudo apt updatesudo apt install lircsudo apt-get install liblircclient-devsudo apt-get install python3-lirc 之后，需要对红外接口IO进行配置，在树莓派终端执行： 1sudo nano /boot/config.txt nano是Linux系统下的一个文本编辑器，打开此配置文件后，我们需要找到下面两行配置项： 123# Uncomment this to enable the lirc-rpi module#dtoverlay=lirc-rpi,gpio_out_pin=17,gpio_in_pin=18,gpio_in_pull=up 将第二行的注释去掉，并修改如下： 1dtoverlay=lirc-rpi,gpio_in_pin=27,gpio_in_pull=up 需要注意，这里我们采用了树莓派的GPIO27引脚(BCM编码)作为红外信号的收接引脚，并默认设置为上拉电阻。本实验中，我们不需发出红外信号，因此红外信号的输出引脚可以不用配置。修改完成后，使用Control + x来退出编辑器，退出时会询问是否保存修改，按Y键保存即可。 下面，我们还需要对lirc的硬件接口进行配置，在树莓派终端使用如下指令打开配置文件： 1sudo nano /etc/lirc/lirc_options.conf 在配置文件中找到如下两行： 123driver = devinputdevice = auto 修改如下： 123driver = defaultdevice = /dev/lirc0 之后，重启树莓派，我们就可以测试红外收接功能了。 二.红外信号的收接树莓派重启完成后，在终端输入如下指令来测试红外信号： 1mode2 -d /dev/lirc0 需要注意，如果提示无法初始化lirc0，则需要先停止服务后在执行上面的指令，使用如下指令来停止服务： 1sudo service lircd stop 如果成功进入测试模式，你可以尝试使用红外遥控器对这树莓派按下一些按键，终端上出现如下图所示的输出，则表明已经可以成功收接到红外信号。 仅仅能够收接到信号对我们来说是不够的，这些信号我们并不能友好的进行识别，要将这些信号识别为有意义的按键，我们还需要信号进行编码。首先，在终端执行下面指令来查看所有可用的编码： 1irrecord -l 终端将输出如下信息： 可用的编码非常多，本次实验我们可以选3个来使用，例如我们选择KEY_0，KEY_1和KEY_2这三个编码来绑定到我们的遥控器对应的0，1和2按键上。 下面我们来进行编码的烧录，在终端执行如下指令： 1irrecord -d /dev/lirc0 ~/lircd.conf 之后终端会输出很多描述文案，如下图所示： 如果你有兴趣，可以阅读下这些介绍文案，然后直接回车即可。 如果是第一次进行编码的烧录，终端会提示“Enter name of remote(only ascii, no spaces)”的文件，我们需要为烧录文件取一个名字，需要注意名字只能有ascii字符且不能有空格。输入完成名字后回车，终端会输出“Press RETURN now to start recording.”的提示，我们再次按回车，即可进入烧录阶段。 烧录的过程有些繁琐，刚开始需要分析出遥控的按键间隔，我们可以随便按遥控上的按键，每次按键终端会输出一个“.”，注意一定要有耐心，一下一下的按，不要按住不松。按满一行后，终端会提示“Please keep on pressing btns like described above”，继续之前的操作即可，直到终端出现“Please enter the name for the next btn(press to finish recording)”，即表示按键间隔时间已经分析完成，我们可以开始正式录制。这时开始输入我们需要录制的键，比如KEY_0，之后终端提示如下： 这时我们点按遥控器上的“0”键即可，之后按照相同的方式再录制KEY_1和KEY_2。全部录制完成后，再按回车即可。主要特别注意，这时终端会提示要进行保存验证，应尽快按住遥控器上任意一个按键不松，直到终端提示录制成功，如下图所示： 录制完成后，会在当前文件夹下生成*.lircd.conf的录制文件，将其拷贝到/etc/lirc/lircd.conf.d文件夹下，如下： 1sudo cp 0_1_2.lircd.conf /etc/lirc/lircd.conf.d/0_1_2.lircd.conf 还有一个细节需要注意，在/etc/lirc/lircd.conf.d文件夹下默认存在一个名为devinput.lircd.conf的文件，默认会读取这个文件的配置，将其改名为devinput.lircd.dist即可。进入/etc/lirc/lircd.conf.d文件夹后，执行如下指令即可： 1sudo mv devinput.lircd.conf devinput.lircd.dist 你也可以打开录制的*.lircd.conf文件看一下，如果每个录制的键后面有两串十六进制数，如下图所示： 则你需要将后一串一样的十六进制数删除，否则无法正常使用，删除后的文件如下： 现在，不出意外的话，我们已经可以正常处理这3个按键信号了，在终端输入如下指令开启守护进程： 123sudo service lircd restart lircd --nodaemon --device /dev/lirc0 --driver default 另外开一个终端，输入如下指令来测试遥控按键： 1sudo irw 此时，按遥控器上的0，1和2按键，终端已经可以正常的响应了，如下图所示： 三.在Python中使用lirc驱动库你还记得我们之前的安装的python3-lirc库吧，下面是该用到它的时候了，首先创建一个Python文件，我们暂且命名为19.infrared.py，在树莓派终端将/etc/lirc/irexec.lircrc文件改名为lircrc，需要注意，就是lircrc文件，没有后缀名。下面我们需要根据需求进行一些配置，打开此文件，在其中配置Python程序要处理的红外按键，如下图所示： 如图中所示，通过begin和end组的方式来配置要处理的信号，其中prog需要配置为要处理此信号的Python程序，这里填我们的程序文件名即可，button用来设置要处理的按键，config用来配置传递到Python程序中的数据。更多配置方式可以通过如下链接得到： https://github.com/tompreston/python-lirc 配置完成后，修改19.infrared.py文件如下，可以进行简单的测试： 1234567891011# 导入lirc库import lirc# 进行初始化 这里设置blocking为False会避免阻塞，不接收的信号直接抛弃sockid = lirc.init(\"19.infrared.py\", blocking=False)while True: #获取按键信息 btn = lirc.nextcode() if len(btn): print(btn)lirc.deinit() 运行上面代码，在红外遥控器上按0，1或者2，可以看到程序会打印出一个数组，其中存放的就是我们的按键值。 现在，原理上说，你已经可以使用红外遥控和红外收接器做非常多的事情了，你可以将所有需要使用的按钮都录入，然后只做一个带LCD屏幕的计算器，或者通过遥控器控制电灯开关，温度气压计的数据上传等等。我们本次实验使用双色LED作为示例，抛砖引玉，希望你能发挥更多创造力。 双色LED有3个引脚，关于双色LED灯的实验在本系列很早的一篇博客中即有介绍，如果你感觉陌生，可以往前翻一翻，这里我们直接连线： 双色LED 树莓派 GND GND S GPIO17（BCM编码，对应物理编码11） - GPIO18（BCM编码，对应物理编码12） 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#coding:utd-8# 导入lirc 和 GPIO库import lircimport RPi.GPIO as GPIO# 初始化lircsockid = lirc.init(\"19.infrared.py\", blocking=False)#初始化GPIOGPIO.setmode(GPIO.BOARD)GPIO.setup(11, GPIO.OUT)GPIO.setup(12, GPIO.OUT)# 灭灯def clear(): GPIO.output(11, GPIO.LOW) GPIO.output(12, GPIO.LOW)# 设置红灯亮def red(): GPIO.output(11, GPIO.HIGH) GPIO.output(12, GPIO.LOW)# 设置绿灯亮def green(): GPIO.output(11, GPIO.LOW) GPIO.output(12, GPIO.HIGH)clear()# 监听红外信号while True: btn = lirc.nextcode() if len(btn): command = btn[0] if command == '0': clear() if command == '1': red() if command == '2': green()lirc.deinit() 运行代码，尝试下使用红外遥控器来控制灯的颜色和开关吧！ 四. 休息一下吧本系列博客到此，我们已经介绍了很多丰富多彩的传感器，你是否有想过组合使用这些传感器来创造出一些好玩的东西，现在你又具备了使用红外遥控远程控制程序的能力，尝试将你的想法实现一下吧！ 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"自上而下的理解网络（2）——HTTP篇","slug":"433自上而下的理解网络（2）——HTTP篇","date":"2021-11-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.395Z","comments":true,"path":"2021/11/10/433自上而下的理解网络（2）——HTTP篇/","link":"","permalink":"http://huishao.cc/2021/11/10/433自上而下的理解网络（2）——HTTP篇/","excerpt":"","text":"自上而下的理解网络（2）——HTTP篇一.引言上一篇博客中，我们介绍了访问网站的第一步：DNS解析的相关内容。地址如下： https://my.oschina.net/u/2340880/blog/5272671 本系列博客的宗旨是【自上而下的理解网络】，因此我们还是要一步一步的从前向后说，如果你已经阅读过了DNS那篇博客，那么现在，你访问网站使用的域名已经转换成了IP地址，有了IP地址，就相当与有了对方的地址（我们姑且先这么理解），从OSI网络模型的设计思路上说，上层无需关注下层的实现，目前我们先不关注拿到IP地址后是如何找到对应的主机的，暂且认为目前我们已经可以找到服务器并与之通信了。 那么当下，最紧要的问题是我们应该怎样与对方交流，我发送的数据如何能让对方理解？对方传输过来的数据我们又如何理解？这就好比，两个人要进行交流，他们必须使用相同的语言，否则就会驴唇不对马嘴，双方谁都无法理解谁。这里所比喻的“语言”就是互联网中的协议，我们访问一个网站，一般使用的都是HTTP协议。 二.重新认识下HTTP吧HTTP（Hyper Text Transfer Protocol）是一种应用层的协议，其设计的结构非常面向应用。对于大多数互联网应用来说，都是由一个服务器提供服务，许多的客户机来请求服务，任何互联网服务本质上都是数据交互，即客户端告诉服务端我要什么数据，服务端将对应的数据返回给客户端，或者客户端将一些数据传送给服务端处理，或者客户端告诉服务端我要修改什么数据，删除什么数据等等。在HTTP协议中，请求的发起方必定是客户端，服务端被动的收到请求后根据逻辑做响应。因此，HTTP协议交互的数据实际上分为两种，一种是Request数据，一种是Response数据，无论是哪种数据，我们都将其称为HTTP报文。 现在，你可以尝试打开浏览器的调试模式，随便访问一个网页，在网络监控部分可以看到HTTP请求的相关内容，如下图所示： 大致预览下，可以发现HTTP请求还有有些复杂的，请求头，响应头，请求体，响应体中都包含很多数据。通常，越面向应用层的上层协议实现简单而逻辑复杂，越底层的协议反而逻辑简单而实现复杂。HTTP协议只是看上去数据字段很多，其原理其实很简单。 HTTP报文有两大部分组成，分别为报文首部和报文主体，报文首部和报文主体之间使用空行来分割。即在报文数据中，第一个空行即是标记首部和主体的分割线，如下图所示： 其中，空行是有回车符（0x0d）加换行符（0x0a）组成，即十六进制的0x0d0a。后面我们在自己编写HTTP请求数据的组装或解析时，就可以使用连续的两个0x0d0a来作为首部和主体的分割位。报文首部又分为请求/状态行和请求/响应首部字段。 1. 请求行与状态行对于请求报文，首部的第一行数据为请求行，其格式如下： 请求方法 URI HTTP版本信息 请求方法，URI和HTTP版本信息之间使用空格进行分割（0x20）。 对于响应报文，首部的第一行数据为状态行，其格式如下： HTTP版本信息 状态码及状态文案 请求方法用来与告知服务端客户端的意图，例如是要获取数据还是上传数据，是删除文件还是修改文件等。而状态码则是服务器返回给客户端当前响应的状态，是成功了还是失败了等。 2. 请求方法请求方法表明了客户端要以什么样的方式来与服务端进行数据交互，常用的请求方法有8种，列举如下： 方法 意义 GET 获取资源 POST 发送数据 PUT 传输文件 HEAD 获得报文首部 DELETE 删除文件 OPTIONS 询问支持的方法 TRACE 追踪路径 CONNECT 要求用隧道协议连接代理 方法的本质其实只是客户端与服务端约定好的数据交互意图，其本身并不会影响传输数据本身，这就好比，生活中我们各种各样的车辆，公交汽车，出租车，小货车，不同类型的车辆有不同的功能，但是本质上，他们并没有区别，公交汽车也可以拉货，小货车也可以作为出租车来载人。那么你可能回想，我们可不可以客户端与服务端约定好一种自定义的请求方法进行交互呢，当然可以，后面我们会动手实践。 3. 状态码状态码负责将服务端请求的结果告知客户端，并不一定客户端所有的请求服务端都能正确处理，通常2XX类型的状态码表示处理成功，200表示请求被正常处理。204表示请求成功处理了，但是没有数据需要返回。206表示客户端进行了范围请求，服务端成功处理了。3XX类型的状态码通常表示与重定向有关，资源移动了位置或发生的变化，服务端会返回此类型的状态码。4XX类的通常是客户端的原因造成的异常，例如使用了不支持的请求方法，要请求的资源不存在等，我相信，404是我们最常见的一种异常状态，当你请求的URL或者参数有问题时会返回这个状态码。5XX类型的状态码通常是服务器错误。 当然，状态码的意义也是服务端和客户端约定而成的，在实际应用中，我们的应用逻辑可能需要更多的状态码来描述，完全可以自定义。 4. 首部字段首部字段主要用来存放控制字段，例如使用什么方法进行请求，使用的HTTP协议版本，发起请求的客户端信息等。以访问huishao.cc网站为例，抓取到的HTTP请求的首部信息如下： 可以看到，HTTP报文首部每个字段的配置是以行为单位进行分割的，每行配置一个字段。根据不同的上下文首部字段可以分为4类：通用类，请求头类，响应头类，实体类。通用类是指同时适用于请求首部和响应首部的字段，请求头类只适用与请求首部，响应头类只使用于响应首部，实体类是指包含报文主体信息的字段，如Content-Length设置主体部分长度。 下表列出了常用的HTTP官方的参考文档中定义了报文首部字段： 字段 意义 Accept 设置期望的数据类型，例如text/html Accept-Charset 设置期望的数据字符集 Accept-Encoding 设置期望的内容编码，例如gzip Accept-Language 设置期望的页面语言 Accept-Ranges 响应首部中的字段，表示是否接受范围请求 Age 资源创建至今的时间 Allow 资源可支持的HTTP方法 Authorization 服务端用来认证客户端身份 Cache-Control 控制缓存行为 Connection 管理连接 Content-Encoding 设置报文主体适用的编码方式 Content-Language 设置报文主体适用的语言 Content-Length 设置报文主体字节长度 Content-Location 标记数据的备用URI Content-MD5 报文主体的MD5摘要 Content-Range 报文主体的位置范围 Content-Type 报文主体的数据类型 Cookie Cookie设置 Date 创建报文日期时间 DNT 设置是否跟踪用户偏好，属于隐私控制字段 ETag 设置报文主体资源的版本号 Expect 客户端用来设置其期望服务端使用特性行为处理 From 用户的电子邮箱地址 Expires 报文主体过期的日期时间 Host 请求资源的服务器地址 If-Match 进行资源版本比较 If-Modified-Since 进行资源更新时间的比较 If-None-Match 与If-Match逻辑相反 If-Range 资源未更新时发送主体的范围请求 If-Unmodified-Since 与If-Modified-Since逻辑相反 Last-Modified 资源的最后修改时间 Location 令客户端重定向到的URI Max-Forwards 设置最大的输逐跳数 Proxy-Authenticate 定义了代理服务器对客户端的认证信息 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 主体的字节请求范围 Referer 对请求中URI的原始获取方 Retry-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 TE 传输编码的优先级 Transfer-Encoding 报文主体的传输编码方式 User-Agent HTTP客户端程序的信息 Upgrade 升级为其他协议 Vary 代理服务器缓存的管理信息 Via 代理服务器的相关信息 Warning 错误通知 WWW-Authenticate 服务端对客户端的认证信息 需要注意，上面列出的字段很多，但不一定所有的HTTP服务器都对他们进行了实现，HTTP本身只是一个协议，真正实现此协议的是服务端程序和客户端程序。同样，HTTP协议也是一种很具扩展性的协议，我们也可以根据应用需要，自定义一些首部字段，只要我们自己的客户端和服务端都按照约定好的理解来处理自定义的字段即可。下面，我们对一些重要的首部字段进行解释。 5. 核心首部字段解析Cache-ControlCache-Control首部字段用来控制缓存逻辑，在官方的协议定义中，此字段可以设置多个指令，指令间使用逗号分隔即可，例如： Cache-Control: private, max-age=0, no-cache 有些指令还支持传参，例如max-age指令。指令及参数意义如下： 指令 参数 意义 no-cache 无 强制向源服务器验证缓存有效性 no-store 无 不缓存请求或相应的任何内容 max-age 秒 响应的最大Age值 max-stale 秒 最大收的已过期响应时间 min-fresh 秒 指定在最少多少时间内刷新过的响应才有效 only-if-cached 无 从缓存获取资源 public 无 可向任意方提供响应的缓存 private 无 仅向特定用户返回响应 must-revalidate 无 允许缓存，但必须向服务端验证有效性 Accept客户端通过Accept字段可以告知服务端它所需要的数据格式。例如，当客户端向服务端请求一张图片时，服务端可以提供各种类型的图片数据，但是客户端只能够解析png类型的图片，这是就可以设置Accept字段，如下： Accept：image/png 客户端如果可以收多种类型的数据，Accept也支持设置多个类型，使用逗号进行分割即可，优先级会从前往后依次降低。同样，对字符集和编码方式如果有要求，通过Accept-Charset和Accept-Encoding字段设置。 AuthorizationAuthorization是HTTP协议中用来进行用户认证的字段，有时候客户端的资源并非所有用户都可以访问，如果有用户对这部分资源发起的访问请求，服务端会回执状态码为401的响应，表示需要用户认证才能范文，这时客户端就需要将用户认证信息放入Authorization字段中再次发起请求，服务端会根据Authorization的值来判断当前用户是否有权限访问此资源。 Host在介绍这个字段之前，请你先回忆下，我们在进行HTTP数据交互时，要先通过IP来找到对方的位置，其实一台服务器上是可以部署很多个服务的，不同的服务有可能在不同的虚拟主机上，那个我们的这次请求究竟需要那个虚拟主机来处理呢？这就需要有字段来标识用户到底访问的是什么资源，Host字段的用途就在如此。 三. 实践出真知现在，你是否对HTTP协议有了新的认识和理解，我们可以从实际的应用中验证前面所说的理论知识。 使用Wireshark工具来抓取网络报文包，我们可以将筛选条件设置为http协议，以便过滤掉无关的网络信息。在浏览器中访问huishao.cc网站，为了避免浏览器缓存产生的影响，可以先将缓存清空。 之后，我们可以在Wireshark工具中看到这样两条记录： 其中，第一条记录为HTTP的请求记录，第二条记录为HTTP的响应记录。 我们先看第一个请求记录，将其HTTP协议层的数据复制出来，如下： 1234567891011121314151617181920212247 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d 0a48 6f 73 74 3a 20 68 75 69 73 68 61 6f 2e 63 630d 0a 55 70 67 72 61 64 65 2d 49 6e 73 65 63 7572 65 2d 52 65 71 75 65 73 74 73 3a 20 31 0d 0a41 63 63 65 70 74 3a 20 74 65 78 74 2f 68 74 6d6c 2c 61 70 70 6c 69 63 61 74 69 6f 6e 2f 78 6874 6d 6c 2b 78 6d 6c 2c 61 70 70 6c 69 63 61 7469 6f 6e 2f 78 6d 6c 3b 71 3d 30 2e 39 2c 2a 2f2a 3b 71 3d 30 2e 38 0d 0a 55 73 65 72 2d 41 6765 6e 74 3a 20 4d 6f 7a 69 6c 6c 61 2f 35 2e 3020 28 4d 61 63 69 6e 74 6f 73 68 3b 20 49 6e 7465 6c 20 4d 61 63 20 4f 53 20 58 20 31 30 5f 3135 5f 37 29 20 41 70 70 6c 65 57 65 62 4b 69 742f 36 30 35 2e 31 2e 31 35 20 28 4b 48 54 4d 4c2c 20 6c 69 6b 65 20 47 65 63 6b 6f 29 20 56 6572 73 69 6f 6e 2f 31 34 2e 31 2e 31 20 53 61 6661 72 69 2f 36 30 35 2e 31 2e 31 35 0d 0a 41 6363 65 70 74 2d 4c 61 6e 67 75 61 67 65 3a 20 7a68 2d 63 6e 0d 0a 41 63 63 65 70 74 2d 45 6e 636f 64 69 6e 67 3a 20 67 7a 69 70 2c 20 64 65 666c 61 74 65 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e3a 20 6b 65 65 70 2d 61 6c 69 76 65 0d 0a 0d 0a 按照我们前面的分析，HTTP协议请求报文中的第一行数据为请求行，我们找到第一个换行符0d 0a为止，截出数据如下： 147 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0x20位空格字符，用其作为分割截出三部分数据为： 12347 45 542f 48 54 54 50 2f 31 2e 31 在Ascii码中，0x47为“G”，0x45为“E”，0x54为“T”，0x2f为“/”，0x48为“H”，0x50为“P”，0x31为“1”，0x2e为“.”。翻译完成即为： GET / HTTP/1.1 按照同样的方法，以0d 0a为分隔符可以将请求头中的每一个首部字段解析出来，因为我们本次请求没有请求体数据，因此找到两个连续的0d 0a后即表示首部解析完成。 响应报文的解析方法与请求报文没什么不同，这里我们不再赘述，有一点需要注意，响应报文的首部字段总有Content-Length字段表明了响应主体数据的长度。 四. 尝试下基于TCP来实现一个HTTP服务端和客户端吧在上一篇博客中，我们了解了DNS协议的原理后，基于TCP手动实现了一个简单的DNS解析器，DNS和HTTP都属于应用层的协议，TCP则属于传输层的协议。现在我们理解了HTTP的协议原理，能否手动实现一个简易的HTTP服务端和客户端呢？当然是可以的。 1. 简易HTTP服务端可以参考前面手动实现DNS的博客中TCP协议的用法，编写代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;sys/types.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt; #define QUEUE_MAX_COUNT 5 #define SERVER_STRING \"Server: custom HTTP server\\r\\n\" int main()&#123; // 服务端描述符 int server_fd = -1; // 客户端描述符 int client_fd = -1; // 定义端口号 u_short port = 9001; // 客户端地址 struct sockaddr_in client_addr; // 服务端地址 struct sockaddr_in server_addr; socklen_t client_addr_len = sizeof(client_addr); char buf[1024]; char recv_buf[1024]; int hello_len = 0; int on = 1; // 创建一个socket server_fd = socket(AF_INET, SOCK_STREAM, 0); // 设置地址复用 int ret = setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)); memset(&amp;server_addr, 0, sizeof(server_addr)); // 设置端口，IP，和TCP/IP协议族 server_addr.sin_family = AF_INET; server_addr.sin_port = htons(9001); server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // 绑定套接字到端口 bind(server_fd, (struct sockaddr *)&amp;server_addr,sizeof(server_addr)); // 启动socket监听请求，开始等待客户端发来的请求 listen(server_fd, QUEUE_MAX_COUNT); printf(\"http server running on port %d\\n\", port); // 循环等待客户端请求 while (1) &#123; // 调用了accept函数，阻塞了程序，直到收到客户端的请求 client_fd = accept(server_fd, (struct sockaddr *)&amp;client_addr, &amp;client_addr_len); printf(\"client socket fd: %d\\n\", client_fd); // 调用recv函数收客户端发来的请求信息 hello_len = recv(client_fd, recv_buf, 1024, 0); printf(\"receive %d\\n\\n\", hello_len); printf(\"%s\\n\", recv_buf); // 不管客户端发过来的请求是啥，我们都返回同样的测试数据 // 添加响应头 sprintf(buf, \"HTTP/1.0 200 OK\\r\\n\"); send(client_fd, buf, strlen(buf), 0); // 添加服务端信息 strcpy(buf, SERVER_STRING); send(client_fd, buf, strlen(buf), 0); // 添加主题类型 sprintf(buf, \"Content-Type: text/html\\r\\n\"); send(client_fd, buf, strlen(buf), 0); // 添加自定义头部数据 sprintf(buf, \"Custom: custom\\r\\n\"); send(client_fd, buf, strlen(buf), 0); // 结束首部字段的添加 strcpy(buf, \"\\r\\n\"); send(client_fd, buf, strlen(buf), 0); // 添加主体数据 sprintf(buf, \"HelloWorld!\\r\\n\"); send(client_fd, buf, strlen(buf), 0); /* 关闭客户端套接字 */ close(client_fd); &#125; close(server_fd); return 0;&#125; 上面代码中有比较详细的注释，一个HTTP请求结束后，当前客户端的Socket连接就会被关闭。上面只是简单实现了基于HTTP协议的数据交互，并没有真正实现应用逻辑，无论客户端发什么样的请求过来，服务端都将返回同样的数据。下面，在浏览器中输入http://localhost:9001/，效果如下图所示： 2. 简易的HTTP客户端与服务端实现代码类似，简易客户端代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;errno.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;void socket_init(int *sockfd,char *host);int main(int argc,char **argv)&#123; char message[512]; int socket_desc; char *host = \"127.0.0.1\"; socket_init(&amp;socket_desc,host); // 构建要发送的消息 CUSTOM为自定义的协议 sprintf(message,\"CUSTOM / HTTP/1.1\\r\\nHost: Service.com\\r\\n\\r\\n\"); // 发送数据到服务端 send(socket_desc,message,strlen(message),0); struct timeval timeout = &#123;3, 0&#125;; // 设置Sorket setsockopt(socket_desc, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;timeout, sizeof(struct timeval)); char chunk[512]; fd_set fdset; // 重设字符集 FD_ZERO(&amp;fdset); FD_SET(socket_desc,&amp;fdset); // 收服务端数据 select(socket_desc+1,&amp;fdset,NULL,NULL,NULL); if(FD_ISSET(socket_desc,&amp;fdset)) &#123; memset(chunk , 0 , 512); recv(socket_desc, chunk, 512, 0); printf(\"%s\" , chunk); &#125; return 0;&#125;void socket_init(int *sockfd,char *ip)&#123; struct sockaddr_in server; *sockfd = socket(AF_INET,SOCK_STREAM,0); server.sin_addr.s_addr = inet_addr(ip); server.sin_family = AF_INET; server.sin_port = htons(9001); connect((*sockfd),(struct sockaddr *)&amp;server,sizeof(server));&#125; 可以看到，上面代码中我们用了自定义的请求方法CUSTOM，启动服务端后在运行客户端，服务端应用会打印出如下信息： 12CUSTOM / HTTP/1.1Host: Service.com 同样，客户端的程序会打印出如下信息： 123456HTTP/1.0 200 OKServer: custom HTTP serverContent-Type: text/htmlCustom: customHelloWorld! 五. 结尾上面我们提供了服务端和客户端的简易实现代码，我相信你对HTTP协议的原理有了自己新的理解，你可以尝试下，完善下上面的代码，真正实现下HTTP协议中的GET，POST等方法。现在，回到我们本系列博客的核心：自上而下的理解网络。我们现在已经明白了域名是如何转换成IP地址，获得了IP地址后，客户端和服务端又是如何互相无障碍的通讯的。后面，我们将再进一步，进入传输层的领域，不积跬步，无以至千里，与君共勉。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ：316045346","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://huishao.cc/categories/计算机网络/"}],"tags":[],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://huishao.cc/categories/计算机网络/"}]},{"title":"一起玩转树莓派（18）——MPU6050陀螺仪加速度传感器模块应用","slug":"432一起玩转树莓派（18）——MPU6050螺旋仪加速度传感器模块应用","date":"2021-10-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.394Z","comments":true,"path":"2021/10/25/432一起玩转树莓派（18）——MPU6050螺旋仪加速度传感器模块应用/","link":"","permalink":"http://huishao.cc/2021/10/25/432一起玩转树莓派（18）——MPU6050螺旋仪加速度传感器模块应用/","excerpt":"","text":"一起玩转树莓派（18）——MPU6050陀螺仪加速度传感器模块应用一. 引言现在智能手机的功能已经非常强大，除了基础的通信功能外，测位测速，空间角度等数据的测量也非常方便，这在线路导航，地图，体感游戏等应用中十分重要。不知你是否想过，智能设备是如何获取到其所在的空间状态与加速度等数据的呢？MPU6050就是提供这类数据测量的一种传感器模块。 首先，通过树莓派来读取MPU6050传感器模块的数据并不复杂，MPU60X0是一款扩展性极强的数字运动处理器，我们本次实验使用的是封装好的功能模块，如下图所示： MPU6050芯片本身有24个引脚，每边有6个引脚，功能较多，引脚功能与定位如下图所示： 关于MPU6050的高级用法，可以通过查看芯片手册获取，本篇博客我们着重与在树莓派上对其进行应用。我们只需要关注所使用的模块的8个引脚即可。 二. 连线与准备工作本次实验我们使用的模块有8个引脚，只需要使用其中4个引脚即可实现功能。对于树莓派I2C协议总线的应用，本系列博客之前已经有非常多的实验有过应用。首先连接传感器模块与树莓派如下表： 传感器模块 树莓派 VCC +5V GND GND SCL SCL SDA SDA 开始使用I2C总线前，莫忘了开启树莓派的I2C功能，对I2C总线用法如果不太了解，可以阅读以下博客： https://my.oschina.net/u/2340880/blog/5142788 连线完成后，在树莓派的终端输入如下指令可以查看已经连接的I2C设备： 1sudo i2cdetect -y 1 如果连接无误，终端输出结果将如下图所示： 可以看到，图中显示的68即为我们所连接的传感器的地址。 下面，是时候了解下MPU6050传感器该如何使用了，我们知道，通过I2C总线，我们可以方便的读取设备中某个寄存器的数据，也可以向设备的某个寄存器写入数据，因此，使用MPU6050传感器的核心是了解其中寄存器的使用方法。我们将以使用到的几个寄存器为例做介绍，完整的寄存器用法可以从芯片手册上得到。 1. 电源管理寄存器电源管理寄存器的地址为107，对应十六进制数0x6b，它是一个8位的寄存器，其中第4位为保留位不能使用，功能如下： DECIVE_RESET: 这一位的作用是重置传感器，将传感器内部所有寄存器复位为初始状态，复位完成后，这一位会清零。 SLEEP: 睡眠控制位，当此位为1时，传感器将处于睡眠模式。需要注意，传感器启动时默认是睡眠模式，我们需要手动将其唤醒。 CYCLE:当设备设置为非睡眠模式时，即SLEEP位不为1，此为如果设置为1，传感器将处于循环模式，会按照寄存器108设置的速度进行数据循环采样。 TEMP_DIS:是否禁用温度传感器，设置为1时，禁用温度传感器。 CLKSEL:3位无符号数值，用来指令时钟源。 对于CLKSEL选项，其设置方式如下： CLKSEL值 意义 0 使用内部的8MHz的振荡器 1 使用陀螺仪X轴的频率 2 使用陀螺仪Y轴的频率 3 使用陀螺仪X轴的频率 4 使用外部的32.768kHz频率 5 使用外部19.2MHz频率 6 保留值 7 停止时钟并使振荡器保持复位状态 2. 陀螺仪数据寄存器陀螺仪数据寄存器的地址为67到72，共48个二进制位，如下： 这些寄存器都是只读的，不能写入。 67和68寄存器存储16位数据，为陀螺仪X轴的测量数据。其中68寄存器存储低8位，67寄存器存储高8位。 69和70寄存器存储16位数据，为陀螺仪Y轴的测量数据。其中70寄存器存储低8位，69寄存器存储高8位。 71和72寄存器存储16位数据，为陀螺仪Z轴的测量数据。其中72寄存器存储低8位，71寄存器存储高8位。 需要注意，从这些寄存器取出的数据都是原始数据，要得到真正的陀螺仪测量的旋转角度，需要进行转换，其转换的单位与总量程有关，量程在寄存器27进行配置。 3. 陀螺仪配置寄存器陀螺仪配置寄存器的地址为27，是一个可读可写的寄存器，如下： XG_ST，YG_ST与ZG_ST这3位用来设置陀螺仪执行自检。FS_SEL用来设置陀螺仪的量程范围，低3位为保留位，无需使用。FS_SEL可设置的量程范围如下： FS_SEL 量程范围 灵敏度参数 0 ±250 °/s 131 1 ±500 °/s 65.5 2 ±1000 °/s 32.8 3 ±2000 °/s 16.4 对于不同的量程范围，我们获取到原始数据后，需要除以对应的灵敏度参数才能得到最终的陀螺仪数据。 4. 加速计数据寄存器加速计数据寄存器的地址为59到64，共48个二进制位，如下： 其使用方法与陀螺仪数据寄存器类似，同样需要在寄存器28来对加速计进行配置与设置量程，通过量程对应的灵敏度来计算得到真实的加速度值。 5. 加速计配置寄存器陀螺仪配置寄存器的地址为28，是一个可读可写的寄存器，如下： XA_ST，YA_ST，ZA_ST都是自检执行控制位，AFS_SEL用来设置量程，其与灵敏度对应关系如下： AFS_SEL 量程范围 灵敏度参数 0 ±2 16384 1 ±4g 8192 2 ±8g 4096 3 ±16g 2048 6. 温度数据寄存器温度数据寄存器的地址为65到66，共16个二进制位，如下： 对于测量到的温度数据为有符号数，需要采用如下的计算公式得到真实的摄氏度数据： 摄氏温度 = TEMP_OUT / 340 + 36.53 除此之外，还有许多功能传感器，如采样率配置等，有需要可以从芯片手册查到。 三. 编写代码完成了前面的基础准备工作，编写代码获取传感器模块的数据则非常容易，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8import smbusimport mathimport time# 电源控制寄存器地址power_regist = 0x6b# I2C模块初始化bus = smbus.SMBus(1)# 外接I2C设备的地址address = 0x68# 封装一些读取数据的功能函数# 读取一个字长度的数据(16位)def readWord(adr): high = bus.read_byte_data(address, adr) low = bus.read_byte_data(address, adr+1) val = (high &lt;&lt; 8) + low return val# 将读取到的数据转换为原码 (有符号数本身是采用补码方式存储的)def readWordReal(adr): val = readWord(adr) x = 0xffff # 首位为1 表示是负数 if (val &gt;= 0x8000): # 求原码 return -((x - val)+1) else: return val# 已知加速度求角度值def dist(a, b): return math.sqrt((a*a)+(b*b))def getRotationX(x, y, z): radians = math.atan2(y, dist(x,z)) return math.degrees(radians)def getRotationY(x, y, z): radians = math.atan2(x, dist(y,z)) return math.degrees(radians)# 设置电源模式bus.write_byte_data(address, power_regist, 0)while True: time.sleep(0.5) print(\"螺旋仪数据-----------\") gyroX = readWordReal(0x43) gyroY = readWordReal(0x45) gyroZ = readWordReal(0x47) print(\"X轴陀螺仪原始数据：\", gyroX, \"X轴每秒旋转度数：\", gyroX/131) print(\"Y轴陀螺仪原始数据：\", gyroY, \"Y轴每秒旋转度数：\", gyroY/131) print(\"Z轴陀螺仪原始数据：\", gyroZ, \"Z轴每秒旋转度数：\", gyroZ/131) print(\"加速度数据----------\") accelX = readWordReal(0x3b) accelY = readWordReal(0x3d) accelZ = readWordReal(0x3f) print(\"X轴加速度原始数据：\", accelX, \"X轴加速度：\", accelX/16384) print(\"Y轴加速度原始数据：\", accelY, \"Y轴加速度：\", accelY/16384) print(\"Z轴加速度原始数据：\", accelZ, \"Z轴加速度：\", accelZ/16384) print(\"摄氏温度数据--------\") temp = readWordReal(0x41) print(\"温度原始数据：\", temp, \"摄氏度：\", temp/340 + 36.53) print(\"旋转家角度数据-------\") print(\"X轴旋转度数：\", getRotationX(accelX/16384, accelY/16384, accelZ/16384)) print(\"Y轴旋转度数：\", getRotationX(accelX/16384, accelY/16384, accelZ/16384)) 在树莓派上运行上面代码，效果如下图所示： 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"自上而下的理解网络（1）——DNS篇","slug":"431自上而下的理解网络（1）——DNS篇","date":"2021-10-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.394Z","comments":true,"path":"2021/10/10/431自上而下的理解网络（1）——DNS篇/","link":"","permalink":"http://huishao.cc/2021/10/10/431自上而下的理解网络（1）——DNS篇/","excerpt":"","text":"自上而下的理解网络（1）——DNS篇一.引言现代生活中，网络可谓是无处不在，购物需要网络，付款需要网络，各种生活缴费需要网络，在各行各业的工作中，更是离不开网络。说到底，网络的作用无非是支持计算机间进行数据交换。世界各地有着不计其数的网络设备，这些网络设备是如何有序正常的进行数据交流的呢？网络以及各种协议的工作原理又是怎样的呢？本系列博客，我们将尝试自上而下的对网路的工作原理进行介绍，从应用层开始，逐层向下，详细的帮助你理解网络的核心工作原理。当然，网络协议多如牛毛，在网络分层中每一层的知识也是非常浩渺，希望这些博客可以起到抛砖引玉的作用，能够使你对于天天使用的互联网网络在宏观上有认识，在微观上也有了解。 二.访问网站的第一步是什么？说到网络，对于普通用户来说，使用最多的可能就是浏览各种网站了，虽然现在移动设备上的App基本代替了传统的PC应用和网站，但是这些App里提供的数据本质上网站中提供的数据并无不同，使用的网络技术并无不同。 我们知道，不论是访问网站还是App内进行接口请求，这些数据都是存储在“服务器”这种特殊的远程设备上的，要向服务器获取数据，首先我们需要找到服务器的位置，这很好理解，只有找到它，我们才能和它产生数据交流。互联网无论多大，本质上依然是通过电缆、光纤或各种无线设备这类连接介质连接在一起的，如果一台设备没有硬件上连接入互联网，那么说破天我们也无法和它产生数据交互。要找到一台互联网设备，实际上是通过其物理Mac地址来找到的，这就像现实中的门牌号一样，每家的门牌号都不同，说到这，我们要再老生常谈一下，抛出网络分层模型给你看： 关于这个网络分层模型，它在我们后面博客中的出境还少不了，现在你可以先不用管它，你只需要先知道物理层是负责设备物理媒介相关的协议，数据链路层通过硬件的Mac地址找到具体要网络设备，网络层通过IP协议来封装真实的Mac地址，传输层是对网络层的一种封装，TCP，UDP等传输协议在这一层工作，而最上层的应用层就是我们常说的网络应用协议，如DNS，HTTP，HTTPS和FPT协议工作在这一层。 关于网络分层模型，我们先把多说了，我们的宗旨是自上而下的理解网络，那么还是回到第一步来。我们在访问网站时，都会现在浏览器输入网站的地址，这通常是一个域名，例如我要访问自己的技术博客网站，我会在浏览器输入如下的地址： https://huishao.cc/ huishao.cc就是一个域名，首先只通过域名我们是找不到要访问的对方服务器的，这就好像现实中我要去小王家，可以我只知道小王的名字“王某某”是无法找到他的家的，我需要有一个住址簿，告诉我小王究竟住在哪了，这样我才能找到他。当然，此住址可能也不是真正的物理位置，可能是一个社区，比如小王住在“光明社区”，具体光明社区在哪，我们可以再通过查看地图获取。对应到互联网中，域名就是一个名字，它方便我们对网站进行记忆，IP地址则是要访问的对方在逻辑上的地址，这方便互联网的网络管理，最终的硬件地址则是真正的对方位置。IP地址到硬件地址的映射，等我们讨论到了再细聊，本篇博客我们就说域名到IP地址映射这一过程。 三. DNS服务器现在你应该已经明确，要通过域名找到某个设备，第一步是先得到此域名对应的IP地址，那么此IP地址是怎么得到的呢？首先，一定有一个地方维护了域名与IP地址的映射关系，如果你有过建站的经历，那么你一定进行过域名绑定操作，一个网站建成后，理论上就已经可以使用IP的方式来进行访问，但是为了易记和动态变动IP，通常会对其进行域名绑定。由域名获取到IP的这一过程，我们称之为域名解析。 域名解析是一种服务，提供域名解析服务的服务器即是DNS服务器，下图可以很形象的表示域名服务器的工作方式： 可以发现，映射表中记录了域名与IP间的映射关系，在实际的应用中，上图中描述的场景看似可行，实际却并非如此，世界上的域名与IP总数是一个非常庞大的数字，由一台服务器来维护所有域名IP信息几乎不可能，而且对于域名解析服务，请求量是巨大的，会有大量的用户频繁的进行域名解析请求，单服务器明显是不能满足需求的。因此，实际生产环境中的DNS解析是采用层层递进，多级缓存，递归查询的方式进行的。再看下图： 上图看似复杂，实际上只是描述了三个关键词：层层递进，多级缓存，递归查询。 四.DNS解析过程下面我们来解释域名要解析成正确的IP地址，要经过的几个重要过程。 1. 本机hosts文件 本机hosts文件是优先级最高的域名IP映射表，对于Mac操作系统，这个文件在根目录的etc文件夹下，我们可以直接将域名与对应的IP写在这个文件中，在进行域名解析时，首先会从这个文件中找。广播IP和本机IP对应的域名实际上就定义在这里，如下： 12127.0.0.1 localhost255.255.255.255 broadcasthost 你也可以在其中新增任意映射，例如将huishao.cc的域名映射到127.0.0.1的本机IP，保存后，在浏览器再输入huishao.cc，你将无法再访问到珲少的博客网站，如下图所示： 更多时候，hosts的正确用法是开发应用程序时，测试环境和正式环境可以将域名配置到不同的IP，这样无需应用程序代码中做逻辑，只需要切换hosts文件即可实现环境的切换。 2. 本机应用缓存 本机应用缓存是多级缓存中的第一级，例如当我们在浏览器中访问过某个域名后，其解析的结果会被浏览器缓存下来，当我们再次访问这个域名时，其首先会检查浏览器缓存，如果缓存能够命中此域名，则直接使用，缓存的有效时间会受TTL配置影响（我们后面会介绍）。 3. 本机系统缓存 与本机应用缓存类似，操作系统中也会有一份域名解析的缓存，如果本机应用缓存中没有命中，会从操作系统缓存中检查是否之前有过此域名的解析记录。如果能够命中则会直接使用。 4. 路由器域名解析缓存 如果本机系统缓存依然没有命中，而你的设备又是通过路由器接入的公网，此时你的域名解析服务很大可能是路由器提供的，可以打开网络设置的DNS一栏，观察DNS服务器的地址，如果是192.168.x.x类型内网地址，则说明是由路由器来完成DNS解析了。如下图所示： 路由器内，实际上也会缓存一张DNS解析表，会从其中寻找是否有可以命中的缓存，如果存在并且未过期，则直接使用。有时候，你会发现电脑可以直接使用IP访问网站但是无法使用域名进行访问，很大可能是路由器的DNS服务出问题了，最简单的解决方式就是将配置的DNS服务器IP地址改成公共的。 5. 访问本地域名服务器 如果以上的缓存都没有命中，那么逻辑上我们就需要通过外网的DNS服务来进行解析了，首先本地服务器（LDNS）来解析域名，这里的本地服务器是指城市或区域的DNS服务器，一般就有运营商部署在当地，距离近，性能好，并且也有缓存机制，几乎可以覆盖大多数的域名解析请求。 6. 转发与递归 如果你访问的域名比较冷门，本地服务器依然无法解析，则会进行转发，将此请求转发到更高级的运营商DNS服务器或者根DNS服务器，根DNS服务器会根据域名来返回顶级的域名服务器地址，本地服务器可以继续向顶级域名服务器请求解析。如此递归进行，直到解析成功，再将IP地址依次返回到我们的设备，并逐层做缓存，以便我们下次访问时可以快速得到响应。 上面过程中，我们有提到根域名服务器，其是最高级别的域名服务器，它负责返回顶级域名服务器，目前全球有13个根域名服务器站。顶级域名服务器用来针对某个顶级域名进行解析，例如.com顶级域名，.edu顶级域名，.cc顶级域名和.cn顶级域名等。顶级域名服务器在解析时会将查询到的主域名服务器返回。主域名服务器负责某个区域的域名解析，同样，主域名服务器会配套辅助域名服务器进行备份与分担负载。 五.DNS协议前面说了这么多，都是宏观上的认识。现在，我们要讨论一些更深入的东西了。虽然对于DNS是干什么的，解析的过程是怎样的我们有了一些了解。但是DNS协议究竟是怎么操作的呢？IP数据是怎么得到的？我们可以手动来进行DNS解析么？要了解这些问题，首先需要对DNS协议本身做个了解。 DNS协议是工作在应用层的一种协议，全称Domain Name System。DNS协议是基于UDP之上实现的，前面说过UDP是工作在传输层的一种网络协议，等我们说到它的时候再深入探讨。现在你只需要知道，基于UDP任何人都可以实现一个DNS解析服务。DNS解析分为两步，首先需要客户端向服务器发送一个DNS请求报文，服务器收到报文，解析完成后再返回一个DNS报文给客户端，此报文中就包含解析的数据。 DNS协议规定其请求报文与响应报文的结构是一致的，都包含Header，Question，Answer，Authority，Additional这5个部分。 1. Header部分Header部分的长度是一定的，固定为12个字节。DNS协议文档中有一张图，很好的描述了Header的数据结构： ID：ID占了两个字节，它是一个标识符，由客户端请求的时候填充，DNS服务器解析后，会将此ID返回，用来让客户端将响应与请求对应起来。 配置字段：上图中第2行的都是配置字段，其占了两个字节。 QR占1为，设置为0表示当前是DNS请求报文，设置为1表示当前为DNS响应报文。 Opcode占4位，此值由请求报文设置，并且被复制到响应报文返回。其用来设置查询的类型，设置为0表示标准查询，即由域名解析出IP，设置为1表示反向查询，即由IP反查出域名，设置为2用来查询服务器的状态，3-15为保留字段，以待后续使用。 AA字段占1位，只在返回的响应报文中有，0表示返回数据的服务器不是权威服务器，1表示返回数据的服务器是权威服务器。需要注意，返回的响应报文中可能有多个应答，此字段表明的是第一个应答的服务器类型。 TC字段占1位，表示此报文是否由于数据的传输大小而被截断，当此字段的为1时，数据不可信。 RD字段占1位，该值需要在请求报文中设置，响应报文会直接复制该值。此值表示是否希望服务器进行递归查询。 RA字段占1位，其在响应报文中设置，表示服务端是否支持递归查询。 Z字段占3位，是保留字段。 rcode字段占4位，是响应报文的响应码，0表示没有错误；1表示请求格式有误，服务端无法解析；2表示服务器出错；3表示请求的域名不存在；4表示服务器不支持这类请求；5表示服务器拒绝此次请求；6-15是保留参数。 QDCOUNT：占16位，表明Question部分包含的实例个数，是无符号数。 ANCOUNT：占16位，表明Answer部分包含的回答个数，是无符号数。 NSCOUNT：占16位，表明Authority部分包含的授权服务器数量，是无符号整数。 ARCOUNT：占16位，表明Additional部分中包含的资源记录数量，是无符号整数。 2. Question部分这个部分用来定义查询的问题，问题的个数在QDCOUNT指明，通常只会携带一个问题。每个问题的格式定义如下： QNAME：此部分字节数不定，描述要查询的域名。在解析的时候，这部分以0x00结尾。需要注意，域名通常由符号“.”进行分割，每段的长度不定，QNAME每段的开头会先指明此段的长度，以huishao.cc域名为例，其构造出的QNAME部分如下： 0x07 0x68 0x75 0x69 0x73 0x68 0x61 0x6f 0x02 0x63 0x63 0x00 其中最后一个字节0x00标记了QNAME部分的结束，0x07表示第一段的长度为7个字节，即0x68 0x75 0x69 0x73 0x68 0x61 0x6f是第一段，通过查询ascii码对照表可知，这段数据就是huishao，同理，之后的一个字节为0x02，表示第二段的长度为2个字节，0x63对应ascii表中的字母c，最终可以解析为huishao.cc。 QTYPE：占两个字节，对应查询的类型，定义如下： Type：意义 对应的值 A：iPv4主机地址 1 NS：权威域名服务器 2 MD：邮箱地址（弃用，使用MX） 3 MF：转发邮箱（弃用，使用MX） 4 CNAME：规范的别名 5 SOA：标记权威区域开始 6 MB：邮箱域名 7 MG：邮箱成员 8 MR：邮箱重命名域名 9 NULL：空的类型 10 WKS：服务描述 11 PTR：域名指针 12 HINFO：主机信息 13 MINFO：邮箱或者邮件列表信息 14 MX：邮件交换 15 TXT：字符串 16 AAAA: IPv6域名 28 上面列举的查询类型中，有两个我们需要额外关注，A和CNAME，A类型即是我们查询域名IP所要使用的，CNAME别名技术也很常用，后面会介绍。 QCLASS：占两个字节，表明查询的类别，定义如下： CLASS：意义 对应的值 IN：Internet查询 1 CS：弃用，RFC查询 2 CH：the CHOAS class 3 HS：Hesiod 4 进行DNS解析时，只需要设置成IN类即可。 3. Answer部分这部分是响应的返回数据，可能包含多条资源记录，其格式如下： NAME：此记录所属的域名，长度不定，需要注意，这一部分存放的可能是真正的域名（格式和QNAME一致），也可能是指针，指向真正存放域名的字节位置，甚至可以是一部分是域名，一部分是指针。这样做的好处是可以节省响应报文的数据空间，当检查到某个字节的高两位为11时，则此字节及之后一个字节就是一个指针。例如对于huishao.cc域名的解析，其响应的完整的DNS报文如下（16进制）： b3 a4 81 80 00 01 00 01 00 00 00 00 07 68 75 6973 68 61 6f 02 63 63 00 00 01 00 01 c0 0c 00 0100 01 00 00 02 58 00 04 b9 c7 6d 99 其中开头的12个字节为Header部，随后的16个字节为Question部，后面的即为Answer部，Answer部分开头的c0字节高两位为11，表明其是一个指针，占两个字节，c0，0c两个字节将前两位的1去掉后为十进制数12，表明NAME的真实值在第12个字节处开始，即复用了QNAME的数据。 TYPE：占两个字节，与QTYPE定义一致。 CLASS：占两个字节，与QCLASS定义一致。 TTL：占4个字节，此字段非常重要，标记了缓存的有效时长，单位是秒。顺便分析一下上面的数据，此DNS解析数据的缓存有效期为0x0258，即600秒，10分钟。 RDLENGTH：占两个字节，表明RDATA字段的字节数。 RDATA：真正的解析数据，与TYPE有关，如果是IPv4域名解析，此处为解析的结果。 4. Authority，Additional这两部分的数据结构与Answer部分完全一致，解析方式也完全一致。 六.纸上得来终觉浅，绝知此事要躬行通过前面的介绍，DNS协议的工作原理应该是明了了，如果需要更深入的了解细节，可以阅读其官方的文档： https://datatracker.ietf.org/doc/html/rfc1035 当然，如果你还是感觉云里雾里也没有关系，我们通过实践来验证理论。 1.抓个活物来看看Wireshark是一个网络封包分析软件，能够截取网络封包，对于网络传输的数据包进行分析十分方便。我们打开此软件后，找一个域名进行访问，即可抓取到对应的DNS数据包，以huishao.cc为例，如下图所示： 可以看到，Wireshark可以分析出此次网络交互的时间，发起方IP，目标方IP，协议类型，数据长度和相信信息。在上面的示例中，第一条记录是DNS请求报文，第二条记录是DNS响应报文。我们先看看DNS请求报文的数据： 可以看到，Wireshark将每一层网络协议都分析了出来，我们先只关注最上层的Domian Name System部分，这部分的十六进制数据是上图中选中的部分。可以发现其和我们上面介绍的协议格式是一一对应的。在看响应报文： 数据的格式也是完全对应的，理论诚不欺我啊。 2. 手动实现DNS解析下面，我们可以以huishao.cc域名为例，手动使用UDP协议来试一试发送DNS请求以及对请求到的数据进行解析。首先先看完整的测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/socket.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;netinet/in.h&gt;#include&lt;unistd.h&gt;// 定义NDS服务器的地址char *DNSServer = \"192.168.1.1\";// DNS报文中查询区域的查询类型#define A 1#define CNAME 5/***DNS报文首部**这里使用了位域*/struct DNS_HEADER &#123; // 2字节 unsigned short ID; // 需要注意，对于结构体中的位域 数据是从低字节开始填充的 // 1字节 unsigned char RD :1; unsigned char TC :1; unsigned char AA :1; unsigned char Opcode :4; unsigned char QR :1; // 1字节 unsigned char RCODE :4; unsigned char Z :3; unsigned char RA :1; // 2字节 unsigned short QCOUNT; // 2字节 unsigned short ANCOUNT; // 2字节 unsigned short NSCOUNT; // 2字节 unsigned short ARCOUNT;&#125;;/***DNS报文中查询问题区域 4个字节*/struct QUESTION &#123; unsigned short QTYPE;//查询类型 unsigned short QCLASS;//查询类&#125;;// 请求部分的结构typedef struct &#123; unsigned char *QNAME; struct QUESTION *question;&#125; QUERY;/***DNS报文中回答区域的常量字段 10个字节*/// 需要注意，因为此结构体中有short和int类型，我们需要将其设置为1字节对齐#pragma pack(1)struct R_DATA &#123; unsigned short TYPE; //表示资源记录的类型 unsigned short CLASS; //类 unsigned int TTL; //表示资源记录可以缓存的时间 unsigned short RDLENGTH; //数据长度&#125;;#pragma pack()/***DNS报文中回答区域的资源数据字段*/struct RES_RECORD &#123; unsigned char *NAME;//资源记录包含的域名 struct R_DATA *resource;//资源数据 unsigned char *rdata;&#125;;// DNS解析方法void DNS(unsigned char*);// 域名转换方法int ChangetoDnsNameFormat(unsigned char*, unsigned char*);/***实现DNS查询功能*/void DNS(unsigned char *host) &#123; // UDP目标地址 struct sockaddr_in dest; // DNS请求的数据结构 struct DNS_HEADER dns = &#123;&#125;; printf(\"\\n所需解析域名：%s\\n\", host); //建立分配UDP套结字 int s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //IPv4 dest.sin_family = AF_INET; //53号端口 DNS服务器用的是53号端口 dest.sin_port = htons(53); // 设置IP dest.sin_addr.s_addr = inet_addr(DNSServer);//DNS服务器IP /*设置DNS报文首部*/ dns.ID = (unsigned short) htons(getpid());//id设为进程标识符 dns.QR = 0; //查询 dns.Opcode = 0; //标准查询 dns.AA = 0; //不授权回答 dns.TC = 0; //不可截断 dns.RD = 1; //期望递归 dns.QCOUNT = htons(1); //1个问题 // 不需要的字段置为0 dns.RA = 0; dns.Z = 0; dns.RCODE = 0; dns.ANCOUNT = 0; dns.NSCOUNT = 0; dns.ARCOUNT = 0; // 进行查询的域名处理 先给100个字节大小 unsigned char *qname = malloc(100); // 转换后会将长度返回 int nameLength = ChangetoDnsNameFormat(qname, host);//修改域名格式 // 请求结构 QUERY question = &#123;&#125;; question.QNAME = qname; struct QUESTION qinfo = &#123;&#125;; qinfo.QTYPE = htons(A); //查询类型为A qinfo.QCLASS = htons(1); //查询类为1 question.question = &amp;qinfo; // 定义要发送的UDP数据 先给65536个字节 unsigned char buf[65536]; // 复制DNS头部数据到buf memcpy(buf, &amp;dns, sizeof(dns)); // 移动复制的指针 unsigned char *point = buf + sizeof(dns); // 复制请求的域名到buf memcpy(point, question.QNAME, nameLength); // 移动复制的指针 point = point + nameLength; // 复制要解析的域名到buf memcpy(point, question.question, sizeof(*question.question)); // buf的总长度 int length = sizeof(dns) + nameLength + sizeof(*question.question); //向DNS服务器发送DNS请求报文 printf(\"\\n\\n发送报文中...\"); if (sendto(s, (char*) buf, length, 0, (struct sockaddr*) &amp;dest,sizeof(dest)) &lt; 0) &#123; perror(\"发送失败！\"); &#125; printf(\"发送成功！\\n\"); // 从DNS服务器接受DNS响应报文 unsigned char recvBuf[65536]; int i = sizeof dest; printf(\"接收报文中...\\n\"); recvfrom(s, (char*) recvBuf, 65536, 0, (struct sockaddr*) &amp;dest,(socklen_t*) &amp;i); if (length &lt; 0) &#123; perror(\"接收失败！\"); &#125; printf(\"接收成功！\\n\"); // 将接收到的DNS数据头部解析到结构体 struct DNS_HEADER recvDNS = *((struct DNS_HEADER *)recvBuf); printf(\"\\n\\n响应报文包含: \"); printf(\"\\n %d个问题\", ntohs(recvDNS.QCOUNT)); printf(\"\\n %d个回答\", ntohs(recvDNS.ANCOUNT)); printf(\"\\n %d个授权服务\", ntohs(recvDNS.NSCOUNT)); printf(\"\\n %d个附加记录\\n\\n\", ntohs(recvDNS.ARCOUNT)); // 头部，域名部分和问题的静态部分长度 size_t headLength = sizeof(struct DNS_HEADER); size_t hostLength = strlen((const char*) qname) + 1; size_t qusetionLength = sizeof(struct QUESTION); // 定义指针，将位置移动到报文的Answer部 unsigned char *reader = &amp;recvBuf[headLength + hostLength + qusetionLength]; /* **解析接收报文 */ // 加2个字节，是因为解析的数据中，域名采用的是指针方式，占两个字节(实际情况这里需要判断是否是指针还是真的域名) reader = reader + 2; // 将Answer部分的静态数据解析到结构体 struct R_DATA answer = *((struct R_DATA*) (reader)); printf(\"回答类型：%x\\n\", ntohs(answer.TYPE)); printf(\"缓存时间：%d秒\\n\",ntohl(answer.TTL)); //指向回答问题区域的资源数据字段 reader = reader + sizeof(struct R_DATA); //判断资源类型是否为IPv4地址 unsigned char *ip = NULL; if (ntohs(answer.TYPE) == A) &#123; //解析到的IP数据 指针 ip = (unsigned char*) malloc(ntohs(answer.RDLENGTH)+1); for (int j = 0; j &lt; ntohs(answer.RDLENGTH); j++) &#123; ip[j] = reader[j]; &#125; ip[ntohs(answer.RDLENGTH)] = '\\0'; &#125; //显示查询结果 if (ip) &#123; long *p; p = (long*) ip; // inet_ntoa用来进行IP转换 printf(\"IPv4地址:%s\\n\", inet_ntoa(*(struct in_addr*)ip)); &#125; return;&#125;/***从www.baidu.com转换到3www5baidu3com*/int ChangetoDnsNameFormat(unsigned char* dns, unsigned char* host) &#123; int lock = 0, i, length = 0; strcat((char*) host, \".\"); for (i = 0; i &lt; strlen((char*) host); i++) &#123; if (host[i] == '.') &#123; *dns++ = i - lock; length ++; for (; lock &lt; i; lock++) &#123; *dns++ = host[lock]; length ++; &#125; lock++; &#125; &#125; *dns++ = '\\0'; length ++; return length;&#125;int main(int argc, const char * argv[]) &#123; unsigned char hostname[100] = \"huishao.cc\"; //由域名获得IPv4地址，A是查询类型 DNS(hostname); return 0;&#125; 上面的代码有详细的注释，你可以尝试运行下进行域名解析，需要注意，上面填写的192.168.1.1是本地路由器的域名服务器地址，你需要将其替换成自己的，当然你也可以使用通用的域名解析服务器，如114.114.114.144。上面的代码采用C语言编写，因此在处理数据的时候会有一些复杂，有些点需要注意。 1. 关于结构体位域简单理解，位域可以让结构体中的数据以Byte为单位已经存储，例如上面定义的DNS_HEADER结构体，我们按照DNS协议的结构对其内数据所占的位进行了定义，有一点需要额外注意，在定义结构体时，位域字段的顺序与实际填充的顺序是相反的，位域的填充是从低字节开始的，如上代码所示，对于1个字节的位域来说，我们定义的时候，先定义的RD字段，最后定义的QR字段，实际在存储数据时，这一个字节的最高位会存储QR，最低位会存储RD。 2. 关于字节对齐在定义结构体时，还有一个细节需要注意，如果结构体中的数据字节数不是一致的，则其创建的内存大小可能和实际所需要的并不一致，例如R_DATA结构体，其中有int和short类型的数据，则其会以4字节为标准进行对齐，我们需要手动设置其对齐位数，不然后续数据填充时会出现偏差。 3.网络字节序与主机字节序网络字节序是TCP/IP协议中定义的一种数据格式，其采用的是大端（big-endian）的排序方式，即对于一个字（两个字节）的数据，低字节在前，高字节在后。这与我们可读的主机字节序刚好是相反的，在C语言中，使用htons可以把short类型的数据进行网络和主机字节序的转换，htonl把long类型的数据进行网络和主机字节序的转换。 可以在如下地址下载到完整的上述代码： https://gitee.com/jaki/dns_c 温馨提示，上面代码中解析的域名只返回了一个A类型的解析应答，如果你解析其他域名，可能会有很多CNAME类型的应答，应答个数也可能不止一个，你可以尝试下优化下代码，完整的实现DNS的解析逻辑。 七. 结尾本篇博客到此就结束了，我相信你对从域名获取到IP的过程有了更多的认识，如果遇到了域名解析的问题，你应该明白如何查看响应结果来定位问题了，但是，这只是我们日常使用的网络中的第一步，目前我们连应用层的核心都还没有接触到，不积跬步，无以至千里，与君共勉。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ：316045346","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://huishao.cc/categories/计算机网络/"}],"tags":[],"keywords":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://huishao.cc/categories/计算机网络/"}]},{"title":"一起玩转树莓派（17）——BMP180数字压力传感器应用","slug":"430一起玩转树莓派（17）——BMP180数字压力传感器应用","date":"2021-09-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.393Z","comments":true,"path":"2021/09/25/430一起玩转树莓派（17）——BMP180数字压力传感器应用/","link":"","permalink":"http://huishao.cc/2021/09/25/430一起玩转树莓派（17）——BMP180数字压力传感器应用/","excerpt":"","text":"一起玩转树莓派（17）——BMP180数字压力传感器应用一.BMP180使用说明BMP180是一款高级的温度气压传感器，通过测量的气压值也可以计算出当前海拔高度。其压力测量范围为300-1100hPa，对应的海拔高度为正9000m-负500m。工作电压在1.8V到3.6V之间。体积小，精度高，采用I2C接口，使用非常方便。BMP180传感器在GPS导航，天气检测，海拔测量和垂直方向速度检测等方面有广泛的应用。本实验，我们尝试使用树莓派的I2C接口来读取BMP180的温度和气压值，并进行海拔高度的计算。 相对于本系列博客前面传感器实验案例，BMP180的使用略微复杂。在编写一款传感器的驱动代码之前，首先需要阅读对应的芯片手册。BMP180数据手册可以在如下地址找到，此手册有详细的BMP180的使用方法及温度气压数值的计算公式。 https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/RaspberryPi_I2C/files/BST-BMP180-DS000-09.pdf 本次实验使用的BMP180传感器元件如下图所示： 可以看到此元件有5个引脚，其中VCC引脚可以不做使用，SCL和SDA引脚是I2C总线通信引脚，3.3和GND用来接电源正负极。 1.1 使用校准数据对温度和气压进行补偿校准BMP180的压力和温度数据，必须通过传感器的校准数据进行补偿计算，校准数据可以通过读取其内部EEPROM存储器来获取，EEPROM (Electrically Erasable Programmable read only memory)又称为E2PROM，即带电可擦可编程只读存储器，等下我们会介绍校准数据的读取方法。 BMP180除了拥有压力温度物理传感器外，还包含E2PROM存储模块，ADC模数转换模块和控制单元等，核心电路图如下： E2PROM存储器中共存储176位数据，这176位数据被分为11个字，即11个校准系数，每个校准系数为2个字节16位数据。在计算温度和气压之前，需要先将这11个校准系数获取到，下图列出了使用I2C访问的寄存器地址： 需要注意，在这11个校准系数中，AC4，AC5和AC6这3个是无符号整数，其他的都是有符号的整数，对于有符号的整数，寄存器中本身存储的是补码，我们需要将其转换成原码数据。示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#coding:utf-8import smbus# 定义BMP180设备地址deviceAddress = 0x77# 有符号数的补码转换def getInt(data): r = data # 第1位为1表示是负数 # 对负数的补码再取补码即可得到源码 if (data &amp; 0x8000) != 0: d = data ^ 0xffff d = d + 1 r = -d return r# 封装的获取E2PROM存储器中数据的方法# sign参数表示是否是有符号数def readCalibrate(adrList, index, sign): value = (adrList[index] &lt;&lt; 8) + adrList[index + 1] if sign: return getInt(value) else: return value# 获取E2PROM存储其的数据# read_i2c_block_data为i2C读取一块数据的方法，第2个参数为寄存器地址，第3个参数为读取的字节数calibrationList = bus.read_i2c_block_data(deviceAddress, 0xAA, 22)# 获取需要的校准系数AC1 = readCalibrate(calibrationList, 0, True)AC2 = readCalibrate(calibrationList, 2, True)AC3 = readCalibrate(calibrationList, 4, True)AC4 = readCalibrate(calibrationList, 6, False)AC5 = readCalibrate(calibrationList, 8, False)AC6 = readCalibrate(calibrationList, 10, False)B1 = readCalibrate(calibrationList, 12, True) B2 = readCalibrate(calibrationList, 14, True)MB = readCalibrate(calibrationList, 16, True)MC = readCalibrate(calibrationList, 18, True)MD = readCalibrate(calibrationList, 20, True) 上面代码中deviceAddress为BMP180连接上I2C总线后的设备地址，后面在连线时，我们再介绍如何得到。read_i2c_block_data函数用来读取一块数据，从芯片手册可知，E2PROM存储器数据地址的起始是0xAA，且是连续的，我们直接将22个字节全部读出即可。 1.2 测量温度与压力数值BMP180对温度和压力的测量逻辑非常简单，先发出测量指令，之后等待一定的数据转换时间，之后即可直接通过I2C总线来读取测量数据。测量流程如下： 在上面的流程图中可以看到，发送测量温度指令后，等待4.5ms后即可读取温度数据，之后发送测量压力指令，等待一段时间后，即可获取压力数据，拿到原始的数据后通过一定的计算方式，即可算出最终的物理量。需要注意，测量压力所需要等待的转换时间与采样精度有关。 通过选择不同的采样精度，我们可以让BMP180工作在最适合的场景中，即实现功耗，性能和测量速度的按需调整。采样精度模式可选的有如下几种： 可以看到，功耗越低的模式(Mode)，采样数越少(Internal number of samples)，转换速度越快(Conversion time)，噪声越大(RMS noise)，精度越差。功耗的配置参数由oversampling_setting决定，后面我们会用到它。 1.3 计算温度和压力数据的全过程现在，我们已经了解了BMP180的一些使用细节，只需要按照芯片手册的步骤来测量和计算即可得到物理数据。完整的过程下图所示： 可以看到，上面流程图从Start开始后，一共有6个需要做的步骤，其中最后一步是展示数据，我们可以省略掉，还剩下5个核心步骤。 第一步：读取校准系数数据 这一步前面我们已经完成。 第二步：读取尚未进行补偿运算的温度数值 首先通过I2C总线向地位为0xF4的寄存器写入0x2E的指令数据，等待4.5ms后，0xF6（MSB）和0xF7（LSB）寄存器的值，最终计算出未补偿的温度数值为： UT = MSB &lt;&lt; 8 + LSB 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding:utf-8import smbusimport time# 定义BMP180设备地址deviceAddress = 0x77# 通过I2C读取设备某个寄存器的数据# regAdr 寄存器地址def readByte(device, regAdr): return bus.read_byte_data(device, regAdr)# 读取一个字的数据def readWord(device, regAdr): high = bus.read_byte_data(device, regAdr) low = bus.read_byte_data(device, regAdr + 1) res = (high &lt;&lt; 8) + low return res# 写入一个字节的数据def writeByte(device, regAdr, data): bus.write_byte_data(device, regAdr, data)# 有符号数的补码转换def getInt(data): r = data # 第1位为1表示是负数 # 对负数的补码再取补码即可得到源码 if (data &amp; 0x8000) != 0: d = data ^ 0xffff d = d + 1 r = -d return r# 获取原始的温度数据（未补偿）def getTemperature(): # 写入指令 writeByte(deviceAddress, 0xF4, 0x2E) # 等待温度数据转换 time.sleep(0.005) # 读取的数据为有符号数 value = readWord(deviceAddress, 0xF6) # 符号处理 return getInt(value) 第三步：获取未补偿的压力数据 与获取温度的原始数据类似，首先向0xF4寄存器写入数据0x34+(oss&lt;&lt;6)，其中参数oss即为software_oversampling_setting，即我们前面提到的采样精度参数，根据需要选择即可。之后等待一定的转换时间，此时间与oss参数的选择有关，上面表中已经列出。再读取0xF6（MSB），0xF7（LSB）和0xF8（XLSB）的数据，最后使用如下计算方式得到原始压力数据： UP = (MSB&lt;&lt;16 + LSB&lt;&gt; (8 - oss) 示例代码如下： 12345678910111213# 定义采样精度，这里取超高分辨率OSS = 3# 获取原始的压力数据 （未补偿）def getPressure(): # 写入指令 writeByte(deviceAddress, 0xF4, 0x34 + (OSS &lt;&lt; 6)) time.sleep(0.026) MSB = readByte(deviceAddress, 0xF6) LSB = readByte(deviceAddress, 0xF7) XLSB = readByte(deviceAddress, 0xF8) value = ((MSB &lt;&lt; 16) + (LSB &lt;&lt; 8) + XLSB) &gt;&gt; (8 - OSS) return value 第四步：计算真实的物理温度值 使用如下公式计算真正的物理温度值： X1 = (UT - AC6) * AC5 / (2^15) X2 = MC * (2^11) / (X1 + MD) B5 = X1 + X2 T = (B5 + 8) / (2^4) 示例代码如下： 12345678import math# 计算真实的温度def calculateTemperature(data): X1 = ((data - AC6) * AC5) / math.pow(2, 15) X2 = (MC * math.pow(2, 11)) / (X1 + MD) B5 = X1 + X2 T = (B5 + 8) / math.pow(2, 4) return T / 10.0 需要注意，最终计算的到的温度数值为0.1摄氏度单位，转换成摄氏度直接除以10即可。 第5步：计算真实的物理气压值 其他数据的计算相对复杂，公式如下： B6 = B5 - 4000 X1 = (B2 (B6 B6 / 2^12)) / 2^11 X2 = AC2 * B6 / 2^11 X3 = X1 + X2 B3 = (((AC1 * 4 + X3) &lt;&lt; OSS) + 2) / 4 X1 = AC3 * B6 / 2^13 X2 = (B1 (B6 B6 / 2^12)) / 2^16 X3 = ((X1 + X2) + 2) /2 ^2 B4 = AC4 *(UNSIGNED LONG)(X3 + 32768) / 2^15 B7 = ((UNSIGNED LONG)UP - B3) * (50000 &gt;&gt; OSS) 如果B7小于0x80000000，则 P = (B7 2) / B4 否则 P = (B7 / B4) 2 X1 = (P / 2^8) * (P / 2^8) X2 = (-7357 * P) / 2^16 P = P + (X1 + X2 + 3791) / 2^4 示例代码如下： 12345678910111213141516171819202122232425# 计算真实的气压def calculatePressure(temp, data): X1 = ((temp - AC6) * AC5) / math.pow(2, 15) X2 = (MC * math.pow(2, 11)) / (X1 + MD) B5 = X1 + X2 B6 = B5 - 4000 X1 = (B2 * (B6 * B6 &gt;&gt; 12)) &gt;&gt; 11 X2 = AC2 * B6 &gt;&gt; 11 X3 = X1 + X2 B3 = (((AC1 * 4 + X3) &lt;&lt; OSS) + 2) &gt;&gt; 2 X1 = (AC3 * B6) &gt;&gt; 13 X2 = (B1 * (B6 * B6 &gt;&gt; 12)) &gt;&gt; 16 X3 = ((X1 + X2) + 2) &gt;&gt; 2 B4 = AC4 * (X3 + 32768) &gt;&gt; 15 B7 = (data - B3) * (50000 &gt;&gt; OSS) if (B7 &lt; 0x80000000): P = (B7 * 2) / B4 else: P = (B7 / B4) * 2 X1 = (P &gt;&gt; 8) * (P &gt;&gt; 8) X1 = (X1 * 3038) &gt;&gt; 16 X2 = (-7357 * P) &gt;&gt; 16 P = P + ((X1 + X2 + 3791) &gt;&gt; 4) # 单位为Pa 转换为hPa除以100即可 return P /100.0 二. 实验-使用BMP180测量温度、气压和海拔高度通过前面的介绍，一些核心的功能代码我们其实都已经实现，首先先将BMP180与树莓派相连： BMP180 树莓派 3.3 3.3V GND GND SCL SCL SDA SDA 要计算海拔高度，可以使用如下公式： 其中p0可以取海平面的标准大气压1013.25hPa。 连好线后，首先确认树莓派开启了I2C总线，如下： 在树莓派的终端使用如下指令可以查看外接的元件地址： 1sudo i2cdetect -y 1 可以看到如下图所示的输出： 其中0x77即为BMP180设备地址。 下面给出完整的实验代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#coding:utf-8import smbusimport timeimport math# 初始化bus = smbus.SMBus(1)# 定义BMP180设备地址deviceAddress = 0x77# 通过I2C读取设备某个寄存器的数据# regAdr 寄存器地址def readByte(device, regAdr): return bus.read_byte_data(device, regAdr)# 读取一个字的数据def readWord(device, regAdr): high = bus.read_byte_data(device, regAdr) low = bus.read_byte_data(device, regAdr + 1) res = (high &lt;&lt; 8) + low return res# 写入一个字节的数据def writeByte(device, regAdr, data): bus.write_byte_data(device, regAdr, data)# 有符号数的补码转换def getInt(data): r = data # 第1位为1表示是负数 # 对负数的补码再取补码即可得到源码 if (data &amp; 0x8000) != 0: d = data ^ 0xffff d = d + 1 r = -d return r# 封装的获取E2PROM存储器中数据的方法# sign参数表示是否是有符号数def readCalibrate(adrList, index, sign): value = (adrList[index] &lt;&lt; 8) + adrList[index + 1] if sign: return getInt(value) else: return value# 获取E2PROM存储其的数据# read_i2c_block_data为i2C读取一块数据的方法，第2个参数为寄存器地址，第3个参数为读取的字节数calibrationList = bus.read_i2c_block_data(deviceAddress, 0xAA, 22)# 获取需要的校准系数AC1 = readCalibrate(calibrationList, 0, True)AC2 = readCalibrate(calibrationList, 2, True)AC3 = readCalibrate(calibrationList, 4, True)AC4 = readCalibrate(calibrationList, 6, False)AC5 = readCalibrate(calibrationList, 8, False)AC6 = readCalibrate(calibrationList, 10, False)B1 = readCalibrate(calibrationList, 12, True) B2 = readCalibrate(calibrationList, 14, True)MB = readCalibrate(calibrationList, 16, True)MC = readCalibrate(calibrationList, 18, True)MD = readCalibrate(calibrationList, 20, True)# 获取原始的温度数据（未补偿）def getTemperature(): # 写入指令 writeByte(deviceAddress, 0xF4, 0x2E) # 等待温度数据转换 time.sleep(0.005) # 读取的数据为有符号数 value = readWord(deviceAddress, 0xF6) # 符号处理 return getInt(value)# 定义采样精度，这里取超高分辨率OSS = 3# 获取原始的压力数据 （未补偿）def getPressure(): # 写入指令 writeByte(deviceAddress, 0xF4, 0x34 + (OSS &lt;&lt; 6)) time.sleep(0.026) MSB = readByte(deviceAddress, 0xF6) LSB = readByte(deviceAddress, 0xF7) XLSB = readByte(deviceAddress, 0xF8) value = ((MSB &lt;&lt; 16) + (LSB &lt;&lt; 8) + XLSB) &gt;&gt; (8 - OSS) return value# 计算真实的温度def calculateTemperature(data): X1 = ((data - AC6) * AC5) / math.pow(2, 15) X2 = (MC * math.pow(2, 11)) / (X1 + MD) B5 = X1 + X2 T = (B5 + 8) / math.pow(2, 4) return T / 10.0# 计算真实的气压def calculatePressure(temp, data): X1 = ((temp - AC6) * AC5) / math.pow(2, 15) X2 = (MC * math.pow(2, 11)) / (X1 + MD) B5 = int(X1 + X2) B6 = B5 - 4000 X1 = (B2 * (B6 * B6 &gt;&gt; 12)) &gt;&gt; 11 X2 = AC2 * B6 &gt;&gt; 11 X3 = X1 + X2 B3 = (((AC1 * 4 + X3) &lt;&lt; OSS) + 2) &gt;&gt; 2 X1 = (AC3 * B6) &gt;&gt; 13 X2 = (B1 * (B6 * B6 &gt;&gt; 12)) &gt;&gt; 16 X3 = ((X1 + X2) + 2) &gt;&gt; 2 B4 = AC4 * (X3 + 32768) &gt;&gt; 15 B7 = (data - B3) * (50000 &gt;&gt; OSS) if (B7 &lt; 0x80000000): P = int((B7 * 2) / B4) else: P = int((B7 / B4) * 2) X1 = (P &gt;&gt; 8) * (P &gt;&gt; 8) X1 = (X1 * 3038) &gt;&gt; 16 X2 = (-7357 * P) &gt;&gt; 16 P = P + ((X1 + X2 + 3791) &gt;&gt; 4) # 单位为Pa 转换为hPa 除以100即可 return P / 100.0while True: t = getTemperature() temp = calculateTemperature(t) press = calculatePressure(t, getPressure()) high = 44330 * (1 - math.pow((press / 1013.25), 1.0) / 5.255) print('温度：%f, 气压：%f, 海拔：%f'%(temp, press, high)) time.sleep(1) 运行上面代码，测量结果如下图所示： 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（16）——旋转编码传感器","slug":"429一起玩转树莓派（16）——旋转编码传感器","date":"2021-09-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.393Z","comments":true,"path":"2021/09/22/429一起玩转树莓派（16）——旋转编码传感器/","link":"","permalink":"http://huishao.cc/2021/09/22/429一起玩转树莓派（16）——旋转编码传感器/","excerpt":"","text":"一起玩转树莓派（16）——旋转编码传感器旋转编码传感器是一种速度位移传感器。其通过旋钮的旋转来带动内部的光栅盘旋转，光栅盘上会预置很多狭缝，光栅盘的转动导致经过狭缝的光线产生脉冲变化，此信号经过后继电路的处理后，输出成脉冲信号。最终，我们可以通过信号引脚的输出来获取旋钮的旋转动作。 本次实验，使用的旋转编码传感器如下图所示： 通过内部发光源与光敏元件的配置，旋转时产生脉冲信号，示意图如下： 我们使用的传感器有5个引脚，其中除了电源和接地引脚外，还有3个信号引脚。SW引脚为复位信号引脚，此旋转编码传感器本身也是一个按钮，当按下此按钮时，SW引脚会从高电平跳变为低电平。CLK引脚为旋转信号引脚，未旋转时，此引脚输出高电平，旋转时输出低电平。DT引脚用来判定旋转的方向，如果未旋转时此引脚为高电平，旋转时变低电平，则表示发生了顺时针旋转，如果未旋转时此引脚为低电平，发生旋转时此引脚为高电平，则表示发生了逆时针旋转。 下面，我们来连接树莓派进行实验，接线如下： 旋转编码传感器 树莓派 VCC +5V GND GND CLK GPIO17 （BCM编码） DT GPIO18 （BCM编码） SW GPIO19 （BCM编码） 编写实验代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8import RPi.GPIO as GPIOimport time# 定义引脚resetPin = 35 # BCM编码为19的GPIO 物理编码为35clkPin = 11dtPin = 12# 计数变量clockwise = 0anticlockwise = 0 # 进行引脚初始化GPIO.setmode(GPIO.BOARD)GPIO.setup(clkPin, GPIO.IN)GPIO.setup(dtPin, GPIO.IN)GPIO.setup(resetPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)# 注册中断函数def reset(channel): global clockwise, anticlockwise clockwise = 0 anticlockwise = 0 print('计数复位')# 监听下降沿GPIO.add_event_detect(resetPin, GPIO.FALLING, callback=reset)# 开启主循环while True: lastDT = GPIO.input(dtPin) # 高电平 没有发生旋转动作 while GPIO.input(clkPin): pass # 开始旋转 currentDT = GPIO.input(dtPin) if (lastDT == 1) and (currentDT == 0): # 顺时针 clockwise += 1 print('顺时针旋转计数：%d'%(clockwise)) if (lastDT == 0) and (currentDT == 1): # 逆时针 anticlockwise += 1 print('逆时针旋转计数：%d'%(anticlockwise)) 运行代码，效果如下图所示： 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（15）——干簧管传感器","slug":"428一起玩转树莓派（15）——干簧管传感器","date":"2021-09-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.393Z","comments":true,"path":"2021/09/16/428一起玩转树莓派（15）——干簧管传感器/","link":"","permalink":"http://huishao.cc/2021/09/16/428一起玩转树莓派（15）——干簧管传感器/","excerpt":"","text":"一起玩转树莓派（15）——干簧管传感器干簧管传感器又被称为磁簧开关。顾名思义，其功能是可以感知周围的磁场从而改变开关的状态。本次实验，我们使用的干簧管传感器模块如下图所示： 可以看到，此模块的核心是一个磁簧开关，附带LED指示灯与灵敏度调节电阻。磁簧开关的工作原理非常简单，两片金属薄片密封于一个玻璃管内，金属片间有非常细的一个缝隙，常态下，两金属片不连通，电路断开，当有磁场靠近玻璃管时，外加的磁场会使两金属片端点附近产生不同的磁极，从而吸引闭合，电路接通。玻璃管内通常会充满惰性气体或者抽成真空状态，使得干簧管性能和耐用度可以最大程度的提高。 本实验所使用的干簧管模块电路原理如下图所示： 此模块包含两个LED提示灯，当接通电源时，电源提示LED灯亮，当磁簧开关闭合时，输出提示LED灯亮。 在本实验中测试干簧管模块的开关功能，还需要准备一个磁石。干簧管模块与树莓派连线如下： 干簧管模块 树莓派 VCC 3.3V电源 GND GND DO GPIO17（BCM编码） 本实验代码本身非常简单，如下： 123456789101112131415161718192021222324#coding:utf-8import RPi.GPIO as GPIOreed = 11def trigger(channel): print('当前开关状态：%s'%('关' if GPIO.input(reed) else '开'))def setup(): GPIO.setmode(GPIO.BOARD) # 当开关未闭合时，信号引脚将输出高电平，默认设置上拉电阻 GPIO.setup(reed, GPIO.IN, pull_up_down=GPIO.PUD_UP) GPIO.add_event_detect(reed, GPIO.BOTH, callback=trigger, bouncetime=200)def destroy(): GPIO.cleanup()if __name__ == '__main__': setup() try: while True: pass # 主动退出时 清除资源 except KeyboardInterrupt: destroy() 在树莓派上运行上面代码，当使用磁体靠近干簧管时，即可通过打印信息看到开关状态，同样也可以通过信号指示灯的明暗来获知磁簧开关的状态。如下图所示： 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（13）——雨滴检测传感器","slug":"426一起玩转树莓派（13）——雨滴检测传感器","date":"2021-09-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.392Z","comments":true,"path":"2021/09/09/426一起玩转树莓派（13）——雨滴检测传感器/","link":"","permalink":"http://huishao.cc/2021/09/09/426一起玩转树莓派（13）——雨滴检测传感器/","excerpt":"","text":"一起玩转树莓派（13）——雨滴检测传感器在本系列的前几篇博客中，我们有进行过温度传感器和光强传感器的实验。通过这些传感器，加上简单的编程技术，我们很容易获取这些环境数据。通过各种丰富的传感器，用树莓派可以非常容易的打造一款”简易气象站“。对于一个小型的气象站来说，除了需要收集温度和光照强度数据外，当前的天气状况也是必不可少的。本篇博客，我们将通过雨滴检测传感器实验来获取雨势信息。 一、雨滴检测传感器本次实验使用的雨滴检测传感器模块如下图所示： 可以看到，此元件组由一个检测板和控制模块组成，两部分分开连接，便于将检测板放置到合适的检测位置，且检测板面积大，易于进行雨滴检测。 此传感器模块工作电路图如下所示： 在使用时，先将检测板的两个引脚与模块的只有两个引脚一侧的引脚相连(可以将检测板理解为两根不想交的导线，有雨水落下时，导线会联通)。 观察控制模块，可以看到其上封装了两个LED，其中一个LED是电源指示灯，当接通电源后会发光，另一个LED是信号灯，没有雨水的时候信号灯不亮，检测板上有雨水的时候信号灯亮。在检测是否下雨时，可以将检测板倾斜放置，有雨水流过即可改变电平信号的输出。控制模块中还自带一个调节电阻，调节此电阻可以设置传感器的灵敏度。控制模块的另一侧有4个引脚，分别为AO，DO，GND和VCC。其中，AO为模拟信号输出，可以通过这个引脚输出的信号来判断雨量的大小。DO引脚为数字信号输出，可以用这个引脚输出的信号判断检测板上是否有雨水，没有水滴时此引脚输出高电平，有水滴时此引脚输出低电平。 二、实验连线与编码本次实验，我们将使用GPIO引脚直接获取雨滴检测模块的数字信号，并通过PCF8591来读取雨滴检测模块的模拟信号。首先，连线如下： PCF8591与树莓派连接： PCF8591 树莓派 SDA SDA SCL SCL VCC 5V电源 GND GND 雨滴检测模块： 雨滴检测模块 树莓派 PCF8591 VCC 5V GND GND AO AIN0 DO GPIO17(BCM编码) 完成了基础的连线，我们就可以开始编码工作了。关于PCF8591的使用，我们之前的博客有过详细的介绍，但是如果每次使用到数模转换时，都编写一遍PCF8591的控制代码会非常的麻烦，而且这也不是我们要核心关注的功能点，对于本实验来说，我们更多需要关注的是如何处理雨滴检测模块的数据，而不是DA转换相关逻辑，因此我们可以编写一套通用的PCF8591驱动代码，之后再使用到有模拟信号输出的元件时，直接使用此驱动即可。 需要注意，要使用PCF8591，不要忘记打开树莓派的I2C接口，接线完成后，使用如下指令可以查看设备地址： 1sudo i2cdetect -y 1 完整代码如下： 12345678910111213141516171819202122232425262728293031323334#coding:utf-8import smbus #在程序中导入“smbus”模块# /dev/i2c-1bus = smbus.SMBus(1) #创建一个smbus实例# 初始化驱动模块 定义PCF元件地址def init(addr): global address address = addr# 读取某个通道的数据def read(chn): global address if chn == 0: #发送一个控制字节到设备 表示要读取AIN0通道的数据 bus.write_byte(address,0x40) if chn == 1: #发送一个控制字节到设备 表示要读取AIN1通道的数据 bus.write_byte(address,0x41) if chn == 2: #发送一个控制字节到设备 表示要读取AIN2通道的数据 bus.write_byte(address,0x42) if chn == 3: #发送一个控制字节到设备 表示要读取AIN3通道的数据 bus.write_byte(address,0x43) bus.read_byte(address) # 空读一次，消费掉无效数据 return bus.read_byte(address) # 返回某通道输入的模拟值A/D转换后的数字值def write(val): global address temp = val temp = int(temp) # 进行写数据操作 bus.write_byte_data(address, 0x40, temp) 实现水滴检测的代码如下： 123456789101112131415161718#coding:utf-8import pcf8591 as PCFimport RPi.GPIO as GPIOimport timeDO = 11# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)GPIO.setup(DO, GPIO.IN)PCF.init(0x48)while True: print('------------分割线-------------') rainDO = GPIO.input(DO) print('是否检测到水滴：%s'%('否' if rainDO else '是')) # 读取AIN0的模拟数据 rainAO = PCF.read(0) print('雨水程度%d'%(255 - rainAO)) time.sleep(2) 在树莓派上运行上面程序，即可检测水滴情况。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（14）——超声测距","slug":"427一起玩转树莓派（14）——超声测距","date":"2021-09-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.393Z","comments":true,"path":"2021/09/09/427一起玩转树莓派（14）——超声测距/","link":"","permalink":"http://huishao.cc/2021/09/09/427一起玩转树莓派（14）——超声测距/","excerpt":"","text":"一起玩转树莓派（14）——超声测距当今，汽车行业的发展可谓是日新月异。智能汽车的概念也越来越火热。自动驾驶也将得到越来越广泛的应用。不知你有没有想过，平时我们在人工驾驶汽车时，主要使用的是视觉来感知距离，对于人工智能来说，它是如何通过感知距离来获取周围环境信息的呢？这就需要使用到相关的测距传感器。 一、超声测距传感器我们知道，超声波频率高，相对于普通声波，其能量消耗慢，传播距离远且指向性很强。十分适合用来进行距离的测量。本次实验，我们使用HC-SR04超声测距模块来进行距离测量。元件如下图所示： 如上图所示，HC-SR04模块有一个超声发生器（T端）和一个超声收集器（R端）以及4个引脚。在网上很容易购买到此模块，其价格低廉，精准度高，使用简单，性价比非常高。HC-SR04硬件原理图如下： 模块内部电路结构虽然看上去非常复杂，但是我们使用它来测距并不需要了解其内部完整的工作原理，要进行距离的测定，离不开公式s = v * t。如果要计算出距离s，需要得知速度v和时间t，声波的速度v是一定的，我们可以取340m/s，时间t就是HC-SR04模块能够帮助我们得到的。 超声测距的核心原理是通过发生源发出超声波，当超声波遇到障碍时会被反射，反射的超声波可以被感知源感知到，从声波发出到被感知到这之间的时间就是超声波从模块到障碍物间传递一次来回所使用的时间。如下图所示： 对于HC-SR04模块，其Trig引脚是触发引脚，向其发10us以上的高电平即可触发发送超声波指令，HC-SR04模块会自动发送8个40kHz的方波，当发送完成后，Echo引脚会输出高电平，当收到反射回来的声波后，Echo会重新变回低电平。因此，在使用HC-SR04模块时，我们只需要通过向Trig引脚加高电平触发测量指令，之后监听Echo引脚高电平的持续时间，即可完成测距工作。 二、连线与编码我们选择BCM编码下的GPIO17来控制超声发生Trig引脚，使用GPIO18来获取Echo引脚的电平。连线如下： HC-SR04模块 树莓派 VCC +5V电源 GND GND Trig GPIO17(BCM编码) Echo CGIO18(BCM编码) 编写如下代码： 1234567891011121314151617181920212223242526272829303132333435363738#coding:utf-8import RPi.GPIO as GPIOimport time# 触发声波引脚trig = 11# 监听信号echo = 12def getDistance(): # 输出高电平 GPIO.output(trig, GPIO.HIGH) # 持续15us高电平 触发超声波 time.sleep(0.000015) # 停止加高电平 GPIO.output(trig, GPIO.LOW) # 开始检测信号引脚的电平为高电平时开始计时 while GPIO.input(echo) == 0: pass t1 = time.time() # 信号引脚的电平为低电平时计算时间间隔 while GPIO.input(echo) == 1: pass t2 = time.time() # 计算距离 s = (t2 - t1)*340/2 return sGPIO.setmode(GPIO.BOARD)GPIO.setup(trig, GPIO.OUT, initial=GPIO.LOW)GPIO.setup(echo, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)while True: s = getDistance() print(\"当前距离前方障碍物：%fm\"%(s)) time.sleep(1) 在树莓派中运行上面代码，即可实现超声波测距，效果如下图： 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（12）——U型光电传感器","slug":"425一起玩转树莓派（12）——U型光电传感器","date":"2021-09-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.392Z","comments":true,"path":"2021/09/07/425一起玩转树莓派（12）——U型光电传感器/","link":"","permalink":"http://huishao.cc/2021/09/07/425一起玩转树莓派（12）——U型光电传感器/","excerpt":"","text":"一起玩转树莓派（12）——U型光电传感器本篇博客，我们将使用U型光电传感器实现一个简单的测速工具。本实使用的元件简单，实验的原理也非常简单。 一、关于U型光电传感器U型光电传感器由于其有一个U型的凹槽而得名。其凹槽的一侧会发射红外光，凹槽的另一侧装有接收装置。通过对红外光的遮挡与导通，从而改变元件信号源引脚的电平高低。基于这种特性，我们很容易使用U型光电传感器来测量是否有物体遮挡光线。在测速领域，运用广泛。 本实验使用的传感器模块如下图所示： 可以看到，此元件有3个引脚，GND引脚为接地引脚，VCC引脚为电源引脚，OUT引脚是输出引脚，当接收器能够接收到从发射源发出的光线时，输出引脚为低电平，当光线被阻断时，输出引脚为高电平。 二、计数器 OR 测速器U型光电传感器有着非常广泛的应用，试想一下，如果一个车间流水线在不停的生产商品，如何方便的对生产的商品数量进行自动计数？这时我们就可以将一个U型光电传感器安装到商品的传送带上，只要有商品从传送带上通过，即会挡住传感器发射源发出的红外光，从而触发电平的跳变，实现计数功能。除此之外，U型光电传感器也可以方便的实现测速，我们只要知道了物体的长度和物体通过U型传感器的时间，就可以使用公式**_v = s / t_**从而计算出物体运动的速度。下面我们就来编写代码实现这两个功能。 首先，元件与树莓派连线如下： U型光电传感器 树莓派 VCC 3.3V电源 GND GND OUT GPIO17(BCM编码) 编写如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#coding:utf-8import RPi.GPIO as GPIOimport time# 采用物理编码GPIO.setmode(GPIO.BOARD)# BCM GPIO17的物理编码是11out_pin = 11# 0 计数模式 1 测速模式MODE = 0count = 0# 测速模式下，需要初始化长度S 单位为毫米S = 10t1 = 0t2 = 0# 进行引脚的初始化，不被遮挡时为低电平，使用低电平的下拉电阻GPIO.setup(out_pin, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)# 定义回调函数def switch_state(pin): global count,t1,t2 # 如果是高电平 if GPIO.input(pin): print(\"物体遮挡\") if MODE == 0: count += 1 else: t1 = time.time() else: print(\"物体遮挡消失\") if MODE == 0: print('计数器-数量：%d'%(count)) else: t2 = time.time() t = t2 - t1 v = S / t print('测速器-速度%fmm/s'%(v))GPIO.add_event_detect(out_pin, GPIO.BOTH, callback=switch_state)while True: pass 如上代码所示，我们可以设置MODE变量来让元件工作在计数模式下或者测速模式下。在树莓派上运行此代码，尝试下计数和测速的功能吧。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（11）——使用LCD屏","slug":"424一起玩转树莓派（11）——使用LCD屏","date":"2021-08-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.392Z","comments":true,"path":"2021/08/28/424一起玩转树莓派（11）——使用LCD屏/","link":"","permalink":"http://huishao.cc/2021/08/28/424一起玩转树莓派（11）——使用LCD屏/","excerpt":"","text":"一起玩转树莓派（11）——使用LCD屏通过本系列博客前几篇文章的介绍，我们已经体验过了许多传感器元件，它们大多非常简单，可以直接对其进行数据读取或写入，无需复杂的指令配置。本篇博客，我们将介绍一个相对复杂的元件：LCD屏。当今大多数常见的电子设备为了便于用户操作，都会配备一块LCD液晶显示屏，用户通过屏幕可以获取到设备的相关信息方便使用。下面，我们将尝试使用树莓派来在LCD屏上展示信息。 一、LCD 1602LCD屏是Liquid Crystal Display的简称，即液晶显示屏。LCD 1602是一种点阵式的给付型液晶显示屏，其型号为1602本身也是有意义的，表示其可以显示2行信息，每行可以显示16个字符。LCD1602最多可以显示32个字符，价格上也并不昂贵，十几元钱即可买到。LCD1602有16个引脚，如下图所示： LCD1602的16个引脚看上去很多，但实际上使用起来并不复杂，我们首先将上图这些引脚的功能来介绍一下。 引脚1：接地引脚 引脚2：接5V电压 引脚3：VE引脚为屏幕对比度调整引脚，接地时对比度最大，接正极电源时对比度最小。 引脚4：RS引脚为功能模式引脚(也被称为寄存器选择引脚)，为其加高电平时为数据模式(存取屏幕展示的数据)，为其加低电平时为指令模式(读取指令)。 引脚5：RW引脚为读写模式引脚，为其加高电平时为读操作，为其加低电平时为写操作。 引脚6：Enable引脚，此引脚用来触发动作，负跳变时进行数据处理或指令的执行。 引脚7-引脚14：这8个引脚为数据引脚，用来进行数据传输。 引脚15：背光电源引脚。 引脚16：背光接地引脚。 上面所介绍的引脚中，引脚1，引脚2，引脚15和引脚16比较好理解，其都是作为供电功能，无需编程操作。引脚3是一个单独调增对比度功能的引脚，作用也相对独立，无需复杂的指令操作。引脚4和引脚5是比较核心的两个引脚，这两个引脚的高低电平状态组合共有4种，分别会将LCD1602设置为读指令模式，写指令模式，读数据模式和写数据模式。引脚6可以理解为一个触发引脚，通过操作这个引脚的电平跳变来让LCD1602执行具体的功能。引脚7-引脚14用来进行数据的存取或指令的存取。 现在请你务必将上面所介绍的内容完全理解，否则后面的内容可能会更加令你迷惑。对于LCD1206的读数据模式和写数据模式你应该没有什么疑惑，只要通过引脚4和引脚5设置正确的模式后，再通过GPIO来写和读引脚7到引脚14的电平数据，即可得到一个8位的数据。我们核心需要理解的是指令模式，LCD1602的指令集如下： 上图中的RS和R/W就是引脚4和引脚5，其控制模式，与指令本身无关，我们可以先不关心。从DB7到DB0是真正的指令部分。我们下面来逐一介绍。 1. 指令一：0000 0001 清屏指令，响应时间为1.53ms。 2.指令二：0000 001- (最后一位’-‘表示0和1都可以，不被关心) 光标归位指令，执行后光标的位置会回到起点，但是数据寄存器中的数据不会清空。 3.指令三：0000 01[I/D][SH] 光标移动模式设置指令，I/D和SH两个控制为光标或屏幕移动模式。 I/D设置为0：每次读取一个字符后光标左移。 I/D设置为1：每次读取一个字符后光标右移。 SH设置为0：屏幕不移动。 SH设置为1：屏幕移动，方向与I/D的设置一致。 4.指令四：0000 1[D][C][B] 显示模式设置指令，D，C，B这三个位分别设置主显示功能，光标显示功能，光标闪烁功能。 D：设置为0则关闭屏幕，设置为1开启屏幕。 C：设置为0关闭光标，设置为1显示光标。 B：设置为0光标不闪烁，设置为1光标闪烁。 5.指令五：0001 [S/C][R/L]– 设置光标和显示屏移动方向。 S/C设置为0时，R/L设置为0则光标左移，RL设置为1时光标右移。 S/C设置为1时，R/L设置为0则显示内容左移，R/L设置为1则显示内容右移。 6.指令六：001[DL] [N][F]– 功能模式设置指令。 DL：设置为1时采用8位总线读数据，设置为0时采用4位总线读数据。 N：设置为0时是单行显示模式，设置为1时是双行显示模式。 F：设置为0时为5*8的点阵字符，设置为1时为5*11的点阵字符。 7.指令七：01[A5][A4] [A3][A2][A1][A0] 设置下一个字符要显示的位置。A5位设置要定位到的行，A0到A4位定位要显示的位置，取值为0-16之间。 8.指令八：1[A6][A5][A4] [A3][A2][A1][A0] 数据寄存器地址设置。 了解了LD1602显示屏上面的指令用法，我们就可以编程来控制显示屏显示的内容了。 二、带I2C模块的LCD 1602前面我们说过，LCD1602有16个引脚。原则上我们已经可以使用树莓派来控制显示屏的显示了，但是16个引脚全部连接到树莓派会使接线十分的复杂，而且程序代码的编写也非常繁琐，要对太多的GPIO引脚进行操作，十分不便。本次实验，我们采用的是带I2C模块的LCD元件，I2C模块本身将一些独立的功能进行了封装，通过I2C模块，我们可以以8位数据为标准来传输任何我们想要执行的指令或让LCD显示的字符，非常方便。 如上图所示，有了IC2模块的LCD1602元件，只需要4个引脚即可实现显示功能。下面我们来分析下如何使用此I2C模块。 首先关于I2C通信的相关内容，之前博客已经有详细的介绍，这里不再赘述。我们先来介绍下为何通过4个引脚通过I2C总线传输8位的数据集合实现所有功能。 LCD引脚1与引脚2：用I2C模块的电源引脚和接地引脚代替。 LCD引脚15和引脚16：LCD的这两个引脚功能为控制背光，此逻辑被封装进了I2C模块中，I2C模块每次写入的8位数据中的第4位用来控制背光。 LCD的引脚3：LCD的此引脚用来设置显示的对比度，在I2C模块中，通过一个可调节的电阻来实现此功能，在后面的实验中如果发现屏幕显示不清，可以尝试调节此电阻器。 LCD的引脚4，引脚5和引脚6：这几个功能引脚也被封装进了I2C模块中，I2C模块每次写入的8位数据中的第1位，的2位和第3位分别用来控制这些引脚。 LCD剩下的数据引脚的数据由I2C传输的8位数据中的高4位来对应，在LCD的8位数据模式下，I2C分两次传输一次完整的数据，前传输的4位为LCD所需数据的低4位，后传输的数据为LCD所需数据的高4位。在LCD的4位数据模式下，因为LCD需要获取到完整的8位数据，因此也需要通过两次数据传输，只是此时先传输的数据为LCD所需数据的高4位，后传输的数据为LCD所需数据的低4位，这点需要特别注意。 下面总结了I2C在传输数据时每一位的意义： 第8位 第7位 第6位 第5位 第4位 第3位 第2位 第1位 数据/指令 数据/指令 数据/指令 数据/指令 背光控制位 Enable控制位 RW控制位 RS控制位 三、编码实验使用I2C模块封装的LCD1602只有4个引脚，接线非常简单，如下： LCD 树莓派 GND GND VCC +5V SDA 树莓派SDA功能引脚 SCL 树莓派SCL功能引脚 将LCD1602与树莓派连接完成后，在树莓派的终端执行如下指令查看I2C设备： 1sudo i2cdetect -y 1 输出入下图所示： 可以看到，目前我们只连接了一个I2C设备，设备号为27。 由于背光的控制位相对独立，我们封装单独的函数来处理，如下： 12345678910111213# 是否开启背光 由PCF8574T的低4位中的第4位决定BLEN = 1 # 补充背光控制位def addBlenControl(data): global BLEN tmpData = data if BLEN: # 将第4位背光控制位强制设置1 tmpData = data | 0b00001000 else: # 将第4位背光控制位强制设置为0 tmpData = data &amp; 0b11110111 return tmpData 同理，可以将Enable位的控制，RS位的控制都封装成函数： 12345678910111213141516171819# 补充Enable控制位def addEnableControl(data, high): tempData = data # 第3位控制Enable if high: tempData |= 0b00000100 else: tempData &amp;= 0b11111011 return tempData# 补充RS控制位def addRSControl(data, high): tempData = data # 第1位控制RS if high: tempData |= 0b00000001 else: tempData &amp;= 0b11111110 return tempData 在向I2C发送数据前，根据配置的背光设置来决定背光控制位的值： 123456# 通过I2C总线写入数据def writeI2C(addr, data): # 添加背光控制 temp = addBlenControl(data) # 写数据到I2C总线 BUS.write_byte(addr ,temp) 准备好了这些工具函数，我们只需要根据LCD1602的指令手册来设置具体的功能，发送要展示的数据即可，完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#coding:utf-8import timeimport smbusBUS = smbus.SMBus(1)# LCD屏幕的硬件地址LCD_ADDR = 0x27# 是否开启背光 由PCF8574T的低4位中的第4位决定BLEN = 1 # 补充背光控制位def addBlenControl(data): global BLEN tmpData = data if BLEN: # 将第4位背光控制位强制设置1 tmpData = data | 0b00001000 else: # 将第4位背光控制位强制设置为0 tmpData = data &amp; 0b11110111 return tmpData # 补充Enable控制位def addEnableControl(data, high): tempData = data # 第3位控制Enable if high: tempData |= 0b00000100 else: tempData &amp;= 0b11111011 return tempData# 补充RS控制位def addRSControl(data, high): tempData = data # 第1位控制RS if high: tempData |= 0b00000001 else: tempData &amp;= 0b11111110 return tempData# 通过I2C总线写入数据def writeI2C(addr, data): # 添加背光控制 temp = addBlenControl(data) # 写数据到I2C总线 BUS.write_byte(addr ,temp)# 发送指令到LCD1602def sendCommand(comm): # comm高4位数据传输 # 低4位先清空 buf = comm &amp; 0b11110000 # 先将Enable置为高电平 buf = addEnableControl(buf, 1) # 设置为指令模式 buf = addRSControl(buf, 0) # 写入指令 writeI2C(LCD_ADDR ,buf) time.sleep(0.002) # 将Enable置为低电平 使产生低电平跳变来执行指令 buf = addEnableControl(buf, 0) writeI2C(LCD_ADDR ,buf) # comm低4位数据传输 # 高4位先清空 并将低4位的数据移动到高4位 buf = (comm &amp; 0b00001111) &lt;&lt; 4 # 当次指令的低4位用来 做enable re rew的控制 # 先将Enable置为高电平 buf = addEnableControl(buf, 1) writeI2C(LCD_ADDR ,buf) time.sleep(0.002) # 将Enable置为低电平 使产生低电平跳变来执行指令 buf = addEnableControl(buf, 0) writeI2C(LCD_ADDR ,buf)# 发送数据到LCD def sendData(data): # data高4位数据传输 # 低4位先清空 buf = data &amp; 0b11110000 # 先将Enable置为高电平 buf = addEnableControl(buf, 1) # 设置为数据模式 buf = addRSControl(buf, 1) writeI2C(LCD_ADDR ,buf) time.sleep(0.002) # 将Enable置为低电平 使产生低电平跳变来执行指令 buf = addEnableControl(buf, 0) writeI2C(LCD_ADDR ,buf) # data低4位数据传输 buf = (data &amp; 0b00001111) &lt;&lt; 4 # 先将Enable置为高电平 buf = addEnableControl(buf, 1) # 设置为数据模式 buf = addRSControl(buf, 1) writeI2C(LCD_ADDR ,buf) time.sleep(0.002) # 将Enable置为低电平 使产生低电平跳变来执行指令 buf = addEnableControl(buf, 0) writeI2C(LCD_ADDR ,buf)# 初始化方法def initLCD(): # 启动时，LCD1602为8位模式 I2C传输数据时先传输的为低位数据 # 因此实际上的指令为 0b00100011 # 为指令6 将LCD1602设置为4位总线模式 sendCommand(0b00110010) time.sleep(0.005) # 之后的指令都是4位总线模式 sendCommand(0b00110010) time.sleep(0.005) # 指令4 设置屏幕开启，无光标，无闪烁 sendCommand(0b00001100) time.sleep(0.005) # 指令1 清屏 sendCommand(0b00000001) # 设置屏幕要展示的文案 x，y确定位置def printLCD(x, y, str): # 2行 16 列 if x &lt; 0: x = 0 if x &gt; 15: x = 15 if y &lt;0: y = 0 if y &gt; 1: y = 1 # 指令7 设置数据要展示的位置 addr = 0b10000000 + 0b00000100 * y + x sendCommand(addr) # 开始发送字符数据到LCD1602的数据寄存器 for chr in str: # ord函数可以获取字符的ascil sendData(ord(chr)) # 主程序initLCD()printLCD(0, 0, 'Hello, world!')time.sleep(2)sendCommand(0b00000001)time.sleep(0.002)printLCD(0, 0, 'Love China!')time.sleep(2)sendCommand(0b00000001)time.sleep(0.002)printLCD(0, 0, 'Great Raspberry!') 如上代码所示，所有的指令都采用的二进制的方式，便于对比指令手册进行理解。更多时候我们会采用十六进制数字来编写指令，这样会使代码看的干净很多。上面的示例代码是一个简单的应用程序，运行后可以直接在LCD屏幕上展示3句话： 123Hello World!Love China!Great Raspberry! 其实此程序也是一个完整的LCD1602驱动，初始化完成后，我们可以通过其提供额sendData方法来实现各种各样的显示需求。效果如下图所示： 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（10）——触控激光灯","slug":"423一起玩转树莓派（10）——触控激光灯","date":"2021-08-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.392Z","comments":true,"path":"2021/08/12/423一起玩转树莓派（10）——触控激光灯/","link":"","permalink":"http://huishao.cc/2021/08/12/423一起玩转树莓派（10）——触控激光灯/","excerpt":"","text":"一起玩转树莓派（10）——触控激光灯如果你已经阅读并且练习了本系列博客前面实验，那么我相信你已经能够使用树莓派做很多有趣的事情。本博客将要介绍的内容就是一个例子。 你在小时候有玩过激光灯么？其模样类似于一个小型的手电筒，只是其光线十分集中，亮度强，并且通过不同的滤片，可以在墙上或地上打射出不同的图案，十分有趣。本实验，我们将找回童趣，使用触摸传感器和激光灯传感器来实现一个简易的触控激光灯。 本实验的原理非常简单，无非是通过树莓派的GPIO引脚来读取触摸传感器的数据，之后将其用于操作激光传感器的开关控制上。本次实验使用的触摸传感器如下图所示： 此触摸传感器有3个引脚，除了正负极引脚外，最外侧的引脚用来输出信号，当手指触摸传感器上的圆形区域时，其信号引脚会输出高电平，否则输出低电平。对于这种类型的传感器，我们可以直接使用GPIO的下拉电阻功能，将其默认设置为低电平，轮询等待高电平信号。 首先，先来体验下触摸传感器的应用，连线如下： 触摸传感器 树莓派 GND GND VCC 3.3V SIG BCM编码17的引脚(对应物理引脚为11) 编写如下测试代码： 1234567891011121314#coding:utf-8import RPi.GPIO as GPIOimport timetouchPin = 11GPIO.setmode(GPIO.BOARD)GPIO.setup(touchPin,GPIO.IN, pull_up_down=GPIO.PUD_DOWN)while True: swi = GPIO.input(touchPin) print(swi) time.sleep(0.5) 在树莓派上运行上面代码。通过触摸传感器，可以看到控制台上打印出对应的电平信息。 下面，我们再来看一下本次实验所使用的激光模块，如下图所示： 此激光模块也有3个引脚，其中“-”号一侧的引脚接地，中间引脚接3.3V电压，“S”一侧引脚接GPIO信号引脚。当S信号引脚输入高电平时，激光模块被激活发射激光，当S信号引脚输入低电平时，激光发射关闭。激光模块的接线如下： 激光模块 树莓派 - GND — — 中间引脚 3.3V — — S BCM编码18的引脚(对应物理引脚为12) — — 修改上面的示例代码如下： 123456789101112131415161718192021222324252627#coding:utf-8import RPi.GPIO as GPIOimport time# 触摸传感器的信号引脚touchPin = 11# 激光模块的信号引脚lightPin = 12# 设置采用物理编码GPIO.setmode(GPIO.BOARD)# 对触摸传感器的引脚进行初始化GPIO.setup(touchPin,GPIO.IN, pull_up_down=GPIO.PUD_DOWN)# 对激光传感器的引脚进行初始化GPIO.setup(lightPin,GPIO.OUT)while True: swi = GPIO.input(touchPin) # 当触摸发生时，触摸传感器的引脚输入高电平 if swi == 1: # 向激光模块的引脚输出高电平，发射激光 GPIO.output(lightPin, GPIO.HIGH) else: # 与上面相反，关闭激光 GPIO.output(lightPin, GPIO.LOW) time.sleep(0.5) 在树莓派上运行上面代码，体验下这个自制的激光灯玩具吧！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（9）——DS18B20测温模块应用","slug":"422一起玩转树莓派（9）——DS18B20测温模块应用","date":"2021-08-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.391Z","comments":true,"path":"2021/08/09/422一起玩转树莓派（9）——DS18B20测温模块应用/","link":"","permalink":"http://huishao.cc/2021/08/09/422一起玩转树莓派（9）——DS18B20测温模块应用/","excerpt":"","text":"一起玩转树莓派（9）——DS18B20测温模块应用关于使用树莓派测量温度，我们之前在学习模数转换的相关博客中已经有过应用。其实除了使用传统的AD采集温度数据外，我们也可以通过树莓派中的单总线技术结合DS18B20传感器来更加方便精准的测量环境温度。 一、认识DS18B20模块与单总线通信DS18B20是一种改进型的智能温度传感器。与传统的热敏电阻相比，其可以直接读出被测量的温度，并且能够根据实际应用场景中的要求进行简单的编程。无论是读取数据还是写入数据，DS18B20都只需要一条接口线，因此其使用的是单总线的通讯协议。DS18B20模块的主要优势在于其抗干扰能力强，精度高，无需复杂的软件处理可以直接输出温度数据。本次实验，我们使用的DS18B20模块如下图所示： 可以看到此模块有3个引脚，除了电源引脚和接地引脚外，剩下的一个就是用来输出温度数据的引脚。 单总线通信被称为one-wire通信，因此又常常被简称为1w总线通信。首先我们需要先开始树莓派的1w总线通信功能，打开树莓派的Raspberry Configuration菜单，在Interfaces选项中将1-Wire功能开启，如下图所示。 如果我们是通过无交互页面的终端登录的树莓派，也可以通过修改配置文件来开启1-Wire功能，在树莓派Linux系统的根目录下，找到如下路径的文件： 1/boot/config.txt 在其中添加如下一行文本即可： 1dtoverlay=w1-gpio 需要注意，添加之后需要重启树莓派。需要注意，1-Wire功能默认将使用树莓派的BCM编码为GPIO4的引脚作为通信引脚，如何我们要进行自定义，可以在刚才的配置文件中进行指定，如下： 1dtoverlay=w1-gpio,gpiopin=18 其表示要使用BCM编码为GPIO18的引脚作为通信引脚。 做完了上面的操作后，我们可以在树莓派终端中使用如下指令查看单总线是否启动成功： 1$ lsmod 终端输出效果如下： 可以看到，如果有显示w1_gpio和wire两个部分，则表示单总线已经启动成功，分别在终端执行如下两条命令： 12$ modprobe w1-gpio$ modprobe w1-therm 如果终端没有输出任何信息，则表示单总线已经初始化完成，此时实际上我们已经可以让DS18B20进行工作了。 二、通过DS18B20模块获取环境温度通过前面的操作，我们已经完成了基本的准备工作，将DS18B20连接到树莓派，引脚对应如下： DS18B20 树莓派 + 3.3V - GND out BCM编码为GPIO4的引脚 之后我们从树莓派的终端进入如下目录： 1/sys/bus/w1/devices 在此目录下，我们可以看到有两个文件，如下图所示： 其中以28-xxx开头的文件夹中的文件记录的就是1w单总线输入的数据，需要注意，读者操作时，此文件夹的名称和笔者可能并不完全一样，其表示传感器设备的编号，大家这里只需要找到28-xx开头的文件夹即可。在此文件夹中，有一个名为w1_slave的文件，此文件中记录的就是传感器的温度数据，我们可以打开看看，内容如下： 12d2 01 55 05 7f 7e 81 66 59 : crc=59 YESd2 01 55 05 7f 7e 81 66 59 t=29125 其中，大部分数据我们都无需关心，其最后的t=29125就是当前的环境温度，将其转换为摄氏温度，直接除以1000即可，例如上面的数据表明当前的环境温度是29.125摄氏度。 目前为止，我们已经可以非常轻松的获取DS18B20模块提供的温度数据了，但是查看的方式非常不智能，其实我们可以通过Python程序来不停的读取此数据文件，解析出其中的温度数据，之后无论是做记录还是进行其他元件控制都会非常方便。编写示例代码如下： 12345678910111213141516171819202122232425262728293031323334#coding:utf8import os,time# 传感器编号name = \"28-020692455d61\"# 设备记录数据的文件地址device_file ='/sys/bus/w1/devices/' + name + '/w1_slave'# 读取文件数据def read_temp_raw(): f = open(device_file,'r') lines = f.readlines() f.close() return lines# 解析温度数据def read_temp(): lines = read_temp_raw() # 此行默认不是'YES' 表明未读取到有效数据 while lines[0].strip()[-3:] != 'YES': time.sleep(0.2) # 循环继续读 lines = read_temp_raw() # 找到第2行的't='的位置 equals_pos = lines[1].find('t=') # 将温度数据取出 if equals_pos != -1: temp_string = lines[1][equals_pos+2:] temp_c = float(temp_string)/1000.0 return temp_cwhile True: print('%fC'%read_temp()) time.sleep(1) 在树莓派中运行上面代码，可以看到控制台输出的当前温度数据，如下图所示： 三、讲在后面本篇博客，我们介绍了如何使用one-wire单总线进行外设数据的读取，DS18B20只是作为示例，抛砖引玉，通过树莓派的1w总线，我们还可以连接更多的外设实现更加有创意的东西，大家开动脑筋，尽情玩耍吧！ 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（8）——树莓派模数/数模转换实践(2)","slug":"421一起玩转树莓派（8）——树莓派模数:数模转换实践(2)","date":"2021-08-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.391Z","comments":true,"path":"2021/08/03/421一起玩转树莓派（8）——树莓派模数:数模转换实践(2)/","link":"","permalink":"http://huishao.cc/2021/08/03/421一起玩转树莓派（8）——树莓派模数:数模转换实践(2)/","excerpt":"","text":"一起玩转树莓派（8）——树莓派模数/数模转换实践(2)在上一篇博客中，我们介绍了在树莓派中使用模数转换芯片的基本方法，如果你对上一篇博文中介绍的内容已经有了深入的理解，那后面的应用试验对你来说将非常容易。如果不是，那么我建议你先将之前介绍的内容在研究一下： https://my.oschina.net/u/2340880/blog/5142788 现在，如果你决定继续本篇博客的学习，那么我认为你已经了解了PCF8591芯片的基本用法，明白了PCF8591的接线方式，I2C总线的基本工作原理以及PCF8591的设置命令的意义和读数据的方法。 一、读取外部传感器的模拟信号在本系列博客的上一篇文章中，我们通过读取PCF8591实验模块自带的可调节电压输出、光敏传感器和热敏传感器实现了对当前环境信息的的读取，除了可以读取当前设置的输出电压外，我们还可以获得当前的环境的温度和亮度。PCF8591实验模块自带的传感器可以让我们很方便的进行实验，其实在实际应用中，更多时候我们需要从AIN0到AIN3引脚来获取外接传感器的模拟信号。现在，我们尝试下通过AIN0和AIN1两个输入引脚来获取外接光敏和热敏传感器的数据。 1.关于实验所使用的传感器我们这里的小实验将使用光敏和热敏传感器。 光敏模块光敏传感器能够感应光纤的明暗变化，其实现此功能的核心在于光敏电阻，只做光敏电阻的常用材料有硫化镉、硫化铝等。这些材料在特定波长的光波照射下，其阻值会产生明显的变化。本次实验，我们使用的光敏传感器模块如下图所示： 可以看到，此模块的核心是一个光敏电阻，提供了可调节灵敏度的功能单元和两个LED指示灯，其中一个LED是电源指示灯，接通电源后会亮，另一个LED灯是电平指示灯，当光亮达到阈值时，输出引脚输出低电平，此LED灯亮，当光亮度较暗时，输出引脚输出高电平，此LED灯不亮。我们再看此模块的4个引脚： VCC：电源引脚 GND：接地引脚 DO：数字信号输出引脚(高低电平) AO：模拟信号输出引脚 热敏模块本次实验我们使用的热敏模块的功能与上面将的光敏模块类似，如下图所示： 此热敏模块同样包含两个LED指示灯、灵敏度调节单元和4个引脚，引脚如下： VCC：电源引脚 GND：接地引脚 DO：数字信号输出引脚(高低电平) AO：模拟信号输出引脚 2.实验连线本次实验，我们使用PCF8591读取光敏和热敏传感器的模拟信号，将其转换成数字信号被树莓派程序处理，同时，我们使用树莓派的GPIO端口来读取传感器本身输出的数字信号，首先，我们先确定要使用的PCF8591的输入引脚和要使用的树莓派GPIO引脚。 PCF8591输入引脚使用：AINO和AIN1，其中AINO读取光敏模拟信号，AIN1读取热敏模拟信号。 GPIO输入引脚使用：GPIO17和GPIO18（BCM编码方式），其中17引脚读取光敏数字信号，18引脚读取热敏数字信号。 PCF8591连线： PCF8591 树莓派功能引脚 SCL SCL SDA SDA GND GND VCC 5V 光敏传感器： 光敏传感器 树莓派/PCF8591 VCC 树莓派3.3V GND 树莓派GND DO 树莓派GPIO11(物理引脚) AO PCF8591 AIN0 热敏传感器： 热敏传感器 树莓派/PCF8591 VCC 树莓派3.3V --- --- GND 树莓派GND --- --- DO 树莓派GPIO12(物理引脚) --- --- AO PCF8591 AIN1 --- --- 连线最终如下图所示： 和之前相比，我们这次直接在树莓派上连接了3个元件，连线也复杂了很多，只要按照上面的表格，注意引脚的正确即可。 3.编写程序步入正题，先上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding:utf-8#SMBus (System Management Bus,系统管理总线) import smbus #在程序中导入“smbus”模块import RPi.GPIO as GPIO import timebus = smbus.SMBus(1) #创建一个smbus实例# 通过PCF8591读取模拟信号# 数据亮度的模拟数据def readLight(): #发送一个控制字节到设备 表示要读取AIN0通道的数据 bus.write_byte(0x48,0x40) bus.read_byte(0x48) # 空读一次，消费掉无效数据 return bus.read_byte(0x48) # 返回某通道输入的模拟值A/D转换后的数字值def readTemperature(): #发送一个控制字节到设备 表示要读取AIN1通道的数据 bus.write_byte(0x48,0x41) bus.read_byte(0x48) # 空读一次，消费掉无效数据 return bus.read_byte(0x48) # 返回某通道输入的模拟值A/D转换后的数字值# 通过GPIO读取数字信号# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 光敏模块的数字输出引脚 BCM 17LP = 11# 热敏模块的数字输出引脚 BCM 18TP = 12# 引脚初始化GPIO.setup(LP, GPIO.IN)GPIO.setup(TP, GPIO.IN)while True: print('--------分割线----------') print('亮度数字信号：', GPIO.input(LP)) print('亮度模拟信号：', readLight()) print('温度数字信号：', GPIO.input(TP)) print('温度模拟信号：', readTemperature()) time.sleep(2) 上面的代码有着比较详尽的注释，这里我们无需多说，在树莓派上运行此代码，即可观察到控制台的数据输出。 二、使用操纵杆外设控制圆球移动如果你顺利完成了上面的实验，先别急着庆祝，你会发现，和本系列前面几篇博客的内容较比，到目前为止我们并没有介绍新的知识，同时也没有做什么新颖的事情。的确如此，但是通过上面实验的练习，可以帮助你更深入的理解数模/模数转换的应用场景，并且让你能够更加灵活的对I2C总线与通用GPIO串口结合进行使用。下面我们要来做一些好玩的事情了，不知道你小时候是否有玩过“大把机”，这是一种摇杆游戏机，摇杆可以朝上下左右4个方向转动，也可以从中间按下。通常，上下左右用来控制游戏人物的行动方向，按下用来进行人物跳跃。现在，我们要来做一个简单的游戏，为树莓派连接操纵杆，控制游戏程序页面上圆球的行为，其中方向控制圆球的移动，按下操纵杆则使圆球变色。 此实验所使用的操纵杆如下图所示： 可以看到，此元件有5个引脚： GND：接地引脚 +5V：5V电源引脚 VRX：横向坐标模拟信号输出引脚 VRY：纵向坐标模拟信号输出引脚 SW：按钮数字信号输出引脚 操作杆内部实际上封装了双向的电阻器，其阻值会根据摇杆的方向变动产生变化，从而影响引脚信号的产生变化。 1.进行连线我相信，现在连线对你来说应该是最简单的工作了。操纵杆有模拟信号输出同时也有数字信号输出，我们依然需要结合PCF8591与树莓派GPIO一起使用。关于PCF8591的接线上面有介绍，这里不再重复。操作杆的接线方式如下： 操纵杆 树莓派/PCF8591 GND 树莓派GND +5V 树莓派5.5V VRX PCF8591 AIN0 VRY PCF8591 AIN1 SW 树莓派GPIO 11（物理引脚） 2.编写代码对于本实验来说，有涉及到UI开发，我们依然采用Python自带的Tkinter库，其有很好的移植性，并且其提供了Canvas画布，我们可以灵活的渲染所需要的图形。示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#coding:utf-8# 导入UI模块import tkinter as Tkinter#SMBus (System Management Bus,系统管理总线) import smbus #在程序中导入“smbus”模块import RPi.GPIO as GPIO # 导入树莓派GPIO模块import time # 导入定时器模块import threading# 主页面设置top = Tkinter.Tk()top.geometry('500x300')top.title(\"操纵杆控制圆球\")# 当前圆球的坐标currentX = 0currentY = 0# 当前圆球的颜色是否红色currentColor = True# 进行窗口的初始化canvas = Tkinter.Canvas(top, width=500, height=300, borderwidth=0, highlightthickness=0)canvas.grid()# 进化画布的初始化circle = canvas.create_oval(currentX, currentY, 100, 100, fill=\"red\", outline=\"\")# 定义移动圆球的方法def moveCircle(c, x, y): global currentX, currentY moveX = x moveY = y if x &gt;= 0: if x + currentX &gt; 400: moveX = 400 - currentX currentX = 400 else: currentX += x else: if x + currentX &lt; 0: moveX = -currentX currentX = 0 else: currentX += x if y &gt;= 0: if y + currentY &gt; 200: moveY = 200 - currentY currentY = 200 else: currentY += y else: if y + currentY &lt; 0: moveY = -currentY currentY = 0 else: currentY += y canvas.move(c, moveX, moveY)# 定义改变圆球颜色的方法def changeColor(c): global currentColor canvas.itemconfig(c, fill= 'red' if currentColor else 'blue') currentColor = not currentColorbus = smbus.SMBus(1) #创建一个smbus实例# 通过PCF8591读取模拟信号# 摇杆X引脚的模拟数据def readX(): #发送一个控制字节到设备 表示要读取AIN0通道的数据 bus.write_byte(0x48,0x40) bus.read_byte(0x48) # 空读一次，消费掉无效数据 return bus.read_byte(0x48) # 返回某通道输入的模拟值A/D转换后的数字值# 摇杆Y引脚的模拟数据def readY(): #发送一个控制字节到设备 表示要读取AIN1通道的数据 bus.write_byte(0x48,0x41) bus.read_byte(0x48) # 空读一次，消费掉无效数据 return bus.read_byte(0x48) # 返回某通道输入的模拟值A/D转换后的数字值# 通过GPIO读取数字信号# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 按键使用引脚 BCM 17BTN = 11# 引脚初始化 设置下拉高电平GPIO.setup(BTN, GPIO.IN, pull_up_down=GPIO.PUD_UP)# 创建定时器函数，用来检查摇杆动作def fun_timer(): global timer x = readX() y = readY() press = GPIO.input(BTN) print('X：', x) print('Y：', y) print('按钮：', press) if x &lt;= 10: moveCircle(circle, -10, 0) if x &gt;= 245: moveCircle(circle, 10, 0) if y &lt;= 10: moveCircle(circle, 0, -10) if y &gt;= 245: moveCircle(circle, 0, 10) timer = threading.Timer(0.2, fun_timer) timer.start()timer = threading.Timer(0.2, fun_timer)timer.start()# 定义GPIO输入端口的回调def btnCallback(channel): if not GPIO.input(channel): changeColor(circle)# 添加输入引脚电平变化的回调函数GPIO.add_event_detect(BTN, GPIO.FALLING, callback=btnCallback, bouncetime=200)top.mainloop() 上面的代码有些长，但是有详尽的注释，关于UI开发方面的内容不是我们本系列博客的重点，这里我们不做过多介绍。moveCircle函数是核心的圆球移动函数，内部通过边界判定逻辑可以确保圆球不会移动到视图界面外。changeColor方法用来修改圆球的颜色，这里我们让每次按键后在红绿颜色间进行切换。readX和readY函数我们无需做过多介绍了，其通过PCF8591的AIN0和AIN1来传输摇杆的横纵坐标信号。GPIO的相关操作我们也非常熟悉了，我们通过注册回调函数来监听操作杆按钮按下的行为。 在树莓派上运行上面的代码，尝试操作下，感受下使用操纵杆控制页面元素的喜悦吧。 3.一点扩展观察上面的示例代码，你会发现，我们使用了一些临界值来作为触发方向动作的阈值，例如10，245这种，这是因为PCF8591是8位的数模转换模块，即其转换出的数字量在0-255之间（包括0和255），对于本实验来说，我们并没有让摇杆元件传输的模拟量发挥正真的作用，想一下，你是否能够根据操作杆的旋转程度来调整圆球移动的速度呢？动手试试吧！ 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（7）——树莓派模数/数模转换实践","slug":"420一起玩转树莓派（7）——树莓派模数:数模转换实践","date":"2021-07-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.391Z","comments":true,"path":"2021/07/24/420一起玩转树莓派（7）——树莓派模数:数模转换实践/","link":"","permalink":"http://huishao.cc/2021/07/24/420一起玩转树莓派（7）——树莓派模数:数模转换实践/","excerpt":"","text":"一起玩转树莓派（7）——树莓派模数/数模转换实践如果你跟随本系列博客阅读到此，那么我相信，你已经能够使用树莓派的GPIO接口做许多有趣的事情了。但是不知你是否有发现，GPIO功能接口无论是输入还是输出，都只有高电平或低电平这两种选项，抽象到数学中，即只有0和1两种数值选项，这种离散数值的信号我们将其称为数字信号。更多时候，我们需要使用的元件并非只有开和关两种状态，这时候就需要用数值连续的信号来表达，这种连续的信号我们称之为模拟信号。本篇博客，我们将初步涉猎在树莓派上如何处理模拟信号。 一、树莓派模数转换模块基础其实，直接使用GPIO的功能引脚并非完全不能处理模拟信号，我们知道无论需要多少种状态信号，通过GPIO的电平高低来处理都是无法实现的，但是你一定还记得PWM脉冲宽度调制技术，这其实就是一种将数字信号转换成模拟信号的方式，例如在前面的RGB实验中，我们曾使用PWM技术来控制3种发光二极管的发光明暗程度，如果将二极管的全亮定义为值1，全暗定义为值0，则在明暗之间可以通过设置不同的占空比来实现，例如需要亮度值为0.5时，只需要设置占空比为50%即可。通过PWM技术，虽然我们每个精确的时刻输出的依然是数字信号(0或1)，但最终作用到元件上的信号是模拟的，这就完成了最简单的数模转换。 同样的道理，对于某些外接元件来说，其输出的信号也可能是模拟的，例如温度、光亮传感器，如果直接通过GPIO来获取这些元件的信号是模拟的，解析会非常困难，这时我们就需要一个数模转换模块来帮助我们将其转换为数字信号。 1、关于模数转换数模转换器，又称D/A转换器，简称DAC。用来把数字量转换成模拟量的器件，关于数模转换器的电路和工作原理，不在本篇博客的核心讨论范围内，如果你有兴趣可以查阅数字电路和模拟电路的相关书籍。对其对应，模数转换器，又称为A/D转换器，简称ADC。用来把模拟信号转换为数字信号。树莓派本身没有集成模数转换模块，我们需要外接一个转换单元，在本实验中，我们采用基于PCF8591芯片的模数转换模块。 2、PCF8591芯片PCF8591是一个单片集成，单独供电，低功耗的8位数A/D转换器，其芯片本身如下图所示： 可以看到其左右各有8个引脚，引脚功能图如下： 如上图所示，其AIN0到AIN3都是模拟输入引脚，其用来输入外接元件的模拟信号，它还有1个模拟输入引脚AOUT，用来输出模拟信号。 A0，A1，A2这3个引脚用来进行硬件地址编程，在嵌入式编程中，每个可编程的引脚我们将其理解为一个二进制位，3个引脚可以表达0-7这8个数字（000，001，010，011，100，101，110，111），因此在同一个I2C总线上，实际可以同时连接8个PCF8591芯片进行工作（I2C总线我们后面会介绍）。 VSS是接地引脚，VDD是工作电压引脚，AGND是模拟信号接地引脚，VREF是基准电源引脚。 OSC引脚为外部时钟输入端或内部时钟输出端，EXT如果接地，表示使用内部时钟，否则表示使用外部时钟。 SCL和SDA是I2C总线接口引脚，我们使用这两个引脚来进行数据传输，后面会介绍。 下面是PCF8591工作的电路原理图： 温馨提示，在阅读本篇博客时，难度可能要比本系列的前几篇博客大，你可能会感觉云里雾里，不要着急，后面我们会通过实验来帮助你理解模数转换以及I2总线的工作方式，掌握了这些，你的树莓派开发本领将进一步提升。 3、PCF8591实验模块上一小节我们介绍了PCF8591芯片的引脚用法，实际在本实验中，我们并不会直接使用这个芯片，而是使用基于PCF8591芯片的一个工作模块，如下图所示： 如上图所示，此模块功能非常丰富，我们逐一介绍。 左边一列引脚作用分别为： AOUT ：内部芯片的DA 输出接口 AIN0 ：内部芯片的模拟输入接口 0 AIN1 ：内部芯片的模拟输入接口 1 AIN2 ：内部芯片的模拟输入接口 2 AIN3 ：内部芯片的模拟输入接口 3 右边一列引脚的作用为： SCL ：I2C 通信接口 SDA ：I2C 通信接口 GND ：模块地 VCC ：电源接口 外接 3.3v-5v 除此之外，P4，P5，P6三个地方我们可以通过接短路帽的方式来选择是否接入相关功能。 P4：接上短路帽，表示将热敏电阻接入电路。 P5：接上短路帽，表示将光敏电阻接入电路。 P6：接上短路帽，表示将0-5V的可调节电压接入电路。 如果P4，P5，P6都不接短路帽，可以使用外部元件通过4个AIN引脚进行输入。关于这几个功能如何使用，后面我们会介绍。 此模块的工作示意图如下： 4.I2C总线基础知识I2C总线是有Philips公司开发的一种简单、双向的同步串行总线。只需要两根线即可实现连接在总线上的设备间进行通信。在I2C总线的通讯协议中，SDA用来传输数据，SCL是串行的时钟线，传输流程如下图所示： 只看图你可能会感觉非常疑惑，结合树莓派工作起来，其实要理解并不复杂，在I2C协议中，树莓派就是主机，连接的PCF8591就是从机，主机与从机间无论是发送数据还是接受数据，都是由主机先发起，形象化的流程如下： 1.主机触发开始通信条件(SDA和SCL电平满足一定条件)。 2.通过地址找到要通信的从机(即PCF8591的3个地址编程引脚设置的地址)。 3.主机发送工作命令，即指定要从从机读数据还是写数据，读哪个通道的数据等（PCF8591有4个输入通道）。 4.收到数据会发送ACK回执。 5.结束此次通讯后，主机发送完成指令给从机（SDA和SCL电平满足一定条件）。 5.几个重要的指标概念1.位数 ADC元件的位数非常重要，它描述了一种可读概念，以PCF8591为例，其实8位的数模转换芯片，也就是说其输出的数字量是0到255之间的数值，一共256种(2的8次方)。 2.基准电压 基准电压用来标准数模转换芯片输出的数值与电压之间关系，例如基准电压为5V，则0到255这256个刻度相当于将5V的电压平均分成了255份，数值没增加1，相当于电压约增加0.019V。 二、实验：测定温度和光亮度现在，我们已经准备好了需要使用到的基础知识，可以开始我们的试验了。PCF8591自带光感与温度传感器，我们尝试使用这两个传感器来读取环境的温度与亮度。 1、连线首先，我们可以先使用3个短路帽将PCF8591模块的P4、P5、P6都进行短接，如下图所示： 短接后，相当于我们将PCF8591模块自带的可调节输出电压、光感信号输出和温度信号输出都接入了电路，可以直接通过I2C总线对其数据进行获取。 之后，我们将PCF8591模块模块的SCL、SDA分别连接树莓派对应功能的引脚，GND进行接地，VCC接5V。关于找到树莓派上这些引脚的位置，可以参考下面博客： https://my.oschina.net/u/2340880/blog/5123429 笔者这里使用扩展板来接线，会更加直观方便，如下图所示： 现在，我们已经完成了接线部分的工作。 2、代码编写因为需要使用到树莓派的I2C总线功能，在开始编码前，我们需要将树莓派的I2C功能开启，打开树莓派的配置页面，在其interfaces选项中打开SPI和I2C选项，如下图所示。 我们先将完整的实验代码奉上： 12345678910111213141516171819202122232425262728293031#coding:utf-8#SMBus (System Management Bus,系统管理总线) import smbus #在程序中导入“smbus”模块import timebus = smbus.SMBus(1) #创建一个smbus实例# 数据读取的方法def read(chn): #channel if chn == 0: #发送一个控制字节到设备 表示要读取AIN0通道的数据 bus.write_byte(0x48,0x00) if chn == 1: #发送一个控制字节到设备 表示要读取AIN1通道的数据 bus.write_byte(0x48,0x01) if chn == 2: #发送一个控制字节到设备 表示要读取AIN2通道的数据 bus.write_byte(0x48,0x02) if chn == 3: #发送一个控制字节到设备 表示要读取AIN3通道的数据 bus.write_byte(0x48,0x03) bus.read_byte(0x48) # 空读一次，消费掉无效数据 return bus.read_byte(0x48) # 返回某通道输入的模拟值A/D转换后的数字值if __name__ == \"__main__\": while True: print('电位计 AIN3 = ', 0.0196 * read(3)) #电位计模拟信号转化的数字值 print('光敏电阻 AIN0 = ', 255 - read(0)) #光敏电阻模拟信号转化的数字 print('热敏电阻 AIN1 = ',255-read(1)) #热敏电阻模拟信号转化的数字值 time.sleep(2) 下面我们来详细解释下上面的代码，首先smbus是一个Python模块，我们之前并没使用过，我们这次实验不使用GPIO，使用smbus来进行I2C总线管理。 在核心逻辑执行前，首先需要进行总线管理器的实例化，使用如下方法： 1bus = smbus.SMBus(1) 其中的参数表示要使用的I2C版本。 前面我们分析过，在I2C总线通信中，主机先要发送指令告诉从机要做什么，对应代码中就是write_byte方法，这个方法用来向PCF芯片发送一个8位的控制指令，通过查阅芯片手册，很容易找到这个8位的控制指令每一位的意义，如下图所示： 我们从左往右来分析上图。 对于上图，我们在多解释一下，这个8位的控制指令，第1位和第5位都是默认填充位，都用0填充，目前没有任何意义。 第2位表示是否开启AOUT输出口，只有这一位为1，数模转换才会工作，数字信号才会被转换为模拟信号从AOUT引脚输出。（本次实验我们暂不使用） 第3位和第4位用来编程控制输入模式，这两位可以组成的数值有00，01，10，11共四种，设置为00表示AIN端口与输入通道一一对应。01，10，11这3种模式通道的值都是经过 处理的，上图有明确的标注，比如在11模式下，通道0的值是AIN0和AIN1输入的差分，通道1的值是AIN2和AIN3输入的差分。（本次实验我们也无需使用这一功能） 第6位的作用是设置是否自动切换通道，当其设置为1时，每次读取数据后，通道都会切换，例如第一次读取通道0的数值，第二次会在读取时，会自动读取通道1的数值。 第7位和第8位用来指定从哪个通道读取数值，有4个通道可用，分别通过00，01，10，11进行设置。 我们再来看下write_byte方法： 1bus.write_byte(0x48,0x00) 这个方法有两个参数，第2个参数就是我们上面说的指令参数，其用16进制表示，例如0x03设置为： 第1位 第2位 第3位 第4位 第5位 第6位 第7位 第8位 0(占位) 0(不使用AOUT) 0(一一对应模式) 0(一一对应模式) 0(占位) 0(不启动切换通道) 1(设置要读取的通道) 1(设置要读取的通道) write_byte这个方法的第1个参数用来设置I2C总线中要为哪一个从机设置指令，PCF的地址设置是7位，查阅手册如下： 可以看到第4位到第7位都是固定的，前3位是可编程的，还记得PCF的A0到A3引脚吧，就是让主机来分配从机地址使用的。我们可以知道，PCF从机的地址一定在二进制数01001000(0x48)到01001111(0x4F)之间，要查阅当前连接到树莓派的PCF从机的地址，可以在树莓派终端输入如下指令： 1sudo i2cdetect -y 1 效果如下图所示： 从图中可以看到，树莓派当前只连接了一个I2C从机模块，分配的地址是0x48。 现在，上面的代码对你来说非常好理解了，需要注意，其中除了0x48表示的是PCF从机的地址外，其他十六进制数都是指令。指令设置完成后，接下来就可以进行数据的通信，使用如下方法： 1bus.read_byte(0x48) 这个方法用来通过I2C总线从PCF读取数据，上面代码中我们在读取数据时连续调用了两次，这是因为PCF8591接收到读取数据的命令后会同时进行上一次转换数据的传输和本次数据的转换，空读一次可以消费掉不正确的数据。 还有一点需要注意，对于我们使用的PCF8591模块来说，其自带的可调节电压会输出到第4个通道，光敏传感器的数据会输出到第1个通道，热敏传感器的数据会输出到第2个通道，在本次实验中，第3个通道不被使用(如果你使用的PCF8591模块和笔者的不太一样，对应通道可能会不同，可以自行测试)。 三、尽情玩耍现在，你可以尝试在树莓派上运行写好的程序，通过输出可以看到当前的可调节电压、环境亮度和环境温度的情况。你可以尝试使用螺丝刀对电位计进行调节，可以实时的看到输出电压的改变，可以关灯和开灯来改变环境亮度，你也可以将热敏传感器握在手中，这些都可以明显的从输出信息上看到环境数据的变化。如下图所示： 这次，关于树莓派编程，我们学到了一些新的东西，使用I2C总线和数模转换模块我们可以做出更多有意思的东西，比如红外控制的自制电视机？比如有有马达驱动的遥控小车？等等…。你可以做好准备，我们后面会一起开发一些更好玩的东西！ 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（6）——倾斜传感器与震动传感器实践","slug":"419一起玩转树莓派（6）——倾斜传感器与震动传感器实践","date":"2021-07-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.390Z","comments":true,"path":"2021/07/22/419一起玩转树莓派（6）——倾斜传感器与震动传感器实践/","link":"","permalink":"http://huishao.cc/2021/07/22/419一起玩转树莓派（6）——倾斜传感器与震动传感器实践/","excerpt":"","text":"一起玩转树莓派（6）——倾斜传感器与震动传感器实践通过本系列博客的前几篇文章，我们已经掌握了树莓派应用开发的基本方法。很多时候，树莓派可以做什么更多的取决于我们的创造力。本篇博客，我们将通过实践来学习在树莓派开发中常用的两个开关元件：倾斜传感器与震动传感器。 倾斜传感器和震动传感器都是一种开关元件，其可以通过外界的物理变化来改变状态。在生活中的很多报警系统中都有应用。试想一下，如果我们使用到的某个设备需要避免倾斜和震动，就可以使用这两种传感器做报警电路。 一、传感器工作原理本次实验本身的逻辑代码没有什么难度，所需要使用到的知识都是之前有涉及过的。在开始编写代码和进行实验之前，我们先来了解下倾斜传感器与震动传感器的工作原理。 1.倾斜传感器倾斜传感器又称为倾斜开关，其可以对元件相对与重力方向的倾角做出感应。早期的倾斜传感器多采用贡倾斜传感器，其管体内部使用汞作为导电介质，当有倾斜发生时，金属汞会流动到管体末端，从而接通电路。汞倾斜传感器的优点是耐用寿命长，但其对环境有害，目前已经很少使用。 当下比较流行的是球形倾斜传感器，这种传感器设计简单，管体内放入金属球，当发生倾斜时，金属球滚动接通电路。本次实验，我们采用SW520D型号的倾斜传感器，如下图所示： 其头部的管体就是倾斜开关，其搭载的功能板子分解如下： 此传感器有3个引脚，其中VCC需要接3.3-5V的电压，中间引脚接地，DO引脚是信号输出引脚，我们通过其进行倾斜感应。如上图所示，此传感器自带电源和开关两个LED灯，接通电源后，电源LED灯发光，当传感器触发倾斜时，开关LED灯发光。对于DO引脚，当开关LED发光时，其输出低电平，表示开关打开，当开关LED灯不亮时，其输出高电平，表示开关断开。用其我们可以很方便的实现倾斜断电保护功能。如上图中，此传感器还提供了一个灵敏度的电位调节单元，其工作原理电路图如下所示： 2.震动传感器震动传感器与倾斜传感器的工作原理基本一致，不同的地方只在于开关的触发方式，震动传感器感应外界的震动从而触发电路的导通。常用的震动开关有滚珠式和弹簧式两种，以弹簧式为例，当发生震动时，弹簧与电极接触，从而导通电路，本次实验我们使用的震动传感器如下图所示： 可以看到，其搭载的功能板与上面介绍的倾斜传感器完全一致，这里我们就不再赘述。 二、开始试验1.动手连线对于本次实验，我们将倾斜传感器与震动传感器作为模拟警告开关来使用，当设备发生震动或倾斜时，通过输出Log信息来做提示。首先我们先确认要使用到的GPIO引脚，对于电源和负极直接连接即可，我们暂定使用BCM编号为GPIO5和GPIO6的两个引脚，其对应的物理引脚分别为29和31。物理29引脚我们接震动传感器的信号引脚，物理31引脚我们接倾斜传感器的信号引脚。笔者这里使用扩展板连线如下图所示。如果不使用扩展板，直接连接物理引脚即可。 温馨提示：可以通过线的颜色参考示意图中的连线。 2.编写代码我们使用GPIO引脚的INPUT功能来监听传感器的状态，示例代码如下： 1234567891011121314151617181920212223242526272829303132#coding:utf-8# 导入GPIO控制薄块import RPi.GPIO as GPIO# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 定义震动开关引脚 BCM5swi_shake = 29# 定义倾斜开关引脚 BCM6swi_slop = 31# 进行开关引脚的初始化，设置为输入引脚，且默认为高电平GPIO.setup(swi_shake, GPIO.IN, pull_up_down=GPIO.PUD_UP)GPIO.setup(swi_slop, GPIO.IN, pull_up_down=GPIO.PUD_UP)# 定义状态变化的回调函数def switch_shake(channel): # 低电平为开关打开状态 if not GPIO.input(channel): print(\"注意，发生了震动！\")def switch_slop(channel): # 低电平为开关打开状态 if not GPIO.input(channel): print(\"注意，发生了倾斜！\") # 添加输入引脚电平变化的回调函数GPIO.add_event_detect(swi_shake, GPIO.FALLING, callback=switch_shake, bouncetime=200)GPIO.add_event_detect(swi_slop, GPIO.FALLING, callback=switch_slop, bouncetime=200)while True: pass 上面的代码比较简单，运行上面代码，通过触发传感器的震动与倾斜，可以观察程序的打印输出信息，同时传感器上的开关指示灯也可以提示传感器的接通状态。 三、休息一下本次实验非常简单，但是我们可以发挥创造力，通过这两个传感器做出一些有意思的东西，尽情想象吧！ 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（5）——让蜂鸣器播放音乐","slug":"418一起玩转树莓派（5）——让蜂鸣器播放音乐","date":"2021-07-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.390Z","comments":true,"path":"2021/07/18/418一起玩转树莓派（5）——让蜂鸣器播放音乐/","link":"","permalink":"http://huishao.cc/2021/07/18/418一起玩转树莓派（5）——让蜂鸣器播放音乐/","excerpt":"","text":"一起玩转树莓派（5）——让蜂鸣器播放音乐前面博客中，我们尝试使用开关控制有源蜂鸣器的播放。有源蜂鸣器的一大特点是使用简单，无需复杂的程序控制即可发声，然而其缺陷也很明显，其发声的频率是一定的，我们无法通过频率控制器音调高低。本次实验，我们将尝试使用无源蜂鸣器来进行音乐的播放。 一、实验前的准备在开始本实验前，我们先来对乐理只是和无源蜂鸣器的工作原理进行简单的学习。 1、关于音调的基础乐理知识简单的物理学知识告诉我们，声音的声调高低是有声波的频率决定的，而声音的大小是有声波的振幅决定的。人耳可以听到的声音频率在20Hz-20000Hz之间。频率低于20Hz的声波被称为次声波，我们听不到。同样，频率高于20000Hz的声波称为超声波，我们也听不到。生活中，我们都喜欢听美妙的音乐，音乐是由很多不同的音调和参差的拍子组合而成的。小时候音乐课上常说的Do，Re，Mi，Fa，So，La，Xi就是最常见的音调。我们以C大调为例，其7个音阶与对应的频率如下表所示： Do Re Mi Fa So La Xi 262 294 330 350 393 441 495 与上表对应，如果是高音音调，只需要将上面的频率乘以2，如果是低音音调，需要将上面的音频除以2。 要演奏出美妙的旋律，仅仅只控制音调是不够的，我们还需要把握每个音调演奏的节奏，即每个音调播放的时长。在乐曲中，节奏的把控是通过节拍来定义的，例如常见的四分之四节拍，指的是四分音符为一拍，每小节有四拍，这样，每遇到一个四分音符我们就播放这个音调一拍的单位时间，如果遇到八分音符，我们就播放二分之一拍的单位时间，如果遇到二分音符，我们就播放两拍的单位时间。 现在，你可以练习一下，将喜欢的歌曲翻译为编程符号，音调翻译成频率，对应的节拍翻译为毫秒时间。后面，我们将使用树莓派控制蜂鸣器来播放它。 2、无源蜂鸣器播放声音原理之前，我们分析过有源蜂鸣器的工作原理，其很好理解，电压触发器内部的振荡源工作，震荡源的震动产生一定频率的声波，从而发出声音让我们听到。无源蜂鸣器内部没有震荡源，如果直接通过直流电，其无法产生周期性的声波，因此简单的接通电源是无法使无源蜂鸣器工作的。无源蜂鸣器内部没有震荡源，但却有震荡片，当通电时，无源蜂鸣器通过电磁感应现象来吸引震荡片，当失去电流时，震荡片位置还原。因此，我们只要周期性的给蜂鸣器通电，其就会产生周期性的振荡，从而产生声波，发出声音。 由于无源蜂鸣器的这种特点，我们可以非常容易的通过控制加压的频率来实现播放不同音调的声音。相比有源蜂鸣器而言，无源蜂鸣器成本更低，且可以控制音调高低，唯一的不足之处是程序要略微复杂一些。 本次实验，我们使用的无源蜂鸣器是低电平触发的，如下图所示： 二、使用树莓派制作电子琴明白了无源蜂鸣器的工作原理，本实验对你来说应该非常简单，使用到的知识都是我们之前实验有涉及过的。当你听到视频频率来控制无缘蜂鸣器的发声时，你一定已经想到了，使用PWM脉冲宽度调制技术，其刚好可以产生指定频率的脉冲电压。 1.开始连线连线本身非常简单，只是在开始之前，我们要先确定所使用的树莓派引脚。无缘蜂鸣器有3个引脚，其中VCC接3.3V电源，GMD接地，I/O控制引脚接一个树莓派的GPIO功能引脚，我们选择BCM编码为17的GPIO引脚，即物理引脚11。笔者这里使用的扩展板连接如下图所示： 这一步非常简单，下面我们来开始程序的编写。 2.开始动手编程在本实验中，我们将编写这个一个程序，其类似一个简易的电子琴，有7个按键来发出不同音调的7种声音，同时我们内置一首示例乐曲。笔者这里选用周杰伦的《花海》前奏作为示例乐曲。完整的程序示例代码如下（我建议先自主动手实践，遇到问题再参考示例代码）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#coding:utf-8# 导入UI模块import tkinter as Tkinterimport RPi.GPIO as GPIOimport time# 定义音调频率# C调低音CL = [0, 131, 147, 165, 175, 196, 211, 248] # C调中音CM = [0, 262, 294, 330, 350, 393, 441, 495] # C调高音CH = [0, 525, 589, 661, 700, 786, 882, 990] # 定义乐谱# 音调 0表示休止符songP = [ CM[1],CM[2],CM[3],CM[5],CM[5],CM[0],CM[3],CM[2],CM[1],CM[2],CM[3],CM[0], CM[1],CM[2],CM[3],CM[7],CH[1],CH[1],CH[1],CM[7],CH[1],CM[7],CM[6],CM[5],CM[0], CM[1],CM[2],CM[3],CM[5],CM[5],CM[0],CM[3],CM[2],CM[1],CM[2],CM[1],CM[0], CM[1],CM[2],CM[3],CM[5],CM[1],CM[0],CM[1],CL[7],CL[6],CL[7],CM[1],CM[0]]# 音调对应的节拍songT = [ 2,2,2,1,5,4,2,2,2,1,5,4, 2,2,2,1,5,2,2,2,1,3,2,4,4, 2,2,2,1,5,4,2,2,2,1,3,5, 2,2,2,1,5,4,2,2,2,2,8,2]# 定义标准节拍时间metre = 0.125# 初始化要使用的引脚io = 11GPIO.setmode(GPIO.BOARD)GPIO.setup(io, GPIO.OUT)pwm = GPIO.PWM(io, 440)# 开始设置占空比为100 则无缘蜂鸣器不会发声pwm.start(100)# 播放示例乐曲的方法def playSong(): # 修改占空比为50 此时频率生效 pwm.ChangeDutyCycle(50) # 遍历所有音调 for i in range(0, len(songP)): # 0表示休止 禁声 if songP[i] == 0: pwm.ChangeDutyCycle(100) # 更改频率控制音调 else: pwm.ChangeDutyCycle(50) pwm.ChangeFrequency(songP[i]) # 通过节拍控制播放时间 time.sleep(songT[i] * metre) # 禁声 pwm.ChangeDutyCycle(100)# 分别播放各个音阶的方法def playDo(): pwm.ChangeDutyCycle(50) pwm.ChangeFrequency(CM[1]) time.sleep(0.5) pwm.ChangeDutyCycle(100)def playRe(): pwm.ChangeDutyCycle(50) pwm.ChangeFrequency(CM[2]) time.sleep(0.5) pwm.ChangeDutyCycle(100)def playMi(): pwm.ChangeDutyCycle(50) pwm.ChangeFrequency(CM[3]) time.sleep(0.5) pwm.ChangeDutyCycle(100)def playFa(): pwm.ChangeDutyCycle(50) pwm.ChangeFrequency(CM[4]) time.sleep(0.5) pwm.ChangeDutyCycle(100)def playSo(): pwm.ChangeDutyCycle(50) pwm.ChangeFrequency(CM[5]) time.sleep(0.5) pwm.ChangeDutyCycle(100)def playLa(): pwm.ChangeDutyCycle(50) pwm.ChangeFrequency(CM[6]) time.sleep(0.5) pwm.ChangeDutyCycle(100)def playXi(): pwm.ChangeDutyCycle(50) pwm.ChangeFrequency(CM[7]) time.sleep(0.5) pwm.ChangeDutyCycle(100)# UI相关设置# 主页面设置top = Tkinter.Tk()top.geometry('360x300')top.minsize(420, 300) top.maxsize(420, 300)top.title(\"自制电子琴\")l = Tkinter.Label(top, text='自制电子琴', font=('Arial', 18), width=30, height=2)l.pack()# UI上的按钮布局songBtn = Tkinter.Button(top, text=\"示例歌曲：花海\", command=playSong)songBtn.place(x=30,y=30,width=120,height=40)doBtn = Tkinter.Button(top,bitmap=\"gray50\", text=\"Do\", compound=Tkinter.LEFT, command=playDo)doBtn.place(x=0,y=105,width=60,height=200)reBtn = Tkinter.Button(top,bitmap=\"gray50\", text=\"Re\", compound=Tkinter.LEFT, command=playRe)reBtn.place(x=60,y=105,width=60,height=200)miBtn = Tkinter.Button(top,bitmap=\"gray50\", text=\"Mi\", compound=Tkinter.LEFT, command=playMi)miBtn.place(x=120,y=105,width=60,height=200)faBtn = Tkinter.Button(top,bitmap=\"gray50\", text=\"Fa\", compound=Tkinter.LEFT, command=playFa)faBtn.place(x=180,y=105,width=60,height=200)soBtn = Tkinter.Button(top,bitmap=\"gray50\", text=\"So\", compound=Tkinter.LEFT, command=playSo)soBtn.place(x=240,y=105,width=60,height=200)laBtn = Tkinter.Button(top,bitmap=\"gray50\", text=\"La\", compound=Tkinter.LEFT, command=playLa)laBtn.place(x=300,y=105,width=60,height=200)xiBtn = Tkinter.Button(top,bitmap=\"gray50\", text=\"Xi\", compound=Tkinter.LEFT, command=playXi)xiBtn.place(x=360,y=105,width=60,height=200)stopButton = Tkinter.Button(top, text=\"关闭\")stopButton.place(x=340,y=30,width=60,height=40)# 进入消息循环top.mainloop() 上面代码有比较详尽的注释，程序运行的UI效果如下图所示： 现在，尽情的玩耍吧！ 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（4）——用开关控制蜂鸣器发声","slug":"417一起玩转树莓派（4）——用开关控制蜂鸣器发声","date":"2021-07-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.390Z","comments":true,"path":"2021/07/13/417一起玩转树莓派（4）——用开关控制蜂鸣器发声/","link":"","permalink":"http://huishao.cc/2021/07/13/417一起玩转树莓派（4）——用开关控制蜂鸣器发声/","excerpt":"","text":"一起玩转树莓派（4）——用开关控制蜂鸣器发声在本系列的前几篇博客中，我们使用桌面软件控制过红绿灯，也编程点亮过炫彩的3色LED 灯。在这些实验的过程中，相信你对树莓派GPIO引脚如何输出高低电平，以及如何使用PWM技术来控制电压输出等都有了了解。本篇博客，我们将再探索一些树莓派编程更多新鲜好玩的领域，来尝试使用硬件来控制硬件。 现在，我们将尝试完成这样一个实验，使用按压开关控制蜂鸣器的发声。将开关元件和蜂鸣器都连接到树莓派，当按下开关时，让蜂鸣器发声，当松开开关时，蜂鸣器停止发声。 一、主角登场开始动手实验前，我们先来认识一下将要出场的主角们，当然，无论什么实验，树莓派都是当之无愧的第一主角，但我相信你已经对它已经有了足够的了解（如果没有，可以查看本系列的前几篇博客），因此我们将介绍的重点放在两个新登场的“角色”上：蜂鸣器与按压开关。 1.本实验的“主角甲”——有源蜂鸣器蜂鸣器，顾名思义，其是一种发声元件。广泛应用于计算机、打印机、电话、玩具等电子设备中。 蜂鸣器可以分为“有源蜂鸣器”和“无源蜂鸣器”。其中的源并非指电源，而是指蜂鸣器内部是否有震荡源。有源蜂鸣器自带一个震荡源模块，其使用起来非常简单，只要接通直流电，其就会自动发出声音。而无源蜂鸣器内部没有震荡源，需要外接使用一定频率的方波来驱动其发声。关于无源蜂鸣器更多深入的用法，我们后续博客再专门介绍。这里，我们先着重理解有源蜂鸣器的工作原理。 本实验中，我们采用的是低电平触发的有源蜂鸣器，元件如下图所示： 其有3个引脚，GND引脚用来接地，VCC引脚用来接3.3V的电源，I/O引脚用来进行蜂鸣器是否播放声音的控制。你可能有些疑惑，为什么低电平也可以触发元件的“开”状态，这要归功于PNP型三极管的功劳，对于PNP型三极光，当输入管脚为低电平时，三极管处于导通状态，使得蜂鸣器被加电压，当输入管脚为高电平时，三极管处于截止状态，蜂鸣器无电压。原理如下图所示： 现在，我们先来编写一段简单的Python程序，来使蜂鸣器发出声音。 2. 触发蜂鸣器播放声音我们使用的蜂鸣器的3个引脚，其中VCC接电源，GND接地，I/O引脚我们可以选择树莓派BCM编码为27的GPIO引脚，通过查表，可以得到其物理编码为13。连线示意如下： 编写Python程序代码如下： 12345678910111213141516171819202122232425262728293031#coding:utf-8# 导入GPIO控制薄块import RPi.GPIO as GPIO# 导入time模块import time# 定义引脚fm = 13# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 进行引脚的初始化，因为是低电平触发，初始时设置为高电平GPIO.setup(fm,GPIO.OUT, initial=GPIO.HIGH)# 进行一长两短的声音播放# 播放1秒声音GPIO.output(fm, GPIO.LOW)time.sleep(1)GPIO.output(fm, GPIO.HIGH)time.sleep(0.1)# 播放0.5秒声音GPIO.output(fm, GPIO.LOW)time.sleep(0.5)GPIO.output(fm, GPIO.HIGH)time.sleep(0.1)# 播放0.5秒声音GPIO.output(fm, GPIO.LOW)time.sleep(0.5)# 停止蜂鸣器播放GPIO.output(fm, GPIO.HIGH)GPIO.cleanup() 在树莓派上运行代码，你应该已经可以听到蜂鸣器发出一长两短的鸣叫声了。 3.本实验的“主角乙”——按压开关按压开关是电子设备中最为常用的一种元件，关于按压开关本身的结构和原理，其实非常简单，其按键内部会有弹簧进行控制，当没有外力作用时，弹簧会将开关自动顶起，接触器上升。当外力将按键按下时，接触器下降。通过接触器的上升和下降来控制电路的导通。如下图所示： 本次实验，我们使用的按压开关元件如下图所示： 我们使用的此开关当按键按下式，会向引脚输入低电平，当按键松开时，会向引脚输入低电平。在连线时，按压开关的“-”引脚接地，中间引脚节3.3V电压，“S”引脚接GPIO信号引脚，我们可以将其接BCM编码为GPIO5的引脚，其物理编码为29。连线如下图所示： 下面，我们要来学习点新东西了，如何获取到GPIO引脚的输入。 4. 使用GPIO输入信号之前，我们都是将GPIO作为输出引脚进行使用，即让GPIO输出高电平或低电平从而控制元件。其实还有很多场景，需要读取GPIO的输入信号，例如各种传感器和开关元件。通常，我们可以采用两种方式来获取GPIO的输入信号：轮询式或中断式。 轮询式很好理解，即我们不停的询问当前GPIO引脚：输入的信号是什么啊？之后GPIO会将当前的输入信息告诉我们，这种不停的读取某个GPIO引脚的值的方式就是轮询式获取输入信号。更多时候，我们会采取中断式，中断式是指在程序运行过程中，如果出现外部事件，则中断当前程序运行来处理外部事件。在本实验中，开关的按下和松开就可以理解为中断事件。 需要注意，对于作为输入使用的GPIO引脚来说，当我们未接任何输入源时，其值可能是任意的，即其值是浮动且不可控的，因此我们需要为其配置一个默认值，硬件上，我们通常使用下拉电阻或上拉电阻。软件上我们也可以通过GPIO库的相关接口来实现同样的功能，例如使用下面的方式初始化引脚： 1234# 将引脚初始化为输入引脚，同时设置默认值为高电平GPIO.setup(channel, GPIO.IN, pull_up_down=GPIO.PUD_UP)# 将引脚初始化为输入引脚，同时设置默认值为低电平GPIO.setup(channel, GPIO.IN, pull_up_down=GPIO.PUD_DOWN) 若要获取到某个输入引脚当前的电平情况，可以使用如下方法： 12# 1表示高电平 0表示低电平GPIO.input(channel) 例如可以通过如下的方式轮训检查某个引脚的输入： 12while GPIO.input(channel) == GPIO.LOW: time.sleep(0.01) 我们通常只需要关心电平的变化，以及变化方向，以本实验为例，当按下开关时，电平由低变高，当松开开关时，电平由高到低。下面方法可以中断当前程序的运行，等待电平变化的信号： 12# 当channel引脚由低电平变到高电平时会触发向后执行, timeout设置超时时间GPIO.wait_for_edge(channel, GPIO.RISING, timeout=5000) GPIO.RISING表示要等待的是由低到高的电平变化，与之对应的还有GPIO.FALLING表示由高到低的电平变化，GPIO.BOTH表示两个方向的电平变化都会触发。 对于本实验的场景，GPIO.wait_for_edge方法并不实用，如果我们要采用轮询的方式获取GPIO输入信号，则可以实用下面的方法： 12345# 为channel输入引脚添加[从低到高]的电平变化监听GPIO.add_event_detect(channel, GPIO.RISING) # 下面的判断可以放在轮询中，只要有[从低到高]的电平变化，即会命中if判断if GPIO.event_detected(channel): print('从低到高变化') 需要注意，GPIO.add_event_detect方法比直接轮询通过GPIO.input方法获取信号要可靠的多，直接轮询可能会错过某些电平变化事件，而GPIO.add_event_detect 不会。在使用GPIO.add_event_detect方法时，我们也可以直接设置回调函数，当有变化发生时，即会执行到回调函数，例如： 12345# 定义回调函数def my_callback(channel): pass# 注册回调函数 bouncetime参数用来进行防抖GPIO.add_event_detect(channel, GPIO.RISING, callback=my_callback, bouncetime=200) 上面示例代码中，bouncetime参数能够提供软件防抖的功能，其单位为毫秒，200毫秒内的多次电平变化来回将被忽略。 最后，如果你不再需要监听，可以使用如下方法移除： 1GPIO.remove_event_detect(channel) 5. 获取按压开关元件的状态现在，我们可以尝试使用树莓派读取按压开关元件的开关状态了。示例代码如下： 12345678910111213141516171819202122232425262728#coding:utf-8# 导入GPIO控制薄块import RPi.GPIO as GPIO# 导入time模块import time# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 定义开关引脚swi = 29# 进行开关引脚的初始化，设置为输入引脚，且默认为高电平GPIO.setup(swi, GPIO.IN, pull_up_down=GPIO.PUD_PU)# 定义状态变化的回调函数def switch(channel): # 高电平的开关松开 if GPOI.input(channel): print(\"开关松开\") # 低电平为开关按下 else: print(\"开关按下\") # 添加输入引脚电平变化的回调函数GPIO.add_event_detect(swi, GPIO.BOTH, callback=switch, bouncetime=200)# 开启循环while True: pass 在树莓派运行上面代码，通过按压和松开开关，观察控制台的输出是否正确。 二、开关控制蜂鸣器播放如果你成功做完了前面的工作，那么好了，本节的内容将非常简单，只需要将上面编写的蜂鸣器程序和开关程序进行结合，你就可以使用开关来控制蜂鸣器了。示例代码如下： 1234567891011121314151617181920212223242526272829303132#coding:utf-8# 导入GPIO控制薄块import RPi.GPIO as GPIO# 导入time模块import time# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 定义开关引脚swi = 29# 定义蜂鸣器引脚fm = 13# 进行开关引脚的初始化，设置为输入引脚，且默认为高电平GPIO.setup(swi, GPIO.IN, pull_up_down=GPIO.PUD_UP)# 进行蜂鸣器引脚的初始化，因为是低电平触发，初始时设置为高电平GPIO.setup(fm,GPIO.OUT, initial=GPIO.HIGH)# 定义状态变化的回调函数def switch(channel): # 高电平的开关松开 if GPI0.input(channel): GPIO.output(fm, GPIO.HIGH) # 低电平为开关按下 else: GPIO.output(fm, GPIO.LOW) # 添加输入引脚电平变化的回调函数GPIO.add_event_detect(swi, GPIO.BOTH, callback=switch, bouncetime=200)# 开启循环while True: pass 现在，运行程序，用开关来控制蜂鸣器的声音播放吧。恭喜！你已经能够使用硬件来控制硬件了！ 三、休息一下吧通过本篇博客，你应该收获了GPIO输入信号的编程方法，以及通过GPIO读取有输入功能的传感器数据的方法。本篇博客涉及的内容很多，重点在于GPIO输入引脚中断的相关用法，需要你多多练习。说了这么多，你有没有发现这次我们完成的实验很像生活中的一种东西？没错，就是门铃，你已经可以使用树莓派实现一个简单的门铃器件啦。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（3）——点亮RGB炫彩LED灯","slug":"416一起玩转树莓派（3）——点亮RGB炫彩LED灯","date":"2021-07-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.390Z","comments":true,"path":"2021/07/10/416一起玩转树莓派（3）——点亮RGB炫彩LED灯/","link":"","permalink":"http://huishao.cc/2021/07/10/416一起玩转树莓派（3）——点亮RGB炫彩LED灯/","excerpt":"","text":"一起玩转树莓派（3）——点亮RGB炫彩LED灯在阅读本篇博客之前，如果你对树莓派的GPIO还没有基本的了解，我建议你先阅读本系列博客的上一篇，关于双色LED灯实验的。了解树莓派GPIO的基本用法是进行本篇博客实验的基础。上篇博客地址如下： https://my.oschina.net/u/2340880/blog/5123429 现在，如果你已经成功完成过树莓派双色LED灯实验，并且对深入树莓派玩法有更多的兴趣的话，那么我们在进一步，尝试点亮一个更加绚丽的LED灯：RGB3色LED灯。 一、认识RGB三原色LED灯并连线通过前面的实验，我们已经知道，双色的LED灯内部封装了红绿两个发光二极管，其有3个引脚，其中1个引脚是共用的(共阴或共阳)，对于共阴型的双色LED灯，控制另外两个引脚的高低电平来分别点亮红灯或绿灯。对于RGB3色LED灯也类似，只是其内部封装了3个发光二极管，分别可以发出红光，绿光和蓝光。其有4个引脚，1个引脚共用和3个控制发光二极管的引脚。 本次实验，我们依然采用共阴型的RGB3色LED灯，元件如下图所示： 共阴型的LED灯，GND引脚是其公共的阴极，接线的时候我们需要将此引脚接地，另外3个引脚分别接3个GPIO来控制亮灯。下面两种图，非常直观的演示了此LED灯的工作原理： 在将LED灯连接到树莓派之前，我们需要预定几个要用的GPIO引脚，之后我们在编写代码时，依然采用物理编码，首先我们先确定要使用的GPIO引脚的BCM编码下的GPIO18，GPIO19和GPIO20，通常查看引脚编码对应图，我们可以找到其所对应的物理引脚分别为12，24和28。如果不使用扩展板，直接将原件上的对应引脚连接到树莓派的这些物理引脚上即可，如果使用的是BCM编码的扩展板，则我们在连线时无需关心这些物理引脚，直接连接即可，如下： 好了，现在我们已经完成了基本的连线工作。 二、三原色与脉冲宽度调制三原色本指色彩中不能再分解的三种基本颜色，在光学上，红、绿、蓝为最基本的三原色。三原色经过混合后，可以组成各式各样的颜色。例如将三原色等比混合后将能组成白色，将红色和绿色组合后会生成黄色，将红色和蓝色混合后会得到紫色等等。如下图所示： 因此，从原理上说，我们只要可以控制RGB灯三种颜色的显示亮度，就可以让LED灯调制出各种颜色。控制LED等中各个发光二极管的亮和灭非常简单，我们只需要向其加高电平或低电平即可，那么如何控制发光二极管的亮度呢？我们需要使用到另外一种电流控制技术：PWM脉冲宽度调制。 脉冲宽度调制(PWM)是一种模拟控制方式，其通过控制脉冲电压中高电压的占空比来控制流过元件的电流大小。PWM技术中有两个非常重要的参数：频率与占空比。频率用来控制脉冲信号的周期，如果频率过低，在控制LED灯的时候，灯就会进行闪烁，当频率足够高，人眼已无法分辨出其闪烁，看上起LED灯就是常亮的。占空比指的是在输出的脉冲信号中，高电平保持的时间与该脉冲信号的周期时间之比。例如，假设设置周期为100Hz，则其周期时间为10ms，如果设置的占空比为20%，则当前周期中，高电平的占比时间为2ms。 Python的GPIO库中提供了PWM控制接口，使用也非常简单，使用如下方法可以获取某个引脚的PWM实例： 1p = GPIO.PWM(channel, frequency) 其中，channel参数为引脚编码，frequency参数为设置的PWM频率。下面方法用来开启PWM脉冲： 1p.start(dc) 其中，dc参数设置脉冲的高电平占空比，取值范围为0-100。 通过下面的方法可以对PWM脉冲频率和占空比进行修改： 12p.ChangeFrequency(freq) p.ChangeDutyCycle(dc) 需要结束PWM脉冲调制时，可以调用如下方法： 1p.stop() 三、点亮炫彩的三彩LED灯现在，我们已经做好了所有准备工作，可以开始编码了。我们要实现这样一个功能，当程序运行时，先控制LED灯的红灯，绿灯，靛色灯分别亮2秒，之后通过脉冲混合，让LED灯进行各种颜色的炫彩闪烁，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8# 导入GPIO控制薄块import RPi.GPIO as GPIO# 导入time模块import time# 导入系统模块import sys# 定义引脚(物理引脚)R,G,B = 12,35,38# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 对要使用的引脚进行初始化GPIO.setup(R,GPIO.OUT)GPIO.setup(G,GPIO.OUT)GPIO.setup(B,GPIO.OUT)# 使用PWM脉冲宽度调制pR = GPIO.PWM(R, 60)pG = GPIO.PWM(G, 60)pB = GPIO.PWM(B, 60)# 开启脉冲，默认的占空比为0，灯不亮pR.start(0)pG.start(0)pB.start(0)# 初始时，各种颜色点亮2秒# 红灯先亮2秒pR.ChangeDutyCycle(100)pG.ChangeDutyCycle(0)pB.ChangeDutyCycle(0)time.sleep(2)# 替换为绿灯亮2秒pR.ChangeDutyCycle(0)pG.ChangeDutyCycle(100)pB.ChangeDutyCycle(0)time.sleep(2)# 替换为靛色灯亮2秒pR.ChangeDutyCycle(0)pG.ChangeDutyCycle(0)pB.ChangeDutyCycle(100)time.sleep(2)# 定义要闪烁的时间 这里定义为10秒endTime = 100current = 0# 开始进行炫彩闪烁while True: # 通过占空比控制红色的占比 for r in range(0, 101, 10): pR.ChangeDutyCycle(r) # 通过占空比控制绿色的占比 for g in range(0, 101, 10): pG.ChangeDutyCycle(g) # 空通过占空比控制蓝色的占比 for b in range(0, 101, 10): pB.ChangeDutyCycle(b) time.sleep(0.1) current += 1 # 结束程序 if (current &gt; endTime): pR.stop() pG.stop() pB.stop() GPIO.cleanup() sys.exit(0) 在树莓派上运行此程序，注意！小心不要被太亮的LED闪到了眼睛😝。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（2）——从双色LED灯开始","slug":"415一起玩转树莓派（2）——从双色LED灯开始","date":"2021-07-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.389Z","comments":true,"path":"2021/07/07/415一起玩转树莓派（2）——从双色LED灯开始/","link":"","permalink":"http://huishao.cc/2021/07/07/415一起玩转树莓派（2）——从双色LED灯开始/","excerpt":"","text":"一起玩转树莓派（2）——从双色LED灯开始双色LED灯实验是入门树莓派GPIO外设编程的最简单的实验项目，我们也以其投石问路，来进入树莓派的编程世界。 一、从了解GPIO开始GPIO全称General-purpose input/output，即通用型输入输出，其引脚能够供使用者自由的进行使用，可以对其进行输入，也可以读取其数据进行数据输出，这些引脚的输入或输出都会关联到某个寄存器，寄存器的值控制引脚的电平高低。 以笔者使用树莓派3B+为例，其有40个GPIO引脚，在开始编程之前，我们首先要搞清楚每个引脚的功能意义，从树莓派官网的文档中可以找到GPIO引脚的功能介绍，如下图所示： 我们并不需要对树莓派的GPIO引脚做深入的记忆，只需要记住当正面摆放树莓派时，其最左上角的一个引脚对应的是5V电压的功能，之后对照此图即可确定每一个引脚的功能。后面我们会通过GPIO扩展板加面包板的方式来使用这些引脚，扩展板上默认会标注一些引脚功能，我们使用起来会更加方便。 笔者使用的扩展板引脚标注示如下： 使用排线将其与树莓派正向连接，如下图所示： 可以看到扩展板上的引脚标注与树莓派本身的引脚排布并不一致，下面我会给大家介绍如何定位到要使用的引脚。 二、关于GPIO引脚编码常用的GPIO引脚编码有3种。 我们也可以在树莓派的终端输入如下指令查看GPIO引脚功能： 1pinout 输出效果如下图所示： 需要注意，上图中的GPIO使用的是逻辑编码，从1开始，实际上BCM编码并不是从1开始的。 第1种：BOARD物理编码物理编码比较好理解，也很直观，其就是根据树莓派上40个引脚的位置进行排序编码，如博客中第一张图所示，正向放置树莓派时，第2排的第1个引脚编号为1，第1排第1个引脚编号为2，依次类推。后面在编写代码时，我们使用的编码方式也是这种。 第2种：BCM编码BCM编码是一种更底层的编码方式，与系统中信道编号相对应。在使用一个引脚时，如果使用BCM编码，首先需要查找信道号和物理引脚编号之间的对应规则。对于不同的树莓派版本，可能无法兼容。下图很好的描述了几种编码的信息： 上面我们扩展板上GPIO引脚的标注，实际上使用的就是BCM编码，这也就是说，如果我们要使用树莓派GPIO2和GPIO3两个功能引脚，指定的是物理引脚需要是13和15。直接将线连接到扩展板的G22和G27一行即可，非常直观。 第3种：WiringPi编码WiringPi编码对应的引脚号是在wiringPI库中所使用的，网上很容易找到其编码的相关资料，本系列博客我们不会使用到这个编码，这里不再赘述。 现在，我们总结一下如何使用GPIO引脚。 首先在上图中找到自己要使用的功能引脚，如GOIP.2和GPIO.3两个功能引脚。 之后找到其对应的物理引脚，即13和15。 如果不使用扩展板，则直接接线物理引脚，如果要使用，则找到其对应的BCM编码，27和22。 使用扩展板上的G27和G22引脚插槽。 三、了解双色LED灯并接线双色LED灯构造非常简单，顾名思义，其可以发出两种颜色的光，其内部封装了两个发光二极管。双色LED分为共阴型和共阳型，两个发光二极管共有3个引脚，因此其中一个引脚是共用的。对于共阴型的，两个发光二极管的阴极连在一起。对于共阳型的，两个二极管的阳极连在一起。我们这次使用的将是共阴极的双色LED灯，如下图所示： 其内部工作原理电路图如下，也非常好理解： 如上图所示，可以看到两个二极管的阴极是共用，我们将其公共引脚接地即可，两个阳极是由两个开关控制，即LED等芯片上的另外两个引脚，我们只需要通过GPIO控制将对应的引脚加高电平，即可将二极管点亮。 开始接线 我们已经了解了双色LED等的工作原理，其有3个引脚，我们将引脚“-”接地，S端的引脚接扩展板G22用来控制红灯，中间的引脚接G27用来控制绿灯。接线情况如下图所示： 现在，准备工作大功告成，开始我们的编码工作吧。 四、编写红绿灯控制程序目前为止，我们已经做了足够多的准备工作，你一定已经迫不及待的想要开始编码了，我们先把完整的代码奉上： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#coding:utf-8# 导入UI模块import tkinter as Tkinter# 导入GPIO控制薄块import RPi.GPIO as GPIO# 定时器模块import threading# 主页面设置top = Tkinter.Tk()top.geometry('500x300')top.title(\"双色LED灯控制器\")l = Tkinter.Label(top, text='欢迎使用双色LED灯控制器', bg='green', font=('Arial', 18), width=30, height=2)l.pack()# 定义引脚pins = &#123;0:13,1:15&#125;# 设置使用的引脚编码模式GPIO.setmode(GPIO.BOARD)# 设置隐藏警告GPIO.setwarnings(False)# 初始化物理引脚 13 和 15GPIO.setup(pins[0],GPIO.OUT)GPIO.setup(pins[1],GPIO.OUT)# 定义全局字段 用来处理闪烁功能# f:是否闪烁 l:下次点亮红灯或绿灯f = Falsel = False# 控制红灯亮def redClick(): global f f = False GPIO.output(pins[0],GPIO.HIGH) GPIO.output(pins[1],GPIO.LOW) # 控制绿灯亮def greenClick(): global f f = False GPIO.output(pins[0],GPIO.LOW) GPIO.output(pins[1],GPIO.HIGH)# 退出程序def stopClick(): global f f = False GPIO.output(pins[0],GPIO.LOW) GPIO.output(pins[1],GPIO.LOW) GPIO.cleanup() exit()# 循环闪烁def loop(): global f global timer global l if f == False: return timer = threading.Timer(2,loop) timer.start() if l: GPIO.output(pins[0],GPIO.HIGH) GPIO.output(pins[1],GPIO.LOW) else: GPIO.output(pins[0],GPIO.LOW) GPIO.output(pins[1],GPIO.HIGH) # 转换下次闪烁的颜色 l = not l# 定义全局定时器timer = threading.Timer(2, loop)# 开始进行闪烁def flckerClick(): global f global timer f = True timer = threading.Timer(2,loop) timer.start()# UI上的按钮布局redButton = Tkinter.Button(top, text=\"红灯停\", height='3', command=redClick)redButton.pack()greenButton = Tkinter.Button(top, text=\"绿灯行\", height='3', command=greenClick)greenButton.pack()flckerButton = Tkinter.Button(top, text=\"闪烁请注意\", height='3', command=flckerClick)flckerButton.pack()stopButton = Tkinter.Button(top, text=\"关闭\", height='3', command=stopClick)stopButton.pack()# 进入消息循环top.mainloop() 在树莓派上运行上面的代码，你现在应该已经可以灵活的控制双色LED灯的开关和闪烁了，如下图所示： 温馨提示：如果你使用的是Python3.x版本，可能需要用如下的方式引入tkinter： 1import Tkinter as Tkinter Tkinter是Python内置的一个UI框架，我们这里不做过多介绍，我们将重点放在RPi.GPIO模块的使用。 RPi.GPIO能够帮助我们方便的控制树莓派的GPIO引脚。在进行树莓派编程时，如果使用GPIO库，首先需要设置要使用的编码方式： 1GPIO.setmode(GPIO.BOARD) GPIO.BOARD将设置使用物理编码模式，GPIO.BCM将设置使用BCM编码模式。 在使用某个引脚之前，我们需要对其进行初始化，初始化时，可以将引脚设置成GPIO.OUT也可以设置为GPIO.IN，OUT表示我们要将其作为输出引脚使用，IN表示我们要将其作为输入引脚使用。 最后，当我们停止使用时，要记得调用如下方法进行资源清理： 1GPIO.cleanup(channel) 五、休息一下好了，第一个简单的树莓派实践到此要告一段落了，我相信你一定有些收获，发挥你的创新与动手能力，尝试用树莓派做更多有趣的事情吧。 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"一起玩转树莓派（1）——简介与环境搭建","slug":"414一起玩转树莓派（1）——简介与环境搭建","date":"2021-07-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.389Z","comments":true,"path":"2021/07/03/414一起玩转树莓派（1）——简介与环境搭建/","link":"","permalink":"http://huishao.cc/2021/07/03/414一起玩转树莓派（1）——简介与环境搭建/","excerpt":"","text":"一起玩转树莓派（1）——简介与环境搭建一、引子树莓派开发设计的初衷是为了学生们能够更加方便的进行编程学习，但其一经发布，其实际上所得到的应用要比设计之初所预想的广泛许多。其本质是一款尺寸只有信用卡大小的微型电脑，虽然其是微型电脑，但其性能十分强大，并且支持输出音视频，支持标准USB外设，以及集成了蓝牙等通信芯片。我们可以在台式电脑上进行的工作，几乎都可以在树莓派上进行。其麻雀虽小，但五脏俱全，与普通台式电脑不同的是，树莓派暴露了GPIO接口，我们可以十分方便的使用树莓派控制各式各样的外设和传感器，可以DIY各种有趣的电子设备。 本系列博客是笔者在工作之余，在玩树莓派过程中记录的学习过程与心得感悟，同时希望与有同样爱好的朋友们分享，一起发挥想象与创新能力，玩的开心，同时学习巩固更多嵌入式，Linux与Python相关的知识。 总体来说，如果你满足如下任意一项，那么本系列播放将非常适合你阅读，也期待与你的交流： 想要学习编程技能的朋友。 想要熟悉Linux，学习Python语言的朋友。 对树莓派感兴趣，但是不知道树莓派能够干什么的朋友。 有硬件DIY想法，却不知如何入门的朋友。 二、开机之旅目前，树莓派主要分为A型和B型两种，其配置略有不同，总体来说，A型USB接口较少，无有线网络接口，内存较小。B型拥有更多的USB插口，支持有线网络内存和功率都更高。新的树莓派新增了B+版本，其功耗更低而性能更强，并且将通用的输入输出引脚增加到40个。 要开启树莓派的探索之旅，首先你需要拥有一些硬件设备，可以在官网买到最新版本的树莓派板子，官网地址如下： https://www.raspberrypi.org/ 当然你也可以方便的在电商网站上买到树莓派相关的套装，我建议对于初学者，尽可能的搞齐如下设备： 版本尽量新的树莓派板子 内存大于8G的SD卡 USB鼠标 USB键盘 USB-HDMI接口的显示器 USB无线网卡 如上列出的6项中，树莓派板子和SD内存卡是必须的，板子是树莓派的主机，SD卡出了为树莓派提供外存能力外，还是树莓派的系统盘。后4项不是必须的，但是对于新手来说，拥有显示器和键鼠外设，可以极大的降低树莓派配置的难度，避免引入过高的入门门槛导致大家丧失学习编程的兴趣，对于显示器，我们一般不需专门准备，只需要在环境配置时借用台式机的显示器来做一些配置操作即可，后续只要树莓派和台式电脑在同一网络下，我们可以使用台式机来远程登录树莓派进行操作，台式机与树莓派并不需要两台显示器。USB无限网卡也是十分必要的，树莓派的一大特点是小巧便于携带，如果其受到网线的限制将会大大失去其便携性。 硬件准备好后，首先需要准备树莓派的Linux系统，关于Linux系统的相关内容，网上的资料很多，这里就不再过多的赘述，我们只需要了解其是一个开源的易定制的操作系统即可。对于树莓派来说，有专用的Linux版本，其也被称为Raspberry Pi OS。 首先，在如下官方网站可以下载到此系统的安装工具： https://www.raspberrypi.org/software/ 如下图所示，我们在现在时，需要选择当前所使用电脑的系统版本： 下载完成后，安装并打开下载的软件，如下图所示： 我们将准备好的SD卡插入电脑设备，之后在此软件中选中此SD卡，并选择要安装的操作系统，点击烧录即可一键完成系统的安装，可选择的操作系统有很多，我们可以根据需要来选择，一般选择推荐的即可，如下图： 烧录完成后，我们就准备好了树莓派的系统盘，需要注意，每次烧录都会将SD卡格式化，因此在烧录之前要妥善备份你的数据。 下面可以将树莓派插上SD卡，接通电源进行开机，通过简单的系统引导与配置，如果有接显示设备，你应该已经可以看到操作系统的桌面了，如下： 这个为树莓派专门定制的Linux系统默认安装了一些编程学习软件，Java，Python以及少儿编程热门的Scratch等。 三、远程登录树莓派在操作树莓派时，更多时候我们会采用原生登录的方式进行控制，通过ssh我们可以远程登录树莓派的桌面系统，也可以通过终端登录到Linux的终端模式进行操作。首先，在树莓派机上开启ssh和远程桌面权限，如下图所示，首先打开树莓派配置工具： 将Interfaces配置项中的SSH和VNC修改为Enable，如下图： 下面，打开树莓派设备上的终端应用，输入如下指令查看其网络ip地址： 1ifconfig 之后我们需要将输出的ip地址信息记住，如下图所示： 需要注意，笔者的树莓派是连接的路由器的无线网络，因此其ip是内网的，如果要远程登录，需要再统一内网中，这里的ip地址是192.168.1.27。 之后，在其他设备上打开终端(Mac设备)或命令行(Windows设备)，输入如下指令即可远程登录树莓派： 1ssh pi@192.168.1.27 树莓派默认的系统用户名为pi，登录密码为raspberry。登录成功后，我们即可以在终端进行树莓派上Linux系统的相关操作。 对于初学者来说，使用命令操作Linux系统还是略显困难，因此如果可以直接通过GUI桌面来远程使用树莓派就更加方便了，我们安装的树莓派系统默认也是支持的，上面我们打开的VNC权限就是为了进行远程桌面控制，首先在台式或笔记本电脑上安装VNC 软件，地址如下： https://www.realvnc.com/en/connect/download/viewer/ 下载对应系统的版本即可，如下图所示： 下载安装完成后，打开此软件，新建一个连接，输入树莓派的ip地址，用户名和密码，即可登录远程桌面，如下图： 完成后，远程操作树莓派就变得非常轻松了，我们可以像使用普通台式电脑一样使用树莓派，笔者平时使用的是Mac电脑，远程操作树莓派效果如下图所示： 好了，目前为止，我们已经完成了树莓派的基本配置工作，后面就看我们的想象力与创造力，怎么来玩转它了！ 专注技术，懂的热爱，愿意分享，做个朋友 QQ：316045346","categories":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://huishao.cc/categories/Linux/"}]},{"title":"iOS研习记——记MJExtension多线程Crash的解决历程","slug":"413[iOS研习记]——记MJExtension多线程Crash的解决历程","date":"2021-04-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.389Z","comments":true,"path":"2021/04/02/413[iOS研习记]——记MJExtension多线程Crash的解决历程/","link":"","permalink":"http://huishao.cc/2021/04/02/413[iOS研习记]——记MJExtension多线程Crash的解决历程/","excerpt":"","text":"[iOS研习记]——记MJExtension多线程Crash的解决历程难缠的Crash问题本篇博客的起源是由于收集到线上用户产生的一些难缠的Crash问题，通过堆栈信息观察，Crash的堆栈信息主要有两类： 一类如下： 1234561 MJExtensionDemo 0x000000010903a5e0 main + 0,2 MJExtension 0x000000010923f00d +[NSObject(MJClass) mj_setupBlockReturnValue:key:] + 333,3 MJExtension 0x000000010923ec86 +[NSObject(MJClass) mj_setupIgnoredPropertyNames:] + 70,4 MJExtensionTests 0x00000001095ebe1b -[MJExtensionTests testNestedModelArray] + 1467,5 CoreFoundation 0x00007fff204272fc __invoking___ + 140,6 CoreFoundation 0x00007fff204247b6 -[NSInvocation invoke] + 303, 一类如下: 12345671 MJExtensionDemo 0x000000010729e5e0 main + 0,2 MJExtension 0x00000001074a3255 +[NSObject(MJClass) mj_totalObjectsWithSelector:key:] + 453,3 MJExtension 0x00000001074a2ccf +[NSObject(MJClass) mj_totalIgnoredPropertyNames] + 47,4 MJExtension 0x00000001074a3dcb -[NSObject(MJKeyValue) mj_setKeyValues:context:] + 443,5 MJExtension 0x00000001074a3bdf -[NSObject(MJKeyValue) mj_setKeyValues:] + 79,6 MJExtension 0x00000001074a6536 +[NSObject(MJKeyValue) mj_objectWithKeyValues:context:] + 710,7 MJExtension 0x00000001074a623f +[NSObject(MJKeyValue) mj_objectWithKeyValues:] + 79, 此时使用的MJExtension版本为3.2.4，虽然堆栈信息比较清楚，然而其最后的调用都是在MJExtension内部，且发生此Crash的几率非常小(约为万分之几)，定位和解决此Crash并不容易。 通过分析，发现此Crash有如下特点： 调用栈中最终定位到的函数都在MJExtension进行JSON转对象或模型setup配置时。 只有在多线程使用MJExtension方法时会出现此Crash。 是App在某次版本更新后才开始出现此类Crash。 通过分析上面的特点，可以推理出： 问题一定出在mj_objectWithKeyValues方法或mj_setup相关方法中。 此问题一定是由于业务的某种使用方式或场景的改变触发的。 一定和多线程相关，推测和锁可能相关。 问题的定位与复现对于iOS端开发，定位和解决Crash毕竟两个流程，首先是根据线索来分析和定位问题，得到一个大概的猜想，之后按照自己的猜想去提供外部条件，来尝试复现问题，如果问题能够成功复现并复原与线程问题相似的堆栈现场，则基本完成了90%的工作，剩下的10%才是修复此问题。 首先，根据前面我们对问题的分析和推理，可以从mj\\_objectWithKeyValues和mj\\_setup方法进行切入，通过对MJExtension代码的Review，可以发现这些方法中有一个宏使用的非常频繁，后来也证明问题确实出在这个宏的定义上： 这几个宏的定义如下： 123456789101112131415161718#ifndef MJ_LOCK#define MJ_LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);#endif#ifndef MJ_UNLOCK#define MJ_UNLOCK(lock) dispatch_semaphore_signal(lock);#endif// 信号量#define MJExtensionSemaphoreCreate \\static dispatch_semaphore_t signalSemaphore; \\static dispatch_once_t onceTokenSemaphore; \\dispatch_once(&amp;onceTokenSemaphore, ^&#123; \\ signalSemaphore = dispatch_semaphore_create(1); \\&#125;);#define MJExtensionSemaphoreWait MJ_LOCK(signalSemaphore)#define MJExtensionSemaphoreSignal MJ_UNLOCK(signalSemaphore) 可以看到，这个宏的最终使用方式是通过信号量来实现锁逻辑。问题出在static和宏定义本身，宏定义是做简单的替换，因此在实际使用时，dispatch_semaphore_t信号量变量被定义成了局部静态变量，局部静态 变量有一个特点：其被创建后会被放入全局数据区，但是其受函数作用域的控制，即创建后不会销毁，函数内永远可用，但是对函数外来说是隐藏的。如果在不同的函数中使用了相同名称的静态局部变量，真正放入全局数据区的实际上是多个不同的变量。 我们可以通过查看C文件编译后的.o可执行文件来验证局部静态变量的这一特点： 测试代码如下： 1234567891011&gt; #include &lt;stdio.h&gt;&gt; &gt; int main(int argc, const char * argv[]) &#123;&gt; static char *string = \"hello\";&gt; return 0;&gt; &#125;&gt; &gt; void func1() &#123;&gt; static char *string = \"world\";&gt; &#125;&gt; 查看.o文件的布局信息如下： 可以看到，实际存储的静态变量名都被加上了函数前缀。 到此，我们基本将问题定位到了，当多线程对MJExtension中的多个不同的函数进行调用时，如果这些函数中都有此加锁逻辑，实际上这个锁逻辑并没有生效，会产生多线程数据读写Crash。要复现这个场景就非常简单了： 12345678910dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; for (int i = 0; i &lt; 1000; i++) &#123; MJStatusResult *result = [MJStatusResult mj_objectWithKeyValues:dict]; &#125;&#125;);for (int i = 0; i &lt; 1000; i++) &#123; [MJStatus mj_setupIgnoredPropertyNames:^NSArray *&#123; return @[@\"name\"]; &#125;];&#125; 通过场景复现，基本可以定位此问题原因。 几个疑问的解答1. 产生此Crash的核心原理多线程锁失效导致的多线程读写异常。 2.为何版本更新后会出现需要从业务使用上来分析，之前的版本类似mj_setup相关方法的调用会放入类的+load方法中，这个在main函数调用之前，所有类的解析配置都已完成，基本不会出现多线程问题，新版本做了冷启动的优化，将mj_setup相关方法放入了+(void)initialize方法中，使得多线程问题被触发的概率大大增加了。 MJExtension后续版本截止到本篇博客编写时间，MJExtension最新版本3.2.5已经处理了这个锁问题的Bug，其修复方式是将static修改为了extern，使这个信号量变量被声明为了一个全局变量，如下： 1234567891011121314151617181920#ifndef MJ_LOCK#define MJ_LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);#endif#ifndef MJ_UNLOCK#define MJ_UNLOCK(lock) dispatch_semaphore_signal(lock);#endif// 信号量#define MJExtensionSemaphoreCreate \\extern dispatch_semaphore_t mje_signalSemaphore; \\extern dispatch_once_t mje_onceTokenSemaphore; \\dispatch_once(&amp;mje_onceTokenSemaphore, ^&#123; \\ mje_signalSemaphore = dispatch_semaphore_create(1); \\&#125;);// .m文件中dispatch_semaphore_t mje_signalSemaphore;dispatch_once_t mje_onceTokenSemaphore; 修改后的代码保证了锁的唯一性。 建议使用MJExtension库时，如果需要进行解析配置，优先使用复写相关配置+方法来实现，例如： 123456789101112131415// 不建议的使用方式+ (void)initialize &#123; [self mj_setupObjectClassInArray:^NSDictionary *&#123; return @&#123; @\"nicknames\" : MJStatus.class &#125;; &#125;];&#125;// 建议的使用方式+ (NSDictionary *)mj_objectClassInArray &#123; return @&#123; @\"nicknames\" : @\"MJStatus\" &#125;;&#125; 并且，在配置类型时，尽量使用NSString而不要使用Class，避免类过早的被加载。","categories":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://huishao.cc/categories/疑难杂症/"}],"tags":[],"keywords":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://huishao.cc/categories/疑难杂症/"}]},{"title":"iOS初级教程之三:Crash分析实践","slug":"412[iOS初级教程之三]Crash分析实践","date":"2021-03-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.388Z","comments":true,"path":"2021/03/23/412[iOS初级教程之三]Crash分析实践/","link":"","permalink":"http://huishao.cc/2021/03/23/412[iOS初级教程之三]Crash分析实践/","excerpt":"","text":"[iOS初级教程之三]Crash分析实践一、引言Crash分析与治理是移动端开发人员的必备技能，Crash相关数据也是衡量应用程序质量的重要指标。本篇文章，我们将讨论在iOS开发中基础的Crash治理实践经验，帮助初学者快速的掌握Crash治理技能，提升工作能力。文章将从如下几个方面进行介绍： Crash的统计和分析 如何通过友盟APM平台做监控和报警 SDK收集工具的集成 各种类型的Crash分析实践 Crash治理的重要一步是对Crash进行统计和分析，有了Crash的统计数据，我们才能具体的对某些Crash问题进行分析和处理，友盟U-APM平台提供了非常好的辅助工具，开发者的接入非常简单容易，其可以帮助开发者快速发现问题，统计问题，分析问题最终解决问题。 二、U-APM SDK的集成客户端应用集成U-APM SDK主要用来进行崩溃检测，卡顿检测以及场景记录等功能。如果使用CocoaPods工具其接入非常简单，在Podfile文件中添加如下依赖即可： 1234pod 'UMCommon'pod 'UMDevice'pod 'UMAPM'pod 'UMCCommonLog' 其中UMCommon是友盟SDK基础的支持库，提供SDK初始化等功能，UMDevice库与设备信息功能相关，UMAPM用来做性能与崩溃统计，UMCCommonLog是一个调试库，在开发时我们可以将其引用，用来查看上报情况。 如果项目没有使用CocoaPods，也可以采用手动引入的方式来集成SDK。在如下地址可以根据需求下载到指定的SDK资源： https://developer.umeng.com/sdk/android?spm=a213m0.21038855.9168240680.3.6a311904uispVD 手动集成SDK还需要做一些简单的工程配置： 1.需要依赖如下系统库： 1234CoreTelephony.frameworklibz.tbdlibsqlite.tbdlibc++.tbd 2.在工程的Targets-&gt;BuildSettings 中 ， Other Linker Flags增加-ObjC参数。 完成了上面的配置过程，需要编写代码来完成U-APM SDK的接入工作，示例代码如下： 1234567891011121314151617181920212223242526#import \"AppDelegate.h\"#import &lt;UMCommon/UMCommon.h&gt;#import &lt;UMAPM/UMCrashConfigure.h&gt;#import &lt;UMCommonLog/UMCommonLogHeaders.h&gt;@interface AppDelegate ()@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 1. 初始化SDK [UMConfigure initWithAppkey:@\"602505af668f9e17b8aef059\" channel:nil]; // 2. 进行异常捕获 [UMCrashConfigure setCrashCBBlock:^NSString * _Nullable&#123; return @\"发生了我们测试的Crash\"; &#125;]; // 3. 初始化Log [UMCommonLogManager setUpUMCommonLogManager]; // 4. 开启Log [UMConfigure setLogEnabled:YES]; return YES;&#125;@end 由于需要选择一个较早的实际来进行SDK的初始化，因此我们通常会将初始化的相关代码放入didFinishLaunching方法中，也可以根据具体需求选择初始化的时机，接入SDK基本分为了4个步骤，上面示例代码中有详细的注释，在第1步初始化SDK中，传入的AppKey的值是在友盟后台创建应用后得到的。第2步调用的setCrashCBBlock用来设置上报Crash时的额外信息，通常在这个回调中我们可以将当前登录的用户信息等进行上报。 我们可以手动写一些常见的会产生Crash的代码，在真机上运行上面示例代码后，可以在友盟的APM后台看到记录的异常信息，在上报的日志的自定义字段中，可以看到我们设置的额外上报数据，如下图所示： 此时，你会发现我们收集到的很多堆栈信息都是未符号化的，即都是内存地址，并没与类与方法的信息，这是因为我们还需要配置下应用的符号表，使用Xcode在构建工程时，默认只会在生产环境生成符号表，我们也可以将Build Settings-&gt;Debug Information Format选项设置为DWARF with DSYM File来使其在Debug环境下也生成符号表，如下： 编译后生成的符号表会与App包放在同一文件下，我们需要在友盟U-APM后台的设置页面将此符号表文件进行上传，之后就可以正常的对堆栈信息进行解析。如下图： 三、分析用户路径与监控告警有时候我们记录到了线上的Crash，并且定位到了具体的页面，但是依然无法复现出相同的问题。很多情况下这是因为我们的复现路径与用户的操作路径并不一样，在友盟APM后台，对于收集到了异常问题，除了有详细的堆栈日志和自定义的上报数据外，还可以获取到用户的页面操作路径和设备信息，页面操作路径是非常重要的分析数据，根据这个路径我们可以大致还原出用户打开应用程序后的操作路径，方便我们对问题进行分析复现。如下图所示： 在设备信息页面可以对设备与操作系统相关信息进行查看，如下图： U-APM后台还提供了非常强大的监控与告警功能，我们可以设置一定的阈值作为报警条件。当某一刻异常问题触发了我们的报警规则，我们可以及时的收到反馈并及时的做出响应。在U-APM后台的检测报警功能页面，我们可以创建一种告警计划，如下图所示： 在创建告警计划时，可以设置一些触发条件，例如在最近一小时内触发的错误数超过阈值，则进行告警。对于告警的方式，有钉钉机器人提醒，邮件，企业微信等，可以参照文档根据需要进行配置。 四、常见Crash分析实践1.未实现的选择器未实现的选择器应该是开发中最常见的Crash原因之一，初学者在编写代码时，经常会在控制台看到如下类型的错误提示： 1unrecognized selector sent to instance 这通常是因为调用了没有实现的方法或者执行方法的对象类型不对，我们将这类问题统称为未实现的选择器问题。产生这类的问题的场景通常有如下几种： ①.声明方法未实现例如在.h文件中声明了一个方法，并在其他地方对此方法进行了调用，但是此方法并没有在.m文件中实现，此时编译工程是不会有问题的，在运行时如果调用到了此未实现的方法会产生崩溃。 ②.协议方法未实现这种场景与声明方法未实现类似，有时候，协议中定义的方法并不一定都是必须实现的，为了避免出现此类问题，我们可以在调用协议方法之前先进行安全判断，如下： 123if ([self.delegate respondsToSelector:@selector(protocolMehtod)]) &#123; [self.delegate protocolMehtod];&#125; ③.copy修饰了可变属性在定义属性时，如果我们将一个可变的属性使用了copy进行修饰，则在赋值时会隐式的将其拷贝成不可变的类型，这时如果我们调用了可变属性的方法就会产生异常，例如： 1@property (nonatomic, copy) NSMutableArray *mutableArray; 这种场景具有很好的隐秘性，无论是赋值还是方法的调用，Xcode的自动检查功能都不能提前将问题指出，也不会有警告产生。 ④.动态调用了未知方法Objective-C本身是一种动态的语言，有很多种方式可以动态的进行方法的调用，这类调用是不会做编译时检查的，方法名写错或对象类型不对都会产生异常，因此最好在动态方法调用前，都进行安全判断，例如： 123if ([self respondsToSelector:@selector(unknow)]) &#123; [self performSelector:@selector(unknow)];&#125; ⑤.低版本使用了高版本的API当低版本系统使用了高版本才有的接口时，也会产生未实现的选择器异常，对于这种场景，Xcode会有警告提示，我们可以在调用方法前，先进行版本的判断，示例如下： 123456// iOS 13 之后APIif (@available(iOS 13.0, *)) &#123; [self canPerformUnwindSegueAction:@selector(test) fromViewController:self sender:nil];&#125; else &#123; // Fallback on earlier versions&#125; 2.KVC相关异常 KVC(Key Value Coding)又称键值编码，其指在iOS开发中，可以允许开发者通过key名直接访问对象的属性或者给对象的属性赋值，而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。很多高级的iOS开发技巧都是基于KVC实现的。 KVC的几个核心方法列举如下： 1234567891011121314//核心方法：- (nullable id)valueForKey:(NSString *)key;- (void)setValue:(nullable id)value forKey:(NSString *)key; - (nullable id)valueForKeyPath:(NSString *)keyPath; - (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;//高级方法：+ (BOOL)accessInstanceVariablesDirectly;- (nullable id)valueForUndefinedKey:(NSString *)key;- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;- (void)setNilValueForKey:(NSString *)key;- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues; KVC相关的Crash场景主要有两种： ①. 所使用了值为nil的key当我们使用KVC的方式向对象的属性进行赋值时，要保证Key值不为nil，否则会产生异常，在使用时要做下Key值的判空，如下： 1234NSString *key = nil;if (key) &#123; [self setValue:@\"value\" forKey:key];&#125; ②. 使用了对象中不存在的key值在调用setValue：forKey：方法时，即是传入的Key值不为nil，也有可能会产生异常，默认情况下，如果要操作的属性对象中并不存在，则也会产生Crash，我们可以实现KVC中的如下两个方法来做兼容： 123456789// 为不存在的属性进行KVC赋值时会调用这个方法- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123; NSLog(@\"setForUndefinedKey:%@, %@\", key, value);&#125;// 获取不存在的属性的值的时候会调用这个方法- (id)valueForUndefinedKey:(NSString *)key &#123; return nil;&#125; 3.野指针相关异常由于野指针问题产生的相关异常通常是比较难处理和定位的。野指针通常指所指向的对象已经被释放的指针，其所指向的内存地址存储的数据也被称为僵尸对象。我们可以通过开启Xcode的僵尸对象功能来在开发阶段提前进行预防。在Xcode的scheme编辑中，将Zombie Objects进行勾选即可。如下： 野指针相关问题的异常场景主要有如下几种： ①. 使用了未初始化的对象②. ARC下，使用了assign或unsafe_unretained修饰对象如下： 1@property (nonatomic, assign) UIView *subView; 这种场景下，对象释放后，ARC不会自动的帮我们做指针置空操作。 ③.runtime关联对象使用了不合适的修饰，如OBJC_ASSOCIATION_ASSIGN原因与场景2类似，对于对象属性的修饰要使用正确的修饰符。 4.KVO相关异常 KVO全称Key Value Observing，是Apple提供的一套事件通知机制。其允许一个对象监听另外一个对象特定属性的变化，由于KVO的实现机制的原因，一般继承自NSObject的对象才能使用，并且其只对属性才会发生作用。 KVO和NSNotificationCenter都是iOS中观察者模式的一种实现。区别在于，相对于被观察者和观察者之间的关系，KVO是一对一的，而不一对多的。KVO对被监听对象无侵入性，不需要修改其内部代码即可实现监听，KVO可以监听单个属性的变化，也可以监听集合对象的变化。 在某些场景下如果不恰当的使用KVO，也会产生Crash，常见场景如下： ①.被观察者是局部变量②.观察者是局部变量③.未实现监听方法④.重复移除监听对象要避免上述问题，在使用KVO时要把握两个核心重点： 1. 注意监听对象与被监听对象的生命周期 2. addObserver和removeObserver要成对出现 5.集合对象操作相关Crash这类Crash主要指不当的操作数组或字典所产生的的。 ①.数组越界问题②.向数组中添加nil元素③.遍历数组过程中使用了错误的方式修改了数组④. 字典设置nil值6.多线程操作相关Crash和野指针问题类似，多线程产生的异常往往也是比较难定位和解决的。这类异常通常并不好复现，我们在编写代码时要将尽量将逻辑梳理清楚。常见问题场景如下： ①. group enter 与 group leave在使用GCD多多线程开发时，dispatch\\_group\\_t是很常用的一种进行任务依赖编程的方式，需要注意，在使用dispatch\\_group\\_t时，要确保group enter 与 group leave是成对调用的，否则极易出现死锁问题。 ②.子线程做UI操作在子线程中操作UI不仅会造成页面更新不及时，页面混乱等问题，也极易产生异常从而Crash，因此在做UI操作时，一定要保证是在主线程执行。 ③.多线程对对象进行释放在多个线程中对变量进行赋值操作会造成，会造成变量所引用的旧的对象的多线程释放问题，会出现偶现crash。因此，如果有多线程对外部变量进行赋值的操作，我们可以使用信号量进行加锁，保证变量的赋值是串行的，示例代码如下： 1234567891011121314__block NSObject *obj;dispatch_semaphore_t sem = dispatch_semaphore_create(1);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; while (YES) &#123; dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); obj = [NSObject new]; dispatch_semaphore_signal(sem); &#125;&#125;);while (YES) &#123; dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER); obj = [NSObject new]; dispatch_semaphore_signal(sem);&#125; ④.多线程同时操作数组多线程同时对数组进行操作也是比较危险的行为，例如当一个线程在对数据进行遍历时，另一个线程改变了数组元素的个数，会由于索引错乱而产生意想不到的问题甚至Crash。在多线程中遍历数组时，可以将数组拷贝一份在进行操作。 7.watch dog异常 为了防止一个应用占用过多的系统资源，Apple设计了一个名为“看门狗”( watchdog )的机制。在不同的场景下，“看门狗”会监测应用的性能。如果超出了该场景所规定的运行时间，“看门狗”就会强制终结这个应用的进程。开发者们在 crashlog 里面，会看到诸如 0x8badf00d 这样的错误代码。异常代码：“0x8badf00d ”(看上去非常像 bad food)。 Watch Dog的Crash本身并不是代码错误，其是一种保护机制，当我们收集到的异常有发现这类问题时，就要着重考虑下应用的性能，同时检查是否会有死锁等异常逻辑的产生。 五、建议1. 重视每一个Crash处理 2. 有监控，紧急问题可以及时响应 3. 积累治理经验 4. 代码规范，安全 5. 逻辑设计尽量简单，多线程场景要清晰","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS初级教程之二:DeepLink实践","slug":"411[iOS初级教程之二]DeepLink实践","date":"2021-03-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.388Z","comments":true,"path":"2021/03/19/411[iOS初级教程之二]DeepLink实践/","link":"","permalink":"http://huishao.cc/2021/03/19/411[iOS初级教程之二]DeepLink实践/","excerpt":"","text":"[iOS初级教程之二]DeepLink实践一、唤醒iOS应用程序的几种方式唤醒应用是iOS开发中常见的技术，应用唤醒的方式有多种，概括下来，可以分为如下几类: 直接打开App 通知唤醒 scheme唤醒 Universal Links唤醒 直接打开App是最直接的唤醒应用程序的方式，以iPhone为例，可以从主屏幕、搜索推荐、应用库等场景中进行打开。 当用户收到通知消息时，点击通知栏的通知消息也可以唤醒应用程序，通知分为本地通知和远程通知两种，从唤醒应用程序的作用上来说，这两种通知的逻辑是一致的。下面代码示例了发送本地通知： 1234567891011121314151617- (void)addLocalNotification &#123; [[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; &#125;]; UNMutableNotificationContent *notificaiton = [[UNMutableNotificationContent alloc] init]; notificaiton.title = @\"本地通知\"; notificaiton.body = @\"通知内容\"; notificaiton.badge = @(1); UNTimeIntervalNotificationTrigger *trriger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:@\"requsetID\" content:notificaiton trigger:trriger]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;];&#125; 通过Scheme来唤醒应用程序也非常简单，在上一篇教程中，我们有介绍分享功能的集成，就有配置和使用过Scheme。要通过Scheme唤醒应用程序，首先需要添加URL Types，添加方法如下图所示： 上面我们定义了一个URL Scheme为deeplinkdemo，我们可以直接在浏览器中使用deeplinkdemo://开头的链接来唤醒此应用程序。 Universal Link是一种更加强大的唤醒应用程序的方式，相关介绍官网如下： https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html Universal Link是iOS 9之后新增的应用跳转功能，其可以无缝的连接网站与App，不需通过浏览器做中转，即可以实现应用间的无缝切换。 了解了上述的几种应用程序的唤醒方式，我们回到本教程的主题：DeepLink。DeepLink又称为深度超链，其是指应用以上技术进行应用程序的无缝调起、场景还原、营销唤醒等业务逻辑。下面，我们就介绍如何以友盟工具平台为基础来为应用程序接入智能超链功能。 二、U-Link SDK集成使用CocoaPods的方式来集成U-Link SDK非常方便，只需要在Podfile文件夹中添加如下依赖即可： 12pod 'UMCommon'pod 'UMDevice' 如果项目没有使用CocoaPods进行管理，也可以选择手动引入的方式来集成SDK。可以在如下网址下载到最新版的SDK： https://developer.umeng.com/sdk/ios?acm=lb-zebra-609113-9110428.1003.4.8840408&amp;scm=1003.4.lb-zebra-609113-9110428.OTHER_16059174649951_8840408 需要注意，如果采用了手动的方式引入SDK，需要在工程的Targets-&gt;BuildSettings-&gt;Other Linker Flags中添加-Objc参数，并且添加如下系统依赖库： CoreTelephony.frameworklibz.tbdlibsqlite.tbdSystemConfiguration.framework 在工程中集成好了SDK后，我们还需要做一些简单的配置，首先需要在友盟后台创建应用程序，并在应用设置页面中获取到APP KEY参数，如下图所示： 这个APP KEY参数在进行SDK的初始化时会使用到。在友盟应用后台的Deeplink配置页面中，我们需要将应用的一些Scheme信息进行配置，如下图： 之后，我们便可以通过创建营销活动来使用智能超链的功能了，首先在友盟后台进行营销活动的创建，页面如下图： 可以看到，在创建营销活动时，可以配置活动名称、活动描述、应用内跳转的路径以及相关参数，当用户通过此营销活动的链接唤醒应用程序时，我们可以根据这些参数来让应用程序定位到指令的页面，从而实现业务的无缝衔接。创建好了营销活动后，在此活动的详情页面即可获取到LinkID，在网页中我们使用此LinkID来唤醒应用。 三、Deeplink调试与参数接收创建好了营销活动也集成完成了SDK，下面我们可以尝试通过一个简单的HTML DEMO来调试智能超链。HTML示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;script src=\"https://g.alicdn.com/jssdk/u-link/index.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;测试DeepLink跳转&lt;/h1&gt; &lt;button id=\"btn1\"&gt;唤起 App&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; ULink.start(&#123; id: 'usr1ffnv829fu02h', /* 平台为每个应用分配的方案link ID，必填 */ data: &#123; custom:\"customn1\", custom2:\"custom2\" &#125; /* 自定义参数，选填 */ &#125;).ready(function(ctx) &#123; /* 初始化完成的回调函数 */ document.getElementById('btn1').onclick = function(e)&#123; ctx.wakeup(); /* 用户点击某个按钮时启动app */ &#125;;&#125;);&lt;/script&gt;&lt;style type=\"text/css\"&gt; div &#123; text-align: center; &#125; button &#123; font-size: 60px; &#125; h1 &#123; font-size: 60px; &#125;&lt;/style&gt;&lt;/html&gt; 如上代码所示，u-link是友盟智能超链在JavaScript端的SDK，调用ULink的start方法时，配置的对象id就是我们创建的营销活动的id，通过这种方式唤醒应用程序会自动将后台配置的参数传递过去，同时我们也可以在data中定义更多动态参数进行传递。 对于Xcode工程，在应用启动是首先需要对U-Link的SDK进行初始化操作，如下： 1234- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [UMConfigure initWithAppkey:@\"602505af668f9e17b8aef059\" channel:nil]; return YES;&#125; 之后实现如下几个AppDelegate的回调来处理超链： 12345678910111213141516171819202122232425262728293031323334#import \"AppDelegate.h\"#import &lt;UMCommon/UMConfigure.h&gt;#import &lt;UMCommon/MobClickLink.h&gt;@interface AppDelegate ()&lt;MobClickLinkDelegate&gt;@end@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [UMConfigure initWithAppkey:@\"602505af668f9e17b8aef059\" channel:nil]; return YES;&#125;- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url &#123; return [MobClickLink handleLinkURL:url delegate:self];&#125;- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options &#123; return [MobClickLink handleLinkURL:url delegate:self];&#125;- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123; return [MobClickLink handleUniversalLink:userActivity delegate:self];&#125;// 解析后的回调函数，这里可以拿到所有的参数与跳转路径信息- (void)getLinkPath:(NSString *)path params:(NSDictionary *)params &#123; NSLog(@\"getLinkPath:%@, %@\", path, params);&#125;@end 需要注意，如果是新版Xcode创建的应用程序，需要在SceneDelegate类中实现上面的方法。","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS初级教程之一:社会化分享实践","slug":"410[iOS初级教程之一]社会化分享实践","date":"2021-03-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.388Z","comments":true,"path":"2021/03/18/410[iOS初级教程之一]社会化分享实践/","link":"","permalink":"http://huishao.cc/2021/03/18/410[iOS初级教程之一]社会化分享实践/","excerpt":"","text":"[iOS初级教程之一]社会化分享实践一、简介社会化分享，是指在中，基于其分享功能，将信息网络化输入输出，加速组织传播。博客、微博客、WIKI、社交网络、内容社区等，是可以常见到的社会化媒体形式。在国内近两年，社会化分享的传播量又以QQ空间、新浪微博、腾讯微博势头最猛。 为应用程序添加社会化分享的能力本身并不复杂，繁琐的地方在于不同的分享平台需要接入不同的SDK，例如要支持微信、QQ、微博这3种平台的分享，就要分别对微信SDK、QQSDK和微博SDK进行接入，这些工作非常麻烦。因此，如果我们需要快速的使应用程序具备社会化分享能力，最快捷的方式是采用第三方整合的SDK进行接入，友盟社会化分享平台就提供了非常好的这种服务。 U-Share社会化分享平台官网如下： https://www.umeng.com/social 简单来概括，U-Share平台提供了如下功能： 1.一键分享 2.一键唤醒与拉新 3.营销裂变效果追踪 4.自由定制分享页面 对U-Share工具的整体接入也非常容易，流程如下： 本教程中，我们将结合友盟社会化分享服务平台来完整的介绍如何快速的为应用程序添加分享功能。你将收获到： 1. 社会化分享技术的实践经验 2.借助友盟平台快速实现应用的社会化分享功能 3.能够自定义分享组件 4.各种社会化平台进行分享的账号申请流程 5.等等… 二、创建友盟应用要借助友盟平台实现社会化分享功能，首先需要在友盟后台创建一个应用程序。打开前面提到的友盟官网，如果已有友盟账号，可以直接进行登录，没有的话注册一个友盟账号即可。登录成功后，点击页面上的进入工作台按钮即可来后友盟管理后台，其中可以创建和管理应用。 如果是第一次使用友盟后台，第一步需要先创建一个应用，友盟应用的创建非常简单，只需要根据提示来一步步进行选择即可，如下图所示： 我们需要使用哪些功能只需要进行勾选即可。创建好了应用程序后，我们可以在U-Share后台对此应用进行查看和管理，在应用设置页面可以查看AppKey数据，这个数据非常重要，我们在集成友盟SDK时需要使用到此AppKey。如下图所示： 也可以看到，在U-Share后台也有很多统计数据，详细的记录了App的分享次数、分享人数、回流率、新用户数等重要数据，可以帮助我们持续的对业务进行优化。 三、友盟SDK的获取和接入集成友盟分享SDK的方式有两种，使用CocoaPods集成和手动进行集成。 1. 使用CocoaPods进行集成使用CocoaPods集成非常方便，整体来说有3步： 创建PodFile文件 添加依赖 执行pod install安装依赖库 首先在工程目录下执行pod init指令来创建一个podfile文件，在其中编写如下代码： 123456789101112131415# Uncomment the next line to define a global platform for your project# platform :ios, '9.0'target 'UMShareTest' do # Comment the next line if you don't want to use dynamic frameworks use_frameworks! pod 'UMCommon' pod 'UMDevice' pod 'UMShare/UI' pod 'UMShare/Social/WeChat' pod 'UMShare/Social/QQ' pod 'UMShare/Social/Sina' # Pods for UMShareTestend 在添加依赖时，UMCommon、UMDevice是必选依赖，UMShare/UI是一个UI库，如果需要使用到友盟提供的分享UI组件，可以加入这个库。WeChat、QQ和Sina是第三方分享平台的SDK，我们需要哪些就引入哪些即可。友盟所支持的第三方平台可以在如下文档中进行查看： https://developer.umeng.com/docs/128606/detail/193653 2. 手动集成手动集成是指我们直接下载好所需要的SDK，将其加入工程并进行相关的配置。相比CocoaPods的集成方式，手动集成更加麻烦一些。首先，我们需要下载所需的SDK，在如下网址中可以进行下载： https://developer.umeng.com/sdk/ios 同样，在下载SDK时，我们可以进行设置，只下载所需要的分享平台的SDK，如下图所示： 下载完成后，只需要将解压好的SDK文件夹拖入到工程中即可。之后在Xcode工程的Build Settings中的other linker flags添加-Objc参数。最后，需要将要依赖的系统库进行添加，在Link Binary With Libraries里进行配置，如下图所示： 需要注意，这里配置的系统库可能会由于所支持的分享平台不同而略有不同，可以在下面文档中找到对应分享平台需要对应配置的系统库： https://developer.umeng.com/docs/128606/detail/193653 四、三方平台物料准备通过前面的准备，友盟应用和SDK部分的配置基本已经完成，但在真正接入分享功能前，还有至关重要的一步需要做。我们需要根据需求，来申请各个开放平台的开发者账号。例如我们需要支持微信，QQ和微博的分享操作，就需要申请微信开放平台，腾讯开放平台和微博开放平台的账号，并进行应用的创建。 1.微信开放平台微信开放平台的官网如下： https://open.weixin.qq.com/ 在开放平台注册了开发者账号后，即可进行应用创建，如下图所示： 将所需要提供的信息填写后，即可创建应用程序。需要注意，在配置应用程序时，其设置的bundle ID的值要与工程中的配置一致。提交了创建应用的申请后，需要等待微信开放平台的审核，审核完成后可以得到应用的AppID和AppSecret，这两个参数在我们配置分享时会使用到。 2.腾讯开放平台和微信开放平台类似，要支持进行QQ相关分享操作需要申请一个腾讯开放平台的账号，地址如下： https://open.tencent.com/ 在申请应用时同样需要填写一些基本信息，应用申请后，可以得到AppID和AppKey相关参数用来进行分享配置，如下图： 其他各种开发平台的应用创建和配置逻辑基本大同小异，在友盟的如下文档中找到具体的申请方法： https://developer.umeng.com/docs/128606/detail/193651 五、接入分享功能现在，万事俱备，只欠东风。我们已经做完了实现分享功能的所有准备工作。可以进行工程的配置和代码的编写了。 1. 初始化友盟SDK与回调设置初始化友盟SDK是使用分享功能的第一步，这里我们需要初始化友盟应用并为各个分享平台进行配置，示例代码如下： 123456789101112131415161718192021222324- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [self configShare]; [self configPlatform]; return YES;&#125;- (void)configShare &#123; [UMConfigure initWithAppkey:@\"602505af668f9e17b8aef059\" channel:nil]; [UMSocialGlobal shareInstance].universalLinkDic = @&#123; @(UMSocialPlatformType_WechatSession):@\"https://umplus-sdk-download.oss-cn-shanghai.aliyuncs.com/\", @(UMSocialPlatformType_QQ):@\"https://umplus-sdk-download.oss-cn-shanghai.aliyuncs.com/qq_conn/101830139\" &#125;;&#125;- (void)configPlatform &#123; [[UMSocialManager defaultManager] setPlaform:UMSocialPlatformType_WechatSession appKey:@\"wxdc1e388c3822c80b\" appSecret:@\"3baf1193c85774b3fd9d18447d76cab0\" redirectURL:@\"http://mobile.umeng.com/social\"]; [[UMSocialManager defaultManager] setLauchFromPlatform:(UMSocialPlatformType_WechatSession) completion:^(id userInfoResponse, NSError *error) &#123; NSLog(@\"setLauchFromPlatform:userInfoResponse:%@\",userInfoResponse); &#125;]; [[UMSocialManager defaultManager] setPlaform:UMSocialPlatformType_QQ appKey:@\"1105821097\" appSecret:nil redirectURL:@\"http://mobile.umeng.com/social\"]; [[UMSocialManager defaultManager] setPlaform:UMSocialPlatformType_Sina appKey:@\"3921700954\" appSecret:@\"04b48b094faeb16683c32669824ebdad\" redirectURL:@\"https://sns.whalecloud.com/sina2/callback\"];&#125; 上面代码都写在AppDelegate类中，实际应用中，我们也可以根据使用时机来进行初始化。上面代码中，configShare方法用来进行友盟SDK本身的初始化和配置，configPlatform方法用来对第三方分享平台进行配置。 还需要实现几个AppDelegate的回调来处理通过分享链接打开App后的后续逻辑，示例代码如下： 12345678910111213141516171819- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url &#123; BOOL res = [[UMSocialManager defaultManager] handleOpenURL:url]; return res;&#125;- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options &#123; BOOL res = [[UMSocialManager defaultManager] handleOpenURL:url options:options]; return res;&#125;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation &#123; BOOL res = [[UMSocialManager defaultManager] handleOpenURL:url sourceApplication:sourceApplication annotation:annotation]; return res;&#125;- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123; BOOL res = [[UMSocialManager defaultManager] handleUniversalLink:userActivity options:nil]; return res;&#125; 2. 白名单配置目前，代码配置部分基本完成，下面我们需要在工程的info.plist文件中对要分享的三方平台进行白名单配置。在info.plist文件中添加LSApplicationQueriesSchemes键，其值配置为列表，具体各个分享平台的白名单列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;&lt;array&gt; &lt;!-- 微信 URL Scheme 白名单--&gt; &lt;string&gt;wechat&lt;/string&gt; &lt;string&gt;weixin&lt;/string&gt; &lt;string&gt;weixinULAPI&lt;/string&gt; &lt;!-- QQ、Qzone URL Scheme 白名单--&gt; &lt;string&gt;mqqopensdklaunchminiapp&lt;/string&gt; &lt;string&gt;mqqopensdkminiapp&lt;/string&gt; &lt;string&gt;mqqapi&lt;/string&gt; &lt;string&gt;mqq&lt;/string&gt; &lt;string&gt;mqqOpensdkSSoLogin&lt;/string&gt; &lt;string&gt;mqqconnect&lt;/string&gt; &lt;string&gt;mqqopensdkdataline&lt;/string&gt; &lt;string&gt;mqqopensdkgrouptribeshare&lt;/string&gt; &lt;string&gt;mqqopensdkfriend&lt;/string&gt; &lt;string&gt;mqqopensdkapi&lt;/string&gt; &lt;string&gt;mqqopensdkapiV2&lt;/string&gt; &lt;string&gt;mqqopensdkapiV3&lt;/string&gt; &lt;string&gt;mqqopensdkapiV4&lt;/string&gt; &lt;string&gt;mqzoneopensdk&lt;/string&gt; &lt;string&gt;wtloginmqq&lt;/string&gt; &lt;string&gt;wtloginmqq2&lt;/string&gt; &lt;string&gt;mqqwpa&lt;/string&gt; &lt;string&gt;mqzone&lt;/string&gt; &lt;string&gt;mqzonev2&lt;/string&gt; &lt;string&gt;mqzoneshare&lt;/string&gt; &lt;string&gt;wtloginqzone&lt;/string&gt; &lt;string&gt;mqzonewx&lt;/string&gt; &lt;string&gt;mqzoneopensdkapiV2&lt;/string&gt; &lt;string&gt;mqzoneopensdkapi19&lt;/string&gt; &lt;string&gt;mqzoneopensdkapi&lt;/string&gt; &lt;string&gt;mqqbrowser&lt;/string&gt; &lt;string&gt;mttbrowser&lt;/string&gt; &lt;string&gt;tim&lt;/string&gt; &lt;string&gt;timapi&lt;/string&gt; &lt;string&gt;timopensdkfriend&lt;/string&gt; &lt;string&gt;timwpa&lt;/string&gt; &lt;string&gt;timgamebindinggroup&lt;/string&gt; &lt;string&gt;timapiwallet&lt;/string&gt; &lt;string&gt;timOpensdkSSoLogin&lt;/string&gt; &lt;string&gt;wtlogintim&lt;/string&gt; &lt;string&gt;timopensdkgrouptribeshare&lt;/string&gt; &lt;string&gt;timopensdkapiV4&lt;/string&gt; &lt;string&gt;timgamebindinggroup&lt;/string&gt; &lt;string&gt;timopensdkdataline&lt;/string&gt; &lt;string&gt;wtlogintimV1&lt;/string&gt; &lt;string&gt;timapiV1&lt;/string&gt; &lt;!-- 新浪微博 URL Scheme 白名单--&gt; &lt;string&gt;sinaweibohd&lt;/string&gt; &lt;string&gt;sinaweibo&lt;/string&gt; &lt;string&gt;sinaweibosso&lt;/string&gt; &lt;string&gt;weibosdk&lt;/string&gt; &lt;string&gt;weibosdk2.5&lt;/string&gt; &lt;!-- 支付宝 URL Scheme 白名单--&gt; &lt;string&gt;alipay&lt;/string&gt; &lt;string&gt;alipayshare&lt;/string&gt; &lt;!-- 钉钉 URL Scheme 白名单--&gt; &lt;string&gt;dingtalk&lt;/string&gt; &lt;string&gt;dingtalk-open&lt;/string&gt; &lt;!-- 企业微信--&gt; &lt;string&gt;wxwork&lt;/string&gt; &lt;string&gt;wxworkdebug&lt;/string&gt; &lt;string&gt;wxworkrdm&lt;/string&gt; &lt;string&gt;wxworkrelease&lt;/string&gt; &lt;!--抖音--&gt; &lt;string&gt;douyinopensdk&lt;/string&gt; &lt;string&gt;douyinsharesdk&lt;/string&gt; &lt;string&gt;snssdk1128&lt;/string&gt; &lt;!--Linkedin URL Scheme 白名单--&gt; &lt;string&gt;linkedin&lt;/string&gt; &lt;string&gt;linkedin-sdk2&lt;/string&gt; &lt;string&gt;linkedin-sdk&lt;/string&gt; &lt;!-- 易信 URL Scheme 白名单--&gt; &lt;string&gt;yixin&lt;/string&gt; &lt;string&gt;yixinopenapi&lt;/string&gt; &lt;!-- instagram URL Scheme 白名单--&gt; &lt;string&gt;instagram&lt;/string&gt; &lt;!-- whatsapp URL Scheme 白名单--&gt; &lt;string&gt;whatsapp&lt;/string&gt; &lt;!-- line URL Scheme 白名单--&gt; &lt;string&gt;line&lt;/string&gt; &lt;!-- Facebook URL Scheme 白名单--&gt; &lt;string&gt;fbapi&lt;/string&gt; &lt;string&gt;fb-messenger-api&lt;/string&gt; &lt;string&gt;fb-messenger-share-api&lt;/string&gt; &lt;string&gt;fbauth2&lt;/string&gt; &lt;string&gt;fbshareextension&lt;/string&gt; &lt;!-- Kakao URL Scheme 白名单--&gt; &lt;!-- 注：以下第一个参数需替换为自己的kakao appkey--&gt; &lt;!-- 格式为 kakao + \"kakao appkey\"--&gt; &lt;string&gt;kakaofa63a0b2356e923f3edd6512d531f546&lt;/string&gt; &lt;string&gt;kakaokompassauth&lt;/string&gt; &lt;string&gt;storykompassauth&lt;/string&gt; &lt;string&gt;kakaolink&lt;/string&gt; &lt;string&gt;kakaotalk-4.5.0&lt;/string&gt; &lt;string&gt;kakaostory-2.9.0&lt;/string&gt; &lt;!-- pinterest URL Scheme 白名单--&gt; &lt;string&gt;pinterestsdk.v1&lt;/string&gt; &lt;!-- Tumblr URL Scheme 白名单--&gt; &lt;string&gt;tumblr&lt;/string&gt; &lt;!-- 印象笔记 --&gt; &lt;string&gt;evernote&lt;/string&gt; &lt;string&gt;en&lt;/string&gt; &lt;string&gt;enx&lt;/string&gt; &lt;string&gt;evernotecid&lt;/string&gt; &lt;string&gt;evernotemsg&lt;/string&gt; &lt;!-- 有道云笔记--&gt; &lt;string&gt;youdaonote&lt;/string&gt; &lt;string&gt;ynotedictfav&lt;/string&gt; &lt;string&gt;com.youdao.note.todayViewNote&lt;/string&gt; &lt;string&gt;ynotesharesdk&lt;/string&gt; &lt;!-- Google+--&gt; &lt;string&gt;gplus&lt;/string&gt; &lt;!-- Pocket--&gt; &lt;string&gt;pocket&lt;/string&gt; &lt;string&gt;readitlater&lt;/string&gt; &lt;string&gt;pocket-oauth-v1&lt;/string&gt; &lt;string&gt;fb131450656879143&lt;/string&gt; &lt;string&gt;en-readitlater-5776&lt;/string&gt; &lt;string&gt;com.ideashower.ReadItLaterPro3&lt;/string&gt; &lt;string&gt;com.ideashower.ReadItLaterPro&lt;/string&gt; &lt;string&gt;com.ideashower.ReadItLaterProAlpha&lt;/string&gt; &lt;string&gt;com.ideashower.ReadItLaterProEnterprise&lt;/string&gt; &lt;!-- VKontakte--&gt; &lt;string&gt;vk&lt;/string&gt; &lt;string&gt;vk-share&lt;/string&gt; &lt;string&gt;vkauthorize&lt;/string&gt; &lt;!-- Twitter--&gt; &lt;string&gt;twitter&lt;/string&gt; &lt;string&gt;twitterauth&lt;/string&gt;&lt;/array&gt; 需要注意，默认在Xocde中打开的info.plist文件是以plist浏览模式打开的，如下： 我们可以以文本的方式打开，将所需要的代码复制进去即可，方法如下图所示： 3.配置URL Scheme配置白名单的目的是为了让我们的应用可以打开第三方App进行分享操作，而配置URL Scheme的作用是当分享操作完成后，第三方App可以再次唤醒我们的App，回到App内做后续逻辑。 在工程的Info项目中进行URL Types的配置，如下图所示： 如上图中，我们只配置了微信和QQ的URL Scheme，在配置的时候，不同平台有不同的规则，例如微信是： wx + 微信开放平台的应用appKey 具体每个分享平台的配置规则可参考如下文档： https://developer.umeng.com/docs/128606/detail/193653#h3–sso-12 六、进行分享操作前面的工作完成后，进行分享操作就非常容易，以文本分享为例，只需要创建出UMSocialMessageObject对象即可，示例代码如下： 1234567- (void)shareText:(UMSocialPlatformType)type &#123; UMSocialMessageObject *object = [[UMSocialMessageObject alloc] init]; object.text = @\"title\"; [[UMSocialManager defaultManager] shareToPlatform:type messageObject:object currentViewController:self completion:^(id result, NSError *error) &#123; NSLog(@\"%@\",error); &#125;];&#125; 同样，我们也可以分享网页、小程序、图文、视频、音乐等数据，使用不同的传参即可，具体分享类型的传参方式可以在下面的文档中查询： https://developer.umeng.com/docs/128606/detail/193655#h2-u5206u4EABu7F51u9875u94FEu63A51 调用如上的方法进行分享是纯业务逻辑层面的，我们可以根据需求任意的定制化自己的分享UI。如果你接入了UShareUI库，则可以仅仅通过一些简单的配置，更加快速的接入分享功能，示例代码如下： 1234567891011121314151617181920212223@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [UMSocialShareUIConfig shareInstance].sharePageScrollViewConfig.shareScrollViewBackgroundColor = [UIColor greenColor]; &#125;- (IBAction)share:(id)sender &#123; [UMSocialUIManager showShareMenuViewInWindowWithPlatformSelectionBlock:^(UMSocialPlatformType platformType, NSDictionary *userInfo) &#123; [self shareText:platformType]; &#125;];&#125;- (void)shareText:(UMSocialPlatformType)type &#123; UMSocialMessageObject *object = [[UMSocialMessageObject alloc] init]; object.text = @\"title\"; [[UMSocialManager defaultManager] shareToPlatform:type messageObject:object currentViewController:self completion:^(id result, NSError *error) &#123; NSLog(@\"%@\",error); &#125;];&#125;@end 运行上面代码，效果如下图所示： 这个分享面板中的组件都有暴露接口供开发者进行定制化使用，接入非常便捷。","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原理分析之从源码看load与initialize方法","slug":"409iOS原理分析之从源码看load与initialize方法","date":"2021-02-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.387Z","comments":true,"path":"2021/02/18/409iOS原理分析之从源码看load与initialize方法/","link":"","permalink":"http://huishao.cc/2021/02/18/409iOS原理分析之从源码看load与initialize方法/","excerpt":"","text":"iOS原理分析之从源码看load与initialize方法一、引言在iOS开发中，NSObject类是万事万物的基类，其在Objective-C的整理类架构中非常重要，其中有两个很有名的方法：load方法与initialize方法。 12+ (void)load;+ (void)initialize; 说起这两个方法，你的第一反应一定是觉得太老套了，这两个方法的调用时机及作用几乎成为了iOS面试的必考题。其本身调用时机也非常简单： 1. load方法在pre-main阶段被调用，每个类都会调用且只会调用一次。 2. initialize方法在类或子类第一次进行方法调用前会调用。 上面的两点说明本身是正确的，但是除此之外，还有许多问题值得我们深究，例如： 1. 子类与父类的load方法的调用顺序是怎样的？ 2. 类与分类的load方法调用顺序是怎样的？ 3. 子类未实现load方法，会调用父类的么？ 4. 当有多个分类都实现了load方法时，会怎么样？ 5. 每个类的load方法的调用顺序是怎样的？ 6. 父类与子类的initialize的方法调用顺序是怎样的？ 7. 子类实现initialize方法后，还会调用父类的initialize方法么？ 8. 多个分类都实现了initialize方法后，会怎么样？ 9. … 如上所提到的问题，你现在都能给出明确的答案么？其实，load与initialize方法本身还有许多非常有意思的特点，本篇博客，我们将结合Objective-C源码，对这两个方法的实现原理做深入的分析，相信，如果你对load与initialize还不够了解，不能完全明白上面所提出的问题，那么本篇博客将会使其收获满满。无论在以后的面试中，还是工作中使用到load和initialize方法时，都可能帮助你从源码上理解其执行原理。 二、实践出真知 - 先看load方法在开始分析之前，我们首先可以先创建一个测试工程，对load方法的执行时机先做一个简单的测试。首先，我们创建一个Xcode的命令行程序工程，在其中创建一些类、子类和分类，方便我们测试，目录结构如下图所示： 其中，MyObjectOne和MyObjectTwo都是继承自NSObject的类，MySubObjectOne是MyObjectOne的子类，MySubObjectTwo是MyObjectTwo的子类，同时我们还创建了3个分类，在类中实现load方法，并做打印处理，如下： 123+ (void)load &#123; NSLog(@\"load:%@\", [self className]);&#125; 同样，类似的也在分类中做实现： 123+ (void)load &#123; NSLog(@\"load-category:%@\", [self className]);&#125; 最后我们在main函数中添加一个Log： 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@\"Main\"); &#125; return 0;&#125; 运行工程，打印结果如下： 123456782021-02-18 14:33:46.773294+0800 KCObjc[21400:23090040] load:MyObjectOne2021-02-18 14:33:46.773867+0800 KCObjc[21400:23090040] load:MySubObjectOne2021-02-18 14:33:46.773959+0800 KCObjc[21400:23090040] load:MyObjectTwo2021-02-18 14:33:46.774008+0800 KCObjc[21400:23090040] load:MySubObjectTwo2021-02-18 14:33:46.774052+0800 KCObjc[21400:23090040] load-category:MyObjectTwo2021-02-18 14:33:46.774090+0800 KCObjc[21400:23090040] load-category:MyObjectOne2021-02-18 14:33:46.774127+0800 KCObjc[21400:23090040] load-category:MyObjectOne2021-02-18 14:33:46.774231+0800 KCObjc[21400:23090040] Main 从打印结果可以看出，load方法在main方法开始之前被调用，执行顺序上来说，先调用类的load方法，再调用分类的load方法，从父子类的关系上看来，先调用父类的load方法，再调用子类的load方法。 下面，我们就从源码上来分析下，系统如此调用load方法，是源自于什么样的奥妙。 三、从源码分析load方法的调用要深入的研究load方法，我们首先需要从Objective-C的初始化函数说起： 12345678910111213141516171819202122void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); runtime_init(); exception_init(); cache_init(); _imp_implementationWithBlock_init(); // 其他的我们都不需要关注，只需要关注这行代码 _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);#if __OBJC2__ didCallDyldNotifyRegister = true;#endif&#125; _objc_init函数定义在objc-os.mm文件中，这个函数用来做Objective-C程序的初始化，由引导程序进行调用，其调用实际会非常的早，并且是操作系统引导程序复杂调用驱动，对开发者无感。在_objc_init函数中，会进行环境的初始化，runtime的初始化以及缓存的初始化等等操作，其中很重要的一步操作是执行_dyld_objc_notify_register函数，这个函数会调用load_images函数来进行镜像的加载。 load方法的调用，其实就是类加载过程中的一步，首先，我们先来看一个load_images函数的实现： 12345678910111213141516171819202122voidload_images(const char *path __unused, const struct mach_header *mh)&#123; if (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123; didInitialAttachCategories = true; loadAllCategories(); &#125; // Return without taking locks if there are no +load methods here. if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125; 滤掉其中我们不关心的部分，与load方法调用相关的核心如下： 123456789101112voidload_images(const char *path __unused, const struct mach_header *mh)&#123; // 镜像中没有load方法，直接返回 if (!hasLoadMethods((const headerType *)mh)) return; &#123; // 准备load方法 prepare_load_methods((const headerType *)mh); &#125; // 进行load方法的调用 call_load_methods();&#125; 最核心的部分在于load方法的准备与laod方法的调用，我们一步一步看，先来看load方法的准备(我们去掉了无关紧要的部分)： 123456789101112131415161718void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; // 获取所有类 组成列表 classref_t const *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; // 将所有类的load方法进行整理 schedule_class_load(remapClass(classlist[i])); &#125; // 获取所有的分类 组成列表 category_t * const *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; // 将分类的load方法进行整理 add_category_to_loadable_list(cat); &#125;&#125; 看到这里，我们基本就有头绪了，load方法的调用顺序，基本可以确定是由整理过程所决定的，并且我们可以发现，类的load方法整理与分类的load方法整理是互相独立的，因此也可以推断其调用的时机也是独立的。首先我们先来看类的load方法整理函数schedule_class_load(去掉无关代码后)： 12345678910111213static void schedule_class_load(Class cls)&#123; // 类不存在或者已经加载过load，则return if (!cls) return; if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // 保证加载顺序，递归进行父类加载 schedule_class_load(cls-&gt;superclass); // 将当前类的load方法加载进load方法列表中 add_class_to_loadable_list(cls); // 将当前类设置为已经加载过laod cls-&gt;setInfo(RW_LOADED); &#125; 可以看到，schedule_class_load函数中使用了递归的方式演着继承链逐层向上，保证在加载load方法时，先加载父类，再加载子类。add_class_to_loadable_list是核心的load方法整理函数，如下(去掉了无关代码)： 1234567891011121314151617181920void add_class_to_loadable_list(Class cls)&#123; IMP method; // 读取类中的load方法 method = cls-&gt;getLoadMethod(); if (!method) return; // 类中没有实现load方法，直接返回 // 构建存储列表及扩容逻辑 if (loadable_classes_used == loadable_classes_allocated) &#123; loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; // 向列表中添加 loadable_class 结构体，这个结构体中存储了类与对应的laod方法 loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; // 标记列表index的指针移动 loadable_classes_used++;&#125; loadable_clas结构体的定义如下： 1234struct loadable_class &#123; Class cls; // may be nil IMP method;&#125;; getLoadMetho函数的实现主要是从类中获取到load方法的实现，如下： 1234567891011121314151617IMP objc_class::getLoadMethod()&#123; // 获取方法列表 const method_list_t *mlist; mlist = ISA()-&gt;data()-&gt;ro()-&gt;baseMethods(); if (mlist) &#123; // 遍历，找到load方法返回 for (const auto&amp; meth : *mlist) &#123; const char *name = sel_cname(meth.name); if (0 == strcmp(name, \"load\")) &#123; return meth.imp; &#125; &#125; &#125; return nil;&#125; 现在，关于类的load方法的准备逻辑已经非常清晰了，最终会按照先父类后子类的顺序将所有类的load方法添加进名为loadable_classes的列表中，loadable_classes这个名字你要注意一下，后面我们还会遇到它。 我们再来看分类的laod方法准备过程，其与我们上面介绍的类非常相似，add\\_category\\_to\\_loadable\\_list函数简化后如下： 12345678910111213141516171819void add_category_to_loadable_list(Category cat)&#123; IMP method; // 获取当前分类的load方法 method = _category_getLoadMethod(cat); if (!method) return; // 列表创建与扩容逻辑 if (loadable_categories_used == loadable_categories_allocated) &#123; loadable_categories_allocated = loadable_categories_allocated*2 + 16; loadable_categories = (struct loadable_category *) realloc(loadable_categories, loadable_categories_allocated * sizeof(struct loadable_category)); &#125; // 将分类与load方法进行存储 loadable_categories[loadable_categories_used].cat = cat; loadable_categories[loadable_categories_used].method = method; loadable_categories_used++;&#125; 可以看到，最终分类的load方法是存储在了loadable_categories列表中。 准备好了load方法，我们再来分析下load方法的执行过程，call\\_load\\_methods函数的核心实现如下： 123456789101112131415void call_load_methods(void)&#123; bool more_categories; do &#123; // 先对 loadable_classes 进行遍历，loadable_classes_used这个字段可以理解为列表的元素个数 while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 再对类别进行遍历调用 more_categories = call_category_loads(); &#125; while (loadable_classes_used &gt; 0 || more_categories); &#125; call_class_loads函数实现简化后如下： 12345678910111213141516171819202122static void call_class_loads(void)&#123; int i; // loadable_classes列表 struct loadable_class *classes = loadable_classes; // 需要执行load方法个数 int used = loadable_classes_used; // 清理数据 loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // 循环进行执行 循环的循序是从前到后 for (i = 0; i &lt; used; i++) &#123; // 获取类 Class cls = classes[i].cls; // 获取对应load方法 load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; // 执行load方法 (*load_method)(cls, @selector(load)); &#125;&#125; call_category_loads函数的实现要复杂一些，简化后如下： 123456789101112131415161718192021222324252627static bool call_category_loads(void)&#123; int i, shift; bool new_categories_added = NO; // 获取loadable_categories分类load方法列表 struct loadable_category *cats = loadable_categories; int used = loadable_categories_used; int allocated = loadable_categories_allocated; loadable_categories = nil; loadable_categories_allocated = 0; loadable_categories_used = 0; // 从前往后遍历进行load方法的调用 for (i = 0; i &lt; used; i++) &#123; Category cat = cats[i].cat; load_method_t load_method = (load_method_t)cats[i].method; Class cls; if (!cat) continue; cls = _category_getClass(cat); if (cls &amp;&amp; cls-&gt;isLoadable()) &#123; (*load_method)(cls, @selector(load)); cats[i].cat = nil; &#125; &#125; return new_categories_added;&#125; 现在，我相信你已经对load方法为何类先调用，分类后调用，并且为何父类先调用，子类后调用。但是还有一点，我们不甚明了，即类之间或分类之间的调用顺序是怎么确定的，从源码中可以看到，类列表是通过_getObjc2NonlazyClassList函数获取的，同样分类的列表是通过_getObjc2NonlazyCategoryList函数获取的。这两个函数获取到的类或分类的顺序实际上是与类源文件的编译顺序有关的，如下图所示： 可以看到，打印的load方法的执行顺序与源代码的编译顺序是一直的。 四、initialize方法分析我们可以采用和分析load方法时一样的策略来对initialize方法的执行情况，进行测试，首先将测试工程中所有类中添加initialize方法的实现。此时如果直接运行工程，你会发现控制台没有任何输出，这是由于只有第一次调用类的方法时，才会执行initialize方法，在main函数中编写如下测试代码： 123456789101112int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; [MySubObjectOne new]; [MyObjectOne new]; [MyObjectTwo new]; NSLog(@\"------------\"); [MySubObjectOne new]; [MyObjectOne new]; [MyObjectTwo new]; &#125; return 0;&#125; 运行代码控制台打印效果如下： 12342021-02-18 21:29:55.761897+0800 KCObjc[43834:23521232] initialize-cateOne:MyObjectOne2021-02-18 21:29:55.762526+0800 KCObjc[43834:23521232] initialize:MySubObjectOne2021-02-18 21:29:55.762622+0800 KCObjc[43834:23521232] initialize-cate:MyObjectTwo2021-02-18 21:29:55.762665+0800 KCObjc[43834:23521232] ------------ 可以看到，打印数据都出现在分割线前，说明一旦一个类的initialize方法被调用后，后续再向这个类发送消息，也不会在调用initialize方法，还有一点需要注意，需要注意，如果对子类发送消息，父类的initialize会先调用，再调用子类的initialize，同时，分类中如果实现了initialize方法则会覆盖类本身的，并且分类的加载顺序靠后的会覆盖之前的。下面我们就通过源码来分析下initialize方法的这种调用特点。 首先，在调用类的类方法时，会执行runtime中的class_getClassMethod方法来寻找实现函数，这个方法在源码中的实现如下： 12345Method class_getClassMethod(Class cls, SEL sel)&#123; if (!cls || !sel) return nil; return class_getInstanceMethod(cls-&gt;getMeta(), sel);&#125; 通过源码可以看到，调用一个类的类方法，实际上是调用其元类的示例方法，getMeta函数用来获取类的元类，关于类和元类的相关组织原理，我们这里先不扩展。我们需要关注的是class_getInstanceMethod这个函数，这个函数的实现也非常简单，如下： 12345678910Method class_getInstanceMethod(Class cls, SEL sel)&#123; if (!cls || !sel) return nil; // 做查询方法列表，尝试方法解析相关工作 lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER); // 从类对象中获取方法 return _class_getMethod(cls, sel);&#125; 在class_getInstanceMethod方法的实现中，_class_getMethod是最终获取要调用的方法的函数，在这之前，lookUpImpOrForward函数会做一些前置操作，其中就有initialize函数的调用逻辑，我们去掉无关的逻辑，lookUpImpOrForward中核心的实现如下： 12345678910IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)&#123; IMP imp = nil; // 核心在于!cls-&gt;isInitialized() 如果当前类未初始化过，会执行initializeAndLeaveLocked函数 if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123; cls = initializeAndLeaveLocked(cls, inst, runtimeLock); &#125; return imp;&#125; initializeAndLeaveLocked会直接调用initializeAndMaybeRelock函数，如下： 1234static Class initializeAndLeaveLocked(Class cls, id obj, mutex_t&amp; lock)&#123; return initializeAndMaybeRelock(cls, obj, lock, true);&#125; initializeAndMaybeRelock函数中会做类的初始化逻辑，这个过程是线程安全的，其核心相关代码如下： 1234567891011121314static Class initializeAndMaybeRelock(Class cls, id inst, mutex_t&amp; lock, bool leaveLocked)&#123; // 如果已经初始化过，直接返回 if (cls-&gt;isInitialized()) &#123; return cls; &#125; // 找到当前类的非元类 Class nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // 进行初始化操作 initializeNonMetaClass(nonmeta); return cls;&#125; initializeNonMetaClass函数会采用递归的方式沿着继承链向上查询，找到所有未初始化过的父类进行初始化，核心实现简化如下： 12345678910111213141516171819202122232425262728293031323334void initializeNonMetaClass(Class cls)&#123; Class supercls; // 标记是否需要初始化 bool reallyInitialize = NO; // 父类如果存在，并且没有初始化过，则递归进行父类的初始化 supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; initializeNonMetaClass(supercls); &#125; SmallVector&lt;_objc_willInitializeClassCallback, 1&gt; localWillInitializeFuncs; &#123; // 如果当前不是正在初始化，并且当前类没有初始化过 if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123; // 设置初始化标志，此类标记为初始化过 cls-&gt;setInitializing(); // 标记需要进行初始化 reallyInitialize = YES; &#125; &#125; // 是否需要进行初始化 if (reallyInitialize) &#123; @try &#123; // 调用初始化函数 callInitialize(cls); &#125; @catch (...) &#123; @throw; &#125; return; &#125;&#125; callInitialize函数最终会调用objc_msgSend函数来向类发送initialize初始化消息，如下： 12345void callInitialize(Class cls)&#123; ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize)); asm(\"\");&#125; 需要注意，initialize方法与load方法最大的区别在于其最终是通过objc_msgSend来实现的，每个类如果未初始化过，都会通过objc_msgSend来向类发送一次initialize消息，因此，如果子类没有对initialize实现，按照objc_msgSend的消息机制，其是会沿着继承链一路向上找到父类的实现进行调用的，所有initialize方法并不是只会被调用一次，假如父类中实现了这个方法，并且它有多个未实现此方法的子类，则当每个子类第一次接受消息时，都会调用一遍父类的initialize方法，这点非常重要，在实际开发中一定要牢记。 五、结语load和initialize方法是iOS开发中非常简单也也非常常用的两个方法，然而其与普通的方法比起来，还有有一些特殊，通过对源码的解读，我们可以更加深刻的理解这些特殊之处的原因及原理，编程的过程就像修行，知其然也知其所以然，与大家共勉。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：805263726","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"SwiftUI直通车系列（6）—— 使用动画","slug":"408SwiftUI直通车系列（6）—— 使用动画","date":"2020-11-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.387Z","comments":true,"path":"2020/11/30/408SwiftUI直通车系列（6）—— 使用动画/","link":"","permalink":"http://huishao.cc/2020/11/30/408SwiftUI直通车系列（6）—— 使用动画/","excerpt":"","text":"SwiftUI直通车系列（6）—— 使用动画本系列博客是针对SwiftUI开发框架的快速入门介绍，之前系列博客地址： SwiftUI直通车系列（1）—— 视图的布局与组织 SwiftUI直通车系列（2）—— 列表视图 SwiftUI直通车系列三（3）—— 使用导航 SwiftUI直通车系列（4）—— 处理用户交互 SwiftUI直通车系列（5）—— 自定义绘制 前面的博客整体对使用SwiftUI进行页面布局与简单的用户交互做了介绍。我们知道，作为一个优秀的UI框架，其很重要的一点是对动画的支持，动画是提升用户体验的重要方式，在SwiftUI中，实现动画效果将变得非常容易。 一、使用属性动画属性动画是指当组件的属性发生变化时所展示动画效果，例如组件的颜色、位置、尺寸、旋转角度等。在SwiftUI中，我们知道要动态的对组件样式进行更改，需要使用状态来控制。我们也可以使用状态来控制动画动作。 例如，我们定义一个按钮组件，当点击时，让其旋转180度，并略微放大，代码如下： 1234567891011121314151617struct DrawContent:View &#123; @State private var begin = false var body: some View &#123; VStack(alignment: .center, spacing: 20) &#123; Button(action: &#123; self.begin.toggle() &#125;) &#123; Text(\"开始\") .font(Font.system(size: 30)) .rotationEffect(.degrees(self.begin ? 180 : 0)) .scaleEffect(self.begin ? 2 : 1) .animation(.easeInOut(duration: 3)) &#125; &#125; &#125;&#125; 其中，begin状态属性用来记录动画的状态，当一次点击此按钮时，会将当前按钮放大一倍，并旋转180度，再次点击按钮会动画还原。 rotationEffect用来定义组件的旋转角度，scaleEffect用来定义组件缩放的比例，与之类似，大部分用来渲染视图样式的属性都支持进行动画。animation用来设置动画的执行方式，如上代码所示，设置的为easeInOut表示动画执行的过程采用渐入渐出的方式，且动画执行的时长为3秒。 二、使用转场动画属性动画用在组件的某些属性发生变化的场景，转场动画会影响组件的切换动作。当对组件进行展示或隐藏时，通常可以采用转场动画来处理。我们以上一篇博客自定义的图形组件为例，我们可以为其出现时加一个滑动动画，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637extension Animation &#123; static func custom() -&gt; Animation &#123; Animation.spring(response: 1.5, dampingFraction: 0.5, blendDuration: 0.5) .speed(2) .delay(0.03) &#125;&#125;struct DrawContent:View &#123; @State private var begin = false var body: some View &#123; VStack(alignment: /*@START_MENU_TOKEN@*/.center/*@END_MENU_TOKEN@*/, spacing: 20) &#123; Button(action: &#123; withAnimation &#123; self.begin.toggle() &#125; &#125;) &#123; Text(\"开始\") .font(Font.system(size: 30)) .rotationEffect(.degrees(self.begin ? 180 : 0)) .scaleEffect(self.begin ? 2 : 1) .animation(.easeInOut(duration: 3)) &#125; if self.begin &#123; ZStack&#123; ForEach(0 ..&lt; 10) &#123; i in DrawTestView(angle: Angle(degrees:Double(36*i))).opacity( 0.3) &#125; &#125;.animation(.custom()) .transition(.slide) &#125; &#125; &#125;&#125; 如上代码所示，其中custom是我们自定义的一种动画模式，上面采用了阻尼动画，并自定义了动画的阻尼参数，速度，延时等属性。","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}],"tags":[],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}]},{"title":"SwiftUI直通车系列（5）—— 自定义绘制","slug":"407SwiftUI直通车系列（5）—— 自定义绘制","date":"2020-10-31T16:00:00.000Z","updated":"2023-04-14T11:50:08.387Z","comments":true,"path":"2020/11/01/407SwiftUI直通车系列（5）—— 自定义绘制/","link":"","permalink":"http://huishao.cc/2020/11/01/407SwiftUI直通车系列（5）—— 自定义绘制/","excerpt":"","text":"SwiftUI直通车系列（5）—— 自定义绘制前情回顾： SwiftUI直通车系列（1）—— 视图的布局与组织 SwiftUI直通车系列（2）—— 列表视图 SwiftUI直通车系列三（3）—— 使用导航 SwiftUI直通车系列（4）—— 处理用户交互 在UI开发中，我们经常会使用到各式各样的图标或图形。通常，我们可以直接使用图片来渲染图形，在SwiftUI中也提供了相关的接口来对图形绘制提供支持，理论上，我们可以不使用外部图片来自定义绘制出我们想要渲染的图形。 一、图形绘制首先，在定义SwiftUI组件时，我们可以通过路径的定义绘制其要表现的UI图形，例如要在页面上显示一个菱形图形，示例代码如下： 123456789101112131415161718struct DrawTestView:View &#123; var body: some View &#123; Path &#123; path in let width = 200 let height = 200 path.move(to: CGPoint(x: width, y: height)) path.addLine(to: CGPoint(x: 100, y: 400)) path.addLine(to: CGPoint(x: 200, y: 600)) path.addLine(to: CGPoint(x: 300, y: 400)) &#125;.fill(Color.red) &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; DrawTestView() &#125;&#125; 效果如下图所示: 上面的代码很好理解，使用Path在定义View时，move方法用来进行绘制点的移动，简单理解，如果我们将图形的绘制类比与用笔作画，则move方法的作用就是移动笔尖的位置。addLine方法用来向视图上画一条线，定义完了路径后，调用fill方法用来进行图形内部颜色的填充。如上代码所示，实际上我们只画了三条线，系统默认将三条线及最后一个点与原点的连线组成的图形内部进行了颜色的填充，如果我们不对内部进行颜色填充，只将线的颜色显示出来，就更加直观了，代码如下： 123456789101112struct DrawTestView:View &#123; var body: some View &#123; Path &#123; path in let width = 200 let height = 200 path.move(to: CGPoint(x: width, y: height)) path.addLine(to: CGPoint(x: 100, y: 400)) path.addLine(to: CGPoint(x: 200, y: 600)) path.addLine(to: CGPoint(x: 300, y: 400)) &#125;.stroke(Color.red,lineWidth: 10) &#125;&#125; 效果如下图所示： 与addLine的使用方法类似，我们还可以通过添加矩形、椭圆、贝塞尔曲线等等方法来绘制图形，示例代码如下： 12345678910111213141516struct DrawTestView:View &#123; var body: some View &#123; Path &#123; path in let width = 200 let height = 200 path.move(to: CGPoint(x: width, y: height)) path.addLine(to: CGPoint(x: 100, y: 400)) path.addLine(to: CGPoint(x: 200, y: 600)) path.addLine(to: CGPoint(x: 300, y: 400)) path.addRect(CGRect(x: 20, y: 20, width: 30, height: 30)) path.addEllipse(in: CGRect(x: 60, y: 20, width: 60, height: 30)) path.addCurve(to: CGPoint(x: 100, y: 100), control1: CGPoint(x: 160, y: 100), control2: CGPoint(x: 60, y: 80)) path.addRoundedRect(in: CGRect(x: 140, y: 20, width: 50, height: 40), cornerSize: CGSize(width: 20, height: 20)) &#125;.stroke(Color.red,lineWidth: 3) &#125;&#125; 效果如下图所示： 二、设置绘制属性在SwiftUI中，完成了图形的定义是一步，之后我们还需要将图形描边绘制或填充绘制。无论是描边绘制还是填充绘制，我们都可以定制化的对绘制属性进行控制，例如下面的示例代码： 1234567891011121314151617181920212223struct DrawTestView:View &#123; var body: some View &#123; VStack &#123; Path &#123; path in let width = 200 let height = 0 path.move(to: CGPoint(x: width, y: height)) path.addLine(to: CGPoint(x: 100, y: 200)) path.addLine(to: CGPoint(x: 200, y: 400)) path.addLine(to: CGPoint(x: 300, y: 200)) path.addLine(to: CGPoint(x: 200, y: 0)) &#125;.stroke(style: StrokeStyle(lineWidth: 3, lineCap: CGLineCap.butt, lineJoin: .bevel, miterLimit: 2, dash: [15,4], dashPhase: 2)).foregroundColor(.blue) Path &#123; path in let width = 200 let height = 20 path.move(to: CGPoint(x: width, y: height)) path.addLine(to: CGPoint(x: 100, y: 220)) path.addLine(to: CGPoint(x: 200, y: 420)) path.addLine(to: CGPoint(x: 300, y: 220)) &#125;.fill(LinearGradient(gradient: Gradient(colors: [Color.red, Color.blue]), startPoint: .top, endPoint: .bottom)) &#125; &#125;&#125; 效果如下图所示： 对于描边绘制，我们可以设置线的风格，间距，转角风格等。对于填充绘制，我们可以为其设置渐变填充，上面代码示例的是线性渐变效果，系统还提供了圆心渐变等功能。 三、简单的图形变换和组合有规律的对绘制的图形进行变换和组合往往可以得到非常美观的复合图形，例如对于上面绘制的菱形，我们可以通过修改透明度进行图形组合，并使用旋转变换的方式使其构建出更加美观的图标，修改代码如下： 1234567891011121314151617181920212223242526272829struct DrawTestView:View &#123; let angle:Angle var body: some View &#123; Path &#123; path in let width = 250 let height = 150 path.move(to: CGPoint(x: width, y: height)) path.addLine(to: CGPoint(x: 100, y: 300)) path.addLine(to: CGPoint(x: 200, y: 450)) path.addLine(to: CGPoint(x: 300, y: 100)) &#125;.fill(LinearGradient(gradient: Gradient(colors: [Color.red, Color.blue]), startPoint: .top, endPoint: .bottom)).rotationEffect(angle, anchor: .center) &#125;&#125;struct DrawContent:View &#123; var body: some View &#123; ZStack&#123; ForEach(0 ..&lt; 10) &#123; i in DrawTestView(angle: Angle(degrees:Double(36*i))).opacity(0.3) &#125; &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; DrawContent() &#125;&#125; 效果如下图所示：","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}],"tags":[],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}]},{"title":"SwiftUI直通车系列（4）—— 处理用户交互","slug":"406SwiftUI直通车系列（4）—— 处理用户交互","date":"2020-09-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.387Z","comments":true,"path":"2020/09/29/406SwiftUI直通车系列（4）—— 处理用户交互/","link":"","permalink":"http://huishao.cc/2020/09/29/406SwiftUI直通车系列（4）—— 处理用户交互/","excerpt":"","text":"SwiftUI直通车系列（4）—— 处理用户交互前情回顾： SwiftUI直通车系列（1）—— 视图的布局与组织 SwiftUI直通车系列（2）—— 列表视图 SwiftUI直通车系列（3）—— 使用导航 前面，我们介绍了在SwiftUI中布局与页面跳转的相关逻辑，其中页面跳转可以算是处理用户交互，SwiftUI虽然从名字上听，是一个UI框架，但是其依然有很强大的交互处理能力。本篇博客，我们就其用户交互能力进行介绍和学习。 一、SwiftUI中的按钮按钮是处理用户交互的最基础的组件，在SwiftUI中，使用Button可以十分方便的定义按钮组件，如下： 1234567891011121314151617181920var count = 0struct SimpleView:View &#123; var body: some View &#123; VStack(alignment: .center, spacing: 20) &#123; Button(action:&#123; count += 1 &#125;)&#123; Text(\"按钮一\") &#125; Text(\"\\(count)\") &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; SimpleView() &#125;&#125; 在预览界面，可以看到一个按钮和计数器已经布局在了页面上，我们尝试点击按钮，会发现变量count虽然已经被改变了，但是页面并没有更新。能够接收到用户交互只是第一步，在SwiftUI中通过用户交互而进行页面的刷新才是核心我们需要关注的。效果如下： 二、状态SwiftUI采用的是描述性的结构化布局策略，即通过定义结构体这种结构化的数据来描述页面的布局。这种布局思路开发直观快速，并且非常易于入门上手。其与流行的前端框架Flutter，React等布局思路已经非常相似。因此，对于页面的刷新操作，我们也不能采用原始的iOS开发页面刷新的方式(对对象进行操作)，而是要使用状态来对组件进行管理，改变组件的状态来实现组件刷新操作。 修改上面代码如下： 12345678910111213141516171819struct SimpleView:View &#123; @State var count = 0 var body: some View &#123; VStack(alignment: /*@START_MENU_TOKEN@*/.center/*@END_MENU_TOKEN@*/, spacing: 20) &#123; Button(action:&#123; self.count += 1 &#125;)&#123; Text(\"按钮一\") &#125; Text(\"\\(self.count)\") &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; SimpleView() &#125;&#125; 重新恢复预览，可以看到计数器的功能已经正常了。@State是SwiftUI中提供的一个属性装饰器，其可以将某个属性指定为有状态的，当有状态的属性发生变化时，与其绑定的组件会自动刷新。 如果有状态属性在父组件中，而我们需要在子组件中处理用户交互逻辑进行页面刷新，这时，如果不做特殊的处理，子组件会因为结构体不可修改的原则而导致无法对传递进来的状态属性进行更改。对于这种场景，我们可以使用SwiftUI中提供的@Binding装饰器来修改子组件中的属性，例如： 123456789101112131415161718192021222324252627struct SimpleSubText:View &#123; @Binding var count:Int var body: some View &#123; Button(action:&#123; self.count += 1 &#125;)&#123; Text(\"按钮一\") &#125; Text(\"\\(self.count)\") &#125;&#125;struct SimpleView:View &#123; @State var count = 0 var body: some View &#123; VStack(alignment: /*@START_MENU_TOKEN@*/.center/*@END_MENU_TOKEN@*/, spacing: 20) &#123; SimpleSubText(count: $count) &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; SimpleView() &#125;&#125; 三、使用环境对象使用状态来管理组件刷新并不复杂，但是如果组件的嵌套层数较多，有状态数据的传递可能需要层层下传，这会使数据的流转变得相对复杂。在SwiftUI中，还有另外一种方式，可以定义环境对象，环境对象在SwiftUI组件的任意位置都可以自由访问和修改，与环境对象有绑定关系的组件都会接收到变动的通知并刷新。示例代码如下： 123456789101112131415161718192021222324252627282930313233// 作为环境数据的类，必须是可绑定监听的，需要继承ObservableObjectclass EnviData: ObservableObject &#123; @Published var count = 0&#125;struct SimpleSubText:View &#123; // 获取环境数据进行使用 @EnvironmentObject var data:EnviData var body: some View &#123; Button(action:&#123; self.data.count += 1 &#125;)&#123; Text(\"按钮一\") &#125; Text(\"\\(self.data.count)\") &#125;&#125;struct SimpleView:View &#123; var body: some View &#123; VStack(alignment: .center, spacing: 20) &#123; SimpleSubText() &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; // 传递环境数据 SimpleView().environmentObject(EnviData()) &#125;&#125; 需要注意，并不是环境对象中所有的属性都会触发绑定和监听，只有使用@published的属性才会触发，因此环境对象也是支持静态的内部属性。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：805263726","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}],"tags":[],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}]},{"title":"SwiftUI直通车系列（3）—— 使用导航","slug":"405SwiftUI直通车系列（3）—— 使用导航","date":"2020-09-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.386Z","comments":true,"path":"2020/09/27/405SwiftUI直通车系列（3）—— 使用导航/","link":"","permalink":"http://huishao.cc/2020/09/27/405SwiftUI直通车系列（3）—— 使用导航/","excerpt":"","text":"SwiftUI直通车系列三（3）—— 使用导航关于SwiftUI，我们前两篇博客介绍了独立组件的布局与属性设置相关内容，并且介绍了开发中最常用的列表视图的使用。但是一个完整的应用程序不可能是单界面的，如何使用SwiftUI进行界面间的导航跳转，是我们本博客讨论的重点。前两篇博客地址如下： SwiftUI直通车系列（1）—— 视图的布局与组织 SwiftUI直通车系列（2）—— 列表视图 在本系列的第二篇博客中，我们能够使用SwiftUI来构建列表视图，通常，列表视图用来展示目录页面，当用户点击列表中的某一项时，需要跳转到详情页。在iOS应用中，页面的跳转常用导航控制器进行管理。在SwiftUI中，创建一个导航也是非常简单的，只需要在组件最外层嵌套NavigationView即可。以我们之前的列表视图Demo为例，改写代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import SwiftUIimport UIKitstruct ContactModel &#123; var name:String var phone:String&#125;let modelData = [ ContactModel(name:\"王小丫\", phone:\"15137348888\"), ContactModel(name:\"李小二\", phone:\"15137348989\")]struct ContentView: View &#123; var body: some View &#123; VStack (alignment: .leading, spacing: 10) &#123; Text(\"Hello, SwiftUI!啊啊啊\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) Spacer() Text(\"Hello, SwiftUI!\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) &#125; .padding(EdgeInsets(top: 30, leading: 0, bottom: 30, trailing: 0)) &#125;&#125;struct Label:UIViewRepresentable &#123; func makeUIView(context: Context) -&gt; UILabel &#123; UILabel(frame: .zero) &#125; func updateUIView(_ uiView: UILabel, context: Context) &#123; uiView.text = \"Hello\" &#125;&#125;struct ContentImage:View &#123; var body: some View &#123; Image(\"demo\") .clipShape(Circle()) .shadow(radius: 30) &#125;&#125;struct RowContent:View &#123; var contactModel:ContactModel var body: some View &#123; HStack(alignment:.top) &#123; Image(\"demo\").resizable().frame(width: 70, height: 70) VStack(alignment:.leading, spacing: 10) &#123; Text(self.contactModel.name).bold().font(Font.system(size: 25)) Text(self.contactModel.phone).font(Font.system(size: 20)) &#125; Spacer() &#125;.padding(EdgeInsets(top: 10, leading: 20, bottom: 10, trailing: 20)) &#125;&#125;struct ListContent:View &#123; var body: some View &#123; NavigationView &#123; List(modelData, id: \\.name) &#123; model in RowContent(contactModel: model) &#125; .navigationBarTitle(\"通讯录\") &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ListContent() &#125;&#125; 你只需要关注ListContent结构体即可，其中为列表视图设置了导航，并且定义了导航栏上的标题，效果如下图： 要实现页面的跳转，需要为要触发跳转的组件添加NavigationLink包裹，NavigationLink可以指向要跳转的详情页面，如下： 123456789101112struct ListContent:View &#123; var body: some View &#123; NavigationView &#123; List(modelData, id: \\.name) &#123; model in NavigationLink(destination: ContentImage()) &#123; RowContent(contactModel: model) &#125; &#125; .navigationBarTitle(\"通讯录\") &#125; &#125;&#125; 如果详情页面是动态的，在跳转时，我们也可以将数据传递过去，如下： 123456789101112131415161718192021222324252627struct ContentImage:View &#123; var name:String var phone:String var body: some View &#123; VStack() &#123; Image(\"demo\") .clipShape(Circle()) .shadow(radius: 30) .offset(x: 0, y: -70) Text(name).offset(x: 0, y: -50) Text(phone).offset(x: 0, y: -30) &#125; &#125;&#125;struct ListContent:View &#123; var body: some View &#123; NavigationView &#123; List(modelData, id: \\.name) &#123; model in NavigationLink(destination: ContentImage(name: model.name, phone: model.phone)) &#123; RowContent(contactModel: model) &#125; &#125; .navigationBarTitle(\"通讯录\") &#125; &#125;&#125; 效果如下图所示： 默认导航的标题是大文字风格的，若要使用常规风格的，需要配置其displayMode属性，如下： 123456789101112struct ListContent:View &#123; var body: some View &#123; NavigationView &#123; List(modelData, id: \\.name) &#123; model in NavigationLink(destination: ContentImage(name: model.name, phone: model.phone)) &#123; RowContent(contactModel: model) &#125; &#125; .navigationBarTitle(\"通讯录\", displayMode: .inline) &#125; &#125;&#125; 效果如下图所示： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：805263726","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}],"tags":[],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}]},{"title":"SwiftUI直通车系列（2）—— 列表视图","slug":"404 SwiftUI直通车系列（2）—— 列表视图","date":"2020-08-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.386Z","comments":true,"path":"2020/08/28/404 SwiftUI直通车系列（2）—— 列表视图/","link":"","permalink":"http://huishao.cc/2020/08/28/404 SwiftUI直通车系列（2）—— 列表视图/","excerpt":"","text":"SwiftUI直通车系列（2）—— 列表视图列表视图的开发中非常常用的页面元素。SwiftUI中也有专门用来渲染列表的元素提供。 一、编写行视图列表实际上是一组行视图的组合，在布局列表视图之前，你首先需要定义好行视图的布局。例如，我们使用一个Image元素和两个Text元素来布局一个简单的联系人行视图。 123456789101112struct RowContent:View &#123; var body: some View &#123; HStack(alignment:.top) &#123; Image(\"demo\").resizable().frame(width: 70, height: 70) VStack(alignment:.leading, spacing: 10) &#123; Text(\"王小丫\").bold().font(Font.system(size: 25)) Text(\"15137344444\").font(Font.system(size: 20)) &#125; Spacer() &#125;.padding(EdgeInsets(top: 10, leading: 20, bottom: 10, trailing: 20)) &#125;&#125; 在预览界面上与布局情况进行预览，如下图： 二、关联数据列表中展示的数据往往是一组相似类型的数据。以上联系人行视图为例，我们可以定义一组联系人数据来填充到列表的行视图中。首先定义一个结构体用来描述联系人信息，如下： 123456789struct ContactModel &#123; var name:String var phone:String&#125;let modelData = [ ContactModel(name:\"王小丫\", phone:\"15137348888\"), ContactModel(name:\"李小二\", phone:\"15137348989\")] 如上代码所示，其中ContactModel定义了联系人的基本信息，modelData是一组联系人模型，实际应用中，modelData的数据来源可能是网络，也可能是本地文件。修改RowContent代码如下： 123456789101112131415struct RowContent:View &#123; var contactModel:ContactModel var body: some View &#123; HStack(alignment:.top) &#123; Image(\"demo\").resizable().frame(width: 70, height: 70) VStack(alignment:.leading, spacing: 10) &#123; Text(self.contactModel.name).bold().font(Font.system(size: 25)) Text(self.contactModel.phone).font(Font.system(size: 20)) &#125; Spacer() &#125;.padding(EdgeInsets(top: 10, leading: 20, bottom: 10, trailing: 20)) &#125;&#125; SwiftUI的实时预览功能也支持对一组组件进行预览，示例如下： 12345678struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; Group &#123; RowContent(contactModel: modelData[0]) RowContent(contactModel: modelData[1]) &#125;.previewLayout(.fixed(width: 400, height: 80)) &#125;&#125; 效果如下图所示： 三、使用列表组件SwiftUI中使用List组件来构建列表，将布局好的列表行视图嵌入其中即可展示出列表界面，如下： 1234567891011121314struct ListContent:View &#123; var body: some View &#123; List &#123; RowContent(contactModel: modelData[0]) RowContent(contactModel: modelData[1]) &#125; &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ListContent() &#125;&#125; 此时，预览效果如下图所示： 在实际开发中，一般我会采用动态的方式来构建列表，通过对数据源的便利，可以循环生成列表行，示例如下： 1234567struct ListContent:View &#123; var body: some View &#123; List(modelData, id: \\.name) &#123; model in RowContent(contactModel: model) &#125; &#125;&#125; 其中id是一个行标识字段，使用数据源中能够保证唯一的字段来设置即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：805263726","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}],"tags":[],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}]},{"title":"SwiftUI直通车系列（1）—— 视图的布局与组织","slug":"403SwiftUI直通车系列（1）—— 视图的布局与组织","date":"2020-08-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.386Z","comments":true,"path":"2020/08/26/403SwiftUI直通车系列（1）—— 视图的布局与组织/","link":"","permalink":"http://huishao.cc/2020/08/26/403SwiftUI直通车系列（1）—— 视图的布局与组织/","excerpt":"","text":"SwiftUI直通车系列（1）—— 视图的布局与组织一、引言SwiftUI提供了一种更快、更高效也更简单的页面开发方式。我们知道相对于Objective-C，Swift语言本身就更加高效简洁，SwiftUI采用了结构化的布局方式，使得应用的界面开发更加直观快速。本系列博客，基于Apple官方的SwiftUI Tutorials为参考，配合代码示例介绍了SwiftUI的基础应用和特性，帮助大家快速入门SwiftUI开发，为工作中的开发效率赋能。 二、SwiftUI初体验做为Apple相关产品的开发者，影响界面开发效率的一大问题是每次代码的修改要查看效果都需要重新编译运行。往往，调试验证的时间要远远大于编码时间，严重影响了开发效率。当然，这也是大多数编译型语言所共有的痛点。使用SwiftUI配合Xcode的预览功能，可以做到代码的实时修改实时预览效果，界面的开发效率非常高。 首先，我们可以创建一个模板工程体验下SwiftUI的基础功能。使用Xcode新建一个App项目，在选择语言时，选择Swift，并使用SwiftUI创建界面入口，如下图所示。 创建出的工程中包含3个swift文件，其中AppDelegate.swift文件是应用的入口文件，其在任何模板项目中几乎都是一样的，没有什么特别支持。SceneDelegate.swift文件是iOS 13后新引入的，用来进行多场景的管理，我们也无需关注。ContentView.swift文件是最终的界面定义文件，其中使用SwiftUI定义了界面的显示内容，ContentView.swift文件中的代码如下： 12345678910111213import SwiftUIstruct ContentView: View &#123; var body: some View &#123; Text(\"Hello, SwiftUI!\") &#125;&#125;struct ContentView_Previews: PreviewProvider &#123; static var previews: some View &#123; ContentView() &#125;&#125; 如上代码所示，ContentView是定义的一个视图结构体，其描述的就是界面的渲染信息，其中Text会在页面上渲染出一个文本标签，显示“Hello Swift!”，ContentView_Previews定义了当前界面的预览视图，你可以尝试对Text中的文本进行修改，修改后预览页面就会实时的展示出当前的界面模样，如下图所示。 可以通过为Text组件设置属性来实时的改变界面，例如文本的颜色，字体，是否加下划线等等，如下： 12345678struct ContentView: View &#123; var body: some View &#123; Text(\"Hello, SwiftUI!\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) &#125;&#125; 此时页面效果如下图所示： 通过代码可以修改UI元素的属性，除此之外，我们还可以设置容器的对齐方式和元素间距等，如下： 1234567891011121314struct ContentView: View &#123; var body: some View &#123; VStack (alignment: .leading, spacing: 10) &#123; Text(\"Hello, SwiftUI!啊啊啊\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) Text(\"Hello, SwiftUI!\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) &#125; &#125;&#125; 其中alignment设置内部组件的对其方式，spacing设置组件间距离，对于水平栈，spacing设置的是列间距，对于垂直栈，spacing设置的是行间距。默认，组件会自动计算其做占据的位置，SwiftUI中也提供了一种特殊的占位元素，其可以将剩余的空间充满，例如在两个垂直布局的元素中间加入一个占位元素，则其会进行两端布局，如下： 123456789101112131415struct ContentView: View &#123; var body: some View &#123; VStack (alignment: .leading, spacing: 10) &#123; Text(\"Hello, SwiftUI!啊啊啊\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) Spacer() Text(\"Hello, SwiftUI!\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) &#125; &#125;&#125; 效果如下图所示： 可以发现，SwiftUI在布局上，很多思路都和CSS布局很像，对于组件元素，我们也可以为其追加内间距Padding，例如： 12345678910111213141516struct ContentView: View &#123; var body: some View &#123; VStack (alignment: .leading, spacing: 10) &#123; Text(\"Hello, SwiftUI!啊啊啊\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) Spacer() Text(\"Hello, SwiftUI!\") .foregroundColor(Color.red) .underline() .font(Font.system(size: 25)) &#125; .padding(EdgeInsets(top: 30, leading: 0, bottom: 30, trailing: 0)) &#125;&#125; 三、使用图片组件在SwiftUI中，可以方便的布局图片元素，并设置图片的圆角，阴影，边框等。使用如下代码即可在界面中间布局出一个图片元素： 12345struct ContentImage:View &#123; var body: some View &#123; Image(\"demo\") &#125;&#125; 其中“demo”为工程中一个资源图片的名字。预览效果如下： 图片元素也有很多属性可以设置，如clipShape设置元素的形状，shadow设置元素的阴影，示例代码如下： 1234567struct ContentImage:View &#123; var body: some View &#123; Image(\"demo\") .clipShape(Circle()) .shadow(radius: 30) &#125;&#125; 效果如下图所示： 四、在SwiftUI中使用UIKit组件上面我们使用的文本与图片元素，都是SwiftUI框架中定义的基础组件。在实际开发中的更多时候，你需要结合UIKit来自定义一个SwiftUI组件，这本身也非常方便。例如我们要使用UIKit中的UILabel组件，示例如下： 123456789struct Label:UIViewRepresentable &#123; func makeUIView(context: Context) -&gt; UILabel &#123; UILabel(frame: .zero) &#125; func updateUIView(_ uiView: UILabel, context: Context) &#123; uiView.text = \"Hello\" &#125;&#125; UIViewRepresentable协议用来将UIKit中的组件定义为一个SwiftUI元素，其中有两个方法是必须要实现的，makeUIView用来返回一个指定的UIKit组件，updateUIView当组件更新时会被调用。 有了这些基础知识，我们已经可以使用SwiftUI来实现简单的页面构建了，你可以尝试用其做些简单的页面组合，只需要把握住，在SwiftUI中，无论简单还是复杂的界面都是通过水平和和垂直栈的组合，加上组件的位置偏移所布局出来的。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：805263726","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}],"tags":[],"keywords":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://huishao.cc/categories/SwiftUI/"}]},{"title":"iOS14新特性探索之二：App Widget小组件应用","slug":"402iOS14新特性探索之二：App Widget小组件应用","date":"2020-07-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.386Z","comments":true,"path":"2020/07/10/402iOS14新特性探索之二：App Widget小组件应用/","link":"","permalink":"http://huishao.cc/2020/07/10/402iOS14新特性探索之二：App Widget小组件应用/","excerpt":"","text":"iOS14新特性探索之二：App Widget小组件应用iOS 14除了引入了亮眼的App Clips功能外。还有一个也非常惹争议的功能就是App Widget。App Widget可以理解为小组件，在非常早的Android版本中就有了Widget的概念，应用开发者可以为系统开发自己应用相契合的Widget来让用户更加方便的使用应用提供的功能。例如Android早期系统中非常常见的钟表时间组件、快捷设置组件等。用户可以将这些小组件根据自己的喜好放在屏幕的指定位置。从这点看，iOS 14提供的App Widget功能的确不能算是一种创新，最多算是一种增强。 其实，iOS Widget的概念并非是iOS 14突然引入的，在iOS 10发布时，iOS系统就引入了Extension相关功能，其中有一种Extension叫做Today Extension，这就是iOS 14中Widget的前身。Today Extension允许开发者为负一屏开发快捷功能入口。关于Today Extension的应用，如下博客有详细的介绍： iOS8新特性扩展(Extension)应用之一——Today扩展：https://my.oschina.net/u/2340880/blog/485533 iOS中Today扩展插件与宿主APP的交互：https://my.oschina.net/u/2340880/blog/711807 需要注意，在iOS 14中，Today Extension相关的接口都已经被废弃，我们需要使用新的WidgetKit框架提供的小组件接口开发Widget。在iOS 14上，Today Extension依然可以使用，但是其功能受限，只能在负一屏展示它，用户不能随意的将其放在指定屏的指定位置。 1. 关于App WidgetWidget为应用程序提供了这样一种功能：其可以让用户在主屏幕上展示App中用户所关心的信息。例如一款天气软件，其可以附带一个Widget让用户在主屏幕就可查看今日的天气情况，例如股票相关的软件，用户将自己感兴趣的股票收藏，无需打开App，在主屏幕即可查到对应的股价信息。如下图所示，是系统提供的电池Widget展示在主屏幕上的示例： 一个App也可以提供多个Widget组件，用户可以选择将其最关心的放置在最重要的位置上，以便最方便的获取信息。对于同一种Widget组件，开发者也可以提供不同的尺寸或不同的布局，这可以提供给用户更多的选择以满足不同用户的偏好。 为应用程序添加一个Widget组件并不复杂，但是有一点需要注意，小组件的UI部分只能够使用SwiftUI来开发，因此如果你要开发Widget组件，必须有一些Swift的基础并对SwiftUI有一定的了解。对于Swift与SwiftUI的相关内容，本篇博客就不再做过多赘述。 2. 创建App Widget与其他的Extension扩展类似，App Widget本身也是一种扩展，因此其只能依赖一个宿主App而存在，首先向已有的App中添加App Widget非常简单，为项目创建一个新的Target，选择其中的Widget Extension模板进行创建，如下图： 创建完成后，Xcode会自动帮我们创建和配置的文件的工作都完成，默认的模板为我们创建了一个显示当前时间的组件，我们可以直接在真机上运行它(Bate版本的Xcode模拟器运行会有些异常)，之后，我们就可以将这个显示时间的小组件放置在主屏幕的任意位置，并且，默认提供了3种尺寸供用户选择，如下图所示： Xcode为我们创建的这个模板虽然简单，但是五脏俱全。Widget加载的入口是@main标记的结构体，代码如下： 123456789101112@mainstruct WidgetExt: Widget &#123; private let kind: String = \"WidgetExt\" public var body: some WidgetConfiguration &#123; StaticConfiguration(kind: kind, provider: Provider(), placeholder: PlaceholderView()) &#123; entry in WidgetExtEntryView(entry: entry) &#125; .configurationDisplayName(\"My Widget\") .description(\"This is an example widget.\") &#125;&#125; WidgetExt是我们为组件target项目设置的名字，模板自动使用这个名字帮我们生成了一个实现了Widget协议的结构体。结构体中实现了两个属性，其实Widget协议提供的核心只读属性只有一个body，将上面的代码改写如下也是一样的： 12345678910@mainstruct WidgetExt: Widget &#123; public var body: some WidgetConfiguration &#123; StaticConfiguration(kind: \"WidgetExt\", provider: Provider(), placeholder: PlaceholderView()) &#123; entry in WidgetExtEntryView(entry: entry) &#125; .configurationDisplayName(\"My Widget\") .description(\"This is an example widget.\") &#125;&#125; 上面代码的核心在于body只读属性的实现，其需要返回一个实现了WidgetConfiguration协议的示例。这个协议描述了组件的配置信息，StaticConfiguration是系统提供的组件配置结构体，其用来对静态类型的组件提供配置。StaticConfiguration完整的构造方法如下： 123456public init&lt;Provider, PlaceholderContent&gt;(kind: String, provider: Provider, placeholder: PlaceholderContent, content: @escaping (Provider.Entry) -&gt; Content) where Provider : TimelineProvider, PlaceholderContent : View 可以看到，上面构造方法中的Provider和PlaceholderContent实际上是两个泛型，我们后面再介绍。目前，我们先关注下构造方法需要传的几个参数。 kind：这个参数是一个字符号，我们可以任意提供，用来标识这个Widget组件。 provider：简单理解，这是一个数据提供对象，用来为小组件提供渲染数据，其必须实现TimelineProvider协议，即是基于时间线来驱动小组件的渲染。 placeholder：提供一个占位的视图，当小组件没有数据或者在锁屏状态时，会显示这个占位视图。 content：为小组件提供内容，是一个闭包，其中会把Provider的entry属性传入，因此小组件的视图渲染实际是由Provider驱动的。 明白了上面几个参数的意义，开发小组件就非常轻松了。首先，需要创建一个合适的Provider来为小组件提供数据支持，以模板中的代码为例，如下： 123456789101112131415161718192021222324252627struct Provider: TimelineProvider &#123; public typealias Entry = SimpleEntry public func snapshot(with context: Context, completion: @escaping (SimpleEntry) -&gt; ()) &#123; let entry = SimpleEntry(date: Date()) completion(entry) &#125; public func timeline(with context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) &#123; var entries: [SimpleEntry] = [] // Generate a timeline consisting of five entries an hour apart, starting from the current date. let currentDate = Date() for hourOffset in 0 ..&lt; 5 &#123; let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)! let entry = SimpleEntry(date: entryDate) entries.append(entry) &#125; let timeline = Timeline(entries: entries, policy: .atEnd) completion(timeline) &#125;&#125;struct SimpleEntry: TimelineEntry &#123; public let date: Date&#125; 如上代码所示，Provider结构体实现了TimelineProvider协议，这个协议中只定义了两个方法，分别是上面实现的snapshot方法和timeline方法。 其中snapshop方法在小组件启动时会被调用一次，用来为小组件提供首屏渲染所需要的数据，其通常用来提供一些初始化的数据。调用完snapshot方法后，会调用timeline方法来定义要更新组件的时间线，这个方法的回调中需要传入一组Timeline对象，如上代码所示，其定义当前时刻开始，每隔一个小时进行一次刷新，将当前组件显示的时间刷新成最新的时刻，当最后一次刷新任务结束后，会再次调用timeline函数重新设置一组更新的时间线。关于时间线的详细介绍，后面会提及。 有了Provider来对组件的更新提供驱动后，就是小组件页面的渲染了，在StaticConfiguration构造方法的闭包中，我们需要返回一个View作为小组件的内容，模板提供的示例代码如下： 1234567struct WidgetExtEntryView : View &#123; var entry: Provider.Entry var body: some View &#123; Text(entry.date, style: .time) &#125;&#125; 在向主屏幕添加小组件时，用户可以选择不同尺寸的小组件进行添加，在小组件的渲染布局时，开发者也可以根据不同的环境尺寸配置不同的渲染策略，例如下面代码： 123456789101112131415struct WidgetExtEntryView : View &#123; @Environment(\\.widgetFamily) var family: WidgetFamily var entry: Provider.Entry @ViewBuilder var body: some View &#123; switch family &#123; case .systemSmall: Text(entry.date, style: .time) case .systemMedium: Text(entry.date, style: .date) case .systemLarge: Text(entry.date, style: .relative) default: Text(entry.date, style: .time) &#125; &#125;&#125; 其中通过Enviroment用来判断当前组件的环境情况，即组件的尺寸信息，上面代码根据不同的尺寸渲染了不同格式的时间。 现在，我们对小组件的创建流程已经有了初步的了解，需要注意，小组件只能用来展示静态的信息，并能支持可交互的组件，例如选择器或滚动视图，当用户点击小组件时，会唤起App本身，并传递一个特殊的URL用来给宿主App做逻辑处理。一个App只能创建一个App Widget，但这并不是说我们只能有一种功能类型的组件，可以通过定义组件包，来提供多个小组件供用户进行使用，示例如下： 12345678910111213141516171819202122232425262728struct WidgetExt: Widget &#123; public var body: some WidgetConfiguration &#123; StaticConfiguration(kind: \"WidgetExt\", provider: Provider(), placeholder: PlaceholderView()) &#123; entry in WidgetExtEntryView(entry: entry) &#125; .configurationDisplayName(\"My Widget\") .description(\"This is an example widget.\") &#125;&#125;struct WidgetExt2: Widget &#123; public var body: some WidgetConfiguration &#123; StaticConfiguration(kind: \"WidgetExt2\", provider: Provider(), placeholder: PlaceholderView()) &#123; entry in PlaceholderView() &#125; .configurationDisplayName(\"My Widget\") .description(\"This is an example widget.\") &#125;&#125;@mainstruct WidgetsExt: WidgetBundle &#123; @WidgetBundleBuilder var body: some Widget &#123; WidgetExt() WidgetExt2() &#125;&#125; 需要注意，不同的小组件定义的kind参数要有差异。 3. App Widget 的更新机制通过前面的Widget初体验，我们知道App Widget可以通过定义时间线来实现视图的动态更新。App Widget使用SwiftUI来进行视图的渲染。Widget有单独的系统进程进行维护，因此即便小组件已经显示在屏幕上，其也并不是一直都是活跃的，开发者可以定义一些时机来对小组件的内容进行更新。 首先，在开发小组件时，我们要清楚所需要的更新时机。例如对于天气类小组件，可能需要每3小时对组件进行一次更新。当我们定义小组件Widget时，需要指定一个TimelineProvider来对其更新进行驱动，TimelineProvider可以理解为定义了一条时间线，配合官方文档中的一张图片来理解时间线的作用会比较容易： 如上图中所示，其定义时间线为之后每小时进行刷新，由于将时间线的Refresh机制设置为了atEnd，3小时后系统会重新请求新的Timeline策略，上图中将第2次请求Timeline策略是设置为了立即刷新一次，之后由于时间线的Refresh机制设置为了never，之后不会再尝试请求时间线进行组件更新。时间轴的Refresh选项实际上是设置了当已经定义的时间轴执行完成后，系统将采用怎样的策略(是重新请求还是从此结束更新)。例如下图： 上图描述了这样一种逻辑，首先请求的时间线定义在未来3个小时，每小时更新一次，并在2小时候重新请求时间线，2小时后新请求的时间线定义2小时后刷新Widget并指定了2小时候重新请求时间线，再2小时之后，重新请求的时间线定义立即刷新组件，并指定之后不再请求新的时间线，组件刷新从此结束。 除了通过设置Timeline的Refresh机制让Widget请求时间线来进行刷新机制的定义外，宿主App也可以对Widget的刷新机制进行定义。宿主App可以使用WidgetCenter来触发指定Widget的刷新机制更新，如下： 1WidgetCenter.shared.reloadTimelines(ofKind: \"指定的widget的kind\") 同样，WidgetCenter目前也只能使用Swift来调用。 顺便提一下，关于WidgetCenter，其本身非常简单，提供的接口非常精简，如下： 123456789101112131415// 获取单例对象static let shared: WidgetCenter // 获取当前Widgets的用户自定义配置/*struct WidgetInfo &#123; public let configuration: INIntent? public let family: WidgetFamily public let kind: String&#125;*/func getCurrentConfigurations((Result&lt;[WidgetInfo], Error&gt;) -&gt; ())// 重新刷新某个Widget的时间线func reloadTimelines(ofKind: String)// 刷新所有Widget的时间线func reloadAllTimelines() 4. 可配置的Widget组件前面我们所介绍的构建小组件的方式，虽然可以通过时间线做部分更新逻辑，但对用户来说，依然是静态的。用户不能够根据自己的偏好对组件进行配置，还以天气类组件为例，有些用户可能关心的是空气质量，湿度等信息，有些用户可能只关心阴天雨天的信息，由于小组件的显示空间有限，有时候你无法将所有的信息都展示在组件内，因此让用户选择他感兴趣的信息进行小组件的配置非常重要。 首先，如果要让我们开发的Widget可以支持用户配置，需要在Widget的target工程中添加一个配置属性表文件，使用Xcode新建一个SiriKit Intent Definition File的文件，如下图所示： 之后，需要创建一个新的Intent配置，如下图所示： 之后，我们可以添加一系列的用户配置项，系统提供了各种类型的配置项，如让用户传入字符串信息的配置项，开关配置项，日期配置项等等，如下图： 之后，重新运行Widget，我们的小组件就以支持用户配置功能，用户可以编辑小组件进行设置，如下图所示： 当用户修改了配置项后，组件会重新请求Timeline时间线，在timeline回调方法中，会传入configuration对象，用来存储用户的配置信息，如下： 12345678910111213public func timeline(for configuration: ConfigurationIntent, with context: Context, completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()) &#123; // configuration中存放用户配置信息 var entries: [SimpleEntry] = [] let currentDate = Date() for hourOffset in 0 ..&lt; 5 &#123; let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)! let entry = SimpleEntry(date: entryDate, configuration: configuration) entries.append(entry) &#125; let timeline = Timeline(entries: entries, policy: .atEnd) completion(timeline)&#125; 上面演示的这种配置方式，适用于当配置项固定的场景，更多时候，可能连配置项都是动态的，比如我们的应用会根据服务端的状态来提供不同的服务，这时可提供给用户开启的服务项目就是动态的。Widget的配置项也支持动态进行配置，这需要使用到Intents Extension的相关功能，本篇博客就不再过多介绍。 结语：App Widgets本身并没有什么新意，只是扩大了iOS系统中组件的能力，这从一定程度上可以带给用户更好的服务和更多元的交互体验。脱离App Widgets这个功能的产品意义本身，iOS 14推出这个功能还有一点非常令人惊讶，就是App Widgets只能使用SwiftUI进行开发，这或许从另一个角度暗示了Swift在未来的推广力度，与iOS开发所使用语言的最终方向。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：805263726","categories":[{"name":"iOS14专题","slug":"iOS14专题","permalink":"http://huishao.cc/categories/iOS14专题/"}],"tags":[],"keywords":[{"name":"iOS14专题","slug":"iOS14专题","permalink":"http://huishao.cc/categories/iOS14专题/"}]},{"title":"iOS14新特性探索之一：App Clips轻应用","slug":"401iOS14新特性探索之一：App Clips轻应用","date":"2020-07-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.385Z","comments":true,"path":"2020/07/02/401iOS14新特性探索之一：App Clips轻应用/","link":"","permalink":"http://huishao.cc/2020/07/02/401iOS14新特性探索之一：App Clips轻应用/","excerpt":"","text":"iOS14新特性探索之一：App Clips轻应用 App Clips是苹果WWDC 2020所发布的iOS 14新特性中最具焦点的一项功能。一经曝光，就引发了互联网上针对其特性的各种讨论。有人说App Clips是苹果模仿微信推出的iOS平台的小程序；有人说它是轻量级的应用程序，为用户提供了简洁版的App体验；同样，对AppClips的评价也是众说纷纭，有人看好也有人看跌，有人觉得是新的平台也有人觉得非常鸡肋。 无论如何，AppClips都是Apple给iPhone用户提供了一种新的交互方式和新的应用使用体验，作为开发者，我们更需要做的是了解这样一种新的技术的应用，并将其赋能到我们的产品中，为用户提供更好的使用体验，为产品带来更大的价值。 本篇博客，也是基于这样的想法，将全面的介绍App Clips的应用与开发细节，帮助大家最快的了解与上手这样一种技术。我在编写本篇博客时，使用的依然是iOS14的bate版本，开发工具Xcode的版本也是12.0Bate版本，因此，不能保证后续Apple不会对App Clips的某些特性进行优化修改。如果你在之后很久的某个时间阅读到本篇博客，请有选择的借鉴与吸收。 1. 关于App Clips App Clips用中文如何翻译，一直没有找到合适的词汇。可以叫他应用切片，也可以叫它轻应用，更可以称它为小程序，这些称呼好像都合适又好像都插那么一点感觉，我们不如就叫它App Clips好了。 开发一个App Clips的目的是提供你的App中的部分功能让用户可以快速使用，并且不需要下载完整的App。这句话有两个非常重要的点，首先App Clip提供完整应用程序的一部分功能，这表明你一定要有一个完整功能的App，才可以开发上线App Clips，与iOS开发中其他的Extension类似，App Clip也可以理解为一种Extension，其必须由一个宿主App来承载。 一个App Clip也可以理解为是某个App的轻量级版本，用来提供一些完成瞬时的任务的功能，例如为一杯咖啡进行支付、使用店铺提供的优惠券、公共的信息查询等等。 App Clip的启动需要由一个调用方调起，在iOS开发中，更专业点的术语叫**_invocation_**，**_invocation_**可以是多种形态的，例如通过点击基于位置信息的推荐Banner，点击Sari的推荐或者通过扫描二维码或NFC等。App Clip被**_invocation_**调起后，用户可以通过它完成一件专注的任务，当用户不再需要使用它时，它会自动的被iPhone移除，这个过程对用户来说是无感知的，因此App Clip也不会占用用户的桌面空间。 2. 开发App Clip前的准备在开发App Clip前，你首先需要明确一个核心原则： _ App Clips技术一定要用在帮助用户方便启动并快速完成特定任务。_ 这个原则非常重要，它是App Clips被提供使用的初衷，如果你提供的App Clip非常庞大且操作复杂，那不仅无法丧失了App Clip具有的“快速”优势，而且也会让用户产生困扰，造成糟糕的用户体验。换句话说，App Clips应该是“随用随走”的，即在用户需要使用时快速启动，再用户使用完成后也立刻消失。 在开发过程中，开发一款App Clip与开发正常的iOS应用并没有特别大的差异，它与开发普通iOS应用有着相关的Framework支持，例如使用UIKit开发应用的界面。同样，App Clips也可以像完整App一样的使用设备的硬件（当然需要申请对应的权限），例如使用相机、蓝牙等等。还有一点需要注意，一个完整的App只能拥有一个App Clip，并且App Clip提供的功能在主App中也需要被完整的支持才行。 前面说过，App Clip的启动需要由**_invocation_**来触发，**_invocation_**包括如下5中场景： 通过NFC扫描来唤起 通过点击Sari提供的基于地理位置的推荐 在地图App上点击指定的链接 点击网页上的智能推荐横幅 通过Messages App分享的链接 唤起一个App Clip的过程如下图所示（来自Apple官方文档） 如上图，当某个invocation触发了App Clip时，系统首先会检查invocation关联的URL，通过URL获取用来展示预览信息的数据，预览信息包括一个背景图案，描述标题与启动按钮，用户点击启动按钮后会打开App Clip。我们可以在App Clip启动时拿到传递进来的URL，通过URL的参数进行不同的逻辑处理。 了解了App Clips的启动过程，我们知道实际上在启动App Clip之前，系统会先弹出一个预览卡片，这个卡片上的信息可以由开发者在iTunes Connect上自行定义。 在着手开发App Clips之前，还有一些事情我们需要考虑。 A. 提供畅快的用户体验App Clips不会像通常的App那样展示一个图标在主屏幕上，用户不需要对App Clips进行管理，不用下载也无需删除，当指定的App Clip一段时间不活跃后，系统会自动对它们进行清除。因此，官方建议，App Clips提供的功能应该是线性的，让用户一次性的完成任务。 B. App Clips需要足够小巧App Clips应该足够的小巧，官方限定不可超过10M大小，只有足够小，在用户需要使用的时候才能以更短的时间加载与展示。 C. 检查可用的框架在开发之前，首先要确认下App Clips可用的框架，大部分主App可用的框架在App Clips中都可以使用，但并不是所有，CallKit, CareKit, CloudKit, HealthKit, HomeKit, ResearchKit, SensorKit, 和 Speech在App Clips中是不被支持的。 D. 保护用户隐私由于App Clips会以推荐或其他广告的方式触发，因此保护用户的隐私非常重要。在App Clips中，隐私保护会一直被启用，例如对后台定位权限的申请，当用户同意后，次日的凌晨4点，这个权限会被重新关闭，如果再次启用了App Clips，需要重新向用户申请。当然，还有一些权限在App Clips中是禁止获取的，其中有：运动和健身数据，音乐和多媒体文件，通讯录/信息/照片等文件。除了其宿主App意外，App Clips也不可以和其他应用共享数据。 E. 思考主App的哪些功能是适合在App Clip提供的App Clips提供瞬时的应用体验，因此更多时候，在开发App Clips之前，你最先应该思考的是主App上的哪些功能是适合在App Clips上提供的。这需要从产品角度深度的思考，并真实的站在用户的角度体验。 3. 创建一个App Clip程序前面讲了很多开发App Clips前的准备，现在就让我们上手创建一个App Clip体验一下。创建App Clip非常简单，首先其需要一个宿主App，如果为已经存在的一个完全应用程序添加App Clip，就更加容易，我们只需要新建一个Target，选择App Clip即可，如下图所示： 新建了App Clip的Target后，Xcode会自动的帮我们创建好一系列必须的文件，并做好配置。这时，直接运行target对应的scheme即可在模拟器或真机上运行App Clip做测试，当前，如果你运行会出现一个空白的页面，这是因为我们还没有编写任何代码。 前面说过，App Clip的运行需要**_invocation_**进行调用，对于**_invocation_**的调用，如果用户安装了完全的主App，则会唤起主App来处理用户任务，如果用户没有安装主App，则自动调起App Clip。无论通过哪种**_invocation_**来调起App Clip，我们都需要在App Clip的target中配置指定的域权限。在target工程的设置页面，找到Associated Domains选项，在其中添加要调起App Clip的域名，需要找到这样的格式：appclips:xxx.com。这种配置方式与Deep link的逻辑基本一致。 下面，我们可以尝试向App Clip工程中添加一些代码。观察App Clip的工程目录结构，可以发现，其和正常的App几乎没有什么差异。如下图所示： 我们简单的在ViewController中添加一些代码，例如点击屏幕后，随机改变界面的颜色，如下： 123456789101112131415161718192021#import \"ViewController.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; [self changeColor];&#125;- (void)changeColor &#123; self.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];&#125;@end 在开发App Clips时，我们应该尽量的让主App的代码与App Clips需要使用的代码共享，共享代码非常容易，将可以共享的代码保证在静态库或动态库内即可。有时候，你可能需要在共享的代码中区分环境，比如某些代码只在target环境下被编译，某些则只在主App环境下被编译。可以为target添加一个特殊的编译宏来区分环境，Objective-C的工程，这个编译选项需要在Build Settings的Preprocessor Macros选项下进行配置，Swift的工程则需要在Active Compilation Conditions选项下进行配置，例如我们为target工程添加一个CLIP的编译宏，如下图所示： 之后，在编写代码时，对于针对target的代码，就可以将其通过条件编译区分： 12345- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;#ifdef CLIP self.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];#endif&#125; 对于发布App Clips的程序，还有一点需要注意，在系统弹出预览卡片之前，首先会先通过invocation关联的URL对App Clip进行校验，如果校验不成功，则不会弹出预览卡片也不会打开App Clip程序。要成功进行验证，除了在Xcode工程中配置正确的Associated Domains外，还需要对我们的Web服务做一些修改。需要在服务器添加Apple App Site Association文件，并且添加上类似如下的配置来支持App Clips： 123456&#123; \"appclips\": &#123; \"apps\": [\"ABCED12345.com.example.MyApp.Clip\"] &#125; ...&#125; 4. 测试App Clips的启动虽然App Clips的启动需要由**_invocation_**触发，但是在开发过程中，我们依然有方法来模拟Web发出的**_invocation_**来启动App Clip。编辑在App Clip对应的scheme，在其中添加 _XCAppClipURL这个键值来配置模拟从某个URL调起App Clips，如下图所示： 当App Clip被调起后，我们可以通过一些回调方法来拿到URL信息，根据不同的信息，可以将不同的功能线展示给用户进行使用。以UIKit工程为例，当App Clip被调起时，会调用如下方法： 123- (void)scene:(UIScene *)scene continueUserActivity:(NSUserActivity *)userActivity &#123; NSLog(@\"%@\", userActivity);&#125; 在UNUserAvtivity对象中可以获取到传递的URL等信息。如果你的App Clip是可以被特殊的地理位置触发的，那么需要在Clip对应target的info.plist中添加 NSAppClip键，并将其中的 NSAppClipRequestLocationConfirmation键设置为YES。 5. 配置预览卡片在真正的启动App Clip之前，首先会弹出预览卡片。在提交App Clip时，是跟宿主App一起打包上传到App Store Connect上的，App Clip的预览卡片配置也是在App Store Connect上完成，提供给开发者自由配置的地方并不多，包括3个方面： 配置一个头图 配置副标题并提供描述文案 配置交互按钮 6. 关于数据共享App Clips的和宿主App的数据共享并没有什么特殊的地方，其和普通Extension Target与宿主App通信的方式一样，只要创建一个App Group，并将App Clips与宿主App放入同一个App Group中，之后就可以通过NSUserDefault来进行数据的共享。","categories":[{"name":"iOS14专题","slug":"iOS14专题","permalink":"http://huishao.cc/categories/iOS14专题/"}],"tags":[],"keywords":[{"name":"iOS14专题","slug":"iOS14专题","permalink":"http://huishao.cc/categories/iOS14专题/"}]},{"title":"iOS录屏框架ReplayKit的应用总结","slug":"400iOS录屏框架ReplayKit的应用总结","date":"2020-05-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.385Z","comments":true,"path":"2020/05/12/400iOS录屏框架ReplayKit的应用总结/","link":"","permalink":"http://huishao.cc/2020/05/12/400iOS录屏框架ReplayKit的应用总结/","excerpt":"","text":"iOS录屏框架ReplayKit的应用总结ReplayKit是iOS自带的一个屏幕录制的框架，其支持应用程序对当前应用内页面进行录屏，并将最终的视频保存到系统相册中。ReplayKit在iOS 9之后引入，其接口简介，可以非常方便的为应用添加录屏功能。需要注意，在某些iOS 12系统上，开启录屏可能会失败(通常需要重启设备解决)。 在ReplayKit框架中，有两个非常重要的类，分别是RPScreenRecorder类与RPPreviewViewController类。RPScreenRecorder是录屏核心功能类，RPPreviewViewController是录屏结束后的预览控制器类。 下面，列举了一个简单的录屏示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@interface ViewController () &lt;RPScreenRecorderDelegate, RPPreviewViewControllerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; self.view.backgroundColor = [UIColor whiteColor]; [super viewDidLoad]; // 获取录屏功能是否可用 NSLog(@\"%d\", [RPScreenRecorder sharedRecorder].available); // 设置录屏代理 [RPScreenRecorder sharedRecorder].delegate = self; UIButton *btn = [UIButton buttonWithType:UIButtonTypeSystem]; [btn setTitle:@\"Start\" forState:UIControlStateNormal]; [btn addTarget:self action:@selector(start) forControlEvents:UIControlEventTouchUpInside]; btn.frame = CGRectMake(100, 100, 100, 30); [self.view addSubview:btn]; UIButton *btn2 = [UIButton buttonWithType:UIButtonTypeSystem]; [btn2 setTitle:@\"End\" forState:UIControlStateNormal]; [btn2 addTarget:self action:@selector(stop) forControlEvents:UIControlEventTouchUpInside]; btn2.frame = CGRectMake(100, 150, 100, 30); [self.view addSubview:btn2];&#125;- (void)stop &#123; // 结束录屏 [[RPScreenRecorder sharedRecorder] stopRecordingWithHandler:^(RPPreviewViewController * _Nullable previewViewController, NSError * _Nullable error) &#123; NSLog(@\"stopRecordingWithHandler\"); if (!error) &#123; previewViewController.previewControllerDelegate = self; // 到视频预览控制器 [self presentViewController:previewViewController animated:YES completion:nil]; &#125; &#125;];&#125;// 开始录屏- (void)start &#123; [[RPScreenRecorder sharedRecorder] startRecordingWithHandler:^(NSError * _Nullable error) &#123; NSLog(@\"startRecordingWithHandlerError:%@\", error); &#125;];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; self.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1];&#125;// 录屏结束的回调- (void)screenRecorder:(RPScreenRecorder *)screenRecorder didStopRecordingWithPreviewViewController:(nullable RPPreviewViewController *)previewViewController error:(nullable NSError *)error &#123; NSLog(@\"didStopRecordingWithPreviewViewControllerError:%@\", error);&#125;// 录屏可用性改变的回调- (void)screenRecorderDidChangeAvailability:(RPScreenRecorder *)screenRecorder &#123; NSLog(@\"screenRecorderDidChangeAvailability:%d\", screenRecorder.available);&#125;// 录屏预览控制器的代理回调- (void)previewControllerDidFinish:(RPPreviewViewController *)previewController &#123; [previewController dismissViewControllerAnimated:YES completion:nil];&#125;- (void)previewController:(RPPreviewViewController *)previewController didFinishWithActivityTypes:(NSSet &lt;NSString *&gt; *)activityTypes &#123; NSLog(@\"didFinishWithActivityTypes %@\", activityTypes);&#125;@end 其中，RPScreenRecorder类中提供了丰富的接口可以使用，列举如下： 123456789101112131415161718192021222324252627282930@interface RPScreenRecorder : NSObject// 获取单例+ (RPScreenRecorder *)sharedRecorder;// iOS 10 之前使用，可以通知是否开启麦克风- (void)startRecordingWithMicrophoneEnabled:(BOOL)microphoneEnabled handler:(nullable void(^)(NSError * _Nullable error))handler;// iOS 10 之后使用 开启录屏- (void)startRecordingWithHandler:(nullable void(^)(NSError * _Nullable error))handler;// 结束录屏- (void)stopRecordingWithHandler:(nullable void(^)(RPPreviewViewController * _Nullable previewViewController, NSError * _Nullable error))handler;// 放弃录屏- (void)discardRecordingWithHandler:(void(^)(void))handler;// 开启录屏，可以获取到视频流数据 iOS 11后可用- (void)startCaptureWithHandler:(nullable void(^)(CMSampleBufferRef sampleBuffer, RPSampleBufferType bufferType, NSError * _Nullable error))captureHandler completionHandler:(nullable void(^)(NSError * _Nullable error))completionHandler;// 结束视频流捕获- (void)stopCaptureWithHandler:(nullable void(^)(NSError * _Nullable error))handler;// 设置代理对象@property (nonatomic, weak, nullable) id&lt;RPScreenRecorderDelegate&gt; delegate;// 录屏功能是否可用@property (nonatomic, readonly, getter=isAvailable) BOOL available;// 是否正在录制中@property (nonatomic, readonly, getter=isRecording) BOOL recording;// 是否使用麦克风@property (nonatomic, getter=isMicrophoneEnabled) BOOL microphoneEnabled;// 是否可以使用相机@property (nonatomic, getter=isCameraEnabled) BOOL cameraEnabled;// 设置摄像头模式 前置/后置@property (nonatomic) RPCameraPosition cameraPosition;// 相机预览视图@property (nonatomic, readonly, nullable) UIView *cameraPreviewView;@end 在录屏的时候，也支持调用系统的麦克风和摄像头共同完成录制。RPScreenRecorderDelegate协议中定义了一些回调方法，如下： 123456// 停止录屏后的回调 iOS 10 之前使用- (void)screenRecorder:(RPScreenRecorder *)screenRecorder didStopRecordingWithError:(NSError *)error previewViewController:(nullable RPPreviewViewController *)previewViewController;// 停止录屏后的回调 iOS 10 之后使用- (void)screenRecorder:(RPScreenRecorder *)screenRecorder didStopRecordingWithPreviewViewController:(nullable RPPreviewViewController *)previewViewController error:(nullable NSError *)error;// 录屏权限更改的回调- (void)screenRecorderDidChangeAvailability:(RPScreenRecorder *)screenRecorder; RPPreviewViewController类是视频预览控制器类，这个控制器没有暴露太多的属性给开发者使用，其中预览模式可以选择分享模式或编辑模式，除此之外，其中还提供了一个代理协议给开发者进行使用，用来对用户的操作进行处理，如下： 1234567@protocol RPPreviewViewControllerDelegate &lt;NSObject&gt;@optional// 预览结束- (void)previewControllerDidFinish:(RPPreviewViewController *)previewController;// 用户行为回调- (void)previewController:(RPPreviewViewController *)previewController didFinishWithActivityTypes:(NSSet &lt;NSString *&gt; *)activityTypes;@end","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"使用Python编写iOS原生应用的框架设计思考(首篇)","slug":"399使用Python编写iOS原生应用的框架设计思考(首篇)","date":"2020-04-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.384Z","comments":true,"path":"2020/04/30/399使用Python编写iOS原生应用的框架设计思考(首篇)/","link":"","permalink":"http://huishao.cc/2020/04/30/399使用Python编写iOS原生应用的框架设计思考(首篇)/","excerpt":"","text":"使用Python编写iOS原生应用的框架设计思考(首篇)一、引子使用Python编写iOS原生应用，为何有这样的想法，其实本来是源于对JS类的跨平台框架的学习。熟悉原生开发的同学们都知道，对于可跨平台的原生框架，使用JS实现的占了大半，其原因是由于Apple内置了JavaScriptCore这样一个JS引擎，使得JavaScript与Objective-C的交互变得非常容易，能够交互，我们就可以容易的编写出各种各样的桥来为JS端提供原生功能，随着原生端桥的全面支持和JS端组件的丰富，一个完整的矿平台框架就诞生了。虽说这是一个庞大的工程，但是实现思路并不深奥，之前也有博客也有介绍： https://my.oschina.net/u/2340880/blog/856321 有了JavaScript框架实现思路的基础，那么不免就很容易想到，其实在语言层面，语言可以做的事情都是相似的，只要有对应的引擎可用，那么原则上说，任何语言都可以编写iOS应用程序，只有难以与方便与否的差别。对于Python来说，其的确有iOS版本的解释器可用。 二、在iOS平台使用Python解释器Github上有很多有趣的项目，其中有一个项目可以将Python源码编译成可以在iOS平台运行的Framework，其地址如下： https://github.com/beeware/Python-Apple-support 有了这个工具，我们可以选择任意版本的Python来将其打包成Framework在iOS平台运行，当然如果你对版本没有特殊的要求，你也可以直接从下面的地址下载已经打包好的Framewok使用： https://github.com/pybee/Python-iOS-support/releases 下载完成后，会得到两个Framework，将他们添加进工程，并进行链接，如下图： 需要注意，对于Python.framework要更特殊一点，我们需要将其拷贝进工程的Bundle中，以便后续使用。 三、编写桥接文件这部分主要有Objective-C实现，用来启动Python引擎，加载Python业务代码的入口文件，做各种原生组件与Python组件的桥接等。首先编写一个头文件用来进行静态变量和宏的定义，如下： 123456789101112131415161718192021222324252627282930//// BrdgeDefine.h// PyNativeDemo//// Created by 珲少 on 2020/4/30.// Copyright © 2020 jaki. All rights reserved.//#ifndef BrdgeDefine_h#define BrdgeDefine_h#import &lt;Python/Python.h&gt;#define INTERFACE_INSTANCE + (instancetype)sharedInstance;#define IMPLEMENTATION_INSTANCE \\+ (instancetype)sharedInstance &#123; \\ static id instance = nil; \\ static dispatch_once_t onceToken; \\ dispatch_once(&amp;onceToken, ^&#123; \\ if (!instance) &#123; \\ instance = [[self alloc] init]; \\ &#125; \\ &#125;); \\ return instance; \\&#125;#define SELF_INSTANCE [self.class sharedInstance]#endif /* BrdgeDefine_h */ 编写Python桥的引擎类，如下： BridgeEnigine.h: 1234567891011121314#import &lt;Foundation/Foundation.h&gt;#import \"BrdgeDefine.h\"#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface BridgeEngine : NSObjectINTERFACE_INSTANCE+ (UIViewController *)setupEngine;@endNS_ASSUME_NONNULL_END BridgeEnigine.m: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#import \"BridgeEngine.h\"#import \"DisplayRender.h\"#import \"PythonRun.h\"@interface BridgeEngine ()@end@implementation BridgeEngineIMPLEMENTATION_INSTANCE+ (UIViewController *)setupEngine &#123; [SELF_INSTANCE startEngine]; [SELF_INSTANCE loadLib]; [SELF_INSTANCE runMain]; return [SELF_INSTANCE renderRoot];&#125;- (void)startEngine &#123; NSString* frameworkPath = [NSString stringWithFormat:@\"%@/Resources\",[SELF_INSTANCE p_pythonFrameworkPath]]; wchar_t *pythonHome = [SELF_INSTANCE stingTowWchar_t:frameworkPath]; Py_SetPythonHome(pythonHome); Py_Initialize(); PyEval_InitThreads(); if (Py_IsInitialized()) &#123; NSLog(@\"😄初始化环境成功😄\"); &#125; else &#123; NSLog(@\"😢Python初始化环境失败😢\"); exit(0); &#125;&#125;- (void)loadLib &#123; NSString *path = [NSString stringWithFormat:@\"import sys\\nsys.path.append(\\\"%@\\\")\",[[NSBundle mainBundle] resourcePath]]; PyRun_SimpleString([path UTF8String]); NSLog(@\"😄lib加载成功😄\");&#125;- (void)runMain &#123; PyObject * pModule = PyImport_ImportModule([@\"main\" UTF8String]);//导入模块 [PythonRun sharedInstance].mainItemDic = PyModule_GetDict(pModule);&#125;- (UIViewController *)renderRoot &#123; return [[DisplayRender sharedInstance] renderRoot:@\"Main\"];&#125;- (wchar_t *)stingTowWchar_t:(NSString*)string &#123; return (wchar_t*)[string cStringUsingEncoding:NSUTF32StringEncoding];&#125;- (NSString*)p_pythonFrameworkPath&#123; NSString* path = [[NSBundle mainBundle] pathForResource:@\"Python\" ofType:@\"framework\"]; return path;&#125;- (void)dealloc &#123; Py_Finalize();&#125;@end 其中有使用到DisplayRender，由于Python没有办法主动调用原生，初步设想，让这个类通过帧刷新来负责对界面的渲染维护，编码如下： DisplayRender.h: 123456789101112131415#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;#import \"BrdgeDefine.h\"NS_ASSUME_NONNULL_BEGIN@interface DisplayRender : NSObjectINTERFACE_INSTANCE- (UIViewController *)renderRoot:(NSString *)main;@endNS_ASSUME_NONNULL_END DisplayRender.m: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import \"DisplayRender.h\"#import \"PythonRun.h\"#import \"BridgeColor.h\"#import \"ViewMaker.h\"@interface DisplayRender ()@property (nonatomic, strong) UIViewController *rootController;@property (nonatomic, strong) NSMutableArray&lt;UIView *&gt; *subViews;@end@implementation DisplayRenderIMPLEMENTATION_INSTANCE- (UIViewController *)renderRoot:(NSString *)main &#123; NSDictionary *root = [[PythonRun sharedInstance] run:[main UTF8String] method:[@\"render_main_view\" UTF8String]]; NSLog(@\"AppLaunchFinish🙅‍♀️\"); [self renderController:root]; return self.rootController;&#125;- (void)renderController:(NSDictionary *)info &#123; [self.subViews enumerateObjectsUsingBlock:^(UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [obj removeFromSuperview]; &#125;]; [self.subViews removeAllObjects]; NSString *bg = [info objectForKey:@\"color\"]; self.rootController.view.backgroundColor = [BridgeColor colorWith:bg]; NSArray *views = [info objectForKey:@\"subViews\"]; for (NSUInteger i = 0; i &lt; views.count; i++) &#123; id view = [ViewMaker makerView:[views[i] objectForKey:@\"name\"]]; for (NSString *key in [views[i] allKeys]) &#123; if (![key isEqualToString:@\"name\"]) &#123; [view setValue:[views[i] objectForKey:key] forKey:key]; &#125; &#125; [self.subViews addObject:view]; [self.rootController.view addSubview:view]; &#125;&#125;- (UIViewController *)rootController &#123; if (!_rootController) &#123; _rootController = [[UIViewController alloc] init]; &#125; return _rootController;&#125;@end PythonRun是一个工具类，起来调用Python解释器对Python代码进行执行，并通过数据与原生端进行交互，编码如下： PythonRun.h: 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import \"BrdgeDefine.h\"NS_ASSUME_NONNULL_BEGIN@interface PythonRun : NSObjectINTERFACE_INSTANCE@property (nonatomic, assign) PyObject *mainItemDic;- (NSDictionary *)run:(const char *)item method:(const char *)method;@endNS_ASSUME_NONNULL_END PythonRun.m: 123456789101112131415161718192021222324252627282930313233343536373839#import \"PythonRun.h\"@implementation PythonRunIMPLEMENTATION_INSTANCE- (NSDictionary *)run:(const char *)item method:(const char *)method &#123; PyObject* pClassCalc = PyDict_GetItemString(self.mainItemDic,item); PyObject* pInstanceCalc = PyInstanceMethod_New(pClassCalc); PyObject* pRet = PyObject_CallMethod(pClassCalc, method, \"O\", pInstanceCalc); return [self dumpInfo:pRet];&#125;- (NSDictionary *)dumpInfo:(PyObject *)pRet &#123; // 解析数据 char * resultCString = NULL; PyArg_Parse(pRet, \"s\", &amp;resultCString); //将python类型的返回值转换为c return [self dumpString:resultCString];&#125;- (NSDictionary *)dumpString:(const char *)resultCString &#123; NSString *jsonString = [NSString stringWithCString:resultCString encoding:NSUTF8StringEncoding]; NSDictionary *info = [NSJSONSerialization JSONObjectWithData:[jsonString dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingMutableContainers error:nil]; NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithDictionary:info]; for (NSString *k in dic.allKeys) &#123; if ([k isEqualToString:@\"subViews\"]) &#123; NSMutableArray *array = [NSMutableArray array]; for (NSUInteger i = 0; i &lt; [dic[k] count]; i++) &#123; [array addObject:[self dumpString:[dic[k][i] UTF8String]]]; &#125; dic[k] = [array copy]; &#125; &#125; NSLog(@\"dumpInfo❄️:%@\", dic); return [dic copy];&#125;@end 通过上面3个核心类，一个简易的Python引擎就完整了，下面还需要编写几个转换类，用来将Python对象转换成Objective-C的对象，编写BridgeColor类如下： BridgeColor.h: 123456789101112#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface BridgeColor : NSObject+ (UIColor *)colorWith:(NSString *)c;@endNS_ASSUME_NONNULL_END BridgeColor.m: 1234567891011121314151617#import \"BridgeColor.h\"@implementation BridgeColor+ (UIColor *)colorWith:(NSString *)c &#123; if ([c isEqualToString:@\"red\"]) &#123; return [UIColor redColor]; &#125; else if ([c isEqualToString:@\"white\"]) &#123; return [UIColor whiteColor]; &#125; else if ([c isEqualToString:@\"purple\"]) &#123; return [UIColor purpleColor]; &#125; return [UIColor clearColor];&#125;@end BridgeLabel.h: 12345678910111213141516171819#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface BridgeLabel : UILabel@property (nonatomic, strong) NSNumber *left;@property (nonatomic, strong) NSNumber *top;@property (nonatomic, strong) NSNumber *width;@property (nonatomic, strong) NSNumber *height;@property (nonatomic, strong) NSNumber *font_size;@property (nonatomic, copy) NSString *background_color;@property (nonatomic, copy) NSString *t;@property (nonatomic, copy) NSString *color;@endNS_ASSUME_NONNULL_END BridgeLabel.m: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import \"BridgeLabel.h\"#import \"BridgeColor.h\"@implementation BridgeLabel- (void)setLeft:(NSNumber *)left &#123; _left = left; self.frame = CGRectMake(left.floatValue, self.frame.origin.y, self.frame.size.width, self.frame.size.height);&#125;- (void)setTop:(NSNumber *)top &#123; _top = top; self.frame = CGRectMake(self.frame.origin.x, top.floatValue, self.frame.size.width, self.frame.size.height);&#125;- (void)setWidth:(NSNumber *)width &#123; _width = width; self.frame = CGRectMake(self.frame.origin.x, self.frame.origin.y, width.floatValue, self.frame.size.height);&#125;- (void)setHeight:(NSNumber *)height &#123; _height = height; self.frame = CGRectMake(self.frame.origin.x, self.frame.origin.y, self.frame.size.width, height.floatValue);&#125;- (void)setColor:(NSString *)color &#123; _color = color; self.textColor = [BridgeColor colorWith:color];&#125;- (void)setT:(NSString *)t &#123; _t = t; self.text = t;&#125;- (void)setFont_size:(NSNumber *)font_size &#123; _font_size = font_size; self.font = [UIFont systemFontOfSize:font_size.intValue];&#125;- (void)setBackground_color:(NSString *)background_color &#123; _background_color = background_color; self.backgroundColor = [BridgeColor colorWith:background_color];&#125;@end ViewMaker.h: 1234567891011#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ViewMaker : NSObject+ (id)makerView:(NSString *)name;@endNS_ASSUME_NONNULL_END ViewMaker.m: 12345678910111213#import \"ViewMaker.h\"#import \"BridgeLabel.h\"@implementation ViewMaker+ (id)makerView:(NSString *)name &#123; if ([name isEqualToString:@\"Label\"]) &#123; return [[BridgeLabel alloc] init]; &#125; return nil;&#125;@end 四、编写Python业务代码在项目中添加两个Python文件，一个命名为main.py作为应用程序的入口文件，一个命名为label.py作为标签组件，main.py文件编写代码如下： 1234567891011121314151617181920212223242526272829import jsonfrom label import *class Main(): def application_Launch(self): pass def render_main_view(self): l = Label(\"HelloWorld\") l.color = \"red\" l.font_size = 21 l.background_color = \"white\" l.left = 100 l.top = 100 l.width = 200 l.height = 30 l2 = Label(\"hhahha\") l2.color = \"red\" l2.font_size = 21 l2.background_color = \"white\" l2.left = 100 l2.top = 300 l2.width = 200 l2.height = 30 return json.dumps(&#123; \"color\": \"purple\", \"subViews\": [l.render(), l2.render()] &#125;) label.py编写代码如下： 12345678910111213141516171819202122232425import jsonclass Label: def __init__(self, text): self.t = text self.color = \"\" self.left = 0 self.top = 0 self.width = 0 self.height = 0 self.font_size = 0 self.background_color = \"\" def render(self): return json.dumps(&#123; \"name\": \"Label\", \"t\": self.t, \"color\": self.color, \"left\": self.left, \"top\": self.top, \"width\": self.width, \"height\": self.height, \"font_size\": self.font_size, \"background_color\": self.background_color &#125;) 到此，一个简易的Python iOS应用Demo工程就搭建完成了，上面代码创建了两个文本标签在页面上，并对组件的部分属性进行了配置，上面实现的每个类都非常简单，作为思路的演示，后续有时间会继续补充完善，并通过博客进行连载介绍，上面工程的运行效果如下图： 五、后续设想 通过DisplayLink来进行页面的变更刷新，为组件增加ID，设计一种算法来实现高效的页面刷新。 将组件的功能完善，添加更多原生组件的支持。 将事件进行包装，定义回调函数，让Python端有用处理事件的能力。 增加更多工具接口，如网络，数据文件操作等。 本篇博客内容比较缩略，你可以在如下地址找到完整的Demo工程： https://github.com/ZYHshao/PyNativeDemo/tree/master/PyNativeDemo 需要注意，工程较大，原因是我将Python库也放了进去，这样可以保证你下载的代码是可运行的。","categories":[{"name":"万言归宗","slug":"万言归宗","permalink":"http://huishao.cc/categories/万言归宗/"}],"tags":[],"keywords":[{"name":"万言归宗","slug":"万言归宗","permalink":"http://huishao.cc/categories/万言归宗/"}]},{"title":"属性“__attribute__”在Objective-C中的应用","slug":"398属性“__attribute__”在Objective-C中的应用","date":"2020-04-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.384Z","comments":true,"path":"2020/04/27/398属性“__attribute__”在Objective-C中的应用/","link":"","permalink":"http://huishao.cc/2020/04/27/398属性“__attribute__”在Objective-C中的应用/","excerpt":"","text":"属性“__attribute__”在Objective-C中的应用关于\\_\\_attribute\\_\\_，你可能用的不多，但是一定经常见到，在系统的Foundation框架中，\\_\\_attribute\\_\\_的使用非常频繁。首先，\\_\\_attribute\\_\\_用于在函数，变量或类型声明时进行特殊属性设置的编译器指令。需要注意，它是一种编译器指令，这也就表明了使用它我们可以做更高级的检查与优化功能。 __attribute__根据其修饰的场景不同可以分为3种类型，分别为函数属性，变量属性和类型属性。__attribute__的使用格式如下： 1__attribute__((属性列表)) 下面，我们来介绍几种常用的__attribute__属性。 1.formatformat用来对格式化字符串的参数使用情况进行检查，例如在使用NSLog函数进行输出时，如果我们传入的可变参数没有在格式化字符串中使用，编译器会提示警告，如下： 其实这个提示警告的功能就是借助__attribute__的format属性实现的，例如我们自定义一个LOG方法使其拥有相同的功能，如下： 1void MyLog(NSString *format, ...) __attribute__((format(__NSString__, 1, 2))); format属性有3个参数可以设置，其中第一个参数指定要检查的格式化风格，这里设置为NSString的格式化风格，第2个参数为格式化字符串参数的位置，从1开始，第3个参数为对应的格式化可变参数的位置。 2.deprecateddeprecated可以指定被修饰的函数在编译时产生警告，表示这个函数已经过期，提示开发者谨慎使用，例如： deprecated属性也可以添加一个参数来指定要输出的警告信息，例如： 3. availability这个属性用来指定接口的可用版本，例如指定可用的平台，接口引入的版本，废弃的版本，不可用的版本以及提示信息等，示例如下： 其中，第1个参数指定API可用的平台，可选则为macos或ios，introduced参数设置API引入的系统版本，deprecated参数设置API废弃的版本，obsoleted参数用来设置API不可使用的版本。与availability属性相似，还有一个unavailabel属性可用，这个属性直接将某个API标记为不可用，例如： 4. nonnullnonnull属性用来指定某些指针参数不能为空，其内可以传入一组下标(从1开始)，被下标指定的参数不可为空，例如： 5. constconst属性是一种编译优化功能，其可以将某个函数指定为const类型的，这时会将函数的返回值当做const变量来使用，这时如果没有使用到返回值，则函数本身会被优化，避免执行造成额外的性能消耗，例如： 5. cleanupcleanup属性可以实现一个非常强大的功能，它有这样的一种特点，可以为某个变量指定一个清理函数，当变量离开其作用域的时候，会调用这个清理函数，示例如下： 123456789101112void clean(int *p) &#123; NSLog(@\"变量%d被清理\", *p);&#125;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int a __attribute__((cleanup(clean))) = 10; a = 20; &#125; // 离开作用域后 将打印 变量20被清理 return 0;&#125; 需要注意，指定的清理函数会将当前变量的指针作为参数传入。 6. constructor与destructorconstructor属性可以指定函数在main函数执行之前进行调用，与之对应destructor可以指定某个函数在main函数执行结束之后再执行。这是一种非常强大的机制，在实际应用中也非常频繁，例如对以一个拥有模块化和路由功能的应用程序，可以通过这种方式来自动化的进行路由注册(无需手动调用)，需要注意，constructor与destructor属性都可以设置一个优先级参数，优先级高的函数会先执行(0-100的优先级为系统保留)，示例如下： 12345678910111213141516171819202122232425262728293031void __attribute__((constructor(101))) func1() &#123; NSLog(@\"Func1\");&#125;void __attribute__((constructor(102))) func2() &#123; NSLog(@\"Func2\");&#125;void __attribute__((destructor(101))) func3() &#123; NSLog(@\"Func3\");&#125;void __attribute__((destructor(102))) func4() &#123; NSLog(@\"Func4\");&#125;// 会依次打印/* 2020-04-27 16:05:57.270522+0800 TestDemo[33430:13458931] Func1 2020-04-27 16:05:57.271017+0800 TestDemo[33430:13458931] Func2 2020-04-27 16:05:57.271193+0800 TestDemo[33430:13458931] main函数执行 2020-04-27 16:05:57.271273+0800 TestDemo[33430:13458931] Func4 2020-04-27 16:05:57.271316+0800 TestDemo[33430:13458931] Func3 */int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@\"main函数执行\"); &#125; return 0;&#125; 7. objc_subclassing_restricted这是Objective-C中常用的一个属性，有时候，我们定义了一个类，但是不希望再有其他的类继承于它，即我们要定义的类本身就是一个最终类，不能再被继承，这是就可以使用这个属性来修饰，如果有类继承它会报编译错误，例如： 8. objc_requires_super这个属性用来修饰Objective-C中父类的方法，如果子类进行了重写，在重写的方法中没有调用父类方法，则会进行编译器提示。在实际编程中，很多时候，都是由于子类重写了父类的方法造成不可预知的问题，通过使用这个属性可以有效的对开发者进行提示，例如： 9. enable_ifenable_if提供了一种方式对函数的参数进行校验，不满足校验规则的参数传递将在编译时报错，使得函数的使用更加安全，例如： 这种编译时即可对函数参数进行检查的机制可以避免写很多运行时的代码，并且比运行时更高效的规避错误。 10. overloadable在C语言中，对于相同的函数名，哪怕参数不同，也不能够重复定义。overliadable属性可以指定某个函数为可重载，这样既可定义名字相关参数不同的多个C函数，在调用时，编译器会根据传入的参数类型自行判断具体调用哪个函数，如下： 11. objc_runtime_name这是一个很有趣的属性，其可以运行时改变Objective-C类的类名，但是不会影响其行为。这个属性通常可以用来做代码混淆加密，例如： 1234567891011121314151617181920212223__attribute__((objc_runtime_name(\"Some\")))@interface MyObject : NSObject- (void)myObject:(int)param;@end@implementation MyObject- (void)myObject:(int)param &#123; NSLog(@\"myObject\");&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyObject *object = [[MyObject alloc] init]; [object myObject:1]; NSLog(@\"%@\", [object class]); // Some &#125; return 0;&#125; 上面的代码可以很好的运行，但是在打印其类型时却会打印出一个莫名其妙的Some，需要注意，这个属性要谨慎使用，其有时候也会非常危险，例如代码中有做这样的逻辑就会产生未知的异常，并且很难定位： 1[[object className] isEqualToString:@\"MyObject\"] 除了上面介绍的11中常用的属性外，可用的属性还有很多，例如对内存的分配进行管理的属性，对初始化方法进行修饰的属性等，如果有兴趣，可以参考如下文档： https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：805263726","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"玩转iOS“宏定义”","slug":"397玩转iOS“宏定义”","date":"2020-04-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.384Z","comments":true,"path":"2020/04/22/397玩转iOS“宏定义”/","link":"","permalink":"http://huishao.cc/2020/04/22/397玩转iOS“宏定义”/","excerpt":"","text":"玩转iOS“宏定义”宏定义在C类语言中非常重要，因为宏是一种预编译时的功能，因此其可以比运行时更高层面的对程序流程进行控制。在初学宏定义的时候，大家可能都会有这样一种感觉：就是完全替换么，太简单了。但如果你真这么想，那你就太天真了，不说自己编写宏，在Foundation框架中内置定义的许多宏要看明白也要费一番脑筋。本篇博客，总结了前辈的经验，同时收集了一些编写非常巧妙的宏进行分析，希望可以帮助大家对宏定义有更加深刻的理解，并且可以将心得应用于实际开发中。 一、准备宏的本质是预编译时的替换，在开始正文之前，我们需要先介绍一种观察宏替换后结果的方法，这样帮助我们更方便的对宏最终的结果进行验证与测试。Xcode开发工具自带查看预编译结果的功能，首先需要对工程编译一遍，之后选择工具栏中的Assistant选项，打开助手窗口，如下图所示： 之后选择窗口的Preprocess选项，即可打开预编译结果窗口，可以看到，宏被替换后的最终结果，如下图所示： 后面，我们将使用这种方式来对编写的宏进行验证。 二、关于“宏定义”宏使用#define来进行定义，宏定义分为两种，一种是对象式宏，一种是函数式宏。对象式宏通常对来定义量值，在预编译时，直接将宏名替换成对应的量值，函数式宏在定义时可以设置参数，其作用与函数很类似。 例如，我们可以将π的值定义成一个对象式宏，在使用的时候，用有意义的宏名要比直接使用π的字面值方便很多，例如： 12345678910#import &lt;Foundation/Foundation.h&gt;#define PI 3.1415926int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... CGFloat res = PI * 3; NSLog(@\"%f\", res); &#125; return 0;&#125; 函数式宏要更加灵活一些，例如对圆面积计算的方法，我们就可以将其定义成一个宏： 12345678910#define PI 3.1415926#define CircleArea(r) PI * r * rint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... CGFloat res = CircleArea(1); NSLog(@\"%f\", res); &#125; return 0;&#125; 现在，有了这个面积计算宏我们可以更加方便的计算圆的面积了，看上去很完美，后面我们就使用这个函数式宏为例，来深入理解宏的原理。 三、从一个简单的函数式宏说起再来看下上面我们编写的计算面积的宏，正常情况下好像没什么问题，但是需要注意，归根结底宏并不是函数，如果完全把其作为函数使用，我们就可能会陷入一系列的陷阱中，比如这样使用： 12345678910#define PI 3.1415926#define CircleArea(r) PI * r * rint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... CGFloat res = CircleArea(1 + 1); NSLog(@\"%f\", res); &#125; return 0;&#125; 运行代码，运算的结果并不是半径为2个圆的面积，哪里出了问题呢，我们还是先看下宏预编译后的结果： 1CGFloat res = 3.1415926 * 1 + 1 * 1 + 1; 一目了然了，由于运算符的优先级问题导致了运算顺序错误，在编程中，所有运算符优先级产生的问题都可以使用一种方式解决：用小括号。对CircleArea宏进行一下改造，如下： 1#define CircleArea(r) (PI * (r) * (r)) 对执行顺序进行了强制的控制，代码执行又恢复了正常，看上去好像是没有问题了，现在就满意了还为时过早，例如下面这样使用这个宏： 123456789101112#import &lt;Foundation/Foundation.h&gt;#define PI 3.1415926#define CircleArea(r) PI * (r) * (r)int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... int r = 1; CGFloat res = CircleArea(r++); NSLog(@\"%f, %d\", res, r); &#125; return 0;&#125; 运行，发现结果又错了，不仅计算结果与我们的预期不符，变量自加的的结果也不对了，我们检查其展开的结果： 1CGFloat res = 3.1415926 * (r++) * (r++); 原来问题出在这里，宏在展开的时候，将参数替换了两次，由于参数本身是一个自加表达式，所以被自加了两次，产生了问题，那么这个问题怎么解决呢，C语言中有一种很有用的语法，即使用大括号定义代码块，代码块会将最后一条语句的执行结果返回，修改上面宏定义如下： 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#define PI 3.1415926#define CircleArea(r) \\(&#123; \\ typeof(r) _r = r; \\ (PI * (_r) * (_r)); \\&#125;)int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int r = 1; CGFloat res = CircleArea(r++); NSLog(@\"%f, %d\", res, r); &#125; return 0;&#125; 这次程序又恢复的了正常。但是，如果如果在调用宏是变量的名字与宏内的临时变量产生了重名，灾难就又发生了，例如： 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#define PI 3.1415926#define CircleArea(r) \\(&#123; \\ typeof(r) _r = r; \\ (PI * (_r) * (_r)); \\&#125;)int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int _r = 1; CGFloat res = CircleArea(_r); NSLog(@\"%f, %d\", res, _r); &#125; return 0;&#125; 运行上面代码，会发现宏内的临时变量没有被初始化成功。这确实难受，我们在进一步，比如对临时变量的名字做一些手脚，将其命名为极其不容易重复的名字，其实系统内置的一个宏就是专门用来构造唯一性变量名的：__COUNTER__，这个宏是一个计数器，在编译的时候会自动进行累加，再次对我们编写的宏进行改造，如下： 123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;#define PI 3.1415926#define PAST(A, B) A##B#define CircleArea(r) __CircleArea(r, __COUNTER__)#define __CircleArea(r, v) \\(&#123; \\ typeof(r) PAST(_r, v) = r; \\ (PI * PAST(_r, v) * PAST(_r, v)); \\&#125;)int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int _r = 1; CGFloat res = CircleArea(_r); CGFloat res2 = CircleArea(_r); NSLog(@\"%f, %f\", res, res2); &#125; return 0;&#125; 这里改造后，我们的宏就没有那么容易理解了，首先__COUNTER__在每次宏替换时都会进行自增，##是一种宏中专用的特殊符号，用来将参数拼接到一起，但是需要注意，使用##符号拼接的如果是另外一个宏，则其会阻止宏的展开，因此我们定义了一个转换宏PAST(A, B)来处理拼接。如果你一下子不能理解为什么这样就可以解决宏展开的问题，你只需要记住这样一条宏展开的原则：如果形参有使用#或##这种处理符号，则不会进行宏参数的展开，否则先展开宏参数，在展开当前宏。上面代码最终预编译的结果如下： 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int _r = 1; CGFloat res = (&#123; typeof(_r) _r0 = _r; (3.1415926 * _r0 * _r0); &#125;); CGFloat res2 = (&#123; typeof(_r) _r1 = _r; (3.1415926 * _r1 * _r1); &#125;); NSLog(@\"%f, %f\", res, res2); &#125; return 0;&#125; 一个简单的计算圆面积的宏，为了安全，我们就进行了这么多的处理，看来要用好宏，的确不容易。 四、编写宏时的好习惯通过前面的介绍，我们知道，如果随随意意的编写一个宏是非常不负责任的，看上去好像没问题与在任何场景下使用都没有问题是完全不同的。在编写宏时，我们可以刻意的去培养这样几个编码习惯： 参数与计算结果要加小括号 这条原则应该不必多说了，前面的示例中就有演示，完整的添加小括号可以避免很多由于运算符优先级造成的异常问题。 多语句功能性宏，要使用do-while包裹 这条原则看上去有些莫名其妙，但是其非常重要，例如，我们需要编写一个自定义的LOG宏，在进行打印时添加一些自定义的信息，你或许会这样写： 12345678910#define LOG(string) \\NSLog(@\"自定义的信息\"); \\NSLog(string);int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; LOG(@\"info\") &#125; return 0;&#125; 运行代码，目前貌似没有问题，但是如果其和if语句进行结合，可能问题就来了： 1234567int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; if (NO) LOG(@\"info\") &#125; return 0;&#125; 运行代码，还是有一行LOG信息被输出了，看下其预编译后的结果如下： 1234567int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; if (__objc_no) NSLog(@\"自定义的信息\"); NSLog(@\"info\"); &#125; return 0;&#125; 找到问题了，由于if结构如果不加大括号进行规范，其默认作用域只有一句代码，多写大括号是不会出问题，因此编写多语句宏时，加上大括号是一个好习惯，如下： 123#define LOG(string) \\&#123;NSLog(@\"自定义的信息\"); \\NSLog(string);&#125; 这样解决了问题，但是并不完美，假设在使用时这样写： 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; if (NO) LOG(@\"NO\"); else LOG(@\"YES\"); &#125; return 0;&#125; 结果发现还是会报错，是由于分号捣的鬼，预编译结果如下： 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; if (__objc_no) &#123;NSLog(@\"自定义的信息\"); NSLog(@\"NO\");&#125;; else &#123;NSLog(@\"自定义的信息\"); NSLog(@\"YES\");&#125;; &#125; return 0;&#125; 我们知道，像if，while，for这种语法结构块的大括号后是不需要分号的，我们为了兼容单行if语句由于宏的原因被展开成多行的问题强行加了一个大括号上去，就产生这样的问题了，解决它的一个好方法是真的将多行的宏转化成单语句，do-whlie结构就可以实现这种效果，修改宏如下： 123456789101112#define LOG(string) \\do &#123;NSLog(@\"自定义的信息\"); \\NSLog(string);&#125; while(0);int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; if (NO) LOG(@\"NO\") else LOG(@\"YES\"); &#125; return 0;&#125; 预编译后： 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; if (__objc_no) do &#123;NSLog(@\"自定义的信息\"); NSLog(@\"NO\");&#125; while(0); else do &#123;NSLog(@\"自定义的信息\"); NSLog(@\"YES\");&#125; while(0);; &#125; return 0;&#125; 现在，无论外面怎么使用，这个宏都可以正常工作了。 对于不定参数的宏，借助##符号来拼接参数 在定义函数时，我们可以定义函数的参数为不定个数参数，定义函数式宏时也类似，使用符号”…”可以指定不定个数参数，例如对LOG宏进行调整，如下： 123456789101112#define LOG(format, ...) \\do &#123;NSLog(@\"自定义的信息\"); \\NSLog(format, __VA_ARGS__);&#125; while(0);int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; if (NO) LOG(@\"%d\", NO) else LOG(@\"%d\", YES); &#125; return 0;&#125; __VA_ARGS__也是一个内置的宏符号，则作用是代表宏定义中的可变参数“…”，需要注意，如果按照上面的写法，如果我们传入的可变参数为0个，会产生问题，其原因也是由于多了一个逗号，例如： 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; if (NO) LOG(@\"%d\") // 这里会被预编译成NSLog(@\"%d\", ) else LOG(@\"%d\", YES); &#125; return 0;&#125; 解决方案是对可变参数进行一次##拼接，宏在使用##符号进行参数拼接时，如果后面的参数为空，其会自动将前面的逗号去掉，如下： 123#define LOG(format, ...) \\do &#123;NSLog(@\"自定义的信息\"); \\NSLog(format, ##__VA_ARGS__);&#125; while(0); 五、特殊的宏符号与常用内置宏有几个特殊的符号可以让宏定义变得非常灵活，常用的特殊符号和特殊宏列举如下： # 井号的作用是将参数字符串化，例如： 12345678#define Test(p) #pint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Test(abc); // 预编译后成为 \"abc\"; &#125; return 0;&#125; ## 双井号我们前面有使用过，其作用是对参数进行拼接，例如： 12345678#define Test(a,b) a##bint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Test(1,2); // 预编译后成为 12; &#125; return 0;&#125; __VA_ATGS__ 可变参数宏中专用，表示所有传入的可变参数。 __COUNTER__ 一个累加计数宏，常用来构造唯一变量名。 __LINE__ 记录LOG信息时，常用的一个内置宏，预编译时会将其替换为当前的行号。 __FILE__ 记录LOG信息时，常用的一个内置宏，预编译时会将其替换为当前文件的全路径。 __FILE_NAME__ 记录LOG信息时，常用的一个内置宏，预编译时会将其替换为当前的文件名。 __DATE__ 记录LOG信息时，常用的一个内置宏，预编译时会将其替换为当前日期。 __TIME__ 记录LOG信息时，常用的一个内置宏，预编译时会将其替换为当前时间。 六、宏的展开规则通过前面的介绍，对于应用宏我们已经没有太大的问题，并且也了解了很多宏的使用技巧。这一小节将更深入的对宏的替换规则进行讨论。宏本身是支持嵌套的，例如： 12345678#define M1(A) M2(A)#define M2(A) Aint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; M1(1); &#125; return 0;&#125; 上面代码中定义的两个宏基本上是没有意义的，M1宏替换后的结果是M2宏，M2宏最终被替换为参数本身，从这个例子可以看出，宏是可以嵌套递归展开的，但是递归展开是有原则，不会出现无限递归，例如： 12345678#define M1(A) M2(A)#define M2(A) M1(A)int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; M1(1); // 最终展开为 M1(1) &#125; return 0;&#125; 宏的展开需要符合下面原则： 在展开宏的过程中会先将参数进行展开，如果使用##对参数进行了拼接或使用#进行了处理，则此参数不会被展开。 在宏的展开过程中，如果替换列表中出现了要被展开的宏，则此宏不会被展开。 上面的展开原则提到了替换列表，宏在展开过程中会维护一个替换列表，展开的过程中需要从参数到宏本身，从外层宏到内层宏一层一层的替换，每次替换的时候都会将被替换的宏名放入维护的替换列表中，再下一轮替换中，如果再次出现替换列表中出现过的宏名，则不会被再次替换。以我们上面的代码为例进行分析： 首先M1宏在第一轮替换后，被替换成了M2，此时替换列表中放入宏名M1。 M2依然是一个宏名，第二轮对M2进行替换，将其替换为M1，再次将M2放入替换列表，此时替换列表中有宏名M1和M2。 M1依然是宏名，但是替换列表中已经存在M1，此宏名不再展开。 七、宏的妙用这一小节，我们要转身成为鉴赏家，来对很多实用的宏的巧妙案例进行分析与鉴赏。从这些优秀的使用案例中，可以扩宽我们对宏使用的思路。 MIN与MAX Foundataion内置了一些常用的运算宏，如获取两个数的最大值、最小值、绝对值等等。以MAX宏为例，这个宏的编写基本涵盖了函数式宏所有要注意的点，如下： 12345#define __NSX_PASTE__(A,B) A##B#if !defined(MAX) #define __NSMAX_IMPL__(A,B,L) (&#123; __typeof__(A) __NSX_PASTE__(__a,L) = (A); __typeof__(B) __NSX_PASTE__(__b,L) = (B); (__NSX_PASTE__(__a,L) &lt; __NSX_PASTE__(__b,L)) ? __NSX_PASTE__(__b,L) : __NSX_PASTE__(__a,L); &#125;) #define MAX(A,B) __NSMAX_IMPL__(A,B,__COUNTER__)#endif 其中__NSMAX_IMPL__宏借助计数__COUNTER__和拼接__NSX_PASTE__宏来构造唯一的内部变量名，我们前面提供的示例宏的写法也基本是参照这个系统宏来的。后面大家在编写函数式宏的时候，都可以参照下这个宏的实现。 NSAssert等 NSAssert是断言宏，在开发调试中经常会使用断言来进行安全保障，这个宏的定义如下： 123456789101112#define NSAssert(condition, desc, ...) \\ do &#123; \\ __PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \\ if (__builtin_expect(!(condition), 0)) &#123; \\ NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \\ __assert_file__ = __assert_file__ ? __assert_file__ : @\"&lt;Unknown File&gt;\"; \\ [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \\ object:self file:__assert_file__ \\ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \\ &#125; \\ __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \\ &#125; while(0) NSAssert宏定义中使用到了不定参数拼接消除逗号的技巧，并且是多行宏语句使用do-while进行优化的一个实践。 @weakify与@strongify weakify与strongify是ReactCocoa中常用的两个宏，用来处理循环引用问题。这两个宏的定义非常巧妙，以weakify宏为例，要看懂这个宏并不是十分简单，首先与这个宏相关的宏定义列举如下： 123456789101112131415161718192021222324252627282930313233#if DEBUG#define rac_keywordify autoreleasepool &#123;&#125;#else#define rac_keywordify try &#123;&#125; @catch (...) &#123;&#125;#endif#define rac_weakify_(INDEX, CONTEXT, VAR) \\CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR);#define weakify(...) \\rac_keywordify \\metamacro_foreach_cxt(rac_weakify_,, __weak, __VA_ARGS__)#define metamacro_foreach_cxt(MACRO, SEP, CONTEXT, ...) \\metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(__VA_ARGS__))(MACRO, SEP, CONTEXT, __VA_ARGS__)#define metamacro_argcount(...) \\metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__)#define metamacro_at(N, ...) \\metamacro_concat(metamacro_at, N)(__VA_ARGS__)#define metamacro_concat(A, B) \\metamacro_concat_(A, B)#define metamacro_concat_(A, B) A ## B#define metamacro_head(...) \\metamacro_head_(__VA_ARGS__, 0)#define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0)#define metamacro_head_(FIRST, ...) FIRST 其中rac_keywordify区分DEBUG和RELEASE环境，在DEBUG环境下，其实际上是创建了一个无用的autoreleasepool，消除前面的@符号，在RELEASE环境下，其会创建一个try-catch结构，用来消除参数警告。metamacro_foreach_cxt宏比较复杂，其展开过程如下： 123456789101112131415161718192021222324// 第一步： 原始宏metamacro_foreach_cxt(rac_weakify_,, __weak, obj)// 第二步： 展开metamacro_foreach_cxtmetamacro_concat(metamacro_foreach_cxt, metamacro_argcount(obj))(rac_weakify_,, __weak, obj)// 第三步： 展开metamacro_argcount metamacro_concat(metamacro_foreach_cxt, metamacro_at(20, obj, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1))(rac_weakify_,, __weak, obj)// 第四步： 展开metamacro_at metamacro_concat(metamacro_foreach_cxt,metamacro_concat(metamacro_at, 20)(obj, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1))(rac_weakify_,, __weak, obj)// 第五步：展开metamacro_concat metamacro_concat(metamacro_foreach_cxt,metamacro_at20(obj, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1))(rac_weakify_,, __weak, obj)// 第六步：展开metamacro_at20 metamacro_concat(metamacro_foreach_cxt,metamacro_head(1))(rac_weakify_,, __weak, obj)// 第七步：展开metamacro_head metamacro_concat(metamacro_foreach_cxt,metamacro_head_(1, 0))(rac_weakify_,, __weak, obj)// 第八步：展开metamacro_head_ metamacro_concat(metamacro_foreach_cxt,1)(rac_weakify_,, __weak, obj)// 第九步：展开metamacro_concat metamacro_foreach_cxt1(rac_weakify_,, __weak, obj)// 第十步：展开metamacro_foreach_cxt1rac_weakify_(0, __weak, obj)// 第十一步：展开rac_weakify___weak __typeof__(obj) metamacro_concat(obj, _weak_) = (obj);// 第十二步：展开metamacro_concat __weak __typeof__(obj) obj_weak_ = (obj); strongify宏的展开与之类似。 ParagraphStyleSet宏 ParagraphStyleSet宏是YYLabel中提供的一个设置属性字符串ParagraphStyle相关属性的快捷方法，其中使用到的一个技巧是直接使用宏的形参作为属性名进行使用，使得各种属性的设置都使用同一个宏即可完成，其定义如下： 1234567891011121314151617181920212223#define ParagraphStyleSet(_attr_) \\[self enumerateAttribute:NSParagraphStyleAttributeName \\ inRange:range \\ options:kNilOptions \\ usingBlock: ^(NSParagraphStyle *value, NSRange subRange, BOOL *stop) &#123; \\ NSMutableParagraphStyle *style = nil; \\ if (value) &#123; \\ if (CFGetTypeID((__bridge CFTypeRef)(value)) == CTParagraphStyleGetTypeID()) &#123; \\ value = [NSParagraphStyle yy_styleWithCTStyle:(__bridge CTParagraphStyleRef)(value)]; \\ &#125; \\ if (value. _attr_ == _attr_) return; \\ if ([value isKindOfClass:[NSMutableParagraphStyle class]]) &#123; \\ style = (id)value; \\ &#125; else &#123; \\ style = value.mutableCopy; \\ &#125; \\ &#125; else &#123; \\ if ([NSParagraphStyle defaultParagraphStyle]. _attr_ == _attr_) return; \\ style = [NSParagraphStyle defaultParagraphStyle].mutableCopy; \\ &#125; \\ style. _attr_ = _attr_; \\ [self yy_setParagraphStyle:style range:subRange]; \\ &#125;]; 八、结语宏看上去简单，但是真的用好用巧却并不容易，我想，最好的学习方式就是在实际应用中不断的使用，不断的琢磨与优化。如果能将宏的使用驾轻就熟，一定会为你的代码能力带来质的提升。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：805263726","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"网络杂谈——聊聊NDS解析","slug":"396网络杂谈——聊聊NDS解析","date":"2019-10-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.383Z","comments":true,"path":"2019/10/31/396网络杂谈——聊聊NDS解析/","link":"","permalink":"http://huishao.cc/2019/10/31/396网络杂谈——聊聊NDS解析/","excerpt":"","text":"网络杂谈——聊聊NDS解析一、引言在浏览器中输入一个地址，点击回车之后发生了什么？这是一个面试中常见的问题 ，这个看似常见简单的操作，其中却隐藏了大量复杂的互联网技术。本篇博客，我们就聊一聊网上冲浪的第一步：DNS解析。 DNS解析是一种服务，其又被称为域名解析。它的作用是将域名解析到具体的网络IP地址，以便进行后续的网络连接操作。DNS解析说起来也简单，从表面上看，就是通过一个查询服务，将域名映射成IP地址，可以往深处推敲，你就会发现其实并没有那么简单，世界上有无数的终端接入互联网，DNS服务是如何从浩如烟海的数据中找到目标数据的，DNS服务是如何保证搜索性能的等等都是值得讨论的话题。 二、分层的网络在深入了解DNS解析之前，首先需要对我们当下使用的网络系统有大致的了解。关于网络系统的分层，流行的有OSI的7层模型与TCP/IP的五层模型，其中关系如下图所示： 以OSI的7层网络模型为例，其中每一层都负责对应的协议，两台终端在进行交互时，同层之间进行交互。我们从上到下来看： 应用层：顾名思义应用层的主要作用是搭建应用，其负责实现应用层面的协议，例如文件传输FTP协议，还有我们最常用的HTTP协议以及邮箱相关协议等。 表示层：表示层用来对应用层的数据进行封装处理，如压缩与解压。 会话层：会话层位于传输层之上，其用来管理一对会话，即会话的连接开始，同步，中断等等。 传输层：传输层述责数据的分段传输与接收重组，这一层有TCP、UDP等传输协议。 网络层：网路层负责根据IP来将数据传递到指定的目的主机，其会确定传输路由等问题。 数据链路层：将数据进行MAC地址的封装与解封等。 物理层：定义物理媒介的协议，以二进制的方式传输数据，定义数据的传输速率等参数。 当数据真正的通过7层网络模型传输之前，首要确定的是数据要传输到哪里，我们知道通过IP地址确定数据要到达的目的终端，然而IP地址是有一串数字(字母)与点符号构成的，可读性很差且难于记忆，因此采用别名的方式来代替直接使用IP进行地址确定，这个别名就是域名，将域名解析为IP的过程就是域名解析。 三、DNS服务器既然需要将域名解析成为IP地址，则就需要有一个服务器提供这样的解析功能，这个服务器需要维护这一张域名与IP地址映射的表，在客户提出解析需求时，从表中查询出域名对应的IP地址返回给客户，如下图所示： 然而在实际应用中，上图中的设计结构明显是不切实际的，由一台服务器来维护所有的域名与IP映射关系明显是不现实的。首先，世界上的域名和IP数量非常庞大，并且更新也非常频繁，维护成本很多。另一方面，大量的客户同时进行域名解析请求，也会使解析的效率和速度出现瓶颈。现实中的DNS解析是采用层层递进，多级缓存，递归查询的结构组织而成的，下图很好的描述了这一过程： 从图中可以看到首先当客户端发起DNS解析时，会从本机NDS缓存中进行查找，同样也会查找本机的Hosts文件中是否有指定对应的解析规则，由于本机的Hosts文件具有最高的优先级，因此我们想在本机将某个域名强制指向一个固定的IP，则可以采用修改Hosts文件的方式，在Mac系统中，此Hosts文件在etc文件夹下。 当本机缓存中没有解析出此域名的信息且Hosts文件中也没有指定时，会想本地DNS服务器发起查询，本地DNS服务器也会维护一张缓存表用来提高查询效率，如果本地DNS服务器没有查到，会向根DNS服务器发起请求，根DNS服务器会采用递归迭代的方式进行搜索，全球有13台根DNS服务器，根DNS服务器会根据域名后缀返回对应的顶级域名服务器，顶级域名服务器会再次根据域名分类将指定的主DNS地址返回，如此迭代直到解析到对应的IP地址再一步步返回给客户机。 四、域名服务器类型根域名服务器根域名服务器是域名解析系统中最高级别的域名服务器，其复杂返回顶级域名服务器，他们是互联网的基础。目前，全球有13个根域名服务器地址(并非实际的服务器数量)，可以在如下网站查找到这些根域名服务器的信息。 https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8 顶级域名服务器顶级域名服务器用于某个顶级域名下的DNS解析，例如有专门负责.com后缀的顶级域名服务器，负责.edu后缀的顶级域名服务器等，顶级域名服务器将查询到的主域名服务器返回。 主域名服务器主域名服务器负责某个区域的域名解析。同样，主域名服务器会配套辅助域名服务器进行备份与分担负载。 五、手动进行DNS解析一次完整的HTTP请求首先要做的就是DNS解析(如果是通过域名进行请求)。平时在开发中，我们很少关注是因为发起HTTP的网络请求层帮我们封装好了这一部分逻辑。有时候，为了提高请求的效率或防止DNS劫持，我们也可以自己进行DNS解析。 以iOS中的编程为例，可以直接使用CoreFoundation框架中的接口进行NDS解析： 1234567891011121314151617181920212223242526272829303132333435Boolean result;CFHostRef hostRef;CFArrayRef addresses = NULL;CFArrayRef names = NULL;NSMutableArray * ipsArr = [[NSMutableArray alloc] init];CFStringRef hostNameRef = CFStringCreateWithCString(kCFAllocatorDefault, \"www.baidu.com\", kCFStringEncodingASCII);hostRef = CFHostCreateWithName(kCFAllocatorDefault, hostNameRef);CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();result = CFHostStartInfoResolution(hostRef, kCFHostAddresses, NULL);if (result == true) &#123; addresses = CFHostGetAddressing(hostRef, &amp;result); names = CFHostGetNames(hostRef, &amp;result);&#125;if(result)&#123; struct sockaddr_in* remoteAddr; for(int i = 0; i &lt; CFArrayGetCount(addresses); i++) &#123; CFDataRef saData = (CFDataRef)CFArrayGetValueAtIndex(addresses, i); remoteAddr = (struct sockaddr_in*)CFDataGetBytePtr(saData); if(remoteAddr != NULL) &#123; //获取IP地址 char ip[16]; strcpy(ip, inet_ntoa(remoteAddr-&gt;sin_addr)); NSString * ipStr = [NSString stringWithCString:ip encoding:NSUTF8StringEncoding]; [ipsArr addObject:ipStr]; &#125; &#125;&#125;CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();NSLog(@\"name:%@\", names);NSLog(@\"IP:%@ \\n time cost: %0.3fs\", ipsArr,end - start);CFRelease(hostNameRef);CFRelease(hostRef); 运行上面代码，即可将指定域名的IP地址解析出来，其中CFHostCreateWithName方法根据域名创建一个主机引用对象，CFHostStartInfoResolution方法用来进行主机信息的解析，如果解析成功，CFHostGetAddressing方法用来获取具体的IP地址数据。 上面进行NDS解析的方法比较上层，还有一种方式可以获取到更多的信息，示例代码如下： 123456789101112131415161718192021222324252627CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();char *ptr, **pptr;struct hostent *hptr;char str[32];ptr = \"www.baidu.com\";NSMutableArray * ips = [NSMutableArray array];NSMutableArray * alis = [NSMutableArray array];if((hptr = gethostbyname(ptr)) == NULL)&#123; return 0;&#125;for(pptr=hptr-&gt;h_addr_list; *pptr!=NULL; pptr++) &#123; // inet_ntop方法是将二进制数据转换成IP字符串 NSString * ipStr = [NSString stringWithCString:inet_ntop(hptr-&gt;h_addrtype, *pptr, str, sizeof(str)) encoding:NSUTF8StringEncoding]; [ips addObject:ipStr?:@\"\"];&#125;// 获取主机别名for(pptr=hptr-&gt;h_aliases; *pptr!=NULL; pptr++) &#123; NSString * ali = [NSString stringWithCString:*pptr encoding:NSUTF8StringEncoding]; [alis addObject:ali?:@\"\"];&#125;CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();// 获取主机名NSLog(@\"%s\", hptr-&gt;h_name);NSLog(@\"alias:%@\", alis);NSLog(@\"ip:%@\\ntime cost: %0.3fs\", ips,end - start); gethostbyname方法可以方便的获取指定域名的主机信息，其只支持IPV4，若支持解析IPV6，需要使用gethostbyname2方法，这两个方法都会返回hostent结构体，其中封装了主机的信息。 除了上面介绍的两种方便的方式外，也可以直接通过C语言的Socket接口来进行DNS解析，DNS实际上也是一种协议，只需要向域名解析服务器的指定端口发送指定的请求数据即可获取到解析的结果，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#define DNS_SVR \"198.41.0.4\"#define DNS_HOST 0x01#define DNS_CNAME 0x05int socketfd;struct sockaddr_in dest;static voidsend_dns_request(const char *dns_name);static voidparse_dns_response();/** * Generate DNS question chunk */static voidgenerate_question(const char *dns_name , unsigned char *buf , int *len);static intis_pointer(int in);static voidparse_dns_name(unsigned char *chunk , unsigned char *ptr , char *out , int *len);int main(int argc , char *argv[])&#123; socketfd = socket(AF_INET , SOCK_DGRAM , 0); if(socketfd &lt; 0)&#123; perror(\"create socket failed\"); exit(-1); &#125; bzero(&amp;dest , sizeof(dest)); dest.sin_family = AF_INET; dest.sin_port = htons(53); dest.sin_addr.s_addr = inet_addr(DNS_SVR); send_dns_request(\"www.baidu.com\"); parse_dns_response(); return 0;&#125;static void parse_dns_response()&#123; unsigned char buf[1024]; unsigned char *ptr = buf; struct sockaddr_in addr; char *src_ip; int n , i , flag , querys , answers; int type , ttl , datalen , len; char cname[128] , aname[128] , ip[20] , *cname_ptr; unsigned char netip[4]; size_t addr_len = sizeof(struct sockaddr_in); n = recvfrom(socketfd , buf , sizeof(buf) , 0 , (struct sockaddr*)&amp;addr , &amp;addr_len); ptr += 4; /* move ptr to Questions */ querys = ntohs(*((unsigned short*)ptr)); ptr += 2; /* move ptr to Answer RRs */ answers = ntohs(*((unsigned short*)ptr)); ptr += 6; /* move ptr to Querys */ /* move over Querys */ for(i= 0 ; i &lt; querys ; i ++)&#123; for(;;)&#123; flag = (int)ptr[0]; ptr += (flag + 1); if(flag == 0) break; &#125; ptr += 4; &#125; printf(\"-------------------------------\\n\"); /* now ptr points to Answers */ for(i = 0 ; i &lt; answers ; i ++)&#123; bzero(aname , sizeof(aname)); len = 0; parse_dns_name(buf , ptr , aname , &amp;len); ptr += 2; /* move ptr to Type*/ type = htons(*((unsigned short*)ptr)); ptr += 4; /* move ptr to Time to live */ ttl = htonl(*((unsigned int*)ptr)); ptr += 4; /* move ptr to Data lenth */ datalen = ntohs(*((unsigned short*)ptr)); ptr += 2; /* move ptr to Data*/ if(type == DNS_CNAME)&#123; bzero(cname , sizeof(cname)); len = 0; parse_dns_name(buf , ptr , cname , &amp;len); printf(\"%s is an alias for %s\\n\" , aname , cname); ptr += datalen; &#125; if(type == DNS_HOST)&#123; bzero(ip , sizeof(ip)); if(datalen == 4)&#123; memcpy(netip , ptr , datalen); inet_ntop(AF_INET , netip , ip , sizeof(struct sockaddr)); printf(\"%s has address %s\\n\" , aname , ip); printf(\"\\tTime to live: %d minutes , %d seconds\\n\" , ttl / 60 , ttl % 60); &#125; ptr += datalen; &#125; &#125; ptr += 2;&#125;static voidparse_dns_name(unsigned char *chunk , unsigned char *ptr , char *out , int *len)&#123; int n , alen , flag; char *pos = out + (*len); for(;;)&#123; flag = (int)ptr[0]; if(flag == 0) break; if(is_pointer(flag))&#123; n = (int)ptr[1]; ptr = chunk + n; parse_dns_name(chunk , ptr , out , len); break; &#125;else&#123; ptr ++; memcpy(pos , ptr , flag); pos += flag; ptr += flag; *len += flag; if((int)ptr[0] != 0)&#123; memcpy(pos , \".\" , 1); pos += 1; (*len) += 1; &#125; &#125; &#125;&#125;static int is_pointer(int in)&#123; return ((in &amp; 0xc0) == 0xc0);&#125;static void send_dns_request(const char *dns_name)&#123; unsigned char request[256]; unsigned char *ptr = request; unsigned char question[128]; int question_len; generate_question(dns_name , question , &amp;question_len); *((unsigned short*)ptr) = htons(0xff00); ptr += 2; *((unsigned short*)ptr) = htons(0x0100); ptr += 2; *((unsigned short*)ptr) = htons(1); ptr += 2; *((unsigned short*)ptr) = 0; ptr += 2; *((unsigned short*)ptr) = 0; ptr += 2; *((unsigned short*)ptr) = 0; ptr += 2; memcpy(ptr , question , question_len); ptr += question_len; sendto(socketfd , request , question_len + 12 , 0 , (struct sockaddr*)&amp;dest , sizeof(struct sockaddr));&#125;static voidgenerate_question(const char *dns_name , unsigned char *buf , int *len)&#123; char *pos; unsigned char *ptr; int n; *len = 0; ptr = buf; pos = (char*)dns_name; for(;;)&#123; n = strlen(pos) - (strstr(pos , \".\") ? strlen(strstr(pos , \".\")) : 0); *ptr ++ = (unsigned char)n; memcpy(ptr , pos , n); *len += n + 1; ptr += n; if(!strstr(pos , \".\"))&#123; *ptr = (unsigned char)0; ptr ++; *len += 1; break; &#125; pos += n + 1; &#125; *((unsigned short*)ptr) = htons(1); *len += 2; ptr += 2; *((unsigned short*)ptr) = htons(1); *len += 2;&#125; 其中198.41.0.4是任意选择的一个根域名服务器的地址，如果解析成功，将在控制台看到如下的打印信息： 123456-------------------------------www.baidu.com is an alias for www.a.shifen.comwww.a.shifen.com has address 112.80.248.76 Time to live: 1 minutes , 7 secondswww.a.shifen.com has address 112.80.248.75 Time to live: 1 minutes , 7 seconds","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"iOS开发之ExternalAccessory框架的应用","slug":"395iOS开发之ExternalAccessory框架的应用","date":"2019-06-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.383Z","comments":true,"path":"2019/06/27/395iOS开发之ExternalAccessory框架的应用/","link":"","permalink":"http://huishao.cc/2019/06/27/395iOS开发之ExternalAccessory框架的应用/","excerpt":"","text":"iOS开发之ExternalAccessory框架的应用ExternalAccessory框架用来对外设进行管理，iOS外设通常是通过MFI认证的外部设备，可以通过蓝牙进行连接，也可以使用lighting端口进行连接。 EAAccessoryManager类用来对外设进行管理，其中属性方法如下： 123456789101112@interface EAAccessoryManager : NSObject// 获取单例对象+ (EAAccessoryManager *)sharedAccessoryManager;// 打开蓝牙外设搜索列表- (void)showBluetoothAccessoryPickerWithNameFilter:(nullable NSPredicate *)predicate completion:(nullable EABluetoothAccessoryPickerCompletion)completion;// 注册本地通知 当外设连接状态变化后会触发通知- (void)registerForLocalNotifications;// 取消通知的注册- (void)unregisterForLocalNotifications;// 所有连接的外设列表@property (nonatomic, readonly) NSArray&lt;EAAccessory *&gt; *connectedAccessories;@end 如果注册了本地通知，则可以监听下面两个通知： 12EAAccessoryDidConnectNotification // 外设已经连接的通知EAAccessoryDidDisconnectNotification // 外设断开连接的通知 EAAccessory是外设对象，其中定义了外设的相关信息，如下： 123456789101112131415161718192021222324252627282930@interface EAAccessory : NSObject// 是否已经连接@property(nonatomic, readonly, getter=isConnected) BOOL connected;// 连接ID@property(nonatomic, readonly) NSUInteger connectionID;// 制造商@property(nonatomic, readonly) NSString *manufacturer; // 外设名称@property(nonatomic, readonly) NSString *name;// 模式编码@property(nonatomic, readonly) NSString *modelNumber;// 序列号@property(nonatomic, readonly) NSString *serialNumber;// 固件版本@property(nonatomic, readonly) NSString *firmwareRevision;// 硬件版本@property(nonatomic, readonly) NSString *hardwareRevision;// 接口类型@property(nonatomic, readonly) NSString *dockType;// 协议列表@property(nonatomic, readonly) NSArray&lt;NSString *&gt; *protocolStrings;// 代理@property(nonatomic, assign, nullable) id&lt;EAAccessoryDelegate&gt; delegate;@end@protocol EAAccessoryDelegate &lt;NSObject&gt;@optional// 外设断开连接时调用- (void)accessoryDidDisconnect:(EAAccessory *)accessory;@end 需要注意，与外设进行通讯需要指定对应的协议，首先，需要在iOS应用的info.plist文件中添加如下键来指定此应用要交互的外设协议： 具体的外设协议需要查看外设的说明文档。 EASession类用来进行外设交互，解析如下： 123456789101112@interface EASession : NSObject// 指定外设和协议来创建会话对象- (nullable instancetype)initWithAccessory:(EAAccessory *)accessory forProtocol:(NSString *)protocolString;// 外设对象@property (nonatomic, readonly, nullable) EAAccessory *accessory;// 协议@property (nonatomic, readonly, nullable) NSString *protocolString;// 输入流 用来向外设发送数据@property (nonatomic, readonly, nullable) NSInputStream *inputStream;// 输出流 用来接收外设发送的数据@property (nonatomic, readonly, nullable) NSOutputStream *outputStream;@end EAWiFiUnconfiguredAccessoryBrowser类用来浏览未配置的WIFI外设： 1234567891011121314151617181920212223242526272829303132333435363738@interface EAWiFiUnconfiguredAccessoryBrowser : NSObject// 初始化方法- (instancetype)initWithDelegate:(nullable id&lt;EAWiFiUnconfiguredAccessoryBrowserDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue;// 代理@property (weak, nonatomic, nullable) id&lt;EAWiFiUnconfiguredAccessoryBrowserDelegate&gt; delegate;// 未配置的外设@property (readonly, copy, atomic) NSSet&lt;EAWiFiUnconfiguredAccessory *&gt; *unconfiguredAccessories;// 开始进行搜索- (void)startSearchingForUnconfiguredAccessoriesMatchingPredicate:(nullable NSPredicate *)predicate;// 结束搜索- (void)stopSearchingForUnconfiguredAccessories;// 对外设进行配置- (void)configureAccessory:(EAWiFiUnconfiguredAccessory *)accessory withConfigurationUIOnViewController:(UIViewController *)viewController;@end@protocol EAWiFiUnconfiguredAccessoryBrowserDelegate &lt;NSObject&gt;// 搜索状态改变后调用的回调/*typedef NS_ENUM(NSInteger, EAWiFiUnconfiguredAccessoryBrowserState)&#123; EAWiFiUnconfiguredAccessoryBrowserStateWiFiUnavailable = 0, // WIFI不可用 EAWiFiUnconfiguredAccessoryBrowserStateStopped, // 停止 EAWiFiUnconfiguredAccessoryBrowserStateSearching, // 搜索中 EAWiFiUnconfiguredAccessoryBrowserStateConfiguring, // 配置中&#125;;*/- (void)accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)browser didUpdateState:(EAWiFiUnconfiguredAccessoryBrowserState)state;// 发现了未配置的外设- (void)accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)browser didFindUnconfiguredAccessories:(NSSet&lt;EAWiFiUnconfiguredAccessory *&gt; *)accessories;// 移除了未配置的外设- (void)accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)browser didRemoveUnconfiguredAccessories:(NSSet&lt;EAWiFiUnconfiguredAccessory *&gt; *)accessories;// 完成配置- (void)accessoryBrowser:(EAWiFiUnconfiguredAccessoryBrowser *)browser didFinishConfiguringAccessory:(EAWiFiUnconfiguredAccessory *)accessory withStatus:(EAWiFiUnconfiguredAccessoryConfigurationStatus)status;@end EAWiFiUnconfiguredAccessory对象描述WIFI外设，如下： 12345678910111213141516171819202122@interface EAWiFiUnconfiguredAccessory : NSObject// 名称@property(copy, nonatomic, readonly) NSString *name;// 设备商@property(copy, nonatomic, readonly) NSString *manufacturer;// 模式@property(copy, nonatomic, readonly) NSString *model;// WIFI的SSID@property(copy, nonatomic, readonly) NSString *ssid;// 硬件地址@property(copy, nonatomic, readonly) NSString *macAddress;//属性 /*typedef NS_OPTIONS(NSUInteger, EAWiFiUnconfiguredAccessoryProperties)&#123; EAWiFiUnconfiguredAccessoryPropertySupportsAirPlay = (1 &lt;&lt; 0), EAWiFiUnconfiguredAccessoryPropertySupportsAirPrint = (1 &lt;&lt; 1), EAWiFiUnconfiguredAccessoryPropertySupportsHomeKit = (1 &lt;&lt; 2)&#125;;*/@property(readonly, nonatomic, readonly) EAWiFiUnconfiguredAccessoryProperties properties;@end","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之EventKitUI框架的应用","slug":"394iOS开发之EventKitUI框架的应用","date":"2019-06-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.383Z","comments":true,"path":"2019/06/26/394iOS开发之EventKitUI框架的应用/","link":"","permalink":"http://huishao.cc/2019/06/26/394iOS开发之EventKitUI框架的应用/","excerpt":"","text":"iOS开发之EventKitUI框架的应用前面博客，有介绍EventKit这个框架的使用，使用EventKit可以与系统的日历和提醒应用进行交互，读写用户的日程事件。EventKitUI，顾名思义，其实基于EventKit框架，提供了一套系统的事件管理界面。EventKit的基础内容介绍如下： https://my.oschina.net/u/2340880/blog/3066175 一、EKCalendarChooser日历选择页面EKCalendarChooser提供了选择日历，即选择EKCalendar对象的视图控制器，示例如下： 12345EKCalendarChooser *chooser = [[EKCalendarChooser alloc] initWithSelectionStyle:EKCalendarChooserSelectionStyleSingle displayStyle:EKCalendarChooserDisplayAllCalendars eventStore:self.eventStore];chooser.showsDoneButton = YES;chooser.showsCancelButton = YES;chooser.delegate = self;[self.navigationController pushViewController:chooser animated:YES]; 需要注意，在实例化EKCalendarChooser的时候，需要关联一个EKEventStore对象，用来进行数据操作。 EKCalendarChooser中属性方法如下： 123456789101112131415161718192021222324252627282930// 实例化方法/*typedef NS_ENUM(NSInteger, EKCalendarChooserSelectionStyle) &#123; EKCalendarChooserSelectionStyleSingle, // 单选模式 EKCalendarChooserSelectionStyleMultiple // 多选模式&#125;;typedef NS_ENUM(NSInteger, EKCalendarChooserDisplayStyle) &#123; EKCalendarChooserDisplayAllCalendars, // 展示全部日历 EKCalendarChooserDisplayWritableCalendarsOnly // 只展示可写的日历&#125;;*/- (id)initWithSelectionStyle:(EKCalendarChooserSelectionStyle)selectionStyle displayStyle:(EKCalendarChooserDisplayStyle)displayStyle eventStore:(EKEventStore *)eventStore;// 实例化方法 entityType参数决定是 系统的日历 还是 提醒 对应的 EKCalander- (id)initWithSelectionStyle:(EKCalendarChooserSelectionStyle)style displayStyle:(EKCalendarChooserDisplayStyle)displayStyle entityType:(EKEntityType)entityType eventStore:(EKEventStore *)eventStore;// 获取用户选中的日历 集合@property(nonatomic, copy) NSSet&lt;EKCalendar *&gt; *selectedCalendars;// 选择的风格@property(nonatomic, readonly) EKCalendarChooserSelectionStyle selectionStyle;// 代理对象@property(nonatomic, weak, nullable) id&lt;EKCalendarChooserDelegate&gt; delegate;// 是否展示完成按钮 在导航上@property(nonatomic) BOOL showsDoneButton;// 是否展示取消按钮在导航上@property(nonatomic) BOOL showsCancelButton; EKCalendarChooserDelegate代理中定义的方法如下： 123456789@protocol EKCalendarChooserDelegate &lt;NSObject&gt;@optional// 用户选择改变后触发的回调- (void)calendarChooserSelectionDidChange:(EKCalendarChooser *)calendarChooser;// 用户选择完成后触发的回调- (void)calendarChooserDidFinish:(EKCalendarChooser *)calendarChooser;// 用户取消选择后触发的回调- (void)calendarChooserDidCancel:(EKCalendarChooser *)calendarChooser;@end 二、EKEventViewController事件详情页面EKEventViewController提供了展示某个事件详情的试图控制器，示例如下： 123456789101112131415161718192021- (void)queryEvent &#123; for (EKCalendar *cal in [self.eventStore calendarsForEntityType:EKEntityTypeEvent]) &#123; if ([cal.title isEqualToString:@\"珲少的事项日历\"]) &#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSDateComponents *oneMonthFromNowComponents = [[NSDateComponents alloc] init]; oneMonthFromNowComponents.month = 1; NSDate *oneMonthFromNow = [calendar dateByAddingComponents:oneMonthFromNowComponents toDate:[NSDate date] options:0]; NSPredicate*predicate = [self.eventStore predicateForEventsWithStartDate:[NSDate date] endDate:oneMonthFromNow calendars:@[cal]]; NSArray *eventArray = [self.eventStore eventsMatchingPredicate:predicate]; // 打开控制器 EKEventViewController *controller = [[EKEventViewController alloc] init]; controller.event = eventArray.firstObject; [self presentViewController:controller animated:YES completion:nil]; &#125; &#125;&#125; EKEventViewController也支持进行事件的编辑，其中属性方法如下： 12345678910@interface EKEventViewController : UIViewController// 代理对象@property(nonatomic, weak, nullable) id&lt;EKEventViewDelegate&gt; delegate;// 对应的事件对象，在使用控制器时，必须设置这个属性@property(nonatomic, retain, null_unspecified) EKEvent *event;// 设置是否允许编辑@property(nonatomic) BOOL allowsEditing;// 设置是否允许日历预览@property(nonatomic) BOOL allowsCalendarPreview;@end EKEventViewDelegate中只定义了一个方法，如下： 123456789101112@protocol EKEventViewDelegate &lt;NSObject&gt;@required// 完成某个行为后会调用的代理回调/*typedef NS_ENUM(NSInteger, EKEventViewAction) &#123; EKEventViewActionDone, // 完成了事件 EKEventViewActionResponded, // 回复了事件 EKEventViewActionDeleted, // 删除了事件&#125;;*/- (void)eventViewController:(EKEventViewController *)controller didCompleteWithAction:(EKEventViewAction)action __OSX_AVAILABLE_STARTING(__MAC_NA,__IPHONE_4_2);@end 三、EKEventEditViewController事件编辑控制器EKEventEditViewController提供了事件编辑的视图控制器，对于可编辑的EKEventViewController视图控制器，当用户点击的编辑按钮后，也会调用EKEventEditViewController视图控制器进行编辑，示例如下： 123EKEventEditViewController *controller = [[EKEventEditViewController alloc] init];controller.event = eventArray.firstObject;[self presentViewController:controller animated:YES completion:nil]; 其中属性方法如下： 12345678910@interface EKEventEditViewController : UINavigationController// 代理对象@property(nonatomic, weak, nullable) id&lt;EKEventEditViewDelegate&gt; editViewDelegate;// 编辑行为完成后，进行数据操作的EKEventStore对象@property(nonatomic, retain, null_unspecified) EKEventStore *eventStore;// 要进行编辑的事件对象@property(nonatomic, retain, nullable) EKEvent *event;// 取消编辑- (void)cancelEditing;@end EKEventEditViewDelegate解析如下： 12345678@protocol EKEventEditViewDelegate &lt;NSObject&gt;@required// 完成某个编辑动作后调用- (void)eventEditViewController:(EKEventEditViewController *)controller didCompleteWithAction:(EKEventEditViewAction)action;@optional// 设置新建事件默认对象的日历- (EKCalendar *)eventEditViewControllerDefaultCalendarForNewEvents:(EKEventEditViewController *)controller;@end","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之DeviceCheck框架的应用","slug":"392iOS开发之DeviceCheck框架的应用","date":"2019-06-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.383Z","comments":true,"path":"2019/06/24/392iOS开发之DeviceCheck框架的应用/","link":"","permalink":"http://huishao.cc/2019/06/24/392iOS开发之DeviceCheck框架的应用/","excerpt":"","text":"iOS开发之DeviceCheck框架的应用DeviceCheck框架是iOS 11后提供的一个记录用户设备的工具框架。 在实际应用中，经常会遇到需要识别用户设备的需求，例如某些免费试用的应用程序，会根据设备判断用户是否已经试用过。Apple基于保护用户隐私的原则，开发者不能直接获取用户设备的相关标识信息，iOS 11后，Apple提供了DeviceCheck框架用来提供设备检查功能。 DeviceCheck非常简单，大部分设备检查的逻辑要交给服务端调用Apple提供的接口来实现。 DeviceCheck框架中只提供了一个类：DCDevice。其中定义如下： 12345678@interface DCDevice : NSObject// 类属性 获取实例对象@property (class, readonly) DCDevice *currentDevice;// 检查框架是否可用@property (getter=isSupported, readonly) BOOL supported;// 请求Token- (void)generateTokenWithCompletionHandler:(void(^)(NSData * _Nullable token, NSError * _Nullable error))completion;@end DeviceCheck框架的核心在于获取设备的Token数据，拿到Token数据后可以仿照服务端发送推送的相关流程进行用户设备检查信息的读或写。详细文档地址如下： https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data 使用token进行设备检查时需要发送Query请求，参数如下： ![](https://oscimg.oschina.net/oscnet/83369ca91f61f83ab1eb4e79fda6f074e47.jpg) 在Apple返回的数据中会包含两个二进制的位和一个时间戳： 可以发现，其实Apple提供给开发者标记用户设备的能力十分有限，满打满算，开发者只能对用户设备标记4种状态。通过两个布尔位，用来获取当前设备是否参加了活动或者是否已经使用过试用资格等等。开发者也可以对这两个布尔值进行修改，上传请求的参数如下：","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之DeviceCheck框架的应用","slug":"393iOS开发之EventKit框架的应用","date":"2019-06-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.383Z","comments":true,"path":"2019/06/24/393iOS开发之EventKit框架的应用/","link":"","permalink":"http://huishao.cc/2019/06/24/393iOS开发之EventKit框架的应用/","excerpt":"","text":"iOS开发之DeviceCheck框架的应用DeviceCheck框架是iOS 11后提供的一个记录用户设备的工具框架。 在实际应用中，经常会遇到需要识别用户设备的需求，例如某些免费试用的应用程序，会根据设备判断用户是否已经试用过。Apple基于保护用户隐私的原则，开发者不能直接获取用户设备的相关标识信息，iOS 11后，Apple提供了DeviceCheck框架用来提供设备检查功能。 DeviceCheck非常简单，大部分设备检查的逻辑要交给服务端调用Apple提供的接口来实现。 DeviceCheck框架中只提供了一个类：DCDevice。其中定义如下： 12345678@interface DCDevice : NSObject// 类属性 获取实例对象@property (class, readonly) DCDevice *currentDevice;// 检查框架是否可用@property (getter=isSupported, readonly) BOOL supported;// 请求Token- (void)generateTokenWithCompletionHandler:(void(^)(NSData * _Nullable token, NSError * _Nullable error))completion;@end DeviceCheck框架的核心在于获取设备的Token数据，拿到Token数据后可以仿照服务端发送推送的相关流程进行用户设备检查信息的读或写。详细文档地址如下： https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data 使用token进行设备检查时需要发送Query请求，参数如下： ![](https://oscimg.oschina.net/oscnet/83369ca91f61f83ab1eb4e79fda6f074e47.jpg) 在Apple返回的数据中会包含两个二进制的位和一个时间戳： 可以发现，其实Apple提供给开发者标记用户设备的能力十分有限，满打满算，开发者只能对用户设备标记4种状态。通过两个布尔位，用来获取当前设备是否参加了活动或者是否已经使用过试用资格等等。开发者也可以对这两个布尔值进行修改，上传请求的参数如下：","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之CoreTelephoney框架的应用","slug":"391iOS开发之CoreTelephoney框架的应用","date":"2019-02-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.383Z","comments":true,"path":"2019/02/26/391iOS开发之CoreTelephoney框架的应用/","link":"","permalink":"http://huishao.cc/2019/02/26/391iOS开发之CoreTelephoney框架的应用/","excerpt":"","text":"iOS开发之CoreTelephoney框架的应用CoreTelephoney框架用来获取手机网络状态以及运营商相关信息。 一、CTTelephonyNetworkInfo类这个类是CoreTelephoney框架的核心，使用它来获取手机的运营商、网络等状态信息。使用示例如下： 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; CTTelephonyNetworkInfo *info = [[CTTelephonyNetworkInfo alloc] init]; //获取运营商信息 CTCarrier *carrier = info.subscriberCellularProvider; NSLog(@\"carrier:%@\", [carrier description]);&#125; 运营商信息示例如下： 12345Carrier name: [中国移动]Mobile Country Code: [460]Mobile Network Code:[02]ISO Country Code:[cn]Allows VOIP? [YES] CTTelephonyNetworkInfo类解析如下： 123456789101112131415161718192021//获取所有运营商信息 iOS 12 后支持@property(readonly, retain, nullable) NSDictionary&lt;NSString *, CTCarrier *&gt; *serviceSubscriberCellularProviders;//当前获取运营商信息@property(readonly, retain, nullable) CTCarrier *subscriberCellularProvider;//无线网络提供信息@property (nonatomic, readonly, retain, nullable) NSDictionary&lt;NSString *, NSString *&gt; * serviceCurrentRadioAccessTechnology;//当前无线网络信息/*CTRadioAccessTechnologyGPRS //2.5gCTRadioAccessTechnologyEdge //2.7GCTRadioAccessTechnologyWCDMA //3GCTRadioAccessTechnologyHSDPA //3.5GCTRadioAccessTechnologyHSUPA //3G与4G之间的过度技术CTRadioAccessTechnologyCDMA1x //3GCTRadioAccessTechnologyCDMAEVDORev0 CTRadioAccessTechnologyCDMAEVDORevA CTRadioAccessTechnologyCDMAEVDORevB CTRadioAccessTechnologyeHRPD CTRadioAccessTechnologyLTE //4G*/ @property (nonatomic, readonly, retain, nullable) NSString* currentRadioAccessTechnology; CTCattier类中定义了运营商相关的信息，解析如下： 12345678910//运营商名字@property (nonatomic, readonly, retain, nullable) NSString *carrierName;//国家编码@property (nonatomic, readonly, retain, nullable) NSString *mobileCountryCode;//网络编码@property (nonatomic, readonly, retain, nullable) NSString *mobileNetworkCode;//ISO编码@property (nonatomic, readonly, retain, nullable) NSString* isoCountryCode;//是否允许VOIP@property (nonatomic, readonly, assign) BOOL allowsVOIP; CTCellularData类用来监听用户的网络状态，可以设置当网络状态发生变化后回调的方法，例如： 1234567891011121314151617cellularData = [[CTCellularData alloc] init]; // 状态发生变化时调用cellularData.cellularDataRestrictionDidUpdateNotifier = ^(CTCellularDataRestrictedState restrictedState) &#123; switch (restrictedState) &#123; case kCTCellularDataRestrictedStateUnknown: NSLog(@\"蜂窝移动网络状态：未知\"); break; case kCTCellularDataRestricted: NSLog(@\"蜂窝移动网络状态：关闭\"); break; case kCTCellularDataNotRestricted: NSLog(@\"蜂窝移动网络状态：开启\"); break; default: break; &#125;&#125;; 需要注意，在iOS中使用网络需要获取用户权限，如果用户没有给网络权限，获取到的状态也将是未开启。 二、CTCallCenter使用CTCallCenter相关类可以获取当前通话电话的相关信息，CTCallCenter通过管理中心，其中提供了一个方法来获取当前进行中的通话： 12//获取当前所有激活中的通话@property(readonly, retain, nullable) NSSet&lt;CTCall*&gt; *currentCalls; 通话被抽象成CTCall对象，解析如下： 12345678910//当前通话状态/*CTCallStateDialing 拨号CTCallStateIncoming 来电CTCallStateConnected 接通CTCallStateDisconnected 挂断*/@property(nonatomic, readonly, copy) NSString *callState;//通话ID@property(nonatomic, readonly, copy) NSString *callID;","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之CoreSpotlight框架的应用","slug":"390iOS开发之CoreSpotlight框架的应用","date":"2019-02-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.382Z","comments":true,"path":"2019/02/25/390iOS开发之CoreSpotlight框架的应用/","link":"","permalink":"http://huishao.cc/2019/02/25/390iOS开发之CoreSpotlight框架的应用/","excerpt":"","text":"iOS开发之CoreSpotlight框架的应用CoreSpotlight是iOS提供的一套本地检索推荐功能。开发者可以为自己的应用添加本地索引，用户通过索引中定义的关键字可以搜索并定位到应用程序内的指定功能。 一、一个简单的添加索引示例123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; //创建索引属性对象 CSSearchableItemAttributeSet *set = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:(NSString*)kUTTypeText]; //设置索引属性 set.title = @\"哈哈哈\"; set.displayName = @\"Hello\"; set.alternateNames = @[@\"aaa\",@\"bbb\"]; set.keywords = @[@\"333\",@\"444\"]; set.version = @\"1.1\"; set.path = @\"path\"; set.thumbnailURL = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"image\" ofType:@\"png\"]]; //创建索引 CSSearchableItem *item = [[CSSearchableItem alloc] initWithUniqueIdentifier:@\"1111\" domainIdentifier:@\"huishao\" attributeSet:set]; //添加索引 [[CSSearchableIndex defaultSearchableIndex] indexSearchableItems:@[item] completionHandler:^(NSError * _Nullable error) &#123; if (error) &#123; NSLog(@\"buildSearchableItem Error:%@\",error.localizedDescription); &#125; &#125;];&#125; 在搜索栏中搜索索引的关键字，标题，名称、路径都可以搜索到当前应用程序。例如： 二、CSSearchableIndex索引管理类CSSearchableIndex类提供了对索引的操作功能，例如添加索引，查找索引，删除索引等等，解析如下： 1234567891011121314151617//代理对象@property (weak,nullable) id&lt;CSSearchableIndexDelegate&gt; indexDelegate; //获取索引检索是否可用+ (BOOL)isIndexingAvailable;//获取默认提供的索引管理对象+ (instancetype)defaultSearchableIndex;//创建一个索引管理对象- (instancetype)initWithName:(NSString *)name;- (instancetype)initWithName:(NSString *)name protectionClass:(nullable NSFileProtectionType)protectionClass;//获取索引管理对象中的所有索引- (void)indexSearchableItems:(NSArray&lt;CSSearchableItem *&gt; *)items completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//通过标识符来删除索引- (void)deleteSearchableItemsWithIdentifiers:(NSArray&lt;NSString *&gt; *)identifiers completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//通过域名来删除索引- (void)deleteSearchableItemsWithDomainIdentifiers:(NSArray&lt;NSString *&gt; *)domainIdentifiers completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//删除所有索引- (void)deleteAllSearchableItemsWithCompletionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler; 三、CSSearchableIndexDelegate详解CSSearchableIndexDelegate提供了索引查找的相关回调方法，解析如下： 12345678910111213//这个代理重新索引所有可搜索的数据，并且清除任何本地状态（可能该状态已经被持久化），因为索引已经丢失了- (void)searchableIndex:(CSSearchableIndex *)searchableIndex reindexAllSearchableItemsWithAcknowledgementHandler:(void (^)(void))acknowledgementHandler;//根据id重新索引所有可搜索的数据- (void)searchableIndex:(CSSearchableIndex *)searchableIndex reindexSearchableItemsWithIdentifiers:(NSArray &lt;NSString *&gt; *)identifiers acknowledgementHandler:(void (^)(void))acknowledgementHandler;//已经进入节能模式调用的方法- (void)searchableIndexDidThrottle:(CSSearchableIndex *)searchableIndex;// 结束节能模式调用的方法- (void)searchableIndexDidFinishThrottle:(CSSearchableIndex *)searchableIndex;//用来提供数据- (nullable NSData *)dataForSearchableIndex:(CSSearchableIndex *)searchableIndex itemIdentifier:(NSString *)itemIdentifier typeIdentifier:(NSString *)typeIdentifier error:(out NSError ** __nullable)outError;//用来提供文件地址- (nullable NSURL *)fileURLForSearchableIndex:(CSSearchableIndex *)searchableIndex itemIdentifier:(NSString *)itemIdentifier typeIdentifier:(NSString *)typeIdentifier inPlace:(BOOL)inPlace error:(out NSError ** __nullable)outError; 四、CSSearchableItem索引类CSSearchableItem用来进行索引的定义，解析如下： 123456789101112//通过设置唯一标识符、域名和属性来定义索引- (instancetype)initWithUniqueIdentifier:(nullable NSString *)uniqueIdentifier domainIdentifier:(nullable NSString *)domainIdentifier attributeSet:(CSSearchableItemAttributeSet *)attributeSet;//唯一标识符@property (copy) NSString *uniqueIdentifier;//域名标识符@property (copy, nullable) NSString *domainIdentifier;//过期时间@property (copy, null_resettable) NSDate * expirationDate;//属性@property (strong) CSSearchableItemAttributeSet *attributeSet; 五、CSSearchableItemAttributeSet类这个类的主要作用是进行索引信息的配置，CSSearchableItemAttributeSet并没定义太多的属性，CoreSpotlight中提供了这个类的大量Category来补充这个类的功能，解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//---------------标准---------------------------------//通过类型创建一个索引信息类- (instancetype)initWithItemContentType:(nonnull NSString *)itemContentType;//设置索引的展示名称 可以进行搜索@property(nullable, copy) NSString *displayName;//设置可交互的名称数组 可以进行搜索@property(nullable, copy) NSArray&lt;NSString*&gt; *alternateNames;//设置索引的完整路径 可以进行搜索@property(nullable, copy) NSString *path;//设置索引关联的文件URL@property(nullable, strong) NSURL *contentURL;//设置索引缩略图的URL@property(nullable, strong) NSURL *thumbnailURL;//设置索引缩略图数据@property(nullable, copy) NSData *thumbnailData;//数据最后更改日期@property(nullable, strong) NSDate *metadataModificationDate;//内容类型@property(nullable, copy) NSString *contentType;//关键字数组@property(nullable, copy) NSArray&lt;NSString*&gt; *keywords;//设置标题@property(nullable, copy) NSString *title;//设置版本@property(nullable, copy) NSString *version;//设置搜索权重 0-100之间@property(nullable, strong) NSNumber *rankingHint;//域名标识@property(nullable, copy) NSString *domainIdentifier;//------------动作相关--------------------------------//是否支持拨打电话 必须先设置phoneNumbers属性@property(nullable, strong) NSNumber *supportsPhoneCall;//是否支持导航 必须先设置经纬度信息@property(nullable, strong) NSNumber *supportsNavigation;//------------容器相关--------------------------------//设置容器标题@property(nullable, copy) NSString *containerTitle;//设置容器显示名@property(nullable, copy) NSString *containerDisplayName;//设置容器标识@property(nullable, copy) NSString *containerIdentifier;//设置容器顺序@property(nullable, strong) NSNumber *containerOrder;//-----------图片相关-------------------------------//图片高度@property(nullable, strong) NSNumber *pixelHeight;//图片高度@property(nullable, strong) NSNumber *pixelWidth;//像素总数@property(nullable, strong) NSNumber *pixelCount;//颜色空间@property(nullable, copy) NSString *colorSpace;//每一帧的bit数@property(nullable, strong) NSNumber *bitsPerSample;//拍照时是否开启闪光灯@property(nullable, strong, getter=isFlashOn) NSNumber *flashOn;//焦距是否35毫米@property(nullable, strong, getter=isFocalLength35mm) NSNumber *focalLength35mm;//设备制造商信息@property(nullable, copy) NSString *acquisitionMake;//设备模型信息@property(nullable, copy) NSString *acquisitionModel;//... 更多图片信息//----------媒体相关-------------------------------//编辑者@property(nullable, copy) NSArray&lt;NSString*&gt; *editors;//下载时间@property(nullable, strong) NSDate *downloadedDate;//文件描述@property(nullable, copy) NSString *comment;//内容版权@property(nullable, copy) NSString *copyright;//最后使用时间@property(nullable, strong) NSDate *lastUsedDate;//添加时间@property(nullable, strong) NSDate *addedDate;//时长@property(nullable, strong) NSNumber *duration;//联系人关键字@property(nullable, copy) NSArray&lt;NSString*&gt; *contactKeywords;//媒体类型@property(nullable, copy) NSArray&lt;NSString*&gt; *mediaTypes;//总比特率@property(nullable, strong) NSNumber *totalBitRate;//视频比特币@property(nullable, strong) NSNumber *videoBitRate;//音频比特率@property(nullable, strong) NSNumber *audioBitRate;//组织信息@property(nullable, copy) NSArray&lt;NSString*&gt; *organizations;//创建者@property(nullable, copy) NSString *role;//语言信息@property(nullable, copy) NSArray&lt;NSString*&gt; *languages;//发布者@property(nullable, copy) NSArray&lt;NSString*&gt; *publishers;//地址@property(nullable, strong) NSURL *URL;//... 更多媒体信息//---------------信息相关---------------------------//网页数据@property(nullable, copy) NSData *HTMLContentData;//文本数据@property(nullable, copy) NSString *textContent;//作者数据@property(nullable, copy) NSArray&lt;CSPerson*&gt; *authors;//邮箱地址@property(nullable, copy) NSArray&lt;NSString*&gt; *authorEmailAddresses;@property(nullable, copy) NSArray&lt;NSString*&gt; *emailAddresses;//电话号码@property(nullable, copy) NSArray&lt;NSString*&gt; *phoneNumbers;//... 更多//--------------地址相关-------------------//邮编@property(nullable, copy) NSString *postalCode;//城市@property(nullable, copy) NSString *city;//国家@property(nullable, copy) NSString *country;//海拔@property(nullable, strong) NSNumber *altitude;//经度@property(nullable, strong) NSNumber *latitude;//纬度@property(nullable, strong) NSNumber *longitude;//速度@property(nullable, strong) NSNumber *speed;//时间戳@property(nullable, strong) NSDate *timestamp;//... 更多","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"MD5加密原理解析及OC版原理实现","slug":"389MD5加密原理解析及OC版原理实现","date":"2019-01-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.382Z","comments":true,"path":"2019/01/28/389MD5加密原理解析及OC版原理实现/","link":"","permalink":"http://huishao.cc/2019/01/28/389MD5加密原理解析及OC版原理实现/","excerpt":"","text":"MD5加密原理解析及OC版原理实现一、MD5算法基础概念MD5算法是Hash算法的一种，叫做讯息摘要演算法。所谓摘要，从字面意思理解，是指内容的大概。在MD5算法中，这个摘要是指将任意数据映射成一个128位长的摘要信息。并且其是不可逆的，即从摘要信息无法反向推演中原文，在演算过程中，原文的内容也是有丢失的。 因为MD5算法最终生成的是一个128位长的数据，从原理上说，有2^128种可能，这是一个非常巨大的数据，约等于3.4乘10的38次方，虽然这个是个天文数字，但是世界上可以进行加密的数据原则上说是无限的，因此是可能存在不同的内容经过MD5加密后得到同样的摘要信息，但这个碰中的概率非常小。 二、MD5的使用场景MD5常用在密码加密中，一般为了保证用户密码的安全，在数据库中存储的都是用户的密码经过MD5加密后的值，在客户端用户输入密码后，也会使用MD5进行加密，这样即使用户的网络被窃听，窃听者依然无法拿到用户的原始密码，并且即使用户数据库被盗，没有存储明文的密码对用户来说也多了一层安全保障。 MD5签名技术还常用于防止信息的篡改。使用MD5可以对信息进行签名，接收者拿到信息后只要重新计算签名和原始签名进行对比，即可知道数据信息是否中途被篡改了。 三、MD5算法原理MD5算法大致分为4步完成： 第1步：进行数据填充整理 这一步是对要加密的数据进行填充和整理，将要加密的二进制数据对512取模，得到的结果如果不够448位，则进行补足，补足的方式是第1位填充1，后面全部填充0。 第2步：记录数据长度 经过第一步整理完成后的数据的位数可以表示为N\\*512+448，再向其后追加64位用来存储数据的长度，比如数据的长度为16字节，则用10000来填充后64位。这一步做完后，数据的位数将变成(N+1)\\*512。 第3步：以标准的幻数作为输入 MD5的实现需要每512个字节进行一次处理，后一次处理的输入为前一次处理的输出，因此，在循环处理开始之前，需要拿4个标准数作为输入，它们分别是： 1unsigned int A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476; 第4步：进行N轮循环处理，将最后的结果输出 这一步重要的是每一轮的处理算法，每一轮处理也要循环64次，这64次循环被分为4各组，每16次循环为一组，每组循环使用不同的逻辑处理函数，处理完成后，将输出作为输入进入下一轮循环。 四、MD5核心算法的实现 这里演示的是每轮循环的核心算法： 首先进行3个函数的声明： 123456//将大端字节序转换为小端字节序void convertToLittleEndian(unsigned int *data, int len);//进行循环左移函数void ROL(unsigned int *s, unsigned short cx);//MD5加密函数void MD5(NSString *str); MD5算法中处理的数据都是小端字节序的，而使用Objective-C处理的NSData对象的字节序是大端字节序，因此我们需要做一下转换。函数实现如下： 123456789101112void convertToLittleEndian(unsigned int *data, int len)&#123; for (int index = 0; index &lt; len; index ++) &#123; *data = ((*data &amp; 0xff000000) &gt;&gt; 24) | ((*data &amp; 0x00ff0000) &gt;&gt; 8) | ((*data &amp; 0x0000ff00) &lt;&lt; 8) | ((*data &amp; 0x000000ff) &lt;&lt; 24); data ++; &#125;&#125; 在MD5中有需要对字节数据进行循环左移的操作，循环左移函数实现如下： 123456void ROL(unsigned int *s, unsigned short cx)&#123; if (cx &gt; 32)cx %= 32; *s = (*s &lt;&lt; cx) | (*s &gt;&gt; (32 - cx)); return;&#125; 下面是MD5函数的核心实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108void MD5(NSString *str)&#123; const void * bytes[str.length]; //字符串转字节流 [str getBytes:bytes maxLength:str.length usedLength:nil encoding:NSUTF8StringEncoding options:NSStringEncodingConversionExternalRepresentation range:NSMakeRange(0, str.length) remainingRange:nil]; //使用NSData存储 NSMutableData * data = [[NSMutableData alloc] initWithBytes:bytes length:str.length]; BOOL first = YES; //进行数据填充 if (data.length&lt;56) &#123; do &#123; if (first) &#123; int byte = 0b10000000; [data appendBytes:&amp;byte length:1]; first = NO; &#125;else&#123; int byte = 0b00000000; [data appendBytes:&amp;byte length:1]; &#125; &#125; while (data.length&lt;56); &#125; int length = (int)str.length*8%((int)pow(2, 64)); [data appendBytes:&amp;length length:8]; void * newBytes[64]; memcpy(newBytes, [data bytes], 64); //大小端转换 convertToLittleEndian(newBytes, 64); NSData * newData = [NSData dataWithBytes:newBytes length:data.length]; NSMutableArray * subData = [NSMutableArray array]; //进行分组 for (int i = 0; i&lt;16; i++) &#123; [subData addObject: [newData subdataWithRange:NSMakeRange(i*4, 4)]]; &#125; //初始输入 unsigned int A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476; unsigned int a=A,b=B,c=C,d=D; unsigned int s[64] = &#123; 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11,16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15,21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21 &#125;; unsigned int k[64] = &#123; 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 &#125;; //64次循环处理 for (int i = 0; i &lt;= 64; i++) &#123; if (i&lt;64) &#123; unsigned int f; unsigned int g; if (i&lt;16) &#123; f = (b&amp;c)|((~b)&amp;d); g = i; &#125;else if(i&lt;32) &#123; f = (b&amp;d)|((~d)&amp;c); g = (5*i+1)%16; &#125;else if(i&lt;48)&#123; f = b^c^d; g = (3*i+5)%16; &#125;else&#123; f = c^((~d)|b); g = (7*i)%16; &#125; unsigned int * temp = (unsigned int *) [subData[g] bytes]; unsigned int *tem = malloc(sizeof(unsigned int)); memcpy(tem, temp, 4); convertToLittleEndian(tem, 4); unsigned int res = (a+f+*tem+k[i]); ROL(&amp;res,s[i]); unsigned int t = res+b; a = d; d = c; c = b; b = t; &#125;else&#123; A = a+A; B = b+B; C = c+C; D = d+D; &#125; &#125; //大小端转换 unsigned int * newA = malloc(sizeof(unsigned int)); memcpy(newA, &amp;A, 4); NSLog(@\"%0x\",*newA); convertToLittleEndian(newA, 4); unsigned int * newB = malloc(sizeof(unsigned int)); memcpy(newB, &amp;B, 4); convertToLittleEndian(newB, 4); unsigned int * newC = malloc(sizeof(unsigned int)); memcpy(newC, &amp;C, 4); convertToLittleEndian(newC, 4); unsigned int * newD = malloc(sizeof(unsigned int)); memcpy(newD, &amp;D, 4); convertToLittleEndian(newD, 4); NSLog(@\"AAA:%0x %0x %0x %0x \",*newA,*newB,*newC,*newD);&#125;","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"iOS开发之CoreMotion框架的应用","slug":"388iOS开发之CoreMotion框架的应用","date":"2019-01-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.382Z","comments":true,"path":"2019/01/22/388iOS开发之CoreMotion框架的应用/","link":"","permalink":"http://huishao.cc/2019/01/22/388iOS开发之CoreMotion框架的应用/","excerpt":"","text":"iOS开发之CoreMotion框架的应用我们知道，现在智能手机手机的功能已经越来越强大。小小的手机中集成了众多的传感器配件。通过这些传感器可以获取到手机甚至用户的状态信息。 在iOS5之前，加速度传感器的相关信息封装在UIAccelerometer这个类中，其主要用来获取设备在三维空间中的状态信息，之后，加速度传感器以及螺旋仪传感器的相关信息都封装在了CoreMotion这个框架中，这个框架对加速度，磁力以及螺旋仪传感器信息进行统一管理，并封装了许多强大的计算方法帮助开发者获取设备的空间状态。 之前有写过一篇关于UIAccelerometer与CoreMotion简单使用的博客，比较偏用法介绍，并不系统，本篇博客是针对CoreMotion的完善与补充。 https://my.oschina.net/u/2340880/blog/543434 一、CoreMotion框架整体结构在学习这个框架之前，首先需要对框架中类的关系与作用有个整体的了解。下图展示了CoreMotion框架的整体结构： 从上图中可以看出，CoreMotion框架中主要分为3大块，一部分是用来获取设备的运动状态，如速度，加速度，海拔，三维方向等。一部分是用来配合iWatch进行用户的运动状态获取、另一部分为用户步数相关接口。 二、CMMotionManagerCMMotionManager类是CoreMotion框架中非常核心的一个类，其用来进行设备运动信息的整体管理。主要包括开启更新信息，停止更新信息，获取更新信息等。解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//获取加速计是否可用@property(readonly, nonatomic, getter=isAccelerometerAvailable) BOOL accelerometerAvailable;//加速计更新间隔@property(assign, nonatomic) NSTimeInterval accelerometerUpdateInterval;//加速计是否在持续进行更新@property(readonly, nonatomic, getter=isAccelerometerActive) BOOL accelerometerActive;//最后一次更新的加速计信息 CMAccelerometerData后面会介绍@property(readonly, nullable) CMAccelerometerData *accelerometerData;//开始进行加速计数据更新- (void)startAccelerometerUpdates;//开始进行加速计数据更新 并且指定回调函数以及回调函数执行的线程- (void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler;//停止加速计数据的更新- (void)stopAccelerometerUpdates;//陀螺仪是否可用@property(readonly, nonatomic, getter=isGyroAvailable) BOOL gyroAvailable;//陀螺仪数据的更新间隔@property(assign, nonatomic) NSTimeInterval gyroUpdateInterval;//陀螺仪是否在持续进行更新@property(readonly, nonatomic, getter=isGyroActive) BOOL gyroActive;//陀螺仪数据@property(readonly, nullable) CMGyroData *gyroData;//开启陀螺仪的更新- (void)startGyroUpdates;//开始进行陀螺仪的更新 并且指定回调函数以及回调函数执行的线程- (void)startGyroUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMGyroHandler)handler;//停止进行陀螺仪数据的更新- (void)stopGyroUpdates;//磁力计是否可用@property(readonly, nonatomic, getter=isMagnetometerAvailable) BOOL magnetometerAvailable;//磁力计数据更新间隔@property(assign, nonatomic) NSTimeInterval magnetometerUpdateInterval;//磁力计数据是否在持续更新@property(readonly, nonatomic, getter=isMagnetometerActive) BOOL magnetometerActive;//磁力计数据@property(readonly, nullable) CMMagnetometerData *magnetometerData;//开始更新磁力计数据- (void)startMagnetometerUpdates;//开始更新磁力计数据 并且指定回调函数以及回调函数执行的线程- (void)startMagnetometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMMagnetometerHandler)handler;//停止磁力计的更新- (void)stopMagnetometerUpdates;//设备运动数据并非某个传感器的数据 而是上面3种传感器数据的组合与运算//设备运动数据是否可用@property(readonly, nonatomic, getter=isDeviceMotionAvailable) BOOL deviceMotionAvailable;//设备运动数据更新间隔@property(assign, nonatomic) NSTimeInterval deviceMotionUpdateInterval;//是否在持续更新设备运动数据@property(readonly, nonatomic, getter=isDeviceMotionActive) BOOL deviceMotionActive;//最后一次更新的设备运动信息数据@property(readonly, nullable) CMDeviceMotion *deviceMotion;//开始更新设备运动数据- (void)startDeviceMotionUpdates;//开始更新设备运动数据 并指定回调函数以及回调函数执行的线程- (void)startDeviceMotionUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler;//停止更新设备运动信息- (void)stopDeviceMotionUpdates; 上面的方法看上去非常繁多，其实很有规律，总的来说就是对是否开启传感器数据进行管理，并且进行传感器数据的获取。下面我们来看几种具体的传感器数据类的定义。 三、数据模型类首先，CoreMotion框架中的数据模型类都继承自CMLogItem类，这个类里面只有一个属性： 123@interface CMLogItem : NSObject &lt;NSSecureCoding, NSCopying&gt;@property(readonly, nonatomic) NSTimeInterval timestamp;@end CMLogItem类的timestamp属性用来标记数据记录的时间戳。 1.加速计数据CMAccelerometerData是加速计数据的数据模型类： 12345678910@interface CMAccelerometerData : CMLogItem//加速计数据@property(readonly, nonatomic) CMAcceleration acceleration;@end//加速计数据结构体typedef struct &#123; double x; //x方向加速度 double y; //y方向加速度 double z; //z方向加速度&#125; CMAcceleration; 2、陀螺仪数据CMGyroData是陀螺仪数据的数据模型类： 1234567891011@interface CMGyroData : CMLogItem//角速度数据@property(readonly, nonatomic) CMRotationRate rotationRate;@end//角速度结构体typedef struct &#123; double x; //x方向的角速度 double y; //y方向的角速度 double z; //z方向的角速度&#125; CMRotationRate; 3.磁强计数据CMMagnetometerData是磁强计数据模型类： 123456789101112@interface CMMagnetometerData : CMLogItem&#123;//磁强数据@property(readonly, nonatomic) CMMagneticField magneticField;@endtypedef struct &#123; double x; //x轴磁场 double y; //y轴磁场 double z; //z轴磁场&#125; CMMagneticField; 4.设备运动信息CMDeviceMotion类包含了设备的空间状态信息： 1234567891011121314@interface CMDeviceMotion : CMLogItem//设备的空间状态 CMAttitude后面会介绍@property(readonly, nonatomic) CMAttitude *attitude;//设备的 陀螺仪数据@property(readonly, nonatomic) CMRotationRate rotationRate;//设备的 加速计数据@property(readonly, nonatomic) CMAcceleration gravity;//获取用户给设备带来的加速度@property(readonly, nonatomic) CMAcceleration userAcceleration;//设备附近磁场相关信息@property(readonly, nonatomic) CMCalibratedMagneticField magneticField;//返回航向角度@property(readonly, nonatomic) double heading;@end CMCalibratedMagneticField是一个结构体，如下： 1234567891011typedef struct &#123; CMMagneticField field; //磁场 CMMagneticFieldCalibrationAccuracy accuracy; //磁场强度&#125; CMCalibratedMagneticField;typedef NS_ENUM(int, CMMagneticFieldCalibrationAccuracy) &#123; CMMagneticFieldCalibrationAccuracyUncalibrated = -1, CMMagneticFieldCalibrationAccuracyLow, //低 CMMagneticFieldCalibrationAccuracyMedium,//中 CMMagneticFieldCalibrationAccuracyHigh//高&#125; ; CMAttitude类中封装的信息如下： 12345678910111213141516171819202122232425262728@interface CMAttitude : NSObject &lt;NSCopying, NSSecureCoding&gt;&#123;//设备翻滚弧度@property(readonly, nonatomic) double roll;//旋转弧度@property(readonly, nonatomic) double pitch;//航偏@property(readonly, nonatomic) double yaw;//描述设备状态的旋转矩阵@property(readonly, nonatomic) CMRotationMatrix rotationMatrix;//描述设备姿态的四元数@property(readonly, nonatomic) CMQuaternion quaternion;//进行转换- (void)multiplyByInverseOfAttitude:(CMAttitude *)attitude;@end//四元数typedef struct&#123; double x, y, z, w;&#125; CMQuaternion;//矩阵typedef struct &#123; double m11, m12, m13; double m21, m22, m23; double m31, m32, m33;&#125; CMRotationMatrix; 四、高度信息CoreMotion框架中的CMAltimeter类提供对设备高度相关信息的数据支持，这个类是iOS 8后新加入的，CMAltimeter类解析如下： 12345678910@interface CMAltimeter : NSObject//是否支持相对高度变化+ (BOOL)isRelativeAltitudeAvailable;//进行用户权限的申请+ (CMAuthorizationStatus)authorizationStatus;//开始更新高度变化信息数据- (void)startRelativeAltitudeUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAltitudeHandler)handler;//停止更新高度变化信息数据- (void)stopRelativeAltitudeUpdates;@end CMAltitudeData是高度信息数据： 123456@interface CMAltitudeData : CMLogItem//相对高度 单位为米@property(readonly, nonatomic) NSNumber *relativeAltitude;//压力 单位为千帕@property(readonly, nonatomic) NSNumber *pressure;@end 五、用户活动信息CMMotionActivityManager类是iOS 7之后新引入到CoreMotion框架中的，这个类用来对用户的活动信息进行管理，解析如下： 12345678910111213141516@interface CMMotionActivityManager : NSObject//活动数据是否可用+ (BOOL)isActivityAvailable;//进行用户权限的申请+ (CMAuthorizationStatus)authorizationStatus;//请求某一段时间内的用户活动信息- (void)queryActivityStartingFromDate:(NSDate *)start toDate:(NSDate *)end toQueue:(NSOperationQueue *)queue withHandler:(CMMotionActivityQueryHandler)handler;//开始进行用户活动信息的更新- (void)startActivityUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMMotionActivityHandler)handler;//停止用户活动信息的更新- (void)stopActivityUpdates;@end CMMotionActivity是用户活动信息的具体记录: 12345678910111213141516171819202122232425@interface CMMotionActivity : CMLogItem//数据的可信度/*typedef NS_ENUM(NSInteger, CMMotionActivityConfidence) &#123; CMMotionActivityConfidenceLow = 0, //可信度低 CMMotionActivityConfidenceMedium, //可信度中 CMMotionActivityConfidenceHigh //可信度高&#125;;*/@property(readonly, nonatomic) CMMotionActivityConfidence confidence;//记录开始时间@property(readonly, nonatomic) NSDate *startDate;//是否是位置状态 如果是 可能关机状态@property(readonly, nonatomic) BOOL unknown;//设备是否没有移动@property(readonly, nonatomic) BOOL stationary;//设备持有者是否在步行@property(readonly, nonatomic) BOOL walking;//设备持有者是否在跑步@property(readonly, nonatomic) BOOL running;//设备持有者是否在乘车@property(readonly, nonatomic) BOOL automotive;//设备持有者是否在骑自行车@property(readonly, nonatomic) BOOL cycling;@end 六、用户手臂动作分析在iOS 12系统后，CoreMotion框架中又引入了一些列配合iWatch进行用户手臂动作分析的类，可以分析出用户是否发生了运动障碍等。其主要由CMMovementDisorderManager类进行管理，如下： 12345678910111213141516@interface CMMovementDisorderManager : NSObject//运动障碍管理类是否可用+ (BOOL)isAvailable;//进行用户权限的请求+ (CMAuthorizationStatus)authorizationStatus;//记录和计算一段时间内的震颤和运动异常结果- (void)monitorKinesiasForDuration:(NSTimeInterval)duration;//获取一段时间内的运动障碍记录数据- (void)queryDyskineticSymptomFromDate:(NSDate *)fromDate toDate:(NSDate *)toDate withHandler:(CMDyskineticSymptomResultHandler)handler;//获取一段时间内的震颤记录数据- (void)queryTremorFromDate:(NSDate *)fromDate toDate:(NSDate *)toDate withHandler:(CMTremorResultHandler)handler;//最后一次更新数据的时间- (NSDate * _Nullable)lastProcessedDate;//最后一次计算数据的过期时间- (NSDate * _Nullable)monitorKinesiasExpirationDate;@end CMDyskineticSymptomResult运动障碍数据模型： 12345678910@interface CMDyskineticSymptomResult : NSObject &lt;NSCopying, NSSecureCoding&gt;//记录数据的开始时间@property (copy, nonatomic, readonly) NSDate *startDate;//记录数据的结束时间@property (copy, nonatomic, readonly) NSDate *endDate;//运动异常可能出现的百分比 @property (nonatomic, readonly) float percentUnlikely;//正常的百分比@property (nonatomic, readonly) float percentLikely;@end CMTremorResult记录用户震颤数据： 1234567891011121314151617@interface CMTremorResult : NSObject &lt;NSCopying, NSSecureCoding&gt;//数据记录开始时间@property (copy, nonatomic, readonly) NSDate *startDate;//数据记录结束时间@property (copy, nonatomic, readonly) NSDate *endDate;//无法确定的时间百分比@property (nonatomic, readonly) float percentUnknown;//未检测到震颤的时间百分比@property (nonatomic, readonly) float percentNone;//可能发生震颤的百分比低 微震颤@property (nonatomic, readonly) float percentSlight;//可能发生震颤的百分比高 微震颤@property (nonatomic, readonly) float percentMild;//可能发生震颤的百分比高 中等震颤@property (nonatomic, readonly) float percentModerate;//可能发生震颤的百分比高 高震颤@property (nonatomic, readonly) float percentStrong; 七、计步器应用在iOS 8之后，CoreMotion中引入了CMPedometer相关计步器类，这些类封装的更加应用层，开发者可以直接获取用户步数相关数据，CMPedometer是管理类，解析如下： 1234567891011121314151617181920212223242526272829@interface CMPedometer : NSObject//计步器是否可用+ (BOOL)isStepCountingAvailable;//距离检测是否可用+ (BOOL)isDistanceAvailable;//楼层检测是否可用+ (BOOL)isFloorCountingAvailable;//速度估算是否支持+ (BOOL)isPaceAvailable;//频率估算是否支持+ (BOOL)isCadenceAvailable;//计步器功能是否支持+ (BOOL)isPedometerEventTrackingAvailable;//进行用户权限申请+ (CMAuthorizationStatus)authorizationStatus;//请求一段时间的计步器数据- (void)queryPedometerDataFromDate:(NSDate *)start toDate:(NSDate *)end withHandler:(CMPedometerHandler)handler;//请求从某个时间至今的计步器数据- (void)startPedometerUpdatesFromDate:(NSDate *)start withHandler:(CMPedometerHandler)handler;//停止计步器数据更新- (void)stopPedometerUpdates;//开始更新计步器事件- (void)startPedometerEventUpdatesWithHandler:(CMPedometerEventHandler)handler;//停止更新计数器事件- (void)stopPedometerEventUpdates;@end CMPedometerEvent类记录计步器的事件变化： 1234567891011@interface CMPedometerEvent : NSObject &lt;NSSecureCoding, NSCopying&gt;//记录数据的时间@property(readonly, nonatomic) NSDate *date;/*typedef NS_ENUM(NSInteger, CMPedometerEventType) &#123; CMPedometerEventTypePause, //计步器暂停 CMPedometerEventTypeResume //计步器恢复&#125;*/@property(readonly, nonatomic) CMPedometerEventType type;@end CMPedometerData计步器数据类： 1234567891011121314151617181920@interface CMPedometerData//记录开始时间@property(readonly, nonatomic) NSDate *startDate;//记录结束时间@property(readonly, nonatomic) NSDate *endDate;//步数@property(readonly, nonatomic) NSNumber *numberOfSteps;//距离@property(readonly, nonatomic, nullable) NSNumber *distance;//通过楼梯上升的楼层数@property(readonly, nonatomic, nullable) NSNumber *floorsAscended;//通过楼梯下降的楼层数@property(readonly, nonatomic, nullable) NSNumber *floorsDescended;//估算速度@property(readonly, nonatomic, nullable) NSNumber *currentPace;//步数频率@property(readonly, nonatomic, nullable) NSNumber *currentCadence;//平均速度@property(readonly, nonatomic, nullable) NSNumber *averageActivePace;@end 在CoreMotion中，CMStepCounter也是一个记录器类，其比较简易，只在iOS8之前进行使用，解析如下： 123456789101112131415@interface CMStepCounter : NSObject//计步器是否可用+ (BOOL)isStepCountingAvailable;//请求一段时间内的步数信息- (void)queryStepCountStartingFrom:(NSDate *)start to:(NSDate *)end toQueue:(NSOperationQueue *)queue withHandler:(CMStepQueryHandler)handler;//进行不是更新- (void)startStepCountingUpdatesToQueue:(NSOperationQueue *)queue updateOn:(NSInteger)stepCounts withHandler:(CMStepUpdateHandler)handler;//停止计步器更新- (void)stopStepCountingUpdates;@end","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之CoreLocation框架使用","slug":"387iOS开发之CoreLocation框架使用","date":"2018-12-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.381Z","comments":true,"path":"2018/12/26/387iOS开发之CoreLocation框架使用/","link":"","permalink":"http://huishao.cc/2018/12/26/387iOS开发之CoreLocation框架使用/","excerpt":"","text":"iOS开发之CoreLocation框架使用CoreLocation框架是iOS开发中比较基础的一个位置信息相关框架，关于定位和地图，之前也有博客多详细的介绍。但是对于CoreLocation框架，并没有完整和细致的记录。本篇博客将剖析这个框架的结构并进行应用示例。下图为CoreLocation框架的相关类布局图： 从图中可以看到，在CoreLocation框架中除了一些数据模型，CLLocationManager作用最为重要，它是整个框架的管理中心，从图中也可以看出，CoreLocation框架功能也非常完善，常规定位，方向信息获取，室内定位，GEO编码等功能都支持。 一、CLLocationManager管理类详解CLLocationManager作为整个CoreLocation框架的核心管理类，其第一部分功能是获取设备的功能可用性，如下： 1234567891011121314//获取位置服务是否可用+ (BOOL)locationServicesEnabled;//获取方向信息服务是否可用+ (BOOL)headingAvailable;//获取设备是否支持显著位置更改的监听+ (BOOL)significantLocationChangeMonitoringAvailable;//获取是否支持针对某种位置区域改变的监听+ (BOOL)isMonitoringAvailableForClass:(Class)regionClass;//获取是否支持区域监听 同上面一个函数作用一致+ (BOOL)regionMonitoringAvailable;//获取区域监听是否可用 除了设备支持 还需要 用户授权+ (BOOL)regionMonitoringEnabled;//获取是否支持测距+ (BOOL)isRangingAvailable; 在使用CLLocationManager的服务之前，首先需要获取用户的授权，在iOS8之后，还需要在info.plist中添加相关的键，如下： 上面标出的3个键，只需要设置一个，根据自己的定位要求来选择即可。 下面列出了与用户授权相关的方法： 123456789101112131415//获取当前用户授权类型/*CLAuthorizationStatus枚举如下：kCLAuthorizationStatusNotDetermined 用户目前还没有选择kCLAuthorizationStatusRestricted 当前应用尚未授权kCLAuthorizationStatusDenied 用户拒绝使用位置服务kCLAuthorizationStatusAuthorizedAlways 用户授权始终可以使用位置服务kCLAuthorizationStatusAuthorizedWhenInUse 用户授权可以在APP使用时使用位置kCLAuthorizationStatusAuthorized 用户授权使用位置 iOS8之前*/+ (CLAuthorizationStatus)authorizationStatus;//请求在APP使用时使用用户的位置信息- (void)requestWhenInUseAuthorization;//请求始终使用用户的位置信息- (void)requestAlwaysAuthorization; 下面列举了CLLocationManager中核心的属性和方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//设置代理@property(assign, nonatomic, nullable) id&lt;CLLocationManagerDelegate&gt; delegate;//定位服务是否可用@property(readonly, nonatomic) BOOL locationServicesEnabled;//位置服务的用途，目前这个属性不再使用，在info.plist中配置@property(copy, nonatomic, nullable) NSString *purpose;//指定定位活动的行为/*CLActivityTypeAutomotiveNavigation 汽车导航CLActivityTypeFitness 步行CLActivityTypeOtherNavigation 其他导航 如火车 轮船CLActivityTypeAirborne 飞机导航CLActivityTypeOther 其他类型*/@property(assign, nonatomic) CLActivityType activityType;//设置以米为单位的精度，当小于此精度的位置改变不会收到通知CLLocationDistance就是double类型@property(assign, nonatomic) CLLocationDistance distanceFilter;//设置预期的定位精度CLLocationAccuracy为double类型 不一定完全精准 只是设置预期@property(assign, nonatomic) CLLocationAccuracy desiredAccuracy;//设置是否自动暂停位置更新 根据电量等@property(assign, nonatomic) BOOL pausesLocationUpdatesAutomatically;//设置是否在后台一直更新定位@property(assign, nonatomic) BOOL allowsBackgroundLocationUpdates;//当后台定位时 是否显示活动指示器 在状态栏上@property(assign, nonatomic) BOOL showsBackgroundLocationIndicator;//最近的一次位置信息@property(readonly, nonatomic, copy, nullable) CLLocation *location;//是否支持方向@property(readonly, nonatomic) BOOL headingAvailable;//设置最小方向更新精度@property(assign, nonatomic) CLLocationDegrees headingFilter;//用来作为参考的物理设备方向/* CLDeviceOrientationUnknown , CLDeviceOrientationPortrait, CLDeviceOrientationPortraitUpsideDown, CLDeviceOrientationLandscapeLeft, CLDeviceOrientationLandscapeRight, CLDeviceOrientationFaceUp, CLDeviceOrientationFaceDown*/@property(assign, nonatomic) CLDeviceOrientation headingOrientation;//最近一次更新的方向信息@property(readonly, nonatomic, copy, nullable) CLHeading *heading;//设置最大的区域监听范围@property (readonly, nonatomic) CLLocationDistance maximumRegionMonitoringDistance;//一组目前正在监听的范围集合@property (readonly, nonatomic, copy) NSSet&lt;__kindof CLRegion *&gt; *monitoredRegions;//返回一组支持测距的范围@property (readonly, nonatomic, copy) NSSet&lt;__kindof CLRegion *&gt; *rangedRegions;//开始更新位置信息- (void)startUpdatingLocation;//停止更新位置信息- (void)stopUpdatingLocation;//请求一次位置信息- (void)requestLocation;//开始更新方向信息- (void)startUpdatingHeading;//停止更新方向信息- (void)stopUpdatingHeading;//取消航向校准- (void)dismissHeadingCalibrationDisplay;//开始显著位置变化的监听- (void)startMonitoringSignificantLocationChanges;//停止线束位置变化的监听- (void)stopMonitoringSignificantLocationChanges;//开启范围监听- (void)startMonitoringForRegion:(CLRegion *)region desiredAccuracy:(CLLocationAccuracy)accuracy;- (void)startMonitoringForRegion:(CLRegion *)region;//停止范围监听- (void)stopMonitoringForRegion:(CLRegion *)region;//获取指定区域的状态 会在代理回调中返回- (void)requestStateForRegion:(CLRegion *)region;//开始计算信标范围 关于Beacon 是一种专门的室内定位服务- (void)startRangingBeaconsInRegion:(CLBeaconRegion *)region;//停止计算信标范围- (void)stopRangingBeaconsInRegion:(CLBeaconRegion *)region;//允许延迟更新 即位置改变了多少距离或者间隔了多少秒后更新- (void)allowDeferredLocationUpdatesUntilTraveled:(CLLocationDistance)distance timeout:(NSTimeInterval)timeout;//不允许进行延迟更新- (void)disallowDeferredLocationUpdates;//设备是否支持延迟更新+ (BOOL)deferredLocationUpdatesAvailable; 二、CLLocationManagerDelegate协议CLLocationManagerDelegate配合CLLocationManager进行使用，其中定义了管理器在提供服务时进行回调的相关函数。解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//位置更新后调用的回调 会将原位置和更新后的位置信息传入- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation;//位置更新后调用的回调 会传入按时间排序的一组位置信息对象- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations;//方向信息更新后调用的回调- (void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading;//返回布尔值设置是否需要进行方向校准- (BOOL)locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)manager;//当监听的区域状态变化时调用/*CLRegionState定义区域的状态CLRegionStateUnknown 未知状态CLRegionStateInside 进入CLRegionStateOutside 出去*/- (void)locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region ;//区域内有新的信标可用时调用- (void)locationManager:(CLLocationManager *)manager didRangeBeacons:(NSArray&lt;CLBeacon *&gt; *)beacons inRegion:(CLBeaconRegion *)region;//区域内的信标测距发生错误时调用- (void)locationManager:(CLLocationManager *)manager rangingBeaconsDidFailForRegion:(CLBeaconRegion *)region withError:(NSError *)error;//进入监听区域时调用- (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region;//退出监听区域时调用- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region;//服务发生错误时调用- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error;//监听区域发生错误时调用- (void)locationManager:(CLLocationManager *)manager monitoringDidFailForRegion:(nullable CLRegion *)region withError:(NSError *)error;//用户授权改变时调用- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status;//开启区域监听时调用- (void)locationManager:(CLLocationManager *)manager didStartMonitoringForRegion:(CLRegion *)region;//暂停位置更新时调用- (void)locationManagerDidPauseLocationUpdates:(CLLocationManager *)manager;//恢复位置更新时调用- (void)locationManagerDidResumeLocationUpdates:(CLLocationManager *)manager;//延迟更新位置信息错误时调用- (void)locationManager:(CLLocationManager *)manager didFinishDeferredUpdatesWithError:(nullable NSError *)error;//如果启用了访问监听 则收到访问会调用- (void)locationManager:(CLLocationManager *)manager didVisit:(CLVisit *)visit; 三、进行GEO编码的工具类CLGeocoder如前所述，使用CLLocationManager获取到的位置信息是CLLocation对象，这个对象封装了经纬度等基础信息，但是在实际开发中，我们往往需要获取到的是位置的更多实际信息，比如国家，省份，城市等等，GEO编码的作用就是通过经纬度信息发起请求，获取现实意义的更多数据。CLGeocoder类解析如下： 123456789101112131415161718192021//是否正在进行GEO编码@property (nonatomic, readonly, getter=isGeocoding) BOOL geocoding;//反地理位置信息编码 /*CLGeocodeCompletionHandler会传回一组标志建筑物*/- (void)reverseGeocodeLocation:(CLLocation *)location completionHandler:(CLGeocodeCompletionHandler)completionHandler;//作用同上 local用来设置区域 可以通过这个参数控制返回的语言- (void)reverseGeocodeLocation:(CLLocation *)location preferredLocale:(nullable NSLocale *)locale completionHandler:(CLGeocodeCompletionHandler)completionHandler;//下面这些方法通常与 AddressBook配合使用//将地址信息字典进行编码 这个方法与AddressBook框架配合使用 AddressBook框架中定义这个字典- (void)geocodeAddressDictionary:(NSDictionary *)addressDictionary completionHandler:(CLGeocodeCompletionHandler)completionHandler;- (void)geocodeAddressString:(NSString *)addressString completionHandler:(CLGeocodeCompletionHandler)completionHandler;- (void)geocodeAddressString:(NSString *)addressString inRegion:(nullable CLRegion *)region completionHandler:(CLGeocodeCompletionHandler)completionHandler;- (void)geocodeAddressString:(NSString *)addressString inRegion:(nullable CLRegion *)region preferredLocale:(nullable NSLocale *)locale completionHandler:(CLGeocodeCompletionHandler)completionHandler;//对邮编地址进行GEO编码- (void)geocodePostalAddress:(CNPostalAddress *)postalAddress completionHandler:(CLGeocodeCompletionHandler)completionHandler;- (void)geocodePostalAddress:(CNPostalAddress *)postalAddress preferredLocale:(nullable NSLocale *)locale completionHandler:(CLGeocodeCompletionHandler)completionHandler;//取消编码- (void)cancelGeocode; 四、位置信息模型CLLocation相关类首先在CoreLocation框架中，位置的经纬度是由CLLocationCoordinate2D结构体描述的，这个结构体定义如下： 1234struct CLLocationCoordinate2D &#123; CLLocationDegrees latitude; //精度 CLLocationDegrees longitude;//维度&#125;; 使用下面的函数可以快速的检查和创建CLLocationCoordinate2D对象： 1234//检查经纬度对象是否有效BOOL CLLocationCoordinate2DIsValid(CLLocationCoordinate2D coord);//创建对象CLLocationCoordinate2D CLLocationCoordinate2DMake(CLLocationDegrees latitude, CLLocationDegrees longitude); CLFloor类是一个用来描述楼层信息的模型，并不一定精准，是基于地面的粗略计算，其中属性如下： 12345@interface CLFloor : NSObject &lt;NSCopying, NSSecureCoding&gt;//楼层 地下室可能为负值@property(readonly, nonatomic) NSInteger level;@end 下面列举了CLLocation中封装的属性的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//初始化方法//通过经纬度初始化 CLLocationDegrees就是double类型- (instancetype)initWithLatitude:(CLLocationDegrees)latitude longitude:(CLLocationDegrees)longitude;//初始化方法/*hAccuracy设置水平方向的精确度verticalAccuracy 设置垂直方向的精确度timestamp 设置时间戳*/- (instancetype)initWithCoordinate:(CLLocationCoordinate2D)coordinate altitude:(CLLocationDistance)altitude horizontalAccuracy:(CLLocationAccuracy)hAccuracy verticalAccuracy:(CLLocationAccuracy)vAccuracy timestamp:(NSDate *)timestamp;/*course设置方向speed 设置速度*/- (instancetype)initWithCoordinate:(CLLocationCoordinate2D)coordinate altitude:(CLLocationDistance)altitude horizontalAccuracy:(CLLocationAccuracy)hAccuracy verticalAccuracy:(CLLocationAccuracy)vAccuracy course:(CLLocationDirection)course speed:(CLLocationSpeed)speed timestamp:(NSDate *)timestamp;//获取位置对象的经纬度信息@property(readonly, nonatomic) CLLocationCoordinate2D coordinate;//获取海波高度@property(readonly, nonatomic) CLLocationDistance altitude;//水平方向精度@property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy;//垂直方向精度@property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy;//方向值 0-360之间@property(readonly, nonatomic) CLLocationDirection course;//速度 单位m/s@property(readonly, nonatomic) CLLocationSpeed speed;//时间戳@property(readonly, nonatomic, copy) NSDate *timestamp;//楼层信息@property(readonly, nonatomic, copy, nullable) CLFloor *floor;//获取到某个位置之间的距离- (CLLocationDistance)getDistanceFrom:(const CLLocation *)location;- (CLLocationDistance)distanceFromLocation:(const CLLocation *)location; 五、航向信息模型CLHeading当使用CLLocationManager进行航向信息的请求时，代理回调中会获取到CLHeading对象，这个对象封装了航向相关数据，解析如下： 1234567891011121314//地磁方向0-360@property(readonly, nonatomic) CLLocationDirection magneticHeading;//地理方向0-360@property(readonly, nonatomic) CLLocationDirection trueHeading;//航向精度@property(readonly, nonatomic) CLLocationDirection headingAccuracy;//x轴测量的原始值@property(readonly, nonatomic) CLHeadingComponentValue x;//y轴测量的原始值@property(readonly, nonatomic) CLHeadingComponentValue y;//z轴测量的原始值@property(readonly, nonatomic) CLHeadingComponentValue z;//时间戳@property(readonly, nonatomic, copy) NSDate *timestamp; 六、地标数据模型CLPlacemarkCLPlacemark是进行GEO编码后返回的地标对象，解析如下： 123456789101112131415161718192021222324252627282930313233343536//初始化方法 使用另一个placemark拷贝- (instancetype)initWithPlacemark:(CLPlacemark *) placemark;//位置信息@property (nonatomic, readonly, copy, nullable) CLLocation *location;//区域范围信息@property (nonatomic, readonly, copy, nullable) CLRegion *region;//时区@property (nonatomic, readonly, copy, nullable) NSTimeZone *timeZone;//地理信息字典@property (nonatomic, readonly, copy, nullable) NSDictionary *addressDictionary;//地标名字@property (nonatomic, readonly, copy, nullable) NSString *name;//街道名字@property (nonatomic, readonly, copy, nullable) NSString *thoroughfare;//子街道名字@property (nonatomic, readonly, copy, nullable) NSString *subThoroughfare;//城镇@property (nonatomic, readonly, copy, nullable) NSString *locality;//子城镇@property (nonatomic, readonly, copy, nullable) NSString *subLocality;//州域信息@property (nonatomic, readonly, copy, nullable) NSString *administrativeArea;//子州域信息@property (nonatomic, readonly, copy, nullable) NSString *subAdministrativeArea;//邮编@property (nonatomic, readonly, copy, nullable) NSString *postalCode;//ISO国家编码@property (nonatomic, readonly, copy, nullable) NSString *ISOcountryCode;//国家@property (nonatomic, readonly, copy, nullable) NSString *country;//水域名称@property (nonatomic, readonly, copy, nullable) NSString *inlandWater;//海洋名称@property (nonatomic, readonly, copy, nullable) NSString *ocean;//相关的兴趣点数组@property (nonatomic, readonly, copy, nullable) NSArray&lt;NSString *&gt; *areasOfInterest; 在CLPlacemark对象中有封装region对象，这个对象封装区域信息，如下： 1234567891011121314//通过中心点和半径创建区域- (instancetype)initCircularRegionWithCenter:(CLLocationCoordinate2D)center radius:(CLLocationDistance)radius identifier:(NSString *)identifier;//区域中心@property (readonly, nonatomic) CLLocationCoordinate2D center;//半径@property (readonly, nonatomic) CLLocationDistance radius;//进入区域是否发出提醒 需要开启了位置区域监听@property (nonatomic, assign) BOOL notifyOnEntry;//离开区域是否发出提醒 需要开启了位置区域监听@property (nonatomic, assign) BOOL notifyOnExit;//检查某个点是否在区域内- (BOOL)containsCoordinate:(CLLocationCoordinate2D)coordinate; CLRegion类还有两个子类，CLCircularRegion类用来创建圆形区域，提供了一个便捷的初始化方法，其作用和CLRegion基本一致。CLBeaconRegion专门用来支持Beacon技术，Beacon技术是室内定位技术的一种，例如商场中有很多店铺，如果有店铺部署了Beacon发射设备，则当iOS设备作为接收设备靠近时会受到通知。CLBeaconRegion除了包含基础的区域信息外，还封装了与Beacon设备相关的设备码等信息。 七、区域访问功能在iOS8之前，如果我们想获取用户是否在某个区域停留了一段时间是比较困难的，可能要多次定位并进行整理和分析。在iOS8后，CoreLocation框架中提供了方便的方法来处理这个问题。 首先，用户的区域停留可以理解为用户对某个区域进行了访问，开启和关闭访问监听十分方便，如下： 123456@interface CLLocationManager (CLVisitExtensions)//开启服务- (void)startMonitoringVisits;//关闭服务- (void)stopMonitoringVisits;@end 开启后，当有相关的访问信息时，会回调代理中的相应函数，并且收到CLVisit对象，这个对象信息如下： 12345678//访问开始时间@property (nonatomic, readonly, copy) NSDate *arrivalDate;//访问结束时间@property (nonatomic, readonly, copy) NSDate *departureDate;//位置@property (nonatomic, readonly) CLLocationCoordinate2D coordinate;//精度@property (nonatomic, readonly) CLLocationAccuracy horizontalAccuracy; 热爱技术，热爱生活，写代码，交朋友 珲少 QQ：316045346","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之CoreImage框架使用","slug":"386iOS开发之CoreImage框架使用","date":"2018-12-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.381Z","comments":true,"path":"2018/12/22/386iOS开发之CoreImage框架使用/","link":"","permalink":"http://huishao.cc/2018/12/22/386iOS开发之CoreImage框架使用/","excerpt":"","text":"iOS开发之CoreImage框架使用CoreImage框架是一个专门用来对图片进行处理的框架，其中提供了许多高级功能，可以帮助开发者完成UIKit或者CoreGraphics框架无法完成的任务，并且使用CoreImage框架可以十分轻松的实现滤镜以及图像识别等流行技术。本篇博客主要介绍和总结CoreImage框架的使用，并提供范例代码。 一、图像过滤器1.几组内置的过滤器CIFilter是CoreImage中提供的图像过滤器，也可以将其理解为滤镜。许多美颜应用，图像处理应用等都是为原图添加了滤镜效果。本节我们着重看下与这个类相关的应用。首先，CoreImaghe默认提供了非常多的滤镜效果，但是并没有详细的文档介绍，有关滤镜效果可以分为下面几个类别： 12345678910111213141516171819202122232425262728293031323334353637383940//通过改变图像的几何形状来创建3D效果，类似隆起 过滤器组NSString * const kCICategoryDistortionEffect;//旋转扭曲相关过滤器组NSString * const kCICategoryGeometryAdjustment;//混合过滤器组 对两个图像进行混合操作NSString * const kCICategoryCompositeOperation;//一种色调过滤器组 类似报纸风格NSString * const kCICategoryHalftoneEffect;//颜色过滤器组 调整对比度 亮度等NSString * const kCICategoryColorEffect;//多个图像源的过滤器NSString * const kCICategoryTransition;//平铺图像过滤器NSString * const kCICategoryTileEffect;//滤光类过滤器 通常作为其他过滤器的输入NSString * const kCICategoryGenerator;//减弱图像数据的过滤器 通常用来进行图像分析NSString * const kCICategoryReduction;//渐变过滤器 NSString * const kCICategoryGradient;//画像过滤器NSString * const kCICategoryStylize;//锐化过滤器NSString * const kCICategorySharpen;//模糊过滤器NSString * const kCICategoryBlur;//视频图片相关过滤器NSString * const kCICategoryVideo;//静态图片相关过滤器NSString * const kCICategoryStillImage;//交叉图像过滤器NSString * const kCICategoryInterlaced;//非矩形图像上的过滤器NSString * const kCICategoryNonSquarePixels;//高动态图像的过滤器NSString * const kCICategoryHighDynamicRange;//CoreImage内置的过滤器NSString * const kCICategoryBuiltIn;//复合的过滤器NSString * const kCICategoryFilterGenerator; 上面列出了非常多的类别，其实上面只是按照不同的场景将过滤器进行了分类，每个分类中都定义了许多内置的过滤器，使用下面的方法可以获取每个分类下提供的过滤器： 1234//获取某个分类的所有过滤器名+ (NSArray&lt;NSString *&gt; *)filterNamesInCategory:(nullable NSString *)category;//获取一组分类下的所有过滤器名+ (NSArray&lt;NSString *&gt; *)filterNamesInCategories:(nullable NSArray&lt;NSString *&gt; *)categories; 2.过滤器的一个简单示例下面示例代码演示过滤器的简单应用： 123456789101112131415UIImage * img = [UIImage imageNamed:@\"1.png\"];CIImage * image = [[CIImage alloc]initWithImage:img];CIFilter * filter = [CIFilter filterWithName:@\"CIBoxBlur\" keysAndValues:kCIInputImageKey,image, nil];[filter setDefaults];CIContext * context = [[CIContext alloc]initWithOptions:nil];CIImage * output = [filter outputImage];CGImageRef ref = [context createCGImage:output fromRect:[output extent]];UIImage * newImage = [UIImage imageWithCGImage:ref];CGImageRelease(ref);UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(170, 30, 150, 400)];imageView.image = newImage;[self.view addSubview:imageView]; UIImageView * imageView2 = [[UIImageView alloc]initWithFrame:CGRectMake(0, 30, 150, 400)];imageView2.image = img;[self.view addSubview:imageView2]; 效果如下图： 上面演示了简单的模糊过滤效果。 3.对CIFilter类进行解析CIFilter类的解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//过滤后输出的图像@property (readonly, nonatomic, nullable) CIImage *outputImage;//过滤器名称@property (nonatomic, copy) NSString *name;//是否开启CoreAnimation动画效果@property (getter=isEnabled) BOOL enabled;//返回当前过滤器所有支持的输入键@property (nonatomic, readonly) NSArray&lt;NSString *&gt; *inputKeys;//返回当前过滤器所有支持的输出键@property (nonatomic, readonly) NSArray&lt;NSString *&gt; *outputKeys;//将过滤器的所有输入值设置为默认值- (void)setDefaults;//返回当前过滤器的属性字段/*需要注意这个字段对于学习此过滤器非常有用其中会声明此过滤器的输入和输出 即如果使用*/@property (nonatomic, readonly) NSDictionary&lt;NSString *,id&gt; *attributes;//用来进行过滤器的自定义 后面会介绍- (nullable CIImage *)apply:(CIKernel *)k arguments:(nullable NSArray *)args options:(nullable NSDictionary&lt;NSString *,id&gt; *)dict;//同上- (nullable CIImage *)apply:(CIKernel *)k, ...;//根据过滤器的名称创建过滤器+ (nullable CIFilter *) filterWithName:(NSString *) name;//创建过滤器 同时进行配置+ (nullable CIFilter *)filterWithName:(NSString *)name keysAndValues:key0, ...;+ (nullable CIFilter *)filterWithName:(NSString *)name withInputParameters:(nullable NSDictionary&lt;NSString *,id&gt; *)params;//注册过滤器+ (void)registerFilterName:(NSString *)name constructor:(id&lt;CIFilterConstructor&gt;)anObject classAttributes:(NSDictionary&lt;NSString *,id&gt; *)attributes;//将一组过滤器进行编码+ (nullable NSData*)serializedXMPFromFilters:(NSArray&lt;CIFilter *&gt; *)filters inputImageExtent:(CGRect)extent;//进行反编码+ (NSArray&lt;CIFilter *&gt; *)filterArrayFromSerializedXMP:(NSData *)xmpData inputImageExtent:(CGRect)extent error:(NSError **)outError; 4.常用过滤器详解 区域凸起过滤器 这个过滤器的作用是在图片的某个区域创建一块凸起。示例代码如下： 123456/*kCIInputCenterKey键用来设置滤镜中心kCIInputScaleKey 设置为0则没有影响 1则会凸起效果 -1则会凹入效果kCIInputRadiusKey 设置滤镜的影响范围*/CIFilter * filter = [CIFilter filterWithName:@\"CIBumpDistortion\" keysAndValues:kCIInputImageKey,image,kCIInputCenterKey,[[CIVector alloc] initWithX:100 Y:200],kCIInputScaleKey,@-1,kCIInputRadiusKey,@150, nil]; 效果如下： 线性凹凸过滤器 这个过滤器创建类似波纹效果，示例如下： 12345/*与上一个过滤器相比 可以设置kCIInputAngleKey 角度 0-2π*/CIFilter * filter = [CIFilter filterWithName:@\"CIBumpDistortionLinear\" keysAndValues:kCIInputImageKey,image,kCIInputCenterKey,[[CIVector alloc] initWithX:100 Y:200],kCIInputScaleKey,@-1,kCIInputRadiusKey,@150,kCIInputAngleKey,@(M_PI_2), nil]; 效果如下： 圆形飞溅过滤器 这个过滤器的作用是选取图像的某个区域，对其四周进行飞溅拉伸，例如： 1CIFilter * filter = [CIFilter filterWithName:@\"CICircleSplashDistortion\" keysAndValues:kCIInputImageKey,image,kCIInputCenterKey,[[CIVector alloc] initWithX:100 Y:200],kCIInputRadiusKey,@50, nil]; 效果如下： 圆形缠绕过滤器 这个过滤器选取某个区域，进行缠绕效果，例如： 1CIFilter * filter = [CIFilter filterWithName:@\"CICircularWrap\" keysAndValues:kCIInputImageKey,image,kCIInputCenterKey,[[CIVector alloc] initWithX:100 Y:200],kCIInputRadiusKey,@20, kCIInputAngleKey,@3,nil]; 效果如下： 灰度混合过滤器 这个过滤器将提供混合图像的灰度值应用于目标图像，例如： 1234/*inputDisplacementImage设置要混合的灰度图片*/CIFilter * filter = [CIFilter filterWithName:@\"CIDroste\" keysAndValues:kCIInputImageKey,image,kCIInputScaleKey,@200,@\"inputDisplacementImage\",image2,nil]; 效果如下： 递归绘制图像区域 1CIFilter * filter = [CIFilter filterWithName:@\"CIDroste\" keysAndValues:kCIInputImageKey,image,@\"inputInsetPoint0\",[[CIVector alloc] initWithX:100 Y:100],@\"inputInsetPoint1\",[[CIVector alloc] initWithX:200 Y:200],@\"inputPeriodicity\",@1,@\"inputRotation\",@0,@\"inputStrands\",@1,@\"inputZoom\",@1,nil]; 效果如下： 玻璃纹理过滤器 这个过滤器用提供图片作为目标图片的纹理，进行混合，例如： 1234/*inputTexture设置纹理图像*/CIFilter * filter = [CIFilter filterWithName:@\"CIGlassDistortion\" keysAndValues:kCIInputImageKey,image,kCIInputCenterKey,[[CIVector alloc] initWithX:100 Y:200],kCIInputScaleKey,@100,@\"inputTexture\",image2,nil]; 效果如下： 菱形透镜过滤器 1234567/*inputPoint0设置第一个圆的圆心inputPoint1设置第二个圆的圆心inputRadius设置半径inputRefraction设置折射率 0-5之间*/CIFilter * filter = [CIFilter filterWithName:@\"CIGlassLozenge\" keysAndValues:kCIInputImageKey,image,@\"inputPoint0\",[[CIVector alloc] initWithX:100 Y:200],@\"inputPoint1\",[[CIVector alloc] initWithX:200 Y:200],@\"inputRadius\",@100,@\"inputRefraction\",@2,nil]; 效果如下： 圆孔形变过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIHoleDistortion\" keysAndValues:kCIInputImageKey,image,@\"inputRadius\",@50,kCIInputCenterKey,[[CIVector alloc] initWithX:100 Y:200],nil]; 效果如下： 九宫格拉伸过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CINinePartStretched\" keysAndValues:kCIInputImageKey,image2,@\"inputBreakpoint0\",[[CIVector alloc] initWithX:50 Y:50],@\"inputBreakpoint1\",[[CIVector alloc] initWithX:100 Y:100],@\"inputGrowAmount\",[[CIVector alloc] initWithX:50 Y:50],nil]; 效果如下： 九宫格复制过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CINinePartTiled\" keysAndValues:kCIInputImageKey,image2,@\"inputBreakpoint0\",[[CIVector alloc] initWithX:50 Y:50],@\"inputBreakpoint1\",[[CIVector alloc] initWithX:100 Y:100],@\"inputGrowAmount\",[[CIVector alloc] initWithX:50 Y:50],@\"inputFlipYTiles\",@1,nil]; 效果如下： 紧缩过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIPinchDistortion\" keysAndValues:kCIInputImageKey,image2,@\"inputCenter\",[[CIVector alloc] initWithX:150 Y:150],@\"inputRadius\",@500,@\"inputScale\",@1,nil]; 效果如下： 拉伸裁剪过滤器 1234/*inputSize 设置拉伸裁剪尺寸*/CIFilter * filter = [CIFilter filterWithName:@\"CIStretchCrop\" keysAndValues:kCIInputImageKey,image2,@\"inputCenterStretchAmount\",@1,@\"inputCropAmount\",@0.5,@\"inputSize\",[[CIVector alloc] initWithX:300 Y:150],nil]; 效果如下： 环状透镜过滤器 这个过滤器创建一个环状透镜，对图像进行扭曲。 1234567/*inputCenter设置环中心inputRadius 设置半径inputRefraction 设置折射率inputWidth 设置环宽度*/CIFilter * filter = [CIFilter filterWithName:@\"CITorusLensDistortion\" keysAndValues:kCIInputImageKey,image2,@\"inputCenter\",[[CIVector alloc] initWithX:150 Y:150],@\"inputRadius\",@150,@\"inputRefraction\",@1.6,@\"inputWidth\",@40,nil]; 效果如下： 旋转过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CITwirlDistortion\" keysAndValues:kCIInputImageKey,image2,@\"inputAngle\",@3.14,@\"inputCenter\",[[CIVector alloc] initWithX:150 Y:150],@\"inputRadius\",@150,nil]; 效果如下： 涡流过滤器 12//inputAngle 设置涡流角度CIFilter * filter = [CIFilter filterWithName:@\"CIVortexDistortion\" keysAndValues:kCIInputImageKey,image2,@\"inputAngle\",@(M_PI*10),@\"inputCenter\",[[CIVector alloc] initWithX:150 Y:150],@\"inputRadius\",@150,nil]; 效果如下： 形变过滤器 这个过滤器对图像进行简单的形变处理，如缩放，旋转，平移等。 12CGAffineTransform tr = CGAffineTransformMakeRotation(M_PI_2);CIFilter * filter = [CIFilter filterWithName:@\"CIAffineTransform\" keysAndValues:kCIInputImageKey,image2,@\"inputTransform\",[NSValue valueWithCGAffineTransform:tr],nil]; 效果如下： 矩形裁剪过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CICrop\" keysAndValues:kCIInputImageKey,image2,@\"inputRectangle\",[[CIVector alloc] initWithCGRect:CGRectMake(0, 0, 150, 150)],nil]; 效果如下： 边缘采样过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIEdgePreserveUpsampleFilter\" keysAndValues:kCIInputImageKey,image,@\"inputLumaSigma\",@0.15,@\"inputSpatialSigma\",@3,@\"inputSmallImage\",image2,nil]; 效果如下： 矩形矫正过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIPerspectiveCorrection\" keysAndValues:kCIInputImageKey,image2,@\"inputBottomLeft\",[[CIVector alloc] initWithX:0 Y:0],@\"inputBottomRight\",[[CIVector alloc] initWithX:150 Y:0],@\"inputTopLeft\",[[CIVector alloc] initWithX:0 Y:150],@\"inputTopRight\",[[CIVector alloc] initWithX:150 Y:150],nil]; 效果如图： 旋转矫正过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIStraightenFilter\" keysAndValues:kCIInputImageKey,image2,@\"inputAngle\",@3.14,nil]; 效果如下： 背景混合过滤器 通过提供一个图像作为背景与目标图像进行混合。 1CIFilter * filter = [CIFilter filterWithName:@\"CIAdditionCompositing\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 色彩混合过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIColorBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 暗混合过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIColorBurnBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 亮混合过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIColorDodgeBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 暗选择混合模式过滤器 这个过滤器将选择较暗的图像作为混合背景，例如： 1CIFilter * filter = [CIFilter filterWithName:@\"CIDarkenBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 亮选择混合模式过滤器 这个过滤器将选择较亮的图像作为混合背景，例如： 1CIFilter * filter = [CIFilter filterWithName:@\"CIDifferenceBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 分开混合模式过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIDivideBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 排除混合模式过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIExclusionBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 强光混合模式过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIHardLightBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 色调混合模式过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIHueBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 减轻混合模式过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CILightenBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 线性燃烧混合模式过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CILinearBurnBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 线性高亮混合过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CILinearDodgeBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 亮度混合过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CILuminosityBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 最大值混合过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIMaximumCompositing\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 最小值混合过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIMinimumCompositing\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 多重混合过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIMultiplyBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 效果如下： 多重合成过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIMultiplyCompositing\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 重叠混合模式 1CIFilter * filter = [CIFilter filterWithName:@\"CIOverlayBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 亮混合模式 1CIFilter * filter = [CIFilter filterWithName:@\"CIPinLightBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 饱和混合模式 1CIFilter * filter = [CIFilter filterWithName:@\"CISaturationBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 屏幕混合模式 1CIFilter * filter = [CIFilter filterWithName:@\"CIScreenBlendMode\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 源图像上层混合 1CIFilter * filter = [CIFilter filterWithName:@\"CISourceAtopCompositing\" keysAndValues:kCIInputImageKey,image2,@\"inputBackgroundImage\",image,nil]; 圆屏过滤器 12345/*inputSharpness 设置圆圈锐度inputWidth 设置间距*/CIFilter * filter = [CIFilter filterWithName:@\"CICircularScreen\" keysAndValues:kCIInputImageKey,image2,kCIInputCenterKey,[[CIVector alloc] initWithX:150 Y:150],@\"inputSharpness\",@0.7,@\"inputWidth\",@6,nil]; 半色调过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CICMYKHalftone\" keysAndValues:kCIInputImageKey,image2,@\"inputAngle\",@0,kCIInputCenterKey,[[CIVector alloc] initWithX:150 Y:150],@\"inputGCR\",@1,@\"inputSharpness\",@0.7,@\"inputUCR\",@0.5,@\"inputWidth\",@6,nil]; 点屏过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIDotScreen\" keysAndValues:kCIInputImageKey,image2,@\"inputAngle\",@0,kCIInputCenterKey,[[CIVector alloc] initWithX:150 Y:150],@\"inputSharpness\",@0.7,@\"inputWidth\",@6,nil]; 阴影屏过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIHatchedScreen\" keysAndValues:kCIInputImageKey,image2,@\"inputAngle\",@0,kCIInputCenterKey,[[CIVector alloc] initWithX:150 Y:150],@\"inputSharpness\",@0.7,@\"inputWidth\",@6,nil]; 线性sRGB过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CILinearToSRGBToneCurve\" keysAndValues:kCIInputImageKey,image2,nil]; 色彩翻转过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIColorInvert\" keysAndValues:kCIInputImageKey,image2,nil]; 色图过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIColorMap\" keysAndValues:kCIInputImageKey,image2,@\"inputGradientImage\",image,nil]; 单色过滤器 12345/*inputColor 设置输入颜色inputIntensity 设置影响程度*/CIFilter * filter = [CIFilter filterWithName:@\"CIColorMonochrome\" keysAndValues:kCIInputImageKey,image2,@\"inputColor\",[CIColor colorWithRed:0.5 green:0.5 blue:0.5],@\"inputIntensity\",@1,nil]; 分色镜过滤器 1234/*inputLevels设置亮度级别*/CIFilter * filter = [CIFilter filterWithName:@\"CIColorPosterize\" keysAndValues:kCIInputImageKey,image2,@\"inputLevels\",@6,nil]; 反色过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIFalseColor\" keysAndValues:kCIInputImageKey,image2,@\"inputColor0\",[CIColor colorWithRed:0 green:0 blue:0],@\"inputColor1\",[CIColor colorWithRed:1 green:1 blue:0],nil]; 光效褪色过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIPhotoEffectFade\" keysAndValues:kCIInputImageKey,image2,nil]; 光效瞬时过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIPhotoEffectInstant\" keysAndValues:kCIInputImageKey,image2,nil]; 光效单光过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIPhotoEffectMono\" keysAndValues:kCIInputImageKey,image2,nil]; 黑色光效应过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIPhotoEffectNoir\" keysAndValues:kCIInputImageKey,image2,nil]; 光渐进过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIPhotoEffectProcess\" keysAndValues:kCIInputImageKey,image2,nil]; 光转移过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIPhotoEffectTransfer\" keysAndValues:kCIInputImageKey,image2,nil]; 棕褐色过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CISepiaTone\" keysAndValues:kCIInputImageKey,image2,nil]; 热图过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIThermal\" keysAndValues:kCIInputImageKey,image2,nil]; X射线过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIXRay\" keysAndValues:kCIInputImageKey,image2,nil]; 模糊过滤器 12//参数进行模糊效果的设置CIFilter * filter = [CIFilter filterWithName:@\"CIBokehBlur\" keysAndValues:kCIInputImageKey,image2,@\"inputSoftness\",@0.5,@\"inputRingSize\",@0.1,@\"inputRingAmount\",@0,@\"inputRadius\",@10,nil]; 盒模糊过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIBoxBlur\" keysAndValues:kCIInputImageKey,image2,@\"inputRadius\",@10,nil]; 阀瓣模糊过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIDiscBlur\" keysAndValues:kCIInputImageKey,image2,@\"inputRadius\",@25,nil]; 高斯模糊过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIGaussianBlur\" keysAndValues:kCIInputImageKey,image2,@\"inputRadius\",@10,nil]; 梯度模糊过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIMorphologyGradient\" keysAndValues:kCIInputImageKey,image2,@\"inputRadius\",@5,nil]; 运动模糊过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIMotionBlur\" keysAndValues:kCIInputImageKey,image2,@\"inputRadius\",@5,nil]; 缩放模糊过滤器 1CIFilter * filter = [CIFilter filterWithName:@\"CIZoomBlur\" keysAndValues:kCIInputImageKey,image2,nil]; 5.自定义过滤器上面演示了非常多的常用内置过滤器，我们也可以通过继承CIFilter来自定义过滤器。 自定义过滤器之前，首先需要了解CIKernel这个类，CIKernel是Core Image Kernel Language 的抽象对象。CIKL是CoreImage中专门用来编写像素处理函数的语言。 CIKernel相关类解析如下： 1234567891011121314151617181920212223242526272829//基类 用于通用的过滤函数@interface CIKernel : NSObject//从字符串加载一组过滤函数+ (nullable NSArray&lt;CIKernel *&gt; *)kernelsWithString:(NSString *)string;//从字符串加载一个过滤函数+ (nullable instancetype)kernelWithString:(NSString *)string ;//名称@property (atomic, readonly) NSString *name ;//进行图片生成- (nullable CIImage *)applyWithExtent:(CGRect)extent roiCallback:(CIKernelROICallback)callback arguments:(nullable NSArray&lt;id&gt; *)args;@end//用于颜色修正的过滤函数@interface CIColorKernel : CIKernel+ (nullable instancetype)kernelWithString:(NSString *)string;- (nullable CIImage *)applyWithExtent:(CGRect)extent arguments:(nullable NSArray&lt;id&gt; *)args;@end//用于形状修正的过滤函数@interface CIWarpKernel : CIKernel+ (nullable instancetype)kernelWithString:(NSString *)string;@end//用于色彩混合的过滤函数@interface CIBlendKernel : CIColorKernel+ (nullable instancetype)kernelWithString:(NSString *)string;- (nullable CIImage *)applyWithForeground:(CIImage*)foreground background:(CIImage*)background;@end 下面是一个简单的翻转图像的自定义过滤器示意，首先新建一个新的cikernel文件，命名为a.cikernel，如下： 1234567kernel vec2 mirrorX ( float imageWidth )&#123;// 获取待处理点的位置vec2 currentVec = destCoord();// 返回最终显示位置return vec2 ( imageWidth - currentVec.x , currentVec.y );&#125; 新建一个过滤器类，命名为MyFilter，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import &lt;CoreImage/CoreImage.h&gt;@interface MyFilter : CIFilter@property(nonatomic,strong)CIImage * inputImage;@end#import \"MyFilter.h\"@interface MyFilter()@property(nonatomic,strong)CIWarpKernel * kernel;@end@implementation MyFilter- (instancetype)init &#123; self = [super init]; if (self) &#123; //从文件读取过滤函数 NSBundle *bundle = [NSBundle bundleForClass: [self class]]; NSURL *kernelURL = [bundle URLForResource:@\"a\" withExtension:@\"cikernel\"]; NSError *error; NSString *kernelCode = [NSString stringWithContentsOfURL:kernelURL encoding:NSUTF8StringEncoding error:&amp;error]; NSArray *kernels = [CIKernel kernelsWithString:kernelCode]; self.kernel = [kernels objectAtIndex:0]; &#125; return self;&#125;- (CIImage *)outputImage&#123; CGFloat inputWidth = self.inputImage.extent.size.width; CIImage *result = [self.kernel applyWithExtent:self.inputImage.extent roiCallback:^CGRect(int index, CGRect destRect) &#123; return destRect; &#125; inputImage:self.inputImage arguments:@[@(inputWidth)]]; return result;&#125;//设置说明字典-(NSDictionary&lt;NSString *,id&gt; *)attributes&#123; return @&#123; @\"inputImage\" : @&#123; @\"CIAttributeClass\" : @\"CIImage\", @\"CIAttributeDisplayName\" : @\"Image--\", @\"CIAttributeType\" : @\"CIAttributeTypeImage\" &#125;&#125;;&#125;@end 如下进行使用即可： 123456MyFilter * filter = [[MyFilter alloc]init];filter.inputImage = image2;CIContext * context = [[CIContext alloc]initWithOptions:nil];CIImage * output = [filter outputImage];CGImageRef ref = [context createCGImage:output fromRect:output.extent];UIImage * newImage = [UIImage imageWithCGImage:ref]; 二、使用CoreImage实现人脸识别人脸识别是目前非常热门的一种图像处理技术，CoreImage内置了对人脸进行识别的相关功能接口，并且可以对人脸面部特征进行抓取，下面我们来实现一个简单的实时识别人脸特征的Demo。 首先创建一个视图作为图像扫描视图，如下： .h文件 123//.h 文件@interface FaceView : UIView@end .m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196//// FaceView.m// CoreImageDemo//// Created by jaki on 2018/12/22.// Copyright © 2018年 jaki. All rights reserved.//#import \"FaceView.h\"#import &lt;AVFoundation/AVFoundation.h&gt;#import \"FaceHandle.h\"//定义线程#define FACE_SCAN_QUEUE \"FACE_SCAN_QUEUE\"@interface FaceView()&lt;AVCaptureVideoDataOutputSampleBufferDelegate&gt;@property(nonatomic,strong)AVCaptureSession *captureSession;@property(nonatomic,strong)AVCaptureDeviceInput * captureInput;@property(nonatomic,strong)AVCaptureVideoDataOutput * captureOutput;@property(nonnull,strong)AVCaptureVideoPreviewLayer * videoLayer;@property(nonatomic,strong)dispatch_queue_t queue;@property(nonatomic,assign)BOOL hasHandle;@property(nonatomic,strong)UIView * faceView;@end@implementation FaceView#pragma mark - Override-(instancetype)init&#123; self = [super init]; if (self) &#123; [self install]; &#125; return self;&#125;-(instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self install]; &#125; return self;&#125;-(void)layoutSubviews&#123; [super layoutSubviews]; self.videoLayer.frame = self.bounds;&#125;#pragma mark - InnerFunc-(void)install&#123; if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) &#123; NSLog(@\"不支持\"); return; &#125; self.queue = dispatch_queue_create(FACE_SCAN_QUEUE, NULL); [self.captureSession startRunning]; AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (status!=AVAuthorizationStatusAuthorized) &#123; NSLog(@\"需要权限\"); return; &#125; self.videoLayer = [AVCaptureVideoPreviewLayer layerWithSession:self.captureSession]; self.videoLayer.frame = CGRectZero; self.videoLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; [self.layer addSublayer:self.videoLayer]; [self addSubview:self.faceView]; self.faceView.frame = CGRectMake(0, 0, self.frame.size.width, self.frame.size.height); &#125;//将人脸特征点标记出来-(void)renderReactWithInfo:(NSDictionary *)info&#123; for (UIView * v in self.faceView.subviews) &#123; [v removeFromSuperview]; &#125; NSArray * faceArray = info[FACE_HANDLE_INFO_FACE_ARRAY]; for (int i = 0;i &lt; faceArray.count; i++) &#123; NSDictionary * face = faceArray[i]; NSValue * faceValue = face[FACE_HANDLE_INFO_FACE_FRAME]; if (faceValue) &#123; CGRect faceR = [faceValue CGRectValue]; UIView * faceView = [[UIView alloc]initWithFrame:faceR]; faceView.backgroundColor = [UIColor clearColor]; faceView.layer.borderColor = [UIColor redColor].CGColor; faceView.layer.borderWidth = 2; [self.faceView addSubview:faceView]; &#125; NSValue * leftEye = face[FACE_HANDLE_INFO_FACE_LEFT_EYE_FRAME]; if (leftEye) &#123; CGRect leftEyeR = [leftEye CGRectValue]; UIView * eye = [[UIView alloc]initWithFrame:leftEyeR]; eye.backgroundColor = [UIColor clearColor]; eye.layer.borderColor = [UIColor greenColor].CGColor; eye.layer.borderWidth = 2; [self.faceView addSubview:eye]; &#125; NSValue * rightEye = face[FACE_HANDLE_INFO_FACE_RIGHT_EYE_FRAME]; if (rightEye) &#123; CGRect rightEyeR = [rightEye CGRectValue]; UIView * eye = [[UIView alloc]initWithFrame:rightEyeR]; eye.backgroundColor = [UIColor clearColor]; eye.layer.borderColor = [UIColor greenColor].CGColor; eye.layer.borderWidth = 2; [self.faceView addSubview:eye]; &#125; NSValue * mouth = face[FACE_HANDLE_INFO_FACE_MOUTH_FRAME]; if (mouth) &#123; CGRect mouthR = [mouth CGRectValue]; UIView * mouth = [[UIView alloc]initWithFrame:mouthR]; mouth.backgroundColor = [UIColor clearColor]; mouth.layer.borderColor = [UIColor orangeColor].CGColor; mouth.layer.borderWidth = 2; [self.faceView addSubview:mouth]; &#125; &#125;&#125;#pragma AVDelegate//进行画面的捕获-(void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection&#123; if (self.hasHandle) &#123; return; &#125; self.hasHandle = YES; CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); CVPixelBufferLockBaseAddress(imageBuffer,0); uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddress(imageBuffer); size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer); size_t width = CVPixelBufferGetWidth(imageBuffer); size_t height = CVPixelBufferGetHeight(imageBuffer); CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef newContext = CGBitmapContextCreate(baseAddress,width, height, 8, bytesPerRow, colorSpace,kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst); CGImageRef newImage = CGBitmapContextCreateImage(newContext); CGContextRelease(newContext); CGColorSpaceRelease(colorSpace); UIImage *image= [UIImage imageWithCGImage:newImage scale:1.0 orientation:UIImageOrientationRight]; CGImageRelease(newImage); //image //进行人脸识别的核心工具类 [[FaceHandle sharedInstance] handleImage:image viewSize:self.frame.size completed:^(BOOL success, NSDictionary *info) &#123; self.hasHandle = NO; [self renderReactWithInfo:info]; &#125;]; CVPixelBufferUnlockBaseAddress(imageBuffer,0);&#125;#pragma mark - setter and getter-(AVCaptureSession *)captureSession&#123; if (!_captureSession) &#123; _captureSession = [[AVCaptureSession alloc]init]; [_captureSession addInput:self.captureInput]; [_captureSession addOutput:self.captureOutput]; &#125; return _captureSession;&#125;-(AVCaptureDeviceInput *)captureInput&#123; if (!_captureInput) &#123; _captureInput = [AVCaptureDeviceInput deviceInputWithDevice:[AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo] error:nil]; &#125; return _captureInput;&#125;-(AVCaptureVideoDataOutput *)captureOutput&#123; if (!_captureOutput) &#123; _captureOutput = [[AVCaptureVideoDataOutput alloc]init]; _captureOutput.alwaysDiscardsLateVideoFrames = YES; [_captureOutput setSampleBufferDelegate:self queue:self.queue]; _captureOutput.videoSettings = @&#123;(__bridge NSString *)kCVPixelBufferPixelFormatTypeKey:@(kCVPixelFormatType_32BGRA)&#125;; &#125; return _captureOutput;&#125;-(UIView *)faceView&#123; if (!_faceView) &#123; _faceView = [[UIView alloc]init]; _faceView.backgroundColor = [UIColor clearColor]; &#125; return _faceView;&#125;@end 在真机上运行工程，通过摄像头可以将实时的画面捕获到屏幕上，下面实现核心的人脸识别代码： 创建继承于NSObject的FaceHandle类，如下： .h文件 1234567891011121314151617extern const NSString * FACE_HANDLE_INFO_FACE_ARRAY;extern const NSString * FACE_HANDLE_INFO_FACE_FRAME;extern const NSString * FACE_HANDLE_INFO_FACE_LEFT_EYE_FRAME;extern const NSString * FACE_HANDLE_INFO_FACE_RIGHT_EYE_FRAME;extern const NSString * FACE_HANDLE_INFO_FACE_MOUTH_FRAME;extern const NSString * FACE_HANDLE_INFO_ERROR;@interface FaceHandle : NSObject+(instancetype)sharedInstance;-(void)handleImage:(UIImage *)image viewSize:(CGSize )viewSize completed:(void(^)(BOOL success,NSDictionary * info))completion;@end .m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#import \"FaceHandle.h\"#define FACE_HANDLE_DISPATCH_QUEUE \"FACE_HANDLE_DISPATCH_QUEUE\"const NSString * FACE_HANDLE_INFO_FACE_FRAME = @\"FACE_HANDLE_INFO_FACE_FRAME\";const NSString * FACE_HANDLE_INFO_FACE_LEFT_EYE_FRAME = @\"FACE_HANDLE_INFO_FACE_LEFT_EYE_FRAME\";const NSString * FACE_HANDLE_INFO_FACE_RIGHT_EYE_FRAME = @\"FACE_HANDLE_INFO_FACE_RIGHT_EYE_FRAME\";const NSString * FACE_HANDLE_INFO_FACE_MOUTH_FRAME = @\"FACE_HANDLE_INFO_FACE_MOUTH_FRAME\";const NSString * FACE_HANDLE_INFO_ERROR = @\"FACE_HANDLE_INFO_ERROR\";const NSString * FACE_HANDLE_INFO_FACE_ARRAY = @\"FACE_HANDLE_INFO_FACE_ARRAY\";@interface FaceHandle()@property(nonatomic,strong)dispatch_queue_t workingQueue;@end@implementation FaceHandle+(instancetype)sharedInstance&#123; static dispatch_once_t onceToken; static FaceHandle * sharedInstance = nil; if (!sharedInstance) &#123; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[FaceHandle alloc] init]; &#125;); &#125; return sharedInstance;&#125;#pragma mark - Override-(instancetype)init&#123; self = [super init]; if (self) &#123; self.workingQueue = dispatch_queue_create(FACE_HANDLE_DISPATCH_QUEUE, NULL); &#125; return self;&#125;#pragma mark - InnerFunc-(void)handleImage:(UIImage *)image viewSize:(CGSize )viewSize completed:(void (^)(BOOL , NSDictionary *))completion&#123; if (!image) &#123; if (completion) &#123; completion(NO,@&#123;FACE_HANDLE_INFO_ERROR:@\"图片捕获出错\"&#125;); &#125; return; &#125; dispatch_async(self.workingQueue, ^&#123; UIImage * newImage = [self strectImage:image withSize:viewSize]; if (newImage) &#123; NSArray * faceArray = [self analyseFaceImage:newImage]; if (completion) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completion(YES,@&#123;FACE_HANDLE_INFO_FACE_ARRAY:faceArray&#125;); &#125;); &#125; &#125;else&#123; if (completion) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completion(NO,@&#123;FACE_HANDLE_INFO_ERROR:@\"图片识别出错\"&#125;); &#125;); &#125; &#125; &#125;);&#125;//图片放大处理-(UIImage *)strectImage:(UIImage *)img withSize:(CGSize)size&#123; UIGraphicsBeginImageContext(size); CGRect thumbnailRect = CGRectZero; thumbnailRect.origin = CGPointMake(0, 0); thumbnailRect.size.width = size.width; thumbnailRect.size.height = size.height; [img drawInRect:thumbnailRect]; UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); if (newImage) &#123; return newImage; &#125; return nil;&#125;-(NSArray *)analyseFaceImage:(UIImage *)image&#123; NSMutableArray * dataArray = [NSMutableArray array]; CIImage * cImage = [CIImage imageWithCGImage:image.CGImage]; NSDictionary* opts = [NSDictionary dictionaryWithObject: CIDetectorAccuracyHigh forKey:CIDetectorAccuracy]; //进行分析 CIDetector* detector = [CIDetector detectorOfType:CIDetectorTypeFace context:nil options:opts]; //获取特征数组 NSArray* features = [detector featuresInImage:cImage]; CGSize inputImageSize = [cImage extent].size; CGAffineTransform transform = CGAffineTransformIdentity; transform = CGAffineTransformScale(transform, 1, -1); transform = CGAffineTransformTranslate(transform, 0, -inputImageSize.height); for (CIFaceFeature *faceFeature in features)&#123; NSMutableDictionary * faceDic = [NSMutableDictionary dictionary]; CGRect faceViewBounds = CGRectApplyAffineTransform(faceFeature.bounds, transform); [faceDic setValue:[NSValue valueWithCGRect:faceViewBounds] forKey:(NSString *)FACE_HANDLE_INFO_FACE_FRAME]; CGFloat faceWidth = faceFeature.bounds.size.width; if(faceFeature.hasLeftEyePosition)&#123; CGPoint faceViewLeftPoint = CGPointApplyAffineTransform(faceFeature.leftEyePosition, transform); CGRect leftEyeBounds = CGRectMake(faceViewLeftPoint.x-faceWidth*0.1, faceViewLeftPoint.y-faceWidth*0.1, faceWidth*0.2, faceWidth*0.2); [faceDic setValue:[NSValue valueWithCGRect:leftEyeBounds] forKey:(NSString *)FACE_HANDLE_INFO_FACE_LEFT_EYE_FRAME]; &#125; if(faceFeature.hasRightEyePosition)&#123; //获取人右眼对应的point CGPoint faceViewRightPoint = CGPointApplyAffineTransform(faceFeature.rightEyePosition, transform); CGRect rightEyeBounds = CGRectMake(faceViewRightPoint.x-faceWidth*0.1, faceViewRightPoint.y-faceWidth*0.1, faceWidth*0.2, faceWidth*0.2); [faceDic setValue:[NSValue valueWithCGRect:rightEyeBounds] forKey:(NSString *)FACE_HANDLE_INFO_FACE_RIGHT_EYE_FRAME]; &#125; if(faceFeature.hasMouthPosition)&#123; //获取人嘴巴对应的point CGPoint faceViewMouthPoint = CGPointApplyAffineTransform(faceFeature.mouthPosition, transform); CGRect mouthBounds = CGRectMake(faceViewMouthPoint.x-faceWidth*0.2, faceViewMouthPoint.y-faceWidth*0.2, faceWidth*0.4, faceWidth*0.4); [faceDic setValue:[NSValue valueWithCGRect:mouthBounds] forKey:(NSString *)FACE_HANDLE_INFO_FACE_MOUTH_FRAME]; &#125; [dataArray addObject:faceDic]; &#125; return [dataArray copy];&#125;@end 打开百度，随便搜索一些人脸图片进行识别，可以看到识别率还是很高，如下图： 三、CIImage中提供了其他图像识别功能CIDetector除了可以用来进行人脸识别外，还支持进行二维码、矩形、文字等检测。 矩形区域识别，用来检测图像中的矩形边界，核心代码如下： 123456789101112131415161718192021222324252627282930-(NSArray *)analyseRectImage:(UIImage *)image&#123; NSMutableArray * dataArray = [NSMutableArray array]; CIImage * cImage = [CIImage imageWithCGImage:image.CGImage]; NSDictionary* opts = [NSDictionary dictionaryWithObject: CIDetectorAccuracyHigh forKey:CIDetectorAccuracy]; CIDetector* detector = [CIDetector detectorOfType:CIDetectorTypeRectangle context:nil options:opts]; NSArray* features = [detector featuresInImage:cImage]; CGSize inputImageSize = [cImage extent].size; CGAffineTransform transform = CGAffineTransformIdentity; transform = CGAffineTransformScale(transform, 1, -1); transform = CGAffineTransformTranslate(transform, 0, -inputImageSize.height); for (CIRectangleFeature *feature in features)&#123; NSLog(@\"%lu\",features.count); NSMutableDictionary * dic = [NSMutableDictionary dictionary]; CGRect viewBounds = CGRectApplyAffineTransform(feature.bounds, transform); [dic setValue:[NSValue valueWithCGRect:viewBounds] forKey:@\"rectBounds\"]; CGPoint topLeft = CGPointApplyAffineTransform(feature.topLeft, transform); [dic setValue:[NSValue valueWithCGPoint:topLeft] forKey:@\"topLeft\"]; CGPoint topRight = CGPointApplyAffineTransform(feature.topRight, transform); [dic setValue:[NSValue valueWithCGPoint:topRight] forKey:@\"topRight\"]; CGPoint bottomLeft = CGPointApplyAffineTransform(feature.bottomLeft, transform); [dic setValue:[NSValue valueWithCGPoint:bottomLeft] forKey:@\"bottomLeft\"]; CGPoint bottomRight = CGPointApplyAffineTransform(feature.bottomRight, transform); [dic setValue:[NSValue valueWithCGPoint:bottomRight] forKey:@\"bottomRight\"]; [dataArray addObject:dic]; &#125; return [dataArray copy];&#125; 效果如下图所示： 二维码扫描不仅可以分析出图片中的二维码位置，还可以解析出二维码数据，核心代码如下： 123456789101112131415161718192021222324252627282930-(NSArray *)analyseQRImage:(UIImage *)image&#123; NSMutableArray * dataArray = [NSMutableArray array]; CIImage * cImage = [CIImage imageWithCGImage:image.CGImage]; NSDictionary* opts = [NSDictionary dictionaryWithObject: CIDetectorAccuracyHigh forKey:CIDetectorAccuracy]; CIDetector* detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:nil options:opts]; NSArray* features = [detector featuresInImage:cImage]; CGSize inputImageSize = [cImage extent].size; CGAffineTransform transform = CGAffineTransformIdentity; transform = CGAffineTransformScale(transform, 1, -1); transform = CGAffineTransformTranslate(transform, 0, -inputImageSize.height); for (CIQRCodeFeature *feature in features)&#123; NSMutableDictionary * dic = [NSMutableDictionary dictionary]; CGRect viewBounds = CGRectApplyAffineTransform(feature.bounds, transform); [dic setValue:[NSValue valueWithCGRect:viewBounds] forKey:@\"rectBounds\"]; CGPoint topLeft = CGPointApplyAffineTransform(feature.topLeft, transform); [dic setValue:[NSValue valueWithCGPoint:topLeft] forKey:@\"topLeft\"]; CGPoint topRight = CGPointApplyAffineTransform(feature.topRight, transform); [dic setValue:[NSValue valueWithCGPoint:topRight] forKey:@\"topRight\"]; CGPoint bottomLeft = CGPointApplyAffineTransform(feature.bottomLeft, transform); [dic setValue:[NSValue valueWithCGPoint:bottomLeft] forKey:@\"bottomLeft\"]; CGPoint bottomRight = CGPointApplyAffineTransform(feature.bottomRight, transform); [dic setValue:[NSValue valueWithCGPoint:bottomRight] forKey:@\"bottomRight\"]; [dic setValue:feature.messageString forKey:@\"content\"]; [dataArray addObject:dic]; &#125; return [dataArray copy];&#125; CIImage框架中还支持对文本区域进行分析，核心代码如下： 12345678910111213141516171819202122232425262728293031-(NSArray *)analyseTextImage:(UIImage *)image&#123; NSMutableArray * dataArray = [NSMutableArray array]; CIImage * cImage = [CIImage imageWithCGImage:image.CGImage]; NSDictionary* opts = [NSDictionary dictionaryWithObject: CIDetectorAccuracyHigh forKey:CIDetectorAccuracy]; CIDetector* detector = [CIDetector detectorOfType:CIDetectorTypeText context:nil options:nil]; NSArray* features = [detector featuresInImage:cImage options:@&#123;CIDetectorReturnSubFeatures:@YES&#125;]; CGSize inputImageSize = [cImage extent].size; CGAffineTransform transform = CGAffineTransformIdentity; transform = CGAffineTransformScale(transform, 1, -1); transform = CGAffineTransformTranslate(transform, 0, -inputImageSize.height); for (CITextFeature *feature in features)&#123; NSLog(@\"%@\",feature.subFeatures); NSMutableDictionary * dic = [NSMutableDictionary dictionary]; CGRect viewBounds = CGRectApplyAffineTransform(feature.bounds, transform); [dic setValue:[NSValue valueWithCGRect:viewBounds] forKey:@\"rectBounds\"]; CGPoint topLeft = CGPointApplyAffineTransform(feature.topLeft, transform); [dic setValue:[NSValue valueWithCGPoint:topLeft] forKey:@\"topLeft\"]; CGPoint topRight = CGPointApplyAffineTransform(feature.topRight, transform); [dic setValue:[NSValue valueWithCGPoint:topRight] forKey:@\"topRight\"]; CGPoint bottomLeft = CGPointApplyAffineTransform(feature.bottomLeft, transform); [dic setValue:[NSValue valueWithCGPoint:bottomLeft] forKey:@\"bottomLeft\"]; CGPoint bottomRight = CGPointApplyAffineTransform(feature.bottomRight, transform); [dic setValue:[NSValue valueWithCGPoint:bottomRight] forKey:@\"bottomRight\"]; [dataArray addObject:dic]; &#125; return [dataArray copy];&#125; 效果如下图所示： 四、CoreImage中的相关核心类1.CIColor类CIColor类是CoreImage中描述色彩的类。 12345678910111213141516171819202122232425262728293031323334353637//通过CGColor创建CIColor+ (instancetype)colorWithCGColor:(CGColorRef)c;//构造方法+ (instancetype)colorWithRed:(CGFloat)r green:(CGFloat)g blue:(CGFloat)b alpha:(CGFloat)a;+ (instancetype)colorWithRed:(CGFloat)r green:(CGFloat)g blue:(CGFloat)b;+ (nullable instancetype)colorWithRed:(CGFloat)r green:(CGFloat)g blue:(CGFloat)b alpha:(CGFloat)a colorSpace:(CGColorSpaceRef)colorSpace;+ (nullable instancetype)colorWithRed:(CGFloat)r green:(CGFloat)g blue:(CGFloat)b colorSpace:(CGColorSpaceRef)colorSpace;- (instancetype)initWithCGColor:(CGColorRef)c;//通过字符串创建CIColor对象+ (instancetype)colorWithString:(NSString *)representation;- (instancetype)initWithRed:(CGFloat)r green:(CGFloat)g blue:(CGFloat)b alpha:(CGFloat)a;- (instancetype)initWithRed:(CGFloat)r green:(CGFloat)g blue:(CGFloat)b;- (nullable instancetype)initWithRed:(CGFloat)r green:(CGFloat)g blue:(CGFloat)b alpha:(CGFloat)a colorSpace:(CGColorSpaceRef)colorSpace;- (nullable instancetype)initWithRed:(CGFloat)r green:(CGFloat)g blue:(CGFloat)b colorSpace:(CGColorSpaceRef)colorSpace;//获取颜色分量个数@property (readonly) size_t numberOfComponents;//颜色分量@property (readonly) const CGFloat *components;//颜色透明度@property (readonly) CGFloat alpha;//色彩空间@property (readonly) CGColorSpaceRef colorSpace;//红绿蓝分量@property (readonly) CGFloat red;@property (readonly) CGFloat green;@property (readonly) CGFloat blue;//下面是定义的一些便捷的颜色变量@property (class, strong, readonly) CIColor *blackColor ;@property (class, strong, readonly) CIColor *whiteColor ;@property (class, strong, readonly) CIColor *grayColor ;@property (class, strong, readonly) CIColor *redColor ;@property (class, strong, readonly) CIColor *greenColor ;@property (class, strong, readonly) CIColor *blueColor ;@property (class, strong, readonly) CIColor *cyanColor ;@property (class, strong, readonly) CIColor *magentaColor ;@property (class, strong, readonly) CIColor *yellowColor ;@property (class, strong, readonly) CIColor *clearColor 2.CIImage类CIImage是CoreImage中最核心的类，它描述了图像对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//创建一个新的CIImage实例+ (CIImage *)imageWithCGImage:(CGImageRef)image;//通过字典创建一个新的CIImage实例/*字典中的键kCIImageColorSpace 设置颜色空间 为CGColorSpaceRef对象kCIImageNearestSampling 是否临近采样 布尔值kCIImageProperties 设置图片属性字典kCIImageApplyOrientationProperty 布尔值 是否根据方向进行转换kCIImageTextureTarget NSNumber值 设置OpebGL目标纹理常数kCIImageTextureFormat NSNumber值 设置OpebGL formatkCIImageAuxiliaryDepth 布尔值 是否返回深度图像kCIImageAuxiliaryDisparity 布尔值 是否返回辅助时差图像kCIImageAuxiliaryPortraitEffectsMatte 布尔值 是否返回肖像模板*/+ (CIImage *)imageWithCGImage:(CGImageRef)image options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;//通过CALayer进行CIImage的创建+ (CIImage *)imageWithCGLayer:(CGLayerRef)layer NS_DEPRECATED_MAC(10_4,10_11);+ (CIImage *)imageWithCGLayer:(CGLayerRef)layer options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;//使用bitmap数据创建CIImage+ (CIImage *)imageWithBitmapData:(NSData *)data bytesPerRow:(size_t)bytesPerRow size:(CGSize)size format:(CIFormat)format colorSpace:(nullable CGColorSpaceRef)colorSpace;//通过纹理创建CIImage+ (CIImage *)imageWithTexture:(unsigned int)name size:(CGSize)size flipped:(BOOL)flipped colorSpace:(nullable CGColorSpaceRef)colorSpace;+ (CIImage *)imageWithTexture:(unsigned int)name size:(CGSize)size flipped:(BOOL)flipped options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;+ (nullable CIImage *)imageWithMTLTexture:(id&lt;MTLTexture&gt;)texture options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;//通过url创建CIImage+ (nullable CIImage *)imageWithContentsOfURL:(NSURL *)url;+ (nullable CIImage *)imageWithContentsOfURL:(NSURL *)url options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;//通过NSDate创建CIImage+ (nullable CIImage *)imageWithData:(NSData *)data;+ (nullable CIImage *)imageWithData:(NSData *)data options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;//通过CVImageBufferRef创建CIImage+ (CIImage *)imageWithCVImageBuffer:(CVImageBufferRef)imageBuffer;+ (CIImage *)imageWithCVImageBuffer:(CVImageBufferRef)imageBuffer options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;//通过CVPixelBufferRef创建CIImage+ (CIImage *)imageWithCVPixelBuffer:(CVPixelBufferRef)pixelBuffer;+ (CIImage *)imageWithCVPixelBuffer:(CVPixelBufferRef)pixelBuffer options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;//通过颜色创建CIImage+ (CIImage *)imageWithColor:(CIColor *)color;//创建空CIImage+ (CIImage *)emptyImage;//初始化方法- (instancetype)initWithCGImage:(CGImageRef)image;- (instancetype)initWithCGImage:(CGImageRef)image options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;- (instancetype)initWithCGLayer:(CGLayerRef)layer);- (instancetype)initWithCGLayer:(CGLayerRef)layer;- (instancetype)initWithBitmapData:(NSData *)data bytesPerRow:(size_t)bytesPerRow size:(CGSize)size format:(CIFormat)format colorSpace:(nullable CGColorSpaceRef)colorSpace;- (instancetype)initWithTexture:(unsigned int)name size:(CGSize)size flipped:(BOOL)flipped colorSpace:(nullable CGColorSpaceRef)colorSpace;- (instancetype)initWithTexture:(unsigned int)name size:(CGSize)size flipped:(BOOL)flipped options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;- (nullable instancetype)initWithMTLTexture:(id&lt;MTLTexture&gt;)texture options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options；- (nullable instancetype)initWithContentsOfURL:(NSURL *)url;- (nullable instancetype)initWithContentsOfURL:(NSURL *)url options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;- (instancetype)initWithCVImageBuffer:(CVImageBufferRef)imageBuffer;- (instancetype)initWithCVImageBuffer:(CVImageBufferRef)imageBuffer options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;- (instancetype)initWithCVPixelBuffer:(CVPixelBufferRef)pixelBuffer;- (instancetype)initWithCVPixelBuffer:(CVPixelBufferRef)pixelBuffer options:(nullable NSDictionary&lt;CIImageOption, id&gt; *)options;- (instancetype)initWithColor:(CIColor *)color;//追加变换 返回结果CIImage对象- (CIImage *)imageByApplyingTransform:(CGAffineTransform)matrix;- (CIImage *)imageByApplyingOrientation:(int)orientation;- (CIImage *)imageByApplyingCGOrientation:(CGImagePropertyOrientation)orientation;//根据方向获取变换- (CGAffineTransform)imageTransformForOrientation:(int)orientation;- (CGAffineTransform)imageTransformForCGOrientation:(CGImagePropertyOrientation)orientation;//进行混合- (CIImage *)imageByCompositingOverImage:(CIImage *)dest;//区域裁剪- (CIImage *)imageByCroppingToRect:(CGRect)rect;//返回图像边缘- (CIImage *)imageByClampingToExtent;//设置边缘 返回新图像对象- (CIImage *)imageByClampingToRect:(CGRect)rect;//用过滤器进行过滤- (CIImage *)imageByApplyingFilter:(NSString *)filterName withInputParameters:(nullable NSDictionary&lt;NSString *,id&gt; *)params;- (CIImage *)imageByApplyingFilter:(NSString *)filterName;//图像边缘@property (NS_NONATOMIC_IOSONLY, readonly) CGRect extent;//属性字典@property (atomic, readonly) NSDictionary&lt;NSString *,id&gt; *properties;//通过URL创建的图像的URL@property (atomic, readonly, nullable) NSURL *url;//颜色空间@property (atomic, readonly, nullable) CGColorSpaceRef colorSpace;//通过CGImage创建的CGImage对象@property (nonatomic, readonly, nullable) CGImageRef CGImage; 3.CIContext类CIContext是CoreImage中的上下文对象，用来进行图片的渲染，已经转换为其他框架的图像对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//通过CGContextRef上下文创建CIContext上下文/*配置字典中可以进行配置的：kCIContextOutputColorSpace 设置输出的颜色空间kCIContextWorkingColorSpace 设置工作的颜色空间kCIContextWorkingFormat 设置缓冲区数据格式kCIContextHighQualityDownsample 布尔值kCIContextOutputPremultiplied 设置输出是否带alpha通道kCIContextCacheIntermediates 布尔值kCIContextUseSoftwareRenderer 设置是否使用软件渲染kCIContextPriorityRequestLow 是否低质量*/+ (CIContext *)contextWithCGContext:(CGContextRef)cgctx options:(nullable NSDictionary&lt;CIContextOption, id&gt; *)options;//创建上下文对象+ (CIContext *)contextWithOptions:(nullable NSDictionary&lt;CIContextOption, id&gt; *)options;+ (CIContext *)context;- (instancetype)initWithOptions:(nullable NSDictionary&lt;CIContextOption, id&gt; *)options;//使用指定的处理器创建CIContext+ (CIContext *)contextWithMTLDevice:(id&lt;MTLDevice&gt;)device;+ (CIContext *)contextWithMTLDevice:(id&lt;MTLDevice&gt;)device options:(nullable NSDictionary&lt;CIContextOption, id&gt; *)options;//工作的颜色空间@property (nullable, nonatomic, readonly) CGColorSpaceRef workingColorSpace;//缓冲区格式@property (nonatomic, readonly) CIFormat workingFormat;//进行CIImage图像的绘制- (void)drawImage:(CIImage *)image atPoint:(CGPoint)atPoint fromRect:(CGRect)fromRect;- (void)drawImage:(CIImage *)image inRect:(CGRect)inRect fromRect:(CGRect)fromRect;//使用CIImage创建CGImageRef- (nullable CGImageRef)createCGImage:(CIImage *)image; fromRect:(CGRect)fromRect;- (nullable CGImageRef)createCGImage:(CIImage *)image fromRect:(CGRect)fromRect format:(CIFormat)format colorSpace:(nullable CGColorSpaceRef)colorSpace;//创建CALayer- (nullable CGLayerRef)createCGLayerWithSize:(CGSize)size info:(nullable CFDictionaryRef)info;//将图片写入bitMap数据- (void)render:(CIImage *)image toBitmap:(void *)data rowBytes:(ptrdiff_t)rowBytes bounds:(CGRect)bounds format:(CIFormat)format;//将图片写入缓存- (void)render:(CIImage *)image toCVPixelBuffer:(CVPixelBufferRef)buffer colorSpace:(nullable CGColorSpaceRef)colorSpace;- (void)render:(CIImage *)imagetoCVPixelBuffer:(CVPixelBufferRef)buffer bounds:(CGRect)bounds colorSpace:(nullable CGColorSpaceRef)colorSpace；//将图片写入纹理- (void)render:(CIImage *)image toMTLTexture:(id&lt;MTLTexture&gt;)texture commandBuffer:(nullable id&lt;MTLCommandBuffer&gt;)commandBuffer bounds:(CGRect)bounds colorSpace:(CGColorSpaceRef)colorSpace;//清除缓存- (void)clearCaches;//输入图像的最大尺寸- (CGSize)inputImageMaximumSize;//输出图像的最大尺寸- (CGSize)outputImageMaximumSize;//将CIImage写成TIFF数据- (nullable NSData*) TIFFRepresentationOfImage:(CIImage*)image format:(CIFormat)format colorSpace:(CGColorSpaceRef)colorSpace options:(NSDictionary&lt;CIImageRepresentationOption, id&gt;*)options;//将CIImage写成JPEG数据- (nullable NSData*) JPEGRepresentationOfImage:(CIImage*)image colorSpace:(CGColorSpaceRef)colorSpace options:(NSDictionary&lt;CIImageRepresentationOption, id&gt;*)options;//将CIImage写成HEIF数据- (nullable NSData*) HEIFRepresentationOfImage:(CIImage*)image format:(CIFormat)format colorSpace:(CGColorSpaceRef)colorSpace options:(NSDictionary&lt;CIImageRepresentationOption, id&gt;*)options;//将CIImage写成PNG数据- (nullable NSData*) PNGRepresentationOfImage:(CIImage*)image format:(CIFormat)format colorSpace:(CGColorSpaceRef)colorSpace options:(NSDictionary&lt;CIImageRepresentationOption, id&gt;*)options;//将CIImage写入TIFF文件- (BOOL) writeTIFFRepresentationOfImage:(CIImage*)image toURL:(NSURL*)url format:(CIFormat)format colorSpace:(CGColorSpaceRef)colorSpace options:(NSDictionary&lt;CIImageRepresentationOption, id&gt;*)options error:(NSError **)errorPtr;//将CIImage写入PNG文件- (BOOL) writePNGRepresentationOfImage:(CIImage*)image toURL:(NSURL*)url format:(CIFormat)format colorSpace:(CGColorSpaceRef)colorSpace options:(NSDictionary&lt;CIImageRepresentationOption, id&gt;*)options error:(NSError **)errorPtr;//将CIImage写入JPEG文件- (BOOL) writeJPEGRepresentationOfImage:(CIImage*)image toURL:(NSURL*)url colorSpace:(CGColorSpaceRef)colorSpace options:(NSDictionary&lt;CIImageRepresentationOption, id&gt;*)options error:(NSError **)errorPtr;//将CIImage写HEIF文件- (BOOL) writeHEIFRepresentationOfImage:(CIImage*)image toURL:(NSURL*)url format:(CIFormat)format colorSpace:(CGColorSpaceRef)colorSpace options:(NSDictionary&lt;CIImageRepresentationOption, id&gt;*)options error:(NSError **)errorPtr; 4.CIDetector类前面有过CIDetector类的功能演示，这是CIImage框架中非常强大的一个类，使用它可以进行复杂的图片识别技术，解析如下： 1234567891011121314151617181920212223242526272829//创建CIDetector实例 /*type用来指定识别的类型CIDetectorTypeFace 人脸识别模式CIDetectorTypeRectangle 矩形检测模式CIDetectorTypeText 文本区域检测模式CIDetectorTypeQRCode 二维码扫描模式option可以指定配置字典 可配置的键如下CIDetectorAccuracy 设置检测精度 CIDetectorAccuracyLow 低 CIDetectorAccuracyHigh 高CIDetectorTracking 设置是否跟踪特征CIDetectorMinFeatureSize 设置特征最小尺寸 0-1之间 相对图片CIDetectorMaxFeatureCount 设置最大特征数CIDetectorImageOrientation 设置方向CIDetectorEyeBlink 设置布尔值 是否提取面部表情 眨眼CIDetectorSmile 设置布尔值 是否提取面部表情 微笑CIDetectorFocalLength 设置焦距CIDetectorAspectRatio 设置检测到矩形的宽高比CIDetectorReturnSubFeatures 设置是否提取子特征*/+ (nullable CIDetector *)detectorOfType:(NSString*)type context:(nullable CIContext *)context options:(nullable NSDictionary&lt;NSString *,id&gt; *)options;//进行图片分析 提取特征数组- (NSArray&lt;CIFeature *&gt; *)featuresInImage:(CIImage *)image;- (NSArray&lt;CIFeature *&gt; *)featuresInImage:(CIImage *)image options:(nullable NSDictionary&lt;NSString *,id&gt; *)options; 5.CIFeature相关类CIFeature与其相关子类定义了特征数据模型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@interface CIFeature : NSObject &#123;&#125;//特征类型/*CIFeatureTypeFaceCIFeatureTypeRectangleCIFeatureTypeQRCodeCIFeatureTypeText*/@property (readonly, retain) NSString *type;//特征在图片中的bounds@property (readonly, assign) CGRect bounds;@end//人脸特征对象@interface CIFaceFeature : CIFeature//位置尺寸@property (readonly, assign) CGRect bounds;//左眼位置@property (readonly, assign) BOOL hasLeftEyePosition;@property (readonly, assign) CGPoint leftEyePosition;//是否有左眼特征@property (readonly, assign) BOOL hasRightEyePosition;//右眼位置@property (readonly, assign) CGPoint rightEyePosition;//是否有右眼特征@property (readonly, assign) BOOL hasMouthPosition;//口部特征@property (readonly, assign) CGPoint mouthPosition;//是否有跟踪特征ID@property (readonly, assign) BOOL hasTrackingID;//跟踪特征ID@property (readonly, assign) int trackingID;@property (readonly, assign) BOOL hasTrackingFrameCount;@property (readonly, assign) int trackingFrameCount;@property (readonly, assign) BOOL hasFaceAngle;@property (readonly, assign) float faceAngle;//是否微笑@property (readonly, assign) BOOL hasSmile;//左眼是否闭眼@property (readonly, assign) BOOL leftEyeClosed;//右眼是否闭眼@property (readonly, assign) BOOL rightEyeClosed;@end//矩形特征对象@interface CIRectangleFeature : CIFeature//位置尺寸@property (readonly) CGRect bounds;@property (readonly) CGPoint topLeft;@property (readonly) CGPoint topRight;@property (readonly) CGPoint bottomLeft;@property (readonly) CGPoint bottomRight;@end//二维码特征对象@interface CIQRCodeFeature : CIFeature//位置尺寸信息@property (readonly) CGRect bounds;@property (readonly) CGPoint topLeft;@property (readonly) CGPoint topRight;@property (readonly) CGPoint bottomLeft;@property (readonly) CGPoint bottomRight;//二维码内容@property (nullable, readonly) NSString* messageString;//二维码描述数据@property (nullable, readonly) CIQRCodeDescriptor *symbolDescriptor NS_AVAILABLE(10_13, 11_0);@end//文本特征对象@interface CITextFeature : CIFeature//位置信息@property (readonly) CGRect bounds;@property (readonly) CGPoint topLeft;@property (readonly) CGPoint topRight;@property (readonly) CGPoint bottomLeft;@property (readonly) CGPoint bottomRight;//子特征@property (nullable, readonly) NSArray *subFeatures;@end 热爱技术，热爱生活，写代码，交朋友 珲少 QQ：316045346","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之CFNetwork框架使用","slug":"385iOS开发之CFNetwork框架使用","date":"2018-10-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.381Z","comments":true,"path":"2018/10/24/385iOS开发之CFNetwork框架使用/","link":"","permalink":"http://huishao.cc/2018/10/24/385iOS开发之CFNetwork框架使用/","excerpt":"","text":"iOS开发之CFNetwork框架使用一、引言在iOS应用开发中，CFNetwork框架其实并不是非常常用的，相对NSURLSession框架而言，这是一个相对底层的网络工作框架。官方文档中的下图描述了CFNetwork在整个网络体系中的位置： CFNetwork与CoreFoundation关系密切，其实基于CoreFoundation框架的，结构如下图所示： 本篇博客中不会过多的设计CoreFoundation框架中的内容，主要总结和介绍CFNetwork的相关内容与简单应用。 二、使用CFNetwork进行简单的网络请求CFNetwork是使用C语言实现的一套网络访问框架，进行一个简单的网络请求示例代码如下： 1234567891011121314151617181920//创建请求方法字符串 CFStringRef method = CFSTR(\"GET\");//创建请求URL字符串CFStringRef urlStr = CFSTR(\"http://www.baidu.com\");//创建请求URL对象CFURLRef url = CFURLCreateWithString(kCFAllocatorDefault, urlStr, NULL);//创建HTTP消息对象CFHTTPMessageRef request = CFHTTPMessageCreateRequest(kCFAllocatorDefault, method, url, kCFHTTPVersion1_1);//进行请求头的设置CFHTTPMessageSetHeaderFieldValue(request, CFSTR(\"key\"), CFSTR(\"Value\"));//创建读取流对象CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, request);//定义读取流上下文CFStreamClientContext ctxt = &#123;0, (__bridge void *)(self), NULL, NULL, NULL&#125;;//设置读取的客服端 即回调相关CFReadStreamSetClient(readStream, kCFStreamEventHasBytesAvailable|kCFStreamEventEndEncountered|kCFStreamEventOpenCompleted|kCFStreamEventCanAcceptBytes|kCFStreamEventErrorOccurred, myCallBack, &amp;ctxt);//将读取流加入runloop中CFReadStreamScheduleWithRunLoop(readStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);//开启流printf(\"%d\",CFReadStreamOpen(readStream)); 实现myCallBack回调函数如下： 12345678910111213141516171819202122232425void myCallBack (CFReadStreamRef stream,CFStreamEventType type,void *clientCallBackInfo)&#123; //流中有可读数据的回调 if (type == kCFStreamEventHasBytesAvailable) &#123; //将流中的数据存入到数组中 UInt8 buff [1024]; CFReadStreamRead(stream, buff, 1024); printf(\"%s\",buff); //流打开完成的回调 &#125;else if(type==kCFStreamEventOpenCompleted)&#123; NSLog(@\"open\"); //流异常的回调 &#125;else if (type==kCFStreamEventErrorOccurred)&#123; NSLog(@\"error:%@\",CFErrorCopyDescription( CFReadStreamCopyError(stream))); //可以接收写数据时调用 &#125;else if (type==kCFStreamEventCanAcceptBytes)&#123; NSLog(@\"kCFStreamEventCanAcceptBytes\"); //读取结束回调 &#125;else if(type==kCFStreamEventEndEncountered)&#123; NSLog(@\"end\"); //关闭流 CFReadStreamClose(stream); //将流从runloop中移除 CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes); &#125;&#125; 上面演示了简单的GET请求，如果使用的请求方法为POST，则可以进行请求体的设置，上面示例代码中，CFStringRef、CFURLRef、CFReadStreamRef等相关的类为CoreFoundation框架中的，这里暂不深究，简单使用即可。后面我们将详细的探讨CFNetwork中相关类的使用。 三、CFHTTPMessageRef详解在基于C的框架中，类对象都是使用结构体指针描述的，CFHTTPMessageRef是HTTP消息的封装，其可以是一个HTTP请求，也可以是一个HTTP回执。与其相关的方法解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//返回CGHTTPMessageRef的类型IDCFTypeID CFHTTPMessageGetTypeID(void);//创建一个HTTP请求消息/*alloc为内存管理器 一般使用默认的kCFAllocatorDefaultrequestMethod为请求方法url为请求的路径httpVersion为请求的HTTP版本HTTP版本定义如下：kCFHTTPVersion1_0kCFHTTPVersion1_1kCFHTTPVersion2_0*/CFHTTPMessageRef CFHTTPMessageCreateRequest(CFAllocatorRef __nullable alloc, CFStringRef requestMethod, CFURLRef url, CFStringRef httpVersion);//创建一个HTTP回执消息/*alloc内存管理器statusCode 请求回执状态码statusDescription 请求回执状态描述httpVersion HTTP版本号*/CFHTTPMessageRef CFHTTPMessageCreateResponse(CFAllocatorRef __nullable alloc,CFIndex statusCode,CFStringRef __nullable statusDescription,CFStringRef httpVersion);//创建一个空的HTTP消息 /*isRequest 如果传入kCFBooleanTrue 则为请求类型 否则为回执类型*/CFHTTPMessageRef CFHTTPMessageCreateEmpty(CFAllocatorRef __nullable alloc, Boolean isRequest);//复制一个HTTP消息CFHTTPMessageRef CFHTTPMessageCreateCopy(CFAllocatorRef __nullable alloc, CFHTTPMessageRef message);//判断一个HTTP消息是请求 还是 回执Boolean CFHTTPMessageIsRequest(CFHTTPMessageRef message);//获取HTTP版本CFStringRef CFHTTPMessageCopyVersion(CFHTTPMessageRef message);//获取消息体内容 请求体或者回执体CFDataRef CFHTTPMessageCopyBody(CFHTTPMessageRef message);//设置消息体内容void CFHTTPMessageSetBody(CFHTTPMessageRef message, CFDataRef bodyData);//获取某个消息头内容CFStringRef CFHTTPMessageCopyHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField);//获取所有消息头字段CFDictionaryRef CFHTTPMessageCopyAllHeaderFields(CFHTTPMessageRef message);//设置消息头void CFHTTPMessageSetHeaderFieldValue(CFHTTPMessageRef message, CFStringRef headerField, CFStringRef __nullable value);//向空消息中追加序列化的数据Boolean CFHTTPMessageAppendBytes(CFHTTPMessageRef message, const UInt8 *newBytes, CFIndex numBytes);//返回消息头数据是否准备完成Boolean CFHTTPMessageIsHeaderComplete(CFHTTPMessageRef message);//将一个消息对象序列化成数据CFDataRef CFHTTPMessageCopySerializedMessage(CFHTTPMessageRef message);/*=================下面这些方法针对于请求类型的消息=====================*///获取消息中的urlCFURLRef CFHTTPMessageCopyRequestURL(CFHTTPMessageRef request);//获取消息的请求方法CFStringRef CFHTTPMessageCopyRequestMethod(CFHTTPMessageRef request);//添加认证信息Boolean CFHTTPMessageAddAuthentication(CFHTTPMessageRef request,CFHTTPMessageRef __nullable authenticationFailureResponse,CFStringRef username,CFStringRef password,CFStringRef __nullable authenticationScheme,Boolean forProxy);/*=================下面这些方法针对于绘制类型的消息=====================*///获取回执状态码CFIndex CFHTTPMessageGetResponseStatusCode(CFHTTPMessageRef response);//获取回执状态行信息CFStringRef CFHTTPMessageCopyResponseStatusLine(CFHTTPMessageRef response); 四、进行请求与回调处理CFHTTPMessageRef的主要用途是构建出HTTP的请求或回执对象，请求的相关发起与回调方法都封装在CFHTTPStream.h这个头文件中，解析如下： 123456//通过一个HTTP请求创建一个读取流对象CFReadStreamRef CFReadStreamCreateForHTTPRequest(CFAllocatorRef __nullable alloc, CFHTTPMessageRef request);//通过一个HTTP请求创建读取流对象 但是请求的body会被忽略 取requestBody作为请求体CFReadStreamRef CFReadStreamCreateForStreamedHTTPRequest(CFAllocatorRef __nullable alloc, CFHTTPMessageRef requestHeaders, CFReadStreamRef requestBody);//设置读取流是否自动重定向void CFHTTPReadStreamSetRedirectsAutomatically(CFReadStreamRef httpStream, Boolean shouldAutoRedirect); 五、关于请求的证书验证有时，客户端在向服务端进行请求时收到状态为401的回执，这时往往表明需要客户端提供用户凭证，在CFNetWork框架中，用户凭证与证书验证相关方法封装在CFHTTPAuthentication.h头文件中。解析如下： 12345678910111213141516171819202122232425262728293031//获取CFHTTPAuthentication类IDCFTypeID CFHTTPAuthenticationGetTypeID(void);/*通过一个401或者407的请求回执创建一个 用户认证对象*/CFHTTPAuthenticationRef CFHTTPAuthenticationCreateFromResponse(CFAllocatorRef __nullable alloc, CFHTTPMessageRef response);//获取一个用户认证对象是否有效Boolean CFHTTPAuthenticationIsValid(CFHTTPAuthenticationRef auth, CFStreamError * __nullable error);//获取某个用户认证对象是否是某个请求的Boolean CFHTTPAuthenticationAppliesToRequest(CFHTTPAuthenticationRef auth, CFHTTPMessageRef request);//获取某个用户认证是否必须有序进行Boolean CFHTTPAuthenticationRequiresOrderedRequests(CFHTTPAuthenticationRef auth);//使用给定的用户名和密码执行证书验证方法Boolean CFHTTPMessageApplyCredentials(CFHTTPMessageRef request,CFHTTPAuthenticationRef auth,CFStringRef __nullable username,CFStringRef __nullable password,CFStreamError * __nullable error);/*此方法和上面方法作用一致 不同的是使用字典来进行用户名和密码的设置 字段的键如下：kCFHTTPAuthenticationUsername 用户名键kCFHTTPAuthenticationPassword 密码键kCFHTTPAuthenticationAccountDomain 账户域*/Boolean CFHTTPMessageApplyCredentialDictionary(CFHTTPMessageRef request,CFHTTPAuthenticationRef auth,CFDictionaryRef dict,CFStreamError * __nullable error);//返回用户凭证的账户域CFStringRef CFHTTPAuthenticationCopyRealm(CFHTTPAuthenticationRef auth);//返回一组账户域CFArrayRef CFHTTPAuthenticationCopyDomains(CFHTTPAuthenticationRef auth);//返回用户凭证的验证方法CFStringRef CFHTTPAuthenticationCopyMethod(CFHTTPAuthenticationRef auth);//获取用户凭证验证是否需要用户名和密码Boolean CFHTTPAuthenticationRequiresUserNameAndPassword(CFHTTPAuthenticationRef auth);//获取是否需要账户域Boolean CFHTTPAuthenticationRequiresAccountDomain(CFHTTPAuthenticationRef auth); 六、进行FTP协议的数据交换CFNetWork框架也支持与FTP协议的服务端进行数据交互，方法解析如下： 123456//根据URL创建FTP读取流对象 用来进行文件下载CFReadStreamRef CFReadStreamCreateWithFTPURL(CFAllocatorRef __nullable alloc, CFURLRef ftpURL);//解析文件或目录的格式化数据CFIndex CFFTPCreateParsedResourceListing(CFAllocatorRef __nullable alloc, const UInt8 *buffer, CFIndex bufferLength, CFDictionaryRef __nullable * __nullable parsed);//根据URL创建一个FTP写入流对象 用来进行文件上传CFWriteStreamRef CFWriteStreamCreateWithFTPURL(CFAllocatorRef __nullable alloc, CFURLRef ftpURL); 对于FTP写入和读取流来说，可以使用CFReadStreamSetProperty()函数或者CFWriteStreamSetProperty()函数来进行属性的设置，可设置的属性列举如下： 12345678910111213141516171819202122kCFStreamPropertyFTPUserName //设置用户名kCFStreamPropertyFTPPassword //设置密码kCFStreamPropertyFTPUsePassiveMode //布尔值 设置是否被动模式kCFStreamPropertyFTPResourceSize //资源大小kCFStreamPropertyFTPFileTransferOffset //记录文件位置 用来断点续传kCFStreamPropertyFTPAttemptPersistentConnection //是否重用连接kCFStreamPropertyFTPProxy //设置代理字典kCFStreamPropertyFTPFetchResourceInfo //资源详情字典//下面为代理字典中可以定义的键kCFStreamPropertyFTPProxyHost //代理主机kCFStreamPropertyFTPProxyPort //代理端口kCFStreamPropertyFTPProxyUser //代理用户名kCFStreamPropertyFTPProxyPassword //代理密码//下面是资源详情字典中可以定义的键kCFFTPResourceMode //资源模式kCFFTPResourceName //资源名kCFFTPResourceOwne //资源所有者kCFFTPResourceGroup //资源组kCFFTPResourceLink //资源链接kCFFTPResourceSize //资源尺寸kCFFTPResourceType //资源类型kCFFTPResourceModDate //修改时间 七、主机地址相关操作CFNetWork中也封装了与主机地址域名相关的操作方法，例如，我们可以通过域名进行DNS解析出IP地址，示例代码如下： 1234567891011#import &lt;netinet/in.h&gt;#import &lt;arpa/inet.h&gt;CFStringRef hostString = CFSTR(\"www.baidu.com\");CFHostRef host = CFHostCreateWithName(CFAllocatorGetDefault(), hostString);CFHostStartInfoResolution(host, kCFHostAddresses, NULL);CFArrayRef addresses = CFHostGetAddressing(host, NULL);for (int i = 0; i&lt;CFArrayGetCount(addresses); i++) &#123; struct sockaddr_in * ip; ip = (struct sockaddr_in *)CFDataGetBytePtr(CFArrayGetValueAtIndex(addresses, i)); printf(\"%s\\n\",inet_ntoa(ip-&gt;sin_addr));&#125; CFHostRef对象操作相关方法解析如下： 1234567891011121314151617181920212223242526272829303132333435363738//获取类型IDCFTypeID CFHostGetTypeID(void);//根据域名创建CFHostRef对象CFHostRef CFHostCreateWithName(CFAllocatorRef __nullable allocator, CFStringRef hostname);/*根据地址创建CFHostRef对象addr参数为sockaddr结构体数据*/CFHostRef CFHostCreateWithAddress(CFAllocatorRef __nullable allocator, CFDataRef addr);//CFHostRef对象的复制CFHostRef CFHostCreateCopy(CFAllocatorRef __nullable alloc, CFHostRef host);//对指定主机进行信息预查找 返回值标明是否查找成功Boolean CFHostStartInfoResolution(CFHostRef theHost, CFHostInfoType info, CFStreamError * __nullable error);//获取主机的地址列表 数组中为sockaddr结构体数据CFArrayRef CFHostGetAddressing(CFHostRef theHost, Boolean * __nullable hasBeenResolved);//获取主机名列表CFArrayRef CFHostGetNames(CFHostRef theHost, Boolean * __nullable hasBeenResolved);//获取主机可达性信息CFDataRef CFHostGetReachability(CFHostRef theHost, Boolean * __nullable hasBeenResolved);//取消未完成的解析/*解析类型枚举typedef CF_ENUM(int, CFHostInfoType) &#123; //地址 kCFHostAddresses = 0, //主机名 kCFHostNames = 1, //可达性信息 kCFHostReachability = 2&#125;;*/void CFHostCancelInfoResolution(CFHostRef theHost, CFHostInfoType info);//设置客户端回调Boolean CFHostSetClient(CFHostRef theHost, CFHostClientCallBack __nullable clientCB, CFHostClientContext * __nullable clientContext);//注册进Runloopvoid CFHostScheduleWithRunLoop(CFHostRef theHost, CFRunLoopRef runLoop, CFStringRef runLoopMode);//从Runloop中注销void CFHostUnscheduleFromRunLoop(CFHostRef theHost, CFRunLoopRef runLoop, CFStringRef runLoopMode); 八、后续上面介绍的内容更多还是关于使用CFNetWork框架进行HTTP或FTP请求的相关方法，其实CFNetWork框架中还提供了复杂的Bonjour服务功能，其与CFNetService相关，这部分内容后面有时间再进行整理总结吧。 欢迎交流 珲少 QQ 316045346","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"GCC编译过程记","slug":"384 GCC编译过程记","date":"2018-10-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.380Z","comments":true,"path":"2018/10/16/384 GCC编译过程记/","link":"","permalink":"http://huishao.cc/2018/10/16/384 GCC编译过程记/","excerpt":"","text":"GCC编译过程记一、引言 对于编程工作者来说，GCC是一个熟悉的名字，它的全称是“GNU Compiler Collection”。GCC是一组编译器集合，目前其支持C、C++、Objective-C、Objective-C++、Go和RBIG语言的编译。本篇博客主要总结使用GCC进行代码编译的方法以及从源文件生成可执行文件的整个过程。 GCC完整的编译过程分为4个阶段，分别为预处理、编译、装载和链接。经过完整的4部处理后，GCC会将源文件编译成可执行文件进行输出，但是很多时候，我们进行调用时并不需要每一个过程都单独调用，可以使用组合命令来让GCC帮我们处理完成这些工作。 二、GCC编译的输出参数由于GCC是一组编译器集合，因此输入的文件后缀名决定了GCC的编译方式，下面列出了常见的文件后缀名对应的编译方式： | 文件后缀名 | 编译方式 || .c | C语言源代码，并且需要进行预处理 || .i | 已经预处理完成后的C语言源代码 || .ii | 已经预处理完成后的C++源代码 || .m | Objective-C源代码，并且必须进行libobjc库的链接 || .mi | 已经预处理完成后的Objective-C源代码 || .M或.mm | Objective-C++源代码，并且必须进行libobjc库的链接 || .mii | 已经预处理完成后的Objective-C++源代码 || .h | C,C++,Objective-C的头文件，会被处理进预编译头 || .cc , .cp , .cxx , .cpp , .CPP , .c++ , .C | C++语言源文件，需要进行预编译处理 || .f , .for , .ftn | 已经预处理完成后的Fortran语言源文件 || .F , .FOR , .fpp , .FPP , .FTN | Fortran语言源文件，需要进行预编译处理 || .go | Go语言源文件 | 下面以一个简单的C语言源文件来作为示例文件进行GCC的编译演示，首先编写一个简单的C程序如下，将文件名命名为a.c： 123456#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf(\"%s\\n\",\"Hello\"); return 0;&#125; ·预编译处理使用 -E 参数设置GCC只进行预编译处理，例如对上面的a.c源文件执行如下的GCC命令： 1gcc a.c -E &gt; a.i 需要注意，GCC会将编译后的内容输出到a.i这个文件中，执行命令后，打开a.i文件，你会发现一个简单的C源文件被预处理成了500多行代码，你可以尝试在源文件中添加宏定义，预处理后所有的宏定义都被直接替换了。 使用 -S 参数设置GCC进行编译功能，可以将预处理后的文件编译为汇编源代码，例如： 1gcc a.i -S &gt; a.S .S为后缀名的文件为汇编源文件，-S编译是高级语言向低级语言转换的过程。 使用 -c 参数设置GCC进行编译，可以将汇编后的汇编源文件编译成机器代码。例如： 1gcc a.i -c &gt; a.o .o后缀名的文件一般我们就没有办法读懂了，其是机器码。-c编译是编程语言向机器语言转换的过程。 除了上面提到的几个参数外，可以使用-o参数直接生成目标文件，这个参数会根据输入文件的后缀名进行处理，直接生成可执行文件，例如： 1gcc a.o -o a.out 其实使用.c为后缀名的C语言源文件也可以直接使用-o参数生成可执行文件，此时GCC会聚合前面的预处理，编译，连接等过程。.out为后缀名的文件是可执行文件，在终端可以直接执行，如下：","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"iOS开发之BusinessChat框架使用","slug":"383 iOS开发之BusinessChat框架使用","date":"2018-10-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.380Z","comments":true,"path":"2018/10/12/383 iOS开发之BusinessChat框架使用/","link":"","permalink":"http://huishao.cc/2018/10/12/383 iOS开发之BusinessChat框架使用/","excerpt":"","text":"iOS开发之BusinessChat框架使用BusinessChat是iOS11.3后引入的新框架，这个框架配合iMessage应用将商家与用户更加紧密的结合起来，并且为商家提供了另外一种非常方便的客服系统。 我们知道，在iOS10中新引入了iMessage扩展，iMessage扩展除了丰富了表情包外，开发者也可以开发一些功能独立的iMessage应用，关于iMessage扩展的相关应用，如下博客中有着完整的介绍。 https://my.oschina.net/u/2340880/blog/749331 随着iMessage扩展使得iMessage功能的越来越强大，其为用户提供能力和与第三方APP交互能力也越来越强，BusinessChat框架是提供给应用程序调用iMessage来与商家的客服系统联系的功能框架。 许多服务类的应用程序都有客服系统，例如当用户使用电商类应用程序时通常会需要联系商家。要使用BusinessChat相关功能，首先需要注册成为Apple商家，在如下网站进行商家注册： https://register.apple.com 界面如下： 使用AppleID登录后，填写必要的商家信息和成员信息，即可进行申请，提交申请后，需要Apple进行审核，如果审核通过会分配商户ID给我们，我们需要使用这个商户ID来进行我们的开发。 BusinessChat框架中有两个类：BCChatButton类和BCChatAction类，BCChatButton类是单纯的UI支持类，它提供了同意的联系客服按钮样式，BCChatAction类用来处理行为逻辑。示例代码如下： 1234567891011121314151617@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; BCChatButton * btn = [[BCChatButton alloc]initWithStyle:BCChatButtonStyleDark]; btn.frame = CGRectMake(50, 100, 200,100); [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;-(void)click&#123; NSLog(@\"message\"); [BCChatAction openTranscript:@\"8d7f4b79-bf77-45ab-86b5-b74f56d47737\" intentParameters:@&#123;BCParameterNameIntent:@\"buy\",BCParameterNameGroup:@\"custom\",BCParameterNameBody:@\"Hello World\"&#125;];&#125;@end 运行代码，按钮样式如下图： 点击按钮后，会调起iMessage应用，用户可以直接与商户进客服行联系。 BCChatButton是一个纯UI的按钮类，其继承自UIControl，使用方式和正常的UIButton一样，需要注意，其中并没有封装交互逻辑，按钮的触发事件需要开发者自己定义。BCChatAction来进行交互逻辑的处理，这个类中只有一个方法，如下： 123456789/*businessIdentifier为商户IDintentParameters为意图参数字典，其中可定义键值如下：BCParameterNameIntent 定义意图 用户发送消息时可以让商户更清楚用户的问题领域BCParameterNameGroup 定义组 帮助商户将问题分发明确的组 BCParameterNameBody 信息内容*/+ (void)openTranscript:(NSString *)businessIdentifier intentParameters:(NSDictionary&lt;BCParameterName, NSString *&gt; *)intentParameters;","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之AVKit框架使用","slug":"382iOS开发之AVKit框架使用","date":"2018-10-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.380Z","comments":true,"path":"2018/10/11/382iOS开发之AVKit框架使用/","link":"","permalink":"http://huishao.cc/2018/10/11/382iOS开发之AVKit框架使用/","excerpt":"","text":"iOS开发之AVKit框架使用一、引言在iOS开发框架中，AVKit是一个非常上层，偏应用的框架，它是基于AVFoundation的一层视图层封装。其中相关文件和类都十分简单，本篇博客主要整理和总结AVKit中相关类的使用方法。 二、AVRoutePickerViewAVRoutePickerView是iOS 11后新加入的类，AirPlay是iOS设备方便用户使用的一大特点。其作用是将当前手机播放的音频或者视频投送到其他外部设备上，例如支持AirPlay的电视，车载设备等。AVRoutePickerView只是一个按钮，其用来方便用户可以直接在应用程序内唤出AirPlay选择窗口。示例如下： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; AVRoutePickerView * view = [[AVRoutePickerView alloc]initWithFrame:CGRectMake(100, 100, 60, 60)]; //活跃状态颜色 view.activeTintColor = [UIColor redColor]; //设置代理 view.delegate = self; [self.view addSubview:view];&#125;//AirPlay界面弹出时回调- (void)routePickerViewWillBeginPresentingRoutes:(AVRoutePickerView *)routePickerView&#123; NSLog(@\"!!!!!!!!\");&#125;//AirPlay界面结束时回调- (void)routePickerViewDidEndPresentingRoutes:(AVRoutePickerView *)routePickerView&#123; NSLog(@\"@@@@@@@@\");&#125; 按钮和弹出界面效果如下： 从上面的示例代码也可以看出，对于AVRoutePickerView，我们基本没有任何可以进行自定义的余地，从UI效果到按钮的触发方法全部由AVKit封装好了，它只是一个唤出系统功能的接口。 三、AVPlayerViewControllerAVPlayerViewController是对AVFoundation中的AVPlayer与AVPlayerLayer的封装，它是一个封装好的视图控制器，包含了视频的播放和控制功能。这个类在iOS8之后可用，解析如下： 1234567891011121314151617181920212223242526272829303132@interface AVPlayerViewController : UIViewController//视频播放器对象@property (nonatomic, strong, nullable) AVPlayer *player;//是否显示视频播放控制组件@property (nonatomic) BOOL showsPlaybackControls;//设置视频的填充方式/*//按比例缩放AVF_EXPORT AVLayerVideoGravity const AVLayerVideoGravityResizeAspect NS_AVAILABLE(10_7, 4_0);//按比例填充AVF_EXPORT AVLayerVideoGravity const AVLayerVideoGravityResizeAspectFill NS_AVAILABLE(10_7, 4_0);//充满AVF_EXPORT AVLayerVideoGravity const AVLayerVideoGravityResize NS_AVAILABLE(10_7, 4_0);*/@property (nonatomic, copy) AVLayerVideoGravity videoGravity;//视频的第一帧是否已经准备好了@property (nonatomic, readonly, getter = isReadyForDisplay) BOOL readyForDisplay;//获取视频的尺寸@property (nonatomic, readonly) CGRect videoBounds;//内容覆盖层 可以向其上添加子视图 会出现在视频层与控制层之间@property (nonatomic, readonly, nullable) UIView *contentOverlayView;//是否允许画中画 iOS9以上可用 ipad可用@property (nonatomic) BOOL allowsPictureInPicturePlayback API_AVAILABLE(ios(9.0));//是否对信息中心的播放器信息进行更新 默认为YES@property (nonatomic) BOOL updatesNowPlayingInfoCenter API_AVAILABLE(ios(10.0));//是否默认进行全屏播放@property (nonatomic) BOOL entersFullScreenWhenPlaybackBegins API_AVAILABLE(ios(11.0));//播放结束后 是否默认退出全屏@property (nonatomic) BOOL exitsFullScreenWhenPlaybackEnds API_AVAILABLE(ios(11.0));//代理@property (nonatomic, weak, nullable) id &lt;AVPlayerViewControllerDelegate&gt; delegate API_AVAILABLE(ios(9.0));@end AVPlayerViewControllerDelegate解析如下： 1234567891011121314//将要开始画中画时调用- (void)playerViewControllerWillStartPictureInPicture:(AVPlayerViewController *)playerViewController;//已经开始画中画时调用- (void)playerViewControllerDidStartPictureInPicture:(AVPlayerViewController *)playerViewController;//开启画中画失败调用- (void)playerViewController:(AVPlayerViewController *)playerViewController failedToStartPictureInPictureWithError:(NSError *)error;//将要结束画中画调用- (void)playerViewControllerWillStopPictureInPicture:(AVPlayerViewController *)playerViewController;//已经结束画中画调用- (void)playerViewControllerDidStopPictureInPicture:(AVPlayerViewController *)playerViewController;//是否自动关闭控制器当画中画开始时- (BOOL)playerViewControllerShouldAutomaticallyDismissAtPictureInPictureStart:(AVPlayerViewController *)playerViewController;//画中画结束后回复之前的用户界面- (void)playerViewController:(AVPlayerViewController *)playerViewController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL restored))completionHandler; 四、AVPictureInPictureControllerAVPictureInPictureController是一个控制器，用来对画中画进行相关操作，解析如下： 1234567891011121314151617181920212223@interface AVPictureInPictureController : NSObject//获取当前设备是否支持画中画+ (BOOL)isPictureInPictureSupported;//画中画转换开始按钮图像+ (UIImage *)pictureInPictureButtonStartImageCompatibleWithTraitCollection:(nullable UITraitCollection *)traitCollection;//画中画转换结束按钮图像+ (UIImage *)pictureInPictureButtonStopImageCompatibleWithTraitCollection:(nullable UITraitCollection *)traitCollection;//构造方法- (nullable instancetype)initWithPlayerLayer:(AVPlayerLayer *)playerLayer;//播放器视图@property (nonatomic, readonly) AVPlayerLayer *playerLayer;//代理@property (nonatomic, weak, nullable) id &lt;AVPictureInPictureControllerDelegate&gt; delegate;//开始画中画- (void)startPictureInPicture;//结束画中画- (void)stopPictureInPicture;//画中画目前是否可用@property (nonatomic, readonly, getter = isPictureInPicturePossible) BOOL pictureInPicturePossible;//画中画是否激活@property (nonatomic, readonly, getter = isPictureInPictureActive) BOOL pictureInPictureActive;//是否支持画中画@property (nonatomic, readonly, getter = isPictureInPictureSuspended) BOOL pictureInPictureSuspended;","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之AssetsLibrary框架使用","slug":"381iOS开发之AssetsLibrary框架使用","date":"2018-09-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.380Z","comments":true,"path":"2018/09/11/381iOS开发之AssetsLibrary框架使用/","link":"","permalink":"http://huishao.cc/2018/09/11/381iOS开发之AssetsLibrary框架使用/","excerpt":"","text":"iOS开发之AssetsLibrary框架使用一、引言AssetsLibrary框架是专门用来操作相册相关资源的一个框架，其是iOS4到iOS9之间常使用的一个框架，在iOS9之后，系统系统了Photos框架代替了AssetsLibrary框架，但是AssetsLibrary框架依然可以使用，并且其结构和设计思路依然值得我们进行分析学习。 二、概述AssetsLibrary框架会操作系统的相册，因此首先需要进行权限的申请，在使用之前，首先需要在Info.plist文件中添加如下键值： Privacy - Photo Library Usage Description AssetsLibrary框架中核心的类关系如下图所示： 三、ALAssetsLibrary资源库对象ALAssetsLibrary类用来构建资源库对象，这个对象用来整体操作系统的相册资源，在使用它之前我们可以使用下面的方法来获取用户的授权情况： 1+ (ALAuthorizationStatus)authorizationStatus; ALAuthorizationStatus枚举定义了用户的授权情况，定义如下： 123456typedef NS_ENUM(NSInteger, ALAuthorizationStatus) &#123; ALAuthorizationStatusNotDetermined, // 用户尚未选择是否授权 ALAuthorizationStatusRestricted, //应用尚未授权 ALAuthorizationStatusDenied), // 用户拒绝授权 ALAuthorizationStatusAuthorized // 用户已经授权&#125; 如果用户尚未授权过，那么任何访问操作都将触发授权机制。 资源库中的资源数据是以组的方式进行存储，下面代码示例了获取资源组的方式： 1234567891011121314151617_library = [[ALAssetsLibrary alloc]init];[_library enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) &#123; if (group) &#123; // 遍历相册还未结束 // 设置过滤器 [group setAssetsFilter:[ALAssetsFilter allPhotos]]; if (group.numberOfAssets) &#123; NSLog(@\"%@\",group); &#125; &#125; else &#123; // 遍历结束（当group为空的时候就意味着结束） NSLog(@\"没有相册列表了\"); &#125; &#125; failureBlock:^(NSError *error) &#123; NSLog(@\"失败\");&#125;]; 上面示例的枚举函数用来根据参数类型获取资源组，ALAssetsGroupType参数决定获取组的类型，可选值枚举如下： 123456789enum &#123; ALAssetsGroupLibrary ,// 编辑库 ALAssetsGroupAlbum ,//相册库 ALAssetsGroupEvent ,//事件库 ALAssetsGroupFaces ,// iTunes同步 ALAssetsGroupSavedPhotos ,// 保存的相片 ALAssetsGroupPhotoStream ,// The PhotoStream album. ALAssetsGroupAll ,//所有库&#125;; 枚举过程中，我们可以过去到ALAssetsGroup类型的对象，这个对象中封装了相片资源信息，后面会介绍。 下面列举了ALAssetsLibrary中其他常用的方法： 12345678910111213141516171819202122232425262728//直接通过URL来获取资源- (void)assetForURL:(NSURL *)assetURL resultBlock:(ALAssetsLibraryAssetForURLResultBlock)resultBlock failureBlock:(ALAssetsLibraryAccessFailureBlock)failureBlock;//直接通过URL来获取资源组- (void)groupForURL:(NSURL *)groupURL resultBlock:(ALAssetsLibraryGroupResultBlock)resultBlock failureBlock:(ALAssetsLibraryAccessFailureBlock)failureBlock;//向相册库中添加一个新的资源组 可以自定义名称- (void)addAssetsGroupAlbumWithName:(NSString *)name resultBlock:(ALAssetsLibraryGroupResultBlock)resultBlock failureBlock:(ALAssetsLibraryAccessFailureBlock)failureBlock;//向相册中写入一张图片 orientation参数设置图片的方向/*typedef NS_ENUM(NSInteger, ALAssetOrientation) &#123; ALAssetOrientationUp , // 向上 默认的 ALAssetOrientationDown , // 向下 ALAssetOrientationLeft , // 向左 ALAssetOrientationRight , // 向右 ALAssetOrientationUpMirrored , // ALAssetOrientationDownMirrored , // horizontal flip ALAssetOrientationLeftMirrored , // vertical flip ALAssetOrientationRightMirrored , // vertical flip&#125;;*/- (void)writeImageToSavedPhotosAlbum:(CGImageRef)imageRef orientation:(ALAssetOrientation)orientation completionBlock:(ALAssetsLibraryWriteImageCompletionBlock)completionBlock;//向相册中写入一张图片 并可以设置图片的元数据- (void)writeImageToSavedPhotosAlbum:(CGImageRef)imageRef metadata:(NSDictionary *)metadata completionBlock:(ALAssetsLibraryWriteImageCompletionBlock)completionBlock;//向相册中写入图片数据 并可以设置元数据- (void)writeImageDataToSavedPhotosAlbum:(NSData *)imageData metadata:(NSDictionary *)metadata completionBlock:(ALAssetsLibraryWriteImageCompletionBlock)completionBlock;//将某个路径的视频写入相册中- (void)writeVideoAtPathToSavedPhotosAlbum:(NSURL *)videoPathURL completionBlock:(ALAssetsLibraryWriteVideoCompletionBlock)completionBlock;//检查路径中的视频是否和相册相兼容- (BOOL)videoAtPathIsCompatibleWithSavedPhotosAlbum:(NSURL *)videoPathURL; 当资源库改变时，系统会发出如下通知： 12//资源库改变的通知extern NSString *const ALAssetsLibraryChangedNotification; 通知中传递的信息中包含如下字段： 12345678//资源库更新extern NSString *const ALAssetLibraryUpdatedAssetsKey;//插入组extern NSString *const ALAssetLibraryInsertedAssetGroupsKey;//更新组extern NSString *const ALAssetLibraryUpdatedAssetGroupsKey;//删除组extern NSString *const ALAssetLibraryDeletedAssetGroupsKey; 下面列举了操作过程中的一些异常定义： 123456789101112enum &#123; ALAssetsLibraryUnknownError = -1, // 未知错误 ALAssetsLibraryWriteFailedError = -3300, //写入错误 ALAssetsLibraryWriteBusyError = -3301, // 写入繁忙 可以重试 ALAssetsLibraryWriteInvalidDataError = -3302, // 无效数据 ALAssetsLibraryWriteIncompatibleDataError = -3303, // 不兼容的数据 ALAssetsLibraryWriteDataEncodingError = -3304, // 数据编码错误 ALAssetsLibraryWriteDiskSpaceError = -3305, // 内存不足 ALAssetsLibraryDataUnavailableError = -3310, // 数据不可用 ALAssetsLibraryAccessUserDeniedError = -3311, // 权限错误 ALAssetsLibraryAccessGloballyDeniedError = -3312, // 权限错误&#125;; 四、ALAssetsGroup资源组对象资源组其实就是对应与我们相册中的一组资源，我们可以通过如下的方便遍历出其中的所有资源： 123456789101112131415161718_library = [[ALAssetsLibrary alloc]init];[_library enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) &#123; if (group) &#123; // 遍历相册还未结束 // 设置过滤器 [group setAssetsFilter:[ALAssetsFilter allPhotos]]; if (group.numberOfAssets) &#123; [group enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) &#123; NSLog(@\"%d:%@\",index,result); &#125;]; &#125; &#125; else &#123; // 遍历结束（当group为空的时候就意味着结束） NSLog(@\"没有相册列表了\"); &#125;&#125; failureBlock:^(NSError *error) &#123; NSLog(@\"失败\");&#125;]; ALAssetsGroup中相关方法解析如下： 12345678910111213141516171819202122232425262728//获取相关属性/*extern NSString *const ALAssetsGroupPropertyName;//组名字extern NSString *const ALAssetsGroupPropertyType;//组类型extern NSString *const ALAssetsGroupPropertyPersistentID; //IDextern NSString *const ALAssetsGroupPropertyURL;//组URL*/- (id)valueForProperty:(NSString *)property;//获取当前组的缩略图海报- (CGImageRef)posterImage;//设置过滤器- (void)setAssetsFilter:(ALAssetsFilter *)filter;//获取组中资源个数- (NSInteger)numberOfAssets;//进行资源枚举- (void)enumerateAssetsUsingBlock:(ALAssetsGroupEnumerationResultsBlock)enumerationBlock;/*typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) &#123; NSEnumerationConcurrent = (1UL &lt;&lt; 0),//顺序枚举 NSEnumerationReverse = (1UL &lt;&lt; 1), //逆序枚举&#125;;*/- (void)enumerateAssetsWithOptions:(NSEnumerationOptions)options usingBlock:(ALAssetsGroupEnumerationResultsBlock)enumerationBlock;- (void)enumerateAssetsAtIndexes:(NSIndexSet *)indexSet options:(NSEnumerationOptions)options usingBlock:(ALAssetsGroupEnumerationResultsBlock)enumerationBlock;//获取当前组是否允许编辑@property (nonatomic, readonly, getter=isEditable) BOOL editable;//向组中添加一个资源- (BOOL)addAsset:(ALAsset *)asset; 上面有提到资源过滤器，资源过滤器用来设置过滤组中的资源，有3个类方法可以直接获取系统提供的过滤器： 12345678@interface ALAssetsFilter : NSObject &#123;//所有图片资源+ (ALAssetsFilter *)allPhotos;// 所有视频资源+ (ALAssetsFilter *)allVideos;// 所有资源+ (ALAssetsFilter *)allAssets;@end 五、ALAsset资源对象ALAsset是封装好的资源对象类，如下方法可以获取到资源中封装的属性： 1- (id)valueForProperty:(NSString *)property; 属性名的定义如下： 12345678910111213141516//获取资源类型/*这个属性将返回一个字符串extern NSString *const ALAssetTypePhoto//照片类型extern NSString *const ALAssetTypeVideo//视频类型extern NSString *const ALAssetTypeUnknown//未知类型*/extern NSString *const ALAssetPropertyType;//会返回一个CLLocation对象 图片的地址信息extern NSString *const ALAssetPropertyLocation;//视频资源的时长 NSNumber对象extern NSString *const ALAssetPropertyDuration;//资源方向extern NSString *const ALAssetPropertyOrientation;//资源日期 会返回NSDate对象extern NSString *const ALAssetPropertyDate; 下面列举了ALAsset中常用方法： 12345678910111213141516171819//获取默认的Representation对象- (ALAssetRepresentation *)defaultRepresentation;//获取指定的Representation对象- (ALAssetRepresentation *)representationForUTI:(NSString *)representationUTI;//获取资源缩略图- (CGImageRef)thumbnail;- (CGImageRef)aspectRatioThumbnail;//写入图片数据- (void)writeModifiedImageDataToSavedPhotosAlbum:(NSData *)imageData metadata:(NSDictionary *)metadata completionBlock:(ALAssetsLibraryWriteImageCompletionBlock)completionBlock;//写入视频数据- (void)writeModifiedVideoAtPathToSavedPhotosAlbum:(NSURL *)videoPathURL completionBlock:(ALAssetsLibraryWriteVideoCompletionBlock)completionBlock;//原始资源对象@property (nonatomic, readonly) ALAsset *originalAsset;//是否允许编辑@property (nonatomic, readonly, getter=isEditable) BOOL editable;//替换图片数据- (void)setImageData:(NSData *)imageData metadata:(NSDictionary *)metadata completionBlock:(ALAssetsLibraryWriteImageCompletionBlock)completionBlock;//替换视频数据- (void)setVideoAtPath:(NSURL *)videoPathURL completionBlock:(ALAssetsLibraryWriteVideoCompletionBlock)completionBlock; 六、关于ALAssetRepresentation类每一个ALAsset对象中都封装了一个ALAssetRepresentation对象，这个对象的作用是获取资源的详细信息，解析如下： 1234567891011121314151617181920212223//获取UTI- (NSString *)UTI;//获取资源的尺寸- (CGSize)dimensions;//获取资源的大小- (long long)size;//读取数据- (NSUInteger)getBytes:(uint8_t *)buffer fromOffset:(long long)offset length:(NSUInteger)length error:(NSError **)error;//获取图片数据- (CGImageRef)fullResolutionImage;- (CGImageRef)CGImageWithOptions:(NSDictionary *)options;//获取全屏图片- (CGImageRef)fullScreenImage;//获取资源URL- (NSURL *)url;//获取资源元数据- (NSDictionary *)metadata;//获取资源方向- (ALAssetOrientation)orientation;//缩放比- (float)scale;//获取资源名称- (NSString *)filename;","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之AdSupport框架使用","slug":"380 iOS开发之AdSupport框架使用","date":"2018-09-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.379Z","comments":true,"path":"2018/09/10/380 iOS开发之AdSupport框架使用/","link":"","permalink":"http://huishao.cc/2018/09/10/380 iOS开发之AdSupport框架使用/","excerpt":"","text":"iOS开发之AdSupport框架使用AdSupport从字面意思上理解是用来进行广告支持，这个框架十分简单，里面只有一个类，类中只有一个方法和两个属性。 AdSupport的唯一用途是用来获取设备唯一的一个广告标识符。可以使用此标识符用来标记用户是否来源于某个广告推广，设备重启，重装应用程序都不会使广告标识符修改。 123456789@interface ASIdentifierManager : NSObject//获取单例管理类+ (ASIdentifierManager * _Nonnull)sharedManager;//获取广告标识符@property (nonnull, nonatomic, readonly) NSUUID *advertisingIdentifier;//用户是否同意跟踪广告标识符@property (nonatomic, readonly, getter=isAdvertisingTrackingEnabled) BOOL advertisingTrackingEnabled;@end","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之AddressBookUI框架详解","slug":"379iOS开发之AddressBookUI框架详解","date":"2018-08-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.379Z","comments":true,"path":"2018/08/23/379iOS开发之AddressBookUI框架详解/","link":"","permalink":"http://huishao.cc/2018/08/23/379iOS开发之AddressBookUI框架详解/","excerpt":"","text":"iOS开发之AddressBookUI框架详解一、关于AddressBookUI框架AddressbookUI是iOS开发框架中提供的一套通讯录界面组件。其中封装好了一套选择联系人，查看联系人的界面，在需要时开发者可以直接调用。当然对于联系人界面，开发者也可以进行完全的自定义，下面链接博客中介绍了如何使用AddressBook框架操作通讯录与联系人。 https://my.oschina.net/u/2340880/blog/1930414 AddressBookUI框架主要提供了如下几个类： ABNewPersonViewController：新建联系人界面视图控制器 ABPeoplePickerNavigationController：从通讯录选择联系人界面视图控制器 ABPersonViewController：联系人详情界面视图控制器 ABUnknownPersonViewController：一个未在当前通讯录中的联系人查看界面，可以添加和编辑 二、ABNewPersonViewController新建联系人界面ABNewPersonViewController类的使用非常简单，示例如下： 123ABNewPersonViewController *picker = [[ABNewPersonViewController alloc] init];picker.newPersonViewDelegate = self;[self presentModalViewController:picker animated:YES]; 效果如下图所示： ABNewPersonViewController解析如下： 12345678//代理@property(nonatomic,assign,nullable) id&lt;ABNewPersonViewControllerDelegate&gt; newPersonViewDelegate;//通讯录实例 只读@property(nonatomic,readwrite,nullable) ABAddressBookRef addressBook;//联系人 只读@property(nonatomic,readwrite,nullable) ABRecordRef displayedPerson;//联系人组 只读@property(nonatomic,readwrite,nullable) ABRecordRef parentGroup; 联系人的新建回调可以在代理方法中处理，如下： 1234@protocol ABNewPersonViewControllerDelegate &lt;NSObject&gt;//新建联系人完成后的回调- (void)newPersonViewController:(ABNewPersonViewController *)newPersonView didCompleteWithNewPerson:(nullable ABRecordRef)person;@end 三、ABPeoplePickerNavigationController选择联系人界面ABPeoplePickerNavigationController是用户通讯录界面，开发者在需要用户选择联系人时，可以直接调用这个界面来让用户进行选择，示例如下： 123ABPeoplePickerNavigationController *vc = [[ABPeoplePickerNavigationController alloc] init];vc.peoplePickerDelegate = self;[self presentViewController:vc animated:YES completion:nil]; 效果如下图： ABPeoplePickerNavigationController解析如下： 123456789101112//代理@property(nonatomic,assign,nullable) id&lt;ABPeoplePickerNavigationControllerDelegate&gt; peoplePickerDelegate;//需要展示的用户联系人属性字段 数组中为属性的ID 在AddressBook框架介绍的博客中有讲解@property(nonatomic,copy,nullable) NSArray&lt;NSNumber*&gt; *displayedProperties;//通讯录实例@property(nonatomic,readwrite,nullable) ABAddressBookRef addressBook;//设置一个筛选条件 过滤掉不可显示的联系人@property(nonatomic,copy,nullable) NSPredicate *predicateForEnablingPerson;//设置一个筛选条件 过滤掉不可选择的联系人@property(nonatomic,copy,nullable) NSPredicate *predicateForSelectionOfPerson;//设置一个筛选条件 过滤掉不可显示的属性@property(nonatomic,copy,nullable) NSPredicate *predicateForSelectionOfProperty; 用来进行联系人筛选的属性定义如下： 1234567891011121314151617181920212223extern NSString * const ABPersonNamePrefixProperty NS_AVAILABLE_IOS(8_0);extern NSString * const ABPersonGivenNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonMiddleNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonFamilyNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonNameSuffixProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonPreviousFamilyNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonNicknameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonPhoneticGivenNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonPhoneticMiddleNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonPhoneticFamilyNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonOrganizationNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonDepartmentNameProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonJobTitleProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonBirthdayProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonNoteProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonPhoneNumbersProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonEmailAddressesProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonUrlAddressesProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonDatesProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonInstantMessageAddressesProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonRelatedNamesProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonSocialProfilesProperty NS_AVAILABLE_IOS(8_0); extern NSString * const ABPersonPostalAddressesProperty NS_AVAILABLE_IOS(8_0); ABPeoplePickerNavigationControllerDelegate中方法解释如下： 123456//选中联系人进行回调- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController*)peoplePicker didSelectPerson:(ABRecordRef)person;//选择联系人属性- (void)peoplePickerNavigationController:(ABPeoplePickerNavigationController*)peoplePicker didSelectPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier;//取消选择- (void)peoplePickerNavigationControllerDidCancel:(ABPeoplePickerNavigationController *)peoplePicker; 四、ABPersonViewController联系人详情界面ABPersonViewController是联系人的详情展示界面，简单使用如下： 1234567891011CFErrorRef error = NULL;ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, &amp;error);CFArrayRef peopleArray = ABAddressBookCopyArrayOfAllPeople(addressBook);ABRecordRef person = CFArrayGetValueAtIndex(peopleArray, 0);ABPersonViewController *viewController = [[ABPersonViewController alloc] init];viewController.personViewDelegate = self;viewController.displayedPerson = person;viewController.allowsActions = NO;viewController.allowsEditing = YES;viewController.displayedProperties = @[[NSNumber numberWithInt:kABPersonPhoneProperty]];[self presentViewController:viewController animated:YES completion:nil]; 界面如下： ABPersonViewController中常用属性方法解析如下： 12345678910111213141516//代理@property(nonatomic,assign,nullable) id&lt;ABPersonViewControllerDelegate&gt; personViewDelegate;//通讯录实例@property(nonatomic,readwrite,nullable) ABAddressBookRef addressBook;//联系人记录实例@property(nonatomic,readwrite) ABRecordRef displayedPerson;//展示的属性字段@property(nonatomic,copy,nullable) NSArray&lt;NSNumber*&gt; *displayedProperties;//是否允许编辑@property(nonatomic) BOOL allowsEditing;//是否允许活动按钮 例如分享@property(nonatomic) BOOL allowsActions;//是否允许关联其他联系人@property(nonatomic) BOOL shouldShowLinkedPeople;//设置属性高亮- (void)setHighlightedItemForProperty:(ABPropertyID)property withIdentifier:(ABMultiValueIdentifier)identifier; ABPersonViewControllerDelegate中方法解释如下： 12//选择属性发送时调用- (BOOL)personViewController:(ABPersonViewController *)personViewController shouldPerformDefaultActionForPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier; 五、关于ABUnknownPersonViewControllerABUnknownPersonViewController界面与ABPersonViewController基本一致，不同的是，ABPersonViewController需要使用一个通讯录中已经存在的联系人作为参数进行展示，ABUnknownPersonViewController则不然，你可以使用一个通讯录中不存在的联系人对象来进行界面的渲染，并且支持用户选择将此联系人存入通讯录中。示例如下： 1234ABUnknownPersonViewController *unknown=[[ABUnknownPersonViewController alloc]init];unknown.displayedPerson=ABPersonCreate();unknown.allowsAddingToAddressBook=YES;//允许添加[self presentViewController:unknown animated:YES completion:nil]; ABUnknownPersonViewController中属性方法解释如下： 1234567891011121314//代理@property(nonatomic,assign,nullable) id&lt;ABUnknownPersonViewControllerDelegate&gt; unknownPersonViewDelegate;//通讯录实例对象@property(nonatomic,readwrite,nullable) ABAddressBookRef addressBook;//联系人实例@property(nonatomic,readwrite) ABRecordRef displayedPerson;//提示名字@property(nonatomic,copy,nullable) NSString *alternateName;//提示信息@property(nonatomic,copy,nullable) NSString *message;//是否允许活动@property(nonatomic) BOOL allowsActions;//是否允许添加电话本@property(nonatomic) BOOL allowsAddingToAddressBook; ABUnknownPersonViewControllerDelegate方法： 1234//联系人解释时调用- (void)unknownPersonViewController:(ABUnknownPersonViewController *)unknownCardViewController didResolveToPerson:(nullable ABRecordRef)person;//发送活动- (BOOL)unknownPersonViewController:(ABUnknownPersonViewController *)personViewController shouldPerformDefaultActionForPerson:(ABRecordRef)person property:(ABPropertyID)property identifier:(ABMultiValueIdentifier)identifier;","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之AddressBook框架详解","slug":"378iOS开发之AddressBook框架详解","date":"2018-08-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.379Z","comments":true,"path":"2018/08/19/378iOS开发之AddressBook框架详解/","link":"","permalink":"http://huishao.cc/2018/08/19/378iOS开发之AddressBook框架详解/","excerpt":"","text":"iOS开发之AddressBook框架详解一、写在前面首先，AddressBook框架是一个已经过时的框架，iOS9之后官方提供了Contacts框架来进行用户通讯录相关操作。尽管如此，AddressBook框架依然是一个非常优雅并且使用方便的通讯录帮助库。本篇博客只要总结AddressBook框架的相关使用方法。 在AddressBook框架中，两个最重要的数据模型为ABAddressbookRef与ABRecordRef。前者我们可以理解为通讯录的抽象对象，用它来具体操作通讯录的行为，后者可以理解为通讯录中记录的抽象对象，其中封装了联系人的相关信息。如下图所示： 二、关于用户权限申请在应用程序内，若需要使用用户的通讯录权限需要征得用户的同意(毕竟通讯录属于用户隐私)。因此，在使用之前，开发者首先需要进行权限的申请，首先，需要在info.plist文件中添加如下键： Privacy - Contacts Usage Description 使用如下代码进行使用权限的申请： 123456789101112131415//获取用户授权状态ABAuthorizationStatus status = ABAddressBookGetAuthorizationStatus();//如果尚未获取过授权 进行授权申请if (status==kABAuthorizationStatusNotDetermined) &#123; //创建通讯录对象 这个方法中第1个参数为预留参数 传NULL 即可 第2个参数可以传一个CFErrorRef的指针 ABAddressBookRef addressBookRef = ABAddressBookCreateWithOptions(NULL, NULL); //请求授权 ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; if (granted) &#123;//请求授权页面用户同意授权 //可以进行使用 &#125; //释放内存 CFRelease(addressBookRef); &#125;);&#125; ABAuthorizationStatus是授权状态的枚举，意义如下： 123456typedef CF_ENUM(CFIndex, ABAuthorizationStatus) &#123; kABAuthorizationStatusNotDetermined = 0, // 尚未申请过授权 kABAuthorizationStatusRestricted, // 授权被限制 无法使用 kABAuthorizationStatusDenied, // 用户拒绝授权 kABAuthorizationStatusAuthorized // 已经授权&#125; 三、获取基础的通讯录信息下面代码演示了如何获取基础的通讯录联系人信息： 1234567891011121314151617181920212223242526272829303132333435363738394041//获取通讯录ABAddressBookRef addressBook = ABAddressBookCreateWithOptions(NULL, NULL);//获取联系人数量CFIndex personCount = ABAddressBookGetPersonCount(addressBook);//拿到所有联系人CFArrayRef peopleArray = ABAddressBookCopyArrayOfAllPeople(addressBook);for (int i = 0; i &lt; personCount; i++) &#123; //获取记录 ABRecordRef person = CFArrayGetValueAtIndex(peopleArray, i); //拿到姓名 //姓 需要转换成NSString类型 NSString *lastNameValue = (__bridge_transfer NSString *)ABRecordCopyValue(person, kABPersonLastNameProperty); //名 NSString *firstNameValue = (__bridge_transfer NSString *)ABRecordCopyValue(person, kABPersonFirstNameProperty); NSLog(@\"%@:%@\",lastNameValue,firstNameValue); //拿到电话 电话可能有多个 ABMultiValueRef phones = ABRecordCopyValue(person, kABPersonPhoneProperty); //解析电话数据 CFIndex phoneCount = ABMultiValueGetCount(phones); for (int j = 0; j &lt; phoneCount ; j++) &#123; //电话标签本地化(例如是住宅,工作等) NSString *phoneLabel = (__bridge_transfer NSString *)ABAddressBookCopyLocalizedLabel(ABMultiValueCopyLabelAtIndex(phones, j)); //拿到标签下对应的电话号码 NSString *phoneValue = (__bridge_transfer NSString *)ABMultiValueCopyValueAtIndex(phones, j); NSLog(@\"%@:%@\",phoneLabel,phoneValue); &#125; CFRelease(phones); //邮箱 可能多个 ABMultiValueRef emails = ABRecordCopyValue(person, kABPersonEmailProperty); CFIndex emailCount = ABMultiValueGetCount(emails); for (int k = 0; k &lt; emailCount; k++) &#123; NSString *emailLabel = (__bridge_transfer NSString *)ABAddressBookCopyLocalizedLabel(ABMultiValueCopyLabelAtIndex(emails, k)); NSString *emailValue = (__bridge_transfer NSString *)ABMultiValueCopyValueAtIndex(emails, k); NSLog(@\"%@:%@\",emailLabel,emailValue); &#125; NSLog(@\"==============\"); CFRelease(emails);&#125;CFRelease(addressBook);CFRelease(peopleArray); 打印信息如下： 关于可获取到的联系人属性，键值列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//名kABPersonFirstNameProperty//姓kABPersonLastNameProperty//中间名kABPersonMiddleNameProperty//前缀 用户在存储联系人时 可以添加自定义的前缀 例如 女士 男士等等kABPersonPrefixProperty//后缀kABPersonSuffixProperty//昵称kABPersonNicknameProperty//姓发音说明字段 用户自定义的kABPersonFirstNamePhoneticProperty//名发音说明字段 用户自定义的kABPersonLastNamePhoneticProperty//中间名发音说明字段 用户自定义的kABPersonMiddleNamePhoneticProperty//公司名kABPersonOrganizationProperty//部门名kABPersonDepartmentProperty//头衔kABPersonJobTitleProperty//电子邮件信息 返回一组 需要手动解析kABPersonEmailProperty//返回生日信息 日期对象kABPersonBirthdayProperty//笔记信息kABPersonNoteProperty//记录的创建日期kABPersonCreationDateProperty//记录的最后修改日期kABPersonModificationDateProperty//地址信息 返回 一组/*例如：ABMultiValueRef address = ABRecordCopyValue(person, kABPersonAddressProperty); for (int j=0; j&lt;ABMultiValueGetCount(address); j++) &#123; //地址类型 NSString *type = (__bridge NSString *)(ABMultiValueCopyLabelAtIndex(address, j)); NSDictionary * temDic = (__bridge NSDictionary *)(ABMultiValueCopyValueAtIndex(address, j)); //地址字符串，可以按需求格式化 NSString * adress = [NSString stringWithFormat:@\"国家:%@\\n省:%@\\n市:%@\\n街道:%@\\n邮编:%@\",[temDic valueForKey:(NSString*)kABPersonAddressCountryKey],[temDic valueForKey:(NSString*)kABPersonAddressStateKey],[temDic valueForKey:(NSString*)kABPersonAddressCityKey],[temDic valueForKey:(NSString*)kABPersonAddressStreetKey],[temDic valueForKey:(NSString*)kABPersonAddressZIPKey]]; &#125;*/kABPersonAddressProperty//地址字典中的街道信息键kABPersonAddressStreetKey//地址字典中的城市信息键kABPersonAddressCityKey//地址字典中的地区信息键kABPersonAddressStateKey//地址字典中的压缩码信息键kABPersonAddressZIPKey//地址字典中的国家信息键kABPersonAddressCountryKey//地址字典中的国家编码信息键kABPersonAddressCountryCodeKey//获取 一组 纪念日日期 kABPersonDateProperty//从具体的日期实体中获取纪念日 标签kABPersonAnniversaryLabel//获取一组电话号码kABPersonPhoneProperty//下面这些对应电话类型kABPersonPhoneMobileLabelkABPersonPhoneIPhoneLabelkABPersonPhoneMainLabelkABPersonPhoneHomeFAXLabelkABPersonPhoneWorkFAXLabelkABPersonPhoneOtherFAXLabelkABPersonPhonePagerLabel//获取社交相关信息kABPersonInstantMessageProperty//下面这些对应社交平台kABPersonInstantMessageServiceKey kABPersonInstantMessageServiceYahookABPersonInstantMessageServiceJabberkABPersonInstantMessageServiceMSNkABPersonInstantMessageServiceICQkABPersonInstantMessageServiceAIMkABPersonInstantMessageServiceQQ kABPersonInstantMessageServiceGoogleTalkkABPersonInstantMessageServiceSkypekABPersonInstantMessageServiceFacebookkABPersonInstantMessageServiceGaduGadu//社交用户名kABPersonInstantMessageUsernameKey//获取一组urlkABPersonURLProperty//url相关标签kABPersonHomePageLabel//关联信息kABPersonRelatedNamesProperty//关联信息相关的标签kABPersonFatherLabel kABPersonMotherLabel kABPersonParentLabelkABPersonBrotherLabel kABPersonSisterLabel kABPersonChildLabelkABPersonFriendLabelkABPersonSpouseLabel kABPersonPartnerLabel kABPersonAssistantLabelkABPersonManagerLabel//获取社交账户相关kABPersonSocialProfileProperty//社交账户相关keykABPersonSocialProfileURLKeykABPersonSocialProfileServiceKeykABPersonSocialProfileUsernameKeykABPersonSocialProfileUserIdentifierKeykABPersonSocialProfileServiceTwitterkABPersonSocialProfileServiceSinaWeibokABPersonSocialProfileServiceGameCenterkABPersonSocialProfileServiceFacebookkABPersonSocialProfileServiceMyspacekABPersonSocialProfileServiceLinkedInkABPersonSocialProfileServiceFlickr//周期性日期信息kABPersonAlternateBirthdayProperty//周期性日期相关键kABPersonAlternateBirthdayCalendarIdentifierKeykABPersonAlternateBirthdayEraKeykABPersonAlternateBirthdayYearKeykABPersonAlternateBirthdayMonthKeykABPersonAlternateBirthdayIsLeapMonthKeykABPersonAlternateBirthdayDayKey 四、关于ABMultiValueRef如上所述，我们在获取联系人相关信息时，很多场景都会获取一组，例如对于电话号码，地址，邮箱这类的数据。在AddressBook框架中，这一组数据被封装为ABMultiValueRef对象。对于ABMultiValueRef对象，有如下方法可以对其进行处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//获取内部封装值的类型/*enum &#123; kABInvalidPropertyType = 0x0, // 无效 kABStringPropertyType = 0x1, // 字符串 kABIntegerPropertyType = 0x2, // 整数 kABRealPropertyType = 0x3, // 属性 kABDateTimePropertyType = 0x4, // 时间 kABDictionaryPropertyType = 0x5, // 字典 kABMultiStringPropertyType = kABMultiValueMask | kABStringPropertyType, // 聚合字符串 kABMultiIntegerPropertyType = kABMultiValueMask | kABIntegerPropertyType, // 聚合整型 kABMultiRealPropertyType = kABMultiValueMask | kABRealPropertyType, // 聚合属性 kABMultiDateTimePropertyType = kABMultiValueMask | kABDateTimePropertyType, // 聚合时间 kABMultiDictionaryPropertyType = kABMultiValueMask | kABDictionaryPropertyType, // 聚合字典&#125;;*/ABPropertyType ABMultiValueGetPropertyType(ABMultiValueRef multiValue)//获取其中封装的值的个数CFIndex ABMultiValueGetCount(ABMultiValueRef multiValue)//根据索引获取值ABMultiValueCopyValueAtIndex(ABMultiValueRef multiValue, CFIndex index)//获取所有的值 组成数组CFArrayRef ABMultiValueCopyArrayOfAllValues(ABMultiValueRef multiValue)//根据索引获取标签CFStringRef ABMultiValueCopyLabelAtIndex(ABMultiValueRef multiValue, CFIndex index)//根据ID获取值ABMultiValueIdentifier ABMultiValueGetIdentifierAtIndex(ABMultiValueRef multiValue, CFIndex index)//根据ID 获取索引CFIndex ABMultiValueGetIndexForIdentifier(ABMultiValueRef multiValue, ABMultiValueIdentifier identifier)//获取第一个值CFIndex ABMultiValueGetFirstIndexOfValue(ABMultiValueRef multiValue, CFTypeRef value)//下面这些与写联系人信息相关//创建一个可变的数据对象 ABMutableMultiValueRef ABMultiValueCreateMutable(ABPropertyType type)//为某个标签添加值bool ABMultiValueAddValueAndLabel(ABMutableMultiValueRef multiValue, CFTypeRef value, CFStringRef label, ABMultiValueIdentifier *outIdentifier)//在某个索引处插入 标签和值bool ABMultiValueInsertValueAndLabelAtIndex(ABMutableMultiValueRef multiValue, CFTypeRef value, CFStringRef label, CFIndex index, ABMultiValueIdentifier *outIdentifier)//删除某个索引处的标签和值bool ABMultiValueRemoveValueAndLabelAtIndex(ABMutableMultiValueRef multiValue, CFIndex index)//替换某个索引处的值bool ABMultiValueReplaceValueAtIndex(ABMutableMultiValueRef multiValue, CFTypeRef value, CFIndex index)//替换某个索引处的标签bool ABMultiValueReplaceLabelAtIndex(ABMutableMultiValueRef multiValue, CFStringRef label, CFIndex index) 五、ABRecordRef对象ABRecordRef虽然很多时候，我们可以把它理解为联系人对象，但是其实并不正确，实际上它是一个抽象的记录对象，在AddressBook框架中有3种类型的ABRecordRef： 12345enum &#123; kABPersonType = 0, //联系人类型 kABGroupType = 1, //组类型 kABSourceType = 2 //资源类型&#125;; 可以操作ABRecordRef的方法非常简单，无非读与写，如下： 12345678//获取记录类型ABRecordType ABRecordGetRecordType(ABRecordRef record);//获取记录中的数据CFTypeRef ABRecordCopyValue(ABRecordRef record, ABPropertyID property);//设置记录中的数据bool ABRecordSetValue(ABRecordRef record, ABPropertyID property, CFTypeRef value, CFErrorRef* error);//删除记录中的数据bool ABRecordRemoveValue(ABRecordRef record, ABPropertyID property, CFErrorRef* error); 六、联系人组在iOS系统的联系人应用中，我们可以对联系人进行分组，如下图所示： AddressBook框架中的如下方法与联系人组操作相关： 123456789101112131415161718192021//创建一个联系人组记录ABRecordRef ABGroupCreate(void);//在指定的资源中创建ABRecordRef ABGroupCreateInSource(ABRecordRef source);//获取资源ABRecordRef ABGroupCopySource(ABRecordRef group);//获取组中的所有成员CFArrayRef ABGroupCopyArrayOfAllMembers(ABRecordRef group);//根据指定的排序方法获取组中所有成员CFArrayRef ABGroupCopyArrayOfAllMembersWithSortOrdering(ABRecordRef group, ABPersonSortOrdering sortOrdering);//向组中添加成员bool ABGroupAddMember(ABRecordRef group, ABRecordRef person, CFErrorRef* error);//删除组中的成员bool ABGroupRemoveMember(ABRecordRef group, ABRecordRef member, CFErrorRef* error);//根据某条记录获取组ABRecordRef ABAddressBookGetGroupWithRecordID(ABAddressBookRef addressBook, ABRecordID recordID);//获取通讯录中所有组的个数CFIndex ABAddressBookGetGroupCount(ABAddressBookRef addressBook);//获取通讯录中所有组CFArrayRef ABAddressBookCopyArrayOfAllGroups(ABAddressBookRef addressBook);CFArrayRef ABAddressBookCopyArrayOfAllGroupsInSource(ABAddressBookRef addressBook, ABRecordRef source); 七、重中之重——ABAddressBookRef对象前面介绍了许多操作联系人，操作组的方法，所有这些操作的基础都是基于一个通讯录对象ABAddressBookRef的。除了最前面演示的申请权限的相关方法，如下列举了与ABAddressBookRef相关的其他常用函数： 12345678910111213141516//存储通讯录bool ABAddressBookSave(ABAddressBookRef addressBook, CFErrorRef* error);//获取通讯录是否有未保存的更改bool ABAddressBookHasUnsavedChanges(ABAddressBookRef addressBook);//向通讯录中添加一条记录bool ABAddressBookAddRecord(ABAddressBookRef addressBook, ABRecordRef record, CFErrorRef* error);//移除通讯录中的一条记录bool ABAddressBookRemoveRecord(ABAddressBookRef addressBook, ABRecordRef record, CFErrorRef* error);//注册通讯录发生变化时的外部监听void ABAddressBookRegisterExternalChangeCallback(ABAddressBookRef addressBook, ABExternalChangeCallback callback, void *context);//移除通讯录发生变化时的外部监听void ABAddressBookUnregisterExternalChangeCallback(ABAddressBookRef addressBook, ABExternalChangeCallback callback, void *context);//将未保存的更改重置void ABAddressBookRevert(ABAddressBookRef addressBook);//工具方法，进行标签的本地化转换CFStringRef ABAddressBookCopyLocalizedLabel(CFStringRef label);","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发之Accounts框架详解","slug":"377iOS开发之Accounts框架详解","date":"2018-08-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.378Z","comments":true,"path":"2018/08/06/377iOS开发之Accounts框架详解/","link":"","permalink":"http://huishao.cc/2018/08/06/377iOS开发之Accounts框架详解/","excerpt":"","text":"iOS开发之Accounts框架详解Accounts框架是iOS原生提供的一套账户管理框架，其支持Facebook，新浪微博，腾讯微博，Twitter和领英账户管理的功能。需要注意，在iOS 11及以上系统中，将此功能已经删除，因此Accounts.framework实际上已经没有太大的意义，其只在iOS 11之前的系统上可用。 一、Accounts框架概览 从上图可以看出，Accounts框架中最重要的3个类是ACAccountCredential类、ACAccount类和ACAccountStore类。后面我们着重介绍这3个类。 首先先来看ACAccountType类，这个类用来定义账户类型，如下： 12345678@interface ACAccountType : NSObject//类型描述@property (readonly, nonatomic) NSString *accountTypeDescription;//标识符@property (readonly, nonatomic) NSString *identifier;//此类账户是否已经授权@property (readonly, nonatomic) BOOL accessGranted;@end 需要注意，这个类中的属性都是只读的，这也就是说，开发者不能够直接使用这个类进行对象的构建，需要借助ACAccountStore类来创建ACAccountType实例，后面会介绍。 ACErrorCode定义了错误码的意义，如下： 12345678910111213141516171819202122232425typedef enum ACErrorCode &#123; ACErrorUnknown = 1,//未知错误 ACErrorAccountMissingRequiredProperty, // 缺少必选属性错误 ACErrorAccountAuthenticationFailed, // 授权失败 ACErrorAccountTypeInvalid, // 授权无效 ACErrorAccountAlreadyExists, // 账户已经存在 ACErrorAccountNotFound, // 账户未找到 ACErrorPermissionDenied, // 没有权限 ACErrorAccessInfoInvalid, // 信息失效 ACErrorClientPermissionDenied, // 客户端没有权限 ACErrorAccessDeniedByProtectionPolicy, // 无法取得证书 ACErrorCredentialNotFound, // 证书未找到 ACErrorFetchCredentialFailed, // 请求证书失败 ACErrorStoreCredentialFailed, // 存储证书失败 ACErrorRemoveCredentialFailed, // 删除证书失败 ACErrorUpdatingNonexistentAccount, // 更新失败 ACErrorInvalidClientBundleID, // 无效的BundleID ACErrorDeniedByPlugin, // 权限被阻止 ACErrorCoreDataSaveFailed, // 数据库存储失败 ACErrorFailedSerializingAccountInfo, //序列化数据失败 ACErrorInvalidCommand, //无效的命令 ACErrorMissingTransportMessageID, //缺少安全信息 ACErrorCredentialItemNotFound, // 证书缺少字段 ACErrorCredentialItemNotExpired, // 证书字段失效&#125; ACErrorCode; 二、进行账户操作在iOS 11以下的系统中，在设置中可以找到账户管理选项，如下图： 点击相应的社交平台，通过账号密码可以进行登录。这里一旦设置登录，那么在第三方应用程序中便可以通过Accounts框架来获取授权信息。 首先，要使用Accounts框架，需要导入相应头文件，如下： 1#import &lt;Accounts/Accounts.h&gt; 但应用程序首次使用用户社交平台的账户时，需要获取用户的授权，示例代码如下： 1234567891011121314//创建操作对象ACAccountStore *accountStore = [[ACAccountStore alloc] init];//通过操作对象 构建社交平台类型示例 这里采用的新浪微博ACAccountType *accountType = [accountStore accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierSinaWeibo];//进行用户授权请求[accountStore requestAccessToAccountsWithType: accountType options:nil completion:^(BOOL granted, NSError *error) &#123; if (error) &#123; NSLog(@\"error = %@\", [error localizedDescription]); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; if(granted)&#123; NSLog(@\"授权通过了\"); &#125;);&#125;]; 获取用户授权界面如下图所示： 一旦用户授权通过，可以使用如下方法获取到用户的社交平台账户信息： 123ACAccountStore *accountStore = [[ACAccountStore alloc] init];ACAccountType *accountType = [accountStore accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierSinaWeibo];NSArray *twitterAccounts = [accountStore accountsWithAccountType:accountType]; Accounts框架支持的社交平台类型ID如下： 12345NSString * const ACAccountTypeIdentifierTwitter;//TwitterNSString * const ACAccountTypeIdentifierFacebook;//FacebookNSString * const ACAccountTypeIdentifierSinaWeibo;//新浪微博NSString * const ACAccountTypeIdentifierTencentWeibo;//腾讯微博NSString * const ACAccountTypeIdentifierLinkedIn;//领英 在调用requestAccessToAccountsWithType方法时，可以传入一个字典参数，某些社交平台的授权需要配置一些额外参数，例如： 123456789101112//facebook相关NSString * const ACFacebookAppIdKey;//设置appidNSString * const ACFacebookPermissionsKey;//设置权限keyNSString * const ACFacebookAudienceKey; //权限keyNSString * const ACFacebookAudienceEveryone;//公开权限NSString * const ACFacebookAudienceFriends;//好友权限NSString * const ACFacebookAudienceOnlyMe;//私人权限//领英相关NSString * const ACLinkedInAppIdKey;//领英appidNSString * const ACLinkedInPermissionsKey; //设置权限key//腾讯微博NSString *const ACTencentWeiboAppIdKey; //设置appid 三、用户信息相关类解析ACAccount类解析如下： 123456789@interface ACAccount : NSObject- (instancetype)initWithAccountType:(ACAccountType *)type;//构造方法@property (readonly, weak, NS_NONATOMIC_IOSONLY) NSString *identifier;//标识符@property (strong, NS_NONATOMIC_IOSONLY) ACAccountType *accountType;//账户类型@property (copy, NS_NONATOMIC_IOSONLY) NSString *accountDescription;//账户描述@property (copy, NS_NONATOMIC_IOSONLY) NSString *username;//用户名@property (readonly, NS_NONATOMIC_IOSONLY) NSString *userFullName;//完整名称@property (strong, NS_NONATOMIC_IOSONLY) ACAccountCredential *credential;//授权凭证@end ACAccountCredential类解析如下： 123456789@interface ACAccountCredential : NSObject//构造方法- (instancetype)initWithOAuthToken:(NSString *)token tokenSecret:(NSString *)secret;- (instancetype)initWithOAuth2Token:(NSString *)token refreshToken:(NSString *)refreshToken expiryDate:(NSDate *)expiryDate;//token@property (copy, nonatomic) NSString *oauthToken;@end 四、ACAccountStore类解析12345678910111213141516171819202122@interface ACAccountStore : NSObject//所有账户列表@property (readonly, weak, NS_NONATOMIC_IOSONLY) NSArray *accounts;//根据id获取账户- (ACAccount *)accountWithIdentifier:(NSString *)identifier;//根据id获取账户类型对象- (ACAccountType *)accountTypeWithAccountTypeIdentifier:(NSString *)typeIdentifier;//获取指定类型的所有账户- (NSArray *)accountsWithAccountType:(ACAccountType *)accountType;//进行账户存储- (void)saveAccount:(ACAccount *)account withCompletionHandler:(ACAccountStoreSaveCompletionHandler)completionHandler;//进行账户使用权限申请- (void)requestAccessToAccountsWithType:(ACAccountType *)accountType withCompletionHandler:(ACAccountStoreRequestAccessCompletionHandler)handler NS_DEPRECATED(NA, NA, 5_0, 6_0);- (void)requestAccessToAccountsWithType:(ACAccountType *)accountType options:(NSDictionary *)options completion:(ACAccountStoreRequestAccessCompletionHandler)completion;//如果账户权限已经过期 调用此方法进行刷新- (void)renewCredentialsForAccount:(ACAccount *)account completion:(ACAccountStoreCredentialRenewalHandler)completionHandler;//删除账户- (void)removeAccount:(ACAccount *)account withCompletionHandler:(ACAccountStoreRemoveCompletionHandler)completionHandler;@end 千里之遥始于足下，冰冻三尺非一日之寒 ——共勉","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中的CADisplayLink定时器","slug":"376iOS中的CADisplayLink定时器","date":"2018-07-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.378Z","comments":true,"path":"2018/07/05/376iOS中的CADisplayLink定时器/","link":"","permalink":"http://huishao.cc/2018/07/05/376iOS中的CADisplayLink定时器/","excerpt":"","text":"iOS中的CADisplayLink定时器说到定时器，在iOS中最常用的为NSTimer类，其实CADisplayLink类在某些场景下使用，要比NSTimer类更加适合。首先CADisplayLink也是一种定时器，并且其和屏幕的刷新率始终保持一致(很多时候会使用CADisplayLink来检测屏幕的帧率)。由于CADisplayLink的这种特性，使用它来实现流畅的动画效果非常合适。 CADisplayLink类非常简单，解析如下： 123456789101112131415161718192021222324//创建CADisplayLink对象 /*需要注意 定时器对象创建后 并不会马上执行 需要添加到runloop中*/+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;//将当前定时器对象加入一个RunLoop中- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;//将当前定时器对象从一个RunLoop中移除 如果这个Runloop是定时器所注册的最后一个 移除后定时器将被释放- (void)removeFromRunLoop:(NSRunLoop *)runloop forMode:(NSRunLoopMode)mode;//将定时器失效掉 调用这个函数后 会将定时器从所有注册的Runloop中移除- (void)invalidate;//当前时间戳@property(readonly, nonatomic) CFTimeInterval timestamp;//距离上次执行所间隔的时间@property(readonly, nonatomic) CFTimeInterval duration;//预计下次执行的时间戳@property(readonly, nonatomic) CFTimeInterval targetTimestamp;//设置是否暂停@property(getter=isPaused, nonatomic) BOOL paused;//设置预期的每秒执行帧数 例如设置为1 则以每秒一次的速率执行@property(nonatomic) NSInteger preferredFramesPerSecond CA_AVAILABLE_IOS_STARTING(10.0, 10.0, 3.0);//同上 @property(nonatomic) NSInteger frameInterval CA_AVAILABLE_BUT_DEPRECATED_IOS (3.1, 10.0, 9.0, 10.0, 2.0, 3.0, \"use preferredFramesPerSecond\"); 我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=29qwh7m53g4kc","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"玩转iOS转场动画","slug":"375玩转iOS转场动画","date":"2018-07-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.378Z","comments":true,"path":"2018/07/04/375玩转iOS转场动画/","link":"","permalink":"http://huishao.cc/2018/07/04/375玩转iOS转场动画/","excerpt":"","text":"玩转iOS转场动画一、引言关于动画在iOS开发中的应用，曾经整理过一系列的博客进行总结。包括简单的UIView层的动画，CALayer层的动画，Autolayout自动布局动画以及CoreAnimation核心动画框架等。本篇博客主要深入讨论视图控制器、导航控制器来进行界面跳转时的专场动画相关内容。之前的动画相关博客列举如下： iOS动画开发之一——UIViewAnimation动画的使用：https://my.oschina.net/u/2340880/blog/484457 iOS动画开发之二——UIView动画执行的另一种方式：https://my.oschina.net/u/2340880/blog/484538 iOS动画开发之三——UIView的转场切换：https://my.oschina.net/u/2340880/blog/484669 iOS动画开发之四——核心动画编程(CoreAnimation)：https://my.oschina.net/u/2340880/blog/484793 iOS动画开发之五——炫酷的粒子效果：https://my.oschina.net/u/2340880/blog/485095 iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程：https://my.oschina.net/u/2340880/blog/535235 iOS开发CoreAnimation解读之二——对CALayer的分析：https://my.oschina.net/u/2340880/blog/536048 iOS开发CoreAnimation解读之三——几种常用Layer的使用解析：https://my.oschina.net/u/2340880/blog/538024 iOS开发CoreAnimation解读之四——Layer层动画内容：https://my.oschina.net/u/2340880/blog/539599 iOS开发CoreAnimation解读之五——高级动画技巧：https://my.oschina.net/u/2340880/blog/539827 iOS开发CoreAnimation解读之五——CATransform3D变换的应用：https://my.oschina.net/u/2340880/blog/539878 iOS中播放gif动态图的方式探讨：https://my.oschina.net/u/2340880/blog/608560 iOS界面布局之三——纯代码的autoLayout及布局动画：https://my.oschina.net/u/2340880/blog/524089 开始本篇博客前，先上一张图，如果你觉得不好理解，没关系，看完后面的内容再回来看这张图，就一目了然了。 二、UIViewController进行模态跳转的转场首先，使用CoreAnimation框架中的CATransition类也可以实现视图控制器的转场动画，前面的博客有过讨论，这里不再重复。presentViewController这个函数使用率可谓是非常高的，默认的转场动画为新的视图控制器从下向上弹出，dismissViewControllerAnimated函数的返回动画则是弹出动画的逆序播放。其实，系统提供了4种转场动画供开发者选择，通过设置将要弹出的UIViewController实例的如下属性： 1@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle; UIModalTransitionStyle是一个枚举，如下： 123456typedef NS_ENUM(NSInteger, UIModalTransitionStyle) &#123; UIModalTransitionStyleCoverVertical = 0, //从下向上弹起 默认项 UIModalTransitionStyleFlipHorizontal __TVOS_PROHIBITED, //水平翻转 UIModalTransitionStyleCrossDissolve, //渐隐渐现 UIModalTransitionStylePartialCurl NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED, //翻页&#125;; 很多时候，上面4种枚举的转场动画样式并不能满足我们的需求，我们可以使用UIViewControllerTransitioningDelegate协议来完全自定义想要的转场动画效果。 首先创建一个类，使其遵守UIViewControllerTransitioningDelegate协议，比如我这里将类名去做TransDelegate，继承自NSObject。在界面跳转时，将要弹出的视图控制器设置如下： 1234ViewController2 * v2 = [ViewController2 new];self.transDelegate = [[TransDelegate alloc]init];v2.transitioningDelegate = self.transDelegate;[self presentViewController:v2 animated:YES completion:nil]; 我们先来看UIViewControllerTransitioningDelegate协议中的如下几个函数： 12345678910111213141516//这个函数用来设置当执行present方法时 进行的转场动画/*presented为要弹出的Controllerpresenting为当前的Controllersource为源Contrller 对于present动作 presenting与source是一样的*/- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;//这个函数用来设置当执行dismiss方法时 进行的转场动画- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;//这个函数用来设置当执行present方法时 进行可交互的转场动画- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;//这个函数用来设置当执行dismiss方法时 进行可交互的转场动画- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;//iOS8后提供的新接口 返回UIPresentationController处理转场- (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source NS_AVAILABLE_IOS(8_0); 我们先来看上面的前两个函数，这两个函数都要返回一个实现了UIViewControllerAnimatedTransitioning协议的对象，UIViewControllerAnimatedTransitioning则用来负责具体的动画展示，例如我们在创建一个命名为AniObject的类，继承自NSObject，使其实现UIViewControllerAnimatedTransitioning协议，在TransDelegate类中实现如下： 123- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source&#123; return [AniObject new];&#125; 下面我们来实现AniObject类来具体的处理动画效果： UIViewControllerAnimatedTransitioning协议中有两个函数是必须实现的，如下： 12345678910111213141516171819202122//这个函数用来设置动画执行的时长- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; return 2;&#125;//这个函数用来处理具体的动画- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; //跳转的界面 UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; //最终的位置 CGRect finalRect = [transitionContext finalFrameForViewController:toVC]; //起始位置 toVC.view.frame = CGRectOffset(finalRect, [[UIScreen mainScreen]bounds].size.width, 0); //添加到内容视图 [[transitionContext containerView]addSubview:toVC.view]; //执行动画 [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; toVC.view.frame = finalRect; &#125; completion:^(BOOL finished) &#123; //完成动画 [transitionContext completeTransition:YES]; &#125;];&#125; 上面我们实现了一个简单的自定义转场动画，将present动画修改成了从右侧滑入，但是dismiss动画依然是默认的从下方划出。效果如下： 下面我们来分析下transitionContext这个对象，这个对象实际上是一个转场上下文，使用它来进行动画的定义和执行： 1234567891011121314151617181920212223242526272829303132333435363738//容器视图 用来表现动画@property(nonatomic, readonly) UIView *containerView;//下面是几个只读属性//是否应该执行动画@property(nonatomic, readonly, getter=isAnimated) BOOL animated;//是否是可交互的@property(nonatomic, readonly, getter=isInteractive) BOOL interactive; // This indicates whether the transition is currently interactive.//是否被取消了@property(nonatomic, readonly) BOOL transitionWasCancelled;//转场风格@property(nonatomic, readonly) UIModalPresentationStyle presentationStyle;//调用这个函数来更新转场过程的百分比 用于可交互动画的阈值- (void)updateInteractiveTransition:(CGFloat)percentComplete;//完成可交互的转场交互动作时调用- (void)finishInteractiveTransition;//取消可交互的转场交互动作时调用- (void)cancelInteractiveTransition;//转场动画被中断 暂停时调用- (void)pauseInteractiveTransition;//转场动画完成时调用- (void)completeTransition:(BOOL)didComplete;//获取转场中的两个视图控制器/*UITransitionContextViewControllerKey的定义UITransitionContextFromViewControllerKey //原视图控制器UITransitionContextToViewControllerKey //跳转的视图控制器*/- (nullable __kindof UIViewController *)viewControllerForKey:(UITransitionContextViewControllerKey)key;//直接获取转场中的视图/*UITransitionContextFromViewKey //原视图UITransitionContextToViewKey //转场的视图*/- (nullable __kindof UIView *)viewForKey:(UITransitionContextViewKey)key;//获取视图控制器的初识位置- (CGRect)initialFrameForViewController:(UIViewController *)vc;//获取视图控制器转场后的位置- (CGRect)finalFrameForViewController:(UIViewController *)vc; 通过上面的介绍，我们可以使用UIViewControllerContextTransitioning随心所欲的定制转场动画，但是还有一个困难我们无法克服，那就是可以交互的转场动画。我们在使用系统的导航控制器时，右划返回效果对用户体验十分友好，我们下面就来试着将视图控制器的模态跳转设计成类似导航可交互的。 首先我们需要实现TransDelegate类中的如下两个函数： 1234567- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed&#123; return [AniObject new];&#125;- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator&#123; //遵守了UIViewControllerInteractiveTransitioning协议的对象 return self.object;&#125; UIViewControllerInteractiveTransitioning协议用来处理可交互的转场动画的具体表现，需要注意，因为使用的是可交互的转场动画，UIViewControllerAnimatedTransitioning协议中的animateTransition:方法可以空实现。下面我们再创建一个遵守UIViewControllerInteractiveTransitioning协议的类，比如命名为IntObject，上面代码中的self.object即是这个类的示例，IntObject.h文件如下： 123456789@interface IntObject : NSObject&lt;UIViewControllerInteractiveTransitioning&gt;-(void)updateAniProgress:(CGFloat)progress;-(void)finish;-(void)cancel;@end IntObject.m文件实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@interface IntObject()@property(nonatomic,strong)id&lt;UIViewControllerContextTransitioning&gt; context;@end@implementation IntObject//这个函数用来保存transitionContext-(void)startInteractiveTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; self.context = transitionContext; //跳转的界面 UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIViewController * fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; //最终的位置 toVC.view.frame = [transitionContext finalFrameForViewController:toVC]; //添加到内容视图 [[transitionContext containerView]insertSubview:toVC.view belowSubview:fromVC.view];&#125;//更新动画状态-(void)updateAniProgress:(CGFloat)progress&#123; UIView *frameVC = [self.context viewForKey:UITransitionContextFromViewKey]; //最终的位置 CGRect fR = CGRectMake( [UIScreen mainScreen].bounds.size.width*progress, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); frameVC.frame = fR;&#125;//结束转场-(void)finish&#123; [UIView animateWithDuration:0.2 animations:^&#123; UIView *frameVC = [self.context viewForKey:UITransitionContextFromViewKey]; frameVC.frame = CGRectMake([UIScreen mainScreen].bounds.size.width, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); &#125; completion:^(BOOL finished) &#123; [self.context completeTransition:YES]; &#125;];&#125;//取消转场-(void)cancel&#123; [UIView animateWithDuration:0.2 animations:^&#123; UIView *frameVC = [self.context viewForKey:UITransitionContextFromViewKey]; frameVC.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); &#125; completion:^(BOOL finished) &#123; [self.context cancelInteractiveTransition]; &#125;];&#125;@end 下面我们来添加手势，在ViewController2类中添加如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@interface ViewController2 ()@property(nonatomic,strong)UIPanGestureRecognizer * pan;@end@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor redColor]; [self.view addGestureRecognizer:self.pan]; // Do any additional setup after loading the view.&#125;-(void)pan:(UIPanGestureRecognizer *)pan&#123; CGPoint translatedPoint = [pan translationInView:self.view]; CGFloat persent = translatedPoint.x / [[UIScreen mainScreen]bounds].size.width; if (persent&lt;0) &#123; return; &#125; persent = fabs(persent); IntObject * obj = [(TransDelegate *)self.transitioningDelegate object]; switch (pan.state) &#123; case UIGestureRecognizerStateBegan:&#123; [self dismissViewControllerAnimated:YES completion:nil]; break; &#125; case UIGestureRecognizerStateChanged:&#123; //手势过程中，通过updateInteractiveTransition设置pop过程进行的百分比 [obj updateAniProgress:persent]; break; &#125; case UIGestureRecognizerStateEnded:&#123; //手势完成后结束标记并且判断移动距离是否过半，过则finishInteractiveTransition完成转场操作，否者取消转场操作 if (persent &gt; 0.5) &#123; [obj finish]; &#125;else&#123; [obj cancel]; &#125; break; &#125; default: break; &#125;&#125;-(UIPanGestureRecognizer *)pan&#123; if (!_pan) &#123; _pan = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(pan:)]; &#125; return _pan;&#125;@end 手势效果如下： 其实，上面演示的是我们自己创建了一个类来实现UIViewControllerInteractiveTransitioning协议，其实系统也为我们提供一个类：UIPercentDrivenInteractiveTransition类，我们可以直接调用这个类的如下3个函数而不需要我们自己重写了，但是必须实现UIViewControllerAnimatedTransitioning协议中的transitionContext函数来实现动画效果。 123- (void)updateInteractiveTransition:(CGFloat)percentComplete;- (void)cancelInteractiveTransition;- (void)finishInteractiveTransition; 其实现原理与我们上面进行完全的自定义是一样的。 三、导航转场动画的自定义导航转场动画的原理与模态跳转转场动画的原理基本是一致的，不同的我们需要设置UINavigationController实例的delegate为遵守UINavigationControllerDelegate协议的类对象。之后实现如下两个函数： 1234567891011121314//设置转场的动画不论是push或pop 返回nil 则使用系统默认的导航转场动画- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123; NSLog(@\"sss\"); return nil;&#125;//设置可交互的转场动画- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController&#123; NSLog(@\"aaa\"); return nil;&#125; 可以看到 animationControllerForOperation:函数依然需要返回一个遵守了UIViewControllerAnimatedTransitioning协议的对象，使用方式和前面所介绍的模态跳转自定义转场一模一样。UINavigationControllerOperation这个枚举将告知开发者导航所做的操作，如下： 12345typedef NS_ENUM(NSInteger, UINavigationControllerOperation) &#123; UINavigationControllerOperationNone, //无 UINavigationControllerOperationPush, //push操作 UINavigationControllerOperationPop, //pop操作&#125;; 实现UIViewControllerInteractiveTransitioning协议如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@interface IntObject()@property(nonatomic,strong)id&lt;UIViewControllerContextTransitioning&gt; context;@end@implementation IntObject-(void)startInteractiveTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; self.context = transitionContext; //跳转的界面 UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIViewController * fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; //最终的位置 toVC.view.frame = [transitionContext finalFrameForViewController:toVC]; //添加到内容视图 [[transitionContext containerView]insertSubview:toVC.view belowSubview:fromVC.view];&#125;-(void)updateAniProgress:(CGFloat)progress&#123; UIView *frameVC = [self.context viewForKey:UITransitionContextFromViewKey]; //最终的位置 CGRect fR = CGRectMake( [UIScreen mainScreen].bounds.size.width*progress, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); frameVC.frame = fR; [self.context updateInteractiveTransition:progress];&#125;-(void)finish&#123; [UIView animateWithDuration:0.2 animations:^&#123; UIView *frameVC = [self.context viewForKey:UITransitionContextFromViewKey]; frameVC.frame = CGRectMake([UIScreen mainScreen].bounds.size.width, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); &#125; completion:^(BOOL finished) &#123; [self.context finishInteractiveTransition]; [self.context completeTransition:YES]; &#125;];&#125;-(void)cancel&#123; [UIView animateWithDuration:0.2 animations:^&#123; UIView *frameVC = [self.context viewForKey:UITransitionContextFromViewKey]; frameVC.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); &#125; completion:^(BOOL finished) &#123; [self.context cancelInteractiveTransition]; [self.context completeTransition:NO]; &#125;];&#125;@end 如此即可以轻松实现可交互的自定义导航动画。 四、UITabBarController的转场动画UITabbar也可以进行转场动画的自定义，需要设置UITabBarController的delegate并实现协议中的如下两个函数： 12345678910//设置非交互的转场动画- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController animationControllerForTransitionFromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC &#123;&#125;//设置交互的转场动画- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController interactionControllerForAnimationController: (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationController&#123; &#125; 这两个函数的应用和导航自定义动画基本是一致的，这里就不再列举代码，简单的效果见下图：","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"使用Jenkins配置iOS自动化构建工具","slug":"374使用Jenkins配置iOS自动化构建工具","date":"2018-06-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.378Z","comments":true,"path":"2018/06/28/374使用Jenkins配置iOS自动化构建工具/","link":"","permalink":"http://huishao.cc/2018/06/28/374使用Jenkins配置iOS自动化构建工具/","excerpt":"","text":"使用Jenkins配置iOS自动化构建工具关于iOS自动化构建其实并不复杂，通过一些简单的Git与Xcode指令，加上UI，我们自己也可以动手编写一款自动化构建工具。这在之前的博客中也有涉及，有兴趣的朋友可以在如下地址找到这篇博客： 自己动手设计一款iOS自动构建发布工具：https://my.oschina.net/u/2340880/blog/1486246 本篇博客主要记录使用Jenkins搭建iOS自动化构建项目的过程，关于Jenkins的更多自动化脚本的应用，有机会后面再出专门的博客介绍。 一、Jenkins的安装与启动Jenkins的安装非常方面，在如下官网可以直接下载Jenkins的安装包，其中有支持各个平台的安装包，选择自己所需要的进行下载安装即可。 https://jenkins.io/ 安装完成后，Jenkins会自动启动运行，在当前电脑的8080端口开启一个Web应用服务，如果是第一次安装启动，我们需要配置一个账户作为初始用户。 对于在Mac上Jenkins的启动，有两种方式： 方式一：直接运行Java归档文件启动Jenkins 如果是Mac电脑，Jenkins安装完成后，在Applications目录下会多出一个Jenkins文件夹，这个文件夹中包含一个jenkins.war的文件，如下图所示： 使用如下命令来启动Jenkins： java -jar /Applications/Jenkins/jenkins.war 使用这种方式启动的Jenkins，要关闭服务需要找到Jenkins服务对应的PID，在终端输入如下命令: 1ps 在终端输出的信息中，可以看到Jenkins服务所对应的PID号，如下图： 终端使用如下命令将此服务杀死即可： 1kill -9 PID号 方式二：使用Mac的启动进行控制器启动Jenkins 如果成功安装了Jenkins，在Mac电脑磁盘的资源库中的LaunchDaemons文件夹下可以找到Jenkins的启动配置文件，如下图： 在命令行中执行如下命令即可启动Jenkins服务： 1sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist 使用如下命令关闭Jenkins服务： 1sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist 二、创建持续集成项目在Jenkins的主页选择新建一个项目，创建选项中，我们输入项目名称，并选择构建一个自由风格的软件，如下图： 下一步将进入到项目配置界面，首先需要设置下通用的配置，如下图： 其中，描述部分可以填写项目的相关介绍，丢弃旧的构建设置构建记录保存的天数和最多保持多少个构建记录等。 源码管理的配置是比较重要的一步，其用来设置构建项目从哪里拉取项目的源代码以及进行源码更新的操作。如下图： 如果使用的是Git仓库，如上图所示，需要配置项目的路径，账户以及要进行构建的分支。账户的主要用途是使得Jenkins有权限拉取项目的代码，如果之前没有添加过，可以点击右侧的Add按钮进行添加，如下图： 可以选择配置用户名加密码的方式添加账户，也可以使用SSH公钥的方式。 下一步我们需要配置构建的触发器，构建触发器有多种形式，比如定时触发构建，远程触发，代码提交后触发等等，如下图： 其中远程触发是指我们可以通过远程访问Jenkins服务器地址加上令牌参数来触发构建。 之后再构建一栏中选择增加构建步骤-&gt;执行Shell，添加如下Shell脚本： 12345678export LANG=en_US.UTF-8export LANGUAGE=en_US.UTF-8export LC_ALL=en_US.UTF-8/usr/local/bin/pod installxcodebuild -archivePath &quot;/Users/Shared/Jenkins/Home/workspace/Jenkins项目名称/你的项目名.xcarchive&quot; -workspace 你的项目名.xcworkspace -sdk iphoneos -scheme &quot;你的项目名&quot; -configuration &quot;Release&quot; archivexcodebuild -exportArchive -archivePath &quot;/Users/Shared/Jenkins/Home/workspace/Jenkins项目名称/你的项目名.xcarchive&quot; -exportPath &quot;/Users/Shared/Jenkins/Home/workspace/Jenkins项目名称/buildIPA&quot; -exportOptionsPlist &apos;/Users/Shared/Jenkins/Home/workspace/Tictalk-iOS/ExportOptions.plist&apos; -allowProvisioningUpdatescurl -F &quot;file=@/Users/Shared/Jenkins/Home/workspace/Jenkins项目名称/buildIPA/你的项目名.ipa&quot; -F &quot;uKey=蒲公英userKey&quot; -F &quot;_api_key=蒲公英apikey&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload 上面脚本中，xcodebuild -archivePath 命令用来编译项目，如果你的项目没有使用workspace，需要将命令中的workspace修改成project，configuration参数用来配置编辑的方式，Release为发布环境。xcodebuild -exportArchive 命令用来到处API包，需要额外注意，提前我们需要在/Users/Shared/Jenkins/Home/workspace/Jenkins项目名称/你的项目名这个目录下添加一个ExportOptions.plist文件，新Xcode如果不配置这个文件是无法打包成功的。curl -F 命令是用来将打包好的IPA包自动上传到蒲公英分发平台。 ExportOptions.plist文件编写格式如下： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;ad-hoc(IPA包模式)&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt;(下面设置bundleID对应的provisioningProfiles文件名) &lt;key&gt;com.***&lt;/key&gt; &lt;string&gt;AD_HOC&lt;/string&gt; &lt;key&gt;com.***.TKNotificationCentent&lt;/key&gt; &lt;string&gt;Content&lt;/string&gt; &lt;key&gt;com.***.TKNotificationService&lt;/key&gt; &lt;string&gt;Service&lt;/string&gt; &lt;/dict&gt;(下面配置证书) &lt;key&gt;signingCertificate&lt;/key&gt; &lt;string&gt;iPhone Distribution&lt;/string&gt; &lt;key&gt;signingStyle&lt;/key&gt; &lt;string&gt;manual&lt;/string&gt; &lt;key&gt;stripSwiftSymbols&lt;/key&gt; &lt;true/&gt;(下面配置teamID) &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;KJYHPT****&lt;/string&gt; &lt;key&gt;thinning&lt;/key&gt; &lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 三、构建可能出错的地方配置完了上面的脚本，你可以尝试点击立即构建按钮进行构建，当然构建过程中极有可能会出错，你可以根据log输出检查下是否是因为下面的问题。 1.git相关命令出错可能是Jenkins找不到git所在位置，在Jenkins的系统设置中选择全局工具配置，配置git路径如下图所示： 2.pod相关命令出错 这一步出错的可能性极大，首先你的电脑可以使用pod不代表jenkins用户有使用pod的权限，最好使用jenkins用户登录电脑，进行pod的更新升级，或者直接使用jenkins用户登录，找到我们的项目，手动使用pod进行第三方的安装。 3.xcodebuild相关命令出错和git命令出错的问题基本一致，我们需要配置路径。在Jenkins的系统设置中找到系统配置，设置xcode相关工具如下： 4.编译过程中证书或配置文件出错首先确保你的应用证书放在了钥匙串的系统分类下，如图： 其次，需要将Provisioning Profiles文件复制到下面的目录下，切记： /Users/Shared/Jenkins/Library/MobileDevice/Provisioning Profiles 最后，请确认可以使用Xcode手动进行编辑和打包。而且证书和Provisioning Profiles文件一定要正确和匹配。","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"iOS:JSON转OC属性小工具能","slug":"373iOS-JSON转OC属性小工具","date":"2018-06-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.378Z","comments":true,"path":"2018/06/09/373iOS-JSON转OC属性小工具/","link":"","permalink":"http://huishao.cc/2018/06/09/373iOS-JSON转OC属性小工具/","excerpt":"","text":"iOS:JSON转OC属性小工具在iOS开发中，只要有网络模块，就需要数据模型的编写。在进行数据模型的解析和映射时，JSONModel是一个非常常用且优秀的第三方框架，之前有有过博客对其分析，地址如下： JSONModel源码分析：https://my.oschina.net/u/2340880/blog/1787561。 无论使用什么第三方的JSON数据解析框架，我们都需要手动来编写数据模型类，这是一个十分机械性的体力活，本篇博客将介绍一个配合与JSONModel使用的自动生成属性脚本(支持类的嵌套)。 本脚本采用的语言为JavaScript，采用JavaScript编写有两个好处，首先其可以在node环境运行，可以十分方便的操作文件，使用它可以直接将JSON文件转换成OC数据模型类。其次，它也十分容易在Web端运行，可以通过网页可视化的进行数据模型的转换。 闲话少说，直接上源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134var fileManager = require('fs');var gettype=Object.prototype.toString;String.prototype.firstUpperCase = function()&#123; return this.replace(/\\b(\\w)(\\w*)/g, function($0, $1, $2) &#123; return $1.toUpperCase() + $2.toLowerCase(); &#125;);&#125;var arguments = process.argv.splice(2);var path = arguments[0];if (!path) &#123; console.log(\"请传入要转换的JSON文件路径\"); return;&#125;console.log('json文件路径:', path);try&#123; var result = JSON.parse(fileManager.readFileSync(path));&#125;catch(error)&#123; console.log(\"解析JSON文件失败:\"+error); return;&#125;if (!result) &#123; console.log(\"解析JSON文件无效\"); return;&#125;var classArray = new Array();parseObject(\"MyObject\",result);var stringAll=\"\";//输出for (var i = classArray.length-1; i &gt;=0 ; i--) &#123; let cla = classArray[i]; stringAll+=\"@protocol \"+cla.name+\" @end\\r\\n\\r\\n@interface \"+cla.name+\" : JSONModel\\r\\n\\r\\n\"; console.log(\"@protocol \"+cla.name+\" @end\\r\\n\\r\\n@interface \"+cla.name+\" : JSONModel\\r\\n\\r\\n\"); for (var j = 0; j &lt; cla.property.length; j++) &#123; stringAll+=cla.property[j]+\"\\r\\n\\r\\n\"; console.log(cla.property[j]+\"\\r\\n\\r\\n\"); &#125; stringAll+=\"@end\\r\\n\\r\\n\"; console.log(\"@end\\r\\n\\r\\n\");&#125;stringAll+=\"===========m文件======================\\r\\n\";console.log(\"===========m文件======================\\r\\n\");for (var i = classArray.length-1; i &gt;=0 ; i--) &#123; let cla = classArray[i]; stringAll+=\"@implementation \"+cla.name+\"\\r\\n\\r\\n@end\\r\\n\\r\\n\"; console.log(\"@implementation \"+cla.name+\"\\r\\n\\r\\n@end\\r\\n\\r\\n\");&#125;let paths = path.split(\"/\");paths.pop();let newPath = paths.join(\"/\")+\"/oc.txt\";fileManager.writeFileSync(newPath,stringAll);//核心解析函数function parseObject(k,result)&#123; let c = new Class(k); classArray.push(c); for (var i = 0; i &lt; Object.getOwnPropertyNames(result).length; i++) &#123; let key = Object.getOwnPropertyNames(result)[i]; let value = result[key]; let type = getType(value); if(type==null)&#123; continue; &#125; if (type==\"Object\") &#123; //进行二次解析 if (Object.getOwnPropertyNames(value).length==0) &#123; c.property.push(\"@property(nonatomic,strong)NSDictionary&lt;Optional&gt;*\"+key+\";\"); &#125;else&#123; parseObject(key.firstUpperCase(),value); c.property.push(\"@property(nonatomic,strong)\"+key.firstUpperCase()+\"&lt;Optional,\"+key.firstUpperCase()+\"&gt;*\"+key+\";\"); &#125; continue; &#125; if (type==\"Array\") &#123; if (value.length&gt;0) &#123; let obj = value[0]; let t = getType(obj); if (t==null) &#123; continue; &#125; if (t==\"Object\") &#123; c.property.push(\"@property(nonatomic,strong)NSArray&lt;\"+key.firstUpperCase()+\"*&gt;&lt;Optional,\"+key.firstUpperCase()+\"&gt;*\"+key+\";\"); parseObject(key.firstUpperCase(),obj); &#125;else&#123; c.property.push(\"@property(nonatomic,strong)NSArray&lt;\"+t+\"*&gt;&lt;Optional&gt;*\"+key+\";\"); &#125; &#125;else&#123; c.property.push(\"@property(nonatomic,strong)NSArray&lt;Optional&gt;*\"+key+\";\"); &#125; continue; &#125; if (type==\"id\") &#123; c.property.push(\"@property(nonatomic,strong)\"+type+\"&lt;Optional&gt;\"+key+\";\"); continue; &#125; c.property.push(\"@property(nonatomic,strong)\"+type+\"&lt;Optional&gt;*\"+key+\";\"); &#125;&#125;//获取要转换的类型function getType(obj)&#123; if (typeof obj == 'number') &#123; return \"NSNumber\"; &#125; if (typeof obj == 'undefined') &#123; return \"id\"; &#125; if (typeof obj == 'null') &#123; return \"id\"; &#125; if (typeof obj == 'function') &#123; return null; &#125; if (typeof obj == 'string') &#123; return \"NSString\" &#125; if (typeof obj == 'boolean') &#123; return \"NSNumber\" &#125; if (typeof obj == 'object') &#123; if (gettype.call(obj)==\"[object Object]\") &#123; return \"Object\"; &#125; if (gettype.call(obj)==\"[object Array]\") &#123; return \"Array\"; &#125; if (gettype.call(obj)==\"[object Null]\")&#123; return \"id\"; &#125; &#125;&#125;//类 function Class(name)&#123; this.name = name; this.property = new Array();&#125; 在终端使用如下指令直接运行此脚本： 1node Tool.js /Users/jaki/Desktop/json.json 命令后面所跟的参数为JSON文件的路径，JSON文件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; \"code\": 0, \"message\": \"\", \"result\": &#123; \"aid\": \"be3bdab8-fbf5-4e89-97cb-56b00048b09b\", \"audios\": [], \"avatar_url\": \"https://www.google.com/a.jpg\", \"call_price\": 0, \"cid\": \"efad6549-be62-40d7-a425-40f9b7730192\", \"cover_url\": \"https://www.google.com/a.jpg\", \"created_on\": \"1528349104\", \"fields\": [ &#123; \"key\": \"name\", \"value\": \"Mr.Wang\" &#125;, &#123; \"key\": \"company\", \"value\": \"TicTalk\" &#125;, &#123; \"key\": \"position\", \"value\": \"Senior Engineer\" &#125; ], \"geo\": &#123; \"description\": \"Shanghai, China\", \"latitude\": 48.82694828196076, \"longitude\": 2.367038433387592 &#125;, \"id\": 2, \"message_price\": 0, \"photo_sets\": [], \"pid\": \"9b64395f-687c-4f34-9a5d-68d9adafa4cc\", \"rid\": \"578ff973-c707-42b2-bfc2-87e4dc8e0efd\", \"role_open\": false, \"sid\": \"8f560338-dfa5-48be-b44c-65fd87798543\", \"status\": 0, \"updated_on\": \"1528349104\", \"video_price\": 0, \"videos\": [], \"world_open\": true &#125;&#125; 运行后，可以看到在JSON文件同一目录下生成了oc.txt文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@protocol Geo @end@interface Geo : JSONModel@property(nonatomic,strong)NSString&lt;Optional&gt;*description;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*latitude;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*longitude;@end@protocol Fields @end@interface Fields : JSONModel@property(nonatomic,strong)NSString&lt;Optional&gt;*key;@property(nonatomic,strong)NSString&lt;Optional&gt;*value;@end@protocol Result @end@interface Result : JSONModel@property(nonatomic,strong)NSString&lt;Optional&gt;*aid;@property(nonatomic,strong)NSArray&lt;Optional&gt;*audios;@property(nonatomic,strong)NSString&lt;Optional&gt;*avatar_url;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*call_price;@property(nonatomic,strong)NSString&lt;Optional&gt;*cid;@property(nonatomic,strong)NSString&lt;Optional&gt;*cover_url;@property(nonatomic,strong)NSString&lt;Optional&gt;*created_on;@property(nonatomic,strong)NSArray&lt;Fields*&gt;&lt;Optional,Fields&gt;*fields;@property(nonatomic,strong)Geo&lt;Optional,Geo&gt;*geo;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*id;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*message_price;@property(nonatomic,strong)NSArray&lt;Optional&gt;*photo_sets;@property(nonatomic,strong)NSString&lt;Optional&gt;*pid;@property(nonatomic,strong)NSString&lt;Optional&gt;*rid;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*role_open;@property(nonatomic,strong)NSString&lt;Optional&gt;*sid;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*status;@property(nonatomic,strong)NSString&lt;Optional&gt;*updated_on;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*video_price;@property(nonatomic,strong)NSArray&lt;Optional&gt;*videos;@property(nonatomic,strong)NSNumber&lt;Optional&gt;*world_open;@end@protocol MyObject @end@interface MyObject : JSONModel@property(nonatomic,strong)NSNumber&lt;Optional&gt;*code;@property(nonatomic,strong)NSString&lt;Optional&gt;*message;@property(nonatomic,strong)Result&lt;Optional,Result&gt;*result;@end===========m文件======================@implementation Geo@end@implementation Fields@end@implementation Result@end@implementation MyObject@end 后面我们只需要将类名调整成所需要的即可。 下面是一个即用的网页转换器，采用的脚本代码和上面的代码基本一致： http://zyhshao.github.io/JSONToOC.html 使用效果如下： 热爱技术，热爱生活中有趣的事务，互相交流，也在朋友 QQ：316045346 ——珲少","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"iOS使用VOIP与CallKit实现体验优质的网络通讯功能","slug":"372iOS使用VOIP与CallKit实现体验优质的网络通讯功能","date":"2018-04-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.378Z","comments":true,"path":"2018/04/24/372iOS使用VOIP与CallKit实现体验优质的网络通讯功能/","link":"","permalink":"http://huishao.cc/2018/04/24/372iOS使用VOIP与CallKit实现体验优质的网络通讯功能/","excerpt":"","text":"iOS使用VOIP与CallKit实现体验优质的网络通讯功能VOIP是Apple提供给开发者的网络电话功能接口。简单来说，其可以让你的应用程序在完全杀死的情况下被服务端唤醒。CallKit是iOS10引入的新框架，使用它可以让你的应用程序调用系统的通话和通话记录界面。试想一下，用户可以在锁屏，应用被杀死，应用在后台等情况下收到通讯请求并且弹出系统的通话界面进行交互是多么酷的一件事。 一、创建VOIP推送证书VOIP说是一种网络电话服务，其实质是一种特殊的长连接，使用它每个网络电话类APP不需要自己单独进行保活维护，在进行通话请求时，只需要发送一条VOIP推送，VOIP推送会将应用程序拉起，之后由应用程序处理通讯逻辑。VOIP也是Push的一种，只是其是一种特殊的Push，普通的Push当应用被杀死后可以收到，但是用户点击Push消息前应用程序是不会被激活的，VOIP则不然，可以直接激活应用。 VOIP推送证书的创建方式与普通推送证书的创建方式基本一致，首先需要生成certSigningRequest文件，打开钥匙串应用： 在证书助理栏选择从证书颁发机构申请证书： 填写相关资料后，将生成的文件保存： 在Apple开发者中心创建新的证书，证书类型选择生产环境的VOIP服务证书： 需要注意，普通的推送分开发环境和生产环境，VOIP证书不进行区分，生产环境和开发环境是通用的。之后选择一个AppID并且上传前面生成的certSigningRequest文件来完成VOIP证书的创建。 创建完成后，在证书列表可以看到多了一个VOIP服务证书，可以加载此证书进行VOIP推送。 二、PushKit详析我们知道，客户端若想要接收普通的Push消息，是需要注册Token，通过Token来进行个推的。VOIP推送也是一样的，只是这类推送需要使用PushKit框架。 首先需要用到PKPushRegistey类，这个类进行推送的相关配置和Token的申请： 12345678910111213141516@interface PKPushRegistry : NSObject//代理对象@property (readwrite,weak,nullable) id&lt;PKPushRegistryDelegate&gt; delegate;//目标推送类型/*PK_EXPORT PKPushType const PKPushTypeVoIP NS_AVAILABLE_IOS(8_0);//VOIP推送PK_EXPORT PKPushType const PKPushTypeComplication NS_AVAILABLE_IOS(9_0);//Watch更新PK_EXPORT PKPushType const PKPushTypeFileProvider NS_AVAILABLE_IOS(11_0);//文件传输*/@property (readwrite,copy,nullable) NSSet&lt;PKPushType&gt; *desiredPushTypes;//获取本地缓存的Token 申请Token执行回调后 这个方法可以直接获取缓存- (nullable NSData *)pushTokenForType:(PKPushType)type;//初始化，并设置工作线程- (instancetype)initWithQueue:(nullable dispatch_queue_t)queue NS_DESIGNATED_INITIALIZER;- (instancetype)init NS_UNAVAILABLE;@end PKPushRegistryDelegate相关函数意义如下： 123456789101112131415161718//申请Token更新后回调/*PKPushCredentials是证书对象，其中属性如下：@property (readonly,copy) PKPushType type;//推送类型@property (readonly,copy) NSData *token; //Token*/- (void)pushRegistry:(PKPushRegistry *)registry didUpdatePushCredentials:(PKPushCredentials *)pushCredentials forType:(PKPushType)type;//收到推送后执行的回调/*PKPushPayload为推送信息 其中属性如下：@property (readonly,copy) PKPushType type; //推送类型@property (readonly,copy) NSDictionary *dictionaryPayload; //服务端发来的信息*/- (void)pushRegistry:(PKPushRegistry *)registry didReceiveIncomingPushWithPayload:(PKPushPayload *)payload forType:(PKPushType)type NS_DEPRECATED_IOS(8_0, 11_0);//作用同上，最后的block需要在逻辑处理完成后主动回调- (void)pushRegistry:(PKPushRegistry *)registry didReceiveIncomingPushWithPayload:(PKPushPayload *)payload forType:(PKPushType)type withCompletionHandler:(void(^)(void))completion NS_AVAILABLE_IOS(11_0);//Token失效的回调- (void)pushRegistry:(PKPushRegistry *)registry didInvalidatePushTokenForType:(PKPushType)type; 如果配置成功，在收到VOIP推送时，无论应用程序是否活跃，都会执行代理函数，我们便可以在其中进行逻辑处理。 三、关于CallKit框架CallKit框架是iOS10后系统提供的一套网络电话UI和交互相关接口，应用程序可以调用系统的电话界面来进行逻辑传递。下图比较形象的表达了应用程序与CallKit的关系： 以收到网络电话为例，如果应用程序在前台，客户端可以直接处理通讯逻辑，如果应用程序不在前台，服务端可以发送一条VOIP推送唤醒APP，之后APP通知CallKit框架来唤起系统的通讯界面。CXProvider类主要负责系统服务于APP之间的交互。例如可以通过它来更新通话界面，显示通话的来自方，当用户点击通话界面的某些按钮后，也通过它来通知APP做逻辑处理。 需要注意，上图在CallKit和System之间有两个双向的白色箭头，这描述了CallKit和系统交互的四个方向。 首先，App想要和系统交互，例如接收到VOIP通知后弹出通话界面，需要使用CXProvider通过CXCallUpdate来进行控制。如下图： 之后系统会将一些用户操作通过CSAction传递会APP，如下： APP中进行的操作如果需要通知系统，需要使用CXCallController通过CXTransaction传递。例如App内的通讯需要添加到系统的历史通话列表。如下： 1.先来看CXProvider类CXProvider类用来对系统通话界面进行一些配置操作，并处理回调逻辑，解析如下： 123456789101112131415161718192021222324252627282930313233343536//初始化方法 使用CXProviderConfiguration来进行配置 后面会介绍- (instancetype)initWithConfiguration:(CXProviderConfiguration *)configuration NS_DESIGNATED_INITIALIZER;- (instancetype)init NS_UNAVAILABLE;//设置代理与代理函数所工作的线程- (void)setDelegate:(nullable id&lt;CXProviderDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue;//向系统发起一个新的通话请求/*UUID为此通话请求的标识 可以使用它来关闭通话update设置界面的更新参数*/- (void)reportNewIncomingCallWithUUID:(NSUUID *)UUID update:(CXCallUpdate *)update completion:(void (^)(NSError *_Nullable error))completion;//结束某个通话 使用上面的UUID作为标识/*//通话结束的原因设置typedef NS_ENUM(NSInteger, CXCallEndedReason) &#123; CXCallEndedReasonFailed = 1, // 通话服务失败 CXCallEndedReasonRemoteEnded = 2, // 对方挂断 CXCallEndedReasonUnanswered = 3, // 超时 对方为接听 CXCallEndedReasonAnsweredElsewhere = 4, // 通话在其他设备接听 CXCallEndedReasonDeclinedElsewhere = 5, // 通话在其他设备拒绝&#125; API_AVAILABLE(ios(10.0));*/- (void)reportCallWithUUID:(NSUUID *)UUID endedAtDate:(nullable NSDate *)dateEnded reason:(CXCallEndedReason)endedReason;//更新通话对方的信息- (void)reportCallWithUUID:(NSUUID *)UUID updated:(CXCallUpdate *)update;//调用这个函数来进行通话呼出开始- (void)reportOutgoingCallWithUUID:(NSUUID *)UUID startedConnectingAtDate:(nullable NSDate *)dateStartedConnecting;//调用这个函数来进行通话呼出连接完成- (void)reportOutgoingCallWithUUID:(NSUUID *)UUID connectedAtDate:(nullable NSDate *)dateConnected;//配置对象@property (nonatomic, readwrite, copy) CXProviderConfiguration *configuration;//调用此函数来将通话失效- (void)invalidate;//所有未完成的事物@property (nonatomic, readonly, copy) NSArray&lt;CXTransaction *&gt; *pendingTransactions;- (NSArray&lt;__kindof CXCallAction *&gt; *)pendingCallActionsOfClass:(Class)callActionClass withCallUUID:(NSUUID *)callUUID; 2.在看CXProviderConfiguration类这个类用来进行Provider的配置，例如设置通讯服务名称，铃声，图标，是否支持组等。解析如下： 12345678910111213141516//设置服务名称@property (nonatomic, readonly, copy) NSString *localizedName;//设置铃声 资源必须在 app的 bundle里@property (nonatomic, strong, nullable) NSString *ringtoneSound;//设置应用图标@property (nonatomic, copy, nullable) NSData *iconTemplateImageData;//设置最大支持的组数 默认为2@property (nonatomic) NSUInteger maximumCallGroups;//设置最大的每组人数 默认为5@property (nonatomic) NSUInteger maximumCallsPerCallGroup;//设置是否将通话记录保存进最近通话列表@property (nonatomic) BOOL includesCallsInRecents;//设置是否支持视频通话@property (nonatomic) BOOL supportsVideo;//设置支持的操作类型@property (nonatomic, copy) NSSet&lt;NSNumber *&gt; *supportedHandleTypes; 当App接收到来电VOIP通知时，可以使用CXCallUpdate来更新状态唤出通话界面。 3.CXCallUpdate类1234567891011121314//远程操作对象 如果是接收方 则此为呼叫方 如果是呼叫方 则此为接收方@property (nonatomic, copy, nullable) CXHandle *remoteHandle;//名称@property (nonatomic, copy, nullable) NSString *localizedCallerName;//是否支持暂时挂起@property (nonatomic) BOOL supportsHolding;//是否支持组@property (nonatomic) BOOL supportsGrouping;//是否支持非组通话@property (nonatomic) BOOL supportsUngrouping;//是否支持DTMF@property (nonatomic) BOOL supportsDTMF;//是否包含视频@property (nonatomic) BOOL hasVideo; CXHandle中来定义操作的类型，解析如下： 12345678910111213//类型/*typedef NS_ENUM(NSInteger, CXHandleType) &#123; CXHandleTypeGeneric = 1,//通用 CXHandleTypePhoneNumber = 2,//电话 CXHandleTypeEmailAddress = 3,//邮箱地址&#125; API_AVAILABLE(ios(10.0));*/@property (nonatomic, readonly) CXHandleType type;//值@property (nonatomic, readonly, copy) NSString *value;- (instancetype)initWithType:(CXHandleType)type value:(NSString *)value NS_DESIGNATED_INITIALIZER; 下面给出了简单的当被叫收到VOIP后调起通话界面的代码： 1234567891011CXCallUpdate * callUpdate = [[CXCallUpdate alloc]init];callUpdate.supportsGrouping = YES;callUpdate.supportsDTMF = YES;callUpdate.hasVideo = YES;callUpdate.supportsHolding = YES;[callUpdate setLocalizedCallerName:nickName];CXHandle * handle = [[CXHandle alloc]initWithType:CXHandleTypePhoneNumber value:from];callUpdate.remoteHandle = handle; [[self shareInstance].callProvider reportNewIncomingCallWithUUID:[self shareInstance].uuid update:callUpdate completion:^(NSError * _Nullable error) &#123; LOG(@\"吊起界面\");&#125;]; 锁屏和应用程序在后台的效果分别如下所示： 4.CXProviderDelegate相关函数解析CXProviderDelegate中的相关函数用来处理系统通话界面的某些操作回调给应用程序。 123456789101112131415161718192021222324252627//当接收到呼叫重置时 调用的函数，这个函数必须被实现，其不需做任何逻辑，只用来重置状态- (void)providerDidReset:(CXProvider *)provider;//呼叫开始时回调 - (void)providerDidBegin:(CXProvider *)provider;//音频会话激活状态的回调- (void)provider:(CXProvider *)provider didActivateAudioSession:(AVAudioSession *)audioSession;//音频会话停用的回调- (void)provider:(CXProvider *)provider didDeactivateAudioSession:(AVAudioSession *)audioSession;//行为超时的回调 - (void)provider:(CXProvider *)provider timedOutPerformingAction:(CXAction *)action;//有事务被提交时调用 //如果返回YES 则表示事务被捕获处理 后面的回调都不会调用 如果返回NO 则表示事务不被捕获，会回调后面的函数- (BOOL)provider:(CXProvider *)provider executeTransaction:(CXTransaction *)transaction;//点击开始按钮的回调- (void)provider:(CXProvider *)provider performStartCallAction:(CXStartCallAction *)action;//点击接听按钮的回调- (void)provider:(CXProvider *)provider performAnswerCallAction:(CXAnswerCallAction *)action;//点击结束按钮的回调- (void)provider:(CXProvider *)provider performEndCallAction:(CXEndCallAction *)action;//点击保持通话按钮的回调- (void)provider:(CXProvider *)provider performSetHeldCallAction:(CXSetHeldCallAction *)action;//点击静音按钮的回调- (void)provider:(CXProvider *)provider performSetMutedCallAction:(CXSetMutedCallAction *)action;//点击组按钮的回调- (void)provider:(CXProvider *)provider performSetGroupCallAction:(CXSetGroupCallAction *)action;//DTMF功能回调- (void)provider:(CXProvider *)provider performPlayDTMFCallAction:(CXPlayDTMFCallAction *)action; 需要注意，上面的最后几个回调中CXStartCallAction都会提供一个fullfill的函数，当处理完成回调逻辑后，开发者需要手动调用此函数来通知系统。同样，其中还有一个fail和timeout函数，调用它要通知系统此行为执行失败和超时。 5.CXCallController解析当用户在应用程序内部进行的通讯操作时，可以使用这个类来通知系统。 12345678910//初始化方法- (instancetype)init;- (instancetype)initWithQueue:(dispatch_queue_t)queue;//通讯监听@property (nonatomic, readonly, strong) CXCallObserver *callObserver;//发起一个事务请求 CXProvider之后会接收到请求 进行逻辑- (void)requestTransaction:(CXTransaction *)transaction completion:(void (^)(NSError *_Nullable error))completion;//通过行为发起事务- (void)requestTransactionWithActions:(NSArray&lt;CXAction *&gt; *)actions completion:(void (^)(NSError *_Nullable error))completion API_AVAILABLE(ios(11.0));- (void)requestTransactionWithAction:(CXAction *)action completion:(void (^)(NSError *_Nullable error))completion API_AVAILABLE(ios(11.0)); 6.CXTransaction类CXTransaction是封装了行为的事务。 1234567891011//唯一 ID@property (nonatomic, readonly, copy) NSUUID *UUID;//行为完成后的回调@property (nonatomic, readonly, assign, getter=isComplete) BOOL complete;//行为数组@property (nonatomic, readonly, copy) NSArray&lt;__kindof CXAction *&gt; *actions;//初始化函数- (instancetype)initWithActions:(NSArray&lt;CXAction *&gt; *)actions;- (instancetype)initWithAction:(CXAction *)action;//添加行为- (void)addAction:(CXAction *)action; 四、进行来电拦截与号码识别上面我们介绍了使用CallKit框架来实现的通讯功能，有通讯功能就难免需要进行联系人识别与黑名单。CallKit框架中还有一部分内容可以结合Call Directory Extension来实现号码拦截与识别。 首先创建一个扩展Target，选择Call Directory Extension： 创建好Target工程后，其实需要的核心代码Xcode已经帮我们都生成。 第一步，需要在主APP中进行号码服务的验证和更新， 1234567891011_manager = [[CXCallDirectoryManager alloc]init]; [_manager getEnabledStatusForExtensionWithIdentifier:@\"jaki.CallKitTest.Ex\" completionHandler:^(CXCallDirectoryEnabledStatus enabledStatus, NSError * _Nullable error) &#123; if (enabledStatus==CXCallDirectoryEnabledStatusEnabled) &#123; NSLog(@\"允许\"); &#125;else&#123; NSLog(@\"请开启\"); &#125; &#125;]; [_manager reloadExtensionWithIdentifier:@\"jaki.CallKitTest.Ex\" completionHandler:^(NSError * _Nullable error) &#123; NSLog(@\"刷新配置\"); &#125;]; 通常情况下，当用户在主APP中进行添加联系人，登录，切换账户等操作后，需要通知扩展程序进行号码库的更新，当然，一般在号码库更新时需要从主APP传递数据给扩展，我们可以通过Group来实现，这里不再展开。 工程运行后，会在用户的“设置-&gt;电话-&gt;来电组织与身份识别”项目中看到扩展程序： 当用户打开此服务或者调用上面的reloadExtension时，会从执行扩展程序的相关方法来重新加载号码库。需要注意，reloadExtension函数中的id参数为扩展项目的bundleID，不是主项目的。 在扩展工程的info.plist文件中，默认配置好了处理来电的操作类，如果要自定义，需要开发者手动修改： 默认的CallDirectoryHandler类为来电拦截与身份识别的操作类，其集成自CXCallDirectoryProvider类，当收到加载号码库的请求时，会执行下面的函数： 123456789101112131415- (void)beginRequestWithExtensionContext:(CXCallDirectoryExtensionContext *)context &#123; context.delegate = self; //是否支持增量更新 if (context.isIncremental) &#123; [self addOrRemoveIncrementalBlockingPhoneNumbersToContext:context]; [self addOrRemoveIncrementalIdentificationPhoneNumbersToContext:context]; &#125; else &#123; [self addAllBlockingPhoneNumbersToContext:context]; [self addAllIdentificationPhoneNumbersToContext:context]; &#125; //完成更新操作 [context completeRequestWithCompletionHandler:nil];&#125; 上面是Xcode默认提供的实现，十分优雅，在iOS11后，号码库的更新支持增量，所以这里进行的区分。 CXCallDirectoryExtensionContext是一个操作上下文，通过它可以像号码库中添加删除数据。解析如下： 12345678910111213141516//是否支持增量更新@property (nonatomic, readonly, getter=isIncremental) BOOL incremental API_AVAILABLE(ios(11.0));//添加一个黑名单号码- (void)addBlockingEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber;//移除一个黑名单号码- (void)removeBlockingEntryWithPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber API_AVAILABLE(ios(11.0));//移除所有的黑名单号码- (void)removeAllBlockingEntries API_AVAILABLE(ios(11.0));//添加一个身份识别- (void)addIdentificationEntryWithNextSequentialPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber label:(NSString *)label;//移除一个身份识别- (void)removeIdentificationEntryWithPhoneNumber:(CXCallDirectoryPhoneNumber)phoneNumber API_AVAILABLE(ios(11.0));//移除所有身份识别- (void)removeAllIdentificationEntries API_AVAILABLE(ios(11.0));//完成操作后 需要手动调用此函数- (void)completeRequestWithCompletionHandler:(nullable void (^)(BOOL expired))completion; 添加了黑名单后，用户将收不到此号码的电话，同样，设置了身份识别后，当用户播出前，会显示设置的身份信息(需要注意，大陆号码需要前面带86)，如下：","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Masonry源码解析","slug":"371Masonry源码解析","date":"2018-04-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.377Z","comments":true,"path":"2018/04/20/371Masonry源码解析/","link":"","permalink":"http://huishao.cc/2018/04/20/371Masonry源码解析/","excerpt":"","text":"Masonry源码解析Masonry的核心依然是使用原生的NSLayoutConstraint类来进行添加约束，通过统一的封装和链式函数式编程的方式让开发者添加约束布局更加方便。 一、核心的View+MASAdditions类别这个类别是Masonry中用来添加，更新和重置约束的核心类别。其中提供了我们最常用的布局函数。首先从类别命名上也可以看出，此类别扩展的类是通过宏来设置的： 1@interface MAS_VIEW (MASAdditions) MAS_VIEW宏做到了平台屏蔽的作用，在iOS上，其为UIView，在MacOS上其实NSView。 MASAdditions类别中定义了许多布局属性，例如上，下，左，右边距，宽度高度等等。这些属性被抽象为MASViewAttribute对象，关于这个对象，后面会具体介绍。 1234567891011121314151617181920212223242526272829303132333435363738//左@property (nonatomic, strong, readonly) MASViewAttribute *mas_left;//上@property (nonatomic, strong, readonly) MASViewAttribute *mas_top;//右@property (nonatomic, strong, readonly) MASViewAttribute *mas_right;//下@property (nonatomic, strong, readonly) MASViewAttribute *mas_bottom;//前@property (nonatomic, strong, readonly) MASViewAttribute *mas_leading;//后@property (nonatomic, strong, readonly) MASViewAttribute *mas_trailing;//宽@property (nonatomic, strong, readonly) MASViewAttribute *mas_width;//高@property (nonatomic, strong, readonly) MASViewAttribute *mas_height;//水平中心@property (nonatomic, strong, readonly) MASViewAttribute *mas_centerX;//垂直中心@property (nonatomic, strong, readonly) MASViewAttribute *mas_centerY;//基线@property (nonatomic, strong, readonly) MASViewAttribute *mas_baseline;//这个是一个链式编程的通用转换方法，使用这个属性将系统的NSLayoutAttribute转换成抽象的MASViewAttribute对象@property (nonatomic, strong, readonly) MASViewAttribute *(^mas_attribute)(NSLayoutAttribute attr);//基线相关@property (nonatomic, strong, readonly) MASViewAttribute *mas_firstBaseline;@property (nonatomic, strong, readonly) MASViewAttribute *mas_lastBaseline;//安全区 相关@property (nonatomic, strong, readonly) MASViewAttribute *mas_safeAreaLayoutGuide API_AVAILABLE(ios(11.0),tvos(11.0));@property (nonatomic, strong, readonly) MASViewAttribute *mas_safeAreaLayoutGuideTop API_AVAILABLE(ios(11.0),tvos(11.0));@property (nonatomic, strong, readonly) MASViewAttribute *mas_safeAreaLayoutGuideBottom API_AVAILABLE(ios(11.0),tvos(11.0));@property (nonatomic, strong, readonly) MASViewAttribute *mas_safeAreaLayoutGuideLeft API_AVAILABLE(ios(11.0),tvos(11.0));@property (nonatomic, strong, readonly) MASViewAttribute *mas_safeAreaLayoutGuideRight API_AVAILABLE(ios(11.0),tvos(11.0));//关联的key值@property (nonatomic, strong) id mas_key; 下面是3个最常使用的布局方法： 123456//创建约束- (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;//更新约束- (NSArray *)mas_updateConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;//重新创建约束- (NSArray *)mas_remakeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block; 这3个函数的具体实现基本一致，其核心流程都是：关闭视图Autoresizing特性-&gt;创建约束生成器-&gt;配置约束生成器-&gt;回调开发者约束设置-&gt;进行约束加载。这3个函数不同的地方只在配置约束生成器部分，配置了updateExisting参数为YES，表示要进行已有约束的更新，配置了removeExisting为YES表示要重新创建约束。约束生成器被抽象为MASConstraintMaker对象，下面来具体看这个类。 二、MASConstraintMaker约束生成器MASConstraint类主要用来构建约束对象。其中虽然和MASAdditions扩展类似，也是定义了约束属性对象，但是其所有的Get方法都被重新实现了，当我们通过Get方法调用约束属性时，会执行下面核心函数： 123456789101112131415161718192021- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; //创建属性 MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; //创建约束对象 MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; if ([constraint isKindOfClass:MASViewConstraint.class]) &#123; //进行复合 //replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125; if (!constraint) &#123; newConstraint.delegate = self; [self.constraints addObject:newConstraint]; &#125; //将约束对象返回 return newConstraint;&#125; 上面函数的设计可以巧妙的实现复合约束，例如make.width.height.equalTo(@100)这样一条约束，实际上从width开始后面的属性都被复合进了MASCompositeConstraint对象。约束的属性创建出来后，需要对其进行值的设置，下面来看MASViewConstraint对象。 三、MASConstraint约束对象MASViewConstraint类继承自MASConstraint类，MASConstraint类还有一个子类为MASCompositeConstraint类。MASConstraint中定义了基础的约束值设置方法，都是采用block回调的方式，因此可以进行链式编程： 123456789101112131415161718192021222324//位置- (MASConstraint * (^)(MASEdgeInsets insets))insets;//尺寸偏移- (MASConstraint * (^)(CGSize offset))sizeOffset;//中心位置偏移- (MASConstraint * (^)(CGPoint offset))centerOffset;//比例 *- (MASConstraint * (^)(CGFloat multiplier))multipliedBy;//比例 /- (MASConstraint * (^)(CGFloat divider))dividedBy;//优先级- (MASConstraint * (^)(MASLayoutPriority priority))priority;//直接设置为低优先级- (MASConstraint * (^)(void))priorityLow;//直接设置为中优先级- (MASConstraint * (^)(void))priorityMedium;//直接设置为高优先级- (MASConstraint * (^)(void))priorityHigh;//设置绝对等于- (MASConstraint * (^)(id attr))equalTo;//大于等于- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;//小于等于- (MASConstraint * (^)(id attr))lessThanOrEqualTo; 阅读这个属性的Get方法，你会发现他们最后都返回了当前对象本身，这也是为链式编程所准备，MASConstraint中还有两个属性比较有趣： 12- (MASConstraint *)with;- (MASConstraint *)and; 这两个属性没有实际的作用也没有任何影响，他们的实现是直接返回当前对象，增强代码可读性。 MASConstraint类中的install和uninstall函数是核心的约束添加方法，其中会进行系统原生约束对象的转换添加或者删除操作。核心的install函数解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (void)install &#123; //如果已经被加载 直接返回 if (self.hasBeenInstalled) &#123; return; &#125; //如果系统layout对象已经创建 直接添加之后 返回 if ([self supportsActiveProperty] &amp;&amp; self.layoutConstraint) &#123; self.layoutConstraint.active = YES; [self.firstViewAttribute.view.mas_installedConstraints addObject:self]; return; &#125; //获取布局的视图与属性 MAS_VIEW *firstLayoutItem = self.firstViewAttribute.item; NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute; MAS_VIEW *secondLayoutItem = self.secondViewAttribute.item; NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute; //如果不是尺寸布局并且 相对视图不存在 默认对父视图进行相对布局 if (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) &#123; secondLayoutItem = self.firstViewAttribute.view.superview; secondLayoutAttribute = firstLayoutAttribute; &#125; //创建布局对象 MASLayoutConstraint *layoutConstraint = [MASLayoutConstraint constraintWithItem:firstLayoutItem attribute:firstLayoutAttribute relatedBy:self.layoutRelation toItem:secondLayoutItem attribute:secondLayoutAttribute multiplier:self.layoutMultiplier constant:self.layoutConstant]; //设置key和优先级 layoutConstraint.priority = self.layoutPriority; layoutConstraint.mas_key = self.mas_key; //设置约束对象对用于的视图 if (self.secondViewAttribute.view) &#123; //获取共同的父视图 MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view]; NSAssert(closestCommonSuperview, @\"couldn't find a common superview for %@ and %@\", self.firstViewAttribute.view, self.secondViewAttribute.view); self.installedView = closestCommonSuperview; &#125; else if (self.firstViewAttribute.isSizeAttribute) &#123; self.installedView = self.firstViewAttribute.view; &#125; else &#123; self.installedView = self.firstViewAttribute.view.superview; &#125; MASLayoutConstraint *existingConstraint = nil; //更新约束的操作 if (self.updateExisting) &#123; existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint]; &#125; if (existingConstraint) &#123; // just update the constant existingConstraint.constant = layoutConstraint.constant; self.layoutConstraint = existingConstraint; &#125; else &#123; //添加约束 [self.installedView addConstraint:layoutConstraint]; self.layoutConstraint = layoutConstraint; [firstLayoutItem.mas_installedConstraints addObject:self]; &#125;&#125; 四、一个小技巧Masonry中的一个函数值得我们学习，其作用是对任何类型的值进行一层对象包装，函数如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//值包装宏#define MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value))static inline id _MASBoxValue(const char *type, ...) &#123; va_list v; va_start(v, type); id obj = nil; //进行类型判断 结构体包装成NSValue 基本类型包装成NSNumber if (strcmp(type, @encode(id)) == 0) &#123; id actual = va_arg(v, id); obj = actual; &#125; else if (strcmp(type, @encode(CGPoint)) == 0) &#123; CGPoint actual = (CGPoint)va_arg(v, CGPoint); obj = [NSValue value:&amp;actual withObjCType:type]; &#125; else if (strcmp(type, @encode(CGSize)) == 0) &#123; CGSize actual = (CGSize)va_arg(v, CGSize); obj = [NSValue value:&amp;actual withObjCType:type]; &#125; else if (strcmp(type, @encode(MASEdgeInsets)) == 0) &#123; MASEdgeInsets actual = (MASEdgeInsets)va_arg(v, MASEdgeInsets); obj = [NSValue value:&amp;actual withObjCType:type]; &#125; else if (strcmp(type, @encode(double)) == 0) &#123; double actual = (double)va_arg(v, double); obj = [NSNumber numberWithDouble:actual]; &#125; else if (strcmp(type, @encode(float)) == 0) &#123; float actual = (float)va_arg(v, double); obj = [NSNumber numberWithFloat:actual]; &#125; else if (strcmp(type, @encode(int)) == 0) &#123; int actual = (int)va_arg(v, int); obj = [NSNumber numberWithInt:actual]; &#125; else if (strcmp(type, @encode(long)) == 0) &#123; long actual = (long)va_arg(v, long); obj = [NSNumber numberWithLong:actual]; &#125; else if (strcmp(type, @encode(long long)) == 0) &#123; long long actual = (long long)va_arg(v, long long); obj = [NSNumber numberWithLongLong:actual]; &#125; else if (strcmp(type, @encode(short)) == 0) &#123; short actual = (short)va_arg(v, int); obj = [NSNumber numberWithShort:actual]; &#125; else if (strcmp(type, @encode(char)) == 0) &#123; char actual = (char)va_arg(v, int); obj = [NSNumber numberWithChar:actual]; &#125; else if (strcmp(type, @encode(bool)) == 0) &#123; bool actual = (bool)va_arg(v, int); obj = [NSNumber numberWithBool:actual]; &#125; else if (strcmp(type, @encode(unsigned char)) == 0) &#123; unsigned char actual = (unsigned char)va_arg(v, unsigned int); obj = [NSNumber numberWithUnsignedChar:actual]; &#125; else if (strcmp(type, @encode(unsigned int)) == 0) &#123; unsigned int actual = (unsigned int)va_arg(v, unsigned int); obj = [NSNumber numberWithUnsignedInt:actual]; &#125; else if (strcmp(type, @encode(unsigned long)) == 0) &#123; unsigned long actual = (unsigned long)va_arg(v, unsigned long); obj = [NSNumber numberWithUnsignedLong:actual]; &#125; else if (strcmp(type, @encode(unsigned long long)) == 0) &#123; unsigned long long actual = (unsigned long long)va_arg(v, unsigned long long); obj = [NSNumber numberWithUnsignedLongLong:actual]; &#125; else if (strcmp(type, @encode(unsigned short)) == 0) &#123; unsigned short actual = (unsigned short)va_arg(v, unsigned int); obj = [NSNumber numberWithUnsignedShort:actual]; &#125; va_end(v); return obj;&#125; 其中@encode()是一个编译时特性，其可以将传入的类型转换为标准的OC类型字符串。","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"HTML5中Canvas元素的使用总结","slug":"370HTML5中Canvas元素的使用总结","date":"2018-04-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.377Z","comments":true,"path":"2018/04/16/370HTML5中Canvas元素的使用总结/","link":"","permalink":"http://huishao.cc/2018/04/16/370HTML5中Canvas元素的使用总结/","excerpt":"","text":"HTML5中Canvas元素的使用总结Canvas提供了开发者自定义绘图的接口，我们可以公国getContext()函数来获取绘图上下文进行绘制操作，这个函数中可以传入两个参数，其中第1个参数设置绘图上下文的类型，比较常用的是&quot;2d&quot;，我们也可以使用&quot;webgl&quot;来使用webOpenGL实现3D绘制。本篇博客主要总结2d绘制的相关方法。 1.进行简单的图形绘制使用Canvas进行平面图形绘制比较简单。例如使用如下函数则可以直接绘制一个矩形区域。 123var c = document.getElementById(\"canvas\");var context = c.getContext(\"2d\");context.strokeRect(20,20,100,100); 图形效果如下： 与strokeRect对应，使用fillRect可以绘制填充矩形，例如： 123var c = document.getElementById(\"canvas\");var context = c.getContext(\"2d\");context.fillRect(20,20,100,100); 效果如下： 使用clearRect函数可以进行矩形区域的擦除，示例如下： 1234var c = document.getElementById(\"canvas\");var context = c.getContext(\"2d\");context.strokeRect(20,20,100,100);context.clearRect(10,10,100,100); 效果如下图： 上面的绘制图形的方法实际上是一个复合的函数，其完成了路径的定义和绘制两步。我们也可以自定义图形路径，例如： 12345678var c = document.getElementById(\"canvas\");var context = c.getContext(\"2d\");context.beginPath();context.moveTo(20,20);context.lineTo(20,100);context.lineTo(100,100);context.closePath();context.stroke(); 效果如下： beginPath函数用来开启一个路径，moveTo函数用于将画笔移动到某个点，lineTo函数用来定义一条线，线的起点为当前画笔所在位置，参数为终点位置。closePath函数用来关闭路径，当然，此函数并非一定要调用，如果不调用可以绘制非闭合的图形。stroke函数用来将已经定义的图形进行绘制，与其对应还有一个fill函数用来进行填充绘制。 quadraticCurveTo与bezierCurveTo两个函数分别用来创建二次与三次贝塞尔曲线路径，示例如下： 123456context.moveTo(20,120);context.quadraticCurveTo(20,200,100,180);context.stroke();context.moveTo(20,200);context.bezierCurveTo(20,300,60,300,60,200);context.stroke(); 效果如下图： 关于贝塞尔曲线的相关内容，可以查阅下面的博客： https://my.oschina.net/u/2340880/blog/1519503。 arc函数用来创建圆形弧线，例如： 123context.moveTo(110,350);context.arc(60,350,50,0,2*Math.PI,false);context.stroke(); arc函数中，前两个个参数设置圆心点，第3个参数设置半径，第4个和第5个参数设置圆弧的起始点和结束点，以弧度制表示，最后一个参数为布尔值，设置是否逆向绘制。还有一个arcTo函数用来绘制两条切线间的圆弧，如下： 123context.moveTo(20,420);context.arcTo(80,420,80,600,50);context.stroke(); 效果如下图所示： 使用clip函数可以进行裁剪操作，裁剪之后，之后的绘制只能绘制在裁剪的区域内，例如： 123context.rect(0,500,100,30);context.clip();context.fillRect(0,500,200,200); 效果如下： 有一点需要注意，使用clip函数进行裁剪后，之后的绘制将只能在裁剪的区域内进行绘制，如果想在裁剪区域外绘制，需要使用save和restore两个函数来处理，在裁剪前，使用save函数来保存当前绘图上下文的状态，想要在裁剪区域外绘制时使用restore函数来还原绘图上下文。 2.绘制文本和图像前面示例了使用Canvas进行图形的绘制，除了图形，使用Canvas也可以轻松的绘制出图像与文本。使用drawImage函数进行图像的绘制，如下： 12345var image = document.createElement(\"img\");image.src = 'img/HBuilder.png';image.onload = function()&#123; context.drawImage(image,0,600);&#125; 需要注意，上面创建了img元素后，设置src属性后不能立刻进行渲染，因为图片的加载是需要时间的，直接渲染会无法获取图像数据。drawImage这个函数总共可以有8个参数，drawImage(img,sx,sy,sw,sh,x,y,w,h)。其中sx，sy和sw，sh用来对原图像进行裁剪，只选择图像中的部分进行绘制，x，y，w，h设置绘制在画布上的坐标和尺寸。 关于文本绘制，可以使用fillText或strokeText函数，分别用来绘制实心和空心文字。示例如下： 1234context.font = \"20px Georgia\";//设置字体 context.textAlign = 'start'; //设置文字对齐方式context.fillText(\"Hello World\",0,750,200);context.strokeText(\"Hello World\",0,800,200); 效果如下： 3.绘制属性的设置在绘制过程中，开发者可以对绘制的线条颜色，填充颜色，风格，阴影等进行设置。示例如下： 123456789context.fillStyle = 'red'; //设置填充颜色context.strokeStyle = 'blue'; //设置线条颜色context.shadowColor = 'green'; //设置阴影颜色context.shadowBlur = 10; //设置阴影模糊度context.shadowOffsetX = 10; //设置阴影X轴偏移量context.shadowOffsetY = 5; //设置阴影Y轴偏移量context.lineCap = 'round'; //设置线帽样式context.lineJoin = 'round'; //设置折点样式context.lineWidth = 1; //设置线条宽度 效果如下图： 关于fillStyle和strokeStyle两个属性比较特殊，从名字也可以了解其是设置填充或线条的风格，设置颜色只是一种方式，其还可以设置为一个渐变对象，用来实现渐变效果。例如： 12345var g = context.createLinearGradient(0,750,200,750);g.addColorStop(0,'black');g.addColorStop(0.5,'red');context.fillStyle = g;context.fillText(\"Hello World\",0,750,200); 效果入下图： createLinearGradient函数用来创建线性渐变层，其中4个参数设置起始点的x，y和结束点的x，y。调用addColorStop函数用来想渐变层中添加临界点和颜色值。也可以创建发散型渐变，例如： 12345var g = context.createRadialGradient(70,800,20,70,800,50);g.addColorStop(0,'black');g.addColorStop(1,'red');context.fillStyle = g;context.fillRect(20,750,100,100); 效果如下： createRadiaGradient函数的前3个参数设置渐变开始处的圆弧(分别设置圆心x，y坐标和半径)，后3个参数设置渐变结束处的圆弧(分别设置圆心x，y坐标和半径)。 fillStyle和strokeStyle也可以设置为一个模式背景，例如将图片进行重复得到的背景，示例如下： 12345image.onload = function()&#123; var p = context.createPattern(image,'repeat'); context.fillStyle = p; context.fillRect(20,750,200,200);&#125; 效果如下图所示： 可选的重复模式还有： repeat-x：只在水平方向重复。 repeat-y：只在竖直方向重复。 no-repeat：不重复，只显示一次。 4.进行画布转换画布也可以进行一些简单的变换操作，例如旋转，缩放等等。需要注意，对画布的操作不会影响到已经绘制到画布上的内容，之后绘制的内容会受到影响。使用scale(x,y)函数可以对画布进行缩放，其中两个参数x和y分别设置水平和竖直方向的缩放比例。rotate(angle)函数用来对画布进行旋转，其中的参数为旋转的角度值。translate(x,y)函数用来对画布进行平移，参数x，y分别设置水平和竖直方向的平移量。还有一个复合的transform(a,b,c,d,e,f)函数，使用这个函数可以一步设置平移，旋转和缩放属性，参数意义如下： a：设置水平缩放比 b：设置水平倾斜 c：设置垂直倾斜 d：设置垂直缩放比 e：设置水平平移 f：设置垂直平移 需要注意，如果你多次调用transform，每次的transform变换都将在上一次的基础上进行。如果你不想保留上一次的记录，可以调用setTransform()函数来重置设置。","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"JSONModel源码解析","slug":"369JSONModel源码解析","date":"2018-03-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.377Z","comments":true,"path":"2018/03/30/369JSONModel源码解析/","link":"","permalink":"http://huishao.cc/2018/03/30/369JSONModel源码解析/","excerpt":"","text":"JSONModel源码解析一、引言做移动端开发，解析网络数据是必不可少的工作之一。iOS原生框架很早前就已经提供了将JSON数据直接映射成数组或者字典对象的方法，并且结合KVC，也可以将字典数据直接赋值给对象。但是这种方式十分不灵活，例如如果网络数据中的字段与我们数据模型中的字段不一致，某些网络数据的字段可能为nil等等都需要开发者单独的处理。使用JSOMModel可以十分方便的处理映射过程中的各种情况。 二、JSOMModel类概览平时在使用JSOMModel框架时，往往只会用到JSOMModel这一个类，其实JSOMModel中还封装了一套网络请求逻辑，你可以直接对某个对象调用请求来映射成为数据模型。但是我建议尽量将数据的请求和解析分开来做，这样更利于请求的维护(在新的JSOMModel版本中，也将有关网络请求的部分标记为了弃用)。JSOMModel功能十分强大，代码量却并不特别多，结构逻辑也较为清晰。其中类的关系和结构如下图表示。 如上图所示，其中网络相关模块已经弃用，并且也不是JSONModel的核心模块，不在本次博客的探讨范围之内。JSONModelError定义了许多错误类型，主要用来当请求或数据解析异常时进行抛出，需要注意，JSONModel定义的自己的log函数，其只会在模拟器运行时进行打印。 三、JSONModelClassProperty类的意义将网络数据映射为Model模型的实质即是对Model对象中属性的赋值，在JSONModel中，类的属性被抽象为JSONModelClassProperty对象，这个对象中封装这此属性的相关信息(通过runtime来动态生成)。JSONModelClassProerty类中的属性意义如下： 12345678910111213141516171819202122@interface JSONModelClassProperty : NSObject//已经弃用 这个用来标识当前属性是否是对象的主键 用来进行数据模型的比较@property (assign, nonatomic) BOOL isIndex DEPRECATED_ATTRIBUTE;//属性名@property (copy, nonatomic) NSString *name;//属性类型@property (assign, nonatomic) Class type;//属性结构体名称 基本数据类型的属性 会被抽象成结构体@property (strong, nonatomic) NSString *structName;//属性遵守的协议名@property (copy, nonatomic) NSString *protocol;//当前属性是否是可选属性 如果是 在解析时允许这个属性值为nil@property (assign, nonatomic) BOOL isOptional;//是否是标准的json数据，如果是则不用再调用数据转换的方法@property (assign, nonatomic) BOOL isStandardJSONType;//当前属性是否是可变的 如果是 则会创建可变对象@property (assign, nonatomic) BOOL isMutable;//自定义的 属性get函数@property (assign, nonatomic) SEL customGetter;//自定义的属性 set函数@property (strong, nonatomic) NSMutableDictionary *customSetters;@end 四、关于属性映射器JSONKeyMapper简单理解，JSONKeyMapper属性映射器的作用就是用来制定在数据解析时所遵循的规则。最理想的情况是JSON数据与我们要解析成的数据模型完全对应，例如： JSON数据： 1&#123; \"firstName\":\"Bill\" , \"lastName\":\"Gates\" &#125; 数据Model: 1234567@interface MyOnject : NSObject@property(nonatomic,strong)NSString * firstName;@property(nonatomic,strong)NSString * lastName;@end 然而在实际的开发中，这种完美的情况却很少出现，我们更多遇到的是，JSON数据中某些字段可能有也可能无，数据Model中需要增加些本地字段，JSON数据和Model的某些字段名称可能不一致。更加复杂一点，我们可以Model的某个属性是另一个Model。或者某个属性是数组，数组中存放的是另一种Model。 JSONKeyMapper接口定义如下： 123456789101112//通过字典来创建映射器 字典的键为数据Model的属性名 值为JSOM数据的属性名 - (instancetype)initWithModelToJSONDictionary:(NSDictionary *)toJSON;//通过block来建立映射关系 block的定义如下，其中会将JSOM数据的属性名传入 需要返回要对应Model的属性名/*typedef NSString *(^JSONModelKeyMapBlock)(NSString *keyName);*/ - (instancetype)initWithModelToJSONBlock:(JSONModelKeyMapBlock)toJSON;//创建一个 将以下划线分割的命名键 转换成驼峰命名 例如 first_name =&gt; firstName+ (instancetype)mapperForSnakeCase;//创建一个 将首字母大写的明明键 转换成驼峰 例如 FirstName =&gt; firstName+ (instancetype)mapperForTitleCase; 五、核心数据模型类JSONModelJSONModel框架中最核心的类JSONModel类，其中代码大约有1400行，除了一些调试，复写和提供方便功能的代码外，核心代码在800行左右。首先，其头文件中声明了几个协议，如下： 123456@protocol Index@end@protocol Ignore@end@protocol Optional@end 需要注意，这些协议里面都没有约定任何方法，它们也不会用来实现的，其作为属性的一种标记，例如将属性添加Ignore协议，则JSONModel不会对这个属性进行解析，使用这种方式来进行本地数据的管理，例如： 123456789@interface MyOnject : JSONModel@property(nonatomic,strong)NSString * firstName;@property(nonatomic,strong)NSString * lastName;//这个属性是本地拼接 使用@property(nonatomic,strong)NSString&lt;Ignore&gt; * fullName;@end Optional协议表示这个属性是可选的，即JSON数据中如果有这个属性就解析，如果没有就跳过。Index协议标记这个属性是当前对象的主键，已经弃用。 有了这3个协议，在声明属性时，我们可以十分容易的设定他们的解析规则，在JSONModel中，协议除了可以用来规定解析规则外，还可以用来指定自定义数据类型的解析，只是我们需要自己定义一个协议，名称与自定义类名一致，示例如下： 1234567891011121314151617181920#import \"JSONModel.h\"@protocol Address@end@interface Address:JSONModel@property(nonatomic,strong)NSString * info;@end@interface MyObject : JSONModel@property(nonatomic,strong)NSString&lt;Optional&gt; * firstName;@property(nonatomic,strong)NSString * lastName;@property(nonatomic,strong)NSArray&lt;Address&gt; * address;@end 如上代码所以，在解析数据时，会直接将address数组中赋值为Address的对象，当前也可以直接解析对象，例如： 1234567891011121314151617181920@protocol Address@end@interface Address:JSONModel@property(nonatomic,strong)NSString * info;@end@interface MyObject : JSONModel@property(nonatomic,strong)NSString&lt;Optional&gt; * firstName;@property(nonatomic,strong)NSString * lastName;@property(nonatomic,strong)Address&lt;Address&gt; * address;@end 需要注意，在Objective-C中，只有NSObject的子类可以遵守协议，原始数据类型是不能遵守协议的，那么对于类似BOOL，int这样的属性有没有办法设置他们的忽略解析或者可选解析呢，当然也可以，我们可以通过重写JSONModel中的一些函数来实现，这种方法更加通用，JSONModel类接口意义如下： 1234567891011121314151617181920//将JSON字符串解析成数据模型对象- (instancetype)initWithString:(NSString *)string error:(JSONModelError **)err;- (instancetype)initWithString:(NSString *)string usingEncoding:(NSStringEncoding)encoding error:(JSONModelError **)err;//将数据模型对象转换成JSON字符串- (NSString *)toJSONString;//将数据模型对象转换成JSON数据- (NSData *)toJSONData;//将数据模型对象中的某些键组合成JSON字符串- (NSString *)toJSONStringWithKeys:(NSArray *)propertyNames;//将数据模型对象中的某些键组合成JSON数据- (NSData *)toJSONDataWithKeys:(NSArray *)propertyNames;//重写这个函数 来设置解析时使用的属性映射器+ (JSONKeyMapper *)keyMapper;//重写这个函数 来设置某个属性是否是可选的+ (BOOL)propertyIsOptional:(NSString *)propertyName;//重写这个函数 来设置某个属性是否是忽略的+ (BOOL)propertyIsIgnored:(NSString *)propertyName;//重写这个函数 来设置 如果某个属性集合中是一个自定义对象或本身是自定义对象 设置此对象的类+ (Class)classForCollectionProperty:(NSString *)propertyName; JSONModel的源码这里就不在列举，其首先在类load函数中进行静态数据的加载，所支持的原生类型和基础数据类型的定义等。在对象的初始化方法中，首先使用runtime获取所有的属性和属性的修饰内容，所谓修饰内容，即是指属性名称，类型，所遵守的协议，以及是否忽略，是否可选，是否是主键等内容(过程中会使用到属性映射器keyMapper进行转化)，将其抽象成JSONModelClassProperty对象。后面在解析时，会根据JSONModelClassProperty中的自定义setter和其他信息进行赋值。","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"从一些简单的例子看算法时间复杂度","slug":"368从一些简单的例子看算法时间复杂度","date":"2018-03-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.377Z","comments":true,"path":"2018/03/18/368从一些简单的例子看算法时间复杂度/","link":"","permalink":"http://huishao.cc/2018/03/18/368从一些简单的例子看算法时间复杂度/","excerpt":"","text":"从一些简单的例子看算法时间复杂度在编程中，一段代码的执行效率实际上很难估算和预测，其主要受到如下几个方面的影响： 1.算法依据的数学基础。 2.编译器产生的代码质量和语言的执行效率。 3.问题的输入规模。 4.硬件的执行速度。 通常情况下，问题的输入规模和算法的数学基础是编码人员需要考虑的条件。时间复杂度是一个用来描述算法执行效率的重要标准。 在理解时间复杂度之前，你应该先了解什么叫做算法的时间频度，所谓时间频度即是一个算法解决问题所消耗的时间。但是一般情况下，一个算法解决问题消耗的时间通常与输入值有关，例如我们输入一个整数，找到比它小的所有正偶数，代码如下： 1234567let n = 10;for (var i = 0; i &lt; n; i++) &#123; if (i%2==0) &#123; console.log(i); &#125;&#125; 上面代码，当输入n为10时，循环会执行10次，如果时间频度t，则当输入n为20时，时间频度为2t。时间复杂度是用来描述随着问题规模n的变化时间频度t的变化规律。下面是一段更加数学风格的描述： 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 计算一个算法的时间复杂度时，我们可以将算法分解为逐条语句，计算每条语句的时间复杂度后再进行累加，如下代码的作用是对输入进行求累加： 123456let n = 10; let res = 0; //1for (var i = n; i &gt; 0; i--) &#123; //1+(n+1)+(n+1) res = i+res; //n&#125;console.log(res);//1 当n输入为10时，时间频度为1+1+n+1+n+1+n+1 = 3n+5。设算法的时间复杂度函数为f(n),(3n+5)/f(n)当n趋于无穷大时，上式可以简化为3n/f(n)，取f(n)=n,上次结果为非零常数，因此此算法的时间复杂度为f(n)=n，记做O(n)。 当算法的执行时间频度和n无关时，算法的时间复杂度为O(1)，这是时间复杂度最小的函数，但是需要注意，时间复杂度小并不能说明算法执行耗费的时间短，比如一万行代码每行只执行一次的算法时间复杂度也为O(1)。 常见的算法时间复杂度由小到大以此为： Ο(1)＜Ο(log²_n_)＜Ο(n)＜Ο(nlog²_n_)＜Ο(_n_2)＜Ο(_n_3)＜…＜Ο(_2_n)＜Ο(n!) 其中O(log² n）是除了O(1)外时间复杂度最小的函数，例如如下代码： 1234567let n = 10; var i = 1;while(i&lt;n)&#123;//2^t&lt;n t&lt;log2(n) t为时间频度 i = i * 2; tip++;&#125; 上面的时间频度为 1+1+log2(n)+log2(n)+log2(n)，去掉常数项后为3log2(n)，时间复杂度为O(log2(n))。如果将上面的代码在加一层循环，则时间复杂度会变为O(nlog3(n)): 123456789let n = 10; for (var i = 0; i &lt; n; i++) &#123;// 1+n+1+n+1 var j = 1; //n while(j&lt;n)&#123;//[3^t&lt;n t&lt;log3(n)]n t为时间频度 j = j*3; &#125;&#125; 通过上面的示例，也很容易可以看出，循环层数的增多会剧烈的增加算法的时间复杂度，如果在递归函数中使用循环，则很容易产生时间复杂度为O(n!)的代码，从数学上看，这种代码随着输入复杂度的增加性能会急剧下降，在使用递归加循环时，还是要多多注意，示例代码如下： 1234567891011function func(n) &#123; //n if (n&lt;0) &#123; return; &#125; var i = 0; //n for (; i &lt; n; i++) &#123; //n*(n-1)*(n-2)...*1 console.log(\"tip\"); &#125; func(--i);&#125;func(10); 上面示例的JavaScript代码当传入n为150时的耗时已经和正常循环10000次的相同。","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"iOS开发中Log模块的解决方案","slug":"367iOS开发中Log模块的解决方案","date":"2018-03-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.376Z","comments":true,"path":"2018/03/15/367iOS开发中Log模块的解决方案/","link":"","permalink":"http://huishao.cc/2018/03/15/367iOS开发中Log模块的解决方案/","excerpt":"","text":"iOS开发中Log模块的解决方案在软件开发中，调试模块，Log模块，可视化监控模块等都属于技术需求，并非业务需求，因此在进行这类模块的构建时，我们更多的应该以面向切面的思想来编程。例如Log模块，其往往只是在Debug模式下需要，在编写时就要注意让其可以自动适应编译环境而不需代码做切换操作。 本篇博客主要介绍为项目添加Log模块的开发思路，并且推荐一款开源并且支持Cocoapods的Log库。 一、接口的提供面向切面编程的核心就是要足够简洁，不影响主体工程模块，不依赖也不引入任何其他模块的内容。Log引擎的接口设计可以全部采用宏的模式，使用预编译关键字可以十分容易的对Debug和Release环境进行分别处理，如下： 123456789101112131415161718#ifndef YHDevLog#define YHDevlOG#ifdef DEBUG#define START_DEBUG_MODE() [YHDevLogManager installDevLogView];#define WARN_LOG(msg,...) [YHDevLogManager pushLog:0 format:msg,##__VA_ARGS__,nil];#define ERROR_LOG(msg,...) [YHDevLogManager pushLog:1 format:msg,##__VA_ARGS__,nil];#define LOG(msg,...) [YHDevLogManager pushLog:2 format:msg,##__VA_ARGS__,nil];#else#define START_DEBUG_MODE()#define WARN_LOG(msg,...)#define ERROR_LOG(msg,...)#define LOG(msg,...)#endif#endif 其中，WARN_LOG，ERROR_LOG，LOG三个宏用来进行不同级别的Log打印，并且提供了格式化字符串的支持。START_DEBUG_MODE()宏用来开启模块，可以在应用程序启动完成后调用开启。 二、设计一个Model来描述Log信息Log信息是纯文本的，但是我们需要将其抽象成一种Model来进行描述，区分Log的级别，类型或者其他逻辑，YHDevLog中的Model设计如下： 12345678910111213@interface YHDevLogModel : NSObject@property(nonatomic,strong)NSString * content;/** 0 warn 1 error 2 plain */@property(nonatomic,assign)int type;//是否展开详情@property(nonatomic,assign)BOOL isOpen;@end 三、Log窗口的设计关于Log窗口，我们可以采用悬浮window的方式，为了避免影响主应用功能，窗口的悬浮模式应该可以自由调整，窗口中可以使用TableView来展示Log信息，使用功能按钮来控制窗口尺寸和进行Log的分类和清空等。关于UI方面的代码，因为采用的是纯手写的Autolayout，这里就不在列举代码，有兴趣的可以再如下地址找到： https://github.com/ZYHshao/YHDevLog 一些效果图： 使用下面的Pod可以直接使用此Log组件： pod ‘YHDevLog’ 欢迎共同探讨，一起进步！","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"30分钟摸透iOS中谓词NSPredicate的来龙去脉","slug":"366 30分钟摸透iOS中谓词NSPredicate的来龙去脉","date":"2018-03-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.376Z","comments":true,"path":"2018/03/12/366 30分钟摸透iOS中谓词NSPredicate的来龙去脉/","link":"","permalink":"http://huishao.cc/2018/03/12/366 30分钟摸透iOS中谓词NSPredicate的来龙去脉/","excerpt":"","text":"30分钟摸透iOS中谓词NSPredicate的来龙去脉一、引言在现代汉语的解释中，谓词是用来描述或判断客体性质、特征或者客体之间关系的词项。通俗的说，它是描述事物属性的。在iOS开发Cocoa框架中，有提供NSPredicate类，这个类通常也被成为谓词类，其主要的作用是在Cocoa中帮助查询和检索，但是需要注意，实质上谓词并不是提供查询和检索的支持，它是一种描述查询检索条件的方式，就像更加标准通用的正则表达式一样。 NSPredicate提供的谓词可以分为两类：比较谓词和复合谓词。 比较谓词：比较谓词通过使用比较运算符来描述所符合条件的属性状态。 复合谓词：复合谓词用来组合多个比较谓词的结果，取交集，并集或补集。 对于比较谓词，可以描述精准的比较也可以通过范围或者包含等进行模糊比较。需要注意，任何Cocoa类对象都可以支持谓词，但是此类需要实现键值编码(key-value-coding)协议。 二、NSPredicate类的应用解析NSPredicate提供创建谓词对象和解析谓词对象的方法，它也是Cocoa中有关谓词的类中的基类。我们在日常开发中，NSPredicate类的应用频率也最高。 创建谓词对象有3种方式，分别是通过格式化字符串创建谓词，直接通过代码创建谓词，通过模板创建谓词。NSPredicate提供了如下函数来进行初始化： 1234//通过格式化字符串来进行谓词对象的初始化+ (NSPredicate *)predicateWithFormat:(NSString *)predicateFormat argumentArray:(nullable NSArray *)arguments;+ (NSPredicate *)predicateWithFormat:(NSString *)predicateFormat, ...;+ (NSPredicate *)predicateWithFormat:(NSString *)predicateFormat arguments:(va_list)argList; 使用格式化字符串进行谓词的初始化十分灵活，但是需要注意，其谓词字符串的语法和正则表达式并不一样，后面会有具体的介绍，下面是一个谓词检索示例： 1234567//检索属性length为5的对象NSPredicate * predicate = [NSPredicate predicateWithFormat:@\"length = 5\"];//对于这个数组中的字符串，即是检索字符串长度为5的元素NSArray * test = @[@\"sda\",@\"321\",@\"sf12\",@\"dsdwq1\",@\"swfas\"];NSArray * result = [test filteredArrayUsingPredicate:predicate];//将打印@[@\"swfas\"]NSLog(@\"%@\",result); 其实，你也可以像使用NSLog函数一样来进行格式化字符串的构造，可以使用%@,%d等等格式化字符来在运行时替换为变量的实际值。同时也需要注意，这种格式化字符串创建的谓词语句并不会进行语法检查，错误的语法会产生运行时错误，要格外小心。有一个小细节需要注意，在进行格式化时，如果使用的是变量则不需要添加引号，解析器会帮助你添加，如果使用到常量，则要用转义字符进行转义，例如： 1NSPredicate * predicate = [NSPredicate predicateWithFormat:@\"name = %@ &amp;&amp; age = \\\"25\\\"\",name]; 对于属性名，如果也需要进行格式化，需要注意不能使用%@符号，这个符号在解析时会被解析器自动添加上引号，可以使用%K，示例如下： 123456NSString * key = @\"length\";NSPredicate * predicate = [NSPredicate predicateWithFormat:@\"%K = 5\",key];NSArray * test = @[@\"sda\",@\"321\",@\"sf12\",@\"dsdwq1\",@\"swfas\"];NSArray * result = [test filteredArrayUsingPredicate:predicate];//将打印@[@\"swfas\"]NSLog(@\"%@\",result); 通过模板来创建谓词对象也是一种十分常用的方式，和格式化字符串不同的是，谓词模板中只有键名，没有键值，键值需要在字典中进行提供，例如： 123456NSPredicate * predicate = [NSPredicate predicateWithFormat:@\"length = $LENGTH\"];predicate = [predicate predicateWithSubstitutionVariables:@&#123;@\"LENGTH\":@5&#125;];NSArray * test = @[@\"sda\",@\"321\",@\"sf12\",@\"dsdwq1\",@\"swfas\"];NSArray * result = [test filteredArrayUsingPredicate:predicate];//将打印@[@\"swfas\"]NSLog(@\"%@\",result); NSPredicate中其他属性与方法解析如下： 123456789101112131415161718192021222324//创建一个总是验证通过(YES)或不通过(NO)的谓词对象/*如果创建的是验证通过的，则任何检索都会成功进行返回，否则任何检索都会失败不返回任何对象*/+ (NSPredicate *)predicateWithValue:(BOOL)value;//自定义实现检索函数/*例如前面的示例也可以这样写NSPredicate * predicate = [NSPredicate predicateWithBlock:^BOOL(id _Nullable evaluatedObject, NSDictionary&lt;NSString *,id&gt; * _Nullable bindings) &#123; if ([evaluatedObject length]==5) &#123; return YES; &#125; return NO; &#125;];*/+ (NSPredicate*)predicateWithBlock:(BOOL (^)(id _Nullable evaluatedObject, NSDictionary&lt;NSString *, id&gt; * _Nullable bindings))block;//格式化字符串属性@property (readonly, copy) NSString *predicateFormat; //当使用谓词模板来进行对象创建时，这个函数用来设置谓词模板中变量替换- (instancetype)predicateWithSubstitutionVariables:(NSDictionary&lt;NSString *, id&gt; *)variables;//检查一个Object对象是否可以通过验证- (BOOL)evaluateWithObject:(nullable id)object; //用谓词模板进行对象的验证- (BOOL)evaluateWithObject:(nullable id)object substitutionVariables:(nullable NSDictionary&lt;NSString *, id&gt; *)bindings; 三、通过代码来创建谓词对象前面我们说有3种创建谓词对象的方式，有两种我们已经有介绍，通过代码直接创建谓词对象是最复杂的一种。通过代码来创建谓词对象十分类似通过代码来创建Autolayout约束。通过前面我们的介绍，谓词实际是用表达式来验证对象，用代码来创建谓词实际就是用代码来创建表达式。 1.先来看NSComparisonPredicate类这个类是NSPredicate的子类，其用来创建比较类型的谓词。例如使用下面的代码来改写上面的例子： 12345678910//创建左侧表达式对象 对应为键NSExpression * left = [NSExpression expressionForKeyPath:@\"length\"];//创建右侧表达式对象 对应为值NSExpression * right = [NSExpression expressionForConstantValue:[NSNumber numberWithInt:5]];//创建比较谓词对象 这里设置为严格等于NSComparisonPredicate * pre = [NSComparisonPredicate predicateWithLeftExpression:left rightExpression:right modifier:NSDirectPredicateModifier type:NSEqualToPredicateOperatorType options:NSCaseInsensitivePredicateOption];NSArray * test = @[@\"sda\",@\"321\",@\"sf12\",@\"dsdwq1\",@\"swfas\"];NSArray * result = [test filteredArrayUsingPredicate:pre];//将打印@[@\"swfas\"]NSLog(@\"%@\",result); NSComparisonPredicateModifier用来进行条件的修饰设置，枚举如下： 12345typedef NS_ENUM(NSUInteger, NSComparisonPredicateModifier) &#123; NSDirectPredicateModifier = 0, //直接进行比较操作 NSAllPredicateModifier, //用于数组或集合 只有当内部所有元素都通过验证时 集合才算通过 NSAnyPredicateModifier //同于数组或集合 当内部有一个元素满足时 集合算通过验证&#125;; 关于NSAllPredicateModifier和NSAnyPredicateModifier，这两个枚举专门用于数组或集合类型对象的验证，ALL会验证其中所有元素，全部通过后数组或集合才算验证通过，ANY则只要有一个元素验证通过，数组或集合就算验证通过，例如： 12345NSPredicate * pre = [NSPredicate predicateWithFormat:@\"ALL length = 5\"];NSArray * test = @[@[@\"aaa\",@\"aa\"],@[@\"bbbb\",@\"bbbbb\"],@[@\"ccccc\",@\"ccccc\"]]; NSArray * result = [test filteredArrayUsingPredicate:pre]; //将打印@[@[@\"ccccc\",@\"ccccc\"]] NSLog(@\"%@\",result); NSPredicateOperatorType枚举用来设置运算符类型，如下： 12345678910111213141516typedef NS_ENUM(NSUInteger, NSPredicateOperatorType) &#123; NSLessThanPredicateOperatorType = 0, // 小于 NSLessThanOrEqualToPredicateOperatorType, // 小于等于 NSGreaterThanPredicateOperatorType, // 大于 NSGreaterThanOrEqualToPredicateOperatorType, // 大于等于 NSEqualToPredicateOperatorType, // 等于 NSNotEqualToPredicateOperatorType, //不等于 NSMatchesPredicateOperatorType, //正则比配 NSLikePredicateOperatorType, //Like匹配 与SQL类似 NSBeginsWithPredicateOperatorType, //左边的表达式 以右边的表达式作为开头 NSEndsWithPredicateOperatorType,//左边的表达式 以右边的表达式作为结尾 NSInPredicateOperatorType, // 左边的表达式 出现在右边的集合中 NSCustomSelectorPredicateOperatorType,//使用自定义的函数来进行 验证 NSContainsPredicateOperatorType, //左边的集合包括右边的元素 NSBetweenPredicateOperatorType //左边表达式的值在右边的范围中 例如 1 BETWEEN &#123; 0 , 33 &#125;&#125;; NSComparisonPredicateOptions枚举用来设置比较的方式，如下： 123456//如果不需要特殊指定 这个枚举值也可以传0typedef NS_OPTIONS(NSUInteger, NSComparisonPredicateOptions) &#123; NSCaseInsensitivePredicateOption = 0x01, //不区分大小写 NSDiacriticInsensitivePredicateOption = 0x02,//不区分读音符号 NSNormalizedPredicateOption //比较前进行预处理 代替上面两个选项&#125;; 2.NSExpression类NSExpression类则是提供创建表达式，下面列出了其中一些方便理解的方法： 12345678910111213141516//通过格式化字符串创建表达式+ (NSExpression *)expressionWithFormat:(NSString *)expressionFormat argumentArray:(NSArray *)arguments;+ (NSExpression *)expressionWithFormat:(NSString *)expressionFormat, ...;+ (NSExpression *)expressionWithFormat:(NSString *)expressionFormat arguments:(va_list)argList;//直接通过对象创建常亮的表达式+ (NSExpression *)expressionForConstantValue:(nullable id)obj; //创建变量表达式 验证时将从binding字典中进行替换+ (NSExpression *)expressionForVariable:(NSString *)string; //将多个表达式组合成一个+ (NSExpression *)expressionForAggregate:(NSArray&lt;NSExpression *&gt; *)subexpressions;+ (NSExpression *)expressionForUnionSet:(NSExpression *)left with:(NSExpression *)right;+ (NSExpression *)expressionForIntersectSet:(NSExpression *)left with:(NSExpression *)right;+ (NSExpression *)expressionForMinusSet:(NSExpression *)left with:(NSExpression *)right;+ (NSExpression *)expressionForSubquery:(NSExpression *)expression usingIteratorVariable:(NSString *)variable predicate:(NSPredicate *)predicate;//通过预定义的函数和参数数组来构建表达式对象 预定义的函数 可见dev开发文档+ (NSExpression *)expressionForFunction:(NSString *)name arguments:(NSArray *)parameters; 3.NSCompoundPredicate类这个类也是NSPredicate类的子类，其使用逻辑关系来组合多个谓词对象，解析如下： 123456789101112131415//进行对象初始化/*typedef NS_ENUM(NSUInteger, NSCompoundPredicateType) &#123; NSNotPredicateType = 0, //取非 NSAndPredicateType, //与运算 NSOrPredicateType, //或运算&#125;;*/- (instancetype)initWithType:(NSCompoundPredicateType)type subpredicates:(NSArray&lt;NSPredicate *&gt; *)subpredicates;//快速创建与运算+ (NSCompoundPredicate *)andPredicateWithSubpredicates:(NSArray&lt;NSPredicate *&gt; *)subpredicates;//快速创建或运算+ (NSCompoundPredicate *)orPredicateWithSubpredicates:(NSArray&lt;NSPredicate *&gt; *)subpredicates;//快速创建非运算+ (NSCompoundPredicate *)notPredicateWithSubpredicate:(NSPredicate *)predicate; 四、谓词的几种使用场景谓词主要用在验证对象，数组和集合的过滤。对象的验证前面有介绍，关于数据和集合的过滤函数，类别如下： 12345678910111213141516171819202122232425262728293031@interface NSArray&lt;ObjectType&gt; (NSPredicateSupport)//不可变数组使用过滤器后返回新数组- (NSArray&lt;ObjectType&gt; *)filteredArrayUsingPredicate:(NSPredicate *)predicate; @end@interface NSMutableArray&lt;ObjectType&gt; (NSPredicateSupport)//可变数组可以直接进行过滤操作- (void)filterUsingPredicate:(NSPredicate *)predicate;@end@interface NSSet&lt;ObjectType&gt; (NSPredicateSupport)//不可变集合过滤后返回新集合- (NSSet&lt;ObjectType&gt; *)filteredSetUsingPredicate:(NSPredicate *)predicate;@end@interface NSMutableSet&lt;ObjectType&gt; (NSPredicateSupport)//可变集合可以直接进行过滤操作- (void)filterUsingPredicate:(NSPredicate *)predicate;@end@interface NSOrderedSet&lt;ObjectType&gt; (NSPredicateSupport)- (NSOrderedSet&lt;ObjectType&gt; *)filteredOrderedSetUsingPredicate:(NSPredicate *)p;@end@interface NSMutableOrderedSet&lt;ObjectType&gt; (NSPredicateSupport)- (void)filterUsingPredicate:(NSPredicate *)p;@end 五、谓词的格式化语法总览下面列出了在谓词的格式化字符串规则语法。 | 语法规则 | 意义 || = | 左侧等于右侧 || == | 左侧等于右侧，与=一致 || &gt;= | 左侧大于等于右侧 || =&gt; | 左侧大于等于右侧 与 &gt;=一致 || &lt;= | 左侧小于等于右侧 || =&lt; | 左侧小于等于右侧 与&lt;=一致 || &gt; | 左侧大于右侧 || &lt; | 左侧小于右侧 || != | 左侧不等于右侧 || &lt;&gt; | 左侧不等于右侧 与!=一致 || BETWEEN | 左侧在右侧的集合中 key BETWEEN @[@1,@2] || TRUEPREDICATE | 总是返回YES的谓词 || FALSEPREDICATE | 总是返回NO的谓词 || AND | 逻辑与 || &amp;&amp; | 逻辑与 与AND一致 || OR | 逻辑或 || || | 逻辑或 与OR一致 || NOT | 逻辑非 || ! | 逻辑非 与NOT一致 || BEGINWITH | 左侧以右侧字符串开头 || ENDWITH | 左侧以右侧字符串结尾 || CONTAINS | 左侧集合包含右侧元素 || LIKE | 左侧等于右侧 并且 *和?等通配符可以使用 || MATCHES | 正则匹配 || ANY | 对于数组集合类，验证其中任一元素 || SOME | 同ANY一致 || ALL | 对于数组集合类，验证其中所有元素 || NONE | 作用等同于NOT (ANY) || IN | 左侧在右侧集合中 || SELF | 被验证的对象本身 |","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS高质量的动画实现解决方案——Lottie","slug":"365iOS高质量的动画实现解决方案——Lottie","date":"2018-02-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.376Z","comments":true,"path":"2018/02/11/365iOS高质量的动画实现解决方案——Lottie/","link":"","permalink":"http://huishao.cc/2018/02/11/365iOS高质量的动画实现解决方案——Lottie/","excerpt":"","text":"iOS高质量的动画实现解决方案——Lottie真心的认为Lottie是一款十分优秀且实用的动画开发库，不只对于iOS和android原生开发者来说其让复杂动画的实现几乎没有成本，对于设计师来说，它的所见即所得，不需导出帧图像等优势也十分明显。本篇博客主要以iOS平台为例，简单介绍和总结Lottie动画库的使用方式。 一、几个有用链接Lottie官网：https://airbnb.design/lottie/。 LottieFiles：https://www.lottiefiles.com/。 LottieFiles是一个在线的测试Lottie动画的网站，并且其上面也提供了许多常用的Lottie动画组件。 二、一个简单的小Demo先来看一个简单的小例子，我在LottieFiles上找了一个骑行动画的JSON文件，此文件的下载地址如下： https://www.lottiefiles.com/download/1385 这是一个比较炫酷的骑行动画，试想一下，如果使用GIF或帧动画来实现，需要素材的大小可能要远远超过136k。将下载的JSON文件添加到iOS项目中，之后就像使用图片一样的来使用它即可，代码如下： 12345678910111213141516171819#import &lt;Lottie/Lottie.h&gt;@interface ViewController ()@property(nonatomic,strong)LOTAnimationView * animationView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.animationView = [LOTAnimationView animationNamed:@\"go.json\"]; [self.view addSubview:self.animationView]; self.animationView.frame = CGRectMake(20, 30, 280, 200); self.animationView.loopAnimation = YES; [self.animationView play];&#125;@end 动画效果如下图： 无论是从流畅度还是性能上，动画效果都要比GIF图片好许多。 三、对Lottie库的应用解析首先LOTAnimationView类是显示Lottie动画的视图类，从源代码中看它是继承自LOTView，不要慌，这个LOTView并不是什么稀奇古怪的类，它其实就是为了代码统一，是UIView或NSView的别名而已。 如果你将动画直接拖入到主工程下面，那么可以直接使用动画JSON文件名来进行动画的创建，方法如下： 12//直接从mainBundle中加载素材+ (nonnull instancetype)animationNamed:(nonnull NSString *)animationName NS_SWIFT_NAME(init(name:)); 你也可以从自定义的Bundle或者使用其他方式来加载JSON文件： 123456789//从自定义的Bundle加载动画+ (nonnull instancetype)animationNamed:(nonnull NSString *)animationName inBundle:(nonnull NSBundle *)bundle NS_SWIFT_NAME(init(name:bundle:));//直接从JSON字典加载动画+ (nonnull instancetype)animationFromJSON:(nonnull NSDictionary *)animationJSON NS_SWIFT_NAME(init(json:));//直接通过JSON文件加载动画+ (nonnull instancetype)animationWithFilePath:(nonnull NSString *)filePath NS_SWIFT_NAME(init(filePath:));+ (nonnull instancetype)animationFromJSON:(nullable NSDictionary *)animationJSON inBundle:(nullable NSBundle *)bundle NS_SWIFT_NAME(init(json:bundle:));//从URL加载- (nonnull instancetype)initWithContentsOfURL:(nonnull NSURL *)url; 其实无论上面哪种方式加载动画，都是通过LOTComposition组件类实例化的，你也可以直接通过这个类来构建动画视图： 12345678910//常用的构造方法+ (nullable instancetype)animationNamed:(nonnull NSString *)animationName NS_SWIFT_NAME(init(name:));+ (nullable instancetype)animationNamed:(nonnull NSString *)animationName inBundle:(nonnull NSBundle *)bundle NS_SWIFT_NAME(init(name:bundle:));+ (nullable instancetype)animationWithFilePath:(nonnull NSString *)filePath NS_SWIFT_NAME(init(filePath:));+ (nonnull instancetype)animationFromJSON:(nonnull NSDictionary *)animationJSON NS_SWIFT_NAME(init(json:));+ (nonnull instancetype)animationFromJSON:(nullable NSDictionary *)animationJSON inBundle:(nullable NSBundle *)bundle NS_SWIFT_NAME(init(json:bundle:));- (instancetype _Nonnull)initWithJSON:(NSDictionary * _Nullable)jsonDictionary withAssetBundle:(NSBundle * _Nullable)bundle; JSON文件中包含的信息非常丰富，会与LOTComposition实例进行映射，例如动画的时长，起始帧和结束帧，宽高尺寸等。 构造出LOTAnimationView实例后，需要调用方法进行动画的播放，下面列出了LOTAnimationView中的常用属性与方法： 12345678910111213141516171819202122232425262728293031323334353637383940//获取动画是否正在播放@property (nonatomic, readonly) BOOL isAnimationPlaying;//设置动画是否循环播放@property (nonatomic, assign) BOOL loopAnimation;//设置动画是否自动逆序播放@property (nonatomic, assign) BOOL autoReverseAnimation;//设置是否缓存@property (nonatomic, assign) BOOL cacheEnable;//动画完成的回调block@property (nonatomic, copy, nullable) LOTAnimationCompletionBlock completionBlock;//组件实例@property (nonatomic, strong, nullable) LOTComposition *sceneModel;//从指定的进度位置播放动画- (void)playToProgress:(CGFloat)toProgress withCompletion:(nullable LOTAnimationCompletionBlock)completion;//播放指定区间内的动画- (void)playFromProgress:(CGFloat)fromStartProgress toProgress:(CGFloat)toEndProgress withCompletion:(nullable LOTAnimationCompletionBlock)completion;//播放到动画的某一帧- (void)playToFrame:(nonnull NSNumber *)toFrame withCompletion:(nullable LOTAnimationCompletionBlock)completion;//播放指定帧区间内的动画- (void)playFromFrame:(nonnull NSNumber *)fromStartFrame toFrame:(nonnull NSNumber *)toEndFrame withCompletion:(nullable LOTAnimationCompletionBlock)completion;//播放动画 可以设置回调- (void)playWithCompletion:(nullable LOTAnimationCompletionBlock)completion;//直接播放动画- (void)play;//暂停播放- (void)pause;//停止播放- (void)stop;//设置当前帧- (void)setProgressWithFrame:(nonnull NSNumber *)currentFrame;//设置某一帧对应的动画属性值- (void)setValue:(nonnull id)value forKeypath:(nonnull NSString *)keypath atFrame:(nullable NSNumber *)frame;","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"MJRefresh源码分析","slug":"364MJRefresh源码分析","date":"2018-01-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.376Z","comments":true,"path":"2018/01/30/364MJRefresh源码分析/","link":"","permalink":"http://huishao.cc/2018/01/30/364MJRefresh源码分析/","excerpt":"","text":"MJRefresh源码分析 每次读优秀的代码都是一次深刻的学习，每一次模仿，都是创造的开始！ ——QQ 316045346 欢迎交流 一、MJRefresh源码结构分析MJRefresh主要为UIScrollView，UITableView和UICollectionView添加头部和尾部刷新控件。其主要由3大块组成，类别工具，核心UIScrollView类别和头部尾部刷新组件。如下图： 二、工具类别上面示意图中列出的几个工具类别主要提供方便属性访问的功能。其主要是为了方便MJRefresh库自己的调用，当然你也可以对它进行使用。 UIView+MJExtension类别提供了对UIView组件位置和尺寸的快速访问方法，并且都支持快速获取和设置： 123456@property (assign, nonatomic) CGFloat mj_x;@property (assign, nonatomic) CGFloat mj_y;@property (assign, nonatomic) CGFloat mj_w;@property (assign, nonatomic) CGFloat mj_h;@property (assign, nonatomic) CGSize mj_size;@property (assign, nonatomic) CGPoint mj_origin; UIScrollView+MJExtension提供了对UIScrollView的内容尺寸，偏移量等属性的快速访问： 123456789101112@property (readonly, nonatomic) UIEdgeInsets mj_inset;@property (assign, nonatomic) CGFloat mj_insetT;@property (assign, nonatomic) CGFloat mj_insetB;@property (assign, nonatomic) CGFloat mj_insetL;@property (assign, nonatomic) CGFloat mj_insetR;@property (assign, nonatomic) CGFloat mj_offsetX;@property (assign, nonatomic) CGFloat mj_offsetY;@property (assign, nonatomic) CGFloat mj_contentW;@property (assign, nonatomic) CGFloat mj_contentH; NSBundle+MJRefresh这个类别提供对库中资源的访问方法： 123456+ (instancetype)mj_refreshBundle;//获取箭头图片+ (UIImage *)mj_arrowImage;//获取国际化字符串+ (NSString *)mj_localizedStringForKey:(NSString *)key value:(NSString *)value;+ (NSString *)mj_localizedStringForKey:(NSString *)key; 三、关于UIScrollView+MJRefresh这个类别是MJRefresh库的核心，其中提供的mj\\_header和mj\\_footer两个属性用来添加头部和尾部刷新组件。这两个组件是作为子视图添加在UIScrollView上的，因此和UIScrollView的原生头尾视图都不影响。在以前版本的MJRefresh中，使用的是header和footer属性，容易产生疑惑，因此后面版本框架中都添加了mj前缀。 UIScrollView+MJRefresh类别在开发者设置mj\\_header和mj\\_footer属性时，将这两个组件添加为当前滚动视图的最下层子视图，为了满足某些自动加载的需求，这里面有用runtime将UITableView和UICollectionView的reload函数进行替换，这样做的目的是为了在数据加载时统计界面的元素个数。 四、刷新组件MJRefreshComponent是刷新组件的基类，其中定了一些通用方法。首先，MJRefresh库的刷新组件核心思想是基于状态的，即通过状态来触发某些组件行为，例如正常的常态，下拉的pulling态，释放的refreshing态等等。开发者除了可以手动设置状态外，主要通过监听UIScrollView的偏移量等属性来改变状态。当UIScrollView有偏移量或内容尺寸的变化时，MJRefreshComponent会调用scrollViewContentOffsetDidChange函数，这个函数主要交给其子类实现。 MJRefreshHeader类是头部刷新组件的基类，其将刷新组件布局在UIScrollView组件的顶部，并且封装了记录上次刷新时间的功能。MJRefreshStateHeader提供了接口供开发者设置不同状态下刷新组件所显示的文字，MJRefreshNormalHeader是一个更加上层的头部刷新组件，其状态文字是默认定义好的，并且支持国际化。MJRefreshGifHeader可以支持显示自定义刷新动画，其可以为某个状态设置一组图片。 尾部刷新组件的编写逻辑和头部刷新组件的编写逻辑基本一致，MJRefresh中的尾部刷新组件分为了两类，一类是刷新完成后自动消失的，一类是自动刷新，刷新完成后不会自动消失，只是改变状态。MFRefreshFooter与MJRefreshHeader的实现基本一致，MJRefreshBackFooter有刷新完成后自动还原的功能，MJRefreshBackNormalFooter是比较上层的封装，其显示默认的状态文案，并且支持国际化。MJRefreshBackStateFooter则可以手动设置不同状态下刷新组件显示的文字。MJRefreshBackGifFooter用来显示自定义动画的尾部刷新组件。MJRefreshAutoFooter是自动尾部刷新组件的基类，其可以设置当尾部刷新组件出现多少比例时进行刷新(默认是完全出现后进行刷新)。MJRefreshAutoStateFooter可以自定义其各个状态的文案。同样，也有比较上层的MJRefreshAotuNormalFooter组件，这个组件封装好了国际化的文案可以直接使用，MJRefreshAutoGifFooter组件可以显示自定动画的尾部刷新。 五、MJRefresh中的编程风格技巧与小亮点1.复用，复用，再复用之所以看MJRefresh库的代码非常舒服，很大一部分源自其深入的复用。首先MJRefreshComponent类抽象出了回调与刷新函数，并且提取出了需要子类复写的通用的布局、监听等函数，让子类的结构非常统一。MJRefreshHeader和MJRefreshFooter作为头部与尾部刷新组件的基类，抽象出了构造函数，并且实现了大部分组件与外部的布局，逻辑动作等函数。再子类则专注与实现子类自身的UI与功能。还有一个小细节，也可以看出MJRefresh对复用的追求，在setState函数的实现中，如果新的状态与旧的状态一致，则不需要做任何逻辑，所有的setState函数都需要这个逻辑，MJRefresh中采用的宏的方式进行替换，使代码变得十分简洁，示例如下： 1234567891011121314#define MJRefreshCheckState \\MJRefreshState oldState = self.state; \\if (state == oldState) return; \\[super setState:state];///////////- (void)setState:(MJRefreshState)state&#123; MJRefreshCheckState // 设置状态文字 self.stateLabel.text = self.stateTitles[@(state)];&#125; 2.另一种安全执行block的方式很多时候，我们在执行block的时候都会先检查下这个block是否为nil，下面是我们常用的代码： 123if (block) &#123; block();&#125; 在MJRefresh中有使用问号冒号的方式来代替if语句，如下： 1234- (void)executeReloadDataBlock&#123; ! self.mj_reloadDataBlock ? : self.mj_reloadDataBlock(self.mj_totalDataCount);&#125; 这个表达式初看会有一些疑惑，其实?:的作用是返回一个值，如果?:前的表达式为nil的话，则会返回?:后面的值，同样，如果?:前面的表达式不为nil的话，则直接返回，不会执行到后面的表达式，上面的写法其实和第一种if语句的作用完全一致。","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"SDWebImage源码分析","slug":"363SDWebImage源码分析","date":"2017-12-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.376Z","comments":true,"path":"2017/12/29/363SDWebImage源码分析/","link":"","permalink":"http://huishao.cc/2017/12/29/363SDWebImage源码分析/","excerpt":"","text":"SDWebImage源码分析 每次读优秀的代码都是一次深刻的学习，每一次模仿，都是创造的开始！ ——QQ 316045346 欢迎交流 SDWebImage是iOS开发中非常流行的一个网络图片加载库，如果你观察其源码，会发现其中的文件非常多，虽然文件数很多，但是作者的代码结构和条理却是非清晰。SDWebImage的代码结构基本可以分为3块：应用层类别、核心功能类、工具类与类别。其中我们最常使用的是应用层的类别。例如UIImageView的图片加载，UIButton的图片加载等。 一、帮助类与类别的解析1.NSData+ImageContentType这个类别是一个图片数据的格式帮助类，使用它可以方便的获取图片数据的图片格式，其中枚举了常用的图片格式如下： 123456789typedef NS_ENUM(NSInteger, SDImageFormat) &#123; SDImageFormatUndefined = -1, //未知格式 SDImageFormatJPEG = 0, //jpeg SDImageFormatPNG, //png SDImageFormatGIF, //gif SDImageFormatTIFF, //tiff SDImageFormatWebP, //webp SDImageFormatHEIC //heic&#125;; 其原理是根据图片数据的第1个字节码进行分析，不同格式的图像数据在开头都会有一部分的用来表明图像信息的数据块，通过它可以获取图片的具体格式。这个类别中只提供了两个方法： 1234//获取图像数据格式+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data;//将SDImageFormat转换成CFStringRef+ (nonnull CFStringRef)sd_UTTypeFromSDImageFormat:(SDImageFormat)format; 2、SDWebImageFrame这个类是SDWebImage中封装的图像帧类，主要用来创建动画图像。 123456//当前帧图像@property (nonatomic, strong, readonly, nonnull) UIImage *image;//时间@property (nonatomic, readonly, assign) NSTimeInterval duration;//初始化方法+ (instancetype _Nonnull)frameWithImage:(UIImage * _Nonnull)image duration:(NSTimeInterval)duration; 3.UIImage的编码与解码SDWebImageCoder中定义了一个协议，其中约定了方法来对图像数据进行解码与编码，实现这个协议的主要有SDWebImageIOCoder和SDWebImageGIFCoder。 12345678910111213141516//数据是否可以进行解码 除了webp类型的 其他类型的图像都可以解码- (BOOL)canDecodeFromData:(nullable NSData *)data;//进行图片数据解码- (nullable UIImage *)decodedImageWithData:(nullable NSData *)data;//进行增量解码- (nullable UIImage *)decompressedImageWithImage:(nullable UIImage *)image data:(NSData * _Nullable * _Nonnull)data options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict;//获取此类型图像是否可以编码- (BOOL)canEncodeToFormat:(SDImageFormat)format;//将图片编码为数据- (nullable NSData *)encodedDataWithImage:(nullable UIImage *)image format:(SDImageFormat)format;//获取此图像数据是否可以增量解码- (BOOL)canIncrementallyDecodeFromData:(nullable NSData *)data;//进行增量解码- (nullable UIImage *)incrementallyDecodedImageWithData:(nullable NSData *)data finished:(BOOL)finished; 4.图像数据预加载SDWebImagePrefetcher类提供了图像数据的预加载功能，在进行用户体验优化，需要预加载某些常态图像时，可以用使用这个类。 123456789101112131415161718@interface SDWebImagePrefetcher : NSObject//管理中心@property (strong, nonatomic, readonly, nonnull) SDWebImageManager *manager;//设置最大的同时下载数@property (nonatomic, assign) NSUInteger maxConcurrentDownloads;//配置 枚举 设置优先级等@property (nonatomic, assign) SDWebImageOptions options;//单例对象+ (nonnull instancetype)sharedImagePrefetcher;//构造方法- (nonnull instancetype)initWithImageManager:(nonnull SDWebImageManager *)manager NS_DESIGNATED_INITIALIZER;//进行预下载- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls;- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock;//取消预下载行为- (void)cancelPrefetching; SDWebImagePrefetcher还提供了代理来对预下载过程进行监听，如下： 1234//当一张图片被下载完后调用- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didPrefetchURL:(nullable NSURL *)imageURL finishedCount:(NSUInteger)finishedCount totalCount:(NSUInteger)totalCount;//与下载任务全部结束后调用- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didFinishWithTotalCount:(NSUInteger)totalCount skippedCount:(NSUInteger)skippedCount; 二、核心功能SDWebImage的核心功能类结构如下图所示： 1.缓存管理类SDImageCacheSDImageCache类负责所有网络图片数据的缓存，其从逻辑上分为两级缓存，内存缓存和硬盘缓存。开发者可以使用单例方法来获取默认的SDImageCache实例，也可以使用特殊的Name值来创建缓存实例，常用函数列举如下： 12345678910111213141516171819202122232425262728293031323334//缓存图片到内存和磁盘- (void)storeImage:(nullable UIImage *)image forKey:(nullable NSString *)key completion:(nullable SDWebImageNoParamsBlock)completionBlock;//缓存图片到磁盘- (void)storeImage:(nullable UIImage *)image forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock;- (void)storeImage:(nullable UIImage *)image imageData:(nullable NSData *)imageData forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock;- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key;//异步检查磁盘缓存是否存在- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;//检查内存缓存是否存在- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key;//获取磁盘缓存数据- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key;//获取内存和磁盘缓存数据- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key;//异步删除缓存- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion;- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion;//清除所有内存缓存- (void)clearMemory;//删除所有过期数据- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;//获取磁盘缓存大小- (NSUInteger)getSize;//获取磁盘缓存图片数- (NSUInteger)getDiskCount; SDImageCacheConfig用来对缓存进行配置，如下： 123456//是否允许缓存到内存@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;//缓存生命@property (assign, nonatomic) NSInteger maxCacheAge;//最大缓存容量@property (assign, nonatomic) NSUInteger maxCacheSize; 2.下载器SDWebImageDownloaderSDWebImageDownloader提供对图片下载的支持管理，其可以配置同时最大下载数量，下载超时等： 12345678910111213141516171819202122232425//同时最大下载数量@property (assign, nonatomic) NSInteger maxConcurrentDownloads;//当前正在下载的任务数量@property (readonly, nonatomic) NSUInteger currentDownloadCount;//设置超时时间@property (assign, nonatomic) NSTimeInterval downloadTimeout;//证书@property (strong, nonatomic, nullable) NSURLCredential *urlCredential;//用户名@property (strong, nonatomic, nullable) NSString *username;//密码@property (strong, nonatomic, nullable) NSString *password;//设置请求头- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(nullable NSString *)field;//获取请求头- (nullable NSString *)valueForHTTPHeaderField:(nullable NSString *)field;//开始下载任务- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;//取消下载任务- (void)cancel:(nullable SDWebImageDownloadToken *)token;//取消所有下载任务- (void)cancelAllDownloads; 三、应用类别1.UIButton+WebCache这个类别用来对按钮设置网络图片。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//当前状态的图片URL- (nullable NSURL *)sd_currentImageURL;//获取指定状态的图片URL- (nullable NSURL *)sd_imageURLForState:(UIControlState)state;//为某个状态设置网络图片- (void)sd_setImageWithURL:(nullable NSURL *)url forState:(UIControlState)state;- (void)sd_setImageWithURL:(nullable NSURL *)url forState:(UIControlState)state placeholderImage:(nullable UIImage *)placeholder;- (void)sd_setImageWithURL:(nullable NSURL *)url forState:(UIControlState)state placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options;- (void)sd_setImageWithURL:(nullable NSURL *)url forState:(UIControlState)state completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url forState:(UIControlState)state placeholderImage:(nullable UIImage *)placeholder completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url forState:(UIControlState)state placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options completed:(nullable SDExternalCompletionBlock)completedBlock;//下面这些方法设置按钮的背景图- (nullable NSURL *)sd_currentBackgroundImageURL;- (nullable NSURL *)sd_backgroundImageURLForState:(UIControlState)state;- (void)sd_setBackgroundImageWithURL:(nullable NSURL *)url forState:(UIControlState)state;- (void)sd_setBackgroundImageWithURL:(nullable NSURL *)url forState:(UIControlState)state placeholderImage:(nullable UIImage *)placeholder;- (void)sd_setBackgroundImageWithURL:(nullable NSURL *)url forState:(UIControlState)state placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options;- (void)sd_setBackgroundImageWithURL:(nullable NSURL *)url forState:(UIControlState)state completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setBackgroundImageWithURL:(nullable NSURL *)url forState:(UIControlState)state placeholderImage:(nullable UIImage *)placeholder completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setBackgroundImageWithURL:(nullable NSURL *)url forState:(UIControlState)state placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options completed:(nullable SDExternalCompletionBlock)completedBlock;//取消图片下载- (void)sd_cancelImageLoadForState:(UIControlState)state;- (void)sd_cancelBackgroundImageLoadForState:(UIControlState)state; 2.UIImageView+WebCache与UIImageView+HighlightedWebCache这两个类别的作用都是对UIImageView实例进行图片设置，分别设置正常状态的图片和高亮状态的图片。只举例UIImageView+WebCache中方法如下： 123456789101112131415161718192021222324252627282930//设置网络图片- (void)sd_setImageWithURL:(nullable NSURL *)url;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options;- (void)sd_setImageWithURL:(nullable NSURL *)url completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock;- (void)sd_setImageWithPreviousCachedImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock;//对一组url进行下载并以动画方式显示- (void)sd_setAnimationImagesWithURLs:(nonnull NSArray&lt;NSURL *&gt; *)arrayOfURLs;//取消当前图片下载- (void)sd_cancelCurrentAnimationImagesLoad; 关于SDWebImageOptions，它是一个配置枚举： 12345678910111213141516171819202122232425typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; //配置这个参数下载失败的url将会重试下载 SDWebImageRetryFailed = 1 &lt;&lt; 0, //低优先级 SDWebImageLowPriority = 1 &lt;&lt; 1, //仅仅进行内存缓存 SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, //进行分步下载 SDWebImageProgressiveDownload = 1 &lt;&lt; 3, //刷新缓存 SDWebImageRefreshCached = 1 &lt;&lt; 4, //支持后台 SDWebImageContinueInBackground = 1 &lt;&lt; 5, //保持cookie SDWebImageHandleCookies = 1 &lt;&lt; 6, //允许证书 SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, //高优先级 SDWebImageHighPriority = 1 &lt;&lt; 8, //配置此参数 当图片加载结束后才会显示placeholder SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, //执行图片变换 SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12&#125;;","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"从AFNetworking源码分析到应用全解","slug":"362从AFNetworking源码分析到应用全解","date":"2017-11-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.375Z","comments":true,"path":"2017/11/24/362从AFNetworking源码分析到应用全解/","link":"","permalink":"http://huishao.cc/2017/11/24/362从AFNetworking源码分析到应用全解/","excerpt":"","text":"从AFNetworking源码分析到应用全解一、引言AFNetworking是iOS/OS开发中常用的一个第三方网络库，可以说它是目前最流行的网络库，但其代码结构其实并不复杂，也可以说非常简洁优美。在AFNetworking中，大量使用的线程安全的开发技巧，读此源码也是一次很好的多线程学习机会。本篇博客从主要结构和网络请求的主流程进行分享，解析了AFNetworking的设计思路与工作原理，后面还有其中提供的UI扩展包的接口应用总结。 每次读优秀的代码都是一次深刻的学习，每一次模仿，都是创造的开始！ 二、核心源码分析平时我们在使用AFNetworking框架时，大多只使用其中的请求管理功能。其实，这个有名的框架中还提供了许多其他的工具，除了可以方便的进行网络安全验证，请求数据与回执数据的序列化，网络状态茶台等基础应用外，还提供了UIKit工具包，其中提供有常用组件的扩展，图片下载器和缓存器等。 对于AFNetworking框架的核心，无非AFURLSesstionManager类，这个类是基于系统的NSURLSesstion回话类进行的管理者包装，下图是AF框架一个整体的结构。 把握这个结构，我们再来学习AF框架将变得十分容易上手，打开AFURLSesstionManager类，你会发现它有1200多行代码，但是AFURLSesstionManager类真正的实现确实从500多行开始的，之前的代码是内部的代理处理类，就像在MVVM模式中，我们总是喜欢将控制器的逻辑放入View-Model中一样，AFURLSesstionManager实例也会将通知，回调等操作交给这个代理实例处理。 1.AFURLSesstionManager首先先来看AFURLSesstionManager类的初始化方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; if (!configuration) &#123; //使用默认 configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; //代理方法执行做在的操作队列 self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; //创建sesstion会话 self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; //默认将返回数据按照json进行解析 self.responseSerializer = [AFJSONResponseSerializer serializer]; //使用默认的安全验证 self.securityPolicy = [AFSecurityPolicy defaultPolicy];#if !TARGET_OS_WATCH //使用默认的网络状态监测 self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];#endif //每一个请求任务都对应有一个delegate 存在这里面 self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; //初始化锁 self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; //下面的做法是为了防止 被修改了sesstion的系统实现有初始任务 [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; for (NSURLSessionDataTask *task in dataTasks) &#123; [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; &#125; for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123; [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; &#125; for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123; [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; &#125; &#125;]; return self;&#125; 用AFURLSesstionManager创建请求任务有三类，当然也对应NSURLSesstion中的数据请求任务，上传任务和下载任务。我们以数据请求任务为例，核心方法如下： 123456789101112131415- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler &#123; __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^&#123; //创建任务 dataTask = [self.session dataTaskWithRequest:request]; &#125;); //进行代理设置 [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask;&#125; 上传任务和下载任务的创建源码和上面大同小异，只是创建出的任务类型不同，它们都要进行下一步代理的设置，还以数据请求任务的代理设置为例，源码如下： 12345678910111213141516- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler&#123; //创建内部代理 AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init]; delegate.manager = self; delegate.completionHandler = completionHandler; dataTask.taskDescription = self.taskDescriptionForSessionTasks; //设置代理 [self setDelegate:delegate forTask:dataTask]; delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock;&#125; 需要注意，原生的NSURLSesstionTask的代理其实依然是AFURLSesstionManager类自身，这里Manager作为中介来进行方法的传递(它也会自己处理一些回调，与开发者相关的回调才会转给内部代理处理)。 上面的流程就是AFURLSesstionManager创建的任务的主流程了，需要注意，它只创建出任务并不会执行，需要开发者手动调用resume才能激活任务。下面的流程就是系统的NSURLSesstionTaskDelagate相关的回调了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186//接收到URL重定向时回调- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskwillPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest *))completionHandler&#123; NSURLRequest *redirectRequest = request; //这里会执行用户自定义的重定向block if (self.taskWillPerformHTTPRedirection) &#123; redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request); &#125; //继续重定向后的请求 if (completionHandler) &#123; completionHandler(redirectRequest); &#125;&#125;//接收到安全认证挑战的回调- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler&#123; NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; //如果开发者有提供block 交开发者处理 否则用默认的安全验证方案处理 if (self.taskDidReceiveAuthenticationChallenge) &#123; disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential); &#125; else &#123; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; disposition = NSURLSessionAuthChallengeUseCredential; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; if (completionHandler) &#123; completionHandler(disposition, credential); &#125;&#125;//需要提供数据流传向服务器时调用- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler&#123; NSInputStream *inputStream = nil; if (self.taskNeedNewBodyStream) &#123; inputStream = self.taskNeedNewBodyStream(session, task); &#125; else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) &#123; inputStream = [task.originalRequest.HTTPBodyStream copy]; &#125; if (completionHandler) &#123; completionHandler(inputStream); &#125;&#125;//已经发送数据后调用- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; int64_t totalUnitCount = totalBytesExpectedToSend; if(totalUnitCount == NSURLSessionTransferSizeUnknown) &#123; NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@\"Content-Length\"]; if(contentLength) &#123; totalUnitCount = (int64_t) [contentLength longLongValue]; &#125; &#125; if (self.taskDidSendBodyData) &#123; self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount); &#125;&#125;//请求任务完成时回调- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123; //拿到内部代理 交给它处理 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) &#123; [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; &#125; if (self.taskDidComplete) &#123; self.taskDidComplete(session, task, error); &#125;&#125;//接收到返回数据时回调- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler&#123; NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; if (self.dataTaskDidReceiveResponse) &#123; disposition = self.dataTaskDidReceiveResponse(session, dataTask, response); &#125; if (completionHandler) &#123; completionHandler(disposition); &#125;&#125;//此请求将要变更成下载任务时回调- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask&#123; //重新设置内部代理 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; if (delegate) &#123; [self removeDelegateForTask:dataTask]; [self setDelegate:delegate forTask:downloadTask]; &#125; if (self.dataTaskDidBecomeDownloadTask) &#123; self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask); &#125;&#125;//开始获取数据时调用- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; //交给内部代理处理 AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask]; [delegate URLSession:session dataTask:dataTask didReceiveData:data]; if (self.dataTaskDidReceiveData) &#123; self.dataTaskDidReceiveData(session, dataTask, data); &#125;&#125;//将要缓存回执数据时调用- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask willCacheResponse:(NSCachedURLResponse *)proposedResponse completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler&#123; NSCachedURLResponse *cachedResponse = proposedResponse; if (self.dataTaskWillCacheResponse) &#123; cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse); &#125; if (completionHandler) &#123; completionHandler(cachedResponse); &#125;&#125;//下载任务结束后回调- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask]; if (self.downloadTaskDidFinishDownloading) &#123; NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); if (fileURL) &#123; delegate.downloadFileURL = fileURL; NSError *error = nil; //数据位置移动 [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error]; if (error) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo]; &#125; return; &#125; &#125; //内部代理进行后续处理 if (delegate) &#123; [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location]; &#125;&#125; 到此，AFURLSesstionManager类的任务基本完成，头文件中的接口更多提供了上述回调的设置还有些通知的发送。下面我们要来看下内部代理AFURLSesstionManagerTaskDelegate类的作用，需要注意AFURLSesstionManagerTaskDelegate是一个类，并不是协议，其除了处理上面介绍的Manager转发过来的回到外，还会进行请求进度的控制。其配置方法和一些监听这里不再过多介绍，主要来看其对Manager转发过来的回到的处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//接收到数据后 将数据进行拼接- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; [self.mutableData appendData:data];&#125;//请求完成后- (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)taskdidCompleteWithError:(NSError *)error&#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wgnu\" __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; //配置一个信息字典 __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //拿到请求结果数据 NSData *data = nil; if (self.mutableData) &#123; data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; &#125; //下载信息配置 if (self.downloadFileURL) &#123; userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; &#125; else if (data) &#123; userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; &#125; //错误信息配置 if (error) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, error); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125; else &#123; dispatch_async(url_session_manager_processing_queue(), ^&#123; NSError *serializationError = nil; //用回执数据序列化类进行数据处理 responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; if (self.downloadFileURL) &#123; responseObject = self.downloadFileURL; &#125; if (responseObject) &#123; userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; &#125; if (serializationError) &#123; userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; &#125; dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; if (self.completionHandler) &#123; self.completionHandler(task.response, responseObject, serializationError); &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; &#125;); &#125;); &#125;); &#125;#pragma clang diagnostic pop&#125;//下载处理- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; NSError *fileManagerError = nil; self.downloadFileURL = nil; if (self.downloadTaskDidFinishDownloading) &#123; self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); if (self.downloadFileURL) &#123; [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError]; if (fileManagerError) &#123; [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo]; &#125; &#125; &#125;&#125; 2.AFHTTPSesstionManager了解了AFURLSesstionManager，学习AFHTTPSesstionManager将十分轻松，这个类只是前者面向应用的一层封装。我们可以先从它的接口看起，这也是开发者最熟悉和常用的部分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@interface AFHTTPSessionManager : AFURLSessionManager &lt;NSSecureCoding, NSCopying//基础URL@property (readonly, nonatomic, strong, nullable) NSURL *baseURL;//请求序列化对象@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;//回执序列化对象@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;//创建一个默认的Manager实例 注意不是单例+ (instancetype)manager;//初始化方法- (instancetype)initWithBaseURL:(nullable NSURL *)url;- (instancetype)initWithBaseURL:(nullable NSURL *)url sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;//进行get请求- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;//进行HEAD请求- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;//进行POST请求- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;//进行PUT请求- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;//进行PATCH请求- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;//进行DELETE请求- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString parameters:(nullable id)parameters success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure; 上面所有的请求，一旦创建就会自动resume，开发则不需要额外开启。 3.请求序列化AFURLRequestSerializationAFURLRequestSerialization是一个协议，它的作用其实就是来将请求进行配置，其中只定义了一个接口： 1234567@protocol AFURLRequestSerialization &lt;NSObject, NSSecureCoding, NSCopying&gt;//将请求和参数进行配置后返回- (nullable NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(nullable id)parameters error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;@end 实现这个接口的类主要是AFHTTPRequestSerizlizaer类，其还有两个子类，分别为AFJSONRequestSerizlizaer和AFPropertyListRequestSerializer类。 在使用AFNetworking进行网络请求时，如果你有过抓包，你一定会发现，在发送的普通HTTP请求的HEAD中默认包含了许多信息，其实这些都是AFHTTPRequestSerizlizaer类做的，他默认会向请求头中添加Accept-Language，User-Agent以及其他可配置的头部信息(缓存，Cookie，超时时间，用户名密码等)。在进行请求参数配置的时候，AFHTTPRequestSerizlizaer会根据请求方法来选择配置到url后面或者添加到请求body中(HEAD，DELETE，GET会追加URL，其他添加body)。AFJSONRequestSerizlizaer的作用与AFHTTPRequestSerizlizaer一致，不同的是会将请求头中的Content-Type设置为application/json并且将参数格式化成JSON数据放置在请求体中，AFPropertyListRequestSerializer类则是将Content-Type设置为application/x-plist，并且将参数格式化成Plist数据放入请求体。 4.回执数据序列化AFURLResponseSerializationAFNetworking进行网络请求有一个十分方便的地方在于它可以直接将返回数据进行解析。其中AFHTTPResponseSerializer是最基础的解析类，它只会根据返回头信息来校验返回数据的有效性，整理后直接将原数据返回。AFJSONResponseSerializer类用来解析返回数据为JSON数据的回执，用这个类进行解析时，返回头信息中的MIMEType必须为application/json，text/json或text/javascript。AFXMLParserResponseSerializer类用来解析XML数据，其会返回一个XML解析器，使用它时，返回头信息中的MIMEType必须为application/xml或text/xml。AFXMLDocumentResponseSerializer类将返回数据解析成XML文档。AFPropertyListResponseSerializer用来将返回数据解析成Plist数据。AFImageResponseSerializer类用来将返回数据解析成UIImage图片，其支持的MIMEType类型为image/tiff，image/jpeg，image/gif，image/png，image/ico，image/x-icon，image/bmp，image/x-bmp，image/x-xbitmap，image/x-win-bitmap。 除了上面列出的这些类外，还有一个AFCompoundResponseSerializer类，这个类示例中可以配置多个ResponseSerializer实例，解析的时候会进行遍历尝试找到可以解析的模式，这种模式也叫混合解析模式。 三、UI工具包源码分析1.AFAutoPurgingImageCache图片缓存源码分析AFAutoPurgingImageCache类是AF框架中提供的图片缓存器，需要注意，它并不是一个持久化的缓存工具，只做临时性的缓存。其中封装了自动清缓存和按时间命中的逻辑。 每一个AFAutoPurgingImageCache类实例中都有一个缓存池，缓存池有两个临界值，最大容量与期望容量。当实际使用的内存超过最大容量时，缓存池会自动清理到期望容量。在缓存池中，存放的实际上是AFCacheImage对象，这个内部类对UIImage进行了包装，如下： 123456789101112@interface AFCachedImage : NSObject//关联的UIImage@property (nonatomic, strong) UIImage *image;//id@property (nonatomic, strong) NSString *identifier;//图片大小@property (nonatomic, assign) UInt64 totalBytes;//最后使用时间@property (nonatomic, strong) NSDate *lastAccessDate;//这个属性没有使用到@property (nonatomic, assign) UInt64 currentMemoryUsage;@end 清缓存的逻辑十分简单，这里就不做代码解析，流程是每次进行图片缓存时，判断是否超出缓存池最大容量，如果超出，将AFCacheImage对象按照lastAccessDate属性进行排序后进行按顺序删除直到到达期望容量。当收到系统的内存警告时，也会唤起清除内存操作。 2.AFImageDownloader图片下载器源码解析AFImageDownloader类专门用来下载图片，其但单独的线程的进行图片的下载处理，并且内置了多任务挂起等待和图片数据缓存的特性。AFImageDownloder类的核心有两个线程： 12@property (nonatomic, strong) dispatch_queue_t synchronizationQueue;@property (nonatomic, strong) dispatch_queue_t responseQueue; 其中synchronizationQueue是一个同步线程，用来创建与开始下载任务，也可以理解这个串行线程为这个下载器类的主要代码执行所在的线程，responseQueue是一个并行线程，其用来当请求完成后处理数据。默认情况下，下载器可以同时下载4张图片，如果图片的请求大于4，多出的请求会被暂时挂起，等待其他请求完成在进行激活。其核心流程如下图所示： 如上图所示，AFImageDownloader类中有大量的操作任务池和修改激活任务数的操作，为了保证数据的安全，这也就是为何AFImageDownloader的主题操作要在其自建的串行线程中执行。核心方法代码解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117- (nullable AFImageDownloadReceipt *)downloadImageForURLRequest:(NSURLRequest *)request withReceiptID:(nonnull NSUUID *)receiptID success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *responseObject))success failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure &#123; __block NSURLSessionDataTask *task = nil; //在串行线程中执行 dispatch_sync(self.synchronizationQueue, ^&#123; //取当前图片的url作为标识 NSString *URLIdentifier = request.URL.absoluteString; //检查url的可用性 if (URLIdentifier == nil) &#123; if (failure) &#123; NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorBadURL userInfo:nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; failure(request, nil, error); &#125;); &#125; return; &#125; //检查任务池中是否已经有此任务 AFImageDownloaderMergedTask *existingMergedTask = self.mergedTasks[URLIdentifier]; if (existingMergedTask != nil) &#123; //已经存在此任务 则追加回调 之后返回 这样做的目的是 先后两次对相同图片的请求 可以只进行一次请求，并且执行不同的两次回调 AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure]; [existingMergedTask addResponseHandler:handler]; task = existingMergedTask.task; return; &#125; //进行缓存的检查 switch (request.cachePolicy) &#123; case NSURLRequestUseProtocolCachePolicy: case NSURLRequestReturnCacheDataElseLoad: case NSURLRequestReturnCacheDataDontLoad: &#123; UIImage *cachedImage = [self.imageCache imageforRequest:request withAdditionalIdentifier:nil]; if (cachedImage != nil) &#123; if (success) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; success(request, nil, cachedImage); &#125;); &#125; return; &#125; break; &#125; default: break; &#125; //创建数据请求任务 NSUUID *mergedTaskIdentifier = [NSUUID UUID]; NSURLSessionDataTask *createdTask; __weak __typeof__(self) weakSelf = self; createdTask = [self.sessionManager dataTaskWithRequest:request completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; dispatch_async(self.responseQueue, ^&#123; __strong __typeof__(weakSelf) strongSelf = weakSelf; AFImageDownloaderMergedTask *mergedTask = self.mergedTasks[URLIdentifier]; if ([mergedTask.identifier isEqual:mergedTaskIdentifier]) &#123; mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier]; if (error) &#123; for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) &#123; if (handler.failureBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; handler.failureBlock(request, (NSHTTPURLResponse*)response, error); &#125;); &#125; &#125; &#125; else &#123; [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil]; for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) &#123; if (handler.successBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; handler.successBlock(request, (NSHTTPURLResponse*)response, responseObject); &#125;); &#125; &#125; &#125; &#125; [strongSelf safelyDecrementActiveTaskCount]; [strongSelf safelyStartNextTaskIfNecessary]; &#125;); &#125;]; //创建处理回调 AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure]; //创建图片任务 追加回调 AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc] initWithURLIdentifier:URLIdentifier identifier:mergedTaskIdentifier task:createdTask]; [mergedTask addResponseHandler:handler]; self.mergedTasks[URLIdentifier] = mergedTask; //进行激活或挂起数据请求任务 if ([self isActiveRequestCountBelowMaximumLimit]) &#123; [self startMergedTask:mergedTask]; &#125; else &#123; [self enqueueMergedTask:mergedTask]; &#125; task = mergedTask.task; &#125;); if (task) &#123; //将回执返回 用来取消任务 return [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task]; &#125; else &#123; return nil; &#125;&#125; 3.UIImageView与UIButton两个类别的设计分析UIImageView+AFNetworking类别与UIButton+AFNetworking类别是AF中提供了两个加载网络图片的工具类别。这两个类别都为其实例对象关联了一个图片下载器，开发者可以自定义这个下载器也可以使用默认提供的，例如： 1234567891011+ (AFImageDownloader *)sharedImageDownloader &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wgnu\" return objc_getAssociatedObject(self, @selector(sharedImageDownloader)) ?: [AFImageDownloader defaultInstance];#pragma clang diagnostic pop&#125;+ (void)setSharedImageDownloader:(AFImageDownloader *)imageDownloader &#123; objc_setAssociatedObject(self, @selector(sharedImageDownloader), imageDownloader, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; 虽然头文件中提供了多个设置图片的接口方法，但实际核心方法只有一个，其他方法都是基于这个核心方法时候封装的遍历方法，以UIImageView类别为例，UIButton类别也类似，如图： 进行网络图片设置的过程如下图： 核心方法代码分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest placeholderImage:(UIImage *)placeholderImage success:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success failure:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure&#123; //检查请求是否合法 if ([urlRequest URL] == nil) &#123; [self cancelImageDownloadTask]; self.image = placeholderImage; return; &#125; //检查此请求是否正在进行中 if ([self isActiveTaskURLEqualToURLRequest:urlRequest])&#123; return; &#125; //取消当前UI组件的下载任务 [self cancelImageDownloadTask]; //拿到图片下载器 AFImageDownloader *downloader = [[self class] sharedImageDownloader]; //拿到缓存器 id &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache; //检查缓存图片是否存在 UIImage *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:nil]; if (cachedImage) &#123; if (success) &#123; success(urlRequest, nil, cachedImage); &#125; else &#123; self.image = cachedImage; &#125; [self clearActiveDownloadInformation]; &#125; else &#123; if (placeholderImage) &#123; self.image = placeholderImage; &#125; __weak __typeof(self)weakSelf = self; //取一个随机的UUID作为标志 NSUUID *downloadID = [NSUUID UUID]; //任务控制对象 AFImageDownloadReceipt *receipt; receipt = [downloader downloadImageForURLRequest:urlRequest withReceiptID:downloadID success:^(NSURLRequest * _Nonnull request, NSHTTPURLResponse * _Nullable response, UIImage * _Nonnull responseObject) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; //检查当前的任务id和请求的任务id是否一致 if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123; if (success) &#123; success(request, response, responseObject); &#125; else if(responseObject) &#123; strongSelf.image = responseObject; &#125; //清空任务信息 [strongSelf clearActiveDownloadInformation]; &#125; &#125; failure:^(NSURLRequest * _Nonnull request, NSHTTPURLResponse * _Nullable response, NSError * _Nonnull error) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123; if (failure) &#123; failure(request, response, error); &#125; [strongSelf clearActiveDownloadInformation]; &#125; &#125;]; //存储任务控制对象 self.af_activeImageDownloadReceipt = receipt; &#125;&#125; 4.AFNetworkActivityIndicatorManager类设计解析AFNetworkActivityIndicatorManager类用来管理系统在状态栏上的指示器显示或隐藏。系统状态栏上的指示器提供的接口非常简单，只有一个： 1[[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES]; 上面方法的参数决定指示器是否显示。AFNetworkActivityIndicatorManager从两个方向来管理这个指示器，可以开发者手动设置，同时他也会对所有AFNetworking发出的请求状态进行监听，来自动适应决定是否显示指示器。 以前我在设计全局Loading时，通常直接为他暴漏显隐两个接口，当处理多个并行请求的时候就很尴尬了，因为你无法保证Loading在最后完成的请求结束后再隐藏。 AFNetworkActivityIndicatorManager采用了触发器的设计模式(其实有些像引用计数)，请求来对触发器进行加或减的操作，触发器决定是否触发显示指示器。后面的应用解析中会有具体的接口解释。 四、应用全解1.检测网络状态在AFNetworking中提供了管理类AFNetworkReachabilityManager类，这个类专门用于网络状态的检测。其代码量很少，接口设计也十分简单。AFNetworkReachabilityManager类解析如下： 1234567891011121314151617181920212223242526272829303132333435//返回默认的单例对象+ (instancetype)sharedManager;//创建一个新的管理对象+ (instancetype)manager;+ (instancetype)managerForDomain:(NSString *)domain;+ (instancetype)managerForAddress:(const void *)address;- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability;//获取当前的网络状态/*typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123; AFNetworkReachabilityStatusUnknown = -1, //未知 AFNetworkReachabilityStatusNotReachable = 0, //未连接 AFNetworkReachabilityStatusReachableViaWWAN = 1, //移动网路 AFNetworkReachabilityStatusReachableViaWiFi = 2, //WIFI&#125;;*/@property (readonly, nonatomic, assign) AFNetworkReachabilityStatus networkReachabilityStatus;//获取当前网络是否连接@property (readonly, nonatomic, assign, getter = isReachable) BOOL reachable;//获取当前是否是移动网络@property (readonly, nonatomic, assign, getter = isReachableViaWWAN) BOOL reachableViaWWAN;//获取当前是否是WIFI网络@property (readonly, nonatomic, assign, getter = isReachableViaWiFi) BOOL reachableViaWiFi;//开启网络状态监听 当网络状态变化时会有回调- (void)startMonitoring;//停止进行网络状态监听- (void)stopMonitoring;//设置网络状态发生变化后的回调- (void)setReachabilityStatusChangeBlock:(nullable void (^)(AFNetworkReachabilityStatus status))block;//格式化的网络状态字符串- (NSString *)localizedNetworkReachabilityStatusString;//如果开启了网络状态监听 则网络状态发生变化时也会 发这个通知FOUNDATION_EXPORT NSString * const AFNetworkingReachabilityDidChangeNotification;//通知中userinfo字典中对应网络状态的键名FOUNDATION_EXPORT NSString * const AFNetworkingReachabilityNotificationStatusItem; 2.UIButton+AFNetworking类别这个类别是AFNetworking中UI部分所提供了一个工具，用来创建远程图片按钮。 1234567891011121314151617181920212223242526272829303132//设置共享的下载器对象 用来进行网络图片的下载+ (void)setSharedImageDownloader:(AFImageDownloader *)imageDownloader;//获取共享的下载器对象+ (AFImageDownloader *)sharedImageDownloader;//下面这些方法用来设置按钮图片- (void)setImageForState:(UIControlState)state withURL:(NSURL *)url;- (void)setImageForState:(UIControlState)state withURL:(NSURL *)url placeholderImage:(nullable UIImage *)placeholderImage;- (void)setImageForState:(UIControlState)state withURLRequest:(NSURLRequest *)urlRequest placeholderImage:(nullable UIImage *)placeholderImage success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure;//下面这些方法用来设置按钮背景图片- (void)setBackgroundImageForState:(UIControlState)state withURL:(NSURL *)url;- (void)setBackgroundImageForState:(UIControlState)state withURL:(NSURL *)url placeholderImage:(nullable UIImage *)placeholderImage;- (void)setBackgroundImageForState:(UIControlState)state withURLRequest:(NSURLRequest *)urlRequest placeholderImage:(nullable UIImage *)placeholderImage success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure;//取消按钮图片下载任务- (void)cancelImageDownloadTaskForState:(UIControlState)state;//取消按钮背景图片下载任务- (void)cancelBackgroundImageDownloadTaskForState:(UIControlState)state; 3.UIImageView+AFNetworking类别这个类别是AFNetworking框架提供了UIImageView加载异步图片的方案(更多时候可能会用SDWebImage)。 123456789101112131415//设置共享的图片下载器+ (void)setSharedImageDownloader:(AFImageDownloader *)imageDownloader;//获取共享的图片下载器+ (AFImageDownloader *)sharedImageDownloader;//设置图片- (void)setImageWithURL:(NSURL *)url;- (void)setImageWithURL:(NSURL *)url placeholderImage:(nullable UIImage *)placeholderImage;- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest placeholderImage:(nullable UIImage *)placeholderImage success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure;//取消图片下载任务- (void)cancelImageDownloadTask; 4.状态栏的网络状态指示器AFNetworking的UI工具包中提供了AFNetworkActivityIndicatorManager类，这个管理类用来对iOS设备状态栏上活动指示器的显示隐藏进行管理。其提供的接口十分简单，解析如下： 12345678910111213141516171819202122//设置是否有效 /*如果设置为YES，则可以手动进行控制器的控制如果设置为NO，则控制器只会根据网络通知来绝对是否显示*/@property (nonatomic, assign, getter = isEnabled) BOOL enabled;//指示器当前是否显示@property (readonly, nonatomic, assign, getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible;//指示器的延时显示时间 当多久后如果网络请求还没有完成 再进行显示@property (nonatomic, assign) NSTimeInterval activationDelay;//设置当请求结束多久后 活动指示器隐藏 默认为0.17s@property (nonatomic, assign) NSTimeInterval completionDelay;//获取单例对象+ (instancetype)sharedManager;//手动对触发器加1 //当计数大于0 则显示指示器- (void)incrementActivityCount;//手动对触发器减1//当计数不大于0 则隐藏指示器- (void)decrementActivityCount;//设置指示器状态改变的回调- (void)setNetworkingActivityActionWithBlock:(nullable void (^)(BOOL networkActivityIndicatorVisible))block; 5.UIActivityIndicatorView+AFNetworking与UIRefreshControl+AFNetworking类别这两个类别可以将一个请求任务绑定到活动指示器或原生刷新组件上，任务的完成与否来决定控件是否展示动画。 1234567//UIActivityIndicatorView+AFNetworking//将任务绑定到活动指示器上- (void)setAnimatingWithStateOfTask:(nullable NSURLSessionTask *)task;//UIRefresh+AFNetworing//将任务绑定到刷新组件上- (void)setRefreshingWithStateOfTask:(NSURLSessionTask *)task; 6.UIProgressView+AFNetworking类别这个类别可以将上传和下载任务绑定到进度条组件上。 123456//将上传任务绑定- (void)setProgressWithUploadProgressOfTask:(NSURLSessionUploadTask *)task animated:(BOOL)animated;//将下载任务绑定- (void)setProgressWithDownloadProgressOfTask:(NSURLSessionDownloadTask *)task animated:(BOOL)animated; 7.UIWebView+AFNetworking类别这个类别是对UIWebView的一种扩展(由于WebKit，这个类别很少会用到了)，其主要作用是将WebView的直接加载改为先下载本地数据，然后进行本地数据的加载，并可以提供一个进度。 123456789101112//这个方法是下面方法的封装- (void)loadRequest:(NSURLRequest *)request progress:(NSProgress * _Nullable __autoreleasing * _Nullable)progress success:(nullable NSString * (^)(NSHTTPURLResponse *response, NSString *HTML))success failure:(nullable void (^)(NSError *error))failure;//进行网页数据请求，完成后会将网页数据返回 并且自动的进行加载- (void)loadRequest:(NSURLRequest *)request MIMEType:(nullable NSString *)MIMEType textEncodingName:(nullable NSString *)textEncodingName progress:(NSProgress * _Nullable __autoreleasing * _Nullable)progress success:(nullable NSData * (^)(NSHTTPURLResponse *response, NSData *data))success failure:(nullable void (^)(NSError *error))failure; 8.图片下载器AFImageDownloader的应用AFImageDownloader是AF框架中提供的图片下载管理类。其内部封装了一个AFImageDownloadReceipt回执类，这个类实例用来进行正在下载图片任务的取消。AFImageDownloader解析如下： 12345678910111213141516171819202122232425262728293031//图片缓存器@property (nonatomic, strong, nullable) id &lt;AFImageRequestCache&gt; imageCache;//请求会话管理类@property (nonatomic, strong) AFHTTPSessionManager *sessionManager;//设置下载器属性/*下载器可以设置同时下载图片的最大数量 如果超出数量的请求会被暂时挂起typedef NS_ENUM(NSInteger, AFImageDownloadPrioritization) &#123; AFImageDownloadPrioritizationFIFO,//被挂起的请求遵守先挂起的先开始 AFImageDownloadPrioritizationLIFO//被挂起的请求遵守后挂起的先开始&#125;;*/@property (nonatomic, assign) AFImageDownloadPrioritization downloadPrioritizaton;//获取单例对象+ (instancetype)defaultInstance;//获取默认的url缓存器+ (NSURLCache *)defaultURLCache;//使用初始化方法新建对象- (instancetype)initWithSessionManager:(AFHTTPSessionManager *)sessionManager downloadPrioritization:(AFImageDownloadPrioritization)downloadPrioritization maximumActiveDownloads:(NSInteger)maximumActiveDownloads imageCache:(nullable id &lt;AFImageRequestCache&gt;)imageCache;//进行图片请求 随机生成uuid- (nullable AFImageDownloadReceipt *)downloadImageForURLRequest:(NSURLRequest *)request success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *responseObject))success failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure;//和上面方法一样，使用自定义的uuid- (nullable AFImageDownloadReceipt *)downloadImageForURLRequest:(NSURLRequest *)request withReceiptID:(NSUUID *)receiptID success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *responseObject))success failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure; 9.图片缓存器应用AF框架中UIKit工具包里的ADAutoPurgingImageCache类用来进行图片缓存，其还封装了自动清缓存的逻辑，缓存的命中则是完全按照使用时间先后为标准。类接口解析如下： 1234567891011121314151617181920212223242526272829303132333435//图片缓存协议@protocol AFImageCache &lt;NSObject&gt;//根据id来缓存图片- (void)addImage:(UIImage *)image withIdentifier:(NSString *)identifier;//根据id来删除图片- (BOOL)removeImageWithIdentifier:(NSString *)identifier;//删除所有图片缓存- (BOOL)removeAllImages;//根据id来取缓存- (nullable UIImage *)imageWithIdentifier:(NSString *)identifier;@end//网络图片缓存协议@protocol AFImageRequestCache &lt;AFImageCache&gt;//缓存某个url的图片 用url+id的方式- (void)addImage:(UIImage *)image forRequest:(NSURLRequest *)request withAdditionalIdentifier:(nullable NSString *)identifier;//移除某个缓存图片- (BOOL)removeImageforRequest:(NSURLRequest *)request withAdditionalIdentifier:(nullable NSString *)identifier;//获取缓存- (nullable UIImage *)imageforRequest:(NSURLRequest *)request withAdditionalIdentifier:(nullable NSString *)identifier;@end//缓存器实例类@interface AFAutoPurgingImageCache : NSObject &lt;AFImageRequestCache&gt;//缓存空间大小 默认为100M@property (nonatomic, assign) UInt64 memoryCapacity;//当缓存超过最大限制时进行清缓存 清缓存后的缓存底线大小设置 默认60M@property (nonatomic, assign) UInt64 preferredMemoryUsageAfterPurge;//已用空间大小@property (nonatomic, assign, readonly) UInt64 memoryUsage;//初始化方法- (instancetype)init;- (instancetype)initWithMemoryCapacity:(UInt64)memoryCapacity preferredMemoryCapacity:(UInt64)preferredMemoryCapacity;@end 每次读优秀的代码都是一次深刻的学习，每一次模仿，都是创造的开始！ ——QQ 316045346 欢迎交流","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"Tkinter之Menu组件用法","slug":"361Tkinter之Menu组件用法","date":"2017-11-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.375Z","comments":true,"path":"2017/11/02/361Tkinter之Menu组件用法/","link":"","permalink":"http://huishao.cc/2017/11/02/361Tkinter之Menu组件用法/","excerpt":"","text":"Tkinter之Menu组件用法开发工具类桌面应用使用Python、Java这类语言是一种不错的选择，他们的GUI库都可以很好的支持跨平台特性。本系列博客主要总结Tkinter库中提供的UI组件，关于Java的GUI开发，感兴趣的可以在如下系列博客中找到： https://my.oschina.net/u/2340880/blog?catalog=5647945&amp;temp=1509528194945。 Tkinter中有提供Menu菜单组件中可以添加如下几种组件: 1_动作项：简单的行为按钮，用户点击后会执行相应的方法。 2_子菜单：行为完整的子菜单项。 3_控制按钮：可有选中与非选中状态，用来做开关。 4_单选列表：一组单选按钮。 为一个窗口添加菜单十分容易，示例代码如下： 12345678910root = Tk()rootMenu = Menu(root)root.config(menu=rootMenu)item = Menu(master=rootMenu,postcommand=call,tearoff=1)rootMenu.add_cascade(menu=item,label=\"File\")item.add_command(label='new File')subItem = Menu(item)subItem.add_command(label=\"Open in noew window\")item.add_cascade(menu=subItem,label=\"Open\") 效果如下图所示： Menu构造函数中第1个参数可以传入菜单所属的窗口或者父菜单，后面可以添加一些菜单配置，例如： | 属性 | 意义 || activebackground | 活跃时的背景色 || activeborderwidth | 活跃时的边框宽度 || activeforeground | 活跃时的前景色 || bg 或者 background | 正常状态背景色 || bd 或者 borderwidth | 正常状态变宽宽度 || cursor | 鼠标样式 || disabledforeground | 无效状态的前景色 || font | 菜单字体 || fg 或者 foreground | 正常状态的前景色 || postcommand | 设置菜单被唤出时的回调 || relief | 设置菜单浮雕效果 || selectcolor | 设置菜单选中颜色 || tearoff | 可以设置为0和1，表示此菜单是否可以独立出来 || tearoffcommand | 菜单独立被触发时的回调 || title | 可设置独立菜单的标题 | 需要注意，在MacOS系统上，菜单的样式是由系统维护的，上面的大多属性都将没有效果。 下面这些方法用来进行菜单配置： 123456789101112131415161718192021222324252627282930313233343536373839#添加一个子菜单 coption为配置选项add_cascade(coption...)#添加一个切换按钮 coption为配置选项add_checkbutton(coption...)#添加一个功能按钮 coption为配置选项add_command(coption...)#添加一个单选按钮 coption为配置选项add_radiobutton(coption...)#添加一个分割线add_separator()#删除index1 到 index2之间的选项delete(index1,index2)#获取菜单某一项的属性值entrycget(index,coption)#重新配置菜单中某项的属性entryconfigure(index,coption...)#返回参数位置对应的选项索引index(i)#在指定位置插入一个子菜单insert_cascade(index,coption...)#在指定位置插入一个切换按钮insert_checkbutton(index,coption...)#在指定位置插入一个功能按钮insert_command(index,coption...)#在指定位置插入一个单选按钮insert_radiobutton(index,coption...)#在指定位置插入一个分割线insert_separator(index)#代码手动调用一次某个选项invoke(index)#在窗口指定位置弹出菜单post(x,y)#获取个选项的类型type(index)#获取某个选项距离菜单顶部的偏移量yposition(n)#添加一个选项 可以是功能按钮，切换按钮，单选按钮或子菜单，由类型确认#类型可选 cascade checkbutton command radiobutton separatoradd(kind,coption) 上面列举方法中的coption用来进行一些配置项的设置，可选配置项如下： | 属性名 | 意义 || accelerator | 设置快捷键 || activebackground | 激活状态背景色 || activeforeground | 激活状态前景色 || background | 正常状态背景色 || bitmap | 设置bitmap图标 || columnbreak | 设置分列 || command | 设置激活时的回调函数 || compound | 设置展示文本和图标是的布局方式 || font | 设置字体 || foreground | 设置正常状态的前景色 || hidemargin | 设置是否隐藏外边距 设置True或False || image | 设置图片 gif格式 || label | 设置显示的文本 || menu | 这个选项只用在添加子菜单中 || offvalue | 设置checkbutton关闭时的值 || onvalue | 设置checkbutton开启时的值 || selectcolor | 设置选中状态的颜色 || selectimage | 设置选中状态的图像 || state | 设置选项状态，DISABLED或ACTIVE || underline | 设置下划线 || value | 选项的值 || variable | 用于单选按钮或切换按钮 |","categories":[{"name":"Python","slug":"Python","permalink":"http://huishao.cc/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"http://huishao.cc/categories/Python/"}]},{"title":"iOS11新特性：新增拖拽交互体验","slug":"360iOS11新特性：新增拖拽交互体验","date":"2017-10-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.375Z","comments":true,"path":"2017/10/20/360iOS11新特性：新增拖拽交互体验/","link":"","permalink":"http://huishao.cc/2017/10/20/360iOS11新特性：新增拖拽交互体验/","excerpt":"","text":"iOS11新特性：新增拖拽交互体验一、引言在使用PC进行操作时，你一定遇到过这样的场景，可以将图片直接拖入聊天软件进行发送，可以将文档、音乐、视频文件等文件拖入相应应用程序直接进行使用。这种拖拽操作交互极大的方便了电脑的使用。在iOS11中，你可以在iPhone或iPad上构建这种交互体验！ 说在前面的话： 拖拽操作在iPad上是支持跨应用程序的，你可以从一个应用中拖取项目，通过Home键回到主界面并且打开另一个应用程序，然后将被拖拽的项目传递给这个应用程序中。在iPhone上，拖拽操作只支持当前应用程序内，你可以将某个元素从一个界面拖拽到另一个，这种维度的操作可以给设计人员更大的灵活性。 拖拽操作被设计成系统管理，开发者不需要为App申请特殊的用户权限。 二、拖拽源对于拖拽操作，至少要有两个组件，一个组件作为拖拽源用来提供数据，一个组件作为拖拽目的用来接收数据，当前，同一个组件既可以是拖拽源也可以是拖拽目的。首先我们先来看拖拽源，在UIKit框架中，iOS11默认实现了一些组件可以作为拖拽源， 例如UITextField、UITextView、UITableView和UICollectionView等。文本组件默认支持拖拽操作进行文本的传递，对于列表组件则默认支持元素的拖拽。例如，在UITextField选中的文案中进行拖拽，可以将文字拖拽出来，效果如下图： 任意的UIView组件都可以作为拖拽源，让其成为拖拽源其实也十分简单，只需要3步： 1.创建一个UIDragInteraction行为对象。 2.设置UIDragInteraction对象的代理并实现相应方法。 3.将UIDragInteraction对象添加到指定View上。 最简单的可拖拽组件的创建示例代码如下： 123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123; [super viewDidLoad]; [self.view addSubview:self.dragView];&#125;//创建View-(UIView *)dragView&#123; if (!_dragView) &#123; _dragView = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; _dragView.backgroundColor = [UIColor redColor]; [_dragView addInteraction:self.dragInteraction]; &#125; return _dragView;&#125;//创建拖拽行为对象-(UIDragInteraction *)dragInteraction&#123; if (!_dragInteraction) &#123; _dragInteraction = [[UIDragInteraction alloc]initWithDelegate:self]; //要设置可用 注意！！！ [_dragInteraction setEnabled:YES]; &#125; return _dragInteraction;&#125;//实现提供数据的代理方法- (NSArray&lt;UIDragItem *&gt; *)dragInteraction:(UIDragInteraction *)interaction itemsForBeginningSession:(id&lt;UIDragSession&gt;)session&#123; //数据提供者 NSItemProvider * provider = [[NSItemProvider alloc]initWithObject:@\"Hello World\"]; UIDragItem * item = [[UIDragItem alloc]initWithItemProvider:provider]; return @[item];&#125; 上面的dragInteraction:代理方法用来提供要传递的数据，传递的数据必须遵守相应的承诺协议，后面会给大家介绍，这里只是简单返回了一个字符串数据Hello World，运行工程，你可以试验下，可以直接将我们自定义的视图拖拽进UITextField并在其中显示Hello World。 三、关于UIDragInteraction类所有可以接收拖拽行为的组件都必须通过这个类实现，这个类中属性意义列举如下： 12345678910//初始化方法- (instancetype)initWithDelegate:(id&lt;UIDragInteractionDelegate&gt;)delegate;//代理@property (nonatomic, nullable, readonly, weak) id&lt;UIDragInteractionDelegate&gt; delegate;//是否支持多种手势都接收响应@property (nonatomic) BOOL allowsSimultaneousRecognitionDuringLift;//设置是否有效@property (nonatomic, getter=isEnabled) BOOL enabled;//获取默认是否有效 不同的设备这个值将有所区别@property (class, nonatomic, readonly, getter=isEnabledByDefault) BOOL enabledByDefault; 四、UIDragInteractionDelegate协议UIDragInteractionDelegate用来处理拖拽源的行为与数据。其中定义了一个必须实现的方法和许多可选实现的方法。解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*这个方法是必须实现的用来返回拖拽源提供的数据需要注意，这个函数需要返回一个数组，数组中可以有多个数据源如果返回空数组，则拖拽行为不会开始*/- (NSArray&lt;UIDragItem *&gt; *)dragInteraction:(UIDragInteraction *)interaction itemsForBeginningSession:(id&lt;UIDragSession&gt;)session;/*这个方法用来自定义拖拽效果的预览视图 关于预览视图，后面会介绍需要注意，系统默认会提供一个预览视图，不实现这个方法即是使用系统默认的如果返回nil，则会去除预览动画*/- (nullable UITargetedDragPreview *)dragInteraction:(UIDragInteraction *)interaction previewForLiftingItem:(UIDragItem *)item session:(id&lt;UIDragSession&gt;)session;/*拖拽动画即将开始时会调用此函数*/- (void)dragInteraction:(UIDragInteraction *)interaction willAnimateLiftWithAnimator:(id&lt;UIDragAnimating&gt;)animator session:(id&lt;UIDragSession&gt;)session;//拖拽行为会话即将开始时调用的方法- (void)dragInteraction:(UIDragInteraction *)interaction sessionWillBegin:(id&lt;UIDragSession&gt;)session;//这个方法设置数据的防止是否允许数据的 移动操作，需要注意，这个只有在app内有效，跨app的操作会总是复制数据- (BOOL)dragInteraction:(UIDragInteraction *)interaction sessionAllowsMoveOperation:(id&lt;UIDragSession&gt;)session;//设置是否允许跨应用程序进行拖拽 ipad- (BOOL)dragInteraction:(UIDragInteraction *)interaction sessionIsRestrictedToDraggingApplication:(id&lt;UIDragSession&gt;)session;//设置预览视图是否显示原始大小- (BOOL)dragInteraction:(UIDragInteraction *)interaction prefersFullSizePreviewsForSession:(id&lt;UIDragSession&gt;)session;/*当拖拽源被移动时调用，可以用如下方法获取其坐标NSLog(@\"%f,%f\",[session locationInView:self.view].x,[session locationInView:self.view].y);*/- (void)dragInteraction:(UIDragInteraction *)interaction sessionDidMove:(id&lt;UIDragSession&gt;)session;//拖拽行为将要结束时调用- (void)dragInteraction:(UIDragInteraction *)interaction session:(id&lt;UIDragSession&gt;)session willEndWithOperation:(UIDropOperation)operation;//拖拽行为已经结束时调用- (void)dragInteraction:(UIDragInteraction *)interaction session:(id&lt;UIDragSession&gt;)session didEndWithOperation:(UIDropOperation)operation;//拖拽源进行了放置操作后调用- (void)dragInteraction:(UIDragInteraction *)interaction sessionDidTransferItems:(id&lt;UIDragSession&gt;)session;//设置拖拽动作取消的视图动画 返回nil则消除动画-(nullable UITargetedDragPreview *)dragInteraction:(UIDragInteraction *)interaction previewForCancellingItem:(UIDragItem *)item withDefault:(UITargetedDragPreview *)defaultPreview;//拖拽动作即将取消时调用的方法- (void)dragInteraction:(UIDragInteraction *)interaction item:(UIDragItem *)item willAnimateCancelWithAnimator:(id&lt;UIDragAnimating&gt;)animator;//设置是否允许向拖拽中的项目添加数据/*可以返回数据载体数组 当拖拽过程中 点击可拖拽的组件时会触发*/- (NSArray&lt;UIDragItem *&gt; *)dragInteraction:(UIDragInteraction *)interaction itemsForAddingToSession:(id&lt;UIDragSession&gt;)session withTouchAtPoint:(CGPoint)point;//设置允许进行拖拽中追加数据的拖拽行为会话- (nullable id&lt;UIDragSession&gt;)dragInteraction:(UIDragInteraction *)interaction sessionForAddingItems:(NSArray&lt;id&lt;UIDragSession&gt;&gt; *)sessions withTouchAtPoint:(CGPoint)point;//将要向拖拽组件中追加数据时调用- (void)dragInteraction:(UIDragInteraction *)interaction session:(id&lt;UIDragSession&gt;)session willAddItems:(NSArray&lt;UIDragItem *&gt; *)items forInteraction:(UIDragInteraction *)addingInteraction; 上面列举的协议方法中有关联到其他许多iOS11中新增的类，后面会一一介绍。其实，完成了以上内容的了解，你就已经可以完全随心所欲的定制拖拽源组件了。 五、放置目的地拖拽源是数据的提供者，放置目的地就是数据的接收者。前面我们也实验过，将自定义的拖拽源拖拽进UITextField后，文本框中会自动填充我们提供的文本数据。同样，对于任何自定义的UIView视图，我们也可以让其成为放置目的地，需要完成如下3步： 1.创建一个UIDropInteraction行为对象。 2.设置UIDropInteraction对象的代理并实现协议方法。 3.将其添加到自定义的视图中。 例如，我们将自定义的UILabel组件用来显示拖拽的文案： 12345678910111213141516171819202122232425262728293031323334353637383940//添加视图- (void)viewDidLoad &#123; [super viewDidLoad]; //有关拖拽源的代码 前面已经列举过 这里不再重复 [self.view addSubview:self.dragView]; [self.view addSubview:self.dropLabel];&#125;-(UILabel *)dropLabel&#123; if (!_dropLabel) &#123; _dropLabel = [[UILabel alloc]initWithFrame:CGRectMake(10, 300, 300, 30)]; _dropLabel.backgroundColor = [UIColor greenColor]; _dropLabel.userInteractionEnabled = YES; [_dropLabel addInteraction:self.dropInteraction]; &#125; return _dropLabel;&#125;//放置目的地行为对象-(UIDropInteraction*)dropInteraction&#123; if (!_dropInteraction) &#123; _dropInteraction = [[UIDropInteraction alloc]initWithDelegate:self]; &#125; return _dropInteraction;&#125;//这个方法返回是否响应此放置目的地的放置请求-(BOOL)dropInteraction:(UIDropInteraction *)interaction canHandleSession:(id&lt;UIDropSession&gt;)session&#123; return YES;&#125;//设置以何种方式响应拖放会话行为-(UIDropProposal *)dropInteraction:(UIDropInteraction *)interaction sessionDidUpdate:(id&lt;UIDropSession&gt;)session&#123; return [[UIDropProposal alloc]initWithDropOperation:UIDropOperationCopy];&#125;//已经应用拖放行为后执行的操作-(void)dropInteraction:(UIDropInteraction *)interaction performDrop:(id&lt;UIDropSession&gt;)session&#123; [session loadObjectsOfClass:[NSString class] completion:^(NSArray&lt;__kindof id&lt;NSItemProviderReading&gt;&gt; * _Nonnull objects) &#123; self.dropLabel.text = objects.firstObject; &#125;];&#125; 上面的代码将我们自定义的拖拽源提供的Hello World拖放进了UILabel组件中。 六、关于UIDropInteraction类与UIDragInteraction类类似，这个类的作用是让组件有相应放置操作的能力。其中属性如下： 123456//初始化方法- (instancetype)initWithDelegate:(id&lt;UIDropInteractionDelegate&gt;)delegate;//代理对象@property (nonatomic, nullable, readonly, weak) id&lt;UIDropInteractionDelegate&gt; delegate;//是否允许多个交互行为@property (nonatomic, assign) BOOL allowsSimultaneousDropSessions; 七、UIDropInteractionDelegate协议UIDropInteractionDelegate协议中所定义的方法全部是可选实现的，其用来处理用户放置交互行为。 123456789101112131415161718192021222324//放置行为即将响应时触发的方法 返回值确定是否响应此次行为- (BOOL)dropInteraction:(UIDropInteraction *)interaction canHandleSession:(id&lt;UIDropSession&gt;)session;//当上面的协议方法返回YES时会接着调用这个函数- (void)dropInteraction:(UIDropInteraction *)interaction sessionDidEnter:(id&lt;UIDropSession&gt;)session;//将要处理数据时回调的方法/*当数据源数据添加时，这个方法也会被重新调用 这个函数需要返回一个处理行为方式UIDropProposal对象，这个我们后面再说*/- (UIDropProposal *)dropInteraction:(UIDropInteraction *)interaction sessionDidUpdate:(id&lt;UIDropSession&gt;)session;//放置行为相应结束的时候会调用此方法- (void)dropInteraction:(UIDropInteraction *)interaction sessionDidExit:(id&lt;UIDropSession&gt;)session;//这个方法当用户进行放置时会调用，可以从session中获取被传递的数据- (void)dropInteraction:(UIDropInteraction *)interaction performDrop:(id&lt;UIDropSession&gt;)session;//放置动画完成后会调用这个方法- (void)dropInteraction:(UIDropInteraction *)interaction concludeDrop:(id&lt;UIDropSession&gt;)session;//整个拖放行为结束后会调用- (void)dropInteraction:(UIDropInteraction *)interaction sessionDidEnd:(id&lt;UIDropSession&gt;)session;//下面这些方法用来自定义放置动画//设置放置预览动画- (nullable UITargetedDragPreview *)dropInteraction:(UIDropInteraction *)interaction previewForDroppingItem:(UIDragItem *)item withDefault:(UITargetedDragPreview *)defaultPreview;//这个函数每当有一个拖拽数据项放入时都会调用一次 可以进行动画- (void)dropInteraction:(UIDropInteraction *)interaction item:(UIDragItem *)item willAnimateDropWithAnimator:(id&lt;UIDragAnimating&gt;)animator; 需要注意，UIDropProposal类用来进行处理回执，属性方法解析如下： 1234567891011121314151617181920//初始化方法/*typedef NS_ENUM(NSUInteger, UIDropOperation) &#123; //取消这次行为 UIDropOperationCancel = 0, //拒绝行为 UIDropOperationForbidden = 1, //接收拷贝数据 UIDropOperationCopy = 2, //接收移动数据 UIDropOperationMove = 3,&#125;*/- (instancetype)initWithDropOperation:(UIDropOperation)operation;//处理方式@property (nonatomic, readonly) UIDropOperation operation;//精准定位@property (nonatomic, getter=isPrecise) BOOL precise;//设置是否展示完整的预览尺寸@property (nonatomic) BOOL prefersFullSizePreview; 八、拖拽数据载体UIDragItem类UIDragItem类用来承载要传递的数据。其通过NSItemProvider类来进行构建，传递的数据类型是有严格规定的，必须遵守一定的协议，系统的NSString，NSAttributeString，NSURL，UIColor和UIImage是默认支持的，你可以直接传递这些数据。 UIDragItem中提供的属性方法： 12345678//初始化方法- (instancetype)initWithItemProvider:(NSItemProvider *)itemProvider;//数据提供者实例@property (nonatomic, readonly) __kindof NSItemProvider *itemProvider;//用来传递一些额外的关联信息@property (nonatomic, strong, nullable) id localObject;//用来自定义每个item添加时的预览动画@property (nonatomic, copy, nullable) UIDragPreview * _Nullable (^previewProvider)(void); 九、UIDropSession与UIDragSession在与拖拽交互相关的接口中，这两个是面向协议编程的绝佳范例，首先在UIKit框架中只定义了这两个协议，而并没有相关的实现类，在拖拽行为的相关回调接口中，很多id类型的参数都遵守了这个协议，我们无需知道是哪个类实现的，直接进行使用即可： UIDropSession： 1234567891011121314151617//继承于UIDragDropSession(提供基础数据), NSProgressReporting(提供数据读取进度)@protocol UIDropSession &lt;UIDragDropSession, NSProgressReporting&gt;//原始的dragSesstion会话 如果是跨应用的 则为nil@property (nonatomic, readonly, nullable) id&lt;UIDragSession&gt; localDragSession;//设置进度风格/*typedef NS_ENUM(NSUInteger, UIDropSessionProgressIndicatorStyle) &#123; UIDropSessionProgressIndicatorStyleNone, // 无 UIDropSessionProgressIndicatorStyleDefault, // 默认的&#125; API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos);*/@property (nonatomic) UIDropSessionProgressIndicatorStyle progressIndicatorStyle;//进行数据的加载- (NSProgress *)loadObjectsOfClass:(Class&lt;NSItemProviderReading&gt;)aClass completion:(void(^)(NSArray&lt;__kindof id&lt;NSItemProviderReading&gt;&gt; *objects))completion;@end UIDragSession： 12345API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(watchos, tvos) @protocol UIDragSession &lt;UIDragDropSession&gt;//设置要传递的额外信息 只有在同个APP内可见@property (nonatomic, strong, nullable) id localContext;@end UIDragDropSession： 123456789101112//传递的数据数组@property (nonatomic, readonly) NSArray&lt;UIDragItem *&gt; *items;//当前操作行为的坐标- (CGPoint)locationInView:(UIView *)view;//此次行为是否允许移动操作@property (nonatomic, readonly) BOOL allowsMoveOperation;//是否支持应用程序层面的拖拽@property (nonatomic, readonly, getter=isRestrictedToDraggingApplication) BOOL restrictedToDraggingApplication;//验证传递的数据是否支持某个数据类型协议- (BOOL)hasItemsConformingToTypeIdentifiers:(NSArray&lt;NSString *&gt; *)typeIdentifiers;//验证传递的数据是否可以加载某个类- (BOOL)canLoadObjectsOfClass:(Class&lt;NSItemProviderReading&gt;)aClass; 十、交互预览类UITargetedDragPreviewUITargetedDragPreview专门用来处理拖放交互过程中的动画与预览视图。方法解析如下： 123456789101112131415161718192021//创建一个预览对象 /*view：要创建的预览视图 需要注意，这个视图必须在window上param：配置参数target：容器视图，用来展示预览，一般设置为view的父视图*/- (instancetype)initWithView:(UIView *)view parameters:(UIDragPreviewParameters *)parameters target:(UIDragPreviewTarget *)target;//同上-(instancetype)initWithView:(UIView *)view parameters:(UIDragPreviewParameters *)parameters;//同上- (instancetype)initWithView:(UIView *)view;//动画承载者@property (nonatomic, readonly) UIDragPreviewTarget* target;//动画视图@property (nonatomic, readonly) UIView *view;//配置参数@property (nonatomic, readonly, copy) UIDragPreviewParameters *parameters;//尺寸@property (nonatomic, readonly) CGSize size;//返回新的对象- (UITargetedDragPreview *)retargetedPreviewWithTarget:(UIDragPreviewTarget *)newTarget; UIDragPreviewTarget主要用来设置动画的起始视图与结束时回归的视图，其中属性方法如下： 12345678910111213/*初始化方法container：必须是在window上的viewcenter：动画起点与终点transform:进行变换*/- (instancetype)initWithContainer:(UIView *)container center:(CGPoint)center transform:(CGAffineTransform)transform;//同上- (instancetype)initWithContainer:(UIView *)container center:(CGPoint)center;//对应属性@property (nonatomic, readonly) UIView *container;@property (nonatomic, readonly) CGPoint center;@property (nonatomic, readonly) CGAffineTransform transform; UIDragPreviewParameters用来进行拖拽动画的配置，解析如下： 123456//构造方法并设置路径矩形- (instancetype)initWithTextLineRects:(NSArray&lt;NSValue /* CGRect */ *&gt; *)textLineRects;//显示的路径@property (nonatomic, copy, nullable) UIBezierPath *visiblePath;//背景色@property (nonatomic, copy, null_resettable) UIColor *backgroundColor; 我们可以使用任意自定义的视图来展现这个预览动画，如下图所示： 十一、使用拖拽操作进行自定义数据的传递本篇文章到这里，其实基本的内容都已经说完了，虽然比较详细，也可能难免冗余，如果你耐着性子看到了这里，那么我首先钦佩你的毅力并且感谢你的耐心。其实，拖拽交互如果进行只能对系统的提供的数据类型进行操作则应用就局限太多。试想一下，如果我们可以通过拖拽商品来进行购买，拖拽联系人来进行发送，或者在游戏中，拖拽进行卡片的融合，装备的提炼等等这种交互操作是不是会很畅快。最后，我们就来看看如何让自定义的数据类型支持拖拽操作。 首先你需要关注两个协议，NSItemProviderWriting与NSItemProviderReading。Writing协议用来让数据支持提供给数据源，Reading协议让数据支持从数据源读出，用自定义的Person类为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#import &lt;Foundation/Foundation.h&gt;//遵守协议@interface Person : NSObject&lt;NSItemProviderWriting,NSItemProviderReading&gt;//自定义内容@property(nonatomic,strong)NSString * name;@property(nonatomic,assign)NSUInteger age;@end//.m文件@implementation Person//数据归档- (nullable NSProgress *)loadDataWithTypeIdentifier:(NSString *)typeIdentifier forItemProviderCompletionHandler:(void (^)(NSData * _Nullable data, NSError * _Nullable error))completionHandler&#123; NSProgress * pro = [NSProgress new]; NSData * data = [NSKeyedArchiver archivedDataWithRootObject:self]; completionHandler(data,nil); return pro;&#125;+(NSItemProviderRepresentationVisibility)itemProviderVisibilityForRepresentationWithTypeIdentifier:(NSString *)typeIdentifier&#123; return NSItemProviderRepresentationVisibilityAll;&#125;- (NSItemProviderRepresentationVisibility)itemProviderVisibilityForRepresentationWithTypeIdentifier:(NSString *)typeIdentifier&#123; return NSItemProviderRepresentationVisibilityAll;&#125;//提供一个标识符+(NSArray&lt;NSString *&gt; *)writableTypeIdentifiersForItemProvider&#123; return @[@\"object\"];&#125;-(NSArray&lt;NSString *&gt; *)writableTypeIdentifiersForItemProvider&#123; return @[@\"object\"];&#125;- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super init]; if (self) &#123; self.name = [coder decodeObjectForKey:@\"name\"]; self.age = [coder decodeIntegerForKey:@\"age\"]; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.name forKey:@\"name\"]; [aCoder encodeInteger:self.age forKey:@\"age\"];&#125;//这两个是读协议+(NSArray&lt;NSString *&gt; *)readableTypeIdentifiersForItemProvider&#123; return @[@\"object\"];&#125;//解归档返回+ (nullable instancetype)objectWithItemProviderData:(NSData *)data typeIdentifier:(NSString *)typeIdentifier error:(NSError **)outError&#123; Person * p = [NSKeyedUnarchiver unarchiveObjectWithData:data]; return p;&#125;@end 需要注意，在拖放行为读取数据时的类型要对应，如下： 123456-(void)dropInteraction:(UIDropInteraction *)interaction performDrop:(id&lt;UIDropSession&gt;)session&#123; NSLog(@\"%@\",session.items.lastObject.localObject); [session loadObjectsOfClass:[Person class] completion:^(NSArray&lt;__kindof id&lt;NSItemProviderReading&gt;&gt; * _Nonnull objects) &#123; self.dropLabel.text = ((Person*)objects.firstObject).name; &#125;];&#125; 写了这么多，难免有疏漏与错误，欢迎指导交流","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C关于id引发的一些思考","slug":"359Objective-C关于id引发的一些思考","date":"2017-10-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.374Z","comments":true,"path":"2017/10/14/359Objective-C关于id引发的一些思考/","link":"","permalink":"http://huishao.cc/2017/10/14/359Objective-C关于id引发的一些思考/","excerpt":"","text":"Objective-C关于id引发的一些思考Objective-C是面向对象语言，但其中又并非全部是对象。在初学这门语言时，我常常从意识上将NS开头的类型与C语言原本的那些类型分割开来，假装他们之间没有联系，只关注“类”的世界。然而类终究只是一种应用上的抽象，就像“语法糖”一样，抛开华丽的外表，内部依然是最朴素的结构体和指针。本篇博客的来由源自朋友的一个问题：在ARC环境，performSelector:withObject:方法如何传递非对象类型的数据呢？这个问题乍看起来简单，但要较较真，却也并非那么简单。下面的内容都是有这个简单的问题引出的，如果你感兴趣，在读之前可以先试着解决下上面的疑问。 一、还要先说idid是Objective-C中定义的一种泛型实现，它可以表示任何对象类型。尽管id看起来是如此简单，但细细琢磨，其却包含了3层意义： 1.作为参数或返回值 将id类型作为函数的参数或返回值是最浅的一层意义，其增加了函数的灵活性，Foundation框架中也有其大量的应用，例如可变数组追加元素。 2.id类型的参数不会进行类型检查 这是id类型十分重要的一个特点，声明为id类型的对象就相当于告诉了编译器不进行类型检查(这也是和NSObject类型最大区别)。因此，你可以将id类型的变量赋值给任何对象类型，也可以将任何对象类型的变量赋值给id类型，更重要的是，使用id类型的对象可以调用任意方法，都不会进行类型检查。 3.id是一种优雅的编程方式 由于id类型不会进行编译检查，要约束类型方法实现最好的方式就是通过协议，id&lt;protocol&gt;是一种十分优雅的编程方式，其不再关心类型，只注重约定的实现，Foundation框架中的代理多采用这种方式设计。 另外，在objc.h文件中，id被定位为如下： 12345struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;;//结构体指针typedef struct objc_object *id; 二、关于void与void*在开发中，void用的最多的地方要数标记Objective-C无返回值的函数，Objective-C函数和C函数不同，其必须有一个确定的返回值类型，如果没有返回值，则需要使用void来标记返回值类型，而C函数是可以不指定返回值类型的，默认的C函数则是返回int类型的值，例如下面的两个函数实际上是完全一样的： 123456789print()&#123; printf(\"cccccc\"); return 0;&#125;int print()&#123; printf(\"cccccc\"); return 0;&#125; void在C语言中还有一大用途在于约束无参函数，例如上面示例的函数虽然没有参数，但是如果你在调用的时候强制传入参数编译器也不出进行错误提醒，如果将函数修改如下，则此函数就完全不能传入参数了： 1234int print(void)&#123; printf(\"cccccc\"); return 0;&#125; 归根结底，void大多时候用来表示“空”，而void * 则完全不同，它所描述的实际上是任意类型的指针。这里和id很像对不对，虽然id描述的是Objective-C对象但是本质也是指针，那么根据我们的推测，id类型的数据和void*类型的数据是可以进行类型转换的。事实上，在MRC环境下确实如此，ARC环境下则要更复杂一些，由于ARC机制要对Objective-C对象进行引用计数管理，对C指针并不会，因此在ARC环境下编译器是不允许我们直接将id于void*进行进行转换的，例如下面的报错： 三、ARC中用__bridge的应用前面说过，由于ARC的原因，导致无法在Objective-C对象与C指针类型之间进行直接转换，但是可以通过\\_\\_bridge来转换，从字面理解，\\_\\_bridge的作用就是用来桥接。在做Objective-C相关开发时，你一定遇到过CoreFoundation框架与Foundation框架混用的情况，CF框架中的类都是由C语言直接实现的，例如CFString，CFURL等，其虽然可以和NSString，NSURL互用，但在ARC环境在，却必须进行桥接转换，即使用__bridge。上面的代码可以做如下修改： 123int a = 10;void * ap = &amp;a;id c = (__bridge id)ap; 同样，将id类型转换为void *如下： 12NSNumber * num = [[NSNumber alloc]initWithInt:1];void * cNumber = (__bridge void *)num; 与__bridge相对应的还有__bridge_transfer与__bridge_retained，他们的区别是__bridge不会改变对象的所有权，__bridge_transfer会将对象所有权进行转移，即release掉转换前的Objective-C对象，而__bridge_retained则是将所有权进行retain强引用。 四、解决最初的问题再来看我们最初的问题，下面方法的两个参数都是id类型的： 1- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2; 虽然我们也可以用其他方式来达到相同的效果，比如修改原函数的参数类型，或者使用NSInvocation来发送消息，一种更简便的方式如下： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int a = 10; [self performSelector:@selector(log:age:) withObject:@\"huishao\" withObject:(__bridge id)(void*)a];&#125;-(void)log:(NSString *)name age:(int)age&#123; NSLog(@\"%@,%d\",name,age);&#125; 最后，总结一点，其实不论任何编程语言，类型检查都是编译时的特性，真正传递的数据依然是在运行时决定的。","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"Swift4语法新特性","slug":"358Swift4语法新特性","date":"2017-08-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.374Z","comments":true,"path":"2017/08/24/358Swift4语法新特性/","link":"","permalink":"http://huishao.cc/2017/08/24/358Swift4语法新特性/","excerpt":"","text":"Swift4语法新特性随着iPhone X的来到，iOS11的发布，Swift语言也更新到了第4个版本。在Swift4中，无论是代码风格还是编程理念都更进一步的融合了许多现代编程的思想。对于熟悉传统语言的开发者来说(尤其是Objective-C、Java和C++)，可能会感觉这些特性并没有多大的价值反而非常不习惯，但是我们依然可以茶余饭后(没事干的时候)，一窥Swift4语言的玩法，体验一下Swift语言的设计思想和编码风格。 一、独占内存访问权限独占访问权限是Swift4中引入的一大新特性。然而大部分人都将这一特性误解了，如果你在百度上搜索 swift4 exclusive access to memory相关关键字，大部分博客或总结都会说这是一种编译器的编译时特性，可以在例如数组越界时、对遍历中的数组进行删添元素时产生编译异常。其实并非如此，独占内存访问权限特性是一种编译时和运行时的安全特性，其和数组也没有任何关系，当两个变量访问同一块内存时，会产生独占内存访问限制。 首先，在Swift中对内存的访问有读访问与写访问两种，例如： 1234//读访问var name = \"jaki\"//写访问print(name) 在Swift4以前，程序对内存的读写访问并没有严格的控制，如果你在读内存时有写内存操作，或者写内存时有读操作并不会产生什么异常(当然，你自己要清楚读写后变量的值，以免产生逻辑歧义)。Swift4中则引入了独占内存访问权限的特性，如果复合如下3个条件，则程序会产生读写权限冲突： 1.至少有一个变量在使用写权限。 2.变量访问的是同一个内存地址。 3.持续时间有重叠。 在开发中，可能会产生读写权限冲突的情况有3种： 1.inout 参数读写权限冲突一般情况下，值类型的传参总会产生复制操作。inout参数则使得函数内可以直接修改外部变量的值。inout参数是最容易产生读写冲突的场景，例如下面的代码：1234567var stepSize = 1func increment(_ number: inout Int) &#123; number += stepSize//crash&#125;increment(&amp;stepSize) 上面的代码在Swift3中没有任何问题，在Swift4环境中运行则会直接crash。在函数中，inout参数从声明开始到函数的结束，这个变量始终开启着写权限，对应上面代码，number参数开启这写权限，stepSize则进行了读访问，如此则满足上面的权限冲突规则，会产生读写冲突。同样，如果对两个inout参数访问同一个内存地址，也会产生读写权限冲突，例如： 1234567var stepSize = 1func increment(_ number: inout Int,_ number2: inout Int) &#123; var a = number+number2&#125;increment(&amp;stepSize,&amp;stepSize) 2.结构体中自修改函数的读写冲突Swift语言中的结构体也是一种值类型，因此其也存在读写冲突的场景，例如如下代码： 123456789101112struct Player &#123; var name: String var health: Int var energy: Int let maxHealth = 10 mutating func shareHealth(_ player:inout Player) &#123; health = player.health &#125;&#125;var play = Player(name: \"jaki\", health: 10, energy: 10)play.shareHealth(&amp;play)//产生错误 上面shareHealth函数中使用到的health是对self自身的读访问，而inout参数是写访问，会产生读写权限冲突。 3.值类型中属性的读写访问权限冲突在Siwft语言中，像结构体，枚举和元组中都有属性的概念。由于其都是值类型，在对不同的属性进行访问时也会产生冲突，例如： 1234567891011class Demo &#123; var playerInformation = (health: 10, energy: 20) func balance(_ p1 :inout Int,_ p2 :inout Int) &#123; &#125; func test() &#123; self.balance(&amp;playerInformation.health, &amp;playerInformation.energy)//crash &#125;&#125;let demo = Demo()demo.test() 看到这里你一定觉得这太严格了，对不同属性的访问也会产生读写冲突。实际上，在开发中大部分的这种访问都会被认为是安全的，你需要满足下面3个条件： 1.你访问的是存储属性而不是计算属性。 2.你访问的是结构体局部变量(函数中的变量)而不是全局变量。 3.你的结构体不被闭包捕获，或者只是被非逃逸的闭包捕获。 将上面的playerInformation变量修改成局部的，程序就可以正常运行了： 123456789101112class Demo &#123; func balance(_ p1 :inout Int,_ p2 :inout Int) &#123; &#125; func test() &#123; var playerInformation = (health: 10, energy: 20) self.balance(&amp;playerInformation.health, &amp;playerInformation.energy) &#125;&#125;let demo = Demo()demo.test() 其实，Swfit4中的独占内存访问权限特性一般情况下我们都不会使用到，但是了解一下还是很有必要，Swift是一种安全性极高的语言，也是其设计的核心思想与方向，例如类构造方法的安全性检查特性，变量类型的安全限制特性等等都是将开发者编写代码的安全交给语言特性来负责，而不是开发者的经验。这让初学者可以更少的出错，语言运行时的不可控因素更少。 二、关联类型可以添加where约束子句associatedtype是Swift协议中一个很有用的关键字，其也是Swift泛型编程思想的一种实现。在Swift3中，associatedtype从语法上是不能追加where子句的，Swift4增强了associatedtype的功能，其可以使用where子句进行更加精准的约束，看下面的代码： 1234567891011121314151617181920212223242526272829//容器协议protocol Container &#123; //约束item 泛型为 Int类型 associatedtype Item where Item == Int func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125;&#125;class MyIntArray: Container &#123; //这个地方必须指定为Int否则会报错 typealias Item = Int func append(_ item: Int) &#123; self.innerArray.append(item) &#125; var count: Int&#123; get&#123; return self.innerArray.count &#125; &#125; subscript(i: Int) -&gt; Int &#123; return self.innerArray[i] &#125; var innerArray = [Int]() &#125; 三、可以创建多行字符串在Swift4以前，字符串只能创建单行的，Swift4中引入了字面量创建多行文本的语法，例如： 123456var multiLineString = \"\"\"abcdjaki24\"\"\"print(multiLineString) 这种方式可以大大减少在创建字符串时人为添加换行符。 关于String操作的相关API，在Swift4中也有许多优化，例如字符串的下标操作与字符操作一直是Swift语言的硬伤，使用起来十分麻烦，在Swift4中都进行了优化。取字符串的子串的方式也更加规范。 四、增强区间运算符Swift语言中的区间运算符使用起来十分方便，例如在Swift3中，我们若要遍历数组的范围，可以使用如下的代码： 12345//Swift3代码let array = [\"1\",\"2\",\"3\"]for item in array[0..&lt;array.count]&#123; print(item)&#125; Swift3中的…运算符只是作为闭区间运算符使用，在Swift4中，可以用它来取集合类型的边界，如字符串，数组等，看如下代码： 1234let array = [\"1\",\"2\",\"3\"]for item in array[0...]&#123; print(item)&#125; 五、下标方法支持泛型subscript方法可以为Swift中的类添加下标访问的支持，在Swift4中，subscript方法更加强大，其不只可以支持泛型，而且可以支持where子句进行协议中关联类型的约束，示例如下： 123456789101112131415161718192021222324252627282930//下标协议protocol Sub &#123; associatedtype T func getIndex()-&gt;T&#125;//实现下标协议的一种下标类class Index:Sub &#123; init(_ index:Int) &#123; self.index = index &#125; var index:Int func getIndex() -&gt; Int &#123; return self.index &#125;&#125;class MyArray &#123; var array = Array&lt;Int&gt;() func push(item:Int) &#123; self.array.append(item) &#125; //泛型 并进行约束 subscript&lt;T:Sub&gt;(i:T)-&gt;Int where T.T == Int &#123; return self.array[i.getIndex()] &#125;&#125;var a = MyArray()a.push(item: 1)print(a[Index(0)]) 六、协议支持混合Swift在对变量类型进行界定时，是支持使用协议的，例如，在Swift3中，我们可以编写如下的代码： 123456789101112131415161718192021222324//swift3protocol People &#123; var name:String&#123;set get&#125; var age:Int&#123;set get&#125;&#125;protocol Teach &#123; func teachSwift()&#125;class Teacher: People,Teach &#123; var name: String = \"jaki\" var age: Int = 25 func teachSwift() &#123; print(\"teaching...\") &#125;&#125;func printTeacher(p:Teacher) &#123; print(p.name,p.age) p.teachSwift()&#125; 上面的代码中，printTeacher方法里使用Teacher类对参数进行的界定，实际上这种做法并不好，Teacher类知识Teach协议与People协议的一种混合实现，在定义方法参数时，应该使用协议来进行参数的界定，可是Teacher类同时实现了两个协议，这在Swift3版本中是无法解决的问题，在Swift4中你则可以这样写： 1234567891011121314151617181920212223protocol People &#123; var name:String&#123;set get&#125; var age:Int&#123;set get&#125;&#125;protocol Teach &#123; func teachSwift()&#125;class Teacher: People,Teach &#123; var name: String = \"jaki\" var age: Int = 25 func teachSwift() &#123; print(\"teaching...\") &#125;&#125;func printTeacher(p:Teach&amp;People) &#123; print(p.name,p.age) p.teachSwift()&#125; &amp;复合可以对协议进行混合，更加贴近面向协议的编程方式。 七、一点总结从Swift语言第1个版本发布到Swift3和Swift3.2进行了语言内容和风格的大改，Swift4中进行的改动实际并不大而且大多是你开发中可能并用不到的特性。随着Swift语言的成长，这种语言的设计风格是与其他传统语言有着本质的区别，我个人感悟，Swift语言如下的特点确实值得我们学习与思考： 1.安全性极高所谓安全性，实际上就是语言是否容易出错，再通俗一些，即是一种编程语言是依赖其自身特性防止其出错还是依赖开发者经验防止其出错。我记得在初学JavaScript时感觉十分苦恼，因为JavaScript是变量弱类型的，并且其隐式转换十分危险(虽然代码编写起来畅快无比)。在Swift中，则基本不会出现类型不匹配，类型被隐式转换了等问题。当然，换句话说，这也使得编程者必须遵守更多的规则(或者说写更多的代码)，虽然各有利弊，但对初学者来说，Swift明显要友好很多。 Swift语言安全性极高表现在如下几点： 1.用let和var来分别声明常量和变量，let声明的量值不可改，从逻辑上保证变量安全。 2.变量类型必须明确(很多时候你没指定是因为编译器的推断功能)，从类型上保证安全。 3.闭包分为逃逸和非逃逸，从逻辑上保证闭包使用的安全。 4.溢出运算符与算术运算符分开，从代码上保证安全。 5.类的初始化检查策略，从类的定义上保证安全。 6.删除++与–运算符，删除常规for循环，从习惯上保证安全。 2.灵活性极高Swift语言的灵活性非常有现代编程语言的特点，有其是其对泛型的支持，是的面向协议的编程方式在Swift语言上可以畅行无阻。灵活性表现在如下几点： 1.强大的泛型编程方式，协议关联类型等。 2.where子句可以精准的进行泛型约束。 3.Optioal类型和可失败构造方法的支持。 4.Any与AntObject类型的支持。 5.强大的枚举和结构体。 6.递归枚举的支持。 7.支持重载与自定义运算符。 3.编码体验极高编码体验这点并不完全依赖与Swift语法，也多有编译器的功劳。 1.支持字符串内嵌变量来构建字符串。 2.支持后置闭包的写法。 3.元组类型的支持。 4.支持默认隐式拆包类型。 5.支持区间运算符。 6.函数分内外两种参数名(外参数名可以省略)。 7.语法上支持便利构造方法。 8.语法层面支持的懒加载。 上面只是列出了一些特性，Swift语言中有意思的地方多的举不胜举，如果你有意更深入的了解它，你可以搜索清华大学出版社的《Swift从入门到精通》一书，其中是我对Swift3进行的全面讲解，也包含iOS开发的部分知识和实战，你也可以直接通过QQ316045346联系我本人进行交流与互相学习。最后，一语以总结Swift语言：一门十分强大并且十分易入门的现代编程语言，只要你掌握了所有语法规则，想出错很难！","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"挖一挖贝塞尔曲线那些事","slug":"357挖一挖贝塞尔曲线那些事","date":"2017-08-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.374Z","comments":true,"path":"2017/08/23/357挖一挖贝塞尔曲线那些事/","link":"","permalink":"http://huishao.cc/2017/08/23/357挖一挖贝塞尔曲线那些事/","excerpt":"","text":"挖一挖贝塞尔曲线那些事一、前世今生贝塞尔曲线的最初设计是服务于工业设计，尤其应用与汽车曲线设计。随着计算机画图的应用广泛，若想在计算机上画出平滑精准的曲线并不是一件容易的事，贝塞尔曲线解决了这样的问题，贝塞尔虚线通过起始点与结束点来确定曲线的首尾，通过若干个控制点来确定曲线的走向。由于其由法国工程师皮埃尔·贝塞尔广泛推广，因此这种曲线被命名为贝塞尔曲线。 二、数学基础平面上的任意连续曲线可以通过伯恩斯坦多项式来进行逼近拟合，因此，当我们想在平面中画一条曲线的时候，如果可以模拟出此曲线的函数，则可以十分精准的控制计算机来描绘一系列曲线上的点来绘制曲线。贝塞尔曲线就是基于这样的数学基础。 首先，对于一条贝塞尔曲线，其3要素分别是：起始点，结束点和控制点。其中曲线的起点在起始点，终点在结束点，曲线并不穿过控制点，控制点来掌握曲线的走向，控制点个数可以不定。 1、一阶贝塞尔曲线一阶贝塞尔曲线控制点的个数为0，只有起始点与结束点。其实一阶贝塞尔曲线就是一条从起始点到结束点的直线段。其公式如下： 上面公式中，P为曲线上的点，P0为起始点，P1为结束点。(对于平面上的点，分别用上面公式计算x，y坐标即可)。由于其公式为线性公式，所有这种贝塞尔曲线也被称为一阶贝塞尔曲线。下图可以很好的描述当t从0到1变化时，线段的绘制过程： 2、二阶贝塞尔曲线二阶贝塞尔曲线有一个控制点，假设起始点，控制点和结束点分别为P0、P1、P2。连接P0P1，P1P2，在区间0-1之间，在P0P1线段上取点M，在P1P2线段上取点N，使得P0M/P0P1=P1N/P1P2，找到线段MN上一点Q，同时使得MQ/QN=P0M/P0P1=P1N/P1P2，所有Q点的集合即为所求贝塞尔曲线。上面的描述有些抽象，使用数学推导就义一目了然了，公式推导如下： 绘图过程如下： 3.高阶贝塞尔曲线有了一阶与二阶的基础，高阶贝塞尔曲线也是通过相同的方式来推导，一个通用的递推公式如下： 三阶和四阶的绘制过程演示如下： 三、iOS中的贝塞尔曲线的应用虽然贝塞尔曲线在很多开发领域都十分容易实现，由于我对iOS开发比较熟，并且上面的曲线绘制示例也是我通过iOS程序实现的。这里就对在iOS中应用贝塞尔曲线进行简单的讨论，首先CoreGraphics核心图形框架中提供了CGPath可以直接创建贝塞尔曲线，系统支持的贝塞尔曲线函数有二阶与三阶。前面有博客专门讨论，这里就不再赘述，地址如下： https://my.oschina.net/u/2340880/blog/757072。 这里主要列举UIKit框架中的UIBezierPath类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//构造方法+ (instancetype)bezierPath;//使用矩形进行构造+ (instancetype)bezierPathWithRect:(CGRect)rect;//使用圆角矩形进行构造+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;//创建圆角矩形贝塞尔路径 并设置圆角半径+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; + (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;//使用圆弧创建+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;//使用CGPath创建+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;//CGPath对象@property(nonatomic) CGPathRef CGPath;//将路径移动到某个点- (void)moveToPoint:(CGPoint)point;//添加一天线- (void)addLineToPoint:(CGPoint)point;//添加一个二阶贝塞尔曲线段- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;//添加一个三阶贝塞尔曲线段- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;//添加圆弧- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;//关闭路径- (void)closePath;//移除所有点- (void)removeAllPoints;//添加一段路径- (void)appendPath:(UIBezierPath *)bezierPath;//对路径进行逆向- (UIBezierPath *)bezierPathByReversingPath;//进行transform变换- (void)applyTransform:(CGAffineTransform)transform;//路径是否为空@property(readonly,getter=isEmpty) BOOL empty;//尺寸@property(nonatomic,readonly) CGRect bounds;//当前点@property(nonatomic,readonly) CGPoint currentPoint;//判断是否包含某个点- (BOOL)containsPoint:(CGPoint)point;//设置线宽@property(nonatomic) CGFloat lineWidth;//设置线帽风格@property(nonatomic) CGLineCap lineCapStyle;//设置折点风格@property(nonatomic) CGLineJoin lineJoinStyle;@property(nonatomic) CGFloat miterLimit;@property(nonatomic) CGFloat flatness;//奇偶规则@property(nonatomic) BOOL usesEvenOddFillRule;//进行虚线设置- (void)setLineDash:(nullable const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase;- (void)getLineDash:(nullable CGFloat *)pattern count:(nullable NSInteger *)count phase:(nullable CGFloat *)phase;//进行填充绘制- (void)fill;//进行路径绘制- (void)stroke; 四、示例程序下面是一个iOS平台的演示小Demo，使用它可以动态进行贝塞尔曲线的绘制并观察到辅助线与绘制过程，可以灵活的配置绘制的速度和控制点： Github地址如下： https://github.com/ZYHshao/Bezel。","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"iOS应用内评价与购买三方APP组件","slug":"356iOS应用内评价与购买三方APP组件","date":"2017-08-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.374Z","comments":true,"path":"2017/08/21/356iOS应用内评价与购买三方APP组件/","link":"","permalink":"http://huishao.cc/2017/08/21/356iOS应用内评价与购买三方APP组件/","excerpt":"","text":"iOS应用内评价与购买三方APP组件首先来说应用内评价组件，应用内评价组件是iOS10.3中新引入的功能。其封装在StoreKit框架中。用户可以直接在APP内唤起评价组件对应用程序进行评星，示例代码如下： 1[SKStoreReviewController requestReview]; 效果如下图： 在模拟器上，这个Submit按钮是不可点击的，如果在真机上，并且应用程序已经上线，可以直接进行评价。这个方便的评价组件可以避免让用户跳出APP进行评价的不好体验。 SKStoreReviewController中只有requestReview这一个类方法，需要注意，只有在iOS10.3后才可以使用。但是StoreKit这个框架很早就有了。里面还有一个类可以让用户直接在应用内打开一个第三方应用的AppStore购买页。示例代码如下： 12345SKStoreProductViewController * controller = [[SKStoreProductViewController alloc]init];[self presentViewController:controller animated:YES completion:nil];[controller loadProductWithParameters:@&#123;SKStoreProductParameterITunesItemIdentifier:@(321231)&#125; completionBlock:^(BOOL result, NSError * _Nullable error) &#123; &#125;]; 上面代码SKStoreProuctViewController是应用程序购买页视图控制器，其调用loadProductWithParameters方法进行页面的加载，这个方法有两个参数，第1个参数用来设置配置字典，第2个参数回调Block来告诉开发者页面的加载是否成功。关于配置字典，有如下键值对可用： 12345678910//设置要加载的APPID NSNumber类型SKStoreProductParameterITunesItemIdentifier//广告tokenSKStoreProductParameterAdvertisingPartnerToken//affiliate tokenSKStoreProductParameterAffiliateToken//CampaignTokenSKStoreProductParameterCampaignToken//ProviderTokenSKStoreProductParameterProviderToken 再多说一点，关于appid的获取，可以直接在https://linkmaker.itunes.apple.com/。网站进行搜索，之后可以获取到应用的下载url地址，这个url地址是被编码过的，解码后其中的参数即有appid值。","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"一个移动开发者的Mock数据之路","slug":"355一个移动开发者的Mock数据之路","date":"2017-08-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.373Z","comments":true,"path":"2017/08/20/355一个移动开发者的Mock数据之路/","link":"","permalink":"http://huishao.cc/2017/08/20/355一个移动开发者的Mock数据之路/","excerpt":"","text":"一个移动开发者的Mock数据之路一、始由在前端开发中，很大一部分工作都是将后台数据获取到后展示在前端界面上。如果接口是现成的，这个过程还相对容易一些，但是如果接口的开发和前端开发是同时进行的，在仅仅有接口文档并无测试环境的情况下，前端开发者就要痛苦了，所得非所见的盲写方式不但效率低下，也有很大的遗漏风险。如果我们有办法自己根据接口文档模拟这些数据，那开发过程中的体验就会好很多了。幸运的是，通过node.js，express和mock.js，我们可以非常容易的进行数据Mock。 二、准备工作1.node.js首先你需要安装node.js，node.js是一个JavaScript运行环境，在其官网可以十分方便的进行下载安装：http://nodejs.cn/。 2.expressexpress是一个基于Node平台的Web开发框架，使用它可以十分方便的搭建本地的web服务，用来部署我们的Mock数据，express可以通过npm来进行安装，官网如下：http://www.expressjs.com.cn/。其中的详细的安装方法。 3.mock.jsmock.js是一个模拟数据结构，生成随机数据的js库。其有一套语法规则用来模拟结构和生成数据。其官网如下，安装过程也十分简单：http://mockjs.com/。 三、Mock.js语法规则及范例对于Mock数据，最重要的是掌握和灵活运用Mock.js的语法规则，能够熟练的编写出Mock数据结构必备的技能。在Mock.js中，语法规则主要分为两块：数据模板和数据占位符。 1.数据模板数据版本主要的作用是用来生成数据结构。数据模板的组成由如下三部分：属性名，生成规则和属性值。在语法上的结构如下： 属性名|生成规则:属性值 最简单的数据模板是不使用生成规则，直接用字面量来表示，代码如下： 123&#123;name:'珲少'&#125; 生成的mock数据如下所示： 对于模拟字符串类型的数据，有两种模板可以定义： 模板1：’属性名|min-max’:属性值 通过重复一个字符串min到max次之间来生成数据。示例： 123&#123;'name|1-10':'珲少'&#125; 生成的mock数据如下： 模板2：’属性名|count’:属性值 通过重复一个字符串count次来生成数据。示例： 1234&#123;'name|1-10':'珲少','moreName|10':'珲少'&#125; 生成数据如下图所示： 对于模拟数值类型的数据，有3种模板可以定义： 模板1：’属性名|+1’:属性值 属性值自动自增，示例如下： 123456789&#123;'array|1-10':[ &#123; 'name|1-10':'珲少', 'moreName|10':'珲少', 'id|+1':0 &#125;]&#125; 生成数据如下图所示： 模板2：’属性名|min-max’:属性值 生成在min到max之间的整数，代码如下： 12345678910&#123;'array|1-5':[ &#123; 'name|1-10':'珲少', 'moreName|10':'珲少', 'id|+1':0, 'age|20-25':20 &#125;]&#125; 效果如下图所示： 模板3：’属性名|min-max.dmin-dmax’:属性值 生成浮点数，整数部分在min到max之间，小数部分保留dmin到dmax位，示例如下： 1234567891011&#123;'array|1-5':[ &#123; 'name|1-10':'珲少', 'moreName|10':'珲少', 'id|+1':0, 'age|20-25':20, 'weight|60-70.1-4':60 &#125;]&#125; 生成数据如下： 对于模拟布尔类型的数据，有两种模板可以定义： 模板1：’属性名|1’:属性值 随机生成一个布尔值，例如： 123456789101112&#123;'array|1-5':[ &#123; 'name|1-10':'珲少', 'moreName|10':'珲少', 'id|+1':0, 'age|20-25':20, 'weight|60-70.1-4':60, 'isWiner|1':true &#125;]&#125; 生成的数据如下： 模板2：’属性名|min-max’:属性值 随机生成一个布尔值，值和属性值相同的概率为min/(min+max)，值与属性值不同的概率为max/(min+max)。 对于模拟对象类型的数据，有两种模板可以定义： 模板1：’属性名|count’:属性值 最终生成的对象的属性为从属性值中随机取count个属性，例如： 123456789101112131415161718&#123;'array|1-5':[ &#123; 'name|1-10':'珲少', 'moreName|10':'珲少', 'id|+1':0, 'age|20-25':20, 'weight|60-70.1-4':60, 'isWiner|1':true, 'job|3':&#123; num:1234, address:'xxxxx', phone:12321, name:'cjj' &#125; &#125;]&#125; 生成的数据如下： 模板2：’属性名|min-max’:属性值 从属性值的属性中随机取min到max个作为最终生成的对象属性。 对于模拟数组类型的数据，有4种模板可以定义： 模板1：’属性名|1’:属性值 从属性值数组中随机取1个值作为最终值。 模板2：’属性名|+1’:属性值 从属性值数组中依次取1个值作为最终值。 模板3：’属性名|min-max’:属性值 通过重复min到max此属性值生成一个数组。 模板4：’属性名|count’:属性值 通过重复count此属性值生成数组。 除了上面列举的创建模板的方式外，还可以使用函数值和正则表达式值作为模板，如果是函数，则生成的值为函数的返回值，如果是正则表达式，则生成的值为可匹配的字符串。 2.数据占位符数据占位符实际上就是指定生成的随机数据，它和Mock.Random库中的生成随机数据方法一一对应，其可以模拟邮箱地址，电话号，姓名，行段等各种数据。数据占位符格式如下： @方法名 或 @方法名(参数) 模拟布尔类型数据： 1.无参：boolean随机返回一个布尔值，示例如下： 123456789101112131415161718&#123;'array|1-5':[ &#123; 'name|1-10':'珲少', 'moreName|10':'珲少', 'id|+1':0, 'age|20-25':20, 'weight|60-70.1-4':60, 'isWiner|1':'@boolean', 'job|3':&#123; num:1234, address:'xxxxx', phone:12321, name:'cjj' &#125; &#125;]&#125; 2.有参：boolean(min,max,current)，指定current出现的概率。 模拟随机自然数： 1.无参：natural随机返回一个大于等于0的整数，示例如下： 123456789101112131415161718&#123;'array|1-5':[ &#123; 'name|1-10':'珲少', 'moreName|10':'珲少', 'id|+1':0, 'age|20-25':20, 'weight|60-70.1-4':60, 'isWiner|1':'@boolean', 'job|3':&#123; num:'@natural', address:'xxxxx', phone:12321, name:'cjj' &#125; &#125;]&#125; 生成数据如下： 2.有参数：natural(nim,max)，随机生成一个在min与max之间的自然数。 模拟随机整数： 1.无参：integer随机生成一个整数。 2.有参：interger(min,max)，随机生成一个在min到max之间的整数。 模拟随机浮点数： 1.无参：float随机生成一个浮点数。 2.有参：float(min,max,dmin,dmax)，随机生成一个整数部分在min到max之间，小数位数为dmin到dmax之间的浮点数。 模拟随机字符： 1.无参：character随机生成一个字符。 2.有参：character(cs),cs为一个字符串，生成的字符从cs字符串中任取一个，如果传入的cs字符串为一下其中之一，则表示从内置字符集中选： lower：小写字母 upper：大写字符 number：数值字符 symbol：系统字符 模拟随机字符串： 1.无参：string随机生成一个字符串。 2.有参： 格式1：string(length)生成指定长度的字符串。 格式2：string(cs,length)从cs字符池中生成指定长度字符串。 格式3：string(min,max)生成长度在min到max之间的字符串。 格式4：string(cs,min,max)从cs字符集中生成长度在min到max之间的字符串。 模拟整型数组： 有参： 格式1：range(stop)生成一个整型数组，stop为数组中的数值结束边界。 格式2：range(start,stop)start为数值的起始边界，stop为数组中的数值结束边界。 格式3：range(start,stop,step)start为数值的起始边界，stop为数值的结束边界，step为步长。 示例： 12345678910111213141516171819&#123;'array|1-5':[ &#123; 'name|1-10':'珲少', 'moreName|10':'珲少', 'id|+1':0, 'age|20-25':20, 'weight|60-70.1-4':60, 'isWiner|1':'@boolean', 'job|3':&#123; num:'@natural', address:'xxxxx', phone:12321, name:'@string(3)' &#125;, node:'@range(3,5,1)' &#125;]&#125; 模拟日期字符串： 1.无参：date随机生成一个日期字符串。 2.有参：date(format)format用来设置如期字符串的格式，例如： 12345678&#123; 'data|3-5':[ &#123; time:'@date', ctime:'@date(yyyy-MM-dd HH-mm-ss A)' &#125; ]&#125; 生成数据如下： 模拟时间字符串： 1.无参：time直接生成一个时间字符串。 2.有参：time(format)生成格式化的时间字符串。 模拟日期时间字符串： 1.无参：detetime生成默认格式的日期时间字符串。 2.有参：datetime(format)生成指定格式的日期时间字符串。 模拟当前日期字符串： 1.无参：now生成当前日期时间字符串。 2.有参： 格式1：now(unit,format)，unit设置时间单位，format设置格式化方式。时间单位可选：year，month，week，day，hour，minute，second。 格式2：now(format) 格式3：now（unit） 模拟图片素材： 1.无参：iamge随机生成一个尺寸的图片地址，此地址可以直接请求到图像。例如： 123456789&#123; 'data|3-5':[ &#123; time:'@date', expriseTime:'@datetime', image:'@image' &#125; ]&#125; 生成数据如下： 2.有参： 格式1：image(size,background,foreground,format,text)，size指定图片的尺寸，格式为300x250，background指定图片的背景色，foreground指定图片的前景色，format指定图片的格式，可选png、gif、jpg，text参数指定图片上的文字。 格式2：image(size) 格式3：image(size,background) 格式4：image(size,background,foreground) 格式5：image(size,background,foreground,text) 模拟图片二进制素材数据： 1.无参：dataImage生成随机的base64图像编码。 2.有参： 格式1：dataImage(size,text)，size参数这是图片尺寸，text参数设置图片上的文字。 格式2：dataImage(size) 模拟颜色字符串的相关占位符： 1.color：随机生成格式为“#rrggbb”的颜色。 2.hex：随机生成格式为“#rrggbb”的颜色值。 3.rgb：随机生成格式为“rgb(r,g,b)”的颜色值。 4.rgba：随机生成格式为“rgba(r,g,b,a)”的颜色值。 5.hsl：随机生成格式为“hsl(h,s,l)”的颜色值。 模拟英文文本段落： 1.无参：paragraph随机生成一段文本。 2.有参： 格式1：paragraph(min,max)随机生成一段文本，句子个数在min于max之间。 格式2：paragraph(len)随机生成一段文本，len设置句子个数，示例如下： 12345678910&#123; 'data|3-5':[ &#123; time:'@date', expriseTime:'@datetime', image:'@image(\"300x250\",\"#222312\",\"#f1f2f3\",\"jpg\",\"image\")' , content:'@paragraph(1,3)' &#125; ]&#125; 生成的随机数据如下： 模拟中文文本段落： 1.无参：cparagraph随机生成中文段落 2.有参： 格式1：cparagraph(min,max) 格式2：cparagraph(len) 模拟英文句子： 1.无参：sentence随机生成一句文本，首字母会大写。 2.有参： 格式1：sentence(min,max)，随机生成一句文本，文本中单词个数为min到max之间。 格式2：sentence(len)，随机生成一句文本，文本中单词个数为len。 模拟中文句子： 1.无参：csentence随机生成一句中文文本。 2.有参： 格式1：csentence(min,max) 格式2：csentence(len) 模拟英文单词： 1.无参：word随机生成一个单词。 2.有参： 格式1：word(min,max)，生成单词中字符个数为min到max之间。 格式2：word(len)，生成单词中字符个数为len。 模拟中文词： 1.无参：cword随机生成一个汉字。 2.有参： 格式1：cword(pool)，pool为汉字字符串，从pool字符池中选取一个汉字。 格式2：cword(length)，随机生成一个词，汉字个数为length。 格式3：cword(min,max)，随机生成一个词，汉字个数为min到max之间。 格式4：cword(pool,length) 格式5：cword(pool,min,max) 模拟标题： 1.无参：title随机生成标题。 2.有参： 格式1：title(len)生成单词个数为len的标题。 格式2：title(min,max)生成单词个数为min到max之间的标题。 模拟中文标题： 1.无参：ctitle 2.有参： 格式1：ctitle(len) 格式2：ctitle(min,max) 模拟姓名相关的占位符： 1.first随机生成常见的英文名。 2.last随机生成常见的英文姓。 3.name(middle)，随机生成一个英文姓名，middle为布尔参数，设置是否生成中间名。 4.cfirst随机生成一个中文姓。 5.clast随机生成一个中文名。 6.cname随机生成一个中文姓名。 模拟网址相关占位符： 1.url(protocol,host)随机生成一个url，protocol指定协议，host指定主机，也可以无参。 2.protocol随机生成一个url协议，例如http。 3.domain随机生成一个域名。 4.tld随机生成一个顶级域名。 5.email(domain)随机生成一个email地址，domain指定域名，也可以无参。 6.ip随机生成一个ip地址。 模拟地址相关占位符： 1.region随机生成一个中国区域，例如华北。 2.province随机生成一个中国省份。 3.city(pro)随机生成一个中国城市，pro为布尔值，指定是否生成其所在的省份，也可以无参。 4.county(all)随机生成一个中国县，all为布尔值，指定是否生成其所在的省市。也可以无参。 5.zip随机生成一个邮编。 模拟id相关占位符： 1.guid随机生成一个GUID。 2.id随机生成一个18位身份证号。 四、一个用express搭建Mock服务的示例1234567891011121314151617181920var express = require('express');var app = express();var Mock = require('mockjs');app.get('/mock', function(req, res)&#123; var data = Mock.mock(&#123; \"name\":'@cname', \"content\":'@string(0, 5)', &#125;); response = &#123; \"data\":data &#125; res.end(JSON.stringify(response));&#125;);var server = app.listen(8082, function()&#123; var host = server.address().address var port = server.address().port&#125;) 上面代码开启了一个get请求，如果正确安装了node，express，mock.js，使用node运行此文件后直接在浏览器通过127.0.0.1:8082/mock地址进行访问即可看到生成的mock数据。 Mock数据的初衷是在前端开发中进行接口的模拟使用，在接口结构和访问url都已经确定，只是没开发完成是，可以使用Charles结合Mock数据来仿真接口返回。Charles工具可以将某个请求映射到另外一个地址上，在Charles抓到的请求上邮件，弹出的菜单中选择Map Remote选项。 在弹出的窗口中将映射到的主机设置为127.0.0.1，端口设置为8082，地址设置为mock即可访问上面文件生成的模拟数据。 五、一个方便易用的Java模拟数据客户端有时候我们需要mock的接口有很多，如果能够方便的对这些mock文件进行管理不用每次都通过终端来操作就更方便了。这里有我写的一个JAR小工具，可以在Mac或Windows上扩平台进行使用。下载地址如下： http://zyhshao.github.io/EasyMock/welcome.html。 这个工具就是一个简单的JAR包，在其中封装了操作终端的命名，只需要在左右列表中创建相应的请求路径，在右侧直接编写Mock.js模拟数据对象后，开启服务即可，开启服务后会将左右列表中所有的接口都开启。如下图： 还需要注意，这个工具不十分完善，如果有产生错误会被捕获但并没有任何提示，如果你没正确安装node或者express或者mock.js，再或者你的mock.js代码有问题，服务都不能正确启动。","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"将iOS项目进行子工程化","slug":"354将iOS项目进行子工程化","date":"2017-07-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.373Z","comments":true,"path":"2017/07/26/354将iOS项目进行子工程化/","link":"","permalink":"http://huishao.cc/2017/07/26/354将iOS项目进行子工程化/","excerpt":"","text":"将iOS项目进行子工程化在iOS项目开发中，随着项目的越来越大，工程的结构化会变差，编译的速度也会越来越慢。使用静态库或动态库的方式来构建子工程不仅可以加快项目的编译速度，从结构上，也优化了项目的组织。有两种方式来来对项目进行子工程化，可以在项目中创建子项目，也可以创建并列的项目，建立项目依赖。需要注意，无论哪种方式，你都应该尽量保证子工程不要用到主工程中的内容，如果必须这样做，你可以采用代理或其他回调编程方式来转交给主工程自己处理。 一、创建子工程的一个示例使用Xcode新建一个命名为ProjectDemo的工程，在ProjectDemo工程中再次新建一个framework库工程，点击新建文件中的Project...选项，选择其中的Cocoa Touch Framework工程(创建Cocoa Touch Static Library则会打包为静态库)。 将新创建的工程命名为LoginLib，用来模拟项目中的登录模块。需要注意，新建工程时，需要将其加入ProjectDemo组，如下图： 对于创建的LoginLib工程，你可以创建一个LoginLib.h头文件用来公开外界需要使用到的类，便于演示，我在里面创建一个视图控制器和一个类别工具类，结构如下： 配置LoginLib的头文件选项，将外界需要用到的进行公开，如下： 现在，分别编译LoginLib工程和ProjectDemo工程，都没有问题，但是你依然无法在ProjectDemo工程中使用LoginLib库中的内容，你需要建立主子工程的关联，在ProjectDemo工程中建立依赖工程并接入动态库，如下所示： 配置Target Dependencies的作用是确保每次主工程编译前都会先对所依赖的工程进行编译。之后，在ProjectDemo工程中导入LoginLib相关头文件即可使用其中功能。 注意，如果报错找不到头文件，你需要设置一下头文件的寻找路径，在ProjectDemo的Build Setting中搜索header，如下图 设置Header Search Paths如下即可。 二、创建依赖模块工程的一个示例开发中还有一种场景，公司可能有一组App，这些App中可能有很多相似的模块，例如某些应用程序分为用户端和老板端，他们都有相同的登录模块，我们可以使用workspace来进行项目和模块的管理。新建一个文件夹命名为Projects，在其中创建一个workspace文件，也命名为Projects。在workspace文件中新建两个项目工程和一个动态库工程，在创建时，注意选择加入workspace，如下图： 创建的3个工程分别命名为UserProject，BossProject和LoginLib，结构如下： 类似我们的第一个示例，配置完头文件路径后，将动态库引入UserProject和BossProject工程，即实现了LoginLib模块的复用。 三、如果子工程只能够有资源文件如果子工程中有资源文件，无论是plist文件还是图片素材，在主工程调用动态库时，这些文件都是没有被打包进来的。有两种方式来处理这个问题： 1.将资源文件打包成Bundle包，从包中取资源Xcode可以创建Bundle资源包，这种文件创建后编译时会自动打包成Bundle文件。需要注意，Xcode只能创建MacOS下的Bundle模板，创建后需要将编译选项设置为iOS。这种方式有很大的弊端，首先主工程必须引入编译后的Bundle包，如果每次新增或修改资源，都要重新打包和导入。其次，在子工程中对素材进行使用时，都必须以Bundle为媒介，增加的复杂度。 2.使用shell拷贝资源脚本这种方式每次在编译时都会将资源进行拷贝，类似CocoaPods的管理模式，推荐使用。例如，在主工程的编译选项中新建一个脚本文件，如图： 编写如下脚本代码即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#!/bin/sh# set -emkdir -p \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;\"install_resource()&#123; if [[ \"$1\" = /* ]] ; then RESOURCE_PATH=\"$1\" fi if [[ ! -e \"$RESOURCE_PATH\" ]] ; then cat &lt;&lt; EOMerror: Resource \"$RESOURCE_PATH\" not found.EOM exit 1 fi case $RESOURCE_PATH in *.storyboard) echo \"ibtool --reference-external-strings-file --errors --warnings --notices --minimum-deployment-target $&#123;!DEPLOYMENT_TARGET_SETTING_NAME&#125; --output-format human-readable-text --compile $&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \\\"$RESOURCE_PATH\\\" .storyboard`.storyboardc $RESOURCE_PATH --sdk $&#123;SDKROOT&#125; $&#123;TARGET_DEVICE_ARGS&#125;\" ibtool --reference-external-strings-file --errors --warnings --notices --minimum-deployment-target $&#123;!DEPLOYMENT_TARGET_SETTING_NAME&#125; --output-format human-readable-text --compile \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \\\"$RESOURCE_PATH\\\" .storyboard`.storyboardc\" \"$RESOURCE_PATH\" --sdk \"$&#123;SDKROOT&#125;\" $&#123;TARGET_DEVICE_ARGS&#125; ;; *.xib) echo \"ibtool --reference-external-strings-file --errors --warnings --notices --minimum-deployment-target $&#123;!DEPLOYMENT_TARGET_SETTING_NAME&#125; --output-format human-readable-text --compile $&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \\\"$RESOURCE_PATH\\\" .xib`.nib $RESOURCE_PATH --sdk $&#123;SDKROOT&#125; $&#123;TARGET_DEVICE_ARGS&#125;\" ibtool --reference-external-strings-file --errors --warnings --notices --minimum-deployment-target $&#123;!DEPLOYMENT_TARGET_SETTING_NAME&#125; --output-format human-readable-text --compile \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \\\"$RESOURCE_PATH\\\" .xib`.nib\" \"$RESOURCE_PATH\" --sdk \"$&#123;SDKROOT&#125;\" $&#123;TARGET_DEVICE_ARGS&#125; ;; *.framework) echo \"mkdir -p $&#123;TARGET_BUILD_DIR&#125;/$&#123;FRAMEWORKS_FOLDER_PATH&#125;\" mkdir -p \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;FRAMEWORKS_FOLDER_PATH&#125;\" echo \"rsync -av $RESOURCE_PATH $&#123;TARGET_BUILD_DIR&#125;/$&#123;FRAMEWORKS_FOLDER_PATH&#125;\" rsync -av \"$RESOURCE_PATH\" \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;FRAMEWORKS_FOLDER_PATH&#125;\" ;; *.xcdatamodel) echo \"xcrun momc \\\"$RESOURCE_PATH\\\" \\\"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \"$RESOURCE_PATH\"`.mom\\\"\" xcrun momc \"$RESOURCE_PATH\" \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \"$RESOURCE_PATH\" .xcdatamodel`.mom\" ;; *.xcdatamodeld) echo \"xcrun momc \\\"$RESOURCE_PATH\\\" \\\"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \"$RESOURCE_PATH\" .xcdatamodeld`.momd\\\"\" xcrun momc \"$RESOURCE_PATH\" \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \"$RESOURCE_PATH\" .xcdatamodeld`.momd\" ;; *.xcmappingmodel) echo \"xcrun mapc \\\"$RESOURCE_PATH\\\" \\\"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \"$RESOURCE_PATH\" .xcmappingmodel`.cdm\\\"\" xcrun mapc \"$RESOURCE_PATH\" \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/`basename \"$RESOURCE_PATH\" .xcmappingmodel`.cdm\" ;; *.xcassets) echo \"all xcassets will compile later!\" ;; *) echo \"$RESOURCE_PATH\" echo \"$RESOURCE_PATH\" &gt;&gt; \"$RESOURCES_TO_COPY\" ;; esac&#125;install_project_resouces()&#123; PROJECT_RESOURCE_DIR=\"$&#123;PROJECT_DIR&#125;/../$1\" if [[ ! -e \"$&#123;PROJECT_RESOURCE_DIR&#125;\" ]]; then cat &lt;&lt; EOMerror: PROJECT_RESOURCE_DIR \"$&#123;PROJECT_RESOURCE_DIR&#125;\" not foundEOM exit 1 fi echo \"copy resources in $&#123;PROJECT_RESOURCE_DIR&#125; to $&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;\" ALL_RESOURCES=() FIND_ALL_RESOURCES=$(find \"$PROJECT_RESOURCE_DIR\" -iname \"*.xcassets\" -o -iname \"*.xib\" -o -iname \"*.storyboard\" -o -iname \"*.plist\" ! -iname \"Info.plist\") while read line; do ALL_RESOURCES+=(\"$line\") done &lt;&lt;&lt;\"$FIND_ALL_RESOURCES\" RESOURCES_TO_COPY=\"$&#123;PROJECT_RESOURCE_DIR&#125;/resources-to-copy.txt\" &gt; \"$RESOURCES_TO_COPY\" case \"$&#123;TARGETED_DEVICE_FAMILY&#125;\" in 1,2) TARGET_DEVICE_ARGS=\"--target-device ipad --target-device iphone\" ;; 1) TARGET_DEVICE_ARGS=\"--target-device iphone\" ;; 2) TARGET_DEVICE_ARGS=\"--target-device ipad\" ;; 3) TARGET_DEVICE_ARGS=\"--target-device tv\" ;; *) TARGET_DEVICE_ARGS=\"--target-device mac\" ;; esac for i in $&#123;ALL_RESOURCES[@]&#125;; do install_resource \"$&#123;i&#125;\" done mkdir -p \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;\" rsync -avr --copy-links --no-relative --exclude '*/.svn/*' --files-from=\"$RESOURCES_TO_COPY\" / \"$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;\" if [[ \"$&#123;ACTION&#125;\" == \"install\" ]] &amp;&amp; [[ \"$&#123;SKIP_INSTALL&#125;\" == \"NO\" ]]; then mkdir -p \"$&#123;INSTALL_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;\" rsync -avr --copy-links --no-relative --exclude '*/.svn/*' --files-from=\"$RESOURCES_TO_COPY\" / \"$&#123;INSTALL_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;\" fi rm -f \"$RESOURCES_TO_COPY\"&#125;for module in $&#123;MODULES&#125;; do install_project_resouces \"$&#123;module&#125;\"doneXCASSETS_SEARCH_DIR=\"$&#123;PROJECT_DIR&#125;/..\"XCASSET_FILES=()if [[ -n \"$&#123;WRAPPER_EXTENSION&#125;\" ]] &amp;&amp; [ \"`xcrun --find actool`\" ]then # Find all other xcassets (this unfortunately includes those of path pods and other targets). ALL_XCASSETS=$(find \"$XCASSETS_SEARCH_DIR\" -iname \"*.xcassets\" -type d) while read line; do if [[ $line != \"$&#123;PODS_ROOT&#125;*\" ]]; then XCASSET_FILES+=(\"$line\") fi done &lt;&lt;&lt;\"$ALL_XCASSETS\" echo \"compile all xcassets: $&#123;XCASSET_FILES[@]&#125;\" printf \"%s\\0\" \"$&#123;XCASSET_FILES[@]&#125;\" | xargs -0 xcrun actool --output-format human-readable-text --notices --warnings --platform \"$&#123;PLATFORM_NAME&#125;\" --minimum-deployment-target \"$&#123;!DEPLOYMENT_TARGET_SETTING_NAME&#125;\" $&#123;TARGET_DEVICE_ARGS&#125; --compress-pngs --compile \"$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;\"fiecho \"all done!\" 四、一点小体悟本博客所讨论的，只是从工程结构上实现模块化与组件化的方式，一个公司可能会有很多个App产品，但其中一定有某些基础模块是可以复用的，除了进行静态库封装或动态库封装外，进行并列工程化也是一种很好的选择，这样可以同步开发，迭代更快。除了公用的模块，还有一些模块可能并不公用但是确可以独立开发，例如资讯类项目中可能会有用户模块，社交模块和内容模块，将这些拆分为项目内的子工程可以使项目的结构更加清晰，模块化测试也更容易进行。 最后，仅仅项目结构上的模块化远远达不到真正实现组件化项目的要求，遵守协议为标准，以函数式编程为方式，全局着眼的接口设计与路由规划，良好的编程习惯与统一的代码风格，这种代码层面的项目开发管理才真正任重道远。后面有时间我会陆续通过其他博客来探讨这些问题。希望一起交流，共同学习！","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"OS X开发：下拉菜单按钮NSPopUpButton应用","slug":"352OS X开发：下拉菜单按钮NSPopUpButton应用","date":"2017-07-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.373Z","comments":true,"path":"2017/07/24/352OS X开发：下拉菜单按钮NSPopUpButton应用/","link":"","permalink":"http://huishao.cc/2017/07/24/352OS X开发：下拉菜单按钮NSPopUpButton应用/","excerpt":"","text":"OS X开发：下拉菜单按钮NSPopUpButton应用NSPopUpButton是一个下拉按钮，当用户点击时，其会弹出一个下拉选择菜单。一个简单的示例如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; NSPopUpButton * popUpButton = [[NSPopUpButton alloc]initWithFrame:CGRectMake(100, 400, 200, 300)]; //设置弹出菜单 NSMenu * menu = [[NSMenu alloc]initWithTitle:@\"menu\"]; [menu insertItemWithTitle:@\"one\" action:@selector(null) keyEquivalent:@\"\" atIndex:0]; [menu addItemWithTitle:@\"two\" action:@selector(null) keyEquivalent:@\"\"]; popUpButton.menu = menu; //设置弹出菜单的位置 popUpButton.preferredEdge = NSRectEdgeMaxX; [self.view addSubview:popUpButton];&#125; 效果如下图所示： NSPopUpButton继承与NSButton，因此NSButton添加触发事件的方式在NSPopUpButton中依然使用，NSPopUpButton类中属性和方法解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//初始化方法 flag参数决定是下拉菜单模式还是弹出菜单模式- (instancetype)initWithFrame:(NSRect)buttonFrame pullsDown:(BOOL)flag;//设置下拉菜单@property (nullable, strong) NSMenu *menu;//设置当交互事件发生时，是否禁用选项@property BOOL autoenablesItems;//风格设置是否为下拉菜单@property BOOL pullsDown;//设置菜单弹出的优先位置@property NSRectEdge preferredEdge;//列表按钮相关//添加一个按钮- (void)addItemsWithTitles:(NSArray&lt;NSString *&gt; *)itemTitles;//插入一个按钮- (void)insertItemWithTitle:(NSString *)title atIndex:(NSInteger)index;//通过标题移除一个按钮- (void)removeItemWithTitle:(NSString *)title;//通过索引移除按钮- (void)removeItemAtIndex:(NSInteger)index;//移除所有按钮- (void)removeAllItems;//所有列表选项按钮数组@property (readonly, copy) NSArray&lt;NSMenuItem *&gt; *itemArray;//按钮个数@property (readonly) NSInteger numberOfItems;//获取按钮索引的方法- (NSInteger)indexOfItem:(NSMenuItem *)item;- (NSInteger)indexOfItemWithTitle:(NSString *)title;- (NSInteger)indexOfItemWithTag:(NSInteger)tag;- (NSInteger)indexOfItemWithRepresentedObject:(nullable id)obj;- (NSInteger)indexOfItemWithTarget:(nullable id)target andAction:(nullable SEL)actionSelector;//获取按钮的方法- (nullable NSMenuItem *)itemAtIndex:(NSInteger)index;- (nullable NSMenuItem *)itemWithTitle:(NSString *)title;//获取最后一个按钮@property (nullable, readonly, strong) NSMenuItem *lastItem;//选择某个按钮的方法- (void)selectItem:(nullable NSMenuItem *)item;- (void)selectItemAtIndex:(NSInteger)index;- (void)selectItemWithTitle:(NSString *)title;- (BOOL)selectItemWithTag:(NSInteger)tag;- (void)setTitle:(NSString *)string;//获取选中的按钮@property (nullable, readonly, strong) NSMenuItem *selectedItem;//获取已经选中的按钮索引@property (readonly) NSInteger indexOfSelectedItem;//获取已经选中的按钮tag@property (readonly) NSInteger selectedTag;//将选中的标题显示进行同步- (void)synchronizeTitleAndSelectedItem;//获取某个索引按钮的标题- (NSString *)itemTitleAtIndex:(NSInteger)index;//获取按钮标题数组@property (readonly, copy) NSArray&lt;NSString *&gt; *itemTitles;//获取选中的按钮标题@property (nullable, readonly, copy) NSString *titleOfSelectedItem;//当下拉菜单弹出时发送的通知APPKIT_EXTERN NSNotificationName NSPopUpButtonWillPopUpNotification;","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"自己动手设计一款iOS自动构建发布工具","slug":"353自己动手设计一款iOS自动构建发布工具","date":"2017-07-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.373Z","comments":true,"path":"2017/07/24/353自己动手设计一款iOS自动构建发布工具/","link":"","permalink":"http://huishao.cc/2017/07/24/353自己动手设计一款iOS自动构建发布工具/","excerpt":"","text":"自己动手设计一款iOS自动构建发布工具一、引言在iOS开发中，你可能经常会遇到这样的场景： 自己负责的功能模块开发完成后，将其合并到测试分支，然后打测试包给测试安装。测试发现bug，这时你可能正在开发分支上做其他的事情，但是你需要修改了bug，提交到测试分支，再次打测试包给测试人员使用。反反复复的切换分支，反反复复的构建打包将浪费你大量的时间，作为一名工程师，最不能容忍的便是在重复的事情上浪费时间。于是，你想，我可以自己动手写一个自动构建发布的小工具。 本篇博客就是基于上面的想法，给大家介绍编写一个简洁的自动化工具的具体步骤与核心要点。在编写本博客时，我也基于这样的想法开发了一款Mac上的iOS自动构建，打包，发布工具，并且将代码开源在Github，如果有兴趣，你也可以作为参考。 二、需求分析开发工具也是一种产品，在开始做一件产品之前，需求分析是十分重要的步骤。商业产品的需求者是用户，而开发工具的需求者就是你自己。首先，结合工作需要，一款自动化构建工具应该至少满足如下这些功能需求： 1.它应该支持多个项目同时进行自动化构建。 2.应该可以方便的新增与删除项目。 3.它应该具备Git操作能力，自动选择合适的分支进行构建。 4.它需要调用Xcode命令来完成打包工作。 5.它具备发布到第三方平台的能力(例如蒲公英)。 6.它可以灵活的进行模式配置，Git模块，Xcode构建模块和发布模块可以自由组合。 7.它应该有一个输出窗口，可以让使用者获取构建的进度以及log日志。 8.它有记忆功能，会将配置信息保存到本地。 上面列出的功能点是这个自动化构建工具的一些基础功能，实现了这些功能，你的软件便可以正式的投入使用，但是它并不完善，你可以在自己规划的第二版，第三版中继续丰富功能，优化体验。 三、技术分析明确了需求，你下一步需要考虑的便是实现这些需求所需要的技术。 1.支持多个项目同时进行自动化构建。在界面上，可以采用列表的方式进行已添加项目的展示。NSTableView是一个很好选择，其使用方便，结合xib文件来编写cell，其开发效率也十分高。关于进行多个项目的同时构建，可以采用多线程编程技术，在Objective-C中，NSOperationQueue可以方便的进行多线程任务管理，我们可以使用它来实现异步编程。 2.新增与删除项目。对于iOS工程的自动构建，新增和删除项目无非就是保存或删除xcode文件的路径，当然，你可以也需要一些附带的数据用于显示，例如项目名等。 3.操作Git。安装了Xcode工具，Git工具会被自动的安装。你可以直接在终端通过命令行来调用Git命令，你可以使用Foundation框架中的NSAppleScript类来在OS X平台软件中执行脚本命令，关于Git模块，你需要使用到的命令如下： ①拉取项目所有分支：git branch ②进行分支的切换：git checkout \\[分支名\\] ③从远端拉取代码：git pull 4.使用Xcode命令来进行工程的构建。和操作Git命令类似，你需要使用到的Xcode的构建命令如下： ①清理工程：xcodebuild clean -\\[工程类型\\] \\[工程地址\\] -scheme \\[scheme名称\\] CONFIGURATION=\\[DEBUG模式\\] ②导出archive文件：xcodebuild archive -\\[工程类型\\] \\[工程地址\\] -scheme \\[scheme名称\\] -archivePath \\[导出路径\\] CONFIGURATION=\\[DEBUG模式\\] ③导出IPA安装包：xcodebuild -exportArchive -archivePath \\[archive文件路径\\] -exportPath \\[导出路径\\] exportOptionsPlist \\[配置plist文件\\] 5.发布到第三方平台这一步其实就是IPA安装包的上传，你可以长传到蒲公英平台作为私有项目供测试人员使用，你也可以上传到公司自己的服务器，AFNetworking是一个同时支持iOS和OS X的网络第三方库，你可以选择使用它来上传文件。 6.灵活的组合模块。这部分就完全是代码逻辑了，在设计时，你可以将每个模块封装成具体的任务，任务之间只能顺序进行执行，然后自由组合这些任务即可。 7.输出窗口。使用NSTextView来显示输出信息，无论是执行脚本，还是上传文件，如果出错，都会有信息反馈。 8.记忆功能。你可以选择使用数据库来存储每个项目的信息，因为数据量并不大，我在开发这个软件时，采用的是归档的原理来进行数据的持久化。 四、界面设计在Xcode中，使用storyboard开发界面是一件什么畅快的事情。在开发项目的主界面时，我参照了SourceTress的设计，也感谢 [@魔笛](https://my.oschina.net/u/157488) 提供的界面思路。我想作为开发者的工具无需绚丽的外表，简约是实用，然后看上去舒服就算达到要求。主页面截图如下，其也十分简单，只是作为数据的展示。 添加工程界面我采用的是弹出窗口的模式，正如上面分析，添加工程的实质就是拿到Xcode项目文件的地址，界面效果如下： 项目详情界面略微复杂，其中需要配置编译模块，Git模块和发布模块，界面如下： 关于逻辑与功能的编写，代码较多，需要的朋友可以自动查看源码。 五、扩展与源码Jenkins是一个持续集成与发布软件的平台。后续你可以为你的自动构建工具添加轮询打包的功能，将其运行在一台作为服务器的Mac电脑上，它就是具有了持续集成功能。 软件下载地址：http://zyhshao.github.io/AutoBuild/welcome.html。 github源码：https://github.com/ZYHshao/AutoBuild。 欢迎starO(∩_∩)O 欢迎指教 共同学习","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"OS X开发：NSProgressIndicator进度指示器控件","slug":"351OS X开发：NSProgressIndicator进度指示器控件","date":"2017-07-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.373Z","comments":true,"path":"2017/07/21/351OS X开发：NSProgressIndicator进度指示器控件/","link":"","permalink":"http://huishao.cc/2017/07/21/351OS X开发：NSProgressIndicator进度指示器控件/","excerpt":"","text":"OS X开发：NSProgressIndicator进度指示器控件NSProgressIndicator是OS X平台上的活动指示器控件，开发者可以设置圆环样式和进度条样式两种。 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; NSProgressIndicator * progressIndicator = [[NSProgressIndicator alloc]initWithFrame:CGRectMake(30, 100, 200, 10)]; //设置是精准的进度条还是模糊的指示器 progressIndicator.indeterminate = YES; //是否贝塞尔风格 progressIndicator.bezeled = YES; //设置控制器尺寸 progressIndicator.controlSize = NSControlSizeSmall; //设置当前进度 progressIndicator.doubleValue = 5; //设置风格 progressIndicator.style = NSProgressIndicatorBarStyle; //设置是否当动画停止时隐藏 progressIndicator.displayedWhenStopped = YES; [self.view addSubview:progressIndicator];&#125; 效果如图： NSProgressIndicator类中属性方法解析如下： 123456789101112131415161718192021222324252627282930313233343536373839//设置是否是模糊模式 牧户模式下，不显示具体的进度，通过动画提示用户正在加载@property (getter=isIndeterminate) BOOL indeterminate; //设置是否贝塞尔风格@property (getter=isBezeled) BOOL bezeled;//指示器的控制色@property NSControlTint controlTint;//指示器的尺寸设置/*typedef NS_ENUM(NSUInteger, NSControlSize) &#123; NSControlSizeRegular,//标准 NSControlSizeSmall,//小 NSControlSizeMini,//迷你&#125;;*/@property NSControlSize controlSize;//设置当前进度值@property double doubleValue;//设置进度值增量，即原始值夹着delta值- (void)incrementBy:(double)delta;//进度条最小值@property double minValue;//进度条最大值@property double maxValue;//是否在多线程中执行动画@property BOOL usesThreadedAnimation;//开始动画- (void)startAnimation:(nullable id)sender;//结束动画- (void)stopAnimation:(nullable id)sender;//设置风格/*typedef NS_ENUM(NSUInteger, NSProgressIndicatorStyle) &#123; NSProgressIndicatorBarStyle = 0, //进度条风格 NSProgressIndicatorSpinningStyle = 1 //风火轮风格&#125;;*/@property NSProgressIndicatorStyle style;//设置动画停止时进度条是否依然显示@property (getter=isDisplayedWhenStopped) BOOL displayedWhenStopped;","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"OS X开发：NSTextField文本输入框","slug":"350OS X开发：NSTextField文本输入框","date":"2017-07-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.373Z","comments":true,"path":"2017/07/19/350OS X开发：NSTextField文本输入框/","link":"","permalink":"http://huishao.cc/2017/07/19/350OS X开发：NSTextField文本输入框/","excerpt":"","text":"OS X开发：NSTextField文本输入框NSTextField组件可以接收用户的输入，和UITextField不同，其可以将用户的输入进行多行显示。示例代码如下： 1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; //创建 MyTextField * textField = [[MyTextField alloc]initWithFrame:NSMakeRect(100, 200, 300, 40)]; //设置默认提示文字 textField.placeholderString = @\"默认文字\"; //设置背景 textField.backgroundColor = [NSColor redColor]; //设置是否渲染背景 textField.drawsBackground = YES; //设置文字颜色 textField.textColor = [NSColor blueColor]; //设置是否边框 textField.bordered = YES; //设置是否贝塞尔 textField.bezeled = YES; //设置代理 textField.delegate = self; [self.view addSubview:textField];&#125; NSTextField类解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//设置默认提示文字@property (nullable, copy) NSString *placeholderString;//富文本提示文字@property (nullable, copy) NSAttributedString *placeholderAttributedString;//设置背景色@property (nullable, copy) NSColor *backgroundColor;//设置是否渲染背景色@property BOOL drawsBackground;//设置文字颜色@property (nullable, copy) NSColor *textColor;//设置是否有边框@property (getter=isBordered) BOOL bordered;//设置贝塞尔边框@property (getter=isBezeled) BOOL bezeled;//设置是否可编辑@property (getter=isEditable) BOOL editable;//设置是否可选择文字@property (getter=isSelectable) BOOL selectable;//选择文本- (void)selectText:(nullable id)sender;//代理@property (nullable, assign) id&lt;NSTextFieldDelegate&gt; delegate;//是否允许称为第一响应@property (readonly) BOOL acceptsFirstResponder;//设置贝塞尔风格/*typedef NS_ENUM(NSUInteger, NSTextFieldBezelStyle) &#123; NSTextFieldSquareBezel = 0, NSTextFieldRoundedBezel = 1&#125;;*/@property NSTextFieldBezelStyle bezelStyle;//子类可以重写如下方法：//即将进入编辑状态时被调用 返回值决定是否允许编辑- (BOOL)textShouldBeginEditing:(NSText *)textObject;//即将结束编辑状态时调用 返回值决定是否允许结束编辑- (BOOL)textShouldEndEditing:(NSText *)textObject;//已经开始编辑时调用- (void)textDidBeginEditing:(NSNotification *)notification;//已经结束编辑时调用- (void)textDidEndEditing:(NSNotification *)notification;//文本改变时调用- (void)textDidChange:(NSNotification *)notification;//下面这些方法用来快捷创建NSTextField+ (instancetype)labelWithString:(NSString *)stringValue;+ (instancetype)wrappingLabelWithString:(NSString *)stringValue;+ (instancetype)textFieldWithString:(nullable NSString *)stringValue;+ (instancetype)labelWithAttributedString:(NSAttributedString *)attributedStringValue;","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"OS X开发：NSButton按钮控件应用","slug":"349OS X开发：NSButton按钮控件应用","date":"2017-07-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.372Z","comments":true,"path":"2017/07/18/349OS X开发：NSButton按钮控件应用/","link":"","permalink":"http://huishao.cc/2017/07/18/349OS X开发：NSButton按钮控件应用/","excerpt":"","text":"OS X开发：NSButton按钮控件应用NSButton控件用来创建功能按钮，和UIButton相比，其样式要丰富许多。NSButton继承自NSControl，其使用setTarget与setAction来添加触发方法，如下： 1234NSButton * btn = [[NSButton alloc]initWithFrame:CGRectMake(50, 300, 90, 25)];[btn setTarget:self];[btn setAction:@selector(click)];[self.view addSubview:btn]; NSButton类中常用属性和方法解析如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//设置按钮标题@property (copy) NSString *title;//设置按钮开启状态的标题@property (copy) NSString *alternateTitle;//设置按钮图片@property (nullable, strong) NSImage *image;//设置按钮开启状态图片@property (nullable, strong) NSImage *alternateImage;//设置按钮图片位置/*typedef NS_ENUM(NSUInteger, NSCellImagePosition) &#123; NSNoImage = 0, //无图片 NSImageOnly = 1, //只有图片 NSImageLeft = 2, //图片在左侧 NSImageRight = 3, //图片在右侧 NSImageBelow = 4, //图片在下侧 NSImageAbove = 5, //图片在上侧 NSImageOverlaps = 6, //图片重叠 NSImageLeading API_AVAILABLE(macosx(10.12)) = 7, //正方向 NSImageTrailing API_AVAILABLE(macosx(10.12)) = 8 //逆方向&#125;;*/@property NSCellImagePosition imagePosition;//设置图片缩放模式/*typedef NS_ENUM(NSUInteger, NSImageScaling) &#123; NSImageScaleProportionallyDown = 0, // 下方缩放 NSImageScaleAxesIndependently, // 整体缩放 NSImageScaleNone, // 不缩放. NSImageScaleProportionallyUpOrDown, // 上下缩放 NSScaleProportionally NS_ENUM_DEPRECATED_MAC(10_0, 10_10, \"Use NSImageScaleProportionallyDown instead\") = 0, NSScaleToFit NS_ENUM_DEPRECATED_MAC(10_0, 10_10, \"Use NSImageScaleAxesIndependently instead\"), NSScaleNone NS_ENUM_DEPRECATED_MAC(10_0, 10_10, \"Use NSImageScaleNone instead\")&#125;;*/@property NSImageScaling imageScaling NS_AVAILABLE_MAC(10_5);//图片是否环绕标题@property BOOL imageHugsTitle;//设置按钮状态/*enum &#123; NSMixedState = -1, //混合状态 NSOffState = 0, //关闭状态 NSOnState = 1, //开启状态&#125;;*/@property NSInteger state;//设置是否显示边框@property (getter=isBordered) BOOL bordered;//设置按钮是否透明@property (getter=isTransparent) BOOL transparent;//设置快捷键@property (copy) NSString *keyEquivalent;//设置富文本标题@property (copy) NSAttributedString *attributedTitle;@property (copy) NSAttributedString *attributedAlternateTitle;//设置边框风格@property NSBezelStyle bezelStyle;//设置是否当鼠标移动到按钮上时显示边框@property BOOL showsBorderOnlyWhileMouseInside;//设置按钮声音@property (nullable, strong) NSSound *sound; 下面是一些便捷创建按钮的方法： 12345678910//创建标准的按钮 包括标题和图片+ (instancetype)buttonWithTitle:(NSString *)title image:(NSImage *)image target:(nullable id)target action:(nullable SEL)action;//创建文字按钮+ (instancetype)buttonWithTitle:(NSString *)title target:(nullable id)target action:(nullable SEL)action;//创建图片按钮+ (instancetype)buttonWithImage:(NSImage *)image target:(nullable id)target action:(nullable SEL)action;//创建复选框按钮+ (instancetype)checkboxWithTitle:(NSString *)title target:(nullable id)target action:(nullable SEL)action;//创建单选框按钮+ (instancetype)radioButtonWithTitle:(NSString *)title target:(nullable id)target action:(nullable SEL)action;","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"OS X 开发：打开文件面板NSOpenPanel应用","slug":"348OS X 开发：打开文件面板NSOpenPanel应用","date":"2017-07-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.372Z","comments":true,"path":"2017/07/17/348OS X 开发：打开文件面板NSOpenPanel应用/","link":"","permalink":"http://huishao.cc/2017/07/17/348OS X 开发：打开文件面板NSOpenPanel应用/","excerpt":"","text":"OS X 开发：打开文件面板NSOpenPanel应用在Mac桌面软件开发中，如果涉及到对文件的操作，无论是新建文件还是选择或读取文件，都离不开文件路径的定位，NSOpenPanel类提供了简洁的文件选择面板，其继承自NSSavePanel(一个专门用来存储文件的类)，NSOpenPanel的使用非常简单，示例如下： 12345678910111213NSOpenPanel * panel = [NSOpenPanel openPanel];//设置是否解析别名panel.resolvesAliases = NO;//设置是否允许选择文件夹panel.canChooseDirectories = YES;//设置是否允许选择文件panel.canChooseFiles = YES;//设置是否允许多选panel.allowsMultipleSelection = YES;NSInteger result = [panel runModal];if (result==NSFileHandlingPanelOKButton) &#123; NSLog(@\"%@\",panel.URLs);&#125; 在使用runModel方法弹出面板后，用户可以选择面板中的文件或文件夹，如下图所示： runModel方法的返回值为NSInteger类型，其是一个枚举值，枚举的意义如下： 1234enum &#123; NSFileHandlingPanelCancelButton = NSModalResponseCancel,//用户点击了取消按钮 NSFileHandlingPanelOKButton = NSModalResponseOK,//用户点击了OK按钮&#125;;","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"OS X开发NSMenu应用详解","slug":"347OS X开发NSMenu应用详解","date":"2017-07-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.372Z","comments":true,"path":"2017/07/14/347OS X开发NSMenu应用详解/","link":"","permalink":"http://huishao.cc/2017/07/14/347OS X开发NSMenu应用详解/","excerpt":"","text":"OS X开发NSMenu应用详解一、引言NSMenu在Mac桌面软件开发中往往有3个方面的应用，作为程序的主菜单栏使用，作为视图邮件菜单使用和作为Dock菜单使用。 二、主应用菜单使用Xcode新建OX S应用时，可以选择使用Storyboard。Storyboard里面会自动创建一个菜单栏，你可以自行在菜单中进行增删改操作，菜单中的Item触发方法也可以直接与AppDelegate进行关联，实现自定义的菜单逻辑，如图： 三：Dock菜单当一款Mac桌面软件运行时，会在Dock栏上显示一个图标，当在此图标上点击右键时，会出现一个Dock菜单，自定义此Dock菜单也十分容易，直接在AppDelegate中重写如下方法即可： 1234567891011121314151617-(NSMenu *)applicationDockMenu:(NSApplication *)sender&#123; NSMenu * menu = [[NSMenu alloc]initWithTitle:@\"Menu\"]; NSMenuItem * item1 = [[NSMenuItem alloc]initWithTitle:@\"菜单1\" action:@selector(click) keyEquivalent:@\"\"]; item1.target = self; NSMenuItem * item2 = [[NSMenuItem alloc]initWithTitle:@\"菜单2\" action:@selector(click) keyEquivalent:@\"\"]; item2.target = self; NSMenuItem * item3 = [[NSMenuItem alloc]initWithTitle:@\"菜单3\" action:@selector(click) keyEquivalent:@\"\"]; NSMenu * subMenu = [[NSMenu alloc]initWithTitle:@\"subMenu\"]; NSMenuItem * item4 = [[NSMenuItem alloc]initWithTitle:@\"菜单4\" action:@selector(click) keyEquivalent:@\"\"]; item4.target = self; [subMenu addItem:item4]; [menu addItem:item1]; [menu addItem:item2]; [menu addItem:item3]; [menu setSubmenu:subMenu forItem:item3]; return menu;&#125; 效果如下： 四、视图右键弹出菜单视图右键弹出菜单是基于NSView视图的，例如： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; NSMenu * menu = [[NSMenu alloc]initWithTitle:@\"Menu\"]; NSMenuItem * item1 = [[NSMenuItem alloc]initWithTitle:@\"菜单1\" action:@selector(click) keyEquivalent:@\"\"]; item1.target = self; NSMenuItem * item2 = [[NSMenuItem alloc]initWithTitle:@\"菜单2\" action:@selector(click) keyEquivalent:@\"\"]; item2.target = self; NSMenuItem * item3 = [[NSMenuItem alloc]initWithTitle:@\"菜单3\" action:@selector(click) keyEquivalent:@\"\"]; NSMenu * subMenu = [[NSMenu alloc]initWithTitle:@\"subMenu\"]; NSMenuItem * item4 = [[NSMenuItem alloc]initWithTitle:@\"菜单4\" action:@selector(click) keyEquivalent:@\"\"]; item4.target = self; [subMenu addItem:item4]; [menu addItem:item1]; [menu addItem:item2]; [menu addItem:item3]; [menu setSubmenu:subMenu forItem:item3]; [self.view setMenu:menu];&#125; 效果如下： 五、NSMenuItem详解NSMenuItem是菜单中的每一个菜单选项对象，其中常用属性方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//设置是否启用用户快捷键+ (void)setUsesUserKeyEquivalents:(BOOL)flag;//设置用户快捷键启用状态+ (BOOL)usesUserKeyEquivalents;//创建一个分割线+ (NSMenuItem *)separatorItem;//使用标题，快捷键和方法选择器来对Item进行初始化- (instancetype)initWithTitle:(NSString *)string action:(nullable SEL)selector keyEquivalent:(NSString *)charCode;//其所在的菜单对象@property (nullable, assign) NSMenu *menu;//其是否有子菜单@property (readonly) BOOL hasSubmenu;//子菜单对象@property (nullable, strong) NSMenu *submenu;//如果此Item是某个子菜单中的，此属性获取与子菜单关联的父item@property (nullable, readonly, assign) NSMenuItem *parentItem;//Item标题@property (copy) NSString *title;//富文本标题@property (nullable, copy) NSAttributedString *attributedTitle;//是否是分隔线Item@property (getter=isSeparatorItem, readonly) BOOL separatorItem;//绑定的快捷键@property (copy) NSString *keyEquivalent;//快捷键类型/*typedef NS_OPTIONS(NSUInteger, NSEventModifierFlags) &#123; NSEventModifierFlagCapsLock = 1 &lt;&lt; 16, // Caps lock键 NSEventModifierFlagShift = 1 &lt;&lt; 17, // shift键 NSEventModifierFlagControl = 1 &lt;&lt; 18, // control键 NSEventModifierFlagOption = 1 &lt;&lt; 19, // option键 NSEventModifierFlagCommand = 1 &lt;&lt; 20, // command键 NSEventModifierFlagNumericPad = 1 &lt;&lt; 21, // 小键盘任意键 NSEventModifierFlagHelp = 1 &lt;&lt; 22, // 帮助键 NSEventModifierFlagFunction = 1 &lt;&lt; 23, // 任意功能按钮&#125;;*/@property NSEventModifierFlags keyEquivalentModifierMask;//Item图标@property (nullable, strong) NSImage *image;//Item状态@property NSInteger state;//开启状态下的图标@property (null_resettable, strong) NSImage *onStateImage;//关闭状态下的图标@property (nullable, strong) NSImage *offStateImage;//混合状态下的图标@property (null_resettable, strong) NSImage *mixedStateImage;//是否有效@property (getter=isEnabled) BOOL enabled;//是否前置@property (getter=isAlternate) BOOL alternate;//Item缩进级别@property NSInteger indentationLevel;//设置交互响应者@property (nullable, weak) id target;//设置交互相应方法@property (nullable) SEL action;//设置tag值@property NSInteger tag;//是否高亮@property (getter=isHighlighted, readonly) BOOL highlighted;//设置是否隐藏@property (getter=isHidden) BOOL hidden;//设置提示文本@property (nullable, copy) NSString *toolTip; 六、NSMenu详解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//初始化方法- (instancetype)initWithTitle:(NSString *)title;//标题@property (copy) NSString *title;//在所在的交互点弹出菜单+ (void)popUpContextMenu:(NSMenu*)menu withEvent:(NSEvent*)event forView:(NSView*)view;+ (void)popUpContextMenu:(NSMenu*)menu withEvent:(NSEvent*)event forView:(NSView*)view withFont:(nullable NSFont*)font;- (BOOL)popUpMenuPositioningItem:(nullable NSMenuItem *)item atLocation:(NSPoint)location inView:(nullable NSView *)view NS_AVAILABLE_MAC(10_6);//设置菜单栏是否可见+ (void)setMenuBarVisible:(BOOL)visible;+ (BOOL)menuBarVisible;//父菜单@property (nullable, assign) NSMenu *supermenu;//插入Item- (void)insertItem:(NSMenuItem *)newItem atIndex:(NSInteger)index;- (NSMenuItem *)insertItemWithTitle:(NSString *)string action:(nullable SEL)selector keyEquivalent:(NSString *)charCode atIndex:(NSInteger)index;//添加Item- (void)addItem:(NSMenuItem *)newItem;- (NSMenuItem *)addItemWithTitle:(NSString *)string action:(nullable SEL)selector keyEquivalent:(NSString *)charCode;//删除某个位置的Item- (void)removeItemAtIndex:(NSInteger)index;//删除Item- (void)removeItem:(NSMenuItem *)item;//为某个Item设置子菜单- (void)setSubmenu:(nullable NSMenu *)menu forItem:(NSMenuItem *)item;//删除所有Item- (void)removeAllItems;//Item数组@property (readonly, copy) NSArray&lt;NSMenuItem *&gt; *itemArray;//获取Item个数@property (readonly) NSInteger numberOfItems;//获取某个位置的Item- (nullable NSMenuItem *)itemAtIndex:(NSInteger)index;//获取某个Item的位置- (NSInteger)indexOfItem:(NSMenuItem *)item;- (NSInteger)indexOfItemWithTitle:(NSString *)title;- (NSInteger)indexOfItemWithTag:(NSInteger)tag;- (NSInteger)indexOfItemWithSubmenu:(nullable NSMenu *)submenu;- (NSInteger)indexOfItemWithTarget:(nullable id)target andAction:(nullable SEL)actionSelector;//根据标题获取item- (nullable NSMenuItem *)itemWithTitle:(NSString *)title;//根据tag获取Item- (nullable NSMenuItem *)itemWithTag:(NSInteger)tag;//刷新菜单- (void)update;//获取菜单高度@property (readonly) CGFloat menuBarHeight;//取消菜单- (void)cancelTracking;- (void)cancelTrackingWithoutAnimation;//获取高亮的Item@property (nullable, readonly, strong) NSMenuItem *highlightedItem;//最小宽度@property CGFloat minimumWidth;//尺寸@property (readonly) NSSize size;//字体@property (null_resettable, strong) NSFont *font;","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"NSAlert组件应用总结","slug":"346NSAlert组件应用总结","date":"2017-07-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.372Z","comments":true,"path":"2017/07/13/346NSAlert组件应用总结/","link":"","permalink":"http://huishao.cc/2017/07/13/346NSAlert组件应用总结/","excerpt":"","text":"NSAlert组件应用总结一、引言在桌面软件开发中，当用户进行非法的操作或有风险的操作时，时长需要弹出警告框来提示用户。在OS X系统上，NSAlert是专门的警告框组件。其提供了简洁的接口供开发者进行使用。 二、NSAlert的简单使用使用警告框最简单的使用方式是提示错误信息，错误信息警告只起到提示用户的作用，其只有一个OK按钮，点击后警告框会关闭。示例如下： 12345- (IBAction)alert:(id)sender &#123; NSError * error = [NSError errorWithDomain:@\"testError\" code:1001 userInfo:@&#123;@\"userid\":@\"1000\"&#125;]; NSAlert * alert = [NSAlert alertWithError:error]; [alert runModal];&#125; 效果图如下： 警告框的展现有两种方式，分别为模态窗与弹出抽屉。弹出抽屉会显示在当前绑定的窗口上，模态窗则会自成窗口，弹出在屏幕中央。 你也可以对警告框进行自定义设置，例如文本，标题，图标等，示例如下： 123456789101112131415161718- (IBAction)alert:(id)sender &#123; NSAlert * alert = [[NSAlert alloc]init]; alert.icon = [NSImage imageNamed:@\"icon\"]; alert.messageText = @\"警告信息\"; alert.informativeText = @\"额外提供的内容\"; alert.showsHelp = YES; alert.helpAnchor = @\"mac\"; alert.alertStyle = NSAlertStyleInformational; alert.showsSuppressionButton = YES; [alert.suppressionButton setTarget:self]; [alert.suppressionButton setAction:@selector(click)]; [alert addButtonWithTitle:@\"1\"]; [alert addButtonWithTitle:@\"2\"]; [alert addButtonWithTitle:@\"3\"]; [alert addButtonWithTitle:@\"4\"]; long res = [alert runModal]; NSLog(@\"%ld\",res);&#125; 效果如下： 三、NSAlert属性与方法解析NSAlert类中的属性和方法解析如下： 123456789101112131415161718192021222324252627282930313233343536//直接使用错误信息创建警告框+ (NSAlert *)alertWithError:(NSError *)error;//设置警告框信息@property (copy) NSString *messageText;//设置额外信息内容@property (copy) NSString *informativeText;//设置警告框图标@property (null_resettable, strong) NSImage *icon;//向警告框中添加按钮- (NSButton *)addButtonWithTitle:(NSString *)title;//按钮数组@property (readonly, copy) NSArray&lt;NSButton *&gt; *buttons;//是否显示帮助按钮@property BOOL showsHelp;//设置帮助手册锚点 用于定于@property (nullable, copy) NSString *helpAnchor;//设置警告框风格/*typedef NS_ENUM(NSUInteger, NSAlertStyle) &#123; NSAlertStyleWarning = 0, //警告风格 NSAlertStyleInformational = 1,//提示信息风格 NSAlertStyleCritical = 2 //验证风格&#125;;*/@property NSAlertStyle alertStyle;//是否显示不再提示按钮@property BOOL showsSuppressionButton NS_AVAILABLE_MAC(10_5);//获取不再提示按钮@property (nullable, readonly, strong) NSButton *suppressionButton NS_AVAILABLE_MAC(10_5);//代理对象@property (nullable, weak) id&lt;NSAlertDelegate&gt; delegate;//以模态窗口的方式弹出警告框，这个方法是同步的，当用户点击警告框中按钮后会返回，返回的NSModalResponse实际上是//整型数据，第1个按钮为1000，后面一次递增，如1001，1002...- (NSModalResponse)runModal;//以窗口抽屉的方式弹出警告框，这个方法是异步的，当用户点击警告框中的按钮后会回调block- (void)beginSheetModalForWindow:(NSWindow *)sheetWindow completionHandler:(void (^ __nullable)(NSModalResponse returnCode))handler NS_AVAILABLE_MAC(10_9); NSAlertDelegate协议中只定义了一个方法，如下： 12345@protocol NSAlertDelegate &lt;NSObject&gt;@optional//当用户点击帮助按钮后回调的方法 返回值决定是否弹出帮助窗口- (BOOL)alertShowHelp:(NSAlert *)alert;@end 除了上面列出的方法外，NSAlert中还有两个已经弃用的便捷构造和弹出方法，如下： 1234//创建警告框+ (NSAlert *)alertWithMessageText:(nullable NSString *)message defaultButton:(nullable NSString *)defaultButton alternateButton:(nullable NSString *)alternateButton otherButton:(nullable NSString *)otherButton informativeTextWithFormat:(NSString *)format, ...;//弹出警告框- (void)beginSheetModalForWindow:(NSWindow *)window modalDelegate:(nullable id)delegate didEndSelector:(nullable SEL)didEndSelector contextInfo:(nullable void *)contextInfo;","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"Java开发GUI之图形绘制","slug":"345Java开发GUI之图形绘制","date":"2017-06-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.371Z","comments":true,"path":"2017/06/22/345Java开发GUI之图形绘制/","link":"","permalink":"http://huishao.cc/2017/06/22/345Java开发GUI之图形绘制/","excerpt":"","text":"Java开发GUI之图形绘制在Java的GUI组件中，每一个视图都有一个paint方法，这个方法负责组件的绘制，其中会传入Graphics对象参数，开发者可以在paint方法中操作这个对象进行自定义图形的绘制。示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class DrawPanel extends Panel&#123; private static final long serialVersionUID = 1L; public DrawPanel() &#123; super(); &#125; @Override public void paint(Graphics g) &#123; // TODO Auto-generated method stub super.paint(g); Color bg = Color.WHITE; Color fg = Color.RED; //绘制背景 g.setColor(bg); g.draw3DRect(50, 50, 699, 140, true); g.draw3DRect(53, 53, 692, 133, true); g.setColor(fg); //绘制线 g.drawLine(60, 60, 140, 60); //绘制矩形 g.drawRect(150, 60, 80, 50); //绘制圆角矩形 g.drawRoundRect(240, 60, 80, 50, 25, 25); //绘制椭圆 g.drawOval(330, 60, 80, 50); //绘制弧线 g.drawArc(420, 60, 50, 50, 0, 90); //绘制闭合折线 Polygon polygon = new Polygon(); polygon.addPoint(510, 60); polygon.addPoint(550, 60); polygon.addPoint(550, 110); polygon.addPoint(590, 110); g.drawPolygon(polygon); //填充矩形 g.fillRect(600, 60, 80, 50); //填充3D矩形 g.fill3DRect(60, 120, 80, 50, true); //填充圆角矩形 g.fillRoundRect(150, 120, 80, 50, 25, 25); //填充椭圆 g.fillOval(240, 120, 80, 50); //填充弧线 g.fillArc(330, 120, 50, 50, 0, 90); //填充闭合折线 Polygon polygon2 = new Polygon(); polygon2.addPoint(390, 120); polygon2.addPoint(440, 120); polygon2.addPoint(440, 180); polygon2.addPoint(490, 180); g.fillPolygon(polygon2); //绘制文字 g.drawString(\"finish draw test!\", 500, 150); &#125;&#125; 效果如下图：","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"自定义Window标题栏titleBar","slug":"343自定义Window标题栏titleBar","date":"2017-06-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.371Z","comments":true,"path":"2017/06/20/343自定义Window标题栏titleBar/","link":"","permalink":"http://huishao.cc/2017/06/20/343自定义Window标题栏titleBar/","excerpt":"","text":"自定义Window标题栏titleBar在进行OS X软件开发时，Window自带的标题栏十分简易，往往不能达到我们的需求，如下图： 在实际开发中，我们需要根据项目的需要对标题栏进行自定义。自定义标题栏主要有如下两种思路： 1.去掉系统的标题栏，使用自定义的View来做标题栏。 2.隐藏系统的标题栏，进行标题栏的透明处理。 上面两种思路中第2种要更好一些，我们可以服用系统的功能按钮，即关闭、最小化和最大化按钮。 首先，现在Window的contentView中添加一个自定义的View，作为标题栏视图，View上可以添加图标或任意自定义的功能按钮。如下： 通过如下代码来设置标题栏： 1234567891011121314151617181920//将系统的标题栏设置透明 self.window.titlebarAppearsTransparent = YES;//将系统标题进行隐藏self.window.titleVisibility = NSWindowTitleHidden;//设置可以通过拖拽window背景视图进行窗口的移动[self.window setMovableByWindowBackground:YES];//设置window的内容部分充满整个窗口[self.window setStyleMask:[self.window styleMask] | NSWindowStyleMaskFullSizeContentView];//获取到windows的主视图 NSView * themeView = self.window.contentView.superview;//根据层级结构获取到标题栏视图NSView * titleView = themeView.subviews[1];titleView.autoresizesSubviews = YES;//重新对标题栏视图的尺寸进行布局，使得系统的功能按钮出现在自定义标题中的竖直中间[titleView mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(@10); make.width.equalTo(@70); make.top.equalTo(@9); make.height.equalTo(@22);&#125;]; 需要注意，上面对标题栏的布局进行了重设，这样是为了让系统的3个功能按钮显示在自定义标题栏的中间，但是当用户使用全屏功能进行全屏与非全屏切换时，系统会对标题栏的尺寸进行重新布局，将功能按钮放回原来的位置，为了避免这样的问题，可以监听用户全屏切换事件，退出全屏时，进行重新布局。 整体效果如下：","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"Java开发GUI之绝对布局","slug":"344Java开发GUI之绝对布局","date":"2017-06-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.371Z","comments":true,"path":"2017/06/20/344Java开发GUI之绝对布局/","link":"","permalink":"http://huishao.cc/2017/06/20/344Java开发GUI之绝对布局/","excerpt":"","text":"Java开发GUI之绝对布局前面多篇博客介绍了Java的awt包中的布局管理类，当然也可以不使用任何布局管理类，开发者可以直接设置组件的坐标和尺寸，示例代码如下： 123456789101112131415161718static void AbsoluteLayoutTest()&#123; Frame frame = new Frame(\"Grid\"); //设置不使用任何布局管理类 Panel pannel = new Panel(null); Button button1 = new Button(\"Button1\"); pannel.add(button1); button1.reshape(10, 10, 60, 20); Button button2 = new Button(\"Button2\"); pannel.add(button2); button2.reshape(80, 40, 60, 20); Button button3 = new Button(\"Button3\"); pannel.add(button3); button3.reshape(10, 70, 60, 20); frame.add(pannel); frame.pack(); frame.show();&#125; 组件的reshape方法用于重设组件的位置和尺寸，其前两个参数确定x，y坐标，后两个参数确定宽度与高度，效果如下图：","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之GridBagLayout布局","slug":"342Java开发GUI之GridBagLayout布局","date":"2017-06-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.371Z","comments":true,"path":"2017/06/19/342Java开发GUI之GridBagLayout布局/","link":"","permalink":"http://huishao.cc/2017/06/19/342Java开发GUI之GridBagLayout布局/","excerpt":"","text":"Java开发GUI之GridBagLayout布局GridBagLayout布局管理器是比GridLayout布局更加强大的表格布局。GridLayout进行的表格布局其中元素尺寸相同，而GridBagLayout则可以灵活配置其中元素的尺寸和位置。同样，GridBagLayout的使用也更加复杂，其布局依赖GridBagConstraints类。 先看如下经典示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static void GridBagLayoutTest()&#123; Frame frame = new Frame(\"GridBag\"); GridBagLayout layout = new GridBagLayout(); GridBagConstraints constraints = new GridBagConstraints(); Panel pannel = new Panel(layout); constraints.fill = GridBagConstraints.BOTH; constraints.weightx = 1.0; Button button1 = new Button(\"Button1\"); layout.setConstraints(button1, constraints); pannel.add(button1); Button button2 = new Button(\"Button2\"); layout.setConstraints(button2, constraints); pannel.add(button2); Button button3 = new Button(\"Button3\"); layout.setConstraints(button3, constraints); pannel.add(button3); constraints.gridwidth = GridBagConstraints.REMAINDER; Button button4 = new Button(\"Button4\"); layout.setConstraints(button4, constraints); pannel.add(button4); constraints.weightx=0; Button button5 = new Button(\"Button5\"); layout.setConstraints(button5, constraints); pannel.add(button5); constraints.gridwidth = GridBagConstraints.RELATIVE; Button button6 = new Button(\"Button6\"); layout.setConstraints(button6, constraints); pannel.add(button6); constraints.gridwidth = GridBagConstraints.REMAINDER; Button button7 = new Button(\"Button7\"); layout.setConstraints(button7, constraints); pannel.add(button7); constraints.gridwidth=1; constraints.gridheight=2; constraints.weighty=1.0; Button button8 = new Button(\"Button8\"); layout.setConstraints(button8, constraints); pannel.add(button8); constraints.weighty=0; constraints.gridwidth=GridBagConstraints.REMAINDER; constraints.gridheight = 1; Button button9 = new Button(\"Button9\"); layout.setConstraints(button9, constraints); pannel.add(button9); Button button10 = new Button(\"Button10\"); layout.setConstraints(button10, constraints); pannel.add(button10); frame.add(pannel); frame.pack(); frame.show();&#125; 上面代码布局了10个按钮，其中复用了同一个GridBagConstraints对象，效果如下： GridBagLayout类中常用方法列举如下： 12345678//构造方法public GridBagLayout ();//设置组件的布局public void setConstraints(Component comp, GridBagConstraints constraints);//获取某个组件的布局对象public GridBagConstraints getConstraints(Component comp);//获取布局原点public Point getLayoutOrigin (); 在GridBagLayout中其着至关重要作用的类是GridBagConstraints布局类，其精确确定每个子组件的位置和尺寸信息。下面我们来一点点介绍这个类中属性的意义： fill：这个属性确定当被布局组件尺寸小于其被指定的表格尺寸时，组件的拉伸模式，可选值定义在GridBagConstraints类中，如下： 12345678//不进行尺寸处理 默认居中public static final int NONE = 0;//水平和竖直均拉伸到充满public static final int BOTH = 1;//水平方向拉伸充满public static final int HORIZONTAL = 2;//竖直方向拉伸充满public static final int VERTICAL = 3; anchor：这个属性确定当被布局组件尺寸小于其被指定的表格尺寸时，组件的布局位置，可选值如下： 123456789101112131415161718//居中public static final int CENTER = 10;//布局在上方public static final int NORTH = 11;//布局在右上方public static final int NORTHEAST = 12;//布局在右方public static final int EAST = 13;//布局在右下方public static final int SOUTHEAST = 14;//布局在下方public static final int SOUTH = 15;//布局在左下方public static final int SOUTHWEST = 16;//布局在左方public static final int WEST = 17;//布局在左上方public static final int NORTHWEST = 18; gridwidth与gridheight：这两个属性分别设置组件的宽度与高度，他们可以设置为固定的数值，也可以设置为下面几个特殊的值来表示特殊的意义： 1234//占据其他组件布局后余下的尺寸public static final int RELATIVE = -1;//暂居此行或者此列的剩下全部，后置的组件另起一行或一列public static final int REMAINDER = 0; gridx与gridy：这两个值设置组件布局左上角所在的单元格，单位为单元格，默认会排列在上一个单元格之后。 weightx与weighty：这两个值设置组件布局的水平权重和竖直权重。 insets：设置组件边距。","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之CardLayout卡片布局","slug":"339Java开发GUI之CardLayout卡片布局","date":"2017-06-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.370Z","comments":true,"path":"2017/06/18/339Java开发GUI之CardLayout卡片布局/","link":"","permalink":"http://huishao.cc/2017/06/18/339Java开发GUI之CardLayout卡片布局/","excerpt":"","text":"Java开发GUI之CardLayout卡片布局CardLayout布局允许进行多套界面的设计，通过切换界面来实现布局样式的改变。CardLayout类似与一叠卡片，默认最先添加的在前面，界面始终只展示一个卡片。示例如下： 1234567891011121314151617181920212223242526272829static Panel cardPannel;static void CardLayoutTest()&#123; Frame frame = new Frame(\"Label\"); Panel top = new Panel(); Choice choice = new Choice(); choice.add(\"BUTTON\"); choice.add(\"LABEL\"); choice.addItemListener(new CardLayoutChoiceListener()); top.add(choice); CardLayout layout = new CardLayout(); cardPannel = new Panel(layout); Panel p1 = new Panel(); p1.add(new Button(\"one\")); p1.add(new Button(\"two\")); p1.add(new Button(\"three\")); cardPannel.add(\"BUTTON\", p1); Panel p2 = new Panel(); p2.add(new Label(\"label\")); p2.add(new Label(\"label\")); p2.add(new Label(\"label\")); cardPannel.add(\"LABEL\", p2); top.add(cardPannel); frame.add(top); frame.pack(); frame.show();&#125; Choice的监听对象类如下： 123456789class CardLayoutChoiceListener implements ItemListener&#123; @Override public void itemStateChanged(ItemEvent e) &#123; // TODO Auto-generated method stub ((CardLayout)APP.cardPannel.getLayout()).show(APP.cardPannel, (String) e.getItem()); &#125; &#125; 需要注意，CardLayout在进行卡片切换时，是通过卡片名来确定的，所以上面的代码将Choice的标题设置为和卡片的名称一致。 CardLayout类中方法总结如下： 12345678910111213141516171819202122//默认的构造方法public CardLayout();//构造方法 hgap设置卡片水平间距 vgap设置卡片竖直间距 public CardLayout(int hgap, int vgap);//获取水平间距public int getHgap();//设置水平间距public void setHgap(int hgap);//获取竖直间距public int getVgap();//设置竖直间距public void setVgap(int vgap);//显示第一个卡片界面 parent为父容器public void first(Container parent);//显示下一个卡片界面public void next(Container parent);//显示上一个卡片界面public void previous(Container parent);//显示最后一个卡片界面public void last(Container parent);//显示指定名称的卡片界面public void show(Container parent, String name);","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之GridLayout网格布局","slug":"341Java开发GUI之GridLayout网格布局","date":"2017-06-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.371Z","comments":true,"path":"2017/06/18/341Java开发GUI之GridLayout网格布局/","link":"","permalink":"http://huishao.cc/2017/06/18/341Java开发GUI之GridLayout网格布局/","excerpt":"","text":"Java开发GUI之GridLayout网格布局GridLayout是简单的网格布局，使用其可以方便的实现多行多列的布局样式。 12345678910111213static void GridLayoutTest()&#123;a Frame frame = new Frame(\"Grid\"); GridLayout layout = new GridLayout(2, 3, 10, 10); Panel pannel = new Panel(layout); pannel.add(new Button(\"Button1\")); pannel.add(new Button(\"Button2\")); pannel.add(new Button(\"Button3\")); pannel.add(new Button(\"Button4\")); pannel.add(new Button(\"Button5\")); frame.add(pannel); frame.pack(); frame.show();&#125; 效果如下： GridLayout类中常用方法总结如下： 12345678910111213141516171819202122//构造方法public GridLayout();//设置行数与列数public GridLayout(int rows, int cols);//设置行数与列数 以及水平竖直间距public GridLayout(int rows, int cols, int hgap, int vgap);//获取行数public int getRows();//设置行数public void setRows(int rows);//获取列数public int getColumns();//设置列数public void setColumns(int cols) ;//获取水平间距public int getHgap();//设置水平间距public void setHgap(int hgap);//获取竖直间距public int getVgap();//设置竖直间距public void setVgap(int vgap);","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之FlowLayout流布局","slug":"340Java开发GUI之FlowLayout流布局","date":"2017-06-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.371Z","comments":true,"path":"2017/06/18/340Java开发GUI之FlowLayout流布局/","link":"","permalink":"http://huishao.cc/2017/06/18/340Java开发GUI之FlowLayout流布局/","excerpt":"","text":"Java开发GUI之FlowLayout流布局FlowLayout顾名思义，即流式布局。其默认以行进行布局，可以设置对齐模式，当一行的距离不够组件进行排列时，FlowLayout会自行进行换行。 12345678910111213static void FlowLayoutTest()&#123; Frame frame = new Frame(\"Flow\"); FlowLayout layout = new FlowLayout(FlowLayout.RIGHT, 30, 20); Panel pannel = new Panel(layout); pannel.add(new Button(\"Button1\")); pannel.add(new Button(\"Button2\")); pannel.add(new Button(\"Button3\")); pannel.add(new Button(\"Button4\")); pannel.add(new Button(\"Button5\")); frame.add(pannel); frame.pack(); frame.show();&#125; 效果如下： FlowLayout类核心方法结局如下： 123456789101112131415161718192021222324252627282930//构造方法 默认居中对齐 行列间距为5public FlowLayout();//align设置对齐模式/*//左对齐public static final int LEFT = 0;//居中对齐public static final int CENTER = 1;//右对齐public static final int RIGHT = 2;*/public FlowLayout(int align);//hgap设置水平间距 vgap设置竖直间距public FlowLayout(int align, int hgap, int vgap);//获取对齐模式public int getAlignment();//设置对齐模式public void setAlignment(int align);//获取水平间距public int getHgap();//设置水平间距public void setHgap(int hgap) ;//获取竖直间距public int getVgap();//设置竖直间距public void setVgap(int vgap) ;//设置是否基线对齐public void setAlignOnBaseline(boolean alignOnBaseline) ;//获取是否基线对齐public boolean getAlignOnBaseline() ;","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之BorderLayout边界布局","slug":"338Java开发GUI之BorderLayout边界布局","date":"2017-06-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.370Z","comments":true,"path":"2017/06/16/338Java开发GUI之BorderLayout边界布局/","link":"","permalink":"http://huishao.cc/2017/06/16/338Java开发GUI之BorderLayout边界布局/","excerpt":"","text":"Java开发GUI之BorderLayout边界布局前面博客中所提及的例子都是针对单独的视图组件，将组件组合并布局在合适的位置才能算是完整的界面。Java中的布局采用布局管理器模式进行，提供了跨平台性，BoaderLayout布局管理器会将其内容分成5个部分，上下左右和中心，示例代码如下：a 12345678910111213static void BorderLayoutTest()&#123; Frame frame = new Frame(\"Label\"); BorderLayout layout = new BorderLayout(10,15); Panel pannel = new Panel(layout); pannel.add(BorderLayout.NORTH, new Button(\"北方\")); pannel.add(BorderLayout.SOUTH, new Button(\"南方\")); pannel.add(BorderLayout.EAST, new Button(\"东方\")); pannel.add(BorderLayout.WEST, new Button(\"西方\")); pannel.add(BorderLayout.CENTER, new Button(\"中心\")); frame.add(pannel); frame.pack(); frame.show();&#125; 效果如下： BorderLayout中常用方法解析： 12345678910111213141516171819202122//常量 指定布局在北方位置public static final String NORTH = \"North\";//常量 指定布局在南方位置public static final String SOUTH = \"South\";//常量 指定布局在东方位置public static final String EAST = \"East\";//常量 指定布局在西方位置public static final String WEST = \"West\";//常量 指定布局在中心位置public static final String CENTER = \"Center\";//初始化方法 默认无间距public BorderLayout();//初始化方法 hgap设置水平间距 vgap设置垂直间距public BorderLayout(int hgap, int vgap);//获取水平间距public int getHgap();//设置水平间距public void setHgap(int hgap);//获取垂直间距public int getVgap();//设置垂直间距public void setVgap(int vgap); 除了上面的方法，布局管理器相关类中都实现了添加组件的方法，这些方法一般开发者是不需要调用到的，当向容器中添加组件时，容器会用其对应的布局管理器来调用这些方法进行布局。","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之可编辑区域","slug":"337Java开发GUI之可编辑区域","date":"2017-06-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.370Z","comments":true,"path":"2017/06/15/337Java开发GUI之可编辑区域/","link":"","permalink":"http://huishao.cc/2017/06/15/337Java开发GUI之可编辑区域/","excerpt":"","text":"Java开发GUI之可编辑区域Java的awt包中提供了单行的文本编辑组件TextField与多行的文本编辑区TextArea，这两个组件都是继承自TextComponent类。 1234567891011121314 static void TextTest()&#123; Frame frame = new Frame(\"Label\"); Panel pannel = new Panel(); TextField textField = new TextField(\"请开始你的表演\",16); //设置密文输入// textField.setEchoChar('*'); textField.addTextListener(new TextFieldListener()); pannel.add(textField); TextArea textArea = new TextArea(\"是时候表演真正的技术了···\",5,20); pannel.add(textArea); frame.add(pannel); frame.pack(); frame.show(); &#125; 效果如下： TextComponent类中提供了可编辑组件的基本方法： 12345678910111213141516171819202122232425262728293031323334//设置是否支持切换输入法public void enableInputMethods(boolean enable);//设置文本public synchronized void setText(String t);//获取文本public synchronized String getText();//获取选中的文案public synchronized String getSelectedText();//获取是否可编辑public boolean isEditable();//设置是否可编辑public synchronized void setEditable(boolean b);//获取背景色public Color getBackground();//设置背景色public void setBackground(Color c);//获取选中文案的起点public synchronized int getSelectionStart();//设置选中文案的起点public synchronized void setSelectionStart(int selectionStart);//设置选中文案终点public synchronized int getSelectionEnd();//设置选中文案终点public synchronized void setSelectionEnd(int selectionEnd);//设置选中文案public synchronized void select(int selectionStart, int selectionEnd);//选中全部文案public synchronized void selectAll();//设置文案变化的监听public synchronized void addTextListener(TextListener l);//移除监听public synchronized void removeTextListener(TextListener l);//获取监听者public synchronized TextListener[] getTextListeners(); TextField用于单行的文本输入，并且可以设置密文输入，对登录框十分适用： 123456789101112131415161718192021222324252627//构造方法public TextField();//text参数设置文本public TextField(String text);//columns参数设置列数 会影响宽度public TextField(int columns);public TextField(String text, int columns);//获取输入文本被替换成的密文字符public char getEchoChar();//设置输入文本被替换成的密文字符public void setEchoChar(char c);//设置密文字符 已经弃用 适用上面的方法public synchronized void setEchoCharacter(char c);//设置文案public void setText(String t);//获取是否设置密文输入public boolean echoCharIsSet();//获取列数public int getColumns();//设置列数public void setColumns(int columns) ;//添加动作监听public synchronized void addActionListener(ActionListener l);//移除动作监听public synchronized void removeActionListener(ActionListener l);//获取监听者public synchronized ActionListener[] getActionListeners(); TextArea类中的方法总结如下： 12345678910111213141516171819202122232425262728293031323334353637//构造方法public TextArea();//text参数设置文本public TextArea(String text);//设置行数与列数public TextArea(int rows, int columns);public TextArea(String text, int rows, int columns);//scrollbars设置滚动条模式/*public static final int SCROLLBARS_BOTH = 0;//水平和竖直都显示滚动条public static final int SCROLLBARS_VERTICAL_ONLY = 1;//仅仅显示竖直滚动条public static final int SCROLLBARS_HORIZONTAL_ONLY = 2;//仅仅显示水平滚动条public static final int SCROLLBARS_NONE = 3; //不显示滚动条*/public TextArea(String text, int rows, int columns, int scrollbars);//在指定位置插入字符串public void insert(String str, int pos);//同上 已经弃用 使用上面的方法public synchronized void insertText(String str, int pos);//在已有文本后追加字符串public void append(String str);//同上，已经弃用 使用上面方法public synchronized void appendText(String str);//替换某个范围内的字符串public void replaceRange(String str, int start, int end);//同上，已经弃用 使用上面方法public synchronized void replaceText(String str, int start, int end);//获取行数public int getRows();//设置行数public void setRows(int rows);//获取列数public int getColumns();//设置列数public void setColumns(int columns);//获取滚动条模式public int getScrollbarVisibility();","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之滚动条","slug":"336Java开发GUI之滚动条","date":"2017-06-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.370Z","comments":true,"path":"2017/06/14/336Java开发GUI之滚动条/","link":"","permalink":"http://huishao.cc/2017/06/14/336Java开发GUI之滚动条/","excerpt":"","text":"Java开发GUI之滚动条滚动条组件可以实现用户拖动调整效果，示例代码如下： 123456789101112static void ScrollBarTest()&#123; Frame frame = new Frame(\"Label\"); Panel pannel = new Panel(); Scrollbar scrollbar = new Scrollbar(Scrollbar.HORIZONTAL, 5, 2, 0, 20); scrollbar.setUnitIncrement(1); scrollbar.setBlockIncrement(5); scrollbar.addAdjustmentListener(new ScrollBarListener()); pannel.add(scrollbar); frame.add(pannel); frame.pack(); frame.show();&#125; AdjustmentListener用来监听滚动条的值变化，其实现如下： 123456789class ScrollBarListener implements AdjustmentListener&#123; @Override public void adjustmentValueChanged(AdjustmentEvent e) &#123; // TODO Auto-generated method stub System.out.println(e.getValue()); &#125; &#125; ScrollBar组件中常用方法列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//构造方法public Scrollbar();//orientation参数设置滚动条的滚动防线/*public static final int HORIZONTAL = 0; //水平滚动public static final int VERTICAL = 1; //竖直滚动*/public Scrollbar(int orientation);/*value:滚动条的初始值visible:滚动条的可见值(比例，确定滑块的尺寸)minimum:滚动条的最小值maximum:滚动条的最大值*/public Scrollbar(int orientation, int value, int visible, int minimum, int maximum);//获取滚动条方向public int getOrientation();//设置滚动条方向public void setOrientation(int orientation);//获取滚动条当前值public int getValue();//设置滚动条当前值public void setValue(int newValue);//获取滚动条最小值public int getMinimum();//设置滚动条最小值public void setMinimum(int newMinimum);//获取滚动条最大值public int getMaximum();//设置滚动条最大值public void setMaximum(int newMaximum);//获取滚动条可见值public int getVisibleAmount();//获取滚动条可见值 已经弃用，使用上面方法public int getVisible();//设置滚动条可见值public void setVisibleAmount(int newAmount);//设置单元增值public void setUnitIncrement(int v);//获取单元增值public int getUnitIncrement();//设置块增值public void setBlockIncrement(int v);//获取块增值public int getBlockIncrement() ;//设置 当前值 可见值 最小值和最大值public void setValues(int value, int visible, int minimum, int maximum);//获取值是否正在调节public boolean getValueIsAdjusting();//设置值是否正在调节public void setValueIsAdjusting(boolean b);//设置滚动条值变化的监听public synchronized void addAdjustmentListener(AdjustmentListener l) ;//移除监听public synchronized void removeAdjustmentListener(AdjustmentListener l);//获取所有监听者public synchronized AdjustmentListener[] getAdjustmentListeners();","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之Menu菜单","slug":"335Java开发GUI之Menu菜单","date":"2017-06-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.369Z","comments":true,"path":"2017/06/13/335Java开发GUI之Menu菜单/","link":"","permalink":"http://huishao.cc/2017/06/13/335Java开发GUI之Menu菜单/","excerpt":"","text":"Java开发GUI之Menu菜单在MacOS上的软件都有一个菜单栏，会浮现在屏幕顶部，Java的awt包中也提供了构建菜单功能的相关组件，示例代码如下： 12345678910111213141516171819202122232425262728293031323334static void MenuTest()&#123; Frame frame = new Frame(\"Menu\"); //创建菜单栏 MenuBar menuBar = new MenuBar(); //设置菜单栏 frame.setMenuBar(menuBar); //创建菜单 Menu m1 = new Menu(\"文件\", true); //向菜单栏中添加菜单 menuBar.add(m1); //创建选项 MenuItem menuItem1 = new MenuItem(\"新建\"); MenuItem menuItem2 = new MenuItem(\"打开\"); //向菜单中添加选项 m1.add(menuItem1); m1.add(menuItem2); Menu m2 = new Menu(\"编辑\", true); menuBar.add(m2); MenuItem menuItem3 = new MenuItem(\"复制\"); MenuItem menuItem4 = new MenuItem(\"粘贴\"); m2.add(menuItem3); m2.add(menuItem4); Menu m3 = new Menu(\"帮助\", true); menuBar.setHelpMenu(m3); MenuItem menuItem5 = new MenuItem(\"问询\"); MenuItem menuItem6 = new MenuItem(\"联系我们\"); m3.add(menuItem5); m3.add(menuItem6); frame.pack(); frame.show();&#125; 效果如下： MenuBar用来创建菜单栏，其中常用方法如下： 123456789101112131415161718//构造方法public MenuBar();//获取帮助菜单public Menu getHelpMenu();//设置帮助菜单public void setHelpMenu(Menu m);//添加菜单public Menu add(Menu m);//根据下标移除菜单public void remove(int index);//移除一个菜单public void remove(MenuComponent m);//获取菜单栏中菜单个数public int getMenuCount();//获取菜单栏中菜单个数 已经弃用 使用上面的方法public int countMenus();//根据下标获取菜单对象public Menu getMenu(int i); Menu类为菜单对象，其中可以添加选项类MenuItem对象，Menu类中常用方法如下： 1234567891011121314151617181920212223242526272829303132//构造函数public Menu();//label参数设置菜单的标题public Menu(String label);//布尔值参数设置是否为tear-off菜单public Menu(String label, boolean tearOff);//获取菜单是否为tear-off菜单public boolean isTearOff();//获取选项个数public int getItemCount();//获取选项个数 已经弃用 使用上面方法public int countItems();//获取某个选项对象public MenuItem getItem(int index);//添加一个菜单选项public MenuItem add(MenuItem mi);//添加一个指定标题的菜单项public void add(String label);//插入一个菜单项public void insert(MenuItem menuitem, int index);//插入一个指定标题的菜单项public void insert(String label, int index) ;//添加分割线public void addSeparator();//插入分割线public void insertSeparator(int index);//根据下标移除一个选项public void remove(int index);//移除一个选项public void remove(MenuComponent item);//移除所有选项public void removeAll() ; 下面是MenuItem类的方法解析： 1234567891011121314151617181920212223242526//构造方法public MenuItem();//label参数设置选项标题public MenuItem(String label);//MenuShortcut为设置快捷键public MenuItem(String label, MenuShortcut s);//获取选项标题public String getLabel() ;//设置选项标题public synchronized void setLabel(String label);//获取选项是否有效public boolean isEnabled();//设置选项public synchronized void setEnabled(boolean b);//获取快捷键public MenuShortcut getShortcut();//设置快捷键public void setShortcut(MenuShortcut s);//删除快捷键public void deleteShortcut();//添加事件监听public synchronized void addActionListener(ActionListener l);//移除事件监听public synchronized void removeActionListener(ActionListener l);//获取所有监听者public synchronized ActionListener[] getActionListeners();","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之列表","slug":"334Java开发GUI之列表","date":"2017-06-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.369Z","comments":true,"path":"2017/06/09/334Java开发GUI之列表/","link":"","permalink":"http://huishao.cc/2017/06/09/334Java开发GUI之列表/","excerpt":"","text":"Java开发GUI之列表awt包中的List控件可以创建一个选择列表，此列表可以支持单选，也可以支持多选。 12345678910111213141516171819202122static void ListTest()&#123; Frame frame = new Frame(\"List\"); Panel pannel = new Panel(); List list = new List(); //向列表中添加选项 list.add(\"鸣人\"); list.add(\"佐助\"); list.add(\"卡卡西\"); list.add(\"小樱\"); list.add(\"釉\"); list.add(\"大蛇丸\"); //设置允许多选 list.setMultipleSelections(true); //添加列表选项切换的监听 list.addItemListener(new ListListener()); //添加列表行为的监听 例如双击某项 list.addActionListener(new ListListener()); pannel.add(list); frame.add(pannel); frame.pack(); frame.show();&#125; ListListener类的简单实现如下： 12345678910111213141516class ListListener implements ActionListener,ItemListener&#123; @Override public void itemStateChanged(ItemEvent e) &#123; // TODO Auto-generated method stub System.out.println(e.getSource()); &#125; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub System.out.println(e); System.out.println(\"======\"); &#125; &#125; List控件中的方法解析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//构造方法public List();//rows:设置行数public List(int rows);//设置行数与是否支持多选 mac上使用command可以多选public List(int rows, boolean multipleMode);//获取列表中选项个数public int getItemCount();//获取列表中选项个数 已经弃用 使用上面的方法public int countItems();//获取某个位置的选项public String getItem(int index);//获取所有选项public synchronized String[] getItems();//添加一个选项public void add(String item);//添加一个选项 已经弃用 使用上面的方法public void addItem(String item);//在指定位置添加一个选项public void add(String item, int index);//在指定位置添加一个选项 已经弃用 使用上面的方法public synchronized void addItem(String item, int index);//替换一个位置的选项public synchronized void replaceItem(String newValue, int index);//删除所有选项public void removeAll();//删除所有选项 已经弃用 使用上面的方法public synchronized void clear();//删除某个选项public synchronized void remove(String item);//移除某个位置的选项public void remove(int position);//删除某个位置的选项 已经弃用 使用上面方法public void delItem(int position);//获取选中的选项的位置public synchronized int getSelectedIndex();//获取所有选中的选项的位置public synchronized int[] getSelectedIndexes();//获取选中的选项public synchronized String getSelectedItem();//获取所有选中的选项public synchronized String[] getSelectedItems();//获取所有选中的选项public Object[] getSelectedObjects();//代码选中某个位置的选项public void select(int index);//代码取消某个选项的选中public synchronized void deselect(int index);//判断某个位置的选项是否选中public boolean isIndexSelected(int index);//判断某个位置的选项是否选中 已经弃用 使用上面方法public boolean isSelected(int index);//获取行数public int getRows();//获取是否可多选public boolean isMultipleMode();//获取是否允许多选 已经弃用 使用上面方法public boolean allowsMultipleSelections();//设置是否允许多选public void setMultipleMode(boolean b);//设置是否允许多选 已经弃用 使用上面方法public synchronized void setMultipleSelections(boolean b);//添加选项选中状态监听public synchronized void addItemListener(ItemListener l);//移除选项选中状态监听public synchronized void removeItemListener(ItemListener l);//获取监听者public synchronized ItemListener[] getItemListeners();//添加用户行为监听public synchronized void addActionListener(ActionListener l);//移除用户行为监听public synchronized void removeActionListener(ActionListener l);//获取监听public synchronized ActionListener[] getActionListeners();","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之Label标签","slug":"333Java开发GUI之Label标签","date":"2017-06-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.369Z","comments":true,"path":"2017/06/07/333Java开发GUI之Label标签/","link":"","permalink":"http://huishao.cc/2017/06/07/333Java开发GUI之Label标签/","excerpt":"","text":"Java开发GUI之Label标签Label控件是awt包中最简单的几个视图控件之一，其用来显示固定的文本，示例如下： 1234567891011Frame frame = new Frame(\"Label\");Panel pannel = new Panel();Label label = new Label(\"刚好遇见你\", Label.LEFT);pannel.add(label);Label label2 = new Label(\"如果再相遇\", Label.CENTER);pannel.add(label2);Label label3 = new Label(\"我会记得你\", Label.RIGHT);pannel.add(label3);frame.add(pannel);frame.pack();frame.show(); Label类中定义了3个静态变量，其中LEFT表示文本左对齐，CENTER表示文本居中对齐，RIGHT表示右对齐。 123456789101112//初始化方法 默认左对齐public Label();public Label(String text);public Label(String text, int alignment);//获取文本对齐模式public int getAlignment(); //设置文本对齐模式public synchronized void setAlignment(int alignment);//获取标签文本public String getText();//设置标签文本public void setText(String text);","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之Dialog弹出窗口","slug":"332Java开发GUI之Dialog弹出窗口","date":"2017-06-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.369Z","comments":true,"path":"2017/06/05/332Java开发GUI之Dialog弹出窗口/","link":"","permalink":"http://huishao.cc/2017/06/05/332Java开发GUI之Dialog弹出窗口/","excerpt":"","text":"Java开发GUI之Dialog弹出窗口 构造方法： 12345678910111213141516171819202122232425//创建弹出窗 owner为拥有其的窗口public Dialog(Frame owner);//创建弹出窗，modal设置其是否是模态的 如果是模态的 则弹出窗显示时不能操作其他窗口public Dialog(Frame owner, boolean modal);//创建弹出窗 title设置弹出窗标题public Dialog(Frame owner, String title);//同上public Dialog(Frame owner, String title, boolean modal);public Dialog(Frame owner, String title, boolean modal, GraphicsConfiguration gc); public Dialog(Dialog owner);public Dialog(Dialog owner, String title);public Dialog(Dialog owner, String title, boolean modal);public Dialog(Dialog owner, String title, boolean modal, GraphicsConfiguration gc);public Dialog(Window owner);public Dialog(Window owner, String title);/*ModalityType是模式枚举MODELESS：不覆盖任何窗口DOCUMENT_MODAL：阻止文档内的所有窗口APPLICATION_MODAL：阻止应用程序的所有窗口TOOLKIT_MODAL*/public Dialog(Window owner, ModalityType modalityType);public Dialog(Window owner, String title, ModalityType modalityType);public Dialog(Window owner, String title, ModalityType modalityType, GraphicsConfiguration gc); 其他常用方法： 12345678910111213141516171819202122232425262728//获取弹出窗是否是模态的public boolean isModal();//设置弹出窗是否为模态窗口public void setModal(boolean modal);//获取弹出窗模态类型public ModalityType getModalityType();//设置弹出窗模态类型public void setModalityType(ModalityType type);//获取弹出窗标题public String getTitle();//设置弹出窗标题public void setTitle(String title);//设置弹出窗显示或隐藏public void setVisible(boolean b);//显示弹出窗 已经弃用 使用setVisible方法public void show();//隐藏弹出窗 已经弃用 使用setVisible方法public void hide();//获取弹出窗是否尺寸可调整public boolean isResizable();//设置弹出窗尺寸是否可调整public void setResizable(boolean resizable);//设置弹出窗透明度public void setOpacity(float opacity);//设置弹出窗形状public void setShape(Shape shape);//设置弹出窗背景色public void setBackground(Color bgColor);","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之选择列表","slug":"331Java开发GUI之选择列表","date":"2017-06-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.369Z","comments":true,"path":"2017/06/02/331Java开发GUI之选择列表/","link":"","permalink":"http://huishao.cc/2017/06/02/331Java开发GUI之选择列表/","excerpt":"","text":"Java开发GUI之选择列表选择列表在多个选项供用户进行选择的场景中使用广泛。其使用也非常简单，Java的awt包中提供了Choice控件，示例代码如下： 12345678910111213141516171819public static Label label = new Label();static void choseTest()&#123; Frame frame = new Frame(\"BUTTON\"); Panel pannel = new Panel(); //创建选择列表 Choice choice = new Choice(); //添加选项 choice.add(\"鸣人\"); choice.addItem(\"佐助\"); choice.insert(\"卡卡西\", 0); //添加用户选择改变的监听 choice.addItemListener(new MyItemListener()); pannel.add(choice); label.setText(choice.getSelectedItem()+\"一定可以成为最NB的火影！\"); pannel.add(label); frame.add(pannel); frame.pack(); frame.show();&#125; MyItemListener类实现如下： 12345678910111213class MyItemListener implements ItemListener&#123; @Override public void itemStateChanged(ItemEvent e) &#123; // TODO Auto-generated method stub if (e.getSource().getClass()==Choice.class) &#123; ButtonTest.label.setText(e.getItem()+\"一定可以成为最NB的火影！\"); &#125;else&#123; System.out.println(((Checkbox)e.getSource()).getState()); &#125; &#125; &#125; 运行效果如下： Choice类解析如下： 123456789101112131415161718192021222324252627282930//获取选项个数public int getItemCount();//获取某个选项public String getItem(int index);//追加一个选项public void add(String item);public void addItem(String item);//插入一个选项public void insert(String item, int index);//通过标题删除一个选项public void remove(String item);//通过位置删除一个选项public void remove(int position);//删除所有选项public void removeAll();//获取当前选中的选项标题public synchronized String getSelectedItem();//获取当前选中的选项位置public int getSelectedIndex();//用代码选中某个位置的选项public synchronized void select(int pos);//用代码选中某个标题的选项public synchronized void select(String str);//添加用户选择监听public synchronized void addItemListener(ItemListener l);//移除监听public synchronized void removeItemListener(ItemListener l);//获取所有监听对象public synchronized ItemListener[] getItemListeners();public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType);","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之单复选框","slug":"330Java开发GUI之单复选框","date":"2017-05-31T16:00:00.000Z","updated":"2023-04-14T11:50:08.368Z","comments":true,"path":"2017/06/01/330Java开发GUI之单复选框/","link":"","permalink":"http://huishao.cc/2017/06/01/330Java开发GUI之单复选框/","excerpt":"","text":"Java开发GUI之单复选框单复选框在处理一些用户选项时十分方便。在Java的GUI体系中，复选框使用Checkbox类来创建，单选框实际上是将多个复选框结合成为组，同一组的复选框同时只能有一个被选中。 12345678910111213141516171819202122232425262728Frame frame = new Frame(\"BUTTON\");Panel pannel = new Panel();frame.add(pannel);MyItemListener listener = new MyItemListener();//无参的构造方法Checkbox checkbox1 = new Checkbox();//设置显示文本checkbox1.setLabel(\"是否已退款\");//设置选中状态checkbox1.setState(true);//添加状态变化监听checkbox1.addItemListener(listener);//使用设置文本和状态的构造方法Checkbox checkbox2 = new Checkbox(\"是否开通额外服务\", false);checkbox2.addItemListener(listener);pannel.add(checkbox1);pannel.add(checkbox2);//创建组CheckboxGroup group = new CheckboxGroup();Checkbox checkbox3 = new Checkbox(\"男\", false);checkbox3.addItemListener(listener);checkbox3.setCheckboxGroup(group);Checkbox checkbox4 = new Checkbox(\"女\", false, group);checkbox4.addItemListener(listener);pannel.add(checkbox3);pannel.add(checkbox4);frame.pack();frame.show(); MyItemListener实现了ItemListener接口，如下： 123456789class MyItemListener implements ItemListener&#123; @Override public void itemStateChanged(ItemEvent e) &#123; // TODO Auto-generated method stub System.out.println(((Checkbox)e.getSource()).getState()); &#125; &#125; 效果如下图所示： Checkbox类常用方法汇总： 12345678910111213141516171819//获取标题文本public String getLabel();//设置标题public void setLabel(String label);//获取当前复选框的选中状态public boolean getState();//设置当前复选框的选中状态public void setState(boolean state);//获取复选框所在的组public CheckboxGroup getCheckboxGroup();//设置复选框组public void setCheckboxGroup(CheckboxGroup g);//添加状态监听对象public synchronized void addItemListener(ItemListener l);//移除状态监听对象public synchronized void removeItemListener(ItemListener l);//获取状态监听对象public synchronized ItemListener[] getItemListeners();public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType); CheckboxGroup常用方法汇总： 1234//获取组中当前选中的checkboxpublic Checkbox getSelectedCheckbox();//设置当前选中的checkboxpublic void setSelectedCheckbox(Checkbox box);","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"Java开发GUI之Button控件","slug":"329Java开发GUI之Button控件","date":"2017-05-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.368Z","comments":true,"path":"2017/05/26/329Java开发GUI之Button控件/","link":"","permalink":"http://huishao.cc/2017/05/26/329Java开发GUI之Button控件/","excerpt":"","text":"Java开发GUI之Button控件Java中的awt包提供了丰富的用户界面组件。重要的是，Java的跨平台性使用awt包可以在Windows，MacOS等平台创建桌面软件。本篇博客总结Button控件的简单使用。 1234567891011121314151617181920212223242526272829303132package App;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class ButtonTest &#123; public static void main(String[] args ) &#123; //创建面板 Frame frame = new Frame(\"BUTTON\"); //创建按钮 Button button1 = new Button(); //设置按钮标题 button1.setLabel(\"按钮\"); //设置按钮标记 用在触发方法中分区按钮 button1.setActionCommand(\"tag1\"); //获取按钮标题 System.out.println(button1.getLabel()); //添加按钮 frame.add(button1); //添加交互监听 button1.addActionListener(new MyActionListener()); frame.pack(); frame.show(); &#125;&#125;class MyActionListener implements ActionListener&#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub //这里可以取到按钮设置的actionCommand值 System.out.println(e.getActionCommand()); &#125;&#125; 与addActionCommand方法对应，Button类中还有一些移除监听与获取监听者的方法，如下： 123456//移除一个监听者public synchronized void removeActionListener(ActionListener l);//获取监听者列表public synchronized ActionListener[] getActionListeners();//获取监听者列表 泛型数组public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType); ActionEvent类中定义了交互行为的一些特征，示例如下： 1234567891011121314class MyActionListener implements ActionListener&#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO Auto-generated method stub //获取触发时间 System.out.println(e.getWhen()); //获取触发模式 System.out.println(e.getModifiers()); //获取触发事件的控件 此处为Button按钮 System.out.println(e.getSource()); //获取关联的actionCommand值 System.out.println(e.getActionCommand()); &#125;&#125; getModifiers方法获取事件的模式，返回值定义如下： 12345678//按住shift键点击按钮public static final int SHIFT_MASK = Event.SHIFT_MASK;//按住ctrl键点击按钮public static final int CTRL_MASK = Event.CTRL_MASK;//按住meta键点击按钮public static final int META_MASK = Event.META_MASK;//按住alt键点击按钮public static final int ALT_MASK = Event.ALT_MASK;","categories":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"http://huishao.cc/categories/Java/"}]},{"title":"iOS开发中活动视图控制器UIActivityViewController的应用","slug":"328iOS开发中活动视图控制器UIActivityViewController的应用","date":"2017-05-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.368Z","comments":true,"path":"2017/05/15/328iOS开发中活动视图控制器UIActivityViewController的应用/","link":"","permalink":"http://huishao.cc/2017/05/15/328iOS开发中活动视图控制器UIActivityViewController的应用/","excerpt":"","text":"iOS开发中活动视图控制器UIActivityViewController的应用在iOS开发中，UIActivityViewController常用来弹出分享面板，其实除了用来社会化分享，UIActivityViewController还有一大应用是用来进行自定义行为。先看如下示例代码： 123456789101112//活动内容NSString * content = @\"活动的内容\";//活动的urlNSURL * url = [NSURL URLWithString:@\"https://www.baidu.com\"];//活动的图片UIImage * image = [UIImage imageNamed:@\"ios\"];UIActivityViewController * con = [[UIActivityViewController alloc]initWithActivityItems:@[content,url,image] applicationActivities:nil];//活动行为结束后回调的blockcon.completionWithItemsHandler = ^(UIActivityType activityType, BOOL completed, NSArray * returnedItems, NSError * __nullable activityError)&#123; NSLog(@\"%@\\n%@\",activityType,returnedItems);&#125;;[self presentViewController:con animated:YES completion:nil]; 活动面板如下图： 需要注意，活动面板可以分为3个部分，最上面为AirDrop传输功能，中间为分享相关功能，最下面为数据处理功能。UIActivityViewController继承自UIViewController，类解析如下： 1234567891011121314151617181920212223242526//初始化方法- (instancetype)init;- (instancetype)initWithNibName:(nullable NSString *)nibNameOrNil bundle:(nullable NSBundle *)nibBundleOrNil;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder;/*activityItems参数用来设置活动数据数组，其中可以是任意类型的对象，但是只有可以处理这些数据的行为会被展示出来applicationActivitie参数可以设置自定义的操作行为，后面会介绍*/- (instancetype)initWithActivityItems:(NSArray *)activityItems applicationActivities:(nullable NSArray&lt;__kindof UIActivity *&gt; *)applicationActivitie;/*活动行为结束后执行的回调block，其中参数如下：typedef void (^UIActivityViewControllerCompletionWithItemsHandler)(UIActivityType __nullable activityType, BOOL completed, NSArray * __nullable returnedItems, NSError * __nullable activityError);activityType:活动的类型completed:活动是否完成returnItems:扩展程序返回的数据*/@property(nullable, nonatomic, copy) UIActivityViewControllerCompletionWithItemsHandler completionWithItemsHandler;//这个参数可以设置不被显示的活动类型@property(nullable, nonatomic, copy) NSArray&lt;UIActivityType&gt; *excludedActivityTypes;//下面这些方法在iOS8后被弃用 在iOS6-iOS8之前可用//设置活动行为结束后回调的block/*typedef void (^UIActivityViewControllerCompletionHandler)(UIActivityType __nullable activityType, BOOL completed);*/@property(nullable, nonatomic, copy) UIActivityViewControllerCompletionHandler completionHandler; 上面初始化方法中有提到activityItems这个参数，系统提供的一些分享与活动行为可支持的数据类型列表如下： 系统提供了一些活动类型，例如分享到微博、脸书、进行添加提示、发送信息等，系统提供的活动类型列举如下(UIActivityType实际上就是NSString*)： 123456789101112131415UIActivityType const UIActivityTypePostToFacebook;//脸书UIActivityType const UIActivityTypePostToTwitter;//推特UIActivityType const UIActivityTypePostToWeibo; // 微博UIActivityType const UIActivityTypeMessage;//发送信息UIActivityType const UIActivityTypeMail;//发送邮件UIActivityType const UIActivityTypePrint;//打印UIActivityType const UIActivityTypeCopyToPasteboard;//复制UIActivityType const UIActivityTypeAssignToContact;//关联到联系人UIActivityType const UIActivityTypeSaveToCameraRoll;//存照片UIActivityType const UIActivityTypeAddToReadingList;//添加到提醒列表UIActivityType const UIActivityTypePostToFlickr;//FlickrUIActivityType const UIActivityTypePostToVimeo;//VimeoUIActivityType const UIActivityTypePostToTencentWeibo;//腾讯微博UIActivityType const UIActivityTypeAirDrop;//AirDropUIActivityType const UIActivityTypeOpenInIBooks;//在IBooks中打开 自定义活动行为需要创建继承于UIActivity类的子类，示例如下： 123456789101112131415161718192021222324252627282930313233343536#import \"CustomActivity.h\"@implementation CustomActivity//设置活动类别+(UIActivityCategory)activityCategory&#123; return UIActivityCategoryShare;&#125;//设置活动类型-(UIActivityType)activityType&#123; return @\"Custom\";&#125;//设置活动标题-(NSString *)activityTitle&#123; return @\"title\";&#125;//设置活动图标-(UIImage *)activityImage&#123; return [UIImage imageNamed:@\"ios\"];&#125;//设置是否可以对指定的数据进行响应-(BOOL)canPerformWithActivityItems:(NSArray *)activityItems&#123; NSLog(@\"%@\",activityItems); return YES;&#125;//为要响应的活动进行准备工作- (void)prepareWithActivityItems:(NSArray *)activityItems&#123; &#125;//响应互动-(void)performActivity&#123; NSLog(@\"=========\"); //活动处理完成后 必须调用activityDidFinish函数 [self activityDidFinish:YES];&#125;@end 用自定义的活动对UIActivityViewController进行初始化： 123456789NSString * content = @\"活动的内容\";NSURL * url = [NSURL URLWithString:@\"https://www.baidu.com\"];UIImage * image = [UIImage imageNamed:@\"ios\"];CustomActivity * activity = [[CustomActivity alloc]init];UIActivityViewController * con = [[UIActivityViewController alloc]initWithActivityItems:@[content,url,image] applicationActivities:@[activity]];con.completionWithItemsHandler = ^(UIActivityType activityType, BOOL completed, NSArray * returnedItems, NSError * __nullable activityError)&#123; NSLog(@\"%@\\n%@\",activityType,returnedItems);&#125;;[self presentViewController:con animated:YES completion:nil]; 效果如下图所示： UIActivity类解析如下： 123456789101112131415161718192021222324//子类实现，设置自定义活动的类别/*typedef NS_ENUM(NSInteger, UIActivityCategory) &#123; UIActivityCategoryAction,//行为类别 显示在活动面板下面 UIActivityCategoryShare,//分享类别，显示在活动面板中间&#125;;*/+ (UIActivityCategory)activityCategory;//子类实现 设置自定义活动的类型 返回字符串- (nullable UIActivityType)activityType;//子类实现 设置自定义活动的标题 返回字符串 - (nullable NSString *)activityTitle;//子类实现 设置自定义活动的图标 UIImage - (nullable UIImage *)activityImage; //子类实现 activityItems为活动数据数组 返回布尔值决定此活动是否可以响应这些数据- (BOOL)canPerformWithActivityItems:(NSArray *)activityItems;//子类实现 如果上面的方法返回YES，会接着执行这个方法，开发者可以做些活动处理的准备- (void)prepareWithActivityItems:(NSArray *)activityItems;//子类实现 返回一个视图控制器作为处理活动的模态视图 活动处理完成后需要调用activityDidFinish方法 - (nullable UIViewController *)activityViewController; //子类实现 如果子类没有实现上一个方法 或者返回nil，则会执行这个方法来处理活动 活动处理完成后需要调用activityDidFinish方法- (void)performActivity; //活动处理完成后需要调用这个方法 之后会通知UIActivityViewController执行活动完成后的回调block- (void)activityDidFinish:(BOOL)completed;","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"动态的Objective-C——关于消息机制与运行时的探讨","slug":"327动态的Objective-C——关于消息机制与运行时的探讨","date":"2017-05-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.368Z","comments":true,"path":"2017/05/05/327动态的Objective-C——关于消息机制与运行时的探讨/","link":"","permalink":"http://huishao.cc/2017/05/05/327动态的Objective-C——关于消息机制与运行时的探讨/","excerpt":"","text":"动态的Objective-C——关于消息机制与运行时的探讨一、引言Objective-C是一种很优美的语言，至少在我使用其进行编程的过程中，是很享受他那近乎自然语言的函数命名、灵活多样的方法调用方式以及配合IDE流顺畅快编写体验。Objective-C是扩展与C面向对象的编程语言，然而其方法的调用方式又和大多面向对象语言大有不同，其采用的是消息传递、转发的方式进行方法的调用。因此在Objective-C中对象的真正行为往往是在运行时确定而非在编译时确定，所以Objective-C又被称为是一种运行时的动态语言。 本篇博客既不介绍iOS开发，也不提及MacOS开发，只对Objective-C语言的这种消息机制与运行时动态进行探讨，所提及的内容也都是我开发中的个人积累与经验，如果偏颇之处，欢迎讨论指正。 二、消息发送与转发机制1.初窥消息发送机制许多面向对象语言中方法的调用都是采用obj.function这样的方式，在Objective-C语言中却是采用中括号包裹的方式进行方法调用，例如\\[obj function\\]。实际上，Objective-C中的每一句方法调用最后都会转换成一条消息进行发送。一条消息包含3部分内容：方法选择器、接收消息的对象以及参数。objc_msgSend函数就是用来发送这种消息。例如，创建一个Xcode命令行工程，我们创建一个类，命名为MyObject，如下： MyObject.h文件： 12345#import &lt;Foundation/Foundation.h&gt;@interface MyObject : NSObject@end MyObject.m文件： 123456789#import \"MyObject.h\"@implementation MyObject-(void)showSelf&#123; NSLog(@\"MyObject\");&#125;@end 首先在MyObject.h文件中并没有暴漏任何方法，MyObject.m文件中添加了一个showSelf方法，这个方法只是做了简单的打印操作。 将main.m文件修改如下： 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import \"MyObject.h\"#import &lt;objc/message.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyObject * obj = [[MyObject alloc]init]; [obj class];//为了消除未定义选择器的警告#pragma clang diagnostic push#pragma clang diagnostic ignored\"-Wundeclared-selector\" //进行消息发送 ((void(*)(id,SEL))objc_msgSend)(obj,@selector(showSelf));#pragma clang diagnostic pop &#125; return 0;&#125; 运行工程，可以看到控制台执行了MyObject类的示例方法showSelf。如果要进行传参，在objc_msgSend方法中继续添加参数，并且指定对应的函数类型即可，例如： MyObject.m文件： 123456789#import \"MyObject.h\"@implementation MyObject-(void)showSelf:(NSString*)name age:(int)age&#123; NSLog(@\"MyObject:%@,%d\",name,age);&#125;@end main.m文件： 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import \"MyObject.h\"#import &lt;objc/message.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyObject * obj = [[MyObject alloc]init]; [obj class];//为了消除未定义选择器的警告#pragma clang diagnostic push#pragma clang diagnostic ignored\"-Wundeclared-selector\" //进行消息发送 ((void(*)(id,SEL,NSString*,int))objc_msgSend)(obj,@selector(showSelf:age:),@\"珲少\",25);#pragma clang diagnostic pop &#125; return 0;&#125; 运行工程可以看到方法被调用，参数被正确传入。 2.消息传递是基于继承链的上面代码只是简单演示了消息发送的效果，下面我们来剖析下消息发送的过程与原理，明白了这个原理，对Objective-C中许多神奇的现象你将会豁然开朗，后面我会再具体向你介绍这些现象。 在介绍消息机制之前，我还是要再啰嗦一点，关于@selector()我们还需要深入理解一下，通过@selector(方法名)可以获取到一个SEL类型的对象，SEL实际上是objc\\_selector结构体指针，在Objective-C库头文件中没有找到objc\\_selector结构体的定义，但我们可以合理猜测，其中很有可能包含的是一个函数指针。因此SEL也可以理解为函数签名，在程序的编译阶段，我们定义类中所有所发会生成一个方法签名列表，这个列表时类直接关联的(原则上来说，类的本质也是对象，它是一个单例对象)，在运行时通过方法签名表来找到具体要执行的函数。 我们再来看objc_msgSend()函数，前面说过，它的第一个参数为接收消息的对象，第2个参数为方法签名，之后为传递的参数。那么Objective-C运行时是如何根据一个对象实例来找到方法签名表，再找到要执行的方法呢，看似麻烦的事情其实原理也非常简单，细心观察，你会发现所有的NSObject子类对象中都包含一个isa成员变量，请看NSObject类的定义： 123@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; 这个isa变量是Class类型，我们的主角终于来了，Class顾名思义就是“类”类型，其实质是objc_class结构体指针： 1typedef struct objc_class *Class; 有些蒙圈了吧，不用着急，拨开层层迷雾，你就会发现Objective-C中类本质上只是结构体而已，下面是objc_class结构体的定义： 1234567891011121314151617181920212223242526struct objc_class &#123; //元类指针 Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ //父类 Class super_class OBJC2_UNAVAILABLE; //类名 const char *name OBJC2_UNAVAILABLE; //类的版本 long version OBJC2_UNAVAILABLE; //信息 long info OBJC2_UNAVAILABLE; //内存布局 long instance_size OBJC2_UNAVAILABLE; //变量列表 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; //函数列表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; //缓存方式 struct objc_cache *cache OBJC2_UNAVAILABLE; //协议列表 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 每一个“类”对象是也有一个isa指针，这个指针指向的类实际上是元类，即构造“类”的类。现在你无须纠结这些概念，举一个例子你就能明白，在Objective-C开发中有加方法与减方法，减方法是实例对象调用的方法，每一个“类”中都包含一个函数列表，就是上面的objc_method_list结构体数组指针，同样如果调用加方法，实际上是从类的元类中找到对应的方法列表，这个列表就是我们前面提到的方法签名列表，进行方法的执行。关于实例对象，“类”对象和元类，下图很好的表现了他们之间的关系： 需要注意，使用LLDB调试器我们是可以拿到对象的isa指针的，并且可以看出它的确为Class类型，但是我们缺无法通过isa指针继续向下取抓取更多类的信息，其所在的内存是禁止我们访问的。但是Objective-C运行时提供了一些方法可以获取到这些信息，后面我们会一一介绍。 上面我们介绍的消息发送机制其实十分不完整，首先Objective-C是支持继承的，因此如果在当前对象的类的方法列表中没有找到此消息对应的方法签名，系统会通过super_class一层层继续向上，直到找到相应的方法或者到达继承链的顶端。 有了上面的理论知识作为基础，我们就可以更深入的分析消息传递的过程了，首先，如果消息的接收对象刚好可以处理这个消息，即其isa指针对应的类中可以查找到这个方法，那么万事大吉，找到对应方法直接执行就大功告成，可以如果接收对象无法处理，其父类，父父类...等都无法处理，那么该怎么办呢，Objective-C为了增强语言的动态性，如果真的出现了这种情况，程序并不会马上crash，在crash前，有3次机会可以挽救本条消息的命运。 3.拯救未知消息的3根救命稻草第一根救命稻草： 如上所说，如果对象整个继承链都无法处理当前消息，那么首先会调用接收对象所属类的resolveInstanceMethod方法(这个对应实例方法，如果是无法处理的类方法消息，则会调用resolveClassMethod方法)，在这个方法中，开发者有机会为类动态添加方法，如果动态添加了方法，可以在这个方法中返回YES，那么此条消息依然会被成功处理。例如我们将main.m文件修改如下： 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import \"MyObject.h\"#import &lt;objc/message.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyObject * obj = [[MyObject alloc]init]; [obj class];//为了消除未定义选择器的警告#pragma clang diagnostic push#pragma clang diagnostic ignored\"-Wundeclared-selector\" //进行消息发送 ((void(*)(id,SEL))objc_msgSend)(obj,@selector(showSelf));#pragma clang diagnostic pop &#125; return 0;&#125; MyObject类不做任何修改，当我们运行程序，程序会直接crash掉，现在我们在MyObject类中添加如下方法： 1234567+(BOOL)resolveInstanceMethod:(SEL)sel&#123; NSLog(@\"resolveInstanceMethod\"); if ([NSStringFromSelector(sel) isEqualToString:@\"showSelf\"]) &#123; class_addMethod(self, sel, newFunc, \"v@:\"); &#125; return [super resolveInstanceMethod:sel];&#125; 其中class_addMethod函数用来向类中动态添加方法，第一个参数为Class对象，第二个参数为方法选择器，第三个参数为IMP类型的函数指针，第四个参数为指定方法的返回值和参数类型。这个参数采用的是C字符串的形式来指定返回值和参数的类型，第1个字符为返回值类型，其后都为参数类型，需要注意，使用这种方式添加方法的时候系统会默认传入两个参数，分别是调用此方法的实例对象和方法选择器，上面示例代码中的”@”表示第1个id类型的参数，”:”表示第2个选择器类型的参数，后面我会把字符所表示的参数类型映射表提供给大家。 抽丝剥茧一下，IMP和SEL并不同，SEL可以理解为函数签名，其与函数名相关联，而IMP是函数所在地址的指针，其定义如下： 1typedef void (*IMP)(void /* id, SEL, ... */ ); 简单理解，通过IMP我们可以直接拿到函数的地址，后面会对函数做更深入的剖析，到时候你能就能豁然你开朗。 运行工程，根据打印信息可以看到showSelf方法被添加并正常执行了。 第二根救命稻草： 抛开运行时添加方法这一手段，将resolveInstanceMethod方法删去，是不是我们的程序就必然走进crash的深渊了，其实不然，上帝还会给你另一根救命稻草，当通过运行时添加方法被否定后，系统会接着调用forwardingTargetForSelector方法，这个方法用来对消息进行转发，没错，重点来了，Objective-C中强大的消息转发机制的奥妙就在这里。forwardingTargetForSelector方法需要返回一个id类型的对象，系统会将当前对象服务处理的消息转发给这个方法返回的对象，如果这个返回的对象可以处理，那么程序依然可以很好的执行下去。 例如，在我们的命令行工程中新添加一个类，命名为SubObject，实现如下： SubObject.h文件： 12345#import &lt;Foundation/Foundation.h&gt;@interface SubObject : NSObject@end SubObject.m文件： 1234567#import \"SubObject.h\"@implementation SubObject-(void)showSelf&#123; NSLog(@\"subObject\");&#125;@end 在MyObject类中实现如下方法： 1234567-(id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@\"forwardingTargetForSelector\"); if ([NSStringFromSelector(aSelector) isEqualToString:@\"showSelf\"]) &#123; return [SubObject new]; &#125; return [super forwardingTargetForSelector:aSelector];&#125; forwardingTargetForSelector方法可以返回一个对象，Objective-C会将当前对象无法处理的消息转发给这个方法返回的对象，如果返回nil，则表示不进行消息转发，这时你如果还想挽救此次crash，你就需要用到第三根救命稻草了。我们可以这种消息转发的机制来模拟Objective-C中的多继承。 第三根救命稻草： 如果你不幸错过了前两次拯救未知消息的机会，那么你还有最后一次机会(中国有句古话，事不过三，世间万事也果真如此...)。当消息转发策略也被否定后，系统会调用methodSignatureForSelector方法，这个方法的主要用途是询问这个选择器是否是有效的，我们需要返回一个NSMethodSignature，顾名思义，这个对象是函数签名的抽象。如果我们返回了有效的函数签名，那么接着系统会调用forwardInvocation方法，这里是拯救应用程序的最后一根稻草了，这个函数会直接将消息包装成NSInvocation对象传入，我们直接将其发送给可以处理此消息的对象即可(当然你也可以直接抛弃，不理会这条未知的消息)。 例如，在MyObject类中将forwardingTargetForSelector方法删去，实现如下两个方法： 1234567891011121314151617//询问此选择器是否是有效的-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSLog(@\"methodSignatureForSelector\"); if ([NSStringFromSelector(aSelector) isEqualToString:@\"showSelf\"]) &#123; return [[SubObject new] methodSignatureForSelector:aSelector]; &#125; return [super methodSignatureForSelector:aSelector];&#125;//处理消息-(void)forwardInvocation:(NSInvocation *)anInvocation&#123; NSLog(@\"forwardInvocation\"); if ([NSStringFromSelector(anInvocation.selector) isEqualToString:@\"showSelf\"]) &#123; [anInvocation invokeWithTarget:[SubObject new]]; &#125;else&#123; [super forwardInvocation:anInvocation]; &#125;&#125; 再次运行工程，程序又被你挽救了一次。 你真的需要救命稻草么？ 通过上面的三根救命稻草，我相信你一定对Objective-C消息机制有了全面而深入的了解，上面的代码也只是为了示例所用，正常情况下，你都不会使用到这些函数(毕竟如果你需要救命稻草，说明你已经落水了)。除非某些特殊需求或者做一些调试框架的开发，否则尽量不要介入消息的发送机制，就像生病就医，发现问题总比逃避治疗要好。顺便说一下，如果你没有使用任何救命稻草，当向某个对象发送了无法处理的消息时，系统会最终调用到NSObject类的doesNotRecognizeSelector方法，这个方法会抛出异常信息，正因如此，你在Xcode的控制台会经常看到如下图所示的crash信息： 你也可以重写这个方法来自定义输出信息，例如： 12345678-(void)doesNotRecognizeSelector:(SEL)aSelector&#123; NSLog(@\"doesNotRecognizeSelector\"); if ([NSStringFromSelector(aSelector) isEqualToString:@\"showSelf\"]) &#123; NSLog(@\"not have a method named showSelf\"); return; &#125; [super doesNotRecognizeSelector:aSelector];&#125; 下图完整展示了Objective-C整个消息发送与转发机制： 三、发送消息的几个函数1.最重要的两个发送消息函数既然Objective-C函数最终的调用都是要转换成消息发送，那么了解下面这些消息发送函数是十分必要的，这些方法都定义在objc/message.h文件中，其中最重要的两个方法是： 1234567891011121314//发送消息的函数/*self:消息的接收对象op:方法选择器...:参数*/id objc_msgSend(id self, SEL op, ...);//发送消息给父类/*super:父类对象结构体 op:方法选择器...:参数*/id objc_msgSendSuper(struct objc_super *super, SEL op, ...); objc_msgSend函数前面已经有过介绍，objc_msgSendSuper函数则是从父类中找方法的实现进行执行。需要注意，这个函数非常重要，理解了这个这个函数进行消息发送的原理，你就明白super关键字的某些令人疑惑的行为了。 2.super关键字到底做了什么做了这么久的Objective-C开发，你是否真的理解super关键字的含义？你一定会说，这很简单啊，self调用本类的方法，super调用父类的方法。那么我们来看一个小案例： 在前面创建的命令行工程中新建一个类，使其继承于MyObject类，命名为MyObjectSon，在其中提供两个方法，如下： MyObjectSon.h文件： 12345#import \"MyObject.h\"@interface MyObjectSon : MyObject-(void)showClass;-(void)showSuperClass;@end MyObjectSon.m文件： 12345678910#import \"MyObjectSon.h\"@implementation MyObjectSon-(void)showClass&#123; NSLog(@\"%@\",[self className]);&#125;-(void)showSuperClass&#123; NSLog(@\"%@\",[super className]);&#125;@end 分别调用两个方法，你会惊奇的发现，打印结构都是“MyObjectSon”，super关键字失效了么？非也非也，下面我们来用消息发送机制重新模拟这两个方法的调用。 首先\\[self className\\]在调用时会采用前面介绍的消息发送机制先从当前类中找className函数，当前类中并没有提供className函数，所以消息会随着继承链向上传递，找到MyObject类中也没有className函数的实现，会继续向上，最终在NSObject类中找到这个方法，记住，这条消息处理的两个要素是：当前MyObjectSon实例对象作为接收者，NSObject类中的className方法作为调用函数。 当调用\\[super className\\]时，首先会使用objc_msgSendSuper方法进行消息的发送，等价于如下代码： 123456-(void)showSuperClass&#123; //创建父类接收对象结构体 struct objc_super superObj = &#123;self, object_getClass([MyObject new])&#125;; NSString * name = ((id(*)(struct objc_super*,SEL))objc_msgSendSuper)(&amp;superObj,@selector(className)); NSLog(@\"%@\",name);&#125; objc_msgSendSuper函数第一个参数为一个父类接收者结构体指针，objc_super结构体定义如下： 123456struct objc_super &#123; //接收者 __unsafe_unretained id receiver; //接收者类型 __unsafe_unretained Class super_class;&#125;; 在构造objc_super这个结构体时，receive为接收消息的对象，super_class为从哪个类中查方法。如此来看一些都清楚了，系统首先从MyObject类中找className方法，没有相应的实现，会继续向上直到找到NSObject类中的className方法，之后进行执行。这条消息处理的两个要素是：当前MyObjectSon实例对象作为接收者，NSObject类中的className方法作为调用函数。这样分析下来，无论是使用self执行的className方法还是使用super执行的className方法，行为实质上是完全一致的！ 3.一些辅助的消息发送函数特殊返回值类型对应不同的发送消息函数： 12345//返回值为结构体时使用此方法发送消息void objc_msgSend_stret(id self, SEL op, ...);void objc_msgSendSuper_stret(struct objc_super *super, SEL op, ...);//返回值为浮点数时使用此方法发送消息double objc_msgSend_fpret(id self, SEL op, ...); 除了使用SEL方法选择器来发送消息，也可以直接使用Method来发送消息： 123456789//进行函数的调用/*receiver:接收者m:函数...:参数*/id method_invoke(id receiver, Method m, ...);//返回结构体数据的函数调用void method_invoke_stret(id receiver, Method m, ...); Method也是一种结构体指针，其定义如下： 12345678struct objc_method &#123; //选择器 SEL method_name OBJC2_UNAVAILABLE; //参数类型 char *method_types OBJC2_UNAVAILABLE; //函数地址 IMP method_imp OBJC2_UNAVAILABLE;&#125; 示例代码如下： 123456789101112131415int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyObject * obj = [[MyObject alloc]init]; [obj class];//为了消除未定义选择器的警告#pragma clang diagnostic push#pragma clang diagnostic ignored\"-Wundeclared-selector\" //进行消息发送 Method method = class_getInstanceMethod([MyObject class], @selector(showSelf:age:)); ((void(*)(id,Method,NSString *,int))method_invoke)(obj,method,@\"珲少\",25);#pragma clang diagnostic pop &#125; return 0;&#125; 下面这些方法可以跳过当前对象，直接进行消息转发： 123//跳过当前对象直接进行消息转发机制id _objc_msgForward(id receiver, SEL sel, ...);void _objc_msgForward_stret(id receiver, SEL sel, ...); 一点建议，上面两个方法都是以下划线开头，这也表明设计者并不想让你直接调用这个方法，确实如此，这两个方法会直接出发对象的消息转发流程，即便当前对象类已经实现了相应的方法也不会进行查找。 四、是时候来重温下Runtime了所谓运行时是针对于编译时而言的，本篇文章的开头，我们就说过Objective-C是一种极动态的运行时语言。对象的行为是在运行时被决定的，我们前边也了解了有关isa指针即Class的内容，虽然我们并不能直接访问isa指针，但是我们可以通过objc/runtime.h文件中定义的运行时方法来获取或改变类与对象的行为。 1.类相关操作函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//对OC对象进行内存拷贝 在ARC环境下不可用/*obj:要拷贝的对象size:内存大小*/id object_copy(id obj, size_t size);//进行OC对象内存的释放 在ARC环境下不可用id object_dispose(id obj);//获取OC对象的类 注意 这个返回值和isa指针并不是同一个指针Class object_getClass(id obj); //重建对象的类Class object_setClass(id obj, Class cls); //判断一个OC对象是否是类或元类(前面说过类实际上也是对象)BOOL object_isClass(id obj);//获取OC对象的类名const char *object_getClassName(id obj);//通过类名获取“类”对象Class objc_getClass(const char *name);//通过类名获取元类对象Class objc_getMetaClass(const char *name);//这个方法也是返回类的定义 只是如果是未注册的 会返回nilClass objc_lookUpClass(const char *name);//这个方法也是返回类的定义 只是如果是未注册的 会直接杀死进程Class objc_getRequiredClass(const char *name);/*获取所有已经注册的类 会返回已经注册的类的个数通常使用如下示例代码：int numClasses; Class * classes = NULL; numClasses = objc_getClassList(NULL, 0); if (numClasses &gt; 0) &#123; classes = (Class*)malloc(sizeof(Class) * numClasses); numClasses = objc_getClassList(classes, numClasses); NSLog(@\"number of classes: %d\", numClasses); for (int i = 0; i &lt; numClasses; i++) &#123; Class cls = classes[i]; NSLog(@\"class name: %s\", class_getName(cls)); &#125; free(classes); &#125;*/int objc_getClassList(Class *buffer, int bufferCount);//拷贝所有注册过的类列表 参数为输出类的个数Class *objc_copyClassList(unsigned int *outCount);//获取Class类名字符串const char *class_getName(Class cls);//判断一个Class是否为元类BOOL class_isMetaClass(Class cls);//获取一个类的父类Class class_getSuperclass(Class cls);//修改一个类的父类Class class_setSuperclass(Class cls, Class newSuper);//获取一个类的版本int class_getVersion(Class cls);//设置一个类的版本void class_setVersion(Class cls, int version);//获取类的内存布局size_t class_getInstanceSize(Class cls); 上面列举的方法都和类相关，你没看错，通过object_setClass()动态改变对象所属的类，但是需要注意，对象的成员变量并不会受到影响，方法则全部替换为新类的方法。如果你喜欢，你甚至可以运行时动态修改类的父类，这十分酷吧。下面这些方法则与类中的变量有关： 2.变量属性相关操作函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//获取类额外分配内存的指针void *object_getIndexedIvars(id obj);//根据变量名获取实例变量指针/*Ivar实质上是一个结构体指针，存放变量信息，如下：struct objc_ivar &#123; //变量名 char *ivar_name OBJC2_UNAVAILABLE; //变量类型 char *ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif&#125; */Ivar class_getInstanceVariable(Class cls, const char *name);//根据变量名获取类变量指针Ivar class_getClassVariable(Class cls, const char *name);//获取所有实例变量指针 outCount输出实例变量个数Ivar *class_copyIvarList(Class cls, unsigned int *outCount);//通过变量指针获取具体变量的值id object_getIvar(id obj, Ivar ivar);//通过变量指针设置具体变量的值void object_setIvar(id obj, Ivar ivar, id value);//通过变量指针设置变量的值 并进行强引用void object_setIvarWithStrongDefault(id obj, Ivar ivar, id value);//直接通过变量名修改实例变量的值 会返回变量指针Ivar object_setInstanceVariable(id obj, const char *name, void *value);//用法同上Ivar object_setInstanceVariableWithStrongDefault(id obj, const char *name, void *value);//通过变量名直接获取示例变量的值Ivar object_getInstanceVariable(id obj, const char *name, void **outValue);//获取类变量内存布局const uint8_t *class_getIvarLayout(Class cls);//设置类变量内存布局void class_setIvarLayout(Class cls, const uint8_t *layout);//获取类变量布局 弱引用const uint8_t *class_getWeakIvarLayout(Class cls);//同上void class_setWeakIvarLayout(Class cls, const uint8_t *layout);//通过属性名获取属性/*属性特指使用@prototype定义的objc_property_t是一个结构体指针，其描述的是属性的信息，如下：typedef struct &#123; const char *name; /**属性名 */ const char *value; /**属性值 */&#125; objc_property_attribute_t;*/objc_property_t class_getProperty(Class cls, const char *name);//获取所有属性列表objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount);//向类添加一个实例变量/*需要注意，已经注册存在的类是不能通过这个方法追加实例变量的这个方法只能在objc_allocateClassPair函数执行后并且objc_registerClassPair执行前进行调用即这个函数是用来动态生成类的*/BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types);//向类中添加属性BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);//进行类属性的替换void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);//获取变量指针对应的变量名const char *ivar_getName(Ivar v);//获取编码后的变量类型const char *ivar_getTypeEncoding(Ivar v);//获取属性名const char *property_getName(objc_property_t property);//获取属性attributeconst char *property_getAttributes(objc_property_t property);char *property_copyAttributeValue(objc_property_t property, const char *attributeName);//获取属性attribute列表objc_property_attribute_t *property_copyAttributeList(objc_property_t property, unsigned int *outCount);//进行属性关联 这种方式可以为已经存在的类的实例扩展属性/*object:要添加属性的对象key:关联的键value:添加的属性的值policy:添加属性的策略typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; //assign OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ //retain nonatimic OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ //copy nonatomic OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ //retain OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ //copy OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;;*/void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);//获取关联属性的值id objc_getAssociatedObject(id object, const void *key);//移除一个关联的属性void objc_removeAssociatedObjects(id object); 3.方法操作相关函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//通过选择器获取某个类的实例方法Method class_getInstanceMethod(Class cls, SEL name);//通过选择器定义某个类的类方法Method class_getClassMethod(Class cls, SEL name);//通过选择器获取某个类的方法函数指针IMP class_getMethodImplementation(Class cls, SEL name);//同上IMP class_getMethodImplementation_stret(Class cls, SEL name);//判断某个类是否可以相应选择器BOOL class_respondsToSelector(Class cls, SEL sel);//获取某个类的实例方法列表Method *class_copyMethodList(Class cls, unsigned int *outCount);//为某个类动态添加一个实例方法/*cls:添加方法的类SEL：添加的方法选择器IMP:方法实现types:参数类型字符串*/BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); //替换一个方法的实现/*cls:类SEL:要替换实现的选择器IMP:实现types:参数类型字符串*/IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types);//获取函数的选择器SEL method_getName(Method m);//获取函数的实现IMP method_getImplementation(Method m);//获取函数的参数类型const char *method_getTypeEncoding(Method m);//获取函数的参数个数unsigned int method_getNumberOfArguments(Method m);//获取函数的返回值类型char *method_copyReturnType(Method m);//拷贝参数类型列表char *method_copyArgumentType(Method m, unsigned int index);//获取返回值类型void method_getReturnType(Method m, char *dst, size_t dst_len) ;//获取参数类型void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len);//获取函数描述信息/*objc_method_description结构体描述函数信息 如下：struct objc_method_description &#123; //函数名 SEL name; /**&lt; The name of the method */ //参数类型 char *types; /**&lt; The types of the method arguments */&#125;;*/struct objc_method_description *method_getDescription(Method m);//修改某个函数的实现IMP method_setImplementation(Method m, IMP imp);//交换两个函数的实现void method_exchangeImplementations(Method m1, Method m2);//获取选择器名称const char *sel_getName(SEL sel);//通过名称获取选择器SEL sel_getUid(const char *str);//注册一个选择器SEL sel_registerName(const char *str);//判断两个选择器是否相等BOOL sel_isEqual(SEL lhs, SEL rhs);//将block作为IMP的实现IMP imp_implementationWithBlock(id block);//获取IMP的实现blockid imp_getBlock(IMP anImp);//删除IMP的block实现BOOL imp_removeBlock(IMP anImp); 上面列举的函数中很多都用到参数类型的指定，types需要设置为C风格的字符数组，即C字符串，其中第1个字符表示返回值类型，其余字符依次表示参数类型，参数类型与字符的映射表如下： 4.协议相关操作函数1234567891011121314151617181920212223242526272829303132333435363738394041424344//判断某个类是否遵守某个协议BOOL class_conformsToProtocol(Class cls, Protocol *protocol);//拷贝某个类的协议列表Protocol * __unsafe_unretained *class_copyProtocolList(Class cls, unsigned int *outCount);//动态向类中添加协议BOOL class_addProtocol(Class cls, Protocol *protocol);//通过协议名获取某个协议指针Protocol *objc_getProtocol(const char *name);//拷贝所有协议列表Protocol * __unsafe_unretained *objc_copyProtocolList(unsigned int *outCount);//判断某个协议是否继承于另一个协议BOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other);//判断两个协议是否相同BOOL protocol_isEqual(Protocol *proto, Protocol *other);//获取协议名const char *protocol_getName(Protocol *p);//获取协议中某个函数的描述/*p:协议指针aSel:方法选择器isRequiredMethod:是否是必实现的isInstanceMehod:是否是实例方法*/struct objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod);//获取协议方法描述列表struct objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount);//获取协议中的属性描述objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty);//获取协议中的属性描述列表objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount);//同上objc_property_t *protocol_copyPropertyList2(Protocol *proto, unsigned int *outCount, BOOL isRequiredProperty, BOOL isInstanceProperty);//获取适配协议列表Protocol * __unsafe_unretained *protocol_copyProtocolList(Protocol *proto, unsigned int *outCount);//创建一个协议Protocol *objc_allocateProtocol(const char *name);//进行协议注册void objc_registerProtocol(Protocol *proto);//向协议中添加一个方法描述void protocol_addMethodDescription(Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod);//向协议中添加另一个协议void protocol_addProtocol(Protocol *proto, Protocol *addition);//向协议中添加属性描述void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty); 协议实质也是一个Objective-C对象。 5.动态构建类实例相关函数123456789101112131415161718192021//动态创建一个类实例/*cls:类名size_t:分配额外的内存 用来存放类定义之外的变量*/id class_createInstance(Class cls, size_t extraBytes);//同上id objc_constructInstance(Class cls, void *bytes);//销毁一个实例void *objc_destructInstance(id obj);//动态定义一个类 /*superClass:指定父类name:类名extraBytes:额外的内存空间*/Class objc_allocateClassPair(Class superclass, const char *name,size_t extraBytes);//进行类的注册 需要注意 要添加属性 必须在注册类之前添加void objc_registerClassPair(Class cls);//销毁一个类void objc_disposeClassPair(Class cls); 五、运行时的几点应用扩展到此本篇文章终于要告一段落了，相信你如果能看到这里，你一定有超凡的耐心。但是切记Objective-C的消息机制配合运行时是可以给开发者极大的元编程自由，但是不适当的使用也会造成破坏性的后果。下面几篇博客从一些方面介绍了Runtime的几点应用，你可以从中管中窥豹，可见一斑。 1.runtime基础应用：https://my.oschina.net/u/2340880/blog/489072 2.使用runtime全局修改UILabel字体：https://my.oschina.net/u/2340880/blog/538356 3.使用runtime自动化归档：https://my.oschina.net/u/2340880/blog/514330 4.代码调试框架的设计：https://my.oschina.net/u/2340880/blog/504675","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"NSTextField控件应用详解","slug":"326NSTextField控件应用详解","date":"2017-04-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.367Z","comments":true,"path":"2017/04/27/326NSTextField控件应用详解/","link":"","permalink":"http://huishao.cc/2017/04/27/326NSTextField控件应用详解/","excerpt":"","text":"NSTextField控件应用详解NSTextField用来接收用户文本输入，其可以接收键盘事件。创建NSTextFiled的示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738- (void)viewDidLoad &#123; [super viewDidLoad]; //创建TextField对象 _textField = [[NSTextField alloc]initWithFrame:NSMakeRect(50, 30, 200, 50)]; //设置默认显示的提示字符串 _textField.placeholderString = @\"请填写你的梦想\"; //设置默认显示的提示字符串 使用的带属性的字符串 NSMutableAttributedString * attriString = [[NSMutableAttributedString alloc]initWithString:@\"请填写你的梦想\"]; [attriString addAttribute:NSForegroundColorAttributeName value:[NSColor redColor] range:NSMakeRange(5, 2)]; _textField.placeholderAttributedString = attriString; //设置文本框背景颜色 _textField.backgroundColor = [NSColor greenColor]; //设置是否绘制背景 _textField.drawsBackground = YES; //设置文字颜色 _textField.textColor = [NSColor blueColor]; //设置是否显示边框 _textField.bordered = YES; //设置是否绘制贝塞尔风格的边框 _textField.bezeled = YES; //设置是否可以编辑 _textField.editable = YES; //设置文本框是否可以选中 _textField.selectable = YES; //设置贝塞尔风格 _textField.bezelStyle = NSTextFieldSquareBezel; //设置倾向布局宽度 _textField.preferredMaxLayoutWidth = 100; //设置最大行数 _textField.maximumNumberOfLines = 5; //设置断行模式 [[_textField cell] setLineBreakMode:NSLineBreakByCharWrapping]; //设置是否启用单行模式 [[_textField cell]setUsesSingleLineMode:NO]; //设置超出行数是否隐藏 [[_textField cell] setTruncatesLastVisibleLine: YES ]; [self.view addSubview:_textField];&#125; 需要注意，在AppKit坐标体系中，原点在左下角，这和数学中的坐标系一致。运行工程，效果如下图所示： NSTextField类中常用的属性和方法列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//设置默认显示的提示文字@property (nullable, copy) NSString *placeholderString NS_AVAILABLE_MAC(10_10);//设置默认显示的提示文字 带属性的文本@property (nullable, copy) NSAttributedString *placeholderAttributedString NS_AVAILABLE_MAC(10_10);//设置背景颜色@property (nullable, copy) NSColor *backgroundColor;//设置是否绘制背景@property BOOL drawsBackground;//设置文字颜色@property (nullable, copy) NSColor *textColor;//设置是否绘制边框@property (getter=isBordered) BOOL bordered;//设置是否贝塞尔绘制@property (getter=isBezeled) BOOL bezeled;//设置是否允许编辑@property (getter=isEditable) BOOL editable;//设置是否允许文本框选中@property (getter=isSelectable) BOOL selectable;//设置代理@property (nullable, assign) id&lt;NSTextFieldDelegate&gt; delegate;//获取是否接受第一响应@property (readonly) BOOL acceptsFirstResponder;//设置贝塞尔风格/*typedef NS_ENUM(NSUInteger, NSTextFieldBezelStyle) &#123; NSTextFieldSquareBezel = 0, NSTextFieldRoundedBezel = 1&#125;;*/@property NSTextFieldBezelStyle bezelStyle;//设置一个预定的最大宽度@property CGFloat preferredMaxLayoutWidth;//设置最大行数@property NSInteger maximumNumberOfLines;//设置是否允许编辑文本属性@property BOOL allowsEditingTextAttributes;//设置是否允许用户向文本框中拖拽图片@property BOOL importsGraphics;//下面这些方法用于子类进行重写//选择文本框时调用- (void)selectText:(nullable id)sender;//询问是否允许开始编辑文本框- (BOOL)textShouldBeginEditing:(NSText *)textObject;//询问是否允许结束编辑文本框- (BOOL)textShouldEndEditing:(NSText *)textObject;//文本框已经开始进入编辑的通知- (void)textDidBeginEditing:(NSNotification *)notification;//文本框已经结束编辑的通知- (void)textDidEndEditing:(NSNotification *)notification;//文本框中文字发生变化的通知- (void)textDidChange:(NSNotification *)notification;//下面两个属性与TouchBar相关 只有再较高版本的mac电脑中有效//自动完成编辑@property (getter=isAutomaticTextCompletionEnabled) BOOL automaticTextCompletionEnabled NS_AVAILABLE_MAC(10_12_2);//字符选择按钮@property BOOL allowsCharacterPickerTouchBarItem NS_AVAILABLE_MAC(10_12_2);//下面是一些便捷创建NSTextField对象的方法+ (instancetype)labelWithString:(NSString *)stringValue NS_SWIFT_NAME(init(labelWithString:)) NS_AVAILABLE_MAC(10_12);+ (instancetype)wrappingLabelWithString:(NSString *)stringValue NS_SWIFT_NAME(init(wrappingLabelWithString:)) NS_AVAILABLE_MAC(10_12);+ (instancetype)labelWithAttributedString:(NSAttributedString *)attributedStringValue NS_SWIFT_NAME(init(labelWithAttributedString:)) NS_AVAILABLE_MAC(10_12);+ (instancetype)textFieldWithString:(nullable NSString *)stringValue NS_AVAILABLE_MAC(10_12); NSTextField类继承自NSControl类，NSControl类中定义了许多属性可以获取到文本框中的文本，例如stringValue属性，本文中不再赘述。 关于NSTextFieldDelegate协议，其实际上是继承自NSControlTextEditingDelegate协议，这个协议中定义了NSTextField控件在活动过程中的回调方法，例如开始编辑，结束编辑等。","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"macOS开发之NSTableView的应用详解","slug":"325macOS开发之NSTableView的应用详解","date":"2017-04-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.367Z","comments":true,"path":"2017/04/25/325macOS开发之NSTableView的应用详解/","link":"","permalink":"http://huishao.cc/2017/04/25/325macOS开发之NSTableView的应用详解/","excerpt":"","text":"NSTableView的应用详解一、引言和iOS开发中的UITableView有很大差别，NSTableView并非是一个可滚动的列表视图，其是一个不可滚动、支持多列多行的原始列表视图。若要使NSTableView支持滚动，通常会将其嵌套入NSScrollView控件中。与UITableView类似，NSTableView的数据也是用过DataSource代理来提供，通过Delegate代理来进行表格视图的定制化。在OS X v10.6版本之前，NSTableView中行数据载体视图必须是NSCell的子类，之后版本的OS X支持开发者创建基于View的TableView视图，同样也支持基于Cell的TabelView视图，在开发者，我们可以根据实际需求选择。 二、构建一个简单的列表视图首先新建一个测试工程，在ViewController.m文件中编写如下代码： 123456789101112131415161718192021222324252627282930313233343536373839#import \"ViewController.h\"@interface ViewController()&lt;NSTableViewDelegate,NSTableViewDataSource&gt;@end@implementation ViewController&#123; NSTableView * _tableView; NSMutableArray * _dataArray;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; _dataArray = [NSMutableArray array]; for (int i=0; i&lt;20; i++) &#123; [_dataArray addObject:[NSString stringWithFormat:@\"%d行数据\",i]]; &#125; NSScrollView * scrollView = [[NSScrollView alloc] init]; scrollView.hasVerticalScroller = YES; scrollView.frame = self.view.bounds; [self.view addSubview:scrollView]; _tableView = [[NSTableView alloc]initWithFrame:self.view.bounds]; NSTableColumn * column = [[NSTableColumn alloc]initWithIdentifier:@\"test\"]; [_tableView addTableColumn:column]; _tableView.delegate = self; _tableView.dataSource = self; [_tableView reloadData]; scrollView.contentView.documentView = _tableView;&#125;-(NSInteger)numberOfRowsInTableView:(NSTableView *)tableView&#123; return _dataArray.count;&#125;-(id)tableView:(NSTableView *)tableView objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row&#123; return _dataArray[row];&#125;@end 运行工程效果如下图： 这是一个最简单的TableView示例，但是细读代码，麻雀虽小五脏俱全。首先NSTableView中的列是由NSTableColumn类描述的。一个列表可以有多个列。也正如前面所说，numberOfRowsInTableView方法为数据源代理必须实现的方法，其中需要返回列表的行数。objectValueForTableColumn方法则是基于Cell的TableView必须实现的方法，其中需要返回每个列表行所填充的数据。 三、关于NSTableColume的探究NSTableColume简单理解就是一列，其中可以进行此列样式的相关设置，NSTableColumn类中常用属性解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//初始化方法，指定一个列ID- (instancetype)initWithIdentifier:(NSString *)identifier;//与此列关联的ID@property (copy) NSString *identifier;//关联的TableView@property (nullable, assign) NSTableView *tableView;//设置列宽度@property CGFloat width;//设置最小列宽度@property CGFloat minWidth;//设置最大列宽度@property CGFloat maxWidth;//设置类标题@property (copy) NSString *title;/*列标题视图 开发者可以对其进行修改需要注意，NSTableHeaderCell是继承自NSTextFieldCell*/@property (strong) __kindof NSTableHeaderCell *headerCell;//设置此列是否可以进行编辑@property (getter=isEditable) BOOL editable;//进行列尺寸的调整 以列标题视图的宽度为标准 - (void)sizeToFit;//提供了这个属性，会在列标题那里显示一个排序按钮 点击列标题后可以进行排序操作(会回调相关协议方法)@property (nullable, copy) NSSortDescriptor *sortDescriptorPrototype;//设置列尺寸的调整模式 枚举如下/*typedef NS_OPTIONS(NSUInteger, NSTableColumnResizingOptions) &#123; NSTableColumnNoResizing = 0, //不允许进行宽度调整 //详见NSTabelView的columnAutoresizingStyle属性 NSTableColumnAutoresizingMask = ( 1 &lt;&lt; 0 ), //使用tableView的column调整策略 NSTableColumnUserResizingMask = ( 1 &lt;&lt; 1 ), //允许用户进行尺寸调整&#125;;*/@property NSTableColumnResizingOptions resizingMask;//设置列头的提示标题 当鼠标悬停在类标题上时 会显示此提示@property (nullable, copy) NSString *headerToolTip;//设置此列是否隐藏@property (getter=isHidden) BOOL hidden;//设置此列所有行的数据载体视图 如果不设置 默认为NSTextFieldCell@property (strong) id dataCell;//为TableView列表提供数据载体视图- (id)dataCellForRow:(NSInteger)row; 四、Cell-Base：基于Cell的TableView视图Cell-Base是OS X早起版本中常用的构造TabelView的方式，其中每一行的数据载体都必须是NSCell的子类。如本文开头的示例代码，Cell-Base的TableView必须实现的两个协议方法是numberOfRowsInTableView和objectValueForTableColumn方法，第一个方法设置列表行数，第2个方法设置每个数据载体对应的具体数据。需要注意，如果只实现这两个方法，则NSTableView会自动从列对象NSTableColume中取具体的行视图，通过dataCellForRow方法。当objectValueForTableColumn方法将每个行具体的数据返回后，会调用cell的setObjectValue方法(因此如果要自定义cell，必须实现这个方法)。如果我们要对Cell的渲染进行一些定制，可以在如下方法中实现： 12//将要渲染cell调用的方法 开发者可以拿到cell对象做定制- (void)tableView:(NSTableView *)tableView willDisplayCell:(id)cell forTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row; 实现下面的方法可以返回一个自定义的Cell，如果实现了这个方法，则TableView不会再从NSTableColumn对象中拿Cell实例： 123456//返回自定义的Cell实例/*需要注意，这个方法在第一次调用的时候 tableColumu对象是nil 如果这时返回了Cell，则此Cell宽度会覆盖整个列表在使用时要多加注意*/- (nullable NSCell *)tableView:(NSTableView *)tableView dataCellForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row; 其他方法的实例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#import \"ViewController.h\"#import \"MyCell.h\"@interface ViewController()&lt;NSTableViewDelegate,NSTableViewDataSource&gt;@end@implementation ViewController&#123; NSTableView * _tableView; NSMutableArray * _dataArray;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; _dataArray = [NSMutableArray array]; for (int i=0; i&lt;20; i++) &#123; [_dataArray addObject:[NSString stringWithFormat:@\"%d行数据\",i]]; &#125; NSScrollView * scrollView = [[NSScrollView alloc] init]; scrollView.hasVerticalScroller = YES; scrollView.frame = self.view.bounds; [self.view addSubview:scrollView]; _tableView = [[NSTableView alloc]initWithFrame:self.view.bounds]; NSTableColumn * column = [[NSTableColumn alloc]initWithIdentifier:@\"test\"]; NSTableColumn * column2 = [[NSTableColumn alloc]initWithIdentifier:@\"test2\"]; column2.width = 100; column2.minWidth = 100; column2.maxWidth = 100; column2.title = @\"数据\"; column2.editable = YES ; column2.headerToolTip = @\"提示\"; column2.hidden=NO; column2.sortDescriptorPrototype = [NSSortDescriptor sortDescriptorWithKey:@\"title\" ascending:NO]; column.resizingMask =NSTableColumnUserResizingMask;// column.dataCell = [[NSButtonCell alloc]initTextCell:@\"\"]; [_tableView addTableColumn:column]; [_tableView addTableColumn:column2]; _tableView.delegate = self; _tableView.dataSource = self; scrollView.contentView.documentView = _tableView;&#125;//设置行数 通用-(NSInteger)numberOfRowsInTableView:(NSTableView *)tableView&#123; return _dataArray.count;&#125;//绑定数据-(id)tableView:(NSTableView *)tableView objectValueForTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row&#123; return _dataArray[row];&#125;//用户编辑列表- (void)tableView:(NSTableView *)tableView setObjectValue:(nullable id)object forTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row&#123; NSLog(@\"%@\",object); _dataArray[row] = object;&#125;//cell-base的cell展示前调用 可以进行自定制- (void)tableView:(NSTableView *)tableView willDisplayCell:(id)cell forTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row&#123; NSTextFieldCell * _cell = cell; _cell.textColor = [NSColor redColor];&#125;//设置是否可以进行编辑- (BOOL)tableView:(NSTableView *)tableView shouldEditTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row&#123; return YES;&#125;//设置鼠标悬停在cell上显示的提示文本- (NSString *)tableView:(NSTableView *)tableView toolTipForCell:(NSCell *)cell rect:(NSRectPointer)rect tableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row mouseLocation:(NSPoint)mouseLocation&#123; return @\"tip\";&#125;//当列表长度无法展示完整某行数据时 当鼠标悬停在此行上 是否扩展显示- (BOOL)tableView:(NSTableView *)tableView shouldShowCellExpansionForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row&#123; return YES;&#125;//设置cell的交互能力/*如果返回YES，则Cell的交互能力会变强，例如NSButtonCell的点击将会调用- (void)tableView:(NSTableView *)tableView setObjectValue方法*/- (BOOL)tableView:(NSTableView *)tableView shouldTrackCell:(NSCell *)cell forTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row&#123; return YES;&#125;//自定义cell- (nullable NSCell *)tableView:(NSTableView *)tableView dataCellForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row&#123; if (tableColumn!=nil) &#123; MyCell * cell = [[MyCell alloc]init]; return cell; &#125; return nil; &#125;-(CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row&#123; return 30;&#125;//排序回调函数-(void)tableView:(NSTableView *)tableView sortDescriptorsDidChange:(NSArray&lt;NSSortDescriptor *&gt; *)oldDescriptors&#123; NSLog(@\"%@\",oldDescriptors[0]);&#125;@end 五、View-Base：基于View的TableView视图基于View-Base的TableView要比基于Cell的TableView更加灵活，其中每行数据载体可以是任意NSView的子类。代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//// ViewController.m// TableView//// Created by jaki on 17/4/14.// Copyright © 2017年 jaki. All rights reserved.//#import \"ViewController.h\"#import \"MyCell.h\"#import \"TableRow.h\"@interface ViewController()&lt;NSTableViewDelegate,NSTableViewDataSource&gt;@end@implementation ViewController&#123; NSTableView * _tableView; NSMutableArray * _dataArray;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; _dataArray = [NSMutableArray array]; for (int i=0; i&lt;20; i++) &#123; [_dataArray addObject:[NSString stringWithFormat:@\"%d行数据\",i]]; &#125; NSScrollView * scrollView = [[NSScrollView alloc] init]; scrollView.hasVerticalScroller = YES; scrollView.frame = self.view.bounds; [self.view addSubview:scrollView]; _tableView = [[NSTableView alloc]initWithFrame:self.view.bounds]; NSTableColumn * column = [[NSTableColumn alloc]initWithIdentifier:@\"test\"]; NSTableColumn * column2 = [[NSTableColumn alloc]initWithIdentifier:@\"test2\"]; column2.width = 100; column2.minWidth = 100; column2.maxWidth = 100; column2.title = @\"数据\"; column2.editable = YES ; column2.headerToolTip = @\"提示\"; column2.hidden=NO; column2.sortDescriptorPrototype = [NSSortDescriptor sortDescriptorWithKey:@\"title\" ascending:NO]; column.resizingMask =NSTableColumnUserResizingMask; _tableView.delegate = self; _tableView.dataSource = self; [_tableView addTableColumn:column]; [_tableView addTableColumn:column2]; scrollView.contentView.documentView = _tableView;&#125;//设置行数 通用-(NSInteger)numberOfRowsInTableView:(NSTableView *)tableView&#123; return _dataArray.count;&#125;//View-base//设置某个元素的具体视图- (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row&#123; //根据ID取视图 NSTextField * view = [tableView makeViewWithIdentifier:@\"cellId\" owner:self]; if (view==nil) &#123; view = [[NSTextField alloc]initWithFrame:CGRectMake(0, 0, 100, 30)]; view.backgroundColor = [NSColor clearColor]; view.identifier = @\"cellId\"; &#125; return view;&#125;//设置每行容器视图- (nullable NSTableRowView *)tableView:(NSTableView *)tableView rowViewForRow:(NSInteger)row&#123; TableRow * rowView = [[TableRow alloc]init]; return rowView;&#125;//当添加行时调用的回调- (void)tableView:(NSTableView *)tableView didAddRowView:(NSTableRowView *)rowView forRow:(NSInteger)row&#123; NSLog(@\"add\");&#125;//当移除行时调用的回调- (void)tableView:(NSTableView *)tableView didRemoveRowView:(NSTableRowView *)rowView forRow:(NSInteger)row&#123; NSLog(@\"remove\");&#125;@end 上面代码中用到了TableRow类，其实它是一个自定义的继承自NSTableRowView的类，实现如下： 123456789101112131415161718#import \"TablerRow.h\"@implementation TablerRow//绘制选中状态的背景-(void)drawSelectionInRect:(NSRect)dirtyRect&#123; NSRect selectionRect = NSInsetRect(self.bounds, 5.5, 5.5); [[NSColor colorWithCalibratedWhite:.72 alpha:1.0] setStroke]; [[NSColor colorWithCalibratedWhite:.82 alpha:1.0] setFill]; NSBezierPath *selectionPath = [NSBezierPath bezierPathWithRoundedRect:selectionRect xRadius:10 yRadius:10]; [selectionPath fill]; [selectionPath stroke];&#125;//绘制背景-(void)drawBackgroundInRect:(NSRect)dirtyRect&#123; [super drawBackgroundInRect:dirtyRect]; [[NSColor greenColor]setFill]; NSRectFill(dirtyRect);&#125;@end 关于NSTableRowView类我们下面来做具体介绍。 六、NSTableRowView解析NSTableRowView用在View-Base的TableView中，其作为行容器存在。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//选中的高亮风格/*typedef NS_ENUM(NSInteger, NSTableViewSelectionHighlightStyle) &#123; //无高亮风格 NSTableViewSelectionHighlightStyleNone, //规则的高亮风格 NSTableViewSelectionHighlightStyleRegular = 0, //源列表风格 NSTableViewSelectionHighlightStyleSourceList = 1,&#125;;*/@property NSTableViewSelectionHighlightStyle selectionHighlightStyle;//是否强调@property(getter=isEmphasized) BOOL emphasized;//设置是否行组风格@property(getter=isGroupRowStyle) BOOL groupRowStyle;//是否选中状态@property(getter=isSelected) BOOL selected;//其前一行的选中状态@property(getter=isPreviousRowSelected) BOOL previousRowSelected;//其后一行的选中状态@property(getter=isNextRowSelected) BOOL nextRowSelected;//设置此行是否浮动@property(getter=isFloating) BOOL floating;//拖放拖动效果@property(getter=isTargetForDropOperation) BOOL targetForDropOperation;//拖放风格@property NSTableViewDraggingDestinationFeedbackStyle draggingDestinationFeedbackStyle;//设置拖放目标的缩进量@property CGFloat indentationForDropOperation;//背景色@property(copy) NSColor *backgroundColor;//子类重写下面方法来进行行容器视图的自定义//画背景色- (void)drawBackgroundInRect:(NSRect)dirtyRect;//画选中背景- (void)drawSelectionInRect:(NSRect)dirtyRect;//画分割线- (void)drawSeparatorInRect:(NSRect)dirtyRect;//绘制拖放时的用户反馈IU- (void)drawDraggingDestinationFeedbackInRect:(NSRect)dirtyRect;//列数@property(readonly) NSInteger numberOfColumns;//提供的访问特定视图的方法- (nullable id)viewAtColumn:(NSInteger)column; 七、来总结下NSTableViewDataSource协议1234567891011121314151617181920212223242526/*无论基于Cell还是基于View，这个方法都需要实现，用来设置列表的行数*/- (NSInteger)numberOfRowsInTableView:(NSTableView *)tableView;/*如果使用cell-base的TableView视图，这个方法是必须实现的，其为要渲染的cell提供数据*/- (nullable id)tableView:(NSTableView *)tableView objectValueForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row;/*这个函数当用户编辑了cell中的内容时会被调用，一般需要在其中进行数据源的修改*/- (void)tableView:(NSTableView *)tableView setObjectValue:(nullable id)object forTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row;/*当用户修改了行排序规则时调用的回调*/- (void)tableView:(NSTableView *)tableView sortDescriptorsDidChange:(NSArray&lt;NSSortDescriptor *&gt; *)oldDescriptors;//下面这些方法全部与列表的数据拖拽相关- (nullable id &lt;NSPasteboardWriting&gt;)tableView:(NSTableView *)tableView pasteboardWriterForRow:(NSInteger)row;- (void)tableView:(NSTableView *)tableView draggingSession:(NSDraggingSession *)session willBeginAtPoint:(NSPoint)screenPoint forRowIndexes:(NSIndexSet *)rowIndexes NS_AVAILABLE_MAC(10_7);- (void)tableView:(NSTableView *)tableView draggingSession:(NSDraggingSession *)session endedAtPoint:(NSPoint)screenPoint operation:(NSDragOperation)operation NS_AVAILABLE_MAC(10_7);- (void)tableView:(NSTableView *)tableView updateDraggingItemsForDrag:(id &lt;NSDraggingInfo&gt;)draggingInfo NS_AVAILABLE_MAC(10_7);- (BOOL)tableView:(NSTableView *)tableView writeRowsWithIndexes:(NSIndexSet *)rowIndexes toPasteboard:(NSPasteboard *)pboard;- (NSDragOperation)tableView:(NSTableView *)tableView validateDrop:(id &lt;NSDraggingInfo&gt;)info proposedRow:(NSInteger)row proposedDropOperation:(NSTableViewDropOperation)dropOperation;- (BOOL)tableView:(NSTableView *)tableView acceptDrop:(id &lt;NSDraggingInfo&gt;)info row:(NSInteger)row dropOperation:(NSTableViewDropOperation)dropOperation;- (NSArray&lt;NSString *&gt; *)tableView:(NSTableView *)tableView namesOfPromisedFilesDroppedAtDestination:(NSURL *)dropDestination forDraggedRowsWithIndexes:(NSIndexSet *)indexSet; 八、来总结下NSTableViewDelegate协议123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//view-base的TableView相关delegate方法/*设置每个数据载体的View*/- (nullable NSView *)tableView:(NSTableView *)tableView viewForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row;/*自定义行视图*/- (nullable NSTableRowView *)tableView:(NSTableView *)tableView rowViewForRow:(NSInteger)row NS_AVAILABLE_MAC(10_7);/*添加一行时会调用的回调*/- (void)tableView:(NSTableView *)tableView didAddRowView:(NSTableRowView *)rowView forRow:(NSInteger)row;/*移除一行时会调用的回调*/- (void)tableView:(NSTableView *)tableView didRemoveRowView:(NSTableRowView *)rowView forRow:(NSInteger)row;//cell-base的TableView相关delegate方法/*cell将要渲染时调用的回调，可以在其中对cell进行定制*/- (void)tableView:(NSTableView *)tableView willDisplayCell:(id)cell forTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row;/*设置某个cell是否可以编辑*/- (BOOL)tableView:(NSTableView *)tableView shouldEditTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row;/*设置当鼠标悬停在cell上时 显示的提示文案*/- (NSString *)tableView:(NSTableView *)tableView toolTipForCell:(NSCell *)cell rect:(NSRectPointer)rect tableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row mouseLocation:(NSPoint)mouseLocation;/*当cell的宽度不够显示完全cell的内容时，设置是否允许鼠标放置扩展cell*/- (BOOL)tableView:(NSTableView *)tableView shouldShowCellExpansionForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row;/*设置是否加强cell的交互能力，这样一些按钮状态的修改也会触发cell编辑的状态*/- (BOOL)tableView:(NSTableView *)tableView shouldTrackCell:(NSCell *)cell forTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row;/*设置自定义cell*/- (nullable NSCell *)tableView:(NSTableView *)tableView dataCellForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row;//通用的TableView代理方法/*设置是否允许修改选中*/- (BOOL)selectionShouldChangeInTableView:(NSTableView *)tableView;/*设置某行是否可以选中*/- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(NSInteger)row;/*当用户通过键盘或鼠标将要选中某行时，返回设置要选中的行如果实现了这个方法，上面一个方法将不会被调用*/- (NSIndexSet *)tableView:(NSTableView *)tableView selectionIndexesForProposedSelection:(NSIndexSet *)proposedSelectionIndexes;/*设置某列是否可以被选中*/- (BOOL)tableView:(NSTableView *)tableView shouldSelectTableColumn:(nullable NSTableColumn *)tableColumn;/*用户点击列头时调用的方法*/- (void)tableView:(NSTableView *)tableView mouseDownInHeaderOfTableColumn:(NSTableColumn *)tableColumn;/*用法同上*/- (void)tableView:(NSTableView *)tableView didClickTableColumn:(NSTableColumn *)tableColumn;/*对列进行拖拽改变顺序时调用的方法*/- (void)tableView:(NSTableView *)tableView didDragTableColumn:(NSTableColumn *)tableColumn;/*设置行高*/- (CGFloat)tableView:(NSTableView *)tableView heightOfRow:(NSInteger)row;/*下面这些方法与行检索有关*/- (nullable NSString *)tableView:(NSTableView *)tableView typeSelectStringForTableColumn:(nullable NSTableColumn *)tableColumn row:(NSInteger)row NS_AVAILABLE_MAC(10_5);- (NSInteger)tableView:(NSTableView *)tableView nextTypeSelectMatchFromRow:(NSInteger)startRow toRow:(NSInteger)endRow forString:(NSString *)searchString NS_AVAILABLE_MAC(10_5);- (BOOL)tableView:(NSTableView *)tableView shouldTypeSelectForEvent:(NSEvent *)event withCurrentSearchString:(nullable NSString *)searchString NS_AVAILABLE_MAC(10_5);/*设置某行是否绘制成组样式*/- (BOOL)tableView:(NSTableView *)tableView isGroupRow:(NSInteger)row;/*调整列宽度*/- (CGFloat)tableView:(NSTableView *)tableView sizeToFitWidthOfColumn:(NSInteger)column;/*设置是否支持列的移动排序*/- (BOOL)tableView:(NSTableView *)tableView shouldReorderColumn:(NSInteger)columnIndex toColumn:(NSInteger)newColumnIndex;//设置某行向左或向右滑动时要显示的功能按钮/*typedef NS_ENUM(NSInteger, NSTableRowActionEdge) &#123; NSTableRowActionEdgeLeading, // 左划 NSTableRowActionEdgeTrailing, // 右划&#125; NS_ENUM_AVAILABLE_MAC(10_11);*/- (NSArray&lt;NSTableViewRowAction *&gt; *)tableView:(NSTableView *)tableView rowActionsForRow:(NSInteger)row edge:(NSTableRowActionEdge)edge NS_AVAILABLE_MAC(10_11);/*TableView选中修改时调用*/- (void)tableViewSelectionDidChange:(NSNotification *)notification;/*TableView列移动完成时调用的函数*/- (void)tableViewColumnDidMove:(NSNotification *)notification;/*TableView列宽度变化时调用的函数*/- (void)tableViewColumnDidResize:(NSNotification *)notification;/*TableView选中正在修改时调用的函数*/- (void)tableViewSelectionIsChanging:(NSNotification *)notification; 九、NSTableView中常用的属性和方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//初始化方法- (instancetype)initWithFrame:(NSRect)frameRect;- (nullable instancetype)initWithCoder:(NSCoder *)coder;//设置代理@property (nullable, weak) id &lt;NSTableViewDataSource&gt; dataSource;@property (nullable, weak) id &lt;NSTableViewDelegate&gt; delegate;//设置TableView的头视图 会被列头图就行覆盖@property (nullable, strong) NSTableHeaderView *headerView;//设置头图右侧视图 可以自定义图标@property (nullable, strong) NSView *cornerView;//设置是否允许列拖拽排序@property BOOL allowsColumnReordering;//设置是否允许调整列宽度@property BOOL allowsColumnResizing;//调整列宽度的风格/*typedef NS_ENUM(NSUInteger, NSTableViewColumnAutoresizingStyle) &#123; //不可调整 NSTableViewNoColumnAutoresizing = 0, //平分 NSTableViewUniformColumnAutoresizingStyle, //从后往前调整 NSTableViewSequentialColumnAutoresizingStyle, //从前往后调整 NSTableViewReverseSequentialColumnAutoresizingStyle, //最后一列可调整 NSTableViewLastColumnOnlyAutoresizingStyle, //第一列可调整 NSTableViewFirstColumnOnlyAutoresizingStyle&#125;;*/@property NSTableViewColumnAutoresizingStyle columnAutoresizingStyle;//设置分割线风格/*typedef NS_OPTIONS(NSUInteger, NSTableViewGridLineStyle) &#123; //无分割线 NSTableViewGridNone = 0, //竖直分割线 NSTableViewSolidVerticalGridLineMask = 1 &lt;&lt; 0, //水平分割线 NSTableViewSolidHorizontalGridLineMask = 1 &lt;&lt; 1, //水平虚线分割线 NSTableViewDashedHorizontalGridLineMask ,&#125;;*/@property NSTableViewGridLineStyle gridStyleMask;//设置cell之间的间隔 需要设置为NSSize对象@property NSSize intercellSpacing;//是否开启斑马纹@property BOOL usesAlternatingRowBackgroundColors;//背景色@property (copy) NSColor *backgroundColor;//设置分割线颜色@property (copy) NSColor *gridColor;//设置行尺寸风格/*typedef NS_ENUM(NSInteger, NSTableViewRowSizeStyle) &#123; //默认 NSTableViewRowSizeStyleDefault = -1, //自定义 NSTableViewRowSizeStyleCustom = 0, //小尺寸风格 NSTableViewRowSizeStyleSmall = 1, //中等尺寸风格 NSTableViewRowSizeStyleMedium = 2, //大尺寸风格 NSTableViewRowSizeStyleLarge = 3,&#125; NS_ENUM_AVAILABLE_MAC(10_7);*/@property NSTableViewRowSizeStyle rowSizeStyle;//行高@property CGFloat rowHeight;//获取所有列对象@property (readonly, copy) NSArray&lt;NSTableColumn *&gt; *tableColumns;//获取列数@property (readonly) NSInteger numberOfColumns;//获取行数@property (readonly) NSInteger numberOfRows;//添加一列- (void)addTableColumn:(NSTableColumn *)tableColumn;//移除一列- (void)removeTableColumn:(NSTableColumn *)tableColumn;//移动列- (void)moveColumn:(NSInteger)oldIndex toColumn:(NSInteger)newIndex;//根据id获取列的下标- (NSInteger)columnWithIdentifier:(NSString *)identifier;//根据id获取列对象- (nullable NSTableColumn *)tableColumnWithIdentifier:(NSString *)identifier;//滚动到指定行可见- (void)scrollRowToVisible:(NSInteger)row;//滚动到指定列可见- (void)scrollColumnToVisible:(NSInteger)column;//重新加载数据- (void)reloadData;//重新加载指定位置的数据- (void)reloadDataForRowIndexes:(NSIndexSet *)rowIndexes columnIndexes:(NSIndexSet *)columnIndexes;//获取编辑的列@property (readonly) NSInteger editedColumn;//获取编辑的行@property (readonly) NSInteger editedRow;//获取点击的列@property (readonly) NSInteger clickedColumn;//获取点击的行@property (readonly) NSInteger clickedRow;//设置列头提示图片- (void)setIndicatorImage:(nullable NSImage *)image inTableColumn:(NSTableColumn *)tableColumn;//获取列头提示图片- (nullable NSImage *)indicatorImageInTableColumn:(NSTableColumn *)tableColumn;//下面这些方法与列表拖拽有关@property BOOL verticalMotionCanBeginDrag;- (BOOL)canDragRowsWithIndexes:(NSIndexSet *)rowIndexes atPoint:(NSPoint)mouseDownPoint;- (NSImage *)dragImageForRowsWithIndexes:(NSIndexSet *)dragRows tableColumns:(NSArray&lt;NSTableColumn *&gt; *)tableColumns event:(NSEvent *)dragEvent offset:(NSPointPointer)dragImageOffset;- (void)setDraggingSourceOperationMask:(NSDragOperation)mask forLocal:(BOOL)isLocal;- (void)setDropRow:(NSInteger)row dropOperation:(NSTableViewDropOperation)dropOperation;//下面这些方法与列表选中有关//是否支持多选@property BOOL allowsMultipleSelection;//是否允许都不选中@property BOOL allowsEmptySelection;//是否支持选中列 如果设置为YES 点击列头会将整列选中@property BOOL allowsColumnSelection;//全选 用于子类重写- (void)selectAll:(nullable id)sender;//全不选 用于子类重写- (void)deselectAll:(nullable id)sender;//进行列选中- (void)selectColumnIndexes:(NSIndexSet *)indexes byExtendingSelection:(BOOL)extend;//进行行选中- (void)selectRowIndexes:(NSIndexSet *)indexes byExtendingSelection:(BOOL)extend;//获取所有选中列index@property (readonly, copy) NSIndexSet *selectedColumnIndexes;//获取所有选中行index@property (readonly, copy) NSIndexSet *selectedRowIndexes;//取消某列的选中- (void)deselectColumn:(NSInteger)column;//取消某行的选中- (void)deselectRow:(NSInteger)row;//判断某列是否被选中- (BOOL)isColumnSelected:(NSInteger)column;//判断某行是否被选中- (BOOL)isRowSelected:(NSInteger)row;//获取选中的列数@property (readonly) NSInteger numberOfSelectedColumns;//获取选中的行数@property (readonly) NSInteger numberOfSelectedRows;//获取某列的位置尺寸- (NSRect)rectOfColumn:(NSInteger)column;//获取某行的位置尺寸- (NSRect)rectOfRow:(NSInteger)row;//获取某个范围内的列- (NSIndexSet *)columnIndexesInRect:(NSRect)rect;//获取某个范围内的行- (NSRange)rowsInRect:(NSRect)rect;//获取包含某个点的列- (NSInteger)columnAtPoint:(NSPoint)point;//获取包含某个点的行- (NSInteger)rowAtPoint:(NSPoint)point;//获取某个cell的位置尺寸- (NSRect)frameOfCellAtColumn:(NSInteger)column row:(NSInteger)row;//获取某个位置的View，用于view-base- (nullable __kindof NSView *)viewAtColumn:(NSInteger)column row:(NSInteger)row makeIfNecessary:(BOOL)makeIfNecessary;//获取某行的视图 用于view-base- (nullable __kindof NSTableRowView *)rowViewAtRow:(NSInteger)row makeIfNecessary:(BOOL)makeIfNecessary;//获取某个View所在的行 用于view-base- (NSInteger)rowForView:(NSView *)view;//获取某个View所在的列 用于view-base- (NSInteger)columnForView:(NSView *)view;//创建一个用于渲染的View 用于view-base- (nullable __kindof NSView *)makeViewWithIdentifier:(NSString *)identifier owner:(nullable id)owner;//下面这些方法用来根据列表数据//开始更新- (void)beginUpdates NS_AVAILABLE_MAC(10_7);//结束更新- (void)endUpdates NS_AVAILABLE_MAC(10_7);//插入行- (void)insertRowsAtIndexes:(NSIndexSet *)indexes withAnimation:(NSTableViewAnimationOptions)animationOptions NS_AVAILABLE_MAC(10_7);//删除行- (void)removeRowsAtIndexes:(NSIndexSet *)indexes withAnimation:(NSTableViewAnimationOptions)animationOptions NS_AVAILABLE_MAC(10_7);//移动行- (void)moveRowAtIndex:(NSInteger)oldIndex toIndex:(NSInteger)newIndex NS_AVAILABLE_MAC(10_7);//隐藏行- (void)hideRowsAtIndexes:(NSIndexSet *)indexes withAnimation:(NSTableViewAnimationOptions)rowAnimation NS_AVAILABLE_MAC(10_11);//取消隐藏行- (void)unhideRowsAtIndexes:(NSIndexSet *)indexes withAnimation:(NSTableViewAnimationOptions)rowAnimation NS_AVAILABLE_MAC(10_11);//所有隐藏状态的行@property (readonly, copy) NSIndexSet *hiddenRowIndexes; 十、相关通知12345678//列表选择改变后发的通知APPKIT_EXTERN NSNotificationName NSTableViewSelectionDidChangeNotification;//列移动后发的通知APPKIT_EXTERN NSNotificationName NSTableViewColumnDidMoveNotification; //列宽度改变后发的通知APPKIT_EXTERN NSNotificationName NSTableViewColumnDidResizeNotification;//选择改变时发的通知 APPKIT_EXTERN NSNotificationName NSTableViewSelectionIsChangingNotification;","categories":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}],"tags":[],"keywords":[{"name":"macOS开发","slug":"macOS开发","permalink":"http://huishao.cc/categories/macOS开发/"}]},{"title":"Git命令集十六——推送命令","slug":"324Git命令集十六——推送命令","date":"2017-04-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.367Z","comments":true,"path":"2017/04/14/324Git命令集十六——推送命令/","link":"","permalink":"http://huishao.cc/2017/04/14/324Git命令集十六——推送命令/","excerpt":"","text":"Git命令集十六——推送命令1.git push :repository为远程主机地址，将本地指定分支推送到远程指定分支。 2.git push origin master将本地的master分支推送到远程的master分支。 3.git push origin :master删除远程master分支，当省略本地分支名时，效果等同于删除远程此分支。 4.git push origin将当前分支推送到origin主机的对应分支。 5.git push进行默认推送。 6.git push origin –delete 删除远程某个分支。 7.git push –all origin将本地所有分支都推送到origin主机。 8.git push origin –tags推送标签。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集十五——拉取命令","slug":"323Git命令集十五——拉取命令","date":"2017-03-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.367Z","comments":true,"path":"2017/03/31/323Git命令集十五——拉取命令/","link":"","permalink":"http://huishao.cc/2017/03/31/323Git命令集十五——拉取命令/","excerpt":"","text":"Git命令集十五——拉取命令pull命令用于从其他仓库或本地分支拉取更改到当前分支。 1.git pull将远程仓库的更改快速拉取到当前分支。2.git pull 从指定的仓库拉取更新。 3.git pull –commit拉取后进行合并操作，并提交结果。 4.git pull –no-conmit拉取后进行合并但是不提交。 5.git pull –rebase拉取后使用rebase的方式进行合并，其会重新整理commit记录。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集十四——抓取命令","slug":"322Git命令集十四——抓取命令","date":"2017-03-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.367Z","comments":true,"path":"2017/03/28/322Git命令集十四——抓取命令/","link":"","permalink":"http://huishao.cc/2017/03/28/322Git命令集十四——抓取命令/","excerpt":"","text":"Git命令集十四——抓取命令Git中提供的fetch命令用于将远端的更新抓取到本地仓库中。 1.git fetch 从指定的远端抓取指定分支的更新。 2.git fetch –all抓取所有远端的所有更新。 3.git fetch –prune抓取前删除远程上不在跟踪的引用。 4.git fetch –tags抓取远程分支上的所有标签。 5.git fetch –progress输出抓取进度。 6.git fetch –ipv4使用IPv4地址。忽略IPv6地址。 7.git fetch –ipv6使用IPv6地址，忽略iPV4地址。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"经典排序算法解析","slug":"321经典排序算法解析","date":"2017-03-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.367Z","comments":true,"path":"2017/03/24/321经典排序算法解析/","link":"","permalink":"http://huishao.cc/2017/03/24/321经典排序算法解析/","excerpt":"","text":"经典排序算法解析许多高级语言中都提供有排序函数，但是掌握一些经典排序算法的基本原理和编码方法还是很有必要，这个学习过程可以帮助我们更好的理解每种排序算法的设计思路，本篇博客将介绍9种十分经典的排序算法，提供了解释性语言JavaScript与编译型语言C的源代码。 一、直接插入排序直接插入排序是最简单的一种排序算法，也最容易理解。它的核心思想为将元素逐个插入一个有序的数列中。用文字描述可以分为如下几步： 1.把数列中的第一个元素取出，作为有序数列的起始元素。 2.依次拿数列中的其他元素与有序数列中的元素进行比较，将其插入正确的位置。 用图示描述插入排序如下： 直接插入排序的特点是对新元素的每轮插入前，有序数列中的所有元素都是排序好的，即任意时刻，被排序动过的元素组成的数列都是有序的。 用JavaScript实现的简单插入排序： 123456789101112//插入排序var array = [1,54,2,64,12,65,76,46,34,98];for(var i = 0;i&lt;array.length-1;i++)&#123; var temp = array[i+1]; for(var j = i+1;j&gt;0;j--)&#123; if (temp&lt;array[j]) &#123; array[j+1] = array[j]; array[j] = temp; &#125; &#125;&#125;console.log(array);//[ 1, 2, 12, 34, 46, 54, 64, 65, 76, 98 ] 用C实现的简单插入排序： 1234567891011121314151617181920#include &lt;stdio.h&gt;void mySort(int array[],int size)&#123; for(int i=0;i&lt;size-1;i++)&#123; int temp = array[i+1]; for(int j=i+1;j&gt;0;j--)&#123; if(temp&lt;array[j])&#123; array[j+1] = array[j]; array[j] = temp; &#125; &#125; &#125;&#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98 &#125;; mySort(a,10); for(int i = 0;i&lt;10;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125; 二、二分插入排序(折半插入排序)二分插入排序也是插入排序的一种，其又叫做折半插入排序。它与直接插入排序的唯一不同只在于查找插入位置的方式。直接插入排序是通过遍历来查找要插入元素的位置，二分插入排序则是通过二分法来查找要插入的位置，之后将此位置所有元素后移，将排序的元素进行插入。 JavaScript实现的二分插入排序： 123456789101112131415161718192021var array = [1,54,2,64,12,65,76,46,34,98];//二分插入排序for(var i=0;i&lt;array.length-1;i++)&#123; var temp = array[i+1]; var left = 0; var right = i; var middle; while(left&lt;=right)&#123; middle = Math.round((left+right)/2); if (array[middle]&gt;temp) &#123; right=middle-1; &#125;else&#123; left = middle+1; &#125; &#125; for(var j=i+1;j&gt;left;j--)&#123; array[j] = array[j-1]; &#125; array[left] = temp;&#125;console.log(array);//[ 1, 2, 12, 34, 46, 54, 64, 65, 76, 98 ]; C实现的二分插入排序： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;//二分插入排序void mySort(int array[],int size)&#123; for(int i=0;i&lt;size-1;i++)&#123; int temp = array[i+1]; int left=0,right=i,middle; while(left&lt;=right)&#123; middle = (left+right)/2; if(array[middle]&gt;temp)&#123; right=middle-1; &#125;else &#123; left = middle+1; &#125; &#125; for(int j =i+1;j&gt;left;j--)&#123; array[j] = array[j-1]; &#125; array[left] = temp; &#125;&#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98 &#125;; mySort(a,10); for(int i = 0;i&lt;10;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125; 三、希尔排序希尔排序也是插入排序的一种，它先将整个数列分割成若干个小的子序列进行插入排序，逐渐减少子序列的个数，直到最后组合成一个数列，完成整个排序过程。希尔排序的过程使用文字描述可以表示为如下几步： 1.假设数列元素个数为n，先取一个小于n的增量d1，将所有间隔d1距离的元素放为1组进行插入排序，d1通常取值n/2，向下取整。 2.再次取d2&lt;d1，将所有间隔d2距离的元素放为1组进行插入排序，通常d2取值为d1/2，向下取整。 3.重复步骤2，直到取得d等于1。 图示希尔排序如下： JavaScript实现的希尔排序： 123456789101112131415161718192021222324var array = [1,54,2,64,12,65,76,46,34,98];//希尔排序//步长 分组数var d = Math.floor(array.length/2);while(d&gt;=1)&#123; //每组元素个数 var counts = Math.floor(array.length/d); //每组排序依次 for (var i = 0; i &lt; d ; i++) &#123; //组内的插入排序 for(var j = 0;j&lt;counts-1;j++)&#123; var temp = array[(j+1)*d]; for(var k = ((j+1)*d);k&gt;0;k-=d)&#123; if (temp&lt;array[k]) &#123; array[k+d] = array[k]; array[k] = temp; &#125; &#125; &#125; &#125; //重取d值 d=Math.floor(d/2);&#125;console.log(array);//[ 1, 2, 12, 34, 46, 54, 64, 65, 76, 98 ]; C实现的希尔排序： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;//希尔排序void mySort(int array[],int size)&#123; int d = size/2; while(d&gt;=1)&#123; //每组元素个数 int counts = size/d; //每组排序依次 for (int i = 0; i &lt; d ; i++) &#123; //组内的插入排序 for(int j = 0;j&lt;counts-1;j++)&#123; int temp = array[(j+1)*d]; for(int k = ((j+1)*d);k&gt;0;k-=d)&#123; if (temp&lt;array[k]) &#123; array[k+d] = array[k]; array[k] = temp; &#125; &#125; &#125; &#125; //重取d值 d=d/2;&#125;&#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98 &#125;; mySort(a,10); for(int i = 0;i&lt;10;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125; 四、选择排序前边所说的3种排序算法原理上都是插入排序，即从无序数列中逐个取元素将其插入到有序数列中的合适位置。选择排序则刚好与之相反，其从无序数列中先找到最小值，放在排序数列首部，在依次找到剩余数列的中最小值追加入有序数列，最终完成数列的排序。用文字描述选择排序步骤不如： 1.找到数列中的最小值，将其作为有序数列的第一个元素。 2.从剩余数列中找到最小值，追加入有序数列。 3.重复步骤2，直到排完整个数列。 图示描述选择排序如下： JavaScript实现的选择排序算法： 1234567891011121314151617var array = [1,54,2,64,12,65,76,46,34,98];//选择排序for(var i=0;i&lt;array.length-1;i++)&#123; //找到最小值 var min = array[i]; var index = i; for (var j = i+1; j &lt;array.length; j++) &#123; if (array[j]&lt;min) &#123; min = array[j]; index = j; &#125; &#125; //进行交换 array[index]=array[i]; array[i]=min;&#125;console.log(array);//[ 1, 2, 12, 34, 46, 54, 64, 65, 76, 98 ] C实现的选择排序算法： 1234567891011121314151617181920212223//选择排序void mySort(int array[],int size)&#123; for(int i=0;i&lt;size-1;i++)&#123; int min = array[i]; int index = i; for(int j=i+1;j&lt;size;j++)&#123; if(array[j]&lt;min)&#123; min = array[j]; index = j; &#125; &#125; array[index] = array[i]; array[i]=min; &#125;&#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98&#125;; mySort(a,11); for(int i = 0;i&lt;10;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125; 五、冒泡排序冒泡排序和选择排序是我们学习编程课时必不可少的两种排序算法，冒泡排序算法的核心是每次比较相邻的连个元素，如果它们的顺序不对，则进行交换，一轮排序下来，最大值一定被排序到数列的末端。之后除去最后一个元素再进行第二轮冒泡，直到整个数列排序完成。用文字描述冒泡排序的过程如下： 1.从左向右依次比较相邻两元素，如果顺序不对，则进行交换，最终最大的元素被放在最后。 2.除去最后一个元素，重复步骤1，最终剩下元素中最大的被放在倒数第2个位置。 3.继续上面的重复，直到排完整个数列。 JavaScript实现的冒泡排序算法： 123456789101112var array = [1,54,2,64,12,65,76,46,34,98];//冒泡排序for(var i=0;i&lt;array.length-1;i++)&#123; for(var j=0;j&lt;array.length-i-1;j++)&#123; var temp = array[j]; if (temp&gt;array[j+1]) &#123; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125;&#125;console.log(array);//[ 1, 2, 12, 34, 46, 54, 64, 65, 76, 98 ] C实现的冒泡排序算法： 123456789101112131415161718192021#include &lt;stdio.h&gt;//冒泡排序void mySort(int array[],int size)&#123; for(int i =0;i&lt;size-1;i++)&#123; for(int j=0;j&lt;size-1-i;j++)&#123; int temp = array[j]; if(temp&gt;array[j+1])&#123; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125;&#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98&#125;; mySort(a,10); for(int i = 0;i&lt;10;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125; 六、双向冒泡排序双向冒泡排序是冒泡排序的一种变体，冒泡排序每次比较都是从左向右，找出最大的放在最后。双向冒泡排序则是第一轮从左向右将最大的放最后，第二轮从右向左将最小的放最首，如此交替直到整个数列排序完成。文字描述双向冒泡排序步骤如下： 1.从左向右依次比较相邻两个元素，如果顺序不对，则进行交换，如此一轮下来，最大的元素在最后。 2.除去已经排序好的元素，从右向左依次比较相邻的两个元素，如果顺序不对，则进行交换，最小的元素在首部。 3.交替重复步骤1与步骤2直到排序完成。 双向冒泡排序示意图如下： JavaScript实现的双向冒泡排序算法： 12345678910111213141516171819202122232425var array = [1,54,2,64,12,65,76,46,34,98];//双向冒泡排序var start = 0;var end = array.length;while(end-start&gt;0)&#123; //从左向右冒泡 for(var i=start;i&lt;end-1;i++)&#123; var temp = array[i]; if (array[i+1]&lt;temp) &#123; array[i] = array[i+1]; array[i+1] = temp; &#125; &#125; end--; //从右向左冒泡 for(var j=end;j&gt;start+1;j--)&#123; var temp = array[j]; if (array[j-1]&gt;temp) &#123; array[j] = array[j-1]; array[j-1] = temp; &#125; &#125; start++;&#125;console.log(array);//[ 1, 2, 12, 34, 46, 54, 64, 65, 76, 98 ] C实现的双向冒泡排序算法： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;//双向冒泡排序void mySort(int array[],int size)&#123; int start = 0; int end = size; //从左向右冒泡 for(int i=start;i&lt;end-1;i++)&#123; int temp = array[i]; if (array[i+1]&lt;temp) &#123; array[i] = array[i+1]; array[i+1] = temp; &#125; &#125; end--; //从右向左冒泡 for(int j=end;j&gt;start+1;j--)&#123; int temp = array[j]; if (array[j-1]&gt;temp) &#123; array[j] = array[j-1]; array[j-1] = temp; &#125; &#125; start++;&#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98,33&#125;; mySort(a,11); for(int i = 0;i&lt;11;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125; 七、快速排序算法快速排序算法和基本思路是通过一趟排序将数列分成两部分，其中一部分的所有数据都比另一部分小。之后在分别在两个子数列中进行递归，直到最终排序完成。快速排序算法的核心是递归，因此其效率十分高。用文字描述快速排序的步骤如下： 1.随机取一个元素作为基准，将小于此元素的数据都放在此元素的左侧，大于此元素的数据都放在此元素的右侧，将数列分隔成左右两个子数列。 2.分别对左右子数列进行步骤1的递归，直到数列长度为1或者0，表示排序完成。 JavaScript实现的快速排序算法： 12345678910111213141516171819202122232425262728293031323334353637var array = [1, 54, 2, 64, 12, 65, 76, 46, 34, 98, 34];//快速排序function sort(array, left, right) &#123; if (right - left &gt;= 1) &#123; //取第一个元素作为基准 let base = array[left]; let i = left + 1; let index = left; while (i &lt;= right) &#123; //大于等于的已经在右边 不需要修改 小于的要放在左边 if (array[i] &lt; base) &#123; if (index + 1 == i) &#123; //交换 array[index] = array[i]; array[i] = base; index++; &#125; else &#123; //先将base与其后一个元素交换 array[index] = array[index + 1]; array[index + 1] = base; //交换 let temp = array[index]; array[index] = array[i]; array[i] = temp; index++; &#125; &#125; i++; &#125; //递归排序 sort(array, left, index - 1); sort(array, index + 1, right); &#125;&#125;sort(array, 0, array.length - 1);console.log(array); //[ 1, 2, 12, 34,34, 46, 54, 64, 65, 76, 98 ] C语言实现的快速排序： 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;//快速排序void mySort(int array[],int left,int right)&#123; if(right-left&gt;=1)&#123; int base = array[left]; int i = left+1; int index = left; while(i&lt;=right)&#123; if(array[i]&lt;base)&#123; if(index+1==i)&#123; array[index] = array[i]; array[i]=base; index = i; &#125;else&#123; array[index]=array[index+1]; array[index+1] = base; int temp = array[index]; array[index] = array[i]; array[i] = temp; index++; &#125; &#125; i++; &#125; mySort(array, left, index-1); mySort(array, index+1, right); &#125;&#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98,34&#125;; mySort(a,0,10); for(int i = 0;i&lt;11;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125; 八、堆排序堆排序是比快速排序更加复杂的一种排序算法。堆排序使用到了堆这样一种数据结构。首先我们需要搞清楚什么是堆结构。堆是一种类似完全二叉树，同时又满足如下条件的数据结构：所有子节点的值总是小于(大于)父节点。所有子节点的值都小于父节点的堆叫大顶堆，所有子节点都大于父节点的堆叫小顶堆。 二叉树你应该比较熟悉，下图就是一个小顶堆的示例： 此二叉树中任何一个子节点的值都是大于父节点。如何将数列构造成这样一个堆结构呢，其实十分简单，将数列按照从上到下，从左到右的原则来构造完全二叉树即可。例如如下数列[1, 54, 2, 64, 12, 65, 76, 46, 34, 98, 34]如果将其构造成堆如下图所示： 正常情况下，这个由数组映射成的二叉树并不符合我们堆的要求，否则也就不需要我们用算法来排序了。要让这个二叉树符合要求，我们需要进行整理，即从末节点开始进行调整，例如先从12，98，34中找到最小的，放在现在12所在的位置，然后从64，46，34中找到最小的元素进行上浮，接着再一层层上浮上去，直到堆顶元素为所有元素中的最小元素。整理完成后，我们只需要将堆顶元素和最后一个元素进行交换，之后除掉最后一个元素再进行堆整理，整理完成后再将顶元素(此时为第2小)与倒数第二个元素交换，依次进行下去，即可完成数列的排序。 用文字描述堆排序步骤如下： 1.先将数列整理成符合要求的堆。 2.将首末元素交换。 3.除掉最后一个元素在进行堆的整理。 4.重复进行2和3，直到数列排序完成。 JavaScript实现的堆排序算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var array = [1, 54, 2, 64, 12, 65, 76, 46, 34, 98, 34];//堆排序//堆调整 大顶function store(array,index,end)&#123; let top = array[index]; let left; let right; if (index*2+1&lt;=end) &#123; left = index*2+1; &#125;else&#123; //没有左子树 说明已经是叶子节点 //无需调整直接return return; &#125; if (index*2+2&lt;=end) &#123; right = index*2+2; &#125;else&#123; //没有右子树 调整左子树即可 if (array[left]&gt;top) &#123; array[index] = array[left]; array[left] = top; top = array[index]; &#125; return; &#125; //找出堆单元中的最大值 if (array[left]&gt;top) &#123; array[index] = array[left]; array[left] = top; top = array[index]; &#125; if (array[right]&gt;top) &#123; array[index] = array[right]; array[right] = top; top = array[index]; &#125;&#125;function sort(array,end)&#123; //先将堆进行调整 倒叙调整 let i = end; while(i&gt;=0)&#123; store(array,i,end) i--; &#125; //根节点一定是最大的 放最后 再进行堆整理 let temp = array[end]; array[end] = array[0]; array[0] = temp; end--; if (end&gt;0) &#123; sort(array,end); &#125;else&#123; return; &#125; &#125;sort(array, array.length-1);console.log(array); //[ 1, 2, 12, 34,34, 46, 54, 64, 65, 76, 98 ] C语言实现的堆排序算法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;void store(int array[],int index,int end)&#123; int top = array[index]; int left; int right; if (index*2+1&lt;=end) &#123; left = index*2+1; &#125;else&#123; //没有左子树 说明已经是叶子节点 //无需调整直接return return; &#125; if (index*2+2&lt;=end) &#123; right = index*2+2; &#125;else&#123; //没有右子树 调整左子树即可 if (array[left]&gt;top) &#123; array[index] = array[left]; array[left] = top; top = array[index]; &#125; return; &#125; //找出堆单元中的最大值 if (array[left]&gt;top) &#123; array[index] = array[left]; array[left] = top; top = array[index]; &#125; if (array[right]&gt;top) &#123; array[index] = array[right]; array[right] = top; top = array[index]; &#125;&#125;void mySort(int array[],int end)&#123; //先将堆进行调整 倒叙调整 int i = end; while(i&gt;=0)&#123; store(array,i,end); i--; &#125; //根节点一定是最大的 放最后 再进行堆整理 int temp = array[end]; array[end] = array[0]; array[0] = temp; end--; if (end&gt;0) &#123; mySort(array,end); &#125;else&#123; return; &#125; &#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98,34&#125;; mySort(a,10); for(int i = 0;i&lt;11;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125; 需要注意，大顶堆排序完成后为升序，小顶堆排序完成后为降序。 九、归并排序归并排序的核心并不是交换元素的顺序，而是将数列分成多个有序小数列，将相邻的小数列进行归并。文字描述归并排序步骤如下： 1.把长度为n的数列分成长度为1的n个数列。 2.相邻数列进行排序归并。 3.重复操作2，直到所有数列归并成1个整体。 JavaScript实现的归并排序算法： 12345678910111213141516171819202122232425262728293031323334353637383940var array = [1, 54, 2, 64, 12, 65, 76, 46, 34, 98, 34];//归并排序function mergeArray(arrL,arrR)&#123; var tempArray = new Array(); let i = 0; let j = 0; while(i&lt;arrL.length &amp;&amp; j&lt;arrR.length)&#123; if (arrL[i]&lt;arrR[j]) &#123; tempArray.push(arrL[i]); i++; &#125;else&#123; tempArray.push(arrR[j]); j++; &#125; &#125; while(i&lt;arrL.length)&#123; tempArray.push(arrL[i]); i++; &#125; while(j&lt;arrR.length)&#123; tempArray.push(arrR[j]); j++ &#125; return tempArray;&#125;function sort(array)&#123; if (array.length&gt;1) &#123; let arrL = array.slice(0,Math.floor(array.length/2)); let arrR = array.slice(Math.floor(array.length/2),array.length); if (arrL.length&gt;1) &#123; arrL = sort(arrL); &#125; if (arrR.length&gt;1) &#123; arrR = sort(arrR); &#125; return mergeArray(arrL,arrR); &#125; return array;&#125;console.log(sort(array)); //[ 1, 2, 12, 34,34, 46, 54, 64, 65, 76, 98 ] C语言实现的归并排序算法： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;void merge(int array[],int temp[],int start,int end,int middle)&#123; int i=start,j=middle+1,k=start; while(i&lt;middle+1 &amp;&amp; j&lt;end+1)&#123; if(array[i]&lt;array[j])&#123; temp[k++] = array[i++]; &#125;else &#123; temp[k++] = array[j++]; &#125; &#125; while(i&lt;middle+1)&#123; temp[k++] = array[i++]; &#125; while(j&lt;end+1)&#123; temp[k++] = array[j++]; &#125; for(i=start;i&lt;=end;i++)&#123; array[i] = temp[i]; // printf(\"%d,\",temp[i]); &#125;&#125;void sort(int array[],int temp[],int start,int end)&#123; int middle; if(start&lt;end)&#123; middle = (start+end)/2; sort(array, temp, start, middle); sort(array, temp, middle+1, end); merge(array, temp, start, end, middle); &#125;&#125;int main()&#123; int a[] = &#123;1, 2, 12, 34, 46, 54, 64, 65, 76, 98,34&#125;; int b[11] = &#123;0&#125;; sort(a,b,0,10); for(int i = 0;i&lt;11;i++)&#123; printf(\"%d\\n\",a[i]); &#125; return 0;&#125;","categories":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}],"tags":[],"keywords":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/categories/编程珠玑/"}]},{"title":"Git命令集十三——快照操作","slug":"320 Git命令集十三——快照操作","date":"2017-03-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.366Z","comments":true,"path":"2017/03/21/320 Git命令集十三——快照操作/","link":"","permalink":"http://huishao.cc/2017/03/21/320 Git命令集十三——快照操作/","excerpt":"","text":"Git命令集十三——快照操作Git工具中提供了一个stash命令，这个命令的作用是创建快照。快照主要的用途是将当前未更新到缓存区的修改进行入栈保存，创建快照后，Git的状态会变回上一次提交时的状态，这时候我们可以做其他的操作。创建的快照会被保存在栈中，在需要的时候，我们可以恢复快照。举一个小例子，实际开发中，很多情况我们都会从主分支拉出一个新的分支进行新功能的开发，如果我们在开发过程中，有一个紧急的bug需要到主分支中修改，这时候我们常常会将目前为完善的代码先提交到新的分支，然后切回主分支修改bug，之后再回来继续开发。但是如果这个新的分支并不只是你一个人开发，你的不完善的提交很有可能造成别人无法工作，其实你可以使用Git的快照命令，先将自己的修改存成快照入栈保存，回到主分支修改完bug后，在将快照出栈即可。 1.git stash将当前未更新到缓存区的修改创建成快照。需要注意，快照是采用栈的方式管理。我们可以入栈多个快照，例如先做一部分修改，创建为快照，之后又进行了修改，再次创建快照。第2次快照并不会覆盖以前的快照，我们可以指定恢复到的快照。 2.git stash list打印当前栈中的所有快照。 3.git stash show 打印某个快照的修改信息，后面的stash参数指定快照在栈中的位置，命令格式如下：stash@{num}，最后入栈的为stash@{0}，向前依次为stash@{1}、stash@{2}...。如果不限stash参数，则默认将打印栈顶快照的信息。 4.git stash pop 恢复到某个快照版本，如果不加stash参数，则默认会恢复到栈顶的快照版本。这个命令会将恢复的快照从栈中删除掉。 5.git stash apply 恢复到某个快照的版本，如果不加stash参数，则默认会恢复到栈顶的快照版本。这个命令和pop的不同之处在于恢复的快照并不会从栈中删除。 6.git stash clear清空栈中的所有快照。 7.git stash drop 清除栈中的某个快照，如果不设置stash参数，则会默认清除栈顶的快照。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集十二——分支合并","slug":"319Git命令集十二——分支合并","date":"2017-03-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.366Z","comments":true,"path":"2017/03/15/319Git命令集十二——分支合并/","link":"","permalink":"http://huishao.cc/2017/03/15/319Git命令集十二——分支合并/","excerpt":"","text":"Git命令集十二——分支合并1.git merge 将指定分支合并进当前分支。 2.git merge –commit 将指定分支合并进当前分支，并且直接提交。 3.git merge –no-commit 将指定分支合并进当前分支，并不自动提交。 4.git merge –edit 将指定分支合并进当前分支，在提交之前进行合并信息的编辑。 5.git merge –no-edit 将指定分支合并进当前分支，不进行提交信息的编辑。 6.git merge –no-ff -m 将指定分支合并进当前分支，在合并操作后提交一条合并信息。 7.git merge 将某次提交合并进当前分支。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集十二——切换分支与还原文件","slug":"318Git命令集十二——切换分支与还原文件","date":"2017-03-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.366Z","comments":true,"path":"2017/03/14/318Git命令集十二——切换分支与还原文件/","link":"","permalink":"http://huishao.cc/2017/03/14/318Git命令集十二——切换分支与还原文件/","excerpt":"","text":"Git命令集十二——切换分支与还原文件1.git checkout 切换当前工作分支。 2.git checkout -b 新建一个分支并切换到此分支。如果分支已经存在会报错。 3.git checkout -B 新建一个分支并切换到此分支。如果分支已经存在则直接进行切换。 4.git checkout –merge 切换分支，如果当前分支有未提交的文件，则会自动进行合并操作。 5.git checkout 将修改过但是未使用add命令更新到缓存区的文件还原。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集十一——创建分支命令","slug":"317Git命令集十一——创建分支命令","date":"2017-03-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.366Z","comments":true,"path":"2017/03/13/317Git命令集十一——创建分支命令/","link":"","permalink":"http://huishao.cc/2017/03/13/317Git命令集十一——创建分支命令/","excerpt":"","text":"Git命令集十一——创建分支命令对分支操作的强大支持是Git管理工具的一大优势。你可以方便的进行分支的创建、合并、删除等。 1.git branch –list打印所有分支以及当前所在的分支。 2.git branch 创建新分支。 3.git branch –delete 删除一个分支。 4.git branch –color …设置输出多颜色风格。 5.git branch –no-color …设置输出无颜色风格。 6.git branch –all输出所有远程和本地分支。 7.git branch –contains只打印出包含某个commit提交的分支。 8.git branch –merged只打印出包含某个提交的分支。 9.git branch –no-merged只打印出不包含某次提交的分支。 10.git branch -m 修改已经存在的分支名称。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"让你的iOS应用程序支持运行JavaScript脚本：JavaScriptCore框架详解","slug":"316让你的iOS应用程序支持运行JavaScript脚本：JavaScriptCore框架详解","date":"2017-03-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.366Z","comments":true,"path":"2017/03/10/316让你的iOS应用程序支持运行JavaScript脚本：JavaScriptCore框架详解/","link":"","permalink":"http://huishao.cc/2017/03/10/316让你的iOS应用程序支持运行JavaScript脚本：JavaScriptCore框架详解/","excerpt":"","text":"让你的iOS应用程序支持运行JavaScript脚本：JavaScriptCore框架详解说到JavaScript脚本，iOS开发者都会想到一个名叫JavaScriptCore的框架。这个框架的确十分强大，其中封装了一套JavaScript运行环境以及Native与JS数据类型之间的转换桥梁。本篇博客主要讨论如何使用此框架来在iOS应用中运行JavaScript脚本。 一、JavaScriptCore框架结构在学习一个框架时，首先应该先了解整个框架的结构，拿iOS开发来举例，对于一个陌生的框架，第一步需要先搞清楚这里面都包含哪些类，个各类之间是怎样的关系，这个框架和其他的框架间有无联系以及怎样产生的联系。将些问题搞清楚，有了大体上的认识后，我们再来学习其中的每个类即其他细节的应用将非常容易。我们先来看一张JavaScriptCore框架的结构图： 这张图是我手工画的，不是那么美观并且没有文字的解释，但是我觉得它能非常直观的表达JavaScriptCore中包含的类之间的关系。下面我来向你解释这张图究竟表达了什么意思，首先原生的iOS应用是支持多线程执行任务的，我们知道JavaScript是单线程，但这并不代表我们不能在Native中异步执行不同的JavaScript代码。 1.JSVirtualMachine——JavaScript的虚拟机 JavaScriptCore中提供了一个名为JSVirtualMachine的类，顾名思义，这个类可以理解为一个JS虚拟机。在Native中，只要你愿意，你可以创建任意多个JSVirtualMachine对象，各个JSViretualMachine对象间是相互独立的，他们之间不能共享数据也不能传递数据，如果你把他们放在不同的Native线程，他们就可以并行的执行无关的JS任务。 2.JSContext——JavaScript运行环境 JSContext上下文对象可以理解为是JS的运行环境，同一个JSVirtualMachine对象可以关联多个JSContext对象，并且在WebView中每次刷新操作后，此WebView的JS运行环境都是不同的JSContext对象。其作用就是用来执行JS代码，在Native和JS间进行数据的传递。 3.JSValue——JavaScript值对象 JavaScript和Objective-C虽然都是面向对象语言，但其实现机制完全不同，OC是基于类的，JS是基于原型的，并且他们的数据类型间也存在很大的差异。因此若要在Native和JS间无障碍的进行数据的传递，就需要一个中间对象做桥接，这个对象就是JSValue。 4.JSExport JSExport是一个协议，Native中遵守此解析的类可以将方法和属性转换为JS的接口供JS调用。 5.一些用于C语言的结构 你一定注意到了，上图的右下角还有一块被虚线包围的区域，其中的&quot;类&quot;都是C语言风格，JavaScriptCore框架是支持在Objective-C、Swift和C三种语言中使用的。 二、在Native中运行JavaScript脚本代码我们先来编写一个最简单的例子，使用OC代码来执行一段JS脚本。首先新建一个文件，将其后缀设置为.js，我这里将它命令为main.js，在其中编写如下代码： 123(function()&#123; console.log(\"Hello Native\");&#125;)(); 上面是一个自执行的函数，其中打印了“Hello Native”字符串。在Native中编写如下代码： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; NSString * path = [[NSBundle mainBundle] pathForResource:@\"main\" ofType:@\"js\"]; NSData * jsData = [[NSData alloc]initWithContentsOfFile:path]; NSString * jsCode = [[NSString alloc]initWithData:jsData encoding:NSUTF8StringEncoding]; self.jsContext = [[JSContext alloc]init]; [self.jsContext evaluateScript:jsCode];&#125; 需要注意，其实这里我将创建的JSContext对象作为了当前视图控制器的属性，这样做的目的仅仅是为了方便调试，不过不对此context对象进行引用，当viewDidLoad函数执行完成后，JS运行环境也将被销毁，我们就无法在Safari中直观的看到JS代码的执行结果了。 运行工程，记得要打开Safari浏览器的自动显示JSContent检查器，如下图： 当iOS模拟器跑起来后，Safari会自动弹出开发者工具，在控制台里面可以看到来自JavaScript的真挚问候： 刚才我们只是简单了通过原生调用了一段JS代码，但是如果Native在调JS方法时无法传参那也太low了，我们可以直接将要传递的参数格式化到字符串中，修改main.js文件如下： 1234function put(name)&#123; console.log(\"Hello \"+name);&#125;;put(%@); 再封装一个OC方法如下： 1234567-(void)runJS_Hello:(NSString *)name&#123; NSString * path = [[NSBundle mainBundle] pathForResource:@\"main\" ofType:@\"js\"]; NSData * jsData = [[NSData alloc]initWithContentsOfFile:path]; NSString * jsCode = [[NSString alloc]initWithData:jsData encoding:NSUTF8StringEncoding]; NSString * finiString = [NSString stringWithFormat:jsCode,name]; [self.jsContext evaluateScript:finiString];&#125; 在viewDidLoad中进行调用，如下： 12345- (void)viewDidLoad &#123; [super viewDidLoad]; self.jsContext = [[JSContext alloc]init]; [self runJS_Hello:@\"'阿凡达'\"];&#125; 运行再看Safari控制台的结果，编程了Hello 阿凡达~： 其实evaluateScript函数执行后会将JS代码的执行结果进行返回，是JSValue类型的对象，后面会再介绍。 三、在JavaScript中调用Native方法有来无往非君子，同样也可以在原生中编写方法让JS来调用，示例如下： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; void(^block)() = ^()&#123; NSLog(@\"Hello JavaScript\"); &#125;; self.jsContext = [[JSContext alloc]init]; [self.jsContext setObject:block forKeyedSubscript:@\"oc_hello\"];&#125; 上面setObject:forKeyedSubscript:方法用来向JSContext环境的全局对象中添加属性，这里添加了一个函数属性，取名为oc_hello。这里JavaScriptCore会自动帮我们把一些数据类型进行转换，会将OC的函数转换为JS的函数，运行工程，在Safari的控制台中调用oc_hello函数，可以看到在Xcode控制台输出了对JavaScript的真挚问候，如下： 同样，如果声明的block是带参数的，JS在调用此OC方法时也需要传入参数，如果block有返回值，则在JS中也能获取到返回值，例如： 123456BOOL (^block)(NSString *) = ^(NSString *name)&#123; NSLog(@\"%@\", [NSString stringWithFormat:@\"Hello %@\",name]); return YES;&#125;;self.jsContext = [[JSContext alloc]init];[self.jsContext setObject:block forKeyedSubscript:@\"oc_hello\"]; 四、深入JSContext类看到这，你已经学会最基础的OC与JS互相问好(交互)。下面我们再来深入看下JSContext中的属性和方法。 创建JSContext对象有如下两种方式： 1234//创建一个新的JS运行环境- (instancetype)init;//创建一个新的JS运行环境 并关联到某个虚拟机对象上- (instancetype)initWithVirtualMachine:(JSVirtualMachine *)virtualMachine; 执行JS代码有如下两个方法： 1234//执行JS代码 结果将封装成JSValue对象返回- (JSValue *)evaluateScript:(NSString *)script;//作用同上- (JSValue *)evaluateScript:(NSString *)script withSourceURL:(NSURL *)sourceURL NS_AVAILABLE(10_10, 8_0); 下面的属性和方法可以获取到JS运行环境中的一些信息： 1234567891011121314151617181920212223242526//当前的JS运行环境 当JS调用OC方法时，在OC方法中可以用此方法获取到JS运行环境+ (JSContext *)currentContext;//获取当前执行的JS函数，当JS调用OC方法时，在OC方法中可以用此方法获取到执行的函数+ (JSValue *)currentCallee;//获取当前执行的JS函数中的this指向的对象+ (JSValue *)currentThis;//获取当前执行函数的参数列表，当JS调用OC方法时，在OC方法中可以用此方法获取到执行的函数的参数列表+ (NSArray *)currentArguments;//获取当前JS运行环境的全局对象@property (readonly, strong) JSValue *globalObject;//当运行的JavaScript代码抛出了未捕获的异常时，这个属性会被赋值为抛出的异常@property (strong) JSValue *exception;//设置为一个异常捕获的block，如果异常被此block捕获，exception属性就不再被赋值了@property (copy) void(^exceptionHandler)(JSContext *context, JSValue *exception);//当前运行环境所关联的虚拟机@property (readonly, strong) JSVirtualMachine *virtualMachine;//当前运行环境名称@property (copy) NSString *name;//获取当前JS运行环境全局对象上的某个属性- (JSValue *)objectForKeyedSubscript:(id)key;//设置当前JS运行环境全局对象上的属性- (void)setObject:(id)object forKeyedSubscript:(NSObject &lt;NSCopying&gt; *)key;//将C语言环境的JS运行环境转换为OC环境的JS运行环境+ (JSContext *)contextWithJSGlobalContextRef:(JSGlobalContextRef)jsGlobalContextRef;//C语言环境的JS运行上下文@property (readonly) JSGlobalContextRef JSGlobalContextRef; 五、深入JSValue类JSValue是JavaScript与Objective-C之间的数据桥梁。在Objective-C中调用JS脚本或者JS调用OC方法都可以使用JSValue来传输数据。其中属性和方法示例如下： 123456789101112131415161718192021222324//所对应的JS运行环境@property (readonly, strong) JSContext *context;//在指定的JS运行环境中创建一个JSValue对象+ (JSValue *)valueWithObject:(id)value inContext:(JSContext *)context;//创建布尔值+ (JSValue *)valueWithBool:(BOOL)value inContext:(JSContext *)context;//创建浮点值+ (JSValue *)valueWithDouble:(double)value inContext:(JSContext *)context;//创建32位整型值+ (JSValue *)valueWithInt32:(int32_t)value inContext:(JSContext *)context;//创建32位无符号整形值+ (JSValue *)valueWithUInt32:(uint32_t)value inContext:(JSContext *)context;//创建空的JS对象+ (JSValue *)valueWithNewObjectInContext:(JSContext *)context;//创建空的JS数组+ (JSValue *)valueWithNewArrayInContext:(JSContext *)context;//创建JS正则对象+ (JSValue *)valueWithNewRegularExpressionFromPattern:(NSString *)pattern flags:(NSString *)flags inContext:(JSContext *)context;//创建JS错误信息+ (JSValue *)valueWithNewErrorFromMessage:(NSString *)message inContext:(JSContext *)context;//创建JS null值+ (JSValue *)valueWithNullInContext:(JSContext *)context;//创建JS undefined值+ (JSValue *)valueWithUndefinedInContext:(JSContext *)context; JavaScript中的数据类型和Objective-C的数据类型还是有着很大的差异，其中对应关系如下： | Objective-C | JavaScript || nil | undefined || NSNull | null || NSString | string || NSNumber | number boolean || NSDictionary | Object || NSArray | Array || NSDate | Date || Block | Function || id | Object || Class | Object | 下面这些方法可以将JSValue值转换为Objective-C中的数据类型： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//将JSValue转换为OC对象- (id)toObject;//将JSValue转换成特定OC类的对象- (id)toObjectOfClass:(Class)expectedClass;//将JSValue转换成布尔值- (BOOL)toBool;//将JSValue转换成浮点值- (double)toDouble;//将JSValue转换成32位整型值- (int32_t)toInt32;//将JSValue转换成32位无符号整型值- (uint32_t)toUInt32;//将JSValue转换成NSNumber值- (NSNumber *)toNumber;//将JSValue转换成NSString值- (NSString *)toString;//将JSValue转换成NSDate值- (NSDate *)toDate;//将JSValue转换成NSArray值- (NSArray *)toArray;//将JSValue转换成NSDictionary值- (NSDictionary *)toDictionary;//获取JSValue对象中某个属性的值- (JSValue *)valueForProperty:(NSString *)property;//设置JSValue对象中某个属性的值- (void)setValue:(id)value forProperty:(NSString *)property;//删除JSValue对象中的某个属性- (BOOL)deleteProperty:(NSString *)property;//判断JSValue对象中是否包含某个属性- (BOOL)hasProperty:(NSString *)property;//定义JSValue中的某个属性 这个方法和JavaScript中Object构造函数的defineProperty方法一致/*第2个参数设置此属性的描述信息 可以设置的键值如下：NSString * const JSPropertyDescriptorWritableKey;//设置布尔值 是否可写NSString * const JSPropertyDescriptorEnumerableKey;//设置布尔值 是否可枚举NSString * const JSPropertyDescriptorConfigurableKey;//设置布尔值 是否可配置NSString * const JSPropertyDescriptorValueKey;//设置此属性的值NSString * const JSPropertyDescriptorGetKey;//设置此属性的get方法NSString * const JSPropertyDescriptorSetKey;//设置此属性的set方法以上set、get方法的键和value、可写性的键不能同时存在，其语法是JavaScript保持一致*/- (void)defineProperty:(NSString *)property descriptor:(id)descriptor;//获取JS数组对象某个下标的值- (JSValue *)valueAtIndex:(NSUInteger)index;//设置JS数组对象某个下标的值- (void)setValue:(id)value atIndex:(NSUInteger)index;//判断此对象是否为undefined@property (readonly) BOOL isUndefined;//判断此对象是否为null@property (readonly) BOOL isNull;//判断此对象是否为布尔值@property (readonly) BOOL isBoolean;//判断此对象是否为数值@property (readonly) BOOL isNumber;//判断此对象是否为字符串@property (readonly) BOOL isString;//判断此对象是否为object对象@property (readonly) BOOL isObject;//判断此对象是否为数组@property (readonly) BOOL isArray;//判断此对象是否为日期对象@property (readonly) BOOL isDate;//比较两个JSValue是否全相等 对应JavaScript中的===- (BOOL)isEqualToObject:(id)value;//比较两个JSValue对象的值是否相等 对应JavaScript中的==- (BOOL)isEqualWithTypeCoercionToObject:(id)value;//判断某个对象是否在当前对象的原型链上- (BOOL)isInstanceOf:(id)value;//如果JSValue是Function对象 可以调用此方法 和JavaScript中的call方法一致- (JSValue *)callWithArguments:(NSArray *)arguments;//如果JSValue是一个构造方法对象 可以调用此方法 和JavaScript中使用new关键字一致- (JSValue *)constructWithArguments:(NSArray *)arguments;//用此对象进行函数的调用 当前对象会被绑定到this中- (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments;//将CGPoint转换为JSValue对象+ (JSValue *)valueWithPoint:(CGPoint)point inContext:(JSContext *)context;//将NSRange转换为JSValue对象+ (JSValue *)valueWithRange:(NSRange)range inContext:(JSContext *)context;//将CGRect转换为JSValue对象+ (JSValue *)valueWithRect:(CGRect)rect inContext:(JSContext *)context;//将CGSize转换为JSValue对象+ (JSValue *)valueWithSize:(CGSize)size inContext:(JSContext *)context;//转换成CGPoint数据- (CGPoint)toPoint;//转换成NSRange数据- (NSRange)toRange;//转换成CGRect数据- (CGRect)toRect;//转换为CGSize数据- (CGSize)toSize;//将C风格的JSValueRef对象转换为JSValue对象+ (JSValue *)valueWithJSValueRef:(JSValueRef)value inContext:(JSContext *)context; 其实在JavaScriptCore框架中还有一个JSManagerValue类，这个的主要作用是管理内存。虽然我们在编写Objective-C代码时有强大的自动引用技术(ARC技术)，我们一般无需关心对象的内存问题，在编写JavaScript代码时也有强大的垃圾回收机制(这种机制下甚至连循环引用都不是问题)，但是在OC和JS混合开发时，就很容易出现问题了，比如一个JS垃圾回收机制释放掉的对象OC中却还在用，反过来也是一样。JSManagerValue对JSValue进行了一层包装，它可以保证在适合时候使用这个对象时对象都不会被释放，其中方法如下： 123456//创建JSVlaue对象的包装JSManagerValue+ (JSManagedValue *)managedValueWithValue:(JSValue *)value;+ (JSManagedValue *)managedValueWithValue:(JSValue *)value andOwner:(id)owner;- (instancetype)initWithValue:(JSValue *)value;//获取所包装的JSValue对象@property (readonly, strong) JSValue *value; 六、Objective-C与JavaScript复杂对象的映射我们在使用JavaScript调用Objective-C方法的实质是将一个OC函数设置为了JS全局对象的一个属性，当然我们也可以设置非函数的属性或者任意JSValue(或者可以转换为JSValue)的值。例如： 123self.jsContext = [[JSContext alloc]init];//向JS全局对象中添加一个获取当前Native设备类型的属性[self.jsContext setObject:@\"iOS\" forKeyedSubscript:@\"deviceType\"]; 但是如果我们想把OC自定义的一个类的对象设置为JS全局对象的某个属性，JS和OC有着完全不同的对象原理，如果不做任何处理，JS是接收不到OC对象中定义的属性和方法的。这时就需要使用到前面提到的JSExport协议，需要注意，这个协议不是用来被类遵守的，它里面没有规定任何方法，其是用来被继承定义新的协议的，自定义的协议中约定的方法和属性可以在JS中被获取到，示例如下: OC中新建一个自定义的类： 1234567891011121314151617181920@protocol MyObjectProtocol &lt;JSExport&gt;@property(nonatomic,strong)NSString * name;@property(nonatomic,strong)NSString * subject;@property(nonatomic,assign)NSInteger age;-(void)sayHi;@end@interface MyObject : NSObject&lt;MyObjectProtocol&gt;@property(nonatomic,strong)NSString * name;@property(nonatomic,strong)NSString * subject;@property(nonatomic,assign)NSInteger age;@end@implementation MyObject-(void)sayHi&#123; NSLog(@\"Hello JavaScript\");&#125;@end 添加到JS全局对象中： 12345MyObject* object = [MyObject new];object.name = @\"Jaki\";object.age = 25;object.subject = @\"OC\";[jsContext setObject:object forKeyedSubscript:@\"deviceObject\"]; 在JS运行环境中可以完整的到deviceObject对象，如下： 七、C语言风格的API解释JavaScriptCore框架中除了包含完整的Objective-C和Swift语言的API外，也提供了对C语言的支持。 与JS运行环境相关的方法如下： 123456789101112131415161718192021222324252627//创建一个JSContextRef组/*JSContextRef相当于JSContext，同一组中的数据可以共享*/JSContextGroupRef JSContextGroupCreate(void);//内存引用JSContextGroupRef JSContextGroupRetain(JSContextGroupRef group);//内存引用释放void JSContextGroupRelease(JSContextGroupRef group);//创建一个全局的运行环境JSGlobalContextRef JSGlobalContextCreate(JSClassRef globalObjectClass);//同上JSGlobalContextRef JSGlobalContextCreateInGroup(JSContextGroupRef group, JSClassRef globalObjectClass);//内存引用JSGlobalContextRef JSGlobalContextRetain(JSGlobalContextRef ctx);//内存引用释放void JSGlobalContextRelease(JSGlobalContextRef ctx);//获取全局对象JSObjectRef JSContextGetGlobalObject(JSContextRef ctx);//获取JSContextRef组JSContextGroupRef JSContextGetGroup(JSContextRef ctx);//获取全局的运行环境JSGlobalContextRef JSContextGetGlobalContext(JSContextRef ctx);//获取运行环境名JSStringRef JSGlobalContextCopyName(JSGlobalContextRef ctx);//设置运行环境名void JSGlobalContextSetName(JSGlobalContextRef ctx, JSStringRef name); 与定义JS对象的相关方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//定义JS类/*参数JSClassDefinition是一个结构体 其中可以定义许多回调*/JSClassRef JSClassCreate(const JSClassDefinition* definition);//引用内存JSClassRef JSClassRetain(JSClassRef jsClass);//释放内存void JSClassRelease(JSClassRef jsClass);//创建一个JS对象JSObjectRef JSObjectMake(JSContextRef ctx, JSClassRef jsClass, void* data);//定义JS函数JSObjectRef JSObjectMakeFunctionWithCallback(JSContextRef ctx, JSStringRef name, JSObjectCallAsFunctionCallback callAsFunction);//定义构造函数JSObjectRef JSObjectMakeConstructor(JSContextRef ctx, JSClassRef jsClass, JSObjectCallAsConstructorCallback callAsConstructor);//定义数组JSObjectRef JSObjectMakeArray(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);//定义日期对象JSObjectRef JSObjectMakeDate(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);//定义异常对象JSObjectRef JSObjectMakeError(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);//定义正则对象JSObjectRef JSObjectMakeRegExp(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);//定义函数对象JSObjectRef JSObjectMakeFunction(JSContextRef ctx, JSStringRef name, unsigned parameterCount, const JSStringRef parameterNames[], JSStringRef body, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception);//获取对象的属性JSValueRef JSObjectGetPrototype(JSContextRef ctx, JSObjectRef object);//设置对象的属性void JSObjectSetPrototype(JSContextRef ctx, JSObjectRef object, JSValueRef value);//检查对象是否包含某个属性bool JSObjectHasProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName);//获取对象属性JSValueRef JSObjectGetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);//定义对象属性void JSObjectSetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception);//删除对象属性bool JSObjectDeleteProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception);//获取数组值JSValueRef JSObjectGetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef* exception);//设置数组值void JSObjectSetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef value, JSValueRef* exception);//获取私有数据void* JSObjectGetPrivate(JSObjectRef object);//设置私有数据bool JSObjectSetPrivate(JSObjectRef object, void* data);//判断是否为函数bool JSObjectIsFunction(JSContextRef ctx, JSObjectRef object);//将对象作为函数来调用JSValueRef JSObjectCallAsFunction(JSContextRef ctx, JSObjectRef object, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);//判断是否为构造函数bool JSObjectIsConstructor(JSContextRef ctx, JSObjectRef object);//将对象作为构造函数来调用JSObjectRef JSObjectCallAsConstructor(JSContextRef ctx, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception);//获取所有属性名JSPropertyNameArrayRef JSObjectCopyPropertyNames(JSContextRef ctx, JSObjectRef object);//进行内存引用JSPropertyNameArrayRef JSPropertyNameArrayRetain(JSPropertyNameArrayRef array);//内存释放void JSPropertyNameArrayRelease(JSPropertyNameArrayRef array);//获取属性个数size_t JSPropertyNameArrayGetCount(JSPropertyNameArrayRef array);//在属性名数组中取值JSStringRef JSPropertyNameArrayGetNameAtIndex(JSPropertyNameArrayRef array, size_t index);//添加属性名void JSPropertyNameAccumulatorAddName(JSPropertyNameAccumulatorRef accumulator, JSStringRef propertyName); JS数据类型相关定义在JSValueRef中，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//获取值的类型/*枚举如下：typedef enum &#123; kJSTypeUndefined, kJSTypeNull, kJSTypeBoolean, kJSTypeNumber, kJSTypeString, kJSTypeObject&#125; JSType;*/JSType JSValueGetType(JSContextRef ctx, JSValueRef);//判断是否为undefined类型bool JSValueIsUndefined(JSContextRef ctx, JSValueRef value);//判断是否为null类型bool JSValueIsNull(JSContextRef ctx, JSValueRef value);//判断是否为布尔类型bool JSValueIsBoolean(JSContextRef ctx, JSValueRef value);//判断是否为数值类型bool JSValueIsNumber(JSContextRef ctx, JSValueRef value);//判断是否为字符串类型bool JSValueIsString(JSContextRef ctx, JSValueRef value);//判断是否为对象类型bool JSValueIsObject(JSContextRef ctx, JSValueRef value);//是否是类bool JSValueIsObjectOfClass(JSContextRef ctx, JSValueRef value, JSClassRef jsClass);//是否是数组bool JSValueIsArray(JSContextRef ctx, JSValueRef value);//是否是日期bool JSValueIsDate(JSContextRef ctx, JSValueRef value);//比较值是否相等bool JSValueIsEqual(JSContextRef ctx, JSValueRef a, JSValueRef b, JSValueRef* exception);//比较值是否全等bool JSValueIsStrictEqual(JSContextRef ctx, JSValueRef a, JSValueRef b);//是否是某个类的实例bool JSValueIsInstanceOfConstructor(JSContextRef ctx, JSValueRef value, JSObjectRef constructor, JSValueRef* exception);//创建undefined值JSValueRef JSValueMakeUndefined(JSContextRef ctx);//创建null值JSValueRef JSValueMakeNull(JSContextRef ctx);//创建布尔值JSValueRef JSValueMakeBoolean(JSContextRef ctx, bool boolean);//创建数值JSValueRef JSValueMakeNumber(JSContextRef ctx, double number);//创建字符串值JSValueRef JSValueMakeString(JSContextRef ctx, JSStringRef string);//通过JSON创建对象JSValueRef JSValueMakeFromJSONString(JSContextRef ctx, JSStringRef string);//将对象转为JSON字符串JSStringRef JSValueCreateJSONString(JSContextRef ctx, JSValueRef value, unsigned indent, JSValueRef* exception);//进行布尔值转换bool JSValueToBoolean(JSContextRef ctx, JSValueRef value);//进行数值转换double JSValueToNumber(JSContextRef ctx, JSValueRef value, JSValueRef* exception);//字符串值赋值JSStringRef JSValueToStringCopy(JSContextRef ctx, JSValueRef value, JSValueRef* exception);//值与对象的转换JSObjectRef JSValueToObject(JSContextRef ctx, JSValueRef value, JSValueRef* exception); 在C风格的API中，字符串也被包装成了JSStringRef类型，其中方法如下： 12345678910111213//创建js字符串JSStringRef JSStringCreateWithCharacters(const JSChar* chars, size_t numChars);JSStringRef JSStringCreateWithUTF8CString(const char* string);//内存引用于释放JSStringRef JSStringRetain(JSStringRef string);void JSStringRelease(JSStringRef string);//获取字符串长度size_t JSStringGetLength(JSStringRef string);//转成UTF8字符串size_t JSStringGetUTF8CString(JSStringRef string, char* buffer, size_t bufferSize);//字符串比较bool JSStringIsEqual(JSStringRef a, JSStringRef b);bool JSStringIsEqualToUTF8CString(JSStringRef a, const char* b); 八、Hybird App 构建思路Hybird App是指混合模式移动应用，即其中既包含原生的结构有内嵌有Web的组件。这种App不仅性能和用户体验可以达到和原生所差无几的程度，更大的优势在于bug修复快，版本迭代无需发版。3月8日苹果给许多开发者发送了一封警告邮件，主要是提示开发者下载脚本动态更改App原本行为的做法将会被提审拒绝。其实这次邮件所提内容和Hybird App并无太大关系(对ReactNative也没有影响)，苹果警告的是网络下发脚本并且使用runtime动态修改Native行为的应用，Hybird App的实质并没有修改原Native的行为，而是将下发的资源进行加载和界面渲染，类似WebView。 关于混合开发，我们有两种模式： 1.Native内嵌WebView，通过JS与OC交互实现业务无缝的衔接。 无论是UIWebView还是WKWebKit，我们都可以在其中拿到当前的JSContext，然是使用前面介绍的方法便可以实现数据互通与交互。这种方式是最简单的混合开发，但其性能和原生相比要差一些。示意图如下： 2.下发JS脚本，使用类似ReactNative的框架进行原生渲染 这是一种效率非常高的混合开发模式，并且ReactNative也本身支持android和iOS公用一套代码。我们也可以使用JavaScriptCore自己实现一套解析逻辑，使用JavaScript来编写Native应用，要完整实现这样一套东西太复杂了，我们也没有能力完成一个如此庞大的工程，但是我们可以做一个小Demo来模拟其原理，这样可以更好的帮助我们理解Hybird App的构建原理。 我们打算实现这样的功能：通过下发JS脚本创建原生的UILabel标签与UIButton控件，首先编写JS代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253(function()&#123; console.log(\"ProgectInit\"); //JS脚本加载完成后 自动render界面 return render();&#125;)();//JS标签类function Label(rect,text,color)&#123; this.rect = rect; this.text = text; this.color = color; this.typeName = \"Label\";&#125;//JS按钮类function Button(rect,text,callFunc)&#123; this.rect = rect; this.text = text; this.callFunc = callFunc; this.typeName = \"Button\";&#125;//JS Rect类function Rect(x,y,width,height)&#123; this.x = x; this.y = y; this.width = width; this.height = height;&#125;//JS颜色类function Color(r,g,b,a)&#123; this.r = r; this.g = g; this.b = b; this.a = a;&#125; //渲染方法 界面的渲染写在这里面 function render()&#123; var rect = new Rect(20,100,280,30); var color = new Color(1,0,0,1); var label = new Label(rect,\"Hello World\",color); var rect2 = new Rect(20,150,280,30); var color2 = new Color(0,1,0,1); var label2 = new Label(rect2,\"Hello Native\",color2); var rect3 = new Rect(20,200,280,30); var color3 = new Color(0,0,1,1); var label3 = new Label(rect3,\"Hello JavaScript\",color3); var rect4 = new Rect(20,240,280,30); var button = new Button(rect4,\"我是一个按钮\",function()&#123; var randColor = new Color(Math.random(),Math.random(),Math.random(),1); Globle.changeBackgroundColor(randColor); &#125;); //将控件以数组形式返回 return [label,label2,label3,button]; &#125; 创建一个Objective-C类绑定到JS全局对象上，作为OC方法的桥接器： 123456789101112131415161718//.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;JavaScriptCore/JavaScriptCore.h&gt;@protocol GloblePrptocol &lt;JSExport&gt;-(void)changeBackgroundColor:(JSValue *)value;@end@interface Globle : NSObject&lt;GloblePrptocol&gt;@property(nonatomic,weak)UIViewController * ownerController;@end//.m#import \"Globle.h\"@implementation Globle-(void)changeBackgroundColor:(JSValue *)value&#123; self.ownerController.view.backgroundColor = [UIColor colorWithRed:value[@\"r\"].toDouble green:value[@\"g\"].toDouble blue:value[@\"b\"].toDouble alpha:value[@\"a\"].toDouble];&#125;@end 在ViewController中实现一个界面渲染的render解释方法，并建立按钮的方法转换，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// ViewController.m// JavaScriptCoreTest//// Created by vip on 17/3/6.// Copyright © 2017年 jaki. All rights reserved.//#import \"ViewController.h\"#import &lt;JavaScriptCore/JavaScriptCore.h&gt;#import \"Globle.h\"@interface ViewController ()@property(nonatomic,strong)JSContext * jsContext;@property(nonatomic,strong)NSMutableArray * actionArray;@property(nonatomic,strong)Globle * globle;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //创建JS运行环境 self.jsContext = [JSContext new]; //绑定桥接器 self.globle = [Globle new]; self.globle.ownerController = self; self.jsContext[@\"Globle\"] = self.globle; self.actionArray = [NSMutableArray array]; [self render];&#125;//界面渲染解释器-(void)render&#123; NSString * path = [[NSBundle mainBundle] pathForResource:@\"main\" ofType:@\"js\"]; NSData * jsData = [[NSData alloc]initWithContentsOfFile:path]; NSString * jsCode = [[NSString alloc]initWithData:jsData encoding:NSUTF8StringEncoding]; JSValue * jsVlaue = [self.jsContext evaluateScript:jsCode]; for (int i=0; i&lt;jsVlaue.toArray.count; i++) &#123; JSValue * subValue = [jsVlaue objectAtIndexedSubscript:i]; if ([[subValue objectForKeyedSubscript:@\"typeName\"].toString isEqualToString:@\"Label\"]) &#123; UILabel * label = [UILabel new]; label.frame = CGRectMake(subValue[@\"rect\"][@\"x\"].toDouble, subValue[@\"rect\"][@\"y\"].toDouble, subValue[@\"rect\"][@\"width\"].toDouble, subValue[@\"rect\"][@\"height\"].toDouble); label.text = subValue[@\"text\"].toString; label.textColor = [UIColor colorWithRed:subValue[@\"color\"][@\"r\"].toDouble green:subValue[@\"color\"][@\"g\"].toDouble blue:subValue[@\"color\"][@\"b\"].toDouble alpha:subValue[@\"color\"][@\"a\"].toDouble]; [self.view addSubview:label]; &#125;else if ([[subValue objectForKeyedSubscript:@\"typeName\"].toString isEqualToString:@\"Button\"])&#123; UIButton * button = [UIButton buttonWithType:UIButtonTypeSystem]; button.frame = CGRectMake(subValue[@\"rect\"][@\"x\"].toDouble, subValue[@\"rect\"][@\"y\"].toDouble, subValue[@\"rect\"][@\"width\"].toDouble, subValue[@\"rect\"][@\"height\"].toDouble); [button setTitle:subValue[@\"text\"].toString forState:UIControlStateNormal]; button.tag = self.actionArray.count; [button addTarget:self action:@selector(buttonAction:) forControlEvents:UIControlEventTouchUpInside]; [self.actionArray addObject:subValue[@\"callFunc\"]]; [self.view addSubview:button]; &#125; &#125;&#125;//按钮转换方法-(void)buttonAction:(UIButton *)btn&#123; JSValue * action = self.actionArray[btn.tag]; //执行JS方法 [action callWithArguments:nil];&#125;@end 运行工程，效果如下图所示，点击按钮即可实现简单的界面颜色切换： 上面的示例工程我只实现了UILabel类与UIButton类的JS-OC转换，如果将原生控件和JS对象再进行一层绑定，并且实现大部分JS类与原生类和他们内部的属性，则我们就开发了一套Hybird App开发框架，但并没有这个必要，如果你对更多兴趣，可以深入学习下ReactNative。 文中的示例Demo我放在了Github上，地址如下：[https://github.com/ZYHshao/Demo-Hybird](https://github.com/ZYHshao/Demo-Hybird)。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Git命令集之十——文件移动命令","slug":"315Git命令集之十——文件移动命令","date":"2017-03-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.365Z","comments":true,"path":"2017/03/09/315Git命令集之十——文件移动命令/","link":"","permalink":"http://huishao.cc/2017/03/09/315Git命令集之十——文件移动命令/","excerpt":"","text":"Git命令集之十——文件移动命令1.git rm 删除某个文件。这个命令会将文件直接删除，并将此操作更新到缓存区，直接进行commit提交即可。 2.git rm –force 删除时覆盖缓存区，进行强制删除。 3.git rm –cached 这个命令只会删除索引中的文件，即Git仓库中关于此文件的记录，不会真的将文件删除，此时Git的状态应该是有新添加的文件未更新到缓存区。 4.git rm –quiet 设置Git的输出信息为精简模式。 5.git mv 移动某个文件的位置并且重命令。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之九——重置命令","slug":"314Git命令集之九——重置命令","date":"2017-03-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.365Z","comments":true,"path":"2017/03/07/314Git命令集之九——重置命令/","link":"","permalink":"http://huishao.cc/2017/03/07/314Git命令集之九——重置命令/","excerpt":"","text":"Git命令集之九——重置命令1.git reset HEAD^返回到上一个版本状态，需要注意，这个命令不会修改本地文件的内容，这些新的内容会变为未更新到缓存区的状态。 2.git reset HEAD^ 退回某个文件到上一个版本的状态，同样不会修改本地文件的内容，这些新的内容会变成未更新到缓存区的状态。 3.git reset HEAD~n退回到n个版本之前，同样不会修改本地文件的内容，这些新的内容会变成未更新到缓存区的状态。 4.git reset 退回到某个指定的commit，同样不会修改本地文件的内容，这些新的内容会变成未更新到缓存区的状态。 注意：git在进行reset操作时，是可以设置操作模式的，常用的模式有hard，soft，mixed3种。如果不进行设置，默认都是mixed模式的，上面的列出的reset命令都是工作在这个模式下的。 5.git reset –mixed mixed模式是默认的模式，不指定的话也是这个模式。这个模式只会重置Git当前游标指针到某次提交，并不会修改本地文件，本地文件中的变化都将作为为更新到缓存区的状态。 6.git reset –hard hard模式会将Git当前游标指针重置到指定提交同时将本地文件也恢复到游标所在的提交时的状态。新的文件修改将被丢弃。 7.git reset –soft soft模式将Git游标指针重置到指定的提交，不修改本地文件状态，但是也不修改缓存区状态，所有的更改将默认作为下次commit的内容。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之八——提交命令","slug":"313Git命令集之八——提交命令","date":"2017-03-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.365Z","comments":true,"path":"2017/03/06/313Git命令集之八——提交命令/","link":"","permalink":"http://huishao.cc/2017/03/06/313Git命令集之八——提交命令/","excerpt":"","text":"Git命令集之八——提交命令1.git commit –message 将使用add命令更新后的修改进行提交，msg为本次提交操作的注释信息。 2.git commit –all –message 使用这个命令可以自动将修改或删除的文件进行更新到缓存区，然后在进行提交，即此命令实际上包括了两步操作，先将修改或删除的文件add更新，再提交，需要注意，这个命令不会将新添加的文件更新到缓存区。 3.git commit –reuse-message 使用指定提交的注释信息作为本次提交的注释信息，commit为某次提交的提交编号，在git中每次进行提交操作都会计算出一个编码，可以使用git log命令进行查看，如下： 4.git commit –reedit-message 这个命令和--reuse-message命令差不多，也是复制一个指定提交的注释信息，这个命令允许对注释信息进行修改后，在提交。 5.git commit –fixup 指定此次提交是某次提交的修复，会自动在被修改复提交所对应的注释前加fixup作为本次提交注释前缀。 6.git commit –squash 将此次提交作为指定提交的合并。 7.git commit –short –message 设置执行命令后的输出结果为精简模式。 8.git commit –branch –message 在输出中显示分支信息。 9.git commit –long –message 设置执行命令后的输出结果为详情模式。 10.git commit –author –message 为此次提交设置指定的作者。 11.git commit –amend修改最后一次提交的注释信息。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之七——差异查询命令","slug":"312Git命令集之七——差异查询命令","date":"2017-03-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.365Z","comments":true,"path":"2017/03/02/312Git命令集之七——差异查询命令/","link":"","permalink":"http://huishao.cc/2017/03/02/312Git命令集之七——差异查询命令/","excerpt":"","text":"Git命令集之七——差异查询命令1.git diff查看未提交的文件变化。会在控制台将文件的前后变化进行打印。 2.git diff –raw将文件变化的输出格式化层单行模式，只打印出有变化的文件。 3.git diff –stat生成一个差异报告，例如多少个文件修改了，修改了什么。打印示例如下： 4.git diff –numstat生成一个数字风格的差异报告。只显示填加了多少，删除了多少和修改的文件名。 5.git diff –shortstat生成一个简洁的差异报告。 6.git diff –name-only仅仅对变化的文件名进行打印。 7.git diff –name-status对变化的文件名和变化的状态进行打印。 8.git diff –color打印结果进行颜色区分。 9.git diff –word-diff以字的维度显示差异。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之六——查看仓库状态","slug":"311Git命令集之六——查看仓库状态","date":"2017-02-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.365Z","comments":true,"path":"2017/03/01/311Git命令集之六——查看仓库状态/","link":"","permalink":"http://huishao.cc/2017/03/01/311Git命令集之六——查看仓库状态/","excerpt":"","text":"Git命令集之六——查看仓库状态1.git status查看当前仓库状态，是否有未缓存的文件或者是否有未提交的修改。 2.git status –short使用简洁的格式进行状态输出。 3.git status –branch在输出信息中显示当前所在分支。 4.git status –long使用详细格式进行状态的输出。默认就是这种格式。 5.git status –untracked-files显示未跟踪的文件。 6.git status –ignored显示被忽略的文件。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之四——克隆命令","slug":"309Git命令集之四——克隆命令","date":"2017-02-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.364Z","comments":true,"path":"2017/02/28/309Git命令集之四——克隆命令/","link":"","permalink":"http://huishao.cc/2017/02/28/309Git命令集之四——克隆命令/","excerpt":"","text":"Git命令集之四——克隆命令1.git clone 这个命令是最基本的克隆命令，其可以从一个远程仓库中将Git仓库克隆岛本地，需要注意，第2个参数可以省略，如果省略，则在本地默认创建一个和远程仓库名相同的目录，不省略则在本地创建的目录名即是设置的dicName值。Git不只可以克隆远程仓库，也可以对本地的仓库进行克隆，但这并没有什么意义。 2.git clone –local 克隆本地仓库。 3.git clone –quiet 克隆过程中只对错误信息进行输出。 4.git clone –progress 克隆过程中报告进行状态。 5.git clone –no-checkout 克隆完成后，不对当前分支进行检出。 6.git clone –origin 使用自定义的名称代替远程origin名。 7.git clone –branch 克隆仓库后直接将指定的分支检出。 8.git clone –template设置一个指定的模板进行克隆。 9.git clone –config =对新克隆的仓库应用指定的配置。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之五——更新内容状态命令","slug":"310Git命令集之五——更新内容状态命令","date":"2017-02-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.365Z","comments":true,"path":"2017/02/28/310Git命令集之五——更新内容状态命令/","link":"","permalink":"http://huishao.cc/2017/02/28/310Git命令集之五——更新内容状态命令/","excerpt":"","text":"Git命令集之五——更新内容状态命令Git是一种分布式的项目版本管理工具，分布式的特点是并不存在中心服务器，每个人电脑中的项目工程都是一个完整的Git工程。在Git中，每次工程的变更都可以理解为一次操作，可以是修改文件，也可以是添加文件或删除文件。当我们想把某些操作进行提交时，首先需要使用add命令来将Git状态进行更新，本篇博客介绍与Git中与更新内容状态相关的命令。 首先在一个空的文件夹中使用git init命令创建Git仓库，使用git status命令查看当前的仓库状态如下： 可以看到，终端提示我们当前所在的分支为master分支，没有东西可以提交。现在我们可以在工程文件夹中新建一个txt格式的文本文件，再在终端使用git status命令查看状态，结果如下： 可以看到，Git提示我们有一个为跟踪的文件combin，使用如下命令来更新Git仓库的状态： 1git add combin 再次检查Git仓库的状态，如下： 可以看到，新添加的文件已经被存入缓存区，Git状态变为有一个改变未提交，后面在使用commit命令即可进行本次操作的提交。 同样，如果我们对一个已经存在的文件进行了修改，查看Git仓库状态如下： 若要提交此次修改，我们也需要先使用add将此文件操作更新到缓存区，之后再提交。 与add命令相关参数解析如下： 1.git add 将某个文件的修改状态更新到Git缓存区。 2.git add –dry-run 并不真正的更新 Git状态，仅仅展示下更新结果。 3.git add –force 允许添加忽略的文件。 4.git add –edit 打开差异编译模式。 5.git add –all不指定文件则会更新所有有变化的文件进缓存区。 6.git add –refresh不更新文件，仅仅进行刷新。 7.git add –ignore-errors如果某些文件由于错误无法被更新，则忽略这些错误，将其他文件进行更新。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之三——帮助与初始化命令","slug":"308Git命令集之三——帮助与初始化命令","date":"2017-02-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.364Z","comments":true,"path":"2017/02/21/308Git命令集之三——帮助与初始化命令/","link":"","permalink":"http://huishao.cc/2017/02/21/308Git命令集之三——帮助与初始化命令/","excerpt":"","text":"Git命令集之三——帮助命令1.git help –all打印所有可用的命令。 2.git help –guides打印可用的用户指南。 3.git help –man展示git命令帮助信息。 4.git init在当前目录下初始化创建一个Git仓库。 5.git init –quiet初始化仓库的时候只输出错误信息。 6.git init –bare创建Git裸库。 7.git init –template指定模板创建Git仓库。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之二——配置命令","slug":"307Git命令集之二——配置命令","date":"2017-02-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.364Z","comments":true,"path":"2017/02/20/307Git命令集之二——配置命令/","link":"","permalink":"http://huishao.cc/2017/02/20/307Git命令集之二——配置命令/","excerpt":"","text":"Git命令集之二——配置命令Git初始化的.git目录中会自动创建一个config文件，这个文件中是对Git仓库做一些个性化的配置。Git的用户配置默认会从全局文件中继承，项目的config文件可以进行覆盖与个性化修改。Git提供了许多命令来对配置文件进行增删改查操作。 1.git config –replace-all key value这个命令用来修改某个配置键值对，不添加--replace-all参数也可以进行配置键值的修改，只是对于某个键可能存在多个对应值时，添加这个参数后会全部进行修改，示例如下： 1git config --replace-all core.bare &quot;true&quot; 2.git config –add key value向配置文件中添加一个配置键，示例如下： 1git config --add core.new &quot;new&quot; 3.git config –get key查询某个配置键的值，示例如下： 1git config --get core.new 4.git config –get-all key和查询命令类似，用于一对多键值的查询。 5.git config –global 添加–global参数 对应全局的Git配置，示例如下： 1git config --global --list 6.git config –system添加--system参数 对应系统的Git配置，示例如下： 1git config --system --list 7.git config –local添加--system参数 对应项目的Git配置，示例如下： 1it config --local --list 8.git config –file 使用给定的文件作为Git配置文件。 9.git config –remove-section sectionName删除一个配置分区，示例如下： 1git config --remove-section core 10.git config –rename-section section newName修改一个配置分区的名字，示例如下： 1git config --rename-section core coor 11.git config –unset key删除一个配置键。 12.git config –unset-all删除配置的键，用于一对多键值的删除，会删除所有这个键对应的值。 13.git config –list打印配置信息。 14.git config –name-only –list 只对配置文件中的键进行打印。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"Git命令集之一——配置参数","slug":"306Git命令集之一——配置参数","date":"2017-02-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.364Z","comments":true,"path":"2017/02/17/306Git命令集之一——配置参数/","link":"","permalink":"http://huishao.cc/2017/02/17/306Git命令集之一——配置参数/","excerpt":"","text":"Git命令集之一——配置参数1.–version命令使用git –version命令可以获取当前安装个Git版本号。 2.–help命令获取Git帮助文档，信息示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142usage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches checkout Switch branches or restore working tree files commit Record changes to the repository diff Show changes between commits, commit and working tree, etc merge Join two or more development histories together rebase Reapply commits on top of another base tip tag Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects&apos;git help -a&apos; and &apos;git help -g&apos; list available subcommands and someconcept guides. See &apos;git help &lt;command&gt;&apos; or &apos;git help &lt;concept&gt;&apos;to read about a specific subcommand or concept. 3.-C 这个命令用于修改git命令执行的目录，例如在桌面执行如下命令和进入到IBox文件夹中执行status是一样的： 1git -C iBox status 4.-c =在执行git命令时，添加这样的一个参数将使用新的value值替换掉config文件中name对应的参数配置的值来执行命令，示例如下： 1git -c bare=false status 5.–exec-path打印Git主程序所在的路径。 6.–html-path打印Git文档所在路径。 7.–man-path打印Git帮助文档所在路径。 8.–info-path打印记录Git版本信息的文件路径。 9.–paginate对Git的输出进行分页，对于大量信息的打印，可以分页进行查看。 10.–no-pager对Git的输出不进行分页。 11.–git-dir=设置Git仓库的路径，默认情况下，我们都是在当前Git仓库目录内执行Git命令，有时候也可以在其他目录下对某个Git仓库进行操作，例如: 1git --git-dir=GitDemo/.git status 12.–work-tree=设置Git的工作目录，这个目录中文件变化都会记录到Git管理仓库中。 13.–namespace=设置Git的命名空间。 14.–bare将Git仓库视为裸库。","categories":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}],"tags":[],"keywords":[{"name":"GIT","slug":"GIT","permalink":"http://huishao.cc/categories/GIT/"}]},{"title":"深入理解JavaScript函数","slug":"305深入理解JavaScript函数","date":"2017-02-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.364Z","comments":true,"path":"2017/02/15/305深入理解JavaScript函数/","link":"","permalink":"http://huishao.cc/2017/02/15/305深入理解JavaScript函数/","excerpt":"","text":"深入理解JavaScript函数一、引言从功能上理解，函数是一组可以随时运行的语句，是一段代码块，也是所谓的子程序。在JavaScript中，函数实质上也是一种对象，是Function对象。函数通常会有参数与返回值(不是必须)，在JavaScript中，函数的应用十分灵活，也有多种定义函数的方法。 二、几种定义函数的方式在JavaScript中，可以通过函数语句来声明和定义函数、可以通过函数表达式来将创建函数，也可以使用Function构造方法来创建函数对象。 1、使用函数语句来定义函数JavaScript中有一种特殊的语法来直接定义函数，示例如下： 1234//使用函数语句定义函数function outputName()&#123; console.log(\"Jaki\");&#125; 函数语句有这样的结构：function name(param…){}。其中function为函数语句的关键字，name为自定义的函数名称，小括号中定义函数的形参，大括号中可以进行代码的编写。 如果仅仅对上面的代码进行运行，你会发现程序并没有执行任何行为，函数必须在调用时才会被执行，调用函数示例如下： 12345//使用函数语句定义函数function outputName()&#123; console.log(\"Jaki\");&#125;outputName();//将打印Jaki 上面的定义的函数是最简单的函数形式，函数也可以通过传入参数的差异来做不同的功能，例如修改上面的函数，使其传入姓名并且进行打印输出： 12345//使用函数语句定义函数function outputName(name)&#123; console.log(name);&#125;outputName(\"张三\");//将打印张三 函数也可以提供一个返回值，例如一个简单的加法运算函数，如下： 12345function add(a,b)&#123; return a+b;&#125;var res = add(3,4);console.log(res);//7 在JavaScript中，函数的返回值类型不需要特殊指定，直接使用return语句返回即可。需要注意，实际上任何函数都是有返回值的，如果函数体中没有使用return语句显式的进行返回，则默认会返回undefined。 JavaScript中函数的定义与使用不一定非要按照顺序进行，实际上也可以将函数的定义写在使用之后(解释器会在与处理阶段解释定义的函数)，如下： 12345var res = add(3,4);function add(a,b)&#123; return a+b;&#125;console.log(res);//7 2.使用函数表达式来定义函数使用函数表达式来定义函数与函数语句的语法十分相似，示例代码如下： 123456//使用函数表达式来定义函数var addFunc = function(a,b)&#123; return a+b; &#125;;var res = addFunc(3,3);console.log(res);//6 这种方式定义的函数实际上是创建了一个函数对象，之后将这个对象的引用赋值给了一个变量，通过变量开发者可以访问和调用函数。需要注意，函数表达式与函数语句的最大区别在于其可以省略函数名，即可以定义匿名函数，但是这种方式定义的函数在函数定义之前是不能够被调用的，这也很好理解，JavaScript解释器在预处理期间只是解析除了addFunc变量，但是并没有对其表达式进行运算，这时函数并没有被定义，例如下面的代码将报错： 12345var res = addFunc(3,3);//使用函数表达式来定义函数var addFunc = function(a,b)&#123; return a+b; &#125;; 其实函数语句与函数表达式定义的函数还有一点重大区别，函数语句定义后函数名实际上是无法修改的，而使用函数表达式定义的函数是将引用赋值给了变量，变量可以重新赋值，也可以将两个变量赋值为同一个函数对象的引用，示例如下： 12345678910//使用函数表达式来定义函数var addFunc = function(a,b)&#123; return a+b; &#125;;//将addFunc的值赋值给另一个变量var addFunc2 = addFunc;//将addFunc变量修改为整型值addFunc = 3;var res = addFunc2(3,3);console.log(res);//6 如果需要在函数内部调用函数本身，即需要定义递归函数时，函数表达式也可以进行函数命名，示例如下： 1234567891011//定义一个递归阶乘函数var mathFunc = function mathF(a)&#123; var res = a; a--; if (a&gt;0) &#123; res *= mathFunc(a); &#125; return res;&#125;;var mathRes = mathFunc(5);console.log(mathRes);//120 需要注意，函数表达式定义的函数名只能作用于函数内部。 3.使用Function构造函数前面有提到，函数在JavaScript中实际上也是一种对象，因此可以使用new关键字来进行函数对象的构造，示例如下： 123//Function构造器var myFunc = new Function(\"name\",\"console.log(name)\");myFunc(\"Jaki\");//Jaki Function构造其的格式如下：Function(param,param…,funcbody)。其中参数个数不固定，最后一个参数为创建的函数的函数体字符串，前面的参数全部都将作为函数的形参传入函数体内。 实际上，无论通过哪种方式创建的函数，其实质上都是Function对象，Function对象中也有一些内置的属性，其中最长用的为arguments属性。arguments属性是实际传入函数的参数数组，其length属性为函数所传入的参数个数，也就是说，开发者在定义函数的时候实际上可以不定义形参，在调用函数的时候直接进行实参的传入，函数内部还是可以获取到参数，JavaScript函数的对象特性使得其十分灵活，形参并不能决定函数的参数个数与类型，实参、函数体和返回值这些都可以在运行时决定！示例如下： 123456789function testFunc()&#123; console.log(arguments.length); console.log(arguments);&#125;/*3&#123; '0': '1', '1': 2, '2': 3 &#125;*/testFunc('1',2,3); 函数是功能完整的对象，实际上函数对象本身也有一个length属性，这个属性将获取到函数预期形参的个数，即可以方便的获取到函数预期需要传入的参数的个数，例如： 123456789function testFunc()&#123; console.log(arguments.length); console.log(arguments);&#125;function textFunc2(name)&#123; &#125;console.log(testFunc.length); //0console.log(textFunc2.length); //1 三、理解函数语句与函数表达式函数语句是定义函数的一种语法，而函数表达式实际上就是返回一个函数对象，因此函数表达式可以直接进行调用，请看如下代码： 123var addFuncS = function(a,b)&#123; console.log(a+b); &#125;(1,2);//3 上面的代码中的addFuncS已经不再是一个函数对象的引用，而是数值3。在函数表达式后面可以直接跟小括号传参进行函数的调用，但是如下的写法将会报错： 123function addFuncE()&#123; console.log(\"hello\");&#125;(); 在JavaScript中函数表达式十分容易被误认为是函数定义的语法，区分了上面两种情况，你会发现这是在编程过程中十分危险，JavaScript中的函数语法有如下两条规则： 1.当函数语法成为表达式的一部分时，其会被转换成为函数表达式。 2.内嵌于非函数的其他代码块中时，函数语法会被转换成函数表达式。 例子如下： 123456789//函数语法被转换成函数表达式//1.函数语法成为表达式的一部分(function f1()&#123;console.log(\"f1\")&#125;)();//2.函数语法内嵌于非函数的代码块汇总if (true) &#123; (function f2()&#123; console.log(\"f2\"); &#125;)();&#125;","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS中ImageIO框架详解与应用分析","slug":"304 iOS中ImageIO框架详解与应用分析","date":"2017-02-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.363Z","comments":true,"path":"2017/02/14/304 iOS中ImageIO框架详解与应用分析/","link":"","permalink":"http://huishao.cc/2017/02/14/304 iOS中ImageIO框架详解与应用分析/","excerpt":"","text":"iOS中ImageIO框架详解与应用分析一、引言ImageIO框架提供了读取与写入图片数据的基本方法，使用它可以直接获取到图片文件的内容数据，ImageIO框架中包含6个头文件，其中完成主要功能的是前两个头文件中定义的方法： 1.CGImageSource.h:负责读取图片数据。 2.CGImageDestination.h:负责写入图片数据。 3.CGImageMetadata.h:图片文件元数据类。 4.CGImageProperties:定义了框架中使用的字符串常量和宏。 5.ImageIOBase.h:预处理逻辑，无需关心。 二、CGImageSource详解CGImageSource类的主要作用是用来读取图片数据，在平时开发中，关于图片我们使用的最多的可能是UIImage类，UIImage是iOS系统UI系统中用于构建图像对象的类，但是其中只有图像数据，实际上一个图片文件中存储的除了图片数据外，还有一些地理位置、设备类型、时间等信息，除此之外，一个图片文件中可能存储的也不只一张图像(例如gif文件)。CGImageSource就是这样的一个抽象图片数据示例，从其中可以获取到我们所关心的所有数据。 读取图片文件数据，并将其展示在视图的简单代码示例如下： 123456789101112131415//获取图片文件路径NSString * path = [[NSBundle mainBundle]pathForResource:@\"timg\" ofType:@\"jpeg\"];NSURL * url = [NSURL fileURLWithPath:path];CGImageRef myImage = NULL;CGImageSourceRef myImageSource;//通过文件路径创建CGImageSource对象myImageSource = CGImageSourceCreateWithURL((CFURLRef)url, NULL);//获取第一张图片myImage = CGImageSourceCreateImageAtIndex(myImageSource, 0, NULL);CFRelease(myImageSource);UIImageView * image = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 200, 200)];image.image = [UIImage imageWithCGImage:myImage];[self.view addSubview:image]; 上面的示例代码采用的是本地的一个素材文件，当然通过网络图片链接也是可以创建CGImageSource独享的。除了通过URL链接的方式创建对象，ImageIO框架中还提供了两种方法，解析如下： 1234567//通过数据提供器创建CGImageSource对象/*CGDataProviderRef是CoreGraphics框架中的一个数据读取类，其也可以通过Data数据，URL和文件名来创建*/CGImageSourceRef __nullable CGImageSourceCreateWithDataProvider(CGDataProviderRef __nonnull provider, CFDictionaryRef __nullable options);//通过Data数据创建CGImageSource对象CGImageSourceRef __nullable CGImageSourceCreateWithData(CFDataRef __nonnull data, CFDictionaryRef __nullable options); 需要注意，上面所提到的所有创建CGImageSource的方法中都可以传入一个CFDictionaryRef类型的字典，可以配置的键值意义如下： 123456789101112131415161718192021222324252627282930/*设置一个预期的图片文件格式，需要设置为字符串类型的值*/const CFStringRef kCGImageSourceTypeIdentifierHint;/*设置是否以解码的方式读取图片数据 默认为kCFBooleanTrue如果设置为true，在读取数据时就进行解码 如果为false 则在渲染时才进行解码*/const CFStringRef kCGImageSourceShouldCache;/*返回CGImage对象时是否允许使用浮点值 默认为kCFBooleanFalse*/const CFStringRef kCGImageSourceShouldAllowFloa;/*设置如果不存在缩略图则创建一个缩略图，缩略图的尺寸受开发者设置影响，如果不设置尺寸极限，则为图片本身大小默认为kCFBooleanFalse*/const CFStringRef kCGImageSourceCreateThumbnailFromImageIfAbsent;/*设置是否创建缩略图，无论原图像有没有包含缩略图kCFBooleanFalse*/const CFStringRef kCGImageSourceCreateThumbnailFromImageAlways;/*设置缩略图的宽高尺寸 需要设置为CFNumber值*/const CFStringRef kCGImageSourceThumbnailMaxPixelSize;/*设置缩略图是否进行Transfrom变换*/const CFStringRef kCGImageSourceCreateThumbnailWithTransform; CGImageSource类中其他方法解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//获取CGImageSource类在CoreFundation框架中的idCFTypeID CGImageSourceGetTypeID (void);//获取所支持的图片格式数组CFArrayRef __nonnull CGImageSourceCopyTypeIdentifiers(void);//获取CGImageSource对象的图片格式CFStringRef __nullable CGImageSourceGetType(CGImageSourceRef __nonnull isrc);//获取CGImageSource中的图片张数 不包括缩略图size_t CGImageSourceGetCount(CGImageSourceRef __nonnull isrc);//获取CGImageSource的文件信息/*字典参数可配置的键值对与创建CGImageSource所传参数意义一致返回的字典中的键值意义后面介绍*/CFDictionaryRef __nullable CGImageSourceCopyProperties(CGImageSourceRef __nonnull isrc, CFDictionaryRef __nullable options);//获取CGImageSource中某个图像的附加数据/*index参数设置获取第几张图像 options参数可配置的键值对与创建CGImageSource所传参数意义一致返回的字典中的键值意义后面介绍*/CFDictionaryRef __nullable CGImageSourceCopyPropertiesAtIndex(CGImageSourceRef __nonnull isrc, size_t index, CFDictionaryRef __nullable options);//获取图片的元数据信息 CGImageMetadataRef类是图像原数据的抽象CGImageMetadataRef __nullable CGImageSourceCopyMetadataAtIndex (CGImageSourceRef __nonnull isrc, size_t index, CFDictionaryRef __nullable options);//获取CGImageSource中的图片数据CGImageRef __nullable CGImageSourceCreateImageAtIndex(CGImageSourceRef __nonnull isrc, size_t index, CFDictionaryRef __nullable options);//删除一个指定索引图像的缓存void CGImageSourceRemoveCacheAtIndex(CGImageSourceRef __nonnull isrc, size_t index);//获取某一帧图片的缩略图CGImageRef __nullable CGImageSourceCreateThumbnailAtIndex(CGImageSourceRef __nonnull isrc, size_t index, CFDictionaryRef __nullable options);//创建一个空的CGImageSource容器，逐步加载大图片CGImageSourceRef __nonnull CGImageSourceCreateIncremental(CFDictionaryRef __nullable options);//使用新的数据更新CGImageSource容器void CGImageSourceUpdateData(CGImageSourceRef __nonnull isrc, CFDataRef __nonnull data, bool final);//更新数据提供器来填充CGImageSource容器void CGImageSourceUpdateDataProvider(CGImageSourceRef __nonnull isrc, CGDataProviderRef __nonnull provider, bool final);//获取当前CGImageSource的状态/*CGImageSourceStatus枚举意义：typedef CF_ENUM(int32_t, CGImageSourceStatus) &#123; kCGImageStatusUnexpectedEOF = -5, //文件结尾出错 kCGImageStatusInvalidData = -4, //数据无效 kCGImageStatusUnknownType = -3, //未知的图片类型 kCGImageStatusReadingHeader = -2, //读标题过程中 kCGImageStatusIncomplete = -1, //操作不完整 kCGImageStatusComplete = 0 //操作完整&#125;;*/CGImageSourceStatus CGImageSourceGetStatus(CGImageSourceRef __nonnull isrc);//同上，获取某一个图片的状态CGImageSourceStatus CGImageSourceGetStatusAtIndex(CGImageSourceRef __nonnull isrc, size_t index); 三、CGImageDestination详解CGImageSource是图片文件数据的抽象对象，而CGImageDestination的作用则是将抽象的图片数据写入指定的目标中。将图片写成文件示例如下： 123456789101112131415//创建存储路径NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES);NSString *newPath = [paths.firstObject stringByAppendingPathComponent:[NSString stringWithFormat:@\"image.png\"]];CFURLRef URL = CFURLCreateWithFileSystemPath ( kCFAllocatorDefault, (CFStringRef)newPath, kCFURLPOSIXPathStyle, false);//创建CGImageDestination对象CGImageDestinationRef myImageDest = CGImageDestinationCreateWithURL(URL,CFSTR(\"public.png\"), 1, NULL);UIImage * image = [UIImage imageNamed:@\"timg.jpeg\"];//写入图片CGImageDestinationAddImage(myImageDest, image.CGImage, NULL);CGImageDestinationFinalize(myImageDest);CFRelease(myImageDest); 同样，除了可以直接将图片数据写入url外，也可以Data数据或数据消费器，方法如下： 1234//将图片数据写入数据消费者CGImageDestinationRef __nullable CGImageDestinationCreateWithDataConsumer(CGDataConsumerRef __nonnull consumer, CFStringRef __nonnull type, size_t count, CFDictionaryRef __nullable options);//将图片数据写入DataCGImageDestinationRef __nullable CGImageDestinationCreateWithData(CFMutableDataRef __nonnull data, CFStringRef __nonnull type, size_t count, CFDictionaryRef __nullable options); 需要注意，上面方法的type参数设置写入数据的文件格式，必须为ImageIO框架所支持的格式，前面有方法可以获取所有支持的格式，还有一点，这3个写入方法的中options参数目前并没有什么作用，其是留给未来使用的，目前传入NULL即可。 CGImageDestination类中的其他方法解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//获取CGImageDestination的CFTypeIDCFTypeID CGImageDestinationGetTypeID(void);//获取CGImageDestination所支持的图片文件类型/*目前支持如下：iOS10.1 ( \"public.jpeg\", \"public.png\", \"com.compuserve.gif\", \"public.tiff\", \"public.jpeg-2000\", \"com.microsoft.ico\", \"com.microsoft.bmp\", \"com.adobe.photoshop-image\", \"com.adobe.pdf\", \"com.truevision.tga-image\", \"com.ilm.openexr-image\", \"public.pbm\", \"public.pvr\", \"org.khronos.astc\", \"org.khronos.ktx\", \"com.microsoft.dds\", \"com.apple.rjpeg\")*/CFArrayRef __nonnull CGImageDestinationCopyTypeIdentifiers(void);//设置图片文件属性/*可以设置的键值对意义如下：const CFStringRef kCGImageDestinationLossyCompressionQuality; //设置压缩质量 0-1之间的cfnumberref值const CFStringRef kCGImageDestinationBackgroundColor; //将图片数据写为无alpha通道时的默认背景色 cgcolor值*/void CGImageDestinationSetProperties(CGImageDestinationRef __nonnull idst, CFDictionaryRef __nullable properties);//向CGImageDestination中添加一张图片 其中的option参数意义和上面一致，设置此图片的质量与无alpha默认背景色void CGImageDestinationAddImage(CGImageDestinationRef __nonnull idst, CGImageRef __nonnull image, CFDictionaryRef __nullable properties);//通过CGImageSource对象来向CGImageDestination中添加图片void CGImageDestinationAddImageFromSource(CGImageDestinationRef __nonnull idst, CGImageSourceRef __nonnull isrc, size_t index, CFDictionaryRef __nullable properties);//进行写入操作 执行此方法后 不可以在写入其他信息bool CGImageDestinationFinalize(CGImageDestinationRef __nonnull idst);//添加图片元信息void CGImageDestinationAddImageAndMetadata(CGImageDestinationRef __nonnull idst, CGImageRef __nonnull image, CGImageMetadataRef __nullable metadata, CFDictionaryRef __nullable options);//将CGImageSource信息拷贝进CGImageDestination/*options参数可以用来添加元信息*/bool CGImageDestinationCopyImageSource(CGImageDestinationRef __nonnull idst, CGImageSourceRef __nonnull isrc, CFDictionaryRef __nullable options, __nullable CFErrorRef * __nullable err); 上面列举的方法中，CGImageDestinationCopyImageSource()方法中的options参数可以添加一些图片的元信息，可以设置的键值对意义如下： 123456789101112//设置元信息 需要设置为CGImageMetadataRef对象const CFStringRef kCGImageDestinationMetadata;//是否将CGImageSource的元信息信息合并操作 默认为kCFBooleanFalseconst CFStringRef kCGImageDestinationMergeMetadata;//XMP数据是否不被写入 默认为kCFBooleanFalseconst CFStringRef kCGImageMetadataShouldExcludeXMP;//GPS信息是否不被写入 默认为kCFBooleanFalseconst CFStringRef kCGImageMetadataShouldExcludeGPS;//更新元数据的时间值 需要设置为CFStringRef或者CFDateRefconst CFStringRef kCGImageDestinationDateTime;//更新元数据的方向值 需要设置为NSNumber1-8const CFStringRef kCGImageDestinationOrientation; 四、关于CGImageMetadata前面我们很多次提到元数据，CGImageMetadata类就是元数据的抽象，其中封装了一些方法供开发者读取或写入元数据信息。奇怪的是Apple的官方文档与API文档中并没有CGImageMetadata的介绍与解释，博客中本部分的内容，多出自我的理解，有疏漏和不对的地方，清楚的朋友可以指点与建议。 前边介绍，CGImageSource中有获取图片元数据的方法，CGImageDestination中也有写入图片元数据的方法，元数据中抽象出的CGImageMetadataTag是对具体数据内容的封装。CGImageMetadata解析如下： 123456789101112131415161718//获取CGImageMetadata类的CFTypeIDCFTypeID CGImageMetadataGetTypeID(void);//创建一个空的可变的CGImageMetadata对象CGMutableImageMetadataRef __nonnull CGImageMetadataCreateMutable(void);//拷贝一个可变的CGImageMetadata对象CGMutableImageMetadataRef __nullable CGImageMetadataCreateMutableCopy(CGImageMetadataRef __nonnull metadata);//获取CGImageMetadataTag类的CFTypeIDCFTypeID CGImageMetadataTagGetTypeID(void);//创建一个CGImageMetadataTag对象/*这个方法比较复杂xmlns参数设置命名空间prefix参数设置命名空间的缩写或前缀name参数设置CGImageMetadataTag的名称type参数设置CGImageMetadataTag对应值的类型value参数设置CGImageMetadataTag的对应值*/CGImageMetadataTagRef __nullable CGImageMetadataTagCreate (CFStringRef __nonnull xmlns, CFStringRef __nullable prefix, CFStringRef __nonnull name, CGImageMetadataType type, CFTypeRef __nonnull value); 上面创建CGImageMetadataTag的方法中，xmlns设置命名空间，必须使用一个预定义的命名空间或者自定义的命名空间，对于自定义的命名空间，必须遵守Adobe的XMP规范。一些共用的命名空间定义如下： 123456789101112131415161718//Exif命名空间const CFStringRef kCGImageMetadataNamespaceExif;//ExifAux命名空间const CFStringRef kCGImageMetadataNamespaceExifAux;//ExifEX命名空间const CFStringRef kCGImageMetadataNamespaceExifEX;//DublineCore命名空间const CFStringRef kCGImageMetadataNamespaceDublinCore;//IPTCCore命名空间const CFStringRef kCGImageMetadataNamespaceIPTCCore;//Photoshop命名空间const CFStringRef kCGImageMetadataNamespacePhotoshop;//TIFF命名空间const CFStringRef kCGImageMetadataNamespaceTIFF;//XMPBasic命名空间const CFStringRef kCGImageMetadataNamespaceXMPBasic;//XMPRights命名空间const CFStringRef kCGImageMetadataNamespaceXMPRights; 上面创建CGImageMetadataTag的方法中prefix设置命名空间缩写或前缀，同样一些公用的前缀定义如下： 123456789101112131415161718//Exif命名空间前缀const CFStringRef kCGImageMetadataPrefixExif;//ExifAux命名空间前缀const CFStringRef kCGImageMetadataPrefixExifAux;//ExifEX命名空间前缀const CFStringRef kCGImageMetadataPrefixExifEX;//DublinCore命名空间前缀const CFStringRef kCGImageMetadataPrefixDublinCore;//IPCCore命名空间前缀const CFStringRef kCGImageMetadataPrefixIPTCCore;//Photoshop命名空间前缀const CFStringRef kCGImageMetadataPrefixPhotoshop;//TIFF命名空间前缀const CFStringRef kCGImageMetadataPrefixTIFF;//XMPBasic命名空间前缀const CFStringRef kCGImageMetadataPrefixXMPBasic;//XMPRights命名空间前缀const CFStringRef kCGImageMetadataPrefixXMPRights; 上面创建CGImageMetadataTag的方法中type设置对应值的类型，其是一个CGImageMetadataType类型的枚举，意义如下： 123456789101112131415161718typedef CF_ENUM(int32_t, CGImageMetadataType) &#123; //无效的数据类型 kCGImageMetadataTypeInvalid = -1, //基本的CFType类型 kCGImageMetadataTypeDefault = 0, //字符串类型 kCGImageMetadataTypeString = 1, //无需集合类型 kCGImageMetadataTypeArrayUnordered = 2, //有序集合类型 kCGImageMetadataTypeArrayOrdered = 3, //有序阵列 kCGImageMetadataTypeAlternateArray = 4, //特殊的数组 其中元素进行不同的本地化 kCGImageMetadataTypeAlternateText = 5, //结构类型 如字典 kCGImageMetadataTypeStructure = 6&#125;; 获取到CGImageMetadataTag后，可以通过如下方法来获取其中封装的信息： 123456789101112//获取标签的命名空间CFStringRef __nullable CGImageMetadataTagCopyNamespace(CGImageMetadataTagRef __nonnull tag);//获取标签的命名空间前缀CFStringRef __nullable CGImageMetadataTagCopyPrefix(CGImageMetadataTagRef __nonnull tag);//获取标签名称CFStringRef __nullable CGImageMetadataTagCopyName(CGImageMetadataTagRef __nonnull tag);//获取标签的值CFTypeRef __nullable CGImageMetadataTagCopyValue(CGImageMetadataTagRef __nonnull tag);//获取标签值的类型CGImageMetadataType CGImageMetadataTagGetType(CGImageMetadataTagRef __nonnull tag);//获取标签的Qualifier数组CFArrayRef __nullable CGImageMetadataTagCopyQualifiers(CGImageMetadataTagRef __nonnull tag); 下面这些方法用于向CGImageMetadata中添加标签或者获取标签： 12345678910111213141516//获取CGImageMetadata中的所有标签CFArrayRef __nullable CGImageMetadataCopyTags(CGImageMetadataRef __nonnull metadata);//通过路径查找特殊的标签CGImageMetadataTagRef __nullable CGImageMetadataCopyTagWithPath(CGImageMetadataRef __nonnull metadata, CGImageMetadataTagRef __nullable parent, CFStringRef __nonnull path);//通过路径查找特殊标签的值 CFStringRef __nullable CGImageMetadataCopyStringValueWithPath(CGImageMetadataRef __nonnull metadata, CGImageMetadataTagRef __nullable parent, CFStringRef __nonnull path);//为一个前缀注册一个命名空间bool CGImageMetadataRegisterNamespaceForPrefix(CGMutableImageMetadataRef __nonnull metadata, CFStringRef __nonnull xmlns, CFStringRef __nonnull prefix, __nullable CFErrorRef * __nullable err);//通过路径为CGImageMetadata设置标签bool CGImageMetadataSetTagWithPath(CGMutableImageMetadataRef __nonnull metadata, CGImageMetadataTagRef __nullable parent, CFStringRef __nonnull path, CGImageMetadataTagRef __nonnull tag);//通过路径为CGImageMetadata设置标签的值bool CGImageMetadataSetValueWithPath(CGMutableImageMetadataRef __nonnull metadata, CGImageMetadataTagRef __nullable parent, CFStringRef __nonnull path, CFTypeRef __nonnull value);//通过路径移除一个标签bool CGImageMetadataRemoveTagWithPath(CGMutableImageMetadataRef __nonnull metadata, CGImageMetadataTagRef __nullable parent, CFStringRef __nonnull path);//对标签进行枚举void CGImageMetadataEnumerateTagsUsingBlock(CGImageMetadataRef __nonnull metadata, CFStringRef __nullable rootPath, CFDictionaryRef __nullable options, CGImageMetadataTagBlock __nonnull block); 五、CGImageProperties中定义的字典意义前面提到的CGImageSourceCopyProperties方法与CGImageSourceCopyPropertiesAtIndex方法都会返回一个字典，字典中可能包含如下有意义的键： 12345678910111213141516171819202122232425262728293031323334353637383940//TIFF信息字典const CFStringRef kCGImagePropertyTIFFDictionary;/GIF信息字典const CFStringRef kCGImagePropertyGIFDictionary;//JFIF信息字典const CFStringRef kCGImagePropertyJFIFDictionary;//EXif信息字典const CFStringRef kCGImagePropertyExifDictionary;//PNG信息字典const CFStringRef kCGImagePropertyPNGDictionary;//IPTC信息字典const CFStringRef kCGImagePropertyIPTCDictionary;//GPS信息字典const CFStringRef kCGImagePropertyGPSDictionary;//原始信息字典const CFStringRef kCGImagePropertyRawDictionary;//CIFF信息字典const CFStringRef kCGImagePropertyCIFFDictionary;//佳能相机信息字典const CFStringRef kCGImagePropertyMakerCanonDictionary;//尼康相机信息字典const CFStringRef kCGImagePropertyMakerNikonDictionary;//柯尼卡相机信息字典const CFStringRef kCGImagePropertyMakerMinoltaDictionary;//富士相机信息字典const CFStringRef kCGImagePropertyMakerFujiDictionary;//奥林巴斯相机信息字典const CFStringRef kCGImagePropertyMakerOlympusDictionary;//宾得相机信息字典const CFStringRef kCGImagePropertyMakerPentaxDictionary;//对应Photoshop相片的信息字典const CFStringRef kCGImageProperty8BIMDictionary;//NDG信息字典const CFStringRef kCGImagePropertyDNGDictionary ;//ExifAux信息字典const CFStringRef kCGImagePropertyExifAuxDictionary;//OpenEXR信息字典const CFStringRef kCGImagePropertyOpenEXRDictionary;//Apple相机信息字典const CFStringRef kCGImagePropertyMakerAppleDictionary ; CGImageSourceCopyProperties方法返回的字典中还可能会有如下一个特殊的键： 12//对应文件大小const CFStringRef kCGImagePropertyFileSize; CGImageSourceCopyPropertiesAtIndex方法中可能包含的特殊键： 123456789101112131415161718192021222324252627282930313233//像素高度const CFStringRef kCGImagePropertyPixelHeight;//像素宽度const CFStringRef kCGImagePropertyPixelWidth;//DPI高度const CFStringRef kCGImagePropertyDPIHeight;//DPI宽度const CFStringRef kCGImagePropertyDPIWidth;//颜色位数const CFStringRef kCGImagePropertyDepth;//图片的显示方向/*对应Number值 * 1 = 左上到右下. * 2 = 右上到左下. * 3 = 右下到左上. * 4 = 左下到右上. * 5 = 行列置换 左上到右下. * 6 = 行列置换 右上到左下. * 7 = 行列置换 右下到左上. * 8 = 行列置换 左下到右上.*/const CFStringRef kCGImagePropertyOrientation;//颜色是否支持浮点数const CFStringRef kCGImagePropertyIsFloat;//图像是否包含像素样本const CFStringRef kCGImagePropertyIsIndexed;//图像是否包含alpha通道const CFStringRef kCGImagePropertyHasAlpha;//图像的颜色模式const CFStringRef kCGImagePropertyColorModel;//嵌入图片的ICC配置文件名称const CFStringRef kCGImagePropertyProfileName; kCGImagePropertyColorModel键可返回的值有如下几种定义： 12345678//RBG模式const CFStringRef kCGImagePropertyColorModelRGB;//Gray模式const CFStringRef kCGImagePropertyColorModelGray;//CMYK模式const CFStringRef kCGImagePropertyColorModelCMYK;//Lab模式const CFStringRef kCGImagePropertyColorModelLab; kCGImagePropertyTIFFDictionary键可返回的值定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940//图片数据压缩方案const CFStringRef kCGImagePropertyTIFFCompression;//图片数据的色彩空间const CFStringRef kCGImagePropertyTIFFPhotometricInterpretation;//文档名称const CFStringRef kCGImagePropertyTIFFDocumentName;//图片描述const CFStringRef kCGImagePropertyTIFFImageDescription;//相机设备名const CFStringRef kCGImagePropertyTIFFMake;//相机设备模式const CFStringRef kCGImagePropertyTIFFModel;//图片方向const CFStringRef kCGImagePropertyTIFFOrientation;//横向每个分辨位的像素数const CFStringRef kCGImagePropertyTIFFXResolution;//纵向每个分辨位的像素数const CFStringRef kCGImagePropertyTIFFYResolution;//分辨率单位const CFStringRef kCGImagePropertyTIFFResolutionUnit;//创建图像的软件名称和版本const CFStringRef kCGImagePropertyTIFFSoftware;//transform函数const CFStringRef kCGImagePropertyTIFFTransferFunction;//日期时间const CFStringRef kCGImagePropertyTIFFDateTime;//作者const CFStringRef kCGImagePropertyTIFFArtist;//创建图片的电脑系统const CFStringRef kCGImagePropertyTIFFHostComputer;//公司信息const CFStringRef kCGImagePropertyTIFFCopyright;//图片的白点const CFStringRef kCGImagePropertyTIFFWhitePoint;//图像的原色色度const CFStringRef kCGImagePropertyTIFFPrimaryChromaticities;//图片的瓦片宽度const CFStringRef kCGImagePropertyTIFFTileWidth;//图片的瓦片高度const CFStringRef kCGImagePropertyTIFFTileLength; kCGImagePropertyJFIFDictionary对应的字典中可能包含如下意义的键： 12345678910//JFIF版本const CFStringRef kCGImagePropertyJFIFVersion;//横向像素密度const CFStringRef kCGImagePropertyJFIFXDensity;//纵向像素密度const CFStringRef kCGImagePropertyJFIFYDensity;//像素密度单元const CFStringRef kCGImagePropertyJFIFDensityUnit;//是否是高质量图像版本const CFStringRef kCGImagePropertyJFIFIsProgressive; kCGImagePropertyExifDictionary对应的字典中可能包含如下意义的键 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//曝光时间const CFStringRef kCGImagePropertyExifExposureTime;//ExifNumberconst CFStringRef kCGImagePropertyExifFNumber;//曝光程序const CFStringRef kCGImagePropertyExifExposureProgram;//每个通道的光谱灵敏度const CFStringRef kCGImagePropertyExifSpectralSensitivity;//ISO速度等级const CFStringRef kCGImagePropertyExifISOSpeedRatings;//ExifOECFconst CFStringRef kCGImagePropertyExifOECF;//灵敏类型const CFStringRef kCGImagePropertyExifSensitivityType;//输出灵敏标准const CFStringRef kCGImagePropertyExifStandardOutputSensitivity;//推荐曝光指数const CFStringRef kCGImagePropertyExifRecommendedExposureIndex;//ISO速率const CFStringRef kCGImagePropertyExifISOSpeed;const CFStringRef kCGImagePropertyExifISOSpeedLatitudeyyy;const CFStringRef kCGImagePropertyExifISOSpeedLatitudezzz;//Exif版本const CFStringRef kCGImagePropertyExifVersion;//原始日期时间const CFStringRef kCGImagePropertyExifDateTimeOriginal;//数字化日期时间const CFStringRef kCGImagePropertyExifDateTimeDigitized;//压缩配置const CFStringRef kCGImagePropertyExifComponentsConfiguration;//压缩模式像素位const CFStringRef kCGImagePropertyExifCompressedBitsPerPixel;//快门速度值const CFStringRef kCGImagePropertyExifShutterSpeedValue;//孔径值const CFStringRef kCGImagePropertyExifApertureValue;//亮度值const CFStringRef kCGImagePropertyExifBrightnessValue;//曝光偏差值const CFStringRef kCGImagePropertyExifExposureBiasValue;//最大光圈值const CFStringRef kCGImagePropertyExifMaxApertureValue;//距离const CFStringRef kCGImagePropertyExifSubjectDistance;//测光模式const CFStringRef kCGImagePropertyExifMeteringMode;//光源const CFStringRef kCGImagePropertyExifLightSource;//拍摄时的闪光状态const CFStringRef kCGImagePropertyExifFlash;//焦距const CFStringRef kCGImagePropertyExifFocalLength;//主体区域const CFStringRef kCGImagePropertyExifSubjectArea;//相机制造商指定的信息const CFStringRef kCGImagePropertyExifMakerNote;//用户信息const CFStringRef kCGImagePropertyExifUserComment;//日期和时间标记的秒分数const CFStringRef kCGImagePropertyExifSubsecTime;//原始时间const CFStringRef kCGImagePropertyExifSubsecTimeOriginal;//数字时间const CFStringRef kCGImagePropertyExifSubsecTimeDigitized;//FlashPix版本信息const CFStringRef kCGImagePropertyExifFlashPixVersion;//色彩空间const CFStringRef kCGImagePropertyExifColorSpace;//X方向像素const CFStringRef kCGImagePropertyExifPixelXDimension;//Y方向像素const CFStringRef kCGImagePropertyExifPixelYDimension;//与图像相关的声音文件const CFStringRef kCGImagePropertyExifRelatedSoundFile;//FlashEnergyconst CFStringRef kCGImagePropertyExifFlashEnergy;//FrequencyResponseconst CFStringRef kCGImagePropertyExifSpatialFrequencyResponse;//像素数目const CFStringRef kCGImagePropertyExifFocalPlaneXResolution;const CFStringRef kCGImagePropertyExifFocalPlaneYResolution;const CFStringRef kCGImagePropertyExifFocalPlaneResolutionUnit;//图像主体的位置const CFStringRef kCGImagePropertyExifSubjectLocation;//选择的曝光指数const CFStringRef kCGImagePropertyExifExposureIndex;//传感器类型const CFStringRef kCGImagePropertyExifSensingMethod;//图像文件源const CFStringRef kCGImagePropertyExifFileSource;//场景类型const CFStringRef kCGImagePropertyExifSceneType;//CFA模块const CFStringRef kCGImagePropertyExifCFAPattern;//对图像数据进行特殊渲染const CFStringRef kCGImagePropertyExifCustomRendered;//曝光模式设置const CFStringRef kCGImagePropertyExifExposureMode;//白平衡模式const CFStringRef kCGImagePropertyExifWhiteBalance;//数字变焦比const CFStringRef kCGImagePropertyExifDigitalZoomRatio;//35毫米胶片的等效焦距const CFStringRef kCGImagePropertyExifFocalLenIn35mmFilm;//场景捕捉类型（标准，景观，肖像，夜晚）const CFStringRef kCGImagePropertyExifSceneCaptureType;//图像增益const CFStringRef kCGImagePropertyExifGainControl;//图像对比度const CFStringRef kCGImagePropertyExifContrast;//图像饱和度const CFStringRef kCGImagePropertyExifSaturation;//图像锐度const CFStringRef kCGImagePropertyExifSharpness;//拍摄条件const CFStringRef kCGImagePropertyExifDeviceSettingDescription;//主体距离const CFStringRef kCGImagePropertyExifSubjectDistRange;//图像的唯一标识const CFStringRef kCGImagePropertyExifImageUniqueID;//相机所有者const CFStringRef kCGImagePropertyExifCameraOwnerName;//相机序列号const CFStringRef kCGImagePropertyExifBodySerialNumber;//透镜规格信息const CFStringRef kCGImagePropertyExifLensSpecification;//透镜制造商名称const CFStringRef kCGImagePropertyExifLensMake;//透镜模式const CFStringRef kCGImagePropertyExifLensModel;//透镜序列号const CFStringRef kCGImagePropertyExifLensSerialNumber;//伽马设置const CFStringRef kCGImagePropertyExifGamma; kCGImagePropertyExifAuxDictionary对应的字典中可能包含的键定义如下： 123456789101112131415161718//镜头信息const CFStringRef kCGImagePropertyExifAuxLensInfo;//镜头模式const CFStringRef kCGImagePropertyExifAuxLensModel;//序列号const CFStringRef kCGImagePropertyExifAuxSerialNumber;//镜头IDconst CFStringRef kCGImagePropertyExifAuxLensID;//镜头序列号const CFStringRef kCGImagePropertyExifAuxLensSerialNumber;//图片编号const CFStringRef kCGImagePropertyExifAuxImageNumber;//闪光补偿const CFStringRef kCGImagePropertyExifAuxFlashCompensation;//所有者名称const CFStringRef kCGImagePropertyExifAuxOwnerName;//固件信息const CFStringRef kCGImagePropertyExifAuxFirmware; kCGImagePropertyGIFDictionary对应的字典中可能包含的键定义如下： 123456789//动画循环次数const CFStringRef kCGImagePropertyGIFLoopCount;//两帧之间的延时const CFStringRef kCGImagePropertyGIFDelayTime;//颜色Mapconst CFStringRef kCGImagePropertyGIFImageColorMap;const CFStringRef kCGImagePropertyGIFHasGlobalColorMap;//两帧之间的延时const CFStringRef kCGImagePropertyGIFUnclampedDelayTime; kCGImagePropertyPNGDictionary对应的字典中可能包含的键定义如下： 12345678910111213141516171819202122232425262728293031//PNG伽马值const CFStringRef kCGImagePropertyPNGGamma;//混合类型const CFStringRef kCGImagePropertyPNGInterlaceType;//X方向像素数const CFStringRef kCGImagePropertyPNGXPixelsPerMeter;//Y方向像素数const CFStringRef kCGImagePropertyPNGYPixelsPerMeter;//RGB意图const CFStringRef kCGImagePropertyPNGsRGBIntent;//色度const CFStringRef kCGImagePropertyPNGChromaticities;//作者const CFStringRef kCGImagePropertyPNGAuthor;//公司const CFStringRef kCGImagePropertyPNGCopyright;//创建时间const CFStringRef kCGImagePropertyPNGCreationTime;//描述const CFStringRef kCGImagePropertyPNGDescription;//最后修改日期时间const CFStringRef kCGImagePropertyPNGModificationTime;//软件const CFStringRef kCGImagePropertyPNGSoftware;//标题const CFStringRef kCGImagePropertyPNGTitle;//动画循环次数const CFStringRef kCGImagePropertyAPNGLoopCount;//两帧之间的延时const CFStringRef kCGImagePropertyAPNGDelayTime;const CFStringRef kCGImagePropertyAPNGUnclampedDelayTime; kCGImagePropertyGPSDictionary对应的字典中可能包含的键定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//GPS版本const CFStringRef kCGImagePropertyGPSVersion;//纬度是南纬或北纬const CFStringRef kCGImagePropertyGPSLatitudeRef;//纬度const CFStringRef kCGImagePropertyGPSLatitude;//经度是东经或西经const CFStringRef kCGImagePropertyGPSLongitudeRef;//经度const CFStringRef kCGImagePropertyGPSLongitude;//海拔标准const CFStringRef kCGImagePropertyGPSAltitudeRef;//海拔高度const CFStringRef kCGImagePropertyGPSAltitude;//时间戳const CFStringRef kCGImagePropertyGPSTimeStamp;//测量GPS的卫星const CFStringRef kCGImagePropertyGPSSatellites;//GPS状态const CFStringRef kCGImagePropertyGPSStatus;//测量模式const CFStringRef kCGImagePropertyGPSMeasureMode;//精度数据const CFStringRef kCGImagePropertyGPSDOP;//速度标准const CFStringRef kCGImagePropertyGPSSpeedRef;//速度const CFStringRef kCGImagePropertyGPSSpeed;//运动方向参考const CFStringRef kCGImagePropertyGPSTrackRef;//运动方向const CFStringRef kCGImagePropertyGPSTrack;//位置方向参考const CFStringRef kCGImagePropertyGPSImgDirectionRef;//位置方向const CFStringRef kCGImagePropertyGPSImgDirection;//地图测量数据const CFStringRef kCGImagePropertyGPSMapDatum;//地理纬度南纬或北纬const CFStringRef kCGImagePropertyGPSDestLatitudeRef;//地理纬度const CFStringRef kCGImagePropertyGPSDestLatitude;//地理经度 东经或西经const CFStringRef kCGImagePropertyGPSDestLongitudeRef;//地理经度const CFStringRef kCGImagePropertyGPSDestLongitude;//方位参照const CFStringRef kCGImagePropertyGPSDestBearingRef;//地理方位const CFStringRef kCGImagePropertyGPSDestBearing;//距离参照const CFStringRef kCGImagePropertyGPSDestDistanceRef;//距离const CFStringRef kCGImagePropertyGPSDestDistance;//查找地理位置的方法const CFStringRef kCGImagePropertyGPSProcessingMethod;//GPS地区名const CFStringRef kCGImagePropertyGPSAreaInformation;//日期时间const CFStringRef kCGImagePropertyGPSDateStamp;//校正信息const CFStringRef kCGImagePropertyGPSDifferental;//错误信息const CFStringRef kCGImagePropertyGPSHPositioningError; kCGImagePropertyIPTCDictionary对应的字典中可能包含的键定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//对象类型const CFStringRef kCGImagePropertyIPTCObjectTypeReference;//对象属性const CFStringRef kCGImagePropertyIPTCObjectAttributeReference;//对象名称const CFStringRef kCGImagePropertyIPTCObjectName;//编辑状态const CFStringRef kCGImagePropertyIPTCEditStatus;//更新状态const CFStringRef kCGImagePropertyIPTCEditorialUpdate;//紧急等级const CFStringRef kCGImagePropertyIPTCUrgency;//主体const CFStringRef kCGImagePropertyIPTCSubjectReference;//类别const CFStringRef kCGImagePropertyIPTCCategory;//补充类别const CFStringRef kCGImagePropertyIPTCSupplementalCategory;//Fixture标识const CFStringRef kCGImagePropertyIPTCFixtureIdentifier;//关键字const CFStringRef kCGImagePropertyIPTCKeywords;//内容定位码const CFStringRef kCGImagePropertyIPTCContentLocationCode;//内容位置名称const CFStringRef kCGImagePropertyIPTCContentLocationName;//图像使用的最早日期const CFStringRef kCGImagePropertyIPTCReleaseDate;//图像使用的最早时间const CFStringRef kCGImagePropertyIPTCReleaseTime;//最后一次使用日期const CFStringRef kCGImagePropertyIPTCExpirationDate;//最后一次使用时间const CFStringRef kCGImagePropertyIPTCExpirationTime;//图像使用的特别说明const CFStringRef kCGImagePropertyIPTCSpecialInstructions;//建议行为const CFStringRef kCGImagePropertyIPTCActionAdvised;//服务参考const CFStringRef kCGImagePropertyIPTCReferenceService;//日期参考const CFStringRef kCGImagePropertyIPTCReferenceDate;//参考码const CFStringRef kCGImagePropertyIPTCReferenceNumber;//创建日期const CFStringRef kCGImagePropertyIPTCDateCreated;//创建时间const CFStringRef kCGImagePropertyIPTCTimeCreated;//数字创建日期const CFStringRef kCGImagePropertyIPTCDigitalCreationDate;//数字创建时间const CFStringRef kCGImagePropertyIPTCDigitalCreationTime;//原始程序const CFStringRef kCGImagePropertyIPTCOriginatingProgram;//程序版本const CFStringRef kCGImagePropertyIPTCProgramVersion;图像的编辑周期（早晨，晚上或两者）。const CFStringRef kCGImagePropertyIPTCObjectCycle;//不想创建者名称const CFStringRef kCGImagePropertyIPTCByline;//图像创建标题const CFStringRef kCGImagePropertyIPTCBylineTitle;//城市信息const CFStringRef kCGImagePropertyIPTCCity;//城市内位置const CFStringRef kCGImagePropertyIPTCSubLocation;//省份const CFStringRef kCGImagePropertyIPTCProvinceState;//国家编码const CFStringRef kCGImagePropertyIPTCCountryPrimaryLocationCode;//国家名称const CFStringRef kCGImagePropertyIPTCCountryPrimaryLocationName;//OriginalTransmission参考const CFStringRef kCGImagePropertyIPTCOriginalTransmissionReference;//图像内容摘要const CFStringRef kCGImagePropertyIPTCHeadline;//提供图像服务的名称const CFStringRef kCGImagePropertyIPTCCredit;//图像源const CFStringRef kCGImagePropertyIPTCSource;//公司提示const CFStringRef kCGImagePropertyIPTCCopyrightNotice;//联系人const CFStringRef kCGImagePropertyIPTCContact;//描述const CFStringRef kCGImagePropertyIPTCCaptionAbstract;//图像编辑者const CFStringRef kCGImagePropertyIPTCWriterEditor;//图像类型const CFStringRef kCGImagePropertyIPTCImageType;//方向信息const CFStringRef kCGImagePropertyIPTCImageOrientation;//语言信息const CFStringRef kCGImagePropertyIPTCLanguageIdentifier;//星级const CFStringRef kCGImagePropertyIPTCStarRating;//联系人详细信息const CFStringRef kCGImagePropertyIPTCCreatorContactInfo;//图像使用权限const CFStringRef kCGImagePropertyIPTCRightsUsageTerms;//场景代码const CFStringRef kCGImagePropertyIPTCScene; 上面的kCGImagePropertyIPTCCreatorContactInfo对应的字典中键的定义如下： 12345678910111213141516//联系人城市const CFStringRef kCGImagePropertyIPTCContactInfoCity;//联系人国家const CFStringRef kCGImagePropertyIPTCContactInfoCountry;//联系人地址const CFStringRef kCGImagePropertyIPTCContactInfoAddress;//邮编const CFStringRef kCGImagePropertyIPTCContactInfoPostalCode;//省份const CFStringRef kCGImagePropertyIPTCContactInfoStateProvince;//电子邮件const CFStringRef kCGImagePropertyIPTCContactInfoEmails;//电话const CFStringRef kCGImagePropertyIPTCContactInfoPhones;//网址const CFStringRef kCGImagePropertyIPTCContactInfoWebURLs; kCGImageProperty8BIMDictionary对应的字典中可能包含的键定义如下： 1234//Photoshop文件的图层名const CFStringRef kCGImageProperty8BIMLayerNames;//版本const CFStringRef kCGImageProperty8BIMVersion; kCGImagePropertyDNGDictionary对应的字典中可能包含的键定义如下： 12345678910111213141516171819202122232425262728293031323334//DNG版本const CFStringRef kCGImagePropertyDNGVersion;//兼容的最老版本const CFStringRef kCGImagePropertyDNGBackwardVersion;//摄像机模型const CFStringRef kCGImagePropertyDNGUniqueCameraModel;const CFStringRef kCGImagePropertyDNGLocalizedCameraModel;//相机序列码const CFStringRef kCGImagePropertyDNGCameraSerialNumber;//镜头信息const CFStringRef kCGImagePropertyDNGLensInfo;//黑度等级const CFStringRef kCGImagePropertyDNGBlackLevel;//白度等级const CFStringRef kCGImagePropertyDNGWhiteLevel;const CFStringRef kCGImagePropertyDNGCalibrationIlluminant1;const CFStringRef kCGImagePropertyDNGCalibrationIlluminant2;const CFStringRef kCGImagePropertyDNGColorMatrix1;const CFStringRef kCGImagePropertyDNGColorMatrix2;const CFStringRef kCGImagePropertyDNGCameraCalibration1;const CFStringRef kCGImagePropertyDNGCameraCalibration2;const CFStringRef kCGImagePropertyDNGAsShotNeutral;const CFStringRef kCGImagePropertyDNGAsShotWhiteXY;const CFStringRef kCGImagePropertyDNGBaselineExposure;const CFStringRef kCGImagePropertyDNGBaselineNoise;const CFStringRef kCGImagePropertyDNGBaselineSharpness;const CFStringRef kCGImagePropertyDNGPrivateData;const CFStringRef kCGImagePropertyDNGCameraCalibrationSignature;const CFStringRef kCGImagePropertyDNGProfileCalibrationSignature;const CFStringRef kCGImagePropertyDNGNoiseProfile;const CFStringRef kCGImagePropertyDNGWarpRectilinear;const CFStringRef kCGImagePropertyDNGWarpFisheye;const CFStringRef kCGImagePropertyDNGFixVignetteRadial; kCGImagePropertyCIFFDictionary对应的字典中可能包含的键定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//相机信息const CFStringRef kCGImagePropertyCIFFDescription;//固件版本const CFStringRef kCGImagePropertyCIFFFirmware;//所有者名称const CFStringRef kCGImagePropertyCIFFOwnerName;//图片名const CFStringRef kCGImagePropertyCIFFImageName;//图片文件名const CFStringRef kCGImagePropertyCIFFImageFileName;//曝光方式const CFStringRef kCGImagePropertyCIFFReleaseMethod;//曝光时间const CFStringRef kCGImagePropertyCIFFReleaseTiming;//RecordIDconst CFStringRef kCGImagePropertyCIFFRecordID;//曝光时间const CFStringRef kCGImagePropertyCIFFSelfTimingTime;//相机序列号const CFStringRef kCGImagePropertyCIFFCameraSerialNumber;//图片编码const CFStringRef kCGImagePropertyCIFFImageSerialNumber;//驱动模式const CFStringRef kCGImagePropertyCIFFContinuousDrive);//焦点模式const CFStringRef kCGImagePropertyCIFFFocusMode;//测量模式const CFStringRef kCGImagePropertyCIFFMeteringMode;//曝光模式const CFStringRef kCGImagePropertyCIFFShootingMode;//透镜模式const CFStringRef kCGImagePropertyCIFFLensModel;//最长镜头长度const CFStringRef kCGImagePropertyCIFFLensMaxMM;//最短镜头长度const CFStringRef kCGImagePropertyCIFFLensMinMM;//白平衡等级const CFStringRef kCGImagePropertyCIFFWhiteBalanceIndex;//曝光补偿const CFStringRef kCGImagePropertyCIFFFlashExposureComp;//实测曝光值const CFStringRef kCGImagePropertyCIFFMeasuredEV); 六、ImageIO框架在实际开发中的几个应用1.显示特殊格式的图片在平时开发中，我们通常使用UIImage来读取图片，UIImage支持的图片包括png与jpg等，但是类似windows系统的ico图标，UIImage默认是无法显示的，可以通过ImageIO框架来在iOS系统中使用ico图标，示例如下： 123456789101112NSString * path = [[NSBundle mainBundle]pathForResource:@\"image\" ofType:@\"ico\"];NSURL * url = [NSURL fileURLWithPath:path];CGImageRef myImage = NULL;CGImageSourceRef myImageSource;CFDictionaryRef myOptions = NULL;myImageSource = CGImageSourceCreateWithURL((CFURLRef)url, NULL);myImage = CGImageSourceCreateImageAtIndex(myImageSource, 0, NULL);CFRelease(myImageSource);UIImageView * image = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 200, 200)];image.image = [UIImage imageWithCGImage:myImage]; 2.读取数码相机拍摄图片的地理位置、时间等信息3.对相册中图片的地理位置，时间等信息进行自定义修改。4.将自定义格式的图片数据写入本地文件。5.展示GIF动图详情见博客：[https://my.oschina.net/u/2340880/blog/608560](https://my.oschina.net/u/2340880/blog/608560)。 6.渐进渲染大图渐进渲染技术在对加载大图片时特别重要，你应该使用过地图软件，地图视图在加载时是局部进行加载，当移动或者放大时，地图会一部分一部分的渐进进行加载，使用ImageIO框架可以实现大图渐进渲染的效果，一般在对大图片进行网络请求时，可以获取一部分数据就加载一部分数据，为了便于演示，博客中使用定时器来默认网络返回数据，代码示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@interface ViewController ()&#123; NSMutableData * _data; NSData * _allData; NSUInteger length; UIImageView * _imageView; NSTimer * timer; NSInteger le;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _data = [[NSMutableData alloc]init]; NSString * path = [[NSBundle mainBundle]pathForResource:@\"Default-Portrait-ns@2x\" ofType:@\"png\"]; _allData = [NSData dataWithContentsOfFile:path]; length = _allData.length; le = length/10; timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(updateImage) userInfo:nil repeats:YES]; _imageView = [[UIImageView alloc]initWithFrame:self.view.frame]; [self.view addSubview:_imageView];&#125;-(void)updateImage&#123; static int index = 0; if (index==10) &#123; return; &#125; NSUInteger l; if (index==9) &#123; l=length-le*9; &#125;else&#123; l= le; &#125; Byte by[l]; [_allData getBytes:by range:NSMakeRange(index*le, l)]; [_data appendBytes:by length:l]; CGImageSourceRef myImageSource = CGImageSourceCreateWithData((CFDataRef)_data, NULL); CGImageRef myImage = CGImageSourceCreateImageAtIndex(myImageSource, 0, NULL); CFRelease(myImageSource); _imageView.image = [UIImage imageWithCGImage:myImage]; // image.image = [UIImage imageNamed:@\"image.ico\"]; index++;&#125;@end 效果如下：","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"JavaScript基础之八——全局函数的应用","slug":"303JavaScript基础之八——全局函数的应用","date":"2017-01-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.363Z","comments":true,"path":"2017/01/06/303JavaScript基础之八——全局函数的应用/","link":"","permalink":"http://huishao.cc/2017/01/06/303JavaScript基础之八——全局函数的应用/","excerpt":"","text":"JavaScript基础之八——全局函数的应用JavaScript中提供了一些常用的全局函数，开发者可以直接对其进行调用，示例如下： 12345678910111213141516171819202122232425var url = \"jaki.io/v3/珲少\";//对字符串进行url编码 这个方法不会对ascll码进行编码var enUrl = encodeURI(url);console.log(enUrl);//jaki.io/v3/%E7%8F%B2%E5%B0%91//对字符串进行url解码console.log(decodeURI(enUrl));//jaki.io/v3/珲少//进行uri全编码var enCompUrl = encodeURIComponent(url);console.log(enCompUrl);//jaki.io%2Fv3%2F%E7%8F%B2%E5%B0%91//记性URI全解码console.log(decodeURIComponent(enCompUrl));//jaki.io/v3/珲少//eval()方法可以将某个字符串解释成JS代码进行执行eval(\"console.log('eval')\");//检查某个值是否为有限数字console.log(isFinite(Infinity));//检查某个值是否为非数字console.log(isNaN(\"s\"));//把对象的值转换为数字console.log(Number(\"222\"));//将一个字符串解析成浮点数console.log(parseFloat(\"3.14\"));//将一个字符串解析成整数console.log(parseInt(\"123\"));//把对象的值转换成字符串console.log(new Date()); 需要注意，encodeURI()与encodeURIComponent()方法都是用来对URI进行编码，不同的是，encodeURI()方法不会对ascll字符进行编码，在进行有中文字符的url编码时，需要使用这个方法。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"JavaScript基础之七——JavaScript中的正则表达式","slug":"301JavaScript基础之七——JavaScript中的正则表达式","date":"2017-01-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.363Z","comments":true,"path":"2017/01/05/301JavaScript基础之七——JavaScript中的正则表达式/","link":"","permalink":"http://huishao.cc/2017/01/05/301JavaScript基础之七——JavaScript中的正则表达式/","excerpt":"","text":"JavaScript基础之七——JavaScript中的正则表达式正则表达式在前端开发中应用十分广泛，从表单验证到内容替换，正则多发挥着十分重要的作用。JavaScript中提供了专门的正则对象。 在JavaScript中，有两种方式创建正则表达式，分别可以通过直接量语法来创建和RegExp对象来创建，示例如下： 123456var string = \"Hello World123454321,&#123;name:jaki,age:25&#125;Hello,HELLO\";//使用直接量语法创建正则console.log(string.match(/ello/g));//[ 'ello', 'ello' ]//使用对象构造正则var reg1 = new RegExp(\"ello\",\"g\");console.log(string.match(reg1));//[ 'ello', 'ello' ] 使用直接量语法创建正则的模板如下: /param/attri 其中param是正则表达式，attri为修饰参数，可以选择的有，i、g、m3个。i代表忽略大小写，g代表全局检索，m代表多行检索。 同样，使用RegExp对象的构造方法来构造正则对象也需要两个参数，第1个参数为正则表达式，第2个参数为修饰参数。 正则表达式可以使用括号来进行范围查找，示例如下： 123456789101112131415161718//i 表示忽略大小写 g表示全局搜索 m表示多行搜索var reg2 = new RegExp(\"ello\",\"igm\");console.log(string.match(reg2));//[ 'ello', 'ello', 'ELLO' ]//[]内表示匹配范围内的某个字符var reg3 = new RegExp(\"[abcd]\",\"g\");console.log(string.match(reg3));//前面加上^表示取反 匹配除了[]内的所有其他字符var reg4 = new RegExp(\"[^abcd]\",\"g\");console.log(string.match(reg4));//进行范围匹配 如下只匹配数字var reg5 = new RegExp(\"[0-9]\",\"g\");console.log(string.match(reg5));//进行范围匹配 如下只匹配英文字符var reg6 = new RegExp(\"[a-z]\",\"ig\");console.log(string.match(reg6));//进行指定串的匹配var reg7 = new RegExp(\"(123|hell)\",\"ig\");//[ 'Hell', '123', 'Hell', 'HELL' ]console.log(string.match(reg7)); 在构造正则表达式时，也可以灵活的使用许多元字符，示例如下： 12345678910111213141516171819202122232425262728//元字符//.元字符会比配任何字符 除了换行和行结束符var reg8 = new RegExp(\"e.l\",\"g\");console.log(string.match(reg8));//x+用于匹配一个或多个x字符var reg9 = new RegExp('l+',\"g\");console.log(string.match(reg9));//x*匹配0个或多个x字符var reg10 = new RegExp('He*',\"g\");console.log(string.match(reg10));//x?匹配0个或1个x字符var reg11 = new RegExp('He?',\"g\");console.log(string.match(reg11));//x&#123;n&#125;匹配有n个x字符var reg12 = new RegExp('l&#123;2&#125;',\"g\");console.log(string.match(reg12));//x&#123;n,m&#125;匹配有n-m间个x字符var reg13 = new RegExp('l&#123;1,5&#125;',\"g\");console.log(string.match(reg13));//x&#123;n,&#125;匹配至少有n个x字符var reg14 = new RegExp('l&#123;1,&#125;',\"g\");console.log(string.match(reg14));//x$匹配以x结尾var reg15 = new RegExp('O$',\"g\");console.log(string.match(reg15));//^x匹配以x开头var reg15 = new RegExp('^H',\"g\");console.log(string.match(reg15)); 关于RegExp对象，其中也封装了一些属性和方法，示例如下： 12345678//获取是否有相应标志位console.log(reg15.global);console.log(reg15.ignoreCase);console.log(reg15.multiline);//检索字符串中正则匹配console.log(reg15.exec(string));//检测字符串是否匹配 会返回true或者falseconsole.log(reg15.test(string)); 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记二十——工具条的应用","slug":"302Bootstrap响应式前端框架笔记二十——工具条的应用","date":"2017-01-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.363Z","comments":true,"path":"2017/01/05/302Bootstrap响应式前端框架笔记二十——工具条的应用/","link":"","permalink":"http://huishao.cc/2017/01/05/302Bootstrap响应式前端框架笔记二十——工具条的应用/","excerpt":"","text":"Bootstrap响应式前端框架笔记二十——工具条的应用工具条用于向用户进行某个操作的提示，在Bootstrap框架中，为按钮添加工具条十分简单，只需如下代码： 1&lt;button class=\"btn btn-primary\" data-toggle=\"tooltip\" data-placement=\"top\" id=\"btn\"&gt;工具条&lt;/button&gt; 需要注意，要使工具条显现，必须先进行工具条对象的构造，示例如下： 1234567$(\"#btn\").tooltip(&#123; animation:false, delay:1000, placement:'top', title:'标题！！！！', trigger:'click'&#125;); 这个方法中可以传入一个对象参数，其中animation属性设置工具条的显隐是否有动画效果；delay属性设置触发后延迟多久进行工具条的显隐操作；placement属性设置工具条出现的位置，可选top，bottom，left，right，auto选项；title属性设置工具栏标题；trigger属性设置触发方式，可选click，hover，focus和manual。 工具条效果如下： 开发者也可以手动调用方法来控制工具条的显示隐藏，示例如下： 123456789101112//显示工具栏$('#show').on('click',function()&#123; $('#btn').tooltip('show');&#125;);//隐藏工具栏$('#hide').on('click',function()&#123; $('#btn').tooltip('hide');&#125;);//切换显隐状态$('#toggle').on('click',function()&#123; $('#btn').tooltip('toggle');&#125;); Bootstrap中还对工具条提供了一些状态监听方法，示例如下： 123456789101112$('#btn').on('show.bs.tooltip',function()&#123; console.log(\"工具条将要开启\");&#125;);$('#btn').on('shown.bs.tooltip',function()&#123; console.log(\"工具条已经开启\");&#125;);$('#btn').on('hide.bs.tooltip',function()&#123; console.log(\"工具条将要关闭\");&#125;);$('#btn').on('hidden.bs.tooltip',function()&#123; console.log(\"工具条已经关闭\");&#125;); 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/toolJS.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"JavaScript基础之六——内置对象","slug":"300JavaScript基础之六——内置对象","date":"2017-01-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.363Z","comments":true,"path":"2017/01/04/300JavaScript基础之六——内置对象/","link":"","permalink":"http://huishao.cc/2017/01/04/300JavaScript基础之六——内置对象/","excerpt":"","text":"JavaScript基础之六——内置对象一、构造对象JavaScript中的一些数据都是对象，对象实际上是属性与方法的包装。并不像其他类似Swift/OC/Java类的面向对象语言，在目前JavaScript的实现中并没有类的概念，开发者有如下两种方式来进行对象的构造： 1234567891011121314//创建对象的方式有两种 可以直接创建对象的实例var obj = new Object();obj.name = \"jaki\";obj.age = 25;console.log(obj);//也可以使用大括号才创建对象var obj2 = &#123; name:\"jaki\", age:25, show:function()&#123; console.log(this.name+\"--\"+this.age); &#125;&#125;;obj2.show(); 回顾Swift语言的对象创建方法，是通过类调用构造方法，因此，在JavaScript中，也可以通过函数来模拟类的功能，此类的函数可以称为构造函数，示例如下： 12345678910//模拟类 构造方法function Person(name,age)&#123; this.name = name; this.age = age; this.show = function()&#123; console.log(this.name+\"--\"+this.age); &#125;;&#125;var p = new Person(\"jaki\",25);p.show(); JavaScript中的对象呗构造出来后，依然可以为其动态添加属性或方法，示例如下： 12345678910111213//模拟类 构造方法function Person(name,age)&#123; this.name = name; this.age = age; this.show = function()&#123; console.log(this.name+\"--\"+this.age); &#125;;&#125;var p = new Person(\"jaki\",25);p.show();//已经构造的对象 也可以增加属性p.phone = \"1111\"console.log(p.phone); 二、数值对象Number在JavaScript中，数值是一种基本数据类型，但是Number是数值对象，可以理解为对数值的包装。并且JavaScript中的数值只有一种类型，可以创建整数，也可以创建小数，如下： 12345//数字对象//JS中只有一种数字对象Number //可以描述整数 也可以描述小数var c = 10;var c1 = 3.14; 也支持使用科学计数法来对数值进行描述，示例如下： 1234//也可以使用科学计数法来计数var c2 = 1.2e5;var c3 = 123e-5;console.log(c2,c3); 在JavaScript中，使用前缀0来描述八进制数值，使用前缀0x来描述十六进行的数值，示例如下： 123456//使用0为前缀 约定为8进制var c4 = 017;console.log(c4); //十进制15//使用0x前缀约定为十六进制var c5 = 0x11;console.log(c5); //十进制17 需要注意：和其他语言不同，JavaScript中不能随意的数值前面加0，否则会被认为是八进制计数。 关于Number，如果使用new来进行构造，会返回一直数值对象，其中可以穿入一个参数作为数值对象的原始值，如果将Number()作为函数来使用，则会直接返回一个具体的数值，示例如下： 12345678//Number可以作为构造方法来使用 传入的参数为要构造的Number值var objc = new Number(15);console.log(objc);//Number也可以作为函数来使用 这时他将返回数值或者NaNvar objc2 = Number(2);console.log(objc2); //2var objc3 = Number(\"c\");console.log(objc3);//NaN Number中内置了一些常用的属性与方法，示例如下： 1234567891011//常用内置属性//返回可表示的最大值console.log(Number.MAX_VALUE);//返回可表示的最小值console.log(Number.MIN_VALUE);//返回非数字值console.log(Number.NaN);//表示负无穷大 发生溢出时 会返回console.log(Number.NEGATIVE_INFINITY);//表示正无穷大 发生溢出时 会返回console.log(Number.POSITIVE_INFINITY); 对象实例的常用方法： 123456789101112131415161718//常用内置方法var c6 = 100;//将数据转换成字符串console.log(c6.toString());//toString()方法中可以传入一个参数 默认为10进制 可选2-36console.log(c6.toString(36));//toLocaleString()方法返回本地环境格式的字符串 一般10进制console.log(c6.toLocaleString());var c7 = 3.1415926;//toFixed()方法用于将数字转换成字符串 可以指定小数位数 会四舍五入console.log(c7.toFixed(3));//将数值转换成指数计数法console.log(c7.toExponential(1));//toPrecision()方法可以将数值转换为指定位数console.log(c7.toPrecision(4));//返回原始数值console.log(c7.valueOf()); 需要注意，对于进制转换，toString()方法支持2-36进制，这很好理解，数字0-9加上26个英文字母，最多可以表达36个数字。 三、字符串对象StringJavaScript语言中的字符串对象封装了大量的操作方法，需要注意，JavaScript中的String对象是不可变的，所有对字符串的操作都是返回一个新的字符串。String对象中最常用的一个属性为length属性，这个属性可以获取字符串的长度，示例如下： 12345//字符串对象var str1 = new String(\"HelloWorld\");var str2 = String(\"HELLO\");//length属性可以获取字符串的长度console.log(str1.length); //10 String对象中封装的一些常用方法示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//静态方法//通过Unicode值创建字符var str3 = String.fromCharCode(100,102,103,104);//dfghconsole.log(str3);//创建html锚点console.log(str1.anchor(\"label\")); //&lt;a name=\"label\"&gt;HelloWorld&lt;/a&gt;//嵌入big标签中console.log(str1.big());//&lt;big&gt;HelloWorld&lt;/big&gt;//嵌入small标签console.log(str1.small());//&lt;small&gt;HelloWorld&lt;/small&gt;//嵌入blick标签中console.log(str1.blink());//&lt;blink&gt;HelloWorld&lt;/blink&gt;//嵌入b标签中console.log(str1.bold());//&lt;b&gt;HelloWorld&lt;/b&gt;//获取指定位置的字符 从0开始console.log(str1.charAt(1));//e//获取指定位置字符的unicode码console.log(str1.charCodeAt(1));//101//字符串拼接console.log(str1.concat(\"1\",\"2\",\"3\"));//HelloWorld123//嵌入打印模式console.log(str1.fixed());//&lt;tt&gt;HelloWorld&lt;/tt&gt;//指定HTML字体颜色console.log(str1.fontcolor('red'));//&lt;font color=\"red\"&gt;HelloWorld&lt;/font&gt;//指定HTML字体大小console.log(str1.fontsize(24));//&lt;font size=\"24\"&gt;HelloWorld&lt;/font&gt;//indexOf()方法用于检查某个子串在父串中第一次出现的位置，其中第1个参数为要检索的子串，第2个参数为从某个位置开始检索console.log(str1.indexOf('l',3));//3 注意，如果没有检索到 会返回-1//嵌入i标签中console.log(str1.italics());//&lt;i&gt;HelloWorld&lt;/i&gt;//从后往前检索 同indexOf()方法console.log(str1.lastIndexOf(\"l\",10));//8//嵌入a标签中console.log(str1.link(\"www.baidu.com\"));//&lt;a href=\"www.baidu.com\"&gt;HelloWorld&lt;/a&gt;//进行字符串比较 如果str1&lt;参数 则返回-1 如果大于 则返回1 相等 则返回0console.log(str1.localeCompare(\"Z\"));//-1//match()方法用于字符串检索 其将返回一个检索结果对象//match()方法的参数可以为//字符串:要检索的字符串//正则表达式:要检索的正则表达式console.log(str1.match(\"ell\"));//[ 'ell', index: 1, input: 'HelloWorld' ]console.log(str1.match(/ell/));//进行字符串替换 第1个参数为要被替换的字符或者正则 第2个参数为替换成的字符串console.log(str1.replace(\"Hello\",\"hahaha\"));//hahahaWorld//进行子串匹配 可以是字符串参数也可以是正则 这个方法不能指定检索起点console.log(str1.search(\"World\"));//5//进行字符串截取console.log(str1.slice(0,5));//Hello//进行字符串分隔操作//第一个参数：分隔标准 可以会字符串或者正则//第二个参数：返回数组中元素的最大个数console.log(str1.split('o',10));//[ 'Hell', 'W', 'rld' ]//嵌入strike标签中console.log(str1.strike());//&lt;strike&gt;HelloWorld&lt;/strike&gt;//嵌入sub标签console.log(str1.sub());//&lt;sub&gt;HelloWorld&lt;/sub&gt;//进行字符串截取 第1个参数为起始位置 第2个参数为需要截取的长度console.log(str1.substr(0,5));//Hello//进行字符串截取 获取两个索引之间的字符console.log(str1.substring(5,10));//World//嵌入sup标签中console.log(str1.sup());//&lt;sup&gt;HelloWorld&lt;/sup&gt;//全部转换为小写字母console.log(str1.toLocaleLowerCase());console.log(str1.toLowerCase());//全部转换为大写字母console.log(str1.toLocaleUpperCase());console.log(str1.toUpperCase());//返回字符串对象的原始值console.log(str1.valueOf()); 四、日期对象DateJavaScript中提供丰富的日期处理方法，示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//日期对象date//创建当前时间对象var date1 = new Date();console.log(date1);//2017-01-04T02:00:05.617Z//返回当前的日期var date2 = Date();console.log(date2);//Wed Jan 04 2017 10:04:56 GMT+0800 (CST)//获取时间对象是一个月中的第几天 1-31之间 必须是Date对象调用console.log(date1.getDate()); //4//获取时间对象是一周中的第几天 周日为0console.log(date1.getDay()); //3//返回月份 注意 这个会返回0-11之间console.log(date1.getMonth()); //0//获取完整的年console.log(date1.getFullYear()); //2017//获取小时0-23console.log(date1.getHours());//获取分钟0-59console.log(date1.getMinutes());//获取秒0-59console.log(date1.getSeconds());//获取毫秒0-999console.log(date1.getMilliseconds());//获取时间戳 从1970年1月1日 起console.log(date1.getTime());//返回本地时间与格林威治时间的分钟差console.log(date1.getTimezoneOffset());//-480//返回世界时间中 一个月中的第几天 1-31console.log(date1.getUTCDate());//返回世界时间中 一周中的第几天 周日为0console.log(date1.getUTCDay());//返回世界时间中的月份 0-11console.log(date1.getUTCMonth());//返回世界时间中的年console.log(date1.getUTCFullYear());//返回世界时间中小时console.log(date1.getUTCHours());//返回世界时间中的分钟console.log(date1.getUTCMinutes());//返回世界时间中的秒console.log(date1.getUTCSeconds());//返回世界时间中的毫秒console.log(date1.getUTCMilliseconds());//静态方法 返回从1970.1.1到指定日期间的毫秒console.log(Date.parse(date1));//设置日期 1个月中的某一天 1-31date1.setDate(1);//设置月份date1.setMonth(2);//设置年份date1.setFullYear(2011);//设置时date1.setHours(10);//设置分date1.setMinutes(20);//设置秒date1.setSeconds(23);//设置毫秒date1.setMilliseconds(100);console.log(date1);//通过时间戳设置date对象date1.setTime(1483599203000);console.log(date1);//下面这些方法设置时间时间date1.setUTCDate(3);date1.setUTCMonth(10);date1.setUTCFullYear(2020);date1.setUTCHours(22);date1.setUTCMinutes(22);date1.setUTCSeconds(34);date1.setUTCMilliseconds(112);console.log(date1);//转换为本地时间字符串console.log(date1.toString());//Wed Nov 04 2020 06:22:34 GMT+0800 (CST)//转换时间部分console.log(date1.toTimeString());//06:22:34 GMT+0800 (CST)//转换日期部分console.log(date1.toDateString());//Wed Nov 04 2020//转换为世界时间字符串console.log(date1.toUTCString());//Tue, 03 Nov 2020 22:22:34 GMT//转换成本地格式的字符串console.log(date1.toLocaleString());//11/4/2020, 6:22:34 AM//只转换本地格式的时间console.log(date1.toLocaleTimeString());//6:22:34 AM//只转换日期console.log(date1.toLocaleDateString());//11/4/2020//返回从1970.1.1到指定时间的时间戳 //参数含义为 年 月 日 时 分 秒 毫秒console.log(Date.UTC(2012,1,1,1,1,1,1)); 五、数组对象Array数组对象用于存放一组数据，JavaScript语言并不像Swift语言那样强调类型，因此数组中存放的元素类型十分自由，JavaScript中数组的相关方法示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//有三种方式进行数组的构造//构造空数组var array1 = new Array();//构造指定个数元素的数组var array2 = new Array(5);//构造初始数组var array3 = new Array(1,2,3,4)//length属性可以获取数组元素个数console.log(array3.length);//4//进行数组连接console.log(array3.concat([5,6],['q','w']));//将数组中所有元素以指定分隔符进行拼接为字符串console.log(array3.join(\"-\"));//删除数组中的最后一个元素array3.pop();console.log(array3);//向数组中添加一个元素array3.push(5);console.log(array3);//进行数组颠倒array3.reverse();console.log(array3);//删除数组中的第一个参数array3.shift();console.log(array3);//向数组开头插入一些元素array3.unshift(1,1,1);console.log(array3);//对数组元素进行排序 array3.sort(function(a,b)&#123; if (a&gt;b) &#123; return true; &#125;else&#123; return false; &#125;&#125;);console.log(array3);//删除数组中的元素 并插入其他元素//第1个参数为参数元素的位置//第2个参数为删除元素的个数//之后可以有任意个参数，作为插入元素array3.splice(0,2,'c',5);console.log(array3);//将数组转换为字符串 使用逗号拼接console.log(array3.toString());console.log(array3.toLocaleString()); 需要注意，数组的排序方法sort()中需要传入一个排序函数，这个函数中会传入两个参数，分别描述数组中相邻的两个元素，如果需要交换位置，返回true即可，否则返回false即可。另外，数组的toString()方法与join()方法作用相似，不同的是join()方法更加自由，开发者可以通过参数决定进行拼接的方式，如果不传参数，则默认也会以逗号进行分割拼接。 六、关于Boolean对象Boolean对象用来描述逻辑值，JavaScript中的Boolean对象可以理解为对布尔值的一种包装，当使用构造函数来进行Boolean对象的创建时，如果不传参数，默认会构造false值的对象包装，如下： 12var b1 = new Boolean();console.log(b1);//[Boolean: false] 如果将Boolean()当做函数来使用，将会返回一个基本布尔值，如下： 12var b2 = Boolean();console.log(b2);//false 在创建布尔值时，下面这些传参都将创建包装false的布尔对象： 1234567var myBoolean=new Boolean();var myBoolean=new Boolean(0);var myBoolean=new Boolean(null);var myBoolean=new Boolean(\"\");var myBoolean=new Boolean(false);var myBoolean=new Boolean(NaN);var myBoolean=new Boolean(undefined); 除了上面所列举的参数情况外，其余的都将构造true包装对象。 七、JavaScript中的数学对象及方法JavaScript中还内置了一个Math数学对象，这个对象中封装了许多数学中常用的常数和算术方法，示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Math对象//自然对数econsole.log(Math.E);//2.718281828459045//2的自然对数console.log(Math.LN2);//0.6931471805599453//10的自然对数console.log(Math.LN10);//2.302585092994046//以2为底e的对数console.log(Math.LOG2E);//1.4426950408889634//以10为底e的对数console.log(Math.LOG10E);//0.4342944819032518//圆周率console.log(Math.PI);//3.141592653589793//根号2的倒数console.log(Math.SQRT1_2);//0.7071067811865476//根号2console.log(Math.SQRT2);//1.4142135623730951//求绝对值函数console.log(Math.abs(-5));//5//求反余弦函数console.log(Math.acos(0.5));//求反正弦函数console.log(Math.asin(0.5));//求反正切函数console.log(Math.atan(1));//求到(x,y)点的角度console.log(Math.atan2(1,0));//进行向上舍入console.log(Math.ceil(1.3));//2//进行向下舍入console.log(Math.floor(1.3));//1//求自然对数console.log(Math.log(10));//2.302585092994046//返回最大值console.log(Math.max(1,2));//2//返回最小值console.log(Math.min(1,2));//1//求幂函数console.log(Math.pow(10,2));//100//取0-1之间的随机数console.log(Math.random());//进行四舍五入console.log(Math.round(1.3));//1//求正弦值console.log(Math.sin(2));//求余弦值console.log(Math.cos(2));//求正切值console.log(Math.tan(1)); 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"JavaScript基础之五——异常的抛出与捕获","slug":"298JavaScript基础之五——异常的抛出与捕获","date":"2017-01-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.362Z","comments":true,"path":"2017/01/02/298JavaScript基础之五——异常的抛出与捕获/","link":"","permalink":"http://huishao.cc/2017/01/02/298JavaScript基础之五——异常的抛出与捕获/","excerpt":"","text":"JavaScript基础之五——异常的抛出与捕获任何程序在运行过程中都会产生开发者意想不到的异常，因此对异常的处理逻辑是一种编程必备的能力。在JavaScript语言中，使用try-catch块来完成对异常的捕获与处理。 正常情况下，当JavaScript程序运行到有异常的地方时，程序会自动中断，例如开发者使用了一种未定义的变量或函数、由于手误造成的错字、由于用户输入非法造成的意想不到的错误等。但是开发者可以使用try-catch结构对可能抛出异常的代码进行异常捕获，如果捕获到异常，开发者可以选择处理或不处理，如果异常被捕获，程序就不会中断，示例代码如下： 123456//异常的抛出与捕获try&#123; consele.log(\"异常\");&#125;catch(error)&#123; console.log(error);&#125; 除了某些系统抛出的异常外，开发者也可以定义和抛出自己的异常，使用throw关键字可以抛出异常，示例如下： 123456789//使用throw关键字用于异常的抛出var func = function()&#123; throw \"My Error\"&#125;try&#123; func();&#125;catch(error)&#123; console.log(error);&#125; 需要注意，抛出的异常可以是自定的异常对象，可以是字符串，可以使任意JavaScript对象。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记十九——标签页的使用","slug":"299Bootstrap响应式前端框架笔记十九——标签页的使用","date":"2017-01-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.362Z","comments":true,"path":"2017/01/02/299Bootstrap响应式前端框架笔记十九——标签页的使用/","link":"","permalink":"http://huishao.cc/2017/01/02/299Bootstrap响应式前端框架笔记十九——标签页的使用/","excerpt":"","text":"Bootstrap响应式前端框架笔记十九——标签页的使用Bootstrap中通过为导航标签增加data-toggle=&quot;tab&quot;，配合类或id来进行标签页的关联，示例如下： 1234567891011121314151617181920212223242526 &lt;ul class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt; &lt;a href=\"#one\" data-toggle=\"tab\" id=\"aone\"&gt;第一页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#two\" data-toggle=\"tab\" id=\"atwo\"&gt;第二页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#three\" data-toggle=\"tab\" id=\"athree\"&gt;第三页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#four\" data-toggle=\"tab\" id=\"afour\"&gt;第四页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- Tab panes --&gt; &lt;div class=\"tab-content\"&gt; &lt;div class=\"tab-pane active fade in\" id=\"one\"&gt;On iPhone 7 and iPhone 7 Plus, haptics provide additional ways to physically engage users with tactile feedback that gets attention and reinforces actions. Some system-provided interface elements, such as pickers, switches, and sliders, automatically provide haptic feedback as users interact with them&lt;/div&gt; &lt;div class=\"tab-pane\" id=\"two\"&gt;Using one of the concrete subclasses, you ask the system to generate haptics for a specific scenario and iOS manages the strength and behavior of the feedback based on the scenario you choose. In addition, you can call the prepare method of UIFeedbackGenerator to inform the system that haptic feedback is about to be required and to minimize latency. To learn how to use haptics to provide the best user experience in your app, see “Haptic Feedback” in iOS Human Interface Guidelines.&lt;/div&gt; &lt;div class=\"tab-pane\" id=\"three\"&gt;When the user makes a request involving your service, SiriKit sends your extension an intent object, which describes the user’s request and provides any data related to that request. You use the intent object to provide an appropriate response object, which includes details of how you can handle the user’s request. Siri typically handles all user interactions, but you can use an extension to provide custom UI that incorporates branding or additional information from your app.&lt;/div&gt; &lt;div class=\"tab-pane\" id=\"four\"&gt;To learn how to support SiriKit and give users new ways to access your services, read SiriKit Programming Guide. When you’re ready to implement the app extensions that handle various intents, see Intents Framework Reference and Intents UI Framework Reference.&lt;/div&gt; &lt;/div&gt; 效果如图： 为tab-pane类增加fade in类可以使标签切换时带渐入动画。 Bootstrap中的标签页JS组件提供了一个tab函数，使用这个方法可以实现代码控制标签的切换，示例如下： 123456789101112131415161718&lt;button class=\"btn btn-primary\" id=\"cone\"&gt;第一页&lt;/button&gt;&lt;button class=\"btn btn-primary\" id=\"ctwo\"&gt;第二页&lt;/button&gt;&lt;button class=\"btn btn-primary\" id=\"cthree\"&gt;第三页&lt;/button&gt;&lt;button class=\"btn btn-primary\" id=\"cfour\"&gt;第四页&lt;/button&gt;&lt;script&gt; $(\"#cone\").on(\"click\",function()&#123; $(\"#aone\").tab('show'); &#125;); $(\"#ctwo\").on(\"click\",function()&#123; $(\"#atwo\").tab('show'); &#125;); $(\"#cthree\").on(\"click\",function()&#123; $(\"#athree\").tab('show'); &#125;); $(\"#cfour\").on(\"click\",function()&#123; $(\"#afour\").tab('show'); &#125;);&lt;/script&gt; Bootstrap中还提供了一些监听事件，开发者可以向导航标签中添加这些监听事件来监听标签页的状态，示例如下： 123456789101112$(\"#aone\").on(\"show.bs.tab\",function()&#123; console.log(\"此标签页将要显示\");&#125;);$(\"#aone\").on(\"shown.bs.tab\",function()&#123; console.log(\"此标签页已经显示\");&#125;);$(\"#aone\").on(\"hide.bs.tab\",function()&#123; console.log(\"此标签页将要隐藏\");&#125;);$(\"#aone\").on(\"hidden.bs.tab\",function()&#123; console.log(\"此标签页已经隐藏\");&#125;); 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/PageJS.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"JavaScript基础之四——选择与循环结构","slug":"297JavaScript基础之四——选择与循环结构","date":"2016-12-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.362Z","comments":true,"path":"2016/12/31/297JavaScript基础之四——选择与循环结构/","link":"","permalink":"http://huishao.cc/2016/12/31/297JavaScript基础之四——选择与循环结构/","excerpt":"","text":"JavaScript基础之四——选择与循环结构选择结构与循环结构是编程中处理逻辑的核心结构，JavaScript中支持if-else和switch-case选择结构，支持for，for-in,do-while,while循环结构。并且可以使用break与continue语句进行循环的跳出，简单的条件选择if语句示例如下： 1234567891011121314151617//if条件语句if (true) &#123; console.log(\"条件语句\");&#125;;if (false) &#123;&#125; else &#123; console.log(\"if-else语句\");&#125;;var a = 10;if (a &lt; 10) &#123; console.log(\"a&lt;10\");&#125; else if (a == 10) &#123; console.log(\"a=10\");&#125; else &#123; console.log(\"a&gt;10\");&#125;; switch-case选择结构用于多分支条件的选择，示例如下： 123456789101112131415161718//选择语句var b = \"hi\";switch (b) &#123; case \"hello\": &#123; console.log(\"Hello world\"); &#125; break; case \"hi\": &#123; console.log(\"Hi world\"); &#125; break; default: &#123; console.log(\"都没匹配上\"); &#125;&#125; 需要注意，每个case结构后面原则上都需要使用break进行中断匹配，如果不添加此break，则匹配到一个case语句后switch结构并不会结束，会继续尝试匹配后面的case条件。 for循环结构用于处理大量重复的逻辑，示例如下： 12345678910for (var i = 0; i &lt; 10; i++) &#123; console.log(\"循环\" + i);&#125;for (var i = 0; i &lt; 10; i++) &#123; console.log(\"循环\" + i); if (i == 2) &#123; //使用break可以提前中断循环 break; &#125;;&#125; JavaScript还有一种更高效的循环模式，for-in结构，这种结构专门用来遍历对象，其可以将对象的属性遍历出来，示例如下： 123456789101112131415var obj1 = &#123; name: \"jaki\", age: 25&#125;;var obj2 = [1, 2, 3, 4, 5, 6, 7, 8];for (var x in obj1) &#123; //跳过本次循环 并不是跳出循环 if (x == \"name\") continue; console.log(x + \":\" + obj1[x]);&#125;for (var x in obj2) &#123; console.log(x + \":\" + obj2[x]);&#125; 需要注意，对于数组，其遍历出来的是数组的下标，并不是其中的值，这和C/OC,Swift等语言有所差异，也证明了数组在JavaScript中其实就是一种特殊的对象。 while循环和do-while循环的差异在于whlie结构是先进行循环条件的判断，再进入循环体，而do-while结构则是先进入循环体，在进行循环条件的判断，示例如下： 123456789var c = 1;while (c &lt; 10) &#123; console.log(c); c++;&#125;do &#123; console.log(c); c--;&#125; while (c &gt; 1); 前面提到过break和continue语句，break语句用于中断switch-case匹配或者跳出最近的循环，跳出循环的意思是指执行到break后，无论后面循环次数还有多少次，直接跳出，执行循环结构之后的代码。continue语句的作用则是跳出最近的本次循环，接着进行循环条件的判断，如果满足会继续进行循环，并且如果有多层循环嵌套，break和continue也可以通过label标签指定具体跳出那层循环，示例如下： 12345678LAB: for (var i = 0; i &lt; 5; i++) &#123; for (var j = 0; j &lt; 5; j++) &#123; if (j == 2) &#123; break LAB &#125;; console.log(i + '==' + j); &#125;;&#125;; 上面的代码，如果不使用LAB标签，则外层循环不会被中断。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"JavaScript基础之三——基本运算符","slug":"296JavaScript基础之三——基本运算符","date":"2016-12-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.361Z","comments":true,"path":"2016/12/30/296JavaScript基础之三——基本运算符/","link":"","permalink":"http://huishao.cc/2016/12/30/296JavaScript基础之三——基本运算符/","excerpt":"","text":"JavaScript基础之三——基本运算符大多数语言支持的基本运算符都差别不大。其中最常用的莫属赋值运算符，编程初学者总是会将赋值运算符与相等运算符混淆，需要注意，赋值运算符用于将等号右侧的值赋值给等号左侧的变量，示例如下： 12//赋值运算符var v = 10; 基本的算术运算符在JavaScript中都是支持的，示例如下： 12345678910111213141516171819202122//+加法运算符var sum = 4+5;console.log(sum);//加法运算符也可以用于字符串之间的拼接var str = \"Hello\" + \"World\";//如果把数字与字符串进行相加 结果为字符串str = str + sum;console.log(str);//-减法运算符var sub = 10-2;console.log(sub);//*乘法运算符var mul = 5*2;console.log(mul);//\\除法运算符var dev = 30/4;console.log(dev);//%取余运算符var rem = 10.5%2.5;console.log(rem);rem = 10%3;console.log(rem); JavaScript语言中的取余运算符十分强大，其不仅可以用于整数间的取余运算，也可以用于小数间的取余运算(Swift2.2以前的版本也可以支持浮点数取余运算，后面的版本将这个特性删掉了)。 除了前面列举的算术运算符外，JavaScript也支持递增与递减运算符，和C中的此类运算符用法一致，其可以放在操作数前也可以放在操作数后。通俗的理解，当运算符放在操作数前表示先进行递增或递减，再将结果返回；当运算符放在操作符后表示先将操作数的值返回，再进行递增或递减操作，演示如下： 123456789101112//累加var t1 = 5;console.log(t1++);console.log(t1);console.log(++t1);console.log(t1);//递减var t2 = 5;console.log(t2--);console.log(t2);console.log(--t2);console.log(t2); 如果将赋值运算符与算术运算符结合起来，就组成了复合赋值运算符，复合运算符将接收的变量本身进行算术运算后返回，示例如下： 1234567//复合运算符var t3 = 5;t3+=1;t3-=1;t3*=2;t3/=2;t3%=2; 在条件与循环结构中，逻辑表达式十分重要，逻辑运算符是构成逻辑表达式的基础，在编程的世界中逻辑值只有两个，非真即假。比较运算符会返回一个逻辑值，JavaScript中支持的比较运算符如下： 12345678910111213141516171819//比较运算符//比较值是否相等 falseconsole.log(3==4);//当数字和字符串进行比较时 只对值是否相等进行比较 trueconsole.log(3=='3');//全等比较 值和类型都相等才返回true 下面示例为fasleconsole.log(3==='3');//是否不等 只比较值console.log(3!='3');//是否不全等 值和类型都比较console.log(3!=='3');//小于比较console.log(3&lt;4);//大于比较console.log(3&gt;4);//不大于比较console.log(3&lt;=4);//不小于比较console.log(3&gt;=4); 上面列举的比较运算符中的“==”与“===”需要注意，前者是对值进行比较，并不比较类型，后者除了比较值之外，还会对类型进行比较。 JavaScript中支持的逻辑运算符有与运算符，或运算符和非运算符，示例如下： 123456789//进行与运算 有1个为false则为false 都为true才为trueconsole.log(false&amp;&amp;true);console.log(true&amp;&amp;true);//进行或运算 有1个为true则为true 都为false才为falseconsole.log(false||true);console.log(false&amp;&amp;false);//进行非运算console.log(!false);console.log(!true); JavaScript中还有一个运算符十分常用，条件运算符(问号冒号运算符)通常可以用来代替简单的条件语句，示例如下： 1234567//条件运算符var a;a = true?\"aaa\":\"bbb\";console.log(a);var b;b = false?\"aaa\":\"bbb\";console.log(b); 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"JavaScript基础之二——方法与属性","slug":"294JavaScript基础之二——方法与属性","date":"2016-12-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.361Z","comments":true,"path":"2016/12/29/294JavaScript基础之二——方法与属性/","link":"","permalink":"http://huishao.cc/2016/12/29/294JavaScript基础之二——方法与属性/","excerpt":"","text":"JavaScript基础之二——方法与属性和编译型语言必须由类产生对象不同，JavaScript语言中并没有严格的类的界定，并且对象的属性和方法也可以进行动态的绑定。属性是对象中封装的一些值数据，其用来描述对此对象的某些特性，方法也称为行为，其用来描述对象的一些行为动作，创建对象有两种方式，可以直接使用大括号的方式创建，也可以使用new Object()来创建，示例如下： 12345678910111213//对象拥有属性与方法//属性描述对象的某些值var person = new Object();//名字和年龄属性person.name = 'Jaki';person.age = 25;//行走方法person.run = function()&#123; console.log(\"前进1公里\");&#125;//调用方法person.run();console.log(person); 数字，字符串等数据实质上也是对象，字符串对象内置了一些属性与方法，示例如下： 123456789101112var txt = \"Hello WorldW\";//获取字符串长度属性console.log(txt.length);//获取子串在字符串中的位置 如果没找到 会返回-1 从前往后搜索console.log(txt.indexOf(\"W\"));//获取子串在字符串中的位置 如果没找到 会返回-1 从后往前搜索console.log(txt.lastIndexOf(\"W\"));//根据正则表达式或者字符串搜索子串console.log(txt.search(/W/));//这个方法有两个参数 第一个参数是需要替换的正则或者子串 第2个参数是替换后的子串txt = txt.replace(\"World\",\"W\");console.log(txt); 方法也是函数，JavaScript中使用function关键字来定义函数，函数可以有参数列表也可以没有，可以通过return返回值也可以无返回值，示例如下： 12345function addFunc(param1,param2)&#123; console.log(param1+param2); return param1+param2;&#125;addFunc(5,6); 需要注意，在函数内使用var声明的变量为局部变量，当函数结束后，局部变量会被销毁，但是需要注意，如果在函数内没有声明变量而直接使用，则此变量会被默认声明为全局的，在函数外面依然可以使用，示例如下： 1234567function addFunc(param1,param2)&#123; console.log(param1+param2); sum = param1+param2; return param1+param2;&#125;addFunc(5,6);console.log(sum); 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记十八——导航滚动监听","slug":"295 Bootstrap响应式前端框架笔记十八——导航滚动监听","date":"2016-12-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.361Z","comments":true,"path":"2016/12/29/295 Bootstrap响应式前端框架笔记十八——导航滚动监听/","link":"","permalink":"http://huishao.cc/2016/12/29/295 Bootstrap响应式前端框架笔记十八——导航滚动监听/","excerpt":"","text":"Bootstrap响应式前端框架笔记十八——导航滚动监听Bootstrap框架中提供了十分方便的方法来使用导航关联内容快，并且开发者可以监听滚动进行导航按钮的切换，示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"../bower_components/bootstrap/dist/css/bootstrap.css\" /&gt; &lt;script type=\"text/javascript\" src=\"../bower_components/jquery/dist/jquery.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"../bower_components/bootstrap/dist/js/bootstrap.js\"&gt;&lt;/script&gt; &lt;style&gt; .scrollspy-example &#123; position: relative; height: 200px; margin-top: 10px; overflow: auto &#125; &lt;/style&gt; &lt;title&gt;滚动监听&lt;/title&gt; &lt;/head&gt; &lt;body class=\"container\"&gt; &lt;br /&gt; &lt;br /&gt; &lt;!--导航栏--&gt; &lt;nav id=\"navbar\" class=\"navbar navbar-default navbar-static\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button class=\"navbar-toggle\" type=\"button\" data-toggle=\"collapse\" data-target=\".navigationShow\"&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;列表&lt;/a&gt; &lt;/div&gt; &lt;!--导航容器--&gt; &lt;div class=\"navbar-collapse navigationShow\"&gt; &lt;!--导航--&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt; &lt;a href=\"#One\"&gt;第一项&lt;/a&gt; &lt;/li&gt; &lt;li class=\"\"&gt; &lt;a href=\"#Two\"&gt;第二项&lt;/a&gt; &lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" id=\"navbarDrop1\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li class=\"\"&gt; &lt;a href=\"#one\"&gt;菜单1&lt;/a&gt; &lt;/li&gt; &lt;li class=\"\"&gt; &lt;a href=\"#two\"&gt;菜单2&lt;/a&gt; &lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li class=\"\"&gt; &lt;a href=\"#three\"&gt;菜单3&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!--内容div 使用data-spy=\"scroll\"来进行滚动监听--&gt; &lt;div data-spy=\"scroll\" data-target=\"#navbar\" class=\"scrollspy-example\"&gt; &lt;!--id需要对应--&gt; &lt;h4 id=\"One\"&gt;第一项&lt;/h4&gt; &lt;p&gt;Ad leggings keytar, brunch id art party dolor labore. Pitchfork yr enim lo-fi before they sold out qui. Tumblr farm-to-table bicycle rights whatever. Anim keffiyeh carles cardigan. Velit seitan mcsweeney's photo booth 3 wolf moon irure. Cosby sweater lomo jean shorts, williamsburg hoodie minim qui you probably haven't heard of them et cardigan trust fund culpa biodiesel wes anderson aesthetic. Nihil tattooed accusamus, cred irony biodiesel keffiyeh artisan ullamco consequat.&lt;/p&gt; &lt;h4 id=\"Two\"&gt;第二项&lt;/h4&gt; &lt;p&gt;Veniam marfa mustache skateboard, adipisicing fugiat velit pitchfork beard. Freegan beard aliqua cupidatat mcsweeney's vero. Cupidatat four loko nisi, ea helvetica nulla carles. Tattooed cosby sweater food truck, mcsweeney's quis non freegan vinyl. Lo-fi wes anderson +1 sartorial. Carles non aesthetic exercitation quis gentrify. Brooklyn adipisicing craft beer vice keytar deserunt.&lt;/p&gt; &lt;h4 id=\"one\"&gt;one&lt;/h4&gt; &lt;p&gt;Occaecat commodo aliqua delectus. Fap craft beer deserunt skateboard ea. Lomo bicycle rights adipisicing banh mi, velit ea sunt next level locavore single-origin coffee in magna veniam. High life id vinyl, echo park consequat quis aliquip banh mi pitchfork. Vero VHS est adipisicing. Consectetur nisi DIY minim messenger bag. Cred ex in, sustainable delectus consectetur fanny pack iphone.&lt;/p&gt; &lt;h4 id=\"two\"&gt;two&lt;/h4&gt; &lt;p&gt;In incididunt echo park, officia deserunt mcsweeney's proident master cleanse thundercats sapiente veniam. Excepteur VHS elit, proident shoreditch +1 biodiesel laborum craft beer. Single-origin coffee wayfarers irure four loko, cupidatat terry richardson master cleanse. Assumenda you probably haven't heard of them art party fanny pack, tattooed nulla cardigan tempor ad. Proident wolf nesciunt sartorial keffiyeh eu banh mi sustainable. Elit wolf voluptate, lo-fi ea portland before they sold out four loko. Locavore enim nostrud mlkshk brooklyn nesciunt.&lt;/p&gt; &lt;h4 id=\"three\"&gt;three&lt;/h4&gt; &lt;p&gt;Ad leggings keytar, brunch id art party dolor labore. Pitchfork yr enim lo-fi before they sold out qui. Tumblr farm-to-table bicycle rights whatever. Anim keffiyeh carles cardigan. Velit seitan mcsweeney's photo booth 3 wolf moon irure. Cosby sweater lomo jean shorts, williamsburg hoodie minim qui you probably haven't heard of them et cardigan trust fund culpa biodiesel wes anderson aesthetic. Nihil tattooed accusamus, cred irony biodiesel keffiyeh artisan ullamco consequat.&lt;/p&gt; &lt;p&gt;Keytar twee blog, culpa messenger bag marfa whatever delectus food truck. Sapiente synth id assumenda. Locavore sed helvetica cliche irony, thundercats you probably haven't heard of them consequat hoodie gluten-free lo-fi fap aliquip. Labore elit placeat before they sold out, terry richardson proident brunch nesciunt quis cosby sweater pariatur keffiyeh ut helvetica artisan. Cardigan craft beer seitan readymade velit. VHS chambray laboris tempor veniam. Anim mollit minim commodo ullamco thundercats. &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果如下所示： 开发者也可以对导航标签的切换事件进行监听，方法如下： 1234$('#navbar').on('activate.bs.scrollspy',function(e)&#123; console.log(\"滚动导航改变\");&#125;) 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/scrollJS.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"JavaScript基础之一——语句与数据类型","slug":"293JavaScript基础之一——语句与数据类型","date":"2016-12-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.361Z","comments":true,"path":"2016/12/28/293JavaScript基础之一——语句与数据类型/","link":"","permalink":"http://huishao.cc/2016/12/28/293JavaScript基础之一——语句与数据类型/","excerpt":"","text":"JavaScript基础之一——语句与数据类型JavaScript语句的编写十分自由，每行可以编写一句语句也可以编写多句语句。需要注意，如果开发者要在一行中编写多句语句，需要使用分号进行分割，示例如下： 12345//JS中的语句可以由分号结尾，也可以不写分号console.log(\"无分号结尾语句\")console.log(\"有分号结尾语句\");//如果要在同一行中写多个语句 需要用分号进行分割 最后一句语句可以不带分号console.log('组');console.log('合') JavaScript语言是一种对大小写十分敏感的语言，大小写字母不同的变量，函数在JavaScript中被认定为两个变量或函数，如下： 123//JS是对大小写敏感的 大写字母与小写字母在JS中是不同的var name = 'jaki';var NAME = 'JAKI'; 在字符串中，开发者可以使用反斜杠来进行折行，示例如下： 12345//对于字符串 支持使用\\进行折行 函数和关键字则不行var address = 'China \\ ShangHai. \\ 1102';console.log(address); 需要注意，函数名、关键字等不能够进行折行操作。 JavaScript中的注释分为两种，使用//进行单行注释和使用/**/进行多行注释，示例如下： 12345//注释可以是这样的单行注释/*也可以是多行注释类似这样的*/ 需要注意，JavaScript中的注释不能嵌套，这和Swift语言有区别，如下的写法会报错： 12345/*/*嵌套*/也可以是多行注释类似这样的*/ 在JavaScript中使用var关键字来声明变量，声明变量的时候可以直接赋值也可以不进行赋值，在同一行语句中可以同时声明多个变量，示例如下： 1234567//JS使用var来进行变量的声明var obj1;obj1 = 'OBJ'//变量在声明的时候 也可以直接赋值var obj2 = 'OBJ'//一条语句中也可以声明多个变量 使用,进行分割var obj3 = 2,obj4 = 1.5,obj5=\"OBJ\" JavaScript语言拥有动态的数据类型，虽然在变量声明上，JavaScript与Swift语言有些相似，但其本质完全不同，Swift语言是强类型语言，在变量声明时不指定类型的原因是Xcode工具会自动推断变量类型，并且Swift语言中的变量类型一旦确定则不能更改，JavaScript则不然，其是根据所分配的值的类型来确定变量的类型，示例如下： 1234//JS中的基本数据类型//JS是动态类型语言 同一个变量可以接收不同数据类型的数据var obj6 = 6;//数字obj6 = \"6\";//字符串 JavaScript中的字符串可以使用单引号也可以使用双引号，需要注意，如果在字符串中要引用字符串，需要交替使用单双引号，示例如下： 123456//如果在字符串内需要引用字符串 需要交替单引号与双引号obj6='你好\"jaki\"';obj6=\"你好'Jaki'\";console.log(obj6);//typeof()用于获取变量类型console.log(typeof(obj6)); 在JavaScript中，部分整型与浮点型，都统一为数字类型，示例如下： 12345//JS只有一种数字类型 可以是小数 也可以是整数var obj8 = 34;var obj9 = 55.4;console.log(typeof(obj8));console.log(typeof(obj9)); JavaScript中使用布尔类型来表示逻辑值，布尔类型只有两种值，true或者false，示例如下： 1234//布尔类型var obj10 = true;var obj11 = false;console.log(typeof(obj11)); JavaScript中有两种方式来创建数组，示例如下： 12345//数组var className = ['1','2','3'];var peoples = new Array(\"jaki\",\"annay\",\"marck\");console.log(className[1]);console.log(peoples); 需要注意，数组的下标从0开始。 JavaScript中最常用的数据类型要属对象了，JavaScript中定义对象的方式如下： 12345//对象var student = &#123;name:'jaki',age:24&#125;;console.log(typeof(student));console.log(student.name);console.log(student['age']); 对象中定义的键值对被称为对象的属性，访问对象的属性有两种方法，一种是通过点语法，一种是通过键名。 除了上述数据类型外，JavaScript中还有两种特殊的数据类型，undefined与null，前者表示未定义，后者表示空，如果只是声明了变量，没做赋值，则此变量就是未定义的，示例如下： 123456//Undefined表示为定义 null表示空值var uni;var cz = 5;cz = null;console.log(uni);console.log(cz); 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记十七——下拉列表交互","slug":"291Bootstrap响应式前端框架笔记十七——下拉列表交互","date":"2016-12-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.360Z","comments":true,"path":"2016/12/27/291Bootstrap响应式前端框架笔记十七——下拉列表交互/","link":"","permalink":"http://huishao.cc/2016/12/27/291Bootstrap响应式前端框架笔记十七——下拉列表交互/","excerpt":"","text":"Bootstrap响应式前端框架笔记十七——下拉列表交互为dropdown-toggle类添加data-toggle=&quot;dropdown&quot;属性可以实现其下拉列表功能的绑定，示例如下： 1234567891011121314151617181920&lt;div class=\"dropdown col-md-2\" id=\"drop\"&gt; &lt;button class=\"btn dropdown-toggle btn-primary\" data-toggle=\"dropdown\"&gt; 下拉列表 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt; &lt;a&gt;金牛座&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;摩羯座&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;狮子座&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;白羊座&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 点击此按钮后，可以自动实现下拉列表的显示或隐藏。 Bootstrap中的下拉列表控件也定义了一些方法回调，其会在drop-menu的父标签上进行绑定，示例如下： 123456789101112$('#myDropMenu').on('show.bs.dropdown',function()&#123; console.log(\"下拉框将要展示\");&#125;);$('#myDropMenu').on('shown.bs.dropdown',function()&#123; console.log(\"下拉框已经展示\");&#125;);$('#myDropMenu').on('hide.bs.dropdown',function()&#123; console.log(\"下拉框将要隐藏\");&#125;);$('#myDropMenu').on('hidden.bs.dropdown',function()&#123; console.log(\"下拉框已经展示\");&#125;); 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/dropdownJS.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"配置Sublime Text工具运行JavaScript代码","slug":"292配置Sublime Text工具运行JavaScript代码","date":"2016-12-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.360Z","comments":true,"path":"2016/12/27/292配置Sublime Text工具运行JavaScript代码/","link":"","permalink":"http://huishao.cc/2016/12/27/292配置Sublime Text工具运行JavaScript代码/","excerpt":"","text":"配置Sublime Text工具运行JavaScript代码SublimeText是一款及强大的跨平台编辑器，其丰富的插件可以帮助开发者编写各种语言的代码。并且其自带控制台，开发者实现简单的配置即可在SublimeText控制台中进行代码的调试运行。 在SublimeText中运行JavaScript代码十分简单，实现运行JavaScript代码需要借助node.js环境，首先需要安装node.js环境，node.js环境可以在如下网址进行下载安装： https://nodejs.org/en/。 安装完成node环境后，在终端输入如下命令获取node的路径： 1which node 示例如下： 打开SublimeText编辑器，在菜单中的Tools-&gt;Build System-&gt;New Build System，如下图： 需要注意，图中的JavaScript是我配置完成后增加的，默认是无法运行JavaScript代码的，Build System中也不会有这一项。 在新建的文件中写入如下信息后进行保存： 1234&#123; \"cmd\": [\"/usr/local/bin/node\", \"$file\"], \"selector\": \"source.js\" &#125; 注意cmd数组中的第一个对象是刚才从终端查到的node路径，selector对应要编译的文件后缀。 进行保存，将其文件名命名为JavaScript(其实什么都可以)。 新建一个SublimeText文件，将其保存为js文件，在其中编写JavaScript代码，使用command+B(Mac)即可进行JavaScript代码的运行，效果如下： 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"ReactNative应用之汇率换算器开发全解析","slug":"289ReactNative应用之汇率换算器开发全解析","date":"2016-12-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.359Z","comments":true,"path":"2016/12/26/289ReactNative应用之汇率换算器开发全解析/","link":"","permalink":"http://huishao.cc/2016/12/26/289ReactNative应用之汇率换算器开发全解析/","excerpt":"","text":"ReactNative应用之汇率换算器开发全解析一、引言本篇博客将介绍如何开发一款简易的ReactNative小应用汇率换算器。本应用仅作为学习使用，其支持在人民币与美元间进行汇率计算。汇率计算器应用主要分为两部分：键盘与显示屏。键盘提供给与用户进行输入，在显示屏上进行汇率换算结果的显示。复杂的界面无非是简单组件的组合使用，因此，在进行开发之前，我们可以思考可能需要使用到的独立组件的开发，例如键盘按钮的开发，有键盘按钮组成的键盘的开发，显示屏开发等。首先创建一个初始的ReactNative工程，将index.ios.js与index.android.js文件中的内容全部删掉。在项目根目录中新建4个目录，分别为const、controller、image和view。这4个目录用于存放后面我们需要新建的静态文件，控制器文件，图片素材和视图文件。 二、用户键盘的封装在view文件夹下新建一个KeyButton.js文件，其用来创建键盘上的独立按钮，将其实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123; Component,PropTypes &#125; from 'react';import &#123; TouchableHighlight, Text, StyleSheet, Image&#125; from 'react-native';export default class KeyButton extends Component&#123; render()&#123; //根据number属性来做判断 if (this.props.number == '删') &#123; return( &lt;TouchableHighlight underlayColor='#f06d30' style=&#123;[keyButtonStyles.buttonStyleNormal,&#123;alignItems:'center'&#125;]&#125; onPress=&#123;this.props.buttonPress.bind(this,this.props.number)&#125;&gt; &lt;Image source=&#123;require('../image/delete.png')&#125;/&gt; &lt;/TouchableHighlight&gt; ); &#125;; //特殊按钮需要状态来判断 var buttonStyle; if(this.props.number == 'C' || this.props.number == '=')&#123; buttonStyle = keyButtonStyles.buttonStyleSpecial; &#125;else&#123; buttonStyle = keyButtonStyles.buttonStyleNormal; &#125; return( &lt;TouchableHighlight underlayColor='#f06d30' style=&#123;buttonStyle&#125; onPress=&#123;this.props.buttonPress.bind(this,this.props.number)&#125;&gt; &lt;Text style=&#123;keyButtonStyles.textStyle&#125;&gt;&#123;this.props.number&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ); &#125;&#125;//配置样式列表const keyButtonStyles = StyleSheet.create(&#123; //正常按钮样式 buttonStyleNormal:&#123; flex:1, backgroundColor:'#323637', justifyContent: 'center', &#125;, //特殊按钮样式 buttonStyleSpecial:&#123; flex:1, backgroundColor:'#f06d30', justifyContent: 'center', &#125;, //文本样式 textStyle:&#123; color:'white', textAlign:'center', fontSize:30 &#125;&#125;); 上面代码中预留number属性作为按钮的标题，不同的按钮可能带有不同的样式，同样通过这个属性来做区分。按钮的触发事件绑定给了buttonPress属性，并且在按钮触发执行时，将按钮的number属性传递出去。 在const文件夹下创建一个Const,js文件，这个文件中用来定义全局的一些样式，实现如下： 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; StyleSheet &#125; from 'react-native';export default mainViewStyles = StyleSheet.create(&#123; //主界面容器的样式 container:&#123; flex:1, flexDirection:'column', backgroundColor:'black' &#125;, //显示屏的样式 screenView:&#123; flex:3, backgroundColor:'#f06d30' &#125;, //键盘的样式 keyboardView:&#123; flex:7, backgroundColor:'#323637' &#125;&#125;); 在View文件夹下新建一个KeyboardView.js文件，将其作为键盘视图类，将其实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react';import &#123; View, Text, StyleSheet &#125; from 'react-native';import KeyButton from './KeyButton';import mainViewStyles from '../const/Const';export default class KeyboardView extends Component &#123; render()&#123; return( &lt;View style=&#123;mainViewStyles.keyboardView&#125;&gt; &lt;View style=&#123;keyboardViewStyles.keyboardRow&#125;&gt; &lt;KeyButton number='1' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='2' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='3' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='删' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;keyboardViewStyles.keyboardRow&#125;&gt; &lt;KeyButton number='4' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='5' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='6' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='0' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;keyboardViewStyles.keyboardRow&#125;&gt; &lt;KeyButton number='7' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='8' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='9' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='.' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;/View&gt; &lt;View style=&#123;keyboardViewStyles.keyboardRow&#125;&gt; &lt;KeyButton number='C' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='-' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='+' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;KeyButton number='=' buttonPress=&#123;this.props.buttonPress&#125;/&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const keyboardViewStyles = StyleSheet.create(&#123; keyboardRow:&#123; flex:1, backgroundColor:'black', flexDirection:'row' &#125;&#125;); 上面以九宫格的布局模式创建了16个功能按钮，并且将按钮的点击事件属性绑定给键盘的buttonPress属性，由上层视图来做处理，这里使用了flex权重的布局模式。 至此，键盘部分先告一段落，我们需要对显示屏进行开发，在View文件夹下新建一个ScreenView.js文件，将其作为显示屏视图类，显示屏类和键盘比起来要复杂许多，因为其要实现各种屏幕操作功能，例如回退，删除，清空，计算等，实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import React, &#123; Component &#125; from 'react';import &#123; View, Text, StyleSheet, TouchableHighlight, Image &#125; from 'react-native';import mainViewStyles from '../const/Const';export default class ScreenView extends Component &#123; constructor(props) &#123; super(props); //这三个状态分别用来标记是美元转人民币或者人民币转美元，美元数，人民币数 this.state = &#123; transUS:true, USMoney:'0', CHMoney:'0' &#125;; let __this = this; //进行美元转人民币或者人民币转美元转换时调用 this.change = function()&#123; __this.setState(&#123;transUS:!__this.state.transUS&#125;); &#125;; //数字类按钮被点击触发的方法 this.buttonClick = function(count)&#123; var us=__this.state.USMoney,ch=__this.state.CHMoney; if (__this.state.transUS) &#123; if (us=='0') &#123;us=count;&#125;else&#123;us=__this.state.USMoney+count;&#125;; &#125;else&#123; if (ch=='0') &#123;ch=count;&#125;else&#123;ch=__this.state.CHMoney+count;&#125;; &#125;; __this.setState(&#123; USMoney:us, CHMoney:ch &#125;); &#125;; //清除按钮被点击触发的方法 this.clear = function()&#123; __this.setState(&#123; USMoney:'0', CHMoney:'0' &#125;); &#125;; //回退按钮被点击触发的方法 this.delete = function()&#123; if (__this.state.transUS) &#123; if (__this.state.USMoney.length&gt;1) &#123; let newUS = __this.state.USMoney.substring(0,__this.state.USMoney.length-1); __this.setState(&#123;USMoney:newUS&#125;); &#125;else if(__this.state.USMoney&gt;'0')&#123; __this.setState(&#123;USMoney:'0'&#125;); &#125; &#125;else&#123; if (__this.state.CHMoney.length&gt;1) &#123; let newCH = __this.state.CHMoney.substring(0,__this.state.CHMoney.length-1); __this.setState(&#123;CHMoney:newCH&#125;); &#125;else if(__this.state.CHMoney&gt;'0')&#123; __this.setState(&#123;CHMoney:'0'&#125;); &#125; &#125; &#125;; //减号触发的方法 this.sub = function()&#123; if (__this.state.transUS) &#123; if(__this.state.USMoney&gt;'0')&#123; let newUS = (parseInt(__this.state.USMoney)-1).toString(); __this.setState(&#123;USMoney:newUS&#125;); &#125; &#125;else&#123; if(__this.state.CHMoney&gt;'0')&#123; let newCH = (parseInt(__this.state.CHMoney)-1).toString(); __this.setState(&#123;CHMoney:newCH&#125;); &#125; &#125; &#125;; //加号触发的方法 this.add = function()&#123; if (__this.state.transUS) &#123; let newUS = (parseFloat(__this.state.USMoney)+1).toString(); __this.setState(&#123;USMoney:newUS&#125;); &#125;else&#123; let newCH = (parseFloat(__this.state.CHMoney)+1).toString(); __this.setState(&#123;CHMoney:newCH&#125;); &#125; &#125;; //进行汇率转换 this.trans = function()&#123; if (__this.state.transUS) &#123; let us = parseFloat(__this.state.USMoney); __this.setState(&#123;CHMoney:(us*6.7).toFixed(2).toString()&#125;); &#125;else&#123; let ch = parseFloat(__this.state.CHMoney); __this.setState(&#123;USMoney:(ch/6.7).toFixed(2).toString()&#125;); &#125; &#125; &#125; render()&#123; let transText = this.state.transUS?\"从美元\":\"从人民币\"; let transToText = this.state.transUS?\"到人民币\":\"到美元\"; let topText = this.state.transUS?this.state.USMoney+'$':this.state.CHMoney+'￥'; let bottomText = this.state.transUS?this.state.CHMoney+'￥':this.state.USMoney+'$'; return( &lt;View style=&#123;mainViewStyles.screenView&#125;&gt; &lt;Text style=&#123;&#123; color:'white', textAlign:'right', marginRight:20, marginTop:20, fontSize:17 &#125;&#125;&gt;&#123;transText&#125;&lt;/Text&gt; &lt;Text style=&#123;&#123; color:'white', textAlign:'right', fontSize:37, marginRight:20, &#125;&#125;&gt;&#123;topText&#125;&lt;/Text&gt; &lt;View style=&#123;&#123; flexDirection:'row', zIndex:100, marginTop:-7.5 &#125;&#125;&gt; &lt;TouchableHighlight underlayColor='#f06d30' style=&#123;&#123; left:50, marginTop:0, &#125;&#125; onPress=&#123;this.change&#125;&gt; &lt;Image source=&#123;require('../image/exchange.png')&#125;/&gt; &lt;/TouchableHighlight&gt; &lt;View style=&#123;&#123; marginLeft:70, height:1, backgroundColor:'white', marginTop:10, flex:1 &#125;&#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;Text style=&#123;&#123; marginTop:10, color:'white', textAlign:'right', fontSize:17, marginRight:20, marginTop:-3, zIndex:99 &#125;&#125;&gt;&#123;transToText&#125;&lt;/Text&gt; &lt;Text style=&#123;&#123; color:'white', textAlign:'right', fontSize:37, marginRight:20 &#125;&#125;&gt;&#123;bottomText&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 封装好了键盘与显示屏，我们需要将其联动结合起来，在View文件夹下再创建一个MainView.js文件，实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, &#123; Component &#125; from 'react';import &#123; View, Text, StyleSheet &#125; from 'react-native';import KeyboardView from './KeyboardView';import mainViewStyles from '../const/Const';import ScreenView from './ScreenView';// 汇率换算器主界面视图export default class MainView extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; let __this = this; return ( &lt;View style=&#123;mainViewStyles.container&#125;&gt; &lt;ScreenView ref=\"screenView\"/&gt; &lt;KeyboardView buttonPress=&#123;function(title)&#123; __this.buttonPress(title); &#125;&#125;/&gt; &lt;/View&gt; ) &#125; buttonPress(title)&#123; //根据按键类型进行相关功能调用 if (title=='删') &#123; this.refs.screenView.delete(); &#125;else if(title=='C')&#123; this.refs.screenView.clear(); &#125;else if(title=='-')&#123; this.refs.screenView.sub(); &#125;else if(title=='+')&#123; this.refs.screenView.add(); &#125;else if(title=='=')&#123; this.refs.screenView.trans(); &#125;else&#123; this.refs.screenView.buttonClick(title); &#125; &#125;&#125; 到此，ReactNative应用汇率转换器的核心功能已经全部完成了，此应用只有一个界面，其实我们已经可以直接将MainView组建注册为项目的根组建，但是如果是多界面的应用，我们最好再使用Controller将其进行封装，在Controller文件夹下创建一个MainViewController.js文件，为其提供一个view()方法，如下： 1234567891011import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text &#125; from 'react-native';import MainView from '../View/MainView';export class MainViewController&#123; view()&#123; return( &lt;MainView /&gt; ); &#125;&#125; 修改index.ios.js与index.android.js文件如下： 1234567891011121314151617import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text&#125; from 'react-native';import &#123; MainViewController&#125; from './Controller/MainViewController';class News extends Component &#123; render() &#123; let controller = new MainViewController(); return controller.view(); &#125;&#125;AppRegistry.registerComponent('News', () =&gt; News); 运行项目，效果如下图： iOS： android： 本项目的完整代码github地址如下： https://github.com/ZYHshao/ReactNative-ExchangeRate。 ReactNative兴趣群：605794212，欢迎交流学习。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://huishao.cc/categories/ReactNative/"}],"tags":[],"keywords":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://huishao.cc/categories/ReactNative/"}]},{"title":"Bootstrap响应式前端框架笔记十六——模态框交互","slug":"290 Bootstrap响应式前端框架笔记十六——模态框交互","date":"2016-12-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.360Z","comments":true,"path":"2016/12/26/290 Bootstrap响应式前端框架笔记十六——模态框交互/","link":"","permalink":"http://huishao.cc/2016/12/26/290 Bootstrap响应式前端框架笔记十六——模态框交互/","excerpt":"","text":"Bootstrap响应式前端框架笔记十六——模态框交互模态框也可以称为弹出窗，其作用是当用户点击某个功能按钮后，在网页上弹出一个内容窗口。在Bootstrap中，创建模态框十分简单。首先模态框组件通过modal类来创建，其默认隐藏，开发者可以使用data相关属性来将其唤出。简单示例如下： 12345678910111213141516171819202122232425262728&lt;button type=\"button\" class=\"btn btn-primary btn-lg\" data-toggle=\"modal\" data-target=\"#myModal\"&gt;正常模态框&lt;/button&gt;&lt;!--这里设置的id用于绑定在按钮事件上--&gt;&lt;div class=\"modal fade\" id=\"myModal\" tabindex=\"-1\"&gt; &lt;!--modal-dialog为悬浮框模式的模态框--&gt; &lt;div class=\"modal-dialog\"&gt; &lt;!--模态框组件内容部分--&gt; &lt;div class=\"modal-content\"&gt; &lt;!--头部内容--&gt; &lt;div class=\"modal-header\"&gt; &lt;!--为按钮绑定data-dismiss=\"modal\"可以实现点击取消模态框--&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&lt;span&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class=\"modal-title\" id=\"myModalLabel\"&gt;模态框标题&lt;/h4&gt; &lt;/div&gt; &lt;!--模态框主体内容--&gt; &lt;div class=\"modal-body\"&gt; 模态框内容 &lt;/div&gt; &lt;!--模态框尾部内容--&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"&gt;关闭&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\" data-dismiss=\"modal\"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 可以为model-dialog类增加modal-lg或者modal-sm可以创建大号的模态框或者小号的模态框。需要注意，模态框的弹出时有渐入动画的，如果不需要动画效果，只需要将fade类去掉即可。 对于定义为modal模块的div，开发者也可以通过设置data属性的方式来对模态框进行设置，列举如下： | data-backdrop | 布尔”true”或”false” | 如果设置为true，则显示灰色背景，否则不显示灰色背景 || data-keyboard | 布尔值 | 设置点击键盘esc键是否隐藏模态框，注意，必须设置tabindex属性，这个值才有效 || data-show | 布尔值 | 模态框初始化后是否立即展示 || data-remote | 路径 | 如果配置了url，会将内容加载进modal-content中 | modal模块也支持通过js代码来进行相关控制，支持的方法如下： 12345678910111213141516171819 $('#open').on(\"click\",function()&#123; //展示模态框 $('#myModal').modal('show');&#125;);$('#close').on(\"click\",function()&#123; //隐藏模态框 $('#myModal').modal('hide');&#125;);$('#exchange').on(\"click\",function()&#123; //显示或隐藏进行切换 $('#myModal').modal('toggle');&#125;);$('#setting').on(\"click\",function()&#123; //对模态框的属性进行设置 传入对象 $('#myModal').modal(&#123; keyboard:false &#125;);&#125;); 模态框也可以添加一些特有的事件回调，示例如下： 123456789101112131415$('#myModal').on('show.bs.modal',function(e)&#123; console.log(\"模态框将要展示触发\")&#125;);$('#myModal').on('shown.bs.modal',function(e)&#123; console.log(\"模态框已经展示后触发\")&#125;);$('#myModal').on('hide.bs.modal',function(e)&#123; console.log(\"模态框将要消失触发\")&#125;);$('#myModal').on('hidden.bs.modal',function(e)&#123; console.log(\"模态框已经消失后触发\")&#125;);$('#myModal').on('loaded.bs.modal',function(e)&#123; console.log(\"从远端数据源加载数据完成\")&#125;); 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/modelJS.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"ReactNative开发环境的搭建与开发前准备","slug":"288ReactNative开发环境的搭建与开发前准备","date":"2016-12-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.359Z","comments":true,"path":"2016/12/23/288ReactNative开发环境的搭建与开发前准备/","link":"","permalink":"http://huishao.cc/2016/12/23/288ReactNative开发环境的搭建与开发前准备/","excerpt":"","text":"ReactNative开发环境的搭建与开发前准备一、准备工作在ReactNative中文网上有详细的开发文档与教程，首先，想要系统了解ReactNative的朋友可以在如下网站中获取详细信息： http://reactnative.cn/。 本篇博客记录搭建ReactNative开发环境中的一些问题与注意点，也介绍在MacOS系统上搭建ReactNative开发环境的全过程与一些小经验技巧。 ReactNative最大的魅力在于其编写的代码可以跨平台应用，因此我极力推荐在MacOS上进行ReactNative应用的开发，由于Xcode开发工具只能运行与MacOS系统，在Windows或Linux系统上将无法进行iOS平台的调试，因此本篇博客也将基于MacOS系统进行演示。 在ReactNative环境之前，开发者需要先安装一些小工具，首先需要安卓Homebrew工具，Homebrew工具是Mac系统的包管理器，在终端运行如下命令进行安装： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装完成后，可以使用brew -v命令检查Homebrew版本，正常输出版本号说明安装成功： 在安装过程中，如果遇到权限问题，需要使用如下命令进行修复： 1sudo chown -R `whoami` /usr/local 安装完成Homebrew后，需要使用其来进行Node环境的安装，使用如下命令： 安装完成后，同样可以使用node -v命令来检查是否安装成功： 虽然Yarn是facebook提供的代替npm的包管理工具，但我个人更倾向使用npm来进行ReactNative包的安装，在使用之前，可以通过替换源镜像的方式来进行npm的加速(在无法科学上网的前提下): 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 之后使用npm config get registry来检查源镜像的替换是否成功： 之后我们需要安装ReactNative的命令行工具react-natice-cli。这个工具用来初始化ReactNative项目，命令如下： 1npm install -g react-native-cli 使用react-native -v命令来检查是否安装成功： 到此，ReactNative的基础环境已经搭建完成了，下面需要配置iOS与Android开发工具。 二、Xcode与Android Studio配置Xcode基本无需进行额外的配置，你只需要从AppStore上下载下来最新版本的Xcode开发工具安装完成即可，Xcode会打包安装命令行工具，git工具和所需要的模拟器。 对于Android开发环境，首先你需要保证你的Android Studio工具版本在2.0以上并且Java版本要在1.8以上，javac -version命令可以查看当前的JDK版本，如果低于1.8，可以到官网下载： 官网：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html。 下载安装完成Android Studio后，首先需要对SDK进行相应配置，打开Android Studio，打开欢迎界面的SDK Manager，如下图： 选中其中的SDK Platforms，勾选Show Package Details。我选择Android6.0相关的SDK进行安装，Android SDK Platform 23,Intel x86 Atom_64 System Image为必选， 如下图所示： 除此之外，还需要安装SDK Tools，必须安装其中的23.0.1版本，切记，这是必须！如下图： 之后随便使用Android Studio创建一个项目，打开其中的AVD Manager，如下： AVD Manager用来管理Android模拟器，如果以后模拟器，可以点击运行按钮开运行模拟器，如果没有，可以创建一个模拟器，如下图： 做完上述步骤后，切记要配置Android SDK的环境变量，在终端使用如下命令进行环境变量文件的编辑： 1sudo vi ~/.bash_profile 在文件中添加如下路径： 1export ANDROID_HOME=~/Library/Android/sdk 之后在终端执行如下命令来使设置生效： 1source ~/.bash_profile 可以使用echo $ANDROID_HOME命令来检查环境变量的配置是否正确，如下： 三、运行第一个项目HelloWorld如果上面的环境配置和开发工具的配置都已顺利完成，那么你离第一个ReactNative项目已经不远了，下面我们来通过ReactNative创建HelloWorld项目。 在终端运行react-native init HelloWorld命令来创建ReactNative项目，这个命令是一个一站式集成命令，其会创建项目并且将所有依赖包都安装完成。命令成功执行后，进入到项目根目录中，如下： 使用react-native run-ios或者react-native run-android来进行iOS项目或者Android项目的运行，如果你看到如下图所示的界面，恭喜你，你的ReactNative项目已经可以跑起来了(需要注意：运行安卓项目的时候，安卓模拟器必须先启动)： 需要注意，运行iOS项目时，会默认启动Xcode的默认模拟器，如果要启动特定的模拟器，可以使用如下命令： 1react-native run-ios --simulator &quot;iPhone SE&quot; xcrun simctl list devices命令可以打印出所有可用的iOS模拟器，示例如下： 观察HelloWorld项目结构，其目录如下图： 其中node_modules为node依赖包的目录，andorid文件夹为安卓项目目录，ios文件夹为iOS项目目录。index.android.js与index.ios.js两个文件是最为重要的两个文件，这两个文件是iOS项目与Android项目的入口文件，打开index.ios.js文件，将其中的代码修改如下： 123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, StyleSheet, Text, View&#125; from 'react-native';export default class HelloWorld extends Component &#123; render() &#123; return ( &lt;Text style=&#123;&#123; flex:1, top:100, left:100, fontSize:30 &#125;&#125;&gt;HelloWorld&lt;/Text&gt; ); &#125;&#125;AppRegistry.registerComponent('HelloWorld', () =&gt; HelloWorld); 上面的代码就是一个最简单的项目HelloWorld，在iOS模拟器中使用command+R来进行界面的刷新，效果如下： 在安卓模拟器中双击R键来进行界面的刷新。 提示：如果在iOS模拟器中使用command+R无效，需要将模拟器的Connect Hardware Keyboard进行勾选，如下： 四、ReactNative开发工具的选择facebook提供了一个叫做Nuclide的工具专门开发ReactNative应用，其实一个基于atom的集成开发环境，但是我个人更喜欢使用SublimeText来进行ReactNative应用的开发。通过安装相应的插件，SublimeText来编写ReactNative应用将十分畅快。 首先下载SublineText编辑工具，可以在官网进行下载： http://www.sublimetext.com/。 在对SublimeText进行插件安装前，需要先为其安装包管理工具PackageControl。在SublimeText工具的导航中选择View下的Show Console来打开命令行，如下： 在命令行中输入如下代码进行，敲击回车进行安装： SublimeText2： 1import urllib2,os; pf='Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), 'wb' ).write( urllib2.urlopen( 'http://sublime.wbond.net/' +pf.replace( ' ','%20' )).read()); print( 'Please restart Sublime Text to finish installation') SublimeText3: 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 由于网络等多种原因，上面使用代码安装PackageControl的方法很大可能会失败，我们也可以从官网下载安装包，将其放在SublimeText的包安装目录中，重启SublimeText来进行安装，点击SublimeText的Preferences-&gt;Browse Packages选项可以浏览SublimeText的包目录： 将下载好的PackageControl安装包放入Installed Package目录中重启即可，如果没有这个目录，可以手动创建： PackageControl的官方下载地址为：http://sublime.wbond.net/Package%20Control.sublime-package。 温馨提示：PackageControl的官方下载地址访问起来也有一定难度，我将这个安装包放在了我的github上一份，如果需要，可以从下面的地址下载： http://zyhshao.github.io/file/Package%20Control.sublime-package。 安装完成PackageControl工具后，即可使用其来进行SublimeText插件的安装。 在SublimeText中选择Preferences-&gt;PackageControl即可调出PackageControl命令面板，如下： PackageControl中提供了许多实用的方法，例如install Package用来安装插件，List Packages用来查看已经安装过的插件，Remove Package用来删除一个已经安装的插件等，如下： 点击Install Package进入SublimeText插件的搜索界面，搜索到所需要安装的插件安装即可，如下： 温馨提示：在使用PackageContrl的Install Package命令时，很有可能会出现超时问题，原因是PackageControl需要拉取一个channels文件列表，而这个文件在国内往往难以访问到，我也在我的github上存放了一份备份，需要将PackageControl的channels拉取路径做下修改，选择SublimeText的Preferences-&gt;PackageSettings-&gt;PackageControl-&gt;Settings-Default选项，如下： 将其中的channels参数修改如下即可： 123&quot;channels&quot;: [ &quot;http://zyhshao.github.io/file/channel_v3.json&quot;], 五、推荐几个编写ReactNative好用的SublimeText插件插件一：EmmetEmmet插件是前端神器，其提供了js的自动补全功能，使用PackageControl搜索安装emmet插件后，打开SublimeText中的Preferences-&gt;Package Settings-&gt;Emmet-&gt;Key Bindings-User，将其文件修改为如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344[&#123; \"keys\": [\"tab\"], \"command\": \"expand_abbreviation_by_tab\", // put comma-separated syntax selectors for which // you want to expandEmmet abbreviations into \"operand\" key // instead of SCOPE_SELECTOR. // Examples: source.js, text.html - source \"context\": [&#123; \"operand\": \"source.js\", \"operator\": \"equal\", \"match_all\": true, \"key\": \"selector\" &#125;, // run only if there's no selected text &#123; \"match_all\": true, \"key\": \"selection_empty\" &#125;, // don't work if there are active tabstops &#123; \"operator\": \"equal\", \"operand\": false, \"match_all\": true, \"key\": \"has_next_field\" &#125;, // don't work if completion popup is visible and you // want to insert completion with Tab. If you want to // expand Emmet with Tab even if popup is visible -- // remove this section &#123; \"operand\": false, \"operator\": \"equal\", \"match_all\": true, \"key\": \"auto_complete_visible\" &#125;, &#123; \"match_all\": true, \"key\": \"is_abbreviation\" &#125; ]&#125;] 插件二：jsformatjsformat插件可以进行js代码的格式化，使用PackageControl安装完成后，选中js代码，使用control+option+f即可进行代码的格式化操作。 插件三：ReactJSReactJS插件支持对React代码进行高亮，并且支持快捷创建函数，原型等操作，熟练使用可以大大提高开发效率，其用法github如下： https://github.com/facebookarchive/sublime-react。 插件四：TerminalTerminal也是SublimeText开发ReactNative应用神器，安装好后，使用command+shift+T可以直接在当前目录打开终端。 插件五：react-native-snippetsreact-native-snippets可以快速的创建ReactNative类等代码块，用法github如下： https://github.com/Shrugs/react-native-snippets。 最后，再推荐一款SublimeText皮肤Hero，我个人非常喜欢这款皮肤，其安装与配置方法在如下github上有详细介绍： https://github.com/nickbalestra/hero。 效果如下： 有了上面的这些工具，我们的SublimeText就编程了一款强大ReactNative开发IDE，尽情享受畅快编码的感觉吧！ 到此为止，本篇博客将所有开发ReactNative应用的准备工作已经介绍完毕，后面的博客将记录手把手开发一款ReactNative应用程序的学习过程：ReactNative简易汇率换算器！期待与您的共同交流与进步！ ReactNative兴趣群：605794212，欢迎交流学习。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://huishao.cc/categories/ReactNative/"}],"tags":[],"keywords":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://huishao.cc/categories/ReactNative/"}]},{"title":"Bootstrap响应式前端框架笔记十五——面板与井","slug":"287Bootstrap响应式前端框架笔记十五——面板与井","date":"2016-12-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.359Z","comments":true,"path":"2016/12/22/287Bootstrap响应式前端框架笔记十五——面板与井/","link":"","permalink":"http://huishao.cc/2016/12/22/287Bootstrap响应式前端框架笔记十五——面板与井/","excerpt":"","text":"Bootstrap响应式前端框架笔记十五——面板与井Bootstrap中的面板由pannel相关类来创建，一个完整的面板分为面板头部、面板体和面板注脚，并且Bootstrap中默认定义了一些面板风格，示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;p&gt;标准样式的面板&lt;/p&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; 面板标题 &lt;/div&gt; &lt;div class=\"panel-body\"&gt; 面板内容......... &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; 面板注脚.......... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; 面板标题 &lt;/div&gt; &lt;div class=\"panel-body\"&gt; 面板内容......... &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; 面板注脚.......... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-success\"&gt; &lt;div class=\"panel-heading\"&gt; 面板标题 &lt;/div&gt; &lt;div class=\"panel-body\"&gt; 面板内容......... &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; 面板注脚.......... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-info\"&gt; &lt;div class=\"panel-heading\"&gt; 面板标题 &lt;/div&gt; &lt;div class=\"panel-body\"&gt; 面板内容......... &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; 面板注脚.......... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-warning\"&gt; &lt;div class=\"panel-heading\"&gt; 面板标题 &lt;/div&gt; &lt;div class=\"panel-body\"&gt; 面板内容......... &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; 面板注脚.......... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-danger\"&gt; &lt;div class=\"panel-heading\"&gt; 面板标题 &lt;/div&gt; &lt;div class=\"panel-body\"&gt; 面板内容......... &lt;/div&gt; &lt;div class=\"panel-footer\"&gt; 面板注脚.......... &lt;/div&gt; &lt;/div&gt; 效果如下： 面板中也可以追加列表组，是的面板更具扩展性，示例如下： 123456789101112131415&lt;p&gt;在面板中追加列表组&lt;/p&gt;&lt;div class=\"panel panel-danger\"&gt; &lt;div class=\"panel-heading\"&gt; 面板标题 &lt;/div&gt; &lt;div class=\"panel-body\"&gt; 面板内容......... &lt;/div&gt; &lt;div class=\"list-group\"&gt; &lt;div class=\"list-group-item\"&gt;数据&lt;/div&gt; &lt;div class=\"list-group-item\"&gt;数据&lt;/div&gt; &lt;div class=\"list-group-item\"&gt;数据&lt;/div&gt; &lt;div class=\"list-group-item\"&gt;数据&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果如下： Bootstrap中还定义了一种样式Well，其效果类似嵌入界面内，示例如下： 1234&lt;p&gt;Well效果&lt;/p&gt;&lt;div class=\"well\"&gt; 这里是内容！！！！！！！&lt;/div&gt; 效果如下： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/pannelAndWell.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记十四——媒体对象与列表组","slug":"286Bootstrap响应式前端框架笔记十四——媒体对象与列表组","date":"2016-12-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.359Z","comments":true,"path":"2016/12/20/286Bootstrap响应式前端框架笔记十四——媒体对象与列表组/","link":"","permalink":"http://huishao.cc/2016/12/20/286Bootstrap响应式前端框架笔记十四——媒体对象与列表组/","excerpt":"","text":"Bootstrap响应式前端框架笔记十四——媒体对象与列表组在移动开发中经常会使用到列表，使用媒体对象可以方便的创建列表中每一行元素，常规的媒体对象实例如下： 12345678910&lt;p&gt;常规的媒体对象&lt;/p&gt;&lt;div class=\"media\"&gt; &lt;div class=\"media-left\"&gt; &lt;img src=\"image/icon.png\" /&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;社科院：经济不会发生硬着陆 警惕高房价对消费挤出效应&lt;/h4&gt; 从2010年开始中国经济增速逐年下滑，到2015年经济增速为6.9%，这是从1990年以来最低的增速，也是从改革开放以来首次连续六年经济增速下滑。由于今年前三季度经济增速为6.7%，北京大学国家发展研究院名誉院长、国务院参事林毅夫在18日举行的第一届国家发展论坛上表示， 2016年的经济增速还会继续下行，低于6.9%。 &lt;/div&gt; &lt;/div&gt; 效果如下图所示： 使用media-middle类与media-bottom类可以设置媒体对象居中或者底部对齐，示例如下： 12345678910111213141516171819&lt;p&gt;媒体对象居中显示&lt;/p&gt;&lt;div class=\"media\"&gt; &lt;div class=\"media-left media-middle\"&gt; &lt;img src=\"image/icon.png\" /&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;社科院：经济不会发生硬着陆 警惕高房价对消费挤出效应&lt;/h4&gt; 从2010年开始中国经济增速逐年下滑，到2015年经济增速为6.9%，这是从1990年以来最低的增速，也是从改革开放以来首次连续六年经济增速下滑。由于今年前三季度经济增速为6.7%，北京大学国家发展研究院名誉院长、国务院参事林毅夫在18日举行的第一届国家发展论坛上表示， 2016年的经济增速还会继续下行，低于6.9%。 &lt;/div&gt;&lt;/div&gt;&lt;br /&gt;&lt;p&gt;媒体对象底部对齐&lt;/p&gt;&lt;div class=\"media\"&gt; &lt;div class=\"media-left media-bottom\"&gt; &lt;img src=\"image/icon.png\" /&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;社科院：经济不会发生硬着陆 警惕高房价对消费挤出效应&lt;/h4&gt; 从2010年开始中国经济增速逐年下滑，到2015年经济增速为6.9%，这是从1990年以来最低的增速，也是从改革开放以来首次连续六年经济增速下滑。由于今年前三季度经济增速为6.7%，北京大学国家发展研究院名誉院长、国务院参事林毅夫在18日举行的第一届国家发展论坛上表示， 2016年的经济增速还会继续下行，低于6.9%。 &lt;/div&gt;&lt;/div&gt; 效果如下图所示： 在实际开发中，列表组的应用也十分广泛，Bootstrap中定义的列表组样式十分灵活，开发者可以灵活的对其进行自定义操作，示例如下： 1234567891011121314151617&lt;p&gt;列表组示例&lt;/p&gt;&lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item list-group-item-info\"&gt; 未读消息 &lt;span class=\"badge\"&gt;2&lt;/span&gt; &lt;/li&gt; &lt;li class=\"list-group-item list-group-item-success\"&gt; 个人中心 &lt;/li&gt; &lt;li class=\"list-group-item list-group-item-danger\"&gt; 退出登录 &lt;/li&gt; &lt;li class=\"list-group-item list-group-item-warning\"&gt; &lt;div class=\"list-group-item-heading\"&gt;温馨提示&lt;/div&gt; &lt;small&gt;更多功能请进个人中心&lt;/small&gt; &lt;/li&gt;&lt;/ul&gt; 效果如下图所示： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/medioAndListGroup.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记十三——警告框与进度条","slug":"285Bootstrap响应式前端框架笔记十三——警告框与进度条","date":"2016-12-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.358Z","comments":true,"path":"2016/12/19/285Bootstrap响应式前端框架笔记十三——警告框与进度条/","link":"","permalink":"http://huishao.cc/2016/12/19/285Bootstrap响应式前端框架笔记十三——警告框与进度条/","excerpt":"","text":"Bootstrap响应式前端框架笔记十三——警告框与进度条在Bootstrap中，使用alert相关类可以实现简洁的警告框控件，示例如下： 12345&lt;p&gt;alert相关类可以实现简洁的警告框样式&lt;/p&gt;&lt;div class=\"alert alert-success\"&gt;成功风格的警告框&lt;/div&gt;&lt;div class=\"alert alert-info\"&gt;详情风格的警告框&lt;/div&gt;&lt;div class=\"alert alert-warning\"&gt;警告风格的警告框&lt;/div&gt;&lt;div class=\"alert alert-danger\"&gt;危险风格的警告框&lt;/div&gt; 效果如下图所示： 警告框上面也可以添加有一个关闭按钮，示例如下： 123456&lt;p&gt;带关闭按钮的警告框&lt;/p&gt;&lt;div class=\"alert alert-warning alert-dismissible\"&gt;可关闭的警告框&lt;button type=\"button\" class=\"close\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;&lt;/div&gt; 效果如下： 警告框中也可以添加跳转链接，示例如下： 12345&lt;p&gt;带链接的警告框&lt;/p&gt;&lt;div class=\"alert alert-danger\"&gt; 您输入的用户名或密码有误 &lt;a class=\"alert-link\" href=\"#\"&gt;找回密码&lt;/a&gt;&lt;/div&gt; 效果如下图所示： 关于进度条组件，Bootstrap中使用progress类来创建，示例如下： 12345&lt;p&gt;默认的进度条组件&lt;/p&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar\" style=\"width: 60%;\"&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 进度条组件也支持多种样式，示例如下： 123456789101112131415161718192021&lt;p&gt;各种风格的进度条组件&lt;/p&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-danger\" style=\"width: 60%;\"&gt; 60% &lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-info\" style=\"width: 60%;\"&gt; 60% &lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width: 60%;\"&gt; 60% &lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width: 60%;\"&gt; 60% &lt;/div&gt;&lt;/div&gt; 效果如下图： 进度条也支持条纹模式，使用progress-bar-striped类可以创建条纹进度条，添加active类可以展现条纹动画，示例如下： 123456&lt;p&gt;带条纹的进度条&lt;/p&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success progress-bar-striped active\" style=\"width: 60%;\"&gt; 60% &lt;/div&gt;&lt;/div&gt; 效果如下图： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/alertAndProgress.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(下)","slug":"284深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(下)","date":"2016-12-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.358Z","comments":true,"path":"2016/12/18/284深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(下)/","link":"","permalink":"http://huishao.cc/2016/12/18/284深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(下)/","excerpt":"","text":"深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(下)一、引言上一篇博客详细讨论了HTTPS协议的原理，搭建HTTPS测试环境以及证书的相关基础。本篇博客将继续探讨更多在iOS开发中适配HTTPS类型请求的内容。上篇博客的地址如下： https://my.oschina.net/u/2340880/blog/807358。 二、关于NSURLAuthenticationChallenge相关类我们在实现URLSession的认证协议方法时，会接收到一个NSURLAuthenticationChallenge类型的参数。简单理解，这个参数就是服务端发起的一个验证挑战，客户端需要根据挑战的类型提供相应的挑战凭证。当然，挑战凭证不一定都是进行HTTPS证书的信任，也可能是需要客户端提供用户密码或者提供双向验证时的客户端证书。当这个挑战凭证被验证通过时，请求便可以继续顺利进行。NSURLAuthenticationChallenge类对象中有一个sender代理实例，开发者通过这个实例来可控采用怎样的验证方式。解析如下： 12345678910//使用凭证进行验证- (void)useCredential:(NSURLCredential *)credential forAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;//试图不提供凭证继续请求- (void)continueWithoutCredentialForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;//取消凭证验证- (void)cancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;//使用默认提供的凭证行为- (void)performDefaultHandlingForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;//拒绝当前提供的受保护控件并且尝试不提供凭证继续请求- (void)rejectProtectionSpaceAndContinueWithChallenge:(NSURLAuthenticationChallenge *)challenge; 可以看到，上面的协议方法中如果要进行凭证的验证，需要客户端提供一个凭证对象NSURLCredential。这个类可以简单理解为客户端创建的凭证信息，解析如下： 123456789101112131415161718//通过用户名和密码进行凭证的创建- (instancetype)initWithUser:(NSString *)user password:(NSString *)password persistence:(NSURLCredentialPersistence)persistence;//同上+ (NSURLCredential *)credentialWithUser:(NSString *)user password:(NSString *)password persistence:(NSURLCredentialPersistence)persistence;//用户名属性 只读@property (nullable, readonly, copy) NSString *user;//密码属性 只读@property (nullable, readonly, copy) NSString *password;//是否有密码 只读@property (readonly) BOOL hasPassword;//通过客户端提供证书进行双向验证- (instancetype)initWithIdentity:(SecIdentityRef)identity certificates:(nullable NSArray *)certArray persistence:(NSURLCredentialPersistence)persistence NS_AVAILABLE(10_6, 3_0);//同上+ (NSURLCredential *)credentialWithIdentity:(SecIdentityRef)identity certificates:(nullable NSArray *)certArray persistence:(NSURLCredentialPersistence)persistence NS_AVAILABLE(10_6, 3_0);//创建证书信任凭证 用户自签名的HTTPS请求- (instancetype)initWithTrust:(SecTrustRef)trust NS_AVAILABLE(10_6, 3_0);//同上+ (NSURLCredential *)credentialForTrust:(SecTrustRef)trust NS_AVAILABLE(10_6, 3_0); 上面方法中的NSURLCredentialPersistence枚举用来设置凭证的存储方式，解析如下： 123456typedef NS_ENUM(NSUInteger, NSURLCredentialPersistence) &#123; NSURLCredentialPersistenceNone, //不保存 NSURLCredentialPersistenceForSession, //在本URLSession中有效 NSURLCredentialPersistencePermanent, //保存在钥匙串中 ，永久有效 NSURLCredentialPersistenceSynchronizable NS_ENUM_AVAILABLE(10_8, 6_0) //永久有效 并且被所有APPID设备共享&#125;; 三、使用AFNetworking进行自签名证书HTTPS请求的认证使用AFNetworking也可以很方便的进行自签名证书的认证，还以上一节博客搭建的HTTPS环境为例，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253-(void)afHttps&#123; NSURLRequest * req = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"https://localhost:8080/users\"]]; AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate]; // securityPolicy.allowInvalidCertificates = YES;//是否允许使用自签名证书 securityPolicy.validatesDomainName = NO;//是否需要验证域名，默认YES AFHTTPSessionManager *_manager = [AFHTTPSessionManager manager]; _manager.responseSerializer = [AFHTTPResponseSerializer serializer]; _manager.securityPolicy = securityPolicy; //设置超时 [_manager.requestSerializer willChangeValueForKey:@\"timeoutinterval\"]; _manager.requestSerializer.timeoutInterval = 20.f; [_manager.requestSerializer didChangeValueForKey:@\"timeoutinterval\"]; _manager.requestSerializer.cachePolicy = NSURLRequestReloadIgnoringCacheData; _manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@\"application/xml\",@\"text/html\",@\"text/plain\",@\"application/json\",nil]; [_manager setSessionDidReceiveAuthenticationChallengeBlock:^NSURLSessionAuthChallengeDisposition(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential *__autoreleasing *_credential) &#123; SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust]; /** * 导入多张CA证书 */ NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"cert\" ofType:@\"der\"];//自签名证书 NSData* caCert = [NSData dataWithContentsOfFile:cerPath]; NSArray *cerArray = @[caCert]; _manager.securityPolicy.pinnedCertificates = cerArray; SecCertificateRef caRef = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)caCert); NSArray *caArray = @[(__bridge id)(caRef)]; SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)caArray); SecTrustSetAnchorCertificatesOnly(serverTrust,NO); NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __autoreleasing NSURLCredential *credential = nil; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123; if ([_manager.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123; credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; if (credential) &#123; disposition = NSURLSessionAuthChallengeUseCredential; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; &#125; &#125; else &#123; disposition = NSURLSessionAuthChallengePerformDefaultHandling; &#125; return disposition; &#125;]; [[_manager dataTaskWithRequest:req completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; NSLog(@\"%@,%@\",[[NSString alloc]initWithData:responseObject encoding:NSUTF8StringEncoding],error); &#125;]resume];&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(上)","slug":"283深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(上)","date":"2016-12-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.358Z","comments":true,"path":"2016/12/16/283深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(上)/","link":"","permalink":"http://huishao.cc/2016/12/16/283深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求(上)/","excerpt":"","text":"深入理解HTTPS及在iOS系统中适配HTTPS类型网络请求一、引言本篇博客主要讨论如何在客户端与服务端之间进行HTTPS网络传输，为了深入理解网络传输的基础原理，更加灵活的校验证书，博客的前半部分也将介绍一些HTTPS网络传输原理。当然，文章中有不正和疏漏之处，还望朋友不吝指正，感谢！ 二、HTTP与HTTPS我们都知道，HTTP是一种常用的网络传输协议，它是基于TCP的一种应用层协议，应用层是什么样的一个概念，通过下面这张示意图可以很好的理解： HTTP协议的网络传输十分常见，例如网易的主页http://www.163.com/。HTTP类型的网络传输使用十分方便，但是其在安全性上却有很大问题，列举如下： 1.HTTP协议在传输数据时是明文的，任何人通过一个简单的抓包工具，就可以截获到所有传输数据。 2.HTTP协议在传输数据时无法保证数据的完整，在截获到明文数据后，很容易就可以将其篡改，这也是一些网页总是被植入恶意广告的原因。 3.HTTP协议在传输数据时无法保证真实性，这也是最恐怖的一点。误入了域名欺骗的钓鱼网站，极容易对用户带来财产损失。 基于上面3点安全性的考虑，一种更加安全的网络传输协议势必要推行，那就是HTTPS。 要理解HTTPS协议，首先需要明白什么是SSL/TLS。SSL全称“Secure Sockets Layer”，意思为安全套接层。其实由网景公司为了解决HTTP传输协议在安全方面的缺陷而设计的。后来被标准化，更名为TLS，全称“Transport Layer Security”，意思为传输层安全协议。 那么现在就好理解了，其实HTTPS就是将HTTP协议与TLS协议组合起来，在不改变HTTP协议原设计的基础上，为其添加安全性校验并对传输的数据进行加密。那么TLS究竟在网络传输的那一层进行了处理了，下图可以很好的表示： 三、证书 通过前面所介绍，我们知道HTTPS主要是为了解决3个问题：数据加密、数据完整、数据真实。那么下一步就是如何解决这些问题，数据加密在发送数据前依赖SSL层对数据进行加密，数据完整与真实性则要靠另一种关键技术：数字证书。 通过一个小例子可以很容易的理解证书的作用，这个例子的来源是&lt;编程随想&gt;的作者，我这里暂且借用一下：A公司的a到B公司办事，为了证明a确实是A公司的职员而不是商业间谍，A公司会为a提供一个带有公章的证明，当B公司看到这个证明时，就可以信任办事员a。对比网络传输，这个证明就是证书，证书可以保证这个网站的真实性。我们继续往后分析，当B公司与越来越多的公司进行商业合作时，就又有新的问题出现了，比如C公司的c来B公司办事，就需要拿C公司带公章的证明，D公司的d来B公司办事就需要拿D公司带公章的证明...这样一来，B公司要存放好多公司的公章和证明的模板，才能够完成校验。这样未免也太麻烦了，对应到网络传输中，客户端就是B公司，各个网站都有自己的证书文件，这样客户端需要安装信任大量的证书，为了解决这样的问题，就有了第三方CA机构。第三方CA机构是由大家公认信任的机构，例如R公司为第三方信任机构，其业务是为其他公司提供公章证明，这样一来，B公司只要保有这个R公司的公章证明副本，其他A，C，D公司的办事员也只需要从R公司申请到一个公章证明就可以到B公司来交流业务了。 CA的全称是“Certificate Authority”，意为证书授权中心。大部分CA机构颁发的证书都是需要付费的，CA机构颁发的证书一般都是根证书，根证书也比较容易理解，首先证书是有链式信任关系的，例如Y证书是由CA机构颁发的根证书，由这个Y证书还可以创建出许多子证书，子证书可以继续创建子证书，只要根证书是受信任的，其下所有的子证书都是受信任的，如下图： 我们可以打开开源中国博客的主页：[https://www.oschina.net/blog](https://www.oschina.net/blog)。在Chrome浏览器地址栏左边可以查看证书信息，如下： 点击证书信息，可以看到完整的证书链，如下图： 从图中可以看到，根证书是由CA机构VerSign公司颁发的。此处还可以看到当前证书是否有效以及过期时间，如果证书无效则说明此网页信息有可能被篡改过，用户在访问时就要小心了。 除了CA机构可以签发证书外，个人其实也是可以创建证书的，当然个人创建的证书也是不被信任的，我们姑且把这类证书叫做自签名证书，如果用自签名证书搭建了HTTPS的服务，则客户端需要安装对应的证书信任，才可以进行此服务的访问。后面我们会进一步讨论自签名证书的使用。 四、搭建一个本地的HTTPS服务使用Node.js可以快速的搭建前端服务，我们这里使借助Express框架来搭建本地的HTTPS服务，用于测试我们后边将要进行HTTPS通讯。Express搭建搭建项目模板的过程在以前的一篇博客中有详细的介绍，这里就不再重复了，地址如下： 使用Express搭建前端项目：https://my.oschina.net/u/2340880/blog/794928。 根据前面所述，搭建HTTPS服务需要有证书凭证，两种证书我们可以选择，一种是CA机构签发的证书，还有一种是我们自己制作的自签名证书，在Mac电脑上打开钥匙串访问应用，打开其中的证书助理，如下图所示： 选择其中的为您自己创建证书选项，如下图： 在之后的界面中，输入证书的名称，选择证书类型，如下图所示： 上面，我把证书的名字创建成了珲少，身份类型选择的是自签名的根证书，证书类型选择SSL服务器，之后点击创建即可完成证书的创建。 创建完成后，在钥匙串访问的登录证书中，可以看到已经有了珲少这个自签名的证书，如下图： 在证书上点击右键，选择导出选项，名字我将其取名为huishao，文件类型要选择.p12，如下图所示： 点击存储后，需要设置一个访问密码，这个密码将来将用于从.p12文件中获取证书和密钥，如下图所示： 之后，系统有可能会让你再次输入一个密码，将入下图所示，注意，这里需要输入的是系统的登录密码： 完成上面操作后，我们已经将一个.p12文件导出到了桌面。那么这个.p12文件到底是个什么东西呢，它和证书之间又有什么关系呢，其实.p12文件一个复合文件，其中包装了私钥与证书信息，使用OpenSSL工具可以将其中的信息进行提取，搭建一个HTTPS的服务器需要两个文件，分别问证书文件和私钥文件，下面我们来从.p12文件中提取这些需要的文件。 打开终端，cd到huishao.p12文件所在的目录下，使用如下命令可以将.p12文件中的私钥分解出来： 1openssl pkcs12 -in huishao.p12 -nocerts -out privateKey.pem -nodes 之间会要求输入导出.p12文件时所设置的密码。 使用如下命令将.p12文件中的证书分解出来： 1openssl pkcs12 -in huishao.p12 -nokeys -out cert.pem -nodes 之间也会要求输入导出.p12文件时所设置的密码。完成上面两部操作后，可以看到当前文件夹下多了两个文件，分别为cert.pem与privateKey.pem，他们分别是证书文件与密钥文件，将他们拷贝到Express项目的bin文件夹下，使得Express项目的结构看起来如下图所示： 下面我们来配置Express项目。 在生成好的Express项目中的www文件的末尾添加如下代码： 123456789101112131415161718192021/*HTTPS*/var fs = require('fs');var https = require('https');/*密钥文件*/var privatekey = fs.readFileSync('./privateKey.pem', 'utf8'); /*证书文件*/var certificate = fs.readFileSync('./cert.pem', 'utf8'); var options=&#123;key:privatekey, cert:certificate&#125;; var serverHttps = https.createServer(options, app); /*绑定端口*/serverHttps.listen(8080,function () &#123; console.log('Https server listening on port ' + 8080);&#125;); 用终端在bin文件夹下运行 node www，效果如下： 在浏览器打开：https://localhost:8080/users，如果服务器搭建成功，Chrome中会出现如下效果： 点击高级，点击其中的继续访问，可以正常获取到服务器返回的数据。到此，我们的HTTPS服务就搭建成功了。 五、iOS开发中通过配置info.plist文件来允许HTTP协议类型的通讯前面扯了太多，终于提到重点部分了。Apple在iOS9中就已经漏出一些强制HTTPS通讯的端倪，只是给了开发者一些过渡，在iOS10及以后的审核机制中，Apple对于强制HTTPS的推动将会越来越强，如何让自己的应用程序尽快的适配HTTPS相关的标准，是iOS开发者必须面对的任务。 通过前面的分析我们了解，CA机构签发的证书是被默认信任的，这就是说，如果你的公司比较有钱，愿意花钱从CA机构申请一个付费的证书，那么很幸运，你的iOS工程是不需要做任何修改的，这些CA机构签发的证书是默认受信任的，因此你可以直接在程序中进行HTTPS类型的请求，所需要修改的只是将请求url改成https开头。但是另一种情况，无论出于什么原因，你的后台服务用的是自签名的证书，就想我们上面搭建的HTTPS服务一样，如果在不做任何处理的情况下在项目中访问这样的服务，就会出现问题了，原因是我们自己创建的自签名证书是不受信任的，系统默认拒绝了请求，示例如下： 12345678-(void)normalHttps&#123; NSURLRequest * req = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"https://localhost:8080/users\"]]; NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:config delegate:nil delegateQueue:[NSOperationQueue mainQueue]]; [[session dataTaskWithRequest:req completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@\"%@,%@\",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],error); &#125;] resume];&#125; 运行工程后可以看到，并没有获取到相关数据，Xcode提示为： 1NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9802) 好了，那么我们先不管HTTPS的问题，如果我们直接对HTTP协议的服务进行请求，会不会有问题呢，将代码修改如下： 12345678-(void)normalHttps&#123; NSURLRequest * req = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://localhost:3000/users\"]]; NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:config delegate:nil delegateQueue:[NSOperationQueue mainQueue]]; [[session dataTaskWithRequest:req completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@\"%@,%@\",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],error); &#125;] resume];&#125; 需要注意：Express在进行项目模板的创建时，会默认帮我们绑定一个3000端口的HTTP服务。 运行工程后，可以发现HTTP协议的请求也无法访问，报错如下： 1App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app&apos;s Info.plist file. 其意思大致是说应用程序传输安全要求强制使用HTTPS类型的服务，但是开发者可以通过配置info.plsit文件来回避这一政策。这就是我们这节的重点，通过文件配置的方式来跳过应用安全传输协议。 在iOS9之后，开发者可以在Info.plist文件中添加如下键：NSAppTransportSecurity。这个键用来配置APP传输安全的相关策略，是字典类型，其中可以设置的键有五个，如下： NSAllowsArbitraryLoads：布尔值，默认为NO，设置为YES则代表除了NSExceptionDomains中设置的域名外，其他所有请求的协议类型都不受限制，也就是说可以支持HTTP类型的请求，这个键的作用域是全局的，App内所有的请求都受影响，但是如果开发者设置为了YES，在提交审核时需要说明原因。 NSAllowsArbitraryLoadsForMedia：布尔值，默认为NO，设置为YES的话，则应用程序内所有的媒体数据的加载将不受协议类型的限制，同样如果开发者设置为了YES，则在提交审核时需要说明原因。 NSAllowsArbitraryLoadsInWebContent：布尔值，默认为NO。如果设置为YES，则应用程序内所有WebView的请求加载不受协议类型的限制，开发者设置为了YES，则在提交审核时需要说明原因。 NSAllowsLocalNetworking：布尔值，默认为NO，如果设置为YES，则在加载本地资源时不受安全传输协议的限制。 NSExceptionDomains：字典，其主要对某些特殊域名做限制。其中结构可以表示如下： 12345678910111213141516NSAppTransportSecurity : Dictionary &#123; NSAllowsArbitraryLoads : Boolean NSAllowsArbitraryLoadsForMedia : Boolean NSAllowsArbitraryLoadsInWebContent : Boolean NSAllowsLocalNetworking : Boolean //对某些域名做特殊限制 NSExceptionDomains : Dictionary &#123; &lt;domain-name-string&gt; : Dictionary &#123; NSIncludesSubdomains : Boolean NSExceptionAllowsInsecureHTTPLoads : Boolean NSExceptionMinimumTLSVersion : String NSExceptionRequiresForwardSecrecy : Boolean // Default value is YES NSRequiresCertificateTransparency : Boolean &#125; &#125;&#125; NSIncludesSubdomains：布尔值，这个键的作用是设置此域名下的所有子域名是否采用和父域名相同的配置。 NSExceptionAllowsInsecureHTTPLoads：布尔值，设置是否允许此域名使用自签名的证书进行请求，默认为NO，如果设置为YES，则在提交时需要说明原因。 NSExceptionMinimumTLSVersion：设置所使用的TLS版本。 NSExceptionRequiresForwardSecret：设置为NO，则不允许向前加密方式。 NSRequiresCertificateTransparency：如果设置为YES，则服务端的证书要有有效的透明时间戳。 六、iOS中使用自签名的证书进行HTTPS请求校验通过Info.plist文件我们是可以绕过安全传输协议的，但是不幸的是，从文档上看，无论开发者通过哪种方式来绕过安全传输协议，Apple都要求开发者在提审时提供合适的理由，这就是说：如果你使用了HTTP协议的请求，没有充足理由的话，你的App有很大的可能被审核拒绝。因此，更加保险的一种方式是将所有的服务都换成HTTPS协议的，如果有CA证书，当然完事大吉，如果没有，我们也可以通过验证自签名证书的方式来适配HTTPS协议。 在进行HTTPS请求时，服务端会先将证书文件返回给客户端，如果客户端的证书信任列表中包含这个证书，则此请求可以正常进行，如果没有，则请求会被拒绝。因此，在iOS中适配自签名证书的HTTPS请求实际上就是将这个自签名的证书安装进客户端的信任列表。iOS中需要使用的证书是der格式的，可以使用如下命令将pem格式的证书转换成der格式的证书： 1openssl x509 -inform PEM -in cert.pem -outform DER -out cert.der 将生成的cert文件添加进工程中，修改请求如下： 123456789-(void)normalHttps&#123; NSURLRequest * req = [NSURLRequest requestWithURL:[NSURL URLWithString:@\"https://localhost:8080/users\"]]; NSURLSessionConfiguration * config = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]]; NSURLSessionTask * task = [session dataTaskWithRequest:req completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@\"%@,%@\",[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],error); &#125;]; [task resume];&#125; 除此之外，需要实现一个SURLSessionDelegate的协议方法如下： 12345678910111213141516171819202122232425262728293031323334- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123; NSLog(@\"证书认证\"); //先判断证书是否有效 if ([[[challenge protectionSpace] authenticationMethod] isEqualToString: NSURLAuthenticationMethodServerTrust]) &#123; //证书验证请求 SecTrustRef serverTrust = [[challenge protectionSpace] serverTrust]; /** * 导入多张CA证书（Certification Authority，支持SSL证书以及自签名的CA） */ NSString *cerPath = [[NSBundle mainBundle] pathForResource:@\"cert\" ofType:@\"der\"];//自签名证书 NSData* caCert = [NSData dataWithContentsOfFile:cerPath]; //可以添加多张证书 NSArray *caArray = @[caCert]; //验证规则 NSMutableArray *policies = [NSMutableArray array]; [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); NSMutableArray *pinnedCertificates = [NSMutableArray array]; //进行自签名证书的添加 for (NSData *certificateData in caArray) &#123; [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; &#125; SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); SecTrustResultType result = -1; //通过本地导入的证书来验证服务器的证书是否可信 SecTrustEvaluate(serverTrust, &amp;result); NSURLCredential *credential = [NSURLCredential credentialForTrust:serverTrust]; completionHandler(NSURLSessionAuthChallengeUseCredential,credential); return [[challenge sender] useCredential: credential forAuthenticationChallenge: challenge]; &#125;&#125; 如上修改后，再次运行工程，可以看到已经成功请求到了HTTPS自签名证书服务提供的数据： 介于篇幅过长，关于NSURLAuthenticationChallenge相关类的更多探讨和常用网络库AFNetworking中HTTPS的适配，下篇博客会继续介绍。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Bootstrap响应式前端框架笔记十二——巨幕与缩略图","slug":"282Bootstrap响应式前端框架笔记十二——巨幕与缩略图","date":"2016-12-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.357Z","comments":true,"path":"2016/12/14/282Bootstrap响应式前端框架笔记十二——巨幕与缩略图/","link":"","permalink":"http://huishao.cc/2016/12/14/282Bootstrap响应式前端框架笔记十二——巨幕与缩略图/","excerpt":"","text":"Bootstrap响应式前端框架笔记十二——巨幕与缩略图巨幕用于创建一块区域，此区域可以用来展示网页页头或者需要重点提示的地方，使用jumbotron类来创建巨幕，示例如下： 123456&lt;p&gt;巨幕演示&lt;/p&gt;&lt;div class=\"jumbotron\"&gt; &lt;h1&gt;勿忘国耻！九一八！&lt;/h1&gt; &lt;p&gt;九一八事变（又称奉天事变、柳条湖事件）是日本在中国东北蓄意制造并发动的一场侵华战争，是日本帝国主义侵华的开端。1931年9月18日夜，在日本关东军安排下，铁道“守备队”炸毁沈阳柳条湖附近日本修筑的南满铁路路轨，并栽赃嫁祸于中国军队。日军以此为借口，炮轰沈阳北大营，是为“九一八事变”。&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary btn-lg\"&gt;查看详情&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; 效果如下： 除了使用巨幕，开发者也可以使用page-header类来创建页头，示例如下： 12345&lt;p&gt;页头演示&lt;/p&gt;&lt;div class=\"page-header\"&gt; &lt;h1&gt;前事不忘，后事之师！&lt;small&gt;祭奠南京大屠杀中遇难的三十万同胞！&lt;/small&gt;&lt;/h1&gt;&lt;/div&gt;&lt;p&gt;南京大屠杀指抗日战争期间，中国当时的首都南京于1937年12月13日沦陷后，日军在南京及附近地区进行长达四十多天的大屠杀[1] 。日军在南京城内对大量平民及战俘无恶不作。南京大屠杀的死亡人数超过30万。&lt;/p&gt; 效果如下： Bootstrap中的缩略图也十分容易创建，使用thumbnail类可以将图片元素创建为缩略图样式，如下: 12345678&lt;p&gt;缩略图&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 col-md-3\"&gt; &lt;a href=\"#\" class=\"thumbnail\"&gt; &lt;img src=\"image/test.png\"&gt; &lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 效果如下图所示： 缩略图组件中也可以添加其他附件，例如标题，段落，按钮等，示例如下： 12345678910111213141516&lt;p&gt;缩略图也可以添加一些附件&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-sm-6 col-md-4\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img src=\"image/nanjing.png\"&gt; &lt;div class=\"caption\"&gt; &lt;h3&gt;国家公祭&lt;/h3&gt; &lt;p&gt;南京大屠杀指抗日战争期间，中国当时的首都南京于1937年12月13日沦陷后，日军在南京及附近地区进行长达四十多天的大屠杀[1] 。日军在南京城内对大量平民及战俘进行屠杀、抢掠、强奸、无恶不作。南京大屠杀的死亡人数超过30万。&lt;/p&gt; &lt;p&gt; &lt;a href=\"#\" class=\"btn btn-primary\" role=\"button\"&gt;网上献花&lt;/a&gt; &lt;a href=\"#\" class=\"btn btn-default\" role=\"button\"&gt;更多史料&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/screen.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记十一——分页与标签","slug":"281Bootstrap响应式前端框架笔记十一——分页与标签","date":"2016-12-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.357Z","comments":true,"path":"2016/12/13/281Bootstrap响应式前端框架笔记十一——分页与标签/","link":"","permalink":"http://huishao.cc/2016/12/13/281Bootstrap响应式前端框架笔记十一——分页与标签/","excerpt":"","text":"Bootstrap响应式前端框架笔记十一——分页与标签在开发搜索结果页、列表页时通常会使用到分页器控件，Bootstrap中提供了方便的类来进行分页器的创建，示例如下： 123456789101112131415161718192021222324&lt;p&gt;标准的分页器控件&lt;/p&gt;&lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;4&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;5&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 效果如下： 为li元素添加disabled类或者active类可以将其设置为禁用或者激活状态，示例如下： 123456789101112131415161718192021222324&lt;p&gt;使用disabled类与active类可以将页标签设置为禁用或激活&lt;/p&gt;&lt;ul class=\"pagination\"&gt; &lt;li class=\"disabled\"&gt; &lt;a href=\"#\"&gt;&amp;laquo;&lt;/a&gt; &lt;/li&gt; &lt;li class=\"active\"&gt; &lt;a href=\"#\"&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;2&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;3&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;4&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;5&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&amp;raquo;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 效果如下图： 除了分页器控件，Bootstrap中还提供了一种更为简单的分页控件，示例如下： 123456789&lt;p&gt;只有前进与后退的分页器&lt;/p&gt;&lt;ul class=\"pager\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;Previous&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;Next&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 效果如下： 这种分页控件默认是居中的，使用previous与next类可以实现两端对齐的效果，示例如下： 123456789&lt;p&gt;进行两端对齐&lt;/p&gt;&lt;ul class=\"pager\"&gt; &lt;li class=\"previous\"&gt; &lt;a href=\"#\"&gt;Previous&lt;/a&gt; &lt;/li&gt; &lt;li class=\"next\"&gt; &lt;a href=\"#\"&gt;Next&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 效果如下： Bootstrap中的标签是一种用于展示文本的控件，示例代码如下： 1234567&lt;p&gt;标签控件演示&lt;/p&gt;&lt;span class=\"label label-default\"&gt;标签&lt;/span&gt;&lt;span class=\"label label-primary\"&gt;标签&lt;/span&gt;&lt;span class=\"label label-success\"&gt;标签&lt;/span&gt;&lt;span class=\"label label-info\"&gt;标签&lt;/span&gt;&lt;span class=\"label label-warning\"&gt;标签&lt;/span&gt;&lt;span class=\"label label-danger\"&gt;标签&lt;/span&gt; 效果如下： 开发者也可以使用badge类来创建气泡，示例如下： 123456&lt;p&gt;进行气泡的创建&lt;/p&gt;&lt;a href=\"#\"&gt;链接&lt;span class=\"badge\"&gt;3&lt;/span&gt;&lt;/a&gt;&lt;button class=\"btn btn-primary\" type=\"button\"&gt; 按钮 &lt;span class=\"badge\"&gt;4&lt;/span&gt;&lt;/button&gt; 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/pageAndLabel.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记十——导航栏相关组件","slug":"280Bootstrap响应式前端框架笔记十——导航栏相关组件","date":"2016-12-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.357Z","comments":true,"path":"2016/12/12/280Bootstrap响应式前端框架笔记十——导航栏相关组件/","link":"","permalink":"http://huishao.cc/2016/12/12/280Bootstrap响应式前端框架笔记十——导航栏相关组件/","excerpt":"","text":"Bootstrap响应式前端框架笔记十——导航栏相关组件Bootstrap中提供的导航栏分为两种模式，使用nav-tabs类可以创建页卡模式的导航栏，使用nav-pills类可以创建胶囊模式的导航栏，示例如下： 1234567891011121314&lt;p&gt;导航分为两种，页卡模式和胶囊模式&lt;/p&gt;&lt;p&gt;页卡模式&lt;/p&lt;ul class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt;&lt;a&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;活动&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;留言&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr /&gt;&lt;p&gt;胶囊模式&lt;/p&gt;&lt;ul class=\"nav nav-pills\"&gt; &lt;li class=\"active\"&gt;&lt;a&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;活动&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;留言&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 效果如下图： 针对胶囊式导航，也可以设置其排列方向为堆叠，添加nav-stacked类即可，示例如下： 123456&lt;p&gt;堆叠排列的胶囊导航&lt;/p&gt;&lt;ul class=\"nav nav-pills nav-stacked\"&gt; &lt;li class=\"active\"&gt;&lt;a&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;活动&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;留言&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 效果如下： 导航中也可以进行下拉菜单的嵌套，示例如下： 1234567891011121314151617&lt;p&gt;导航中嵌套下拉菜单&lt;/p&gt;&lt;ul class=\"nav nav-pills\"&gt; &lt;li&gt;&lt;a&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;活动&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;留言&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown active\"&gt; &lt;a class=\"dropdown-toggle\"&gt; 更多 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;退出&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 效果如下图所示： 除了默认的导航栏组件，Bootstrap中还支持自定义导航条，使用navbar类可以创建导航条容器，其内可以布局图标，文本，按钮和表单等，示例如下： 12345678910111213141516&lt;p&gt;自定义导航条&lt;/p&gt;&lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\"&gt;&lt;img src=\"image/icon.png\" width=\"20px\" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;form class=\"navbar-form navbar-left\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Search\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-default\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;button class=\"btn btn-warning navbar-btn navbar-left\"&gt;提示&lt;/button&gt; &lt;p class=\"navbar-text\"&gt;导航文本&lt;/p&gt; &lt;/div&gt;&lt;/nav&gt; 效果如下图： 使用navbar-fixed-top类或者navbar-fixed-bottom类可以将导航条固定在顶部或底部，示例如下： 123456789101112131415161718192021222324252627282930313233&lt;p&gt;将导航栏固定在顶部&lt;/p&gt; &lt;nav class=\"navbar navbar-default navbar-fixed-top\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\"&gt;&lt;img src=\"image/icon.png\" width=\"20px\" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;form class=\"navbar-form navbar-left\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Search\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-default\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;button class=\"btn btn-warning navbar-btn navbar-left\"&gt;提示&lt;/button&gt; &lt;p class=\"navbar-text\"&gt;导航文本&lt;/p&gt; &lt;/div&gt; &lt;/nav&gt; &lt;hr /&gt; &lt;p&gt;将导航栏固定在底部&lt;/p&gt; &lt;nav class=\"navbar navbar-default navbar-fixed-bottom\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\"&gt;&lt;img src=\"image/icon.png\" width=\"20px\" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;form class=\"navbar-form navbar-left\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Search\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-default\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;button class=\"btn btn-warning navbar-btn navbar-left\"&gt;提示&lt;/button&gt; &lt;p class=\"navbar-text\"&gt;导航文本&lt;/p&gt; &lt;/div&gt; &lt;/nav&gt; 使用navbar-inverse类可以将导航条进行反色处理，示例如下： 12345678910111213141516&lt;p&gt;将导航条进行反色处理&lt;/p&gt;&lt;nav class=\"navbar navbar-default navbar-inverse\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a class=\"navbar-brand\"&gt;&lt;img src=\"image/icon.png\" width=\"20px\" /&gt;&lt;/a&gt; &lt;/div&gt; &lt;form class=\"navbar-form navbar-left\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Search\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-default\"&gt;Search&lt;/button&gt; &lt;/form&gt; &lt;button class=\"btn btn-warning navbar-btn navbar-left\"&gt;提示&lt;/button&gt; &lt;p class=\"navbar-text\"&gt;导航文本&lt;/p&gt; &lt;/div&gt;&lt;/nav&gt; 效果如下图： Bootstrap也支持进行路径导航的创建，其需要使用有序列表配合breadcrumb类，示例如下： 12345678910&lt;p&gt;进行路径导航的创建&lt;/p&gt;&lt;ol class=\"breadcrumb\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;主页&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;新闻列表&lt;/a&gt; &lt;/li&gt; &lt;li class=\"active\"&gt;国际新闻&lt;/li&gt;&lt;/ol&gt; 效果如下图： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/navigation.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记九——输入框组","slug":"278Bootstrap响应式前端框架笔记九——输入框组","date":"2016-12-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.357Z","comments":true,"path":"2016/12/11/278Bootstrap响应式前端框架笔记九——输入框组/","link":"","permalink":"http://huishao.cc/2016/12/11/278Bootstrap响应式前端框架笔记九——输入框组/","excerpt":"","text":"Bootstrap响应式前端框架笔记九——输入框组将input标签与input-group-addon类组合使用可以为输入框添加前后挂件，需要注意，Bootstrap不支持在输入框控件一侧添加多个挂件，示例如下： 12345678910111213141516&lt;p&gt;输入框的前后可以添加额外的标题元素&lt;/p&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-addon\"&gt;邮箱&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"邮箱\"&gt;&lt;/div&gt;&lt;div class=\"input-group form-group\"&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;span class=\"input-group-addon\"&gt;平米&lt;/span&gt;&lt;/div&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-addon\"&gt;余额&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;span class=\"input-group-addon\"&gt;.00&lt;/span&gt;&lt;/div&gt; 效果如下： 也可以将输入框组合为选择控件，示例如下： 12345678910111213&lt;p&gt;将输入框组合为选择组件&lt;/p&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-addon\"&gt; &lt;input type=\"checkbox\"&gt; &lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"&gt;&lt;/div&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-addon\"&gt; &lt;input type=\"radio\"&gt; &lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"&gt;&lt;/div&gt; 效果如下： 在输入框的前后，也可以添加功能按钮，示例如下： 12345678910111213&lt;p&gt;为输入框添加功能按钮&lt;/p&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\" type=\"button\"&gt;星座&lt;/button&gt; &lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"&gt;&lt;/div&gt;&lt;div class=\"input-group form-group\"&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-primary\" type=\"button\"&gt;前往&lt;/button&gt; &lt;/span&gt;&lt;/div&gt; 效果如下图： 在输入框组件中，也可以与下拉菜单进行嵌套使用，示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;p&gt;在输入框组件中嵌套下拉菜单组件&lt;/p&gt;&lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-btn\"&gt; &lt;button type=\"button\" class=\"btn btn-default dropdown-toggle\"&gt;星座 &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;金牛&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;狮子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;摩羯&lt;/a&gt; &lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;无&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input type=\"text\" class=\"form-control\"&gt;&lt;/div&gt;&lt;div class=\"input-group\"&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;div class=\"input-group-btn\"&gt; &lt;button type=\"button\" class=\"btn btn-default\"&gt;金牛&lt;/button&gt; &lt;button class=\"btn btn-default dropdown-toggle\"&gt;&lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;金牛&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;狮子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;摩羯&lt;/a&gt; &lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;无&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/inputGroup.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记九——输入框组","slug":"279Bootstrap响应式前端框架笔记十——导航栏相关组件","date":"2016-12-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.357Z","comments":true,"path":"2016/12/11/279Bootstrap响应式前端框架笔记十——导航栏相关组件/","link":"","permalink":"http://huishao.cc/2016/12/11/279Bootstrap响应式前端框架笔记十——导航栏相关组件/","excerpt":"","text":"Bootstrap响应式前端框架笔记九——输入框组将input标签与input-group-addon类组合使用可以为输入框添加前后挂件，需要注意，Bootstrap不支持在输入框控件一侧添加多个挂件，示例如下： 12345678910111213141516&lt;p&gt;输入框的前后可以添加额外的标题元素&lt;/p&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-addon\"&gt;邮箱&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"邮箱\"&gt;&lt;/div&gt;&lt;div class=\"input-group form-group\"&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;span class=\"input-group-addon\"&gt;平米&lt;/span&gt;&lt;/div&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-addon\"&gt;余额&lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;span class=\"input-group-addon\"&gt;.00&lt;/span&gt;&lt;/div&gt; 效果如下： 也可以将输入框组合为选择控件，示例如下： 12345678910111213&lt;p&gt;将输入框组合为选择组件&lt;/p&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-addon\"&gt; &lt;input type=\"checkbox\"&gt; &lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"&gt;&lt;/div&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-addon\"&gt; &lt;input type=\"radio\"&gt; &lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"&gt;&lt;/div&gt; 效果如下： 在输入框的前后，也可以添加功能按钮，示例如下： 12345678910111213&lt;p&gt;为输入框添加功能按钮&lt;/p&gt;&lt;div class=\"input-group form-group\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\" type=\"button\"&gt;星座&lt;/button&gt; &lt;/span&gt; &lt;input type=\"text\" class=\"form-control\"&gt;&lt;/div&gt;&lt;div class=\"input-group form-group\"&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-primary\" type=\"button\"&gt;前往&lt;/button&gt; &lt;/span&gt;&lt;/div&gt; 效果如下图： 在输入框组件中，也可以与下拉菜单进行嵌套使用，示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;p&gt;在输入框组件中嵌套下拉菜单组件&lt;/p&gt;&lt;div class=\"input-group\"&gt; &lt;div class=\"input-group-btn\"&gt; &lt;button type=\"button\" class=\"btn btn-default dropdown-toggle\"&gt;星座 &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;金牛&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;狮子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;摩羯&lt;/a&gt; &lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;无&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input type=\"text\" class=\"form-control\"&gt;&lt;/div&gt;&lt;div class=\"input-group\"&gt; &lt;input type=\"text\" class=\"form-control\"&gt; &lt;div class=\"input-group-btn\"&gt; &lt;button type=\"button\" class=\"btn btn-default\"&gt;金牛&lt;/button&gt; &lt;button class=\"btn btn-default dropdown-toggle\"&gt;&lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;金牛&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;狮子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;摩羯&lt;/a&gt; &lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;无&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/inputGroup.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记八——按钮组","slug":"277Bootstrap响应式前端框架笔记八——按钮组","date":"2016-12-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.356Z","comments":true,"path":"2016/12/10/277Bootstrap响应式前端框架笔记八——按钮组/","link":"","permalink":"http://huishao.cc/2016/12/10/277Bootstrap响应式前端框架笔记八——按钮组/","excerpt":"","text":"Bootstrap响应式前端框架笔记八——按钮组在Bootstrap定义的Css样式中，开发者可以将一组btn控件包裹在btn-group类中使其组合成按钮组控件，组合后的控件左右两侧的按钮将被圆角处理，示例代码如下： 123456&lt;p&gt;正常的按钮组&lt;/p&gt;&lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;左按钮&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;中心按钮&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;右按钮&lt;/button&gt;&lt;/div&gt; 效果如下： 也可以将一组按钮组包裹在btn-toolbar类中，使其组合成为按钮组工具栏，示例如下： 123456789101112131415&lt;p&gt;按钮组工具栏&lt;/p&gt;&lt;div class=\"btn-toolbar\"&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;左按钮&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;中心按钮&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;右按钮&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;左按钮&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;右按钮&lt;/button&gt; &lt;/div&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-primary\"&gt;独立按钮&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 按钮组也可以进行嵌套，使用按钮组嵌套的方式也可以实现下拉菜单效果，示例如下： 12345678910111213&lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-default\"&gt;左按钮&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;中心按钮&lt;/button&gt; &lt;div class=\"btn-group\"&gt; &lt;button class=\"btn btn-info dropdown-toggle\"&gt;菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a&gt;金牛&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;狮子&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 默认的按钮组是水平排列的，为其设置btn-group-vertical类可以将其设置为竖直排列的，示例如下： 123456&lt;p&gt;竖直排列的按钮组&lt;/p&gt;&lt;div class=\"btn-group-vertical\"&gt; &lt;button class=\"btn btn-default\"&gt;左按钮&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;中心按钮&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;右按钮&lt;/button&gt;&lt;/div&gt; 效果如下： 如果需要使按钮组填充其父容器，需要设置btn-group-justified类，并且使用a标签作为按钮，示例如下： 123456&lt;p&gt;设置按钮组宽度充满父容器&lt;/p&gt;&lt;div class=\"btn-group btn-group-justified\"&gt; &lt;a class=\"btn btn-default\"&gt;左按钮&lt;/a&gt; &lt;a class=\"btn btn-danger\"&gt;中心按钮&lt;/a&gt; &lt;a class=\"btn btn-primary\"&gt;右按钮&lt;/a&gt;&lt;/div&gt; 效果如下： 通过按钮组，可以十分方便的实现分裂式下拉菜单，示例如下： 12345678910111213141516171819202122&lt;p&gt;分裂式下拉菜单&lt;/p&gt;&lt;div class=\"btn-group\"&gt; &lt;button type=\"button\" class=\"btn btn-danger\"&gt;金牛&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-danger dropdown-toggle\"&gt; &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;金牛&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;狮子&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;摩羯&lt;/a&gt; &lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;无&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果如下： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/buttonGroup.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS10为用户添加触摸反馈","slug":"275iOS10为用户添加触摸反馈","date":"2016-12-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.356Z","comments":true,"path":"2016/12/09/275iOS10为用户添加触摸反馈/","link":"","permalink":"http://huishao.cc/2016/12/09/275iOS10为用户添加触摸反馈/","excerpt":"","text":"iOS10为用户添加触摸反馈在iOS10中，UIKit框架中新增加了3个类，UIImpactFeedbackGenerator类、UINotificationFeedbackGenerator类与UISelectionFeedbackGenerator类。开发者使用这3个类可以进一步为用户的某些交互操作增强反馈。举例而言，当用户点击了某个按钮，开发者可以为其提供一个适当的震动效果作为触觉上的反馈。示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//这个方法通过传入参数来确定触发什么样的用户触觉反馈-(void)feedbackStart:(int)style&#123; switch (style) &#123; case 1: &#123; UIImpactFeedbackGenerator * imp = [[UIImpactFeedbackGenerator alloc]initWithStyle:UIImpactFeedbackStyleHeavy]; [imp impactOccurred]; &#125; break; case 2: &#123; UIImpactFeedbackGenerator * imp = [[UIImpactFeedbackGenerator alloc]initWithStyle:UIImpactFeedbackStyleMedium]; [imp impactOccurred]; &#125; break; case 3: &#123; UIImpactFeedbackGenerator * imp = [[UIImpactFeedbackGenerator alloc]initWithStyle:UIImpactFeedbackStyleLight]; [imp impactOccurred]; &#125; break; case 4: &#123; UINotificationFeedbackGenerator * imp = [[UINotificationFeedbackGenerator alloc]init]; [imp notificationOccurred:UINotificationFeedbackTypeError]; &#125; break; case 5: &#123; UINotificationFeedbackGenerator * imp = [[UINotificationFeedbackGenerator alloc]init]; [imp notificationOccurred:UINotificationFeedbackTypeSuccess]; &#125; break; case 6: &#123; UINotificationFeedbackGenerator * imp = [[UINotificationFeedbackGenerator alloc]init]; [imp notificationOccurred:UINotificationFeedbackTypeWarning]; &#125; break; case 7: &#123; UISelectionFeedbackGenerator * imp = [[UISelectionFeedbackGenerator alloc]init]; [imp selectionChanged]; &#125; break; default: break; &#125;&#125; UIImpactFeedbackGenerator类是标准的触觉反馈类，其调用impactOccurred方法来触发反馈，其实例在创建时，可以通过枚举来创建强度不同的反馈： 12345678typedef NS_ENUM(NSInteger, UIImpactFeedbackStyle) &#123; //轻度的反馈 UIImpactFeedbackStyleLight, //中等强度的反馈 UIImpactFeedbackStyleMedium, //高强度的反馈 UIImpactFeedbackStyleHeavy&#125;; UINotificationFeedbackGenerator类是专用于通知类交互的触觉反馈，其在进行反馈时也有3中枚举类型可选，解析如下： 12345678typedef NS_ENUM(NSInteger, UINotificationFeedbackType) &#123; //成功类通知的反馈 UINotificationFeedbackTypeSuccess, //警告类通知的反馈 UINotificationFeedbackTypeWarning, //错误类通知的反馈 UINotificationFeedbackTypeError&#125;; UISelectionFeedbackGenerator类创建的反馈应用与某些选择器控件，例如用户在一个单选列表中切换选项、切换按钮的开关状态时，可以使用其来进行触觉反馈。 需要注意：不是所有的场景都需要反馈，频繁的触觉反馈会给用户代码困扰，开发者在使用这些类时要适当。 有时候，频繁的触觉反馈可能会引起反馈延时，这将大大降低用户的体验，官方建议开发者在合适的时机创建反馈，然后调用prepare方法来使反馈准备完成，之后在需要的时机再进行反馈的触发。需要注意，UIImpactFeedbackGenerator类、UINotificationFeedbackGenerator类与UISelectionFeedbackGenerator类都有一个相同的父类UIFeedbackGenerator类，这个类中定义了prepare方法，当调用这个方法时，系统会调起相关服务来进行触觉触觉反馈的准备工作。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"Bootstrap响应式前端框架笔记七——下拉菜单","slug":"276Bootstrap响应式前端框架笔记七——下拉菜单","date":"2016-12-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.356Z","comments":true,"path":"2016/12/09/276Bootstrap响应式前端框架笔记七——下拉菜单/","link":"","permalink":"http://huishao.cc/2016/12/09/276Bootstrap响应式前端框架笔记七——下拉菜单/","excerpt":"","text":"Bootstrap响应式前端框架笔记七——下拉菜单在Bootstrap的Css框架中，下拉菜单属于组件。一个完整的下拉菜单应该有两部分组成，一个触发按钮与一个选项列表。触发按钮dropdown-toggle类来创建，选项列表有drop-menu类来创建，这两部分元素需要包裹在一个dropdown类元素中，才能正确组合，示例代码如下： 12345678910111213&lt;p&gt;正常的下拉菜单样式&lt;/p&gt;&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\" &gt; &lt;li&gt;&lt;a&gt;白羊座&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;金牛座&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;摩羯座&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;狮子座&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 默认创建的下拉菜单是隐藏的，为了演示方便，可以将ul的display属性重设： 12345&lt;style&gt; ul&#123; display: block !important; &#125;&lt;/style&gt; 效果如下图： 使用dropdown-menu-left或者dropdown-menu-right可以实现对菜单列表的左对齐或者右对齐。 为列表的li元素添加dropdown-header类可以将此行设置为头信息行，示例如下： 1234567891011121314&lt;p&gt;可以使用dropdown-header类来进行菜单头的设置&lt;/p&gt;&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\" &gt; &lt;li class=\"dropdown-header\"&gt;星座&lt;/li&gt; &lt;li&gt;&lt;a&gt;白羊座&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;金牛座&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown-header\"&gt;属相&lt;/li&gt; &lt;li&gt;&lt;a&gt;猴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果如下图所示： 为li标签设置divider类可以将此行设置为分割线，示例如下： 123456789101112131415161718192021&lt;p&gt;可以使用divider类可以为菜单设置分割线&lt;/p&gt;&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li class=\"dropdown-header\"&gt;星座&lt;/li&gt; &lt;li&gt; &lt;a&gt;白羊座&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;金牛座&lt;/a&gt; &lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;li class=\"dropdown-header\"&gt;属相&lt;/li&gt; &lt;li&gt; &lt;a&gt;猴&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果如下： 可以为li设置disabled类来将此行选项设置为禁用，设置禁用后，此行标签也将无法点击，示例如下： 1234567891011121314151617181920&lt;p&gt;可以使用disabled类来禁用某些选项&lt;/p&gt;&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li class=\"dropdown-header\"&gt;星座&lt;/li&gt; &lt;li class=\"disabled\"&gt; &lt;a&gt;白羊座&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;金牛座&lt;/a&gt; &lt;/li&gt; &lt;li class=\"dropdown-header\"&gt;属相&lt;/li&gt; &lt;li&gt; &lt;a&gt;猴&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/dropList.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记五——按钮","slug":"273Bootstrap响应式前端框架笔记五——按钮","date":"2016-12-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.355Z","comments":true,"path":"2016/12/08/273Bootstrap响应式前端框架笔记五——按钮/","link":"","permalink":"http://huishao.cc/2016/12/08/273Bootstrap响应式前端框架笔记五——按钮/","excerpt":"","text":"Bootstrap响应式前端框架笔记五——按钮Bootstrap中预设了default，primary，info，warning，danger和link6种按钮风格，示例如下： 12345678&lt;p&gt;Bootstrap中预设的按钮样式如下&lt;/p&gt;&lt;button type=\"button\" class=\"btn btn-default\"&gt;正常&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-primary\"&gt;重要&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-success\"&gt;成功&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-info\"&gt;信息&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-warning\"&gt;警告&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-danger\"&gt;危险&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-link\"&gt;链接&lt;/button&gt; 效果如下： 可以为按钮元素添加btn-lg，btn-sm，btn-xs类来进行按钮尺寸的设置，示例如下： 12345&lt;p&gt;设置按钮的大小&lt;/p&gt;&lt;button type=\"button\" class=\"btn btn-default btn-lg\"&gt;正常&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-primary\"&gt;重要&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-success btn-sm\"&gt;成功&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-info btn-xs\"&gt;信息&lt;/button&gt; 效果如下图： 使用btn-block类可以将按钮设置为充满整个父元素，示例如下： 123&lt;p&gt;使用btn-block类可以将按钮设置为充满父元素&lt;/p&gt;&lt;button type=\"button\" class=\"btn btn-default btn-block\"&gt;正常&lt;/button&gt;&lt;button type=\"button\" class=\"btn btn-primary btn-block\"&gt;重要&lt;/button&gt; 效果如下： 需要注意：当button标签被用户点击时，按钮周围会出现边框，如果不需要这个边框，可以使用a标签来创建按钮。 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/button.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记六——图片与其他辅助类","slug":"274Bootstrap响应式前端框架笔记六——图片与其他辅助类","date":"2016-12-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.355Z","comments":true,"path":"2016/12/08/274Bootstrap响应式前端框架笔记六——图片与其他辅助类/","link":"","permalink":"http://huishao.cc/2016/12/08/274Bootstrap响应式前端框架笔记六——图片与其他辅助类/","excerpt":"","text":"Bootstrap响应式前端框架笔记六——图片与其他辅助类在页面中插入图片，Bootstrap框架中定义了3中图片的Css类样式，分别为圆角图片img-rounded类，圆形图片img-circle类和带边框的图片img-thumbnail类，示例如下： 1234&lt;p&gt;设置img-rounded类可以使图片显示圆角，img-circle类可以使图片显示圆形，img-thumbnail可以为图片加上边框&lt;/p&gt;&lt;img src=\"image/test.png\" class=\"img-rounded\" /&gt;&lt;img src=\"image/test.png\" class=\"img-circle\" /&gt;&lt;img src=\"image/test.png\" class=\"img-thumbnail\" /&gt; 效果如下图所示： text-xxx相关类定义了一些常用的字体颜色，示例如下： 123456&lt;p class=\"text-muted\"&gt;正常文字&lt;/p&gt;&lt;p class=\"text-primary\"&gt;重要文字&lt;/p&gt;&lt;p class=\"text-success\"&gt;成功文字&lt;/p&gt;&lt;p class=\"text-info\"&gt;详情文字&lt;/p&gt;&lt;p class=\"text-warning\"&gt;警告文字&lt;/p&gt;&lt;p class=\"text-danger\"&gt;危险文字&lt;/p&gt; 效果如下图所示： 与上面文字颜色的类相对应，Bootstrap中也定义了一组背景颜色类，示例如下： 123456&lt;p class=\"bg-muted\"&gt;正常背景&lt;/p&gt;&lt;p class=\"bg-primary\"&gt;重要背景&lt;/p&gt;&lt;p class=\"bg-success\"&gt;成功背景&lt;/p&gt;&lt;p class=\"bg-info\"&gt;详情背景&lt;/p&gt;&lt;p class=\"bg-warning\"&gt;警告背景&lt;/p&gt;&lt;p class=\"bg-danger\"&gt;危险背景&lt;/p&gt; 效果如下： 使用caret类可以方便的创建倒三角图案，示例如下： 12&lt;p&gt;使用caret类可以创建一个倒三角图案&lt;/p&gt;&lt;span class=\"caret\"&gt;&lt;/span&gt; 效果如下： 使用show和hidden类可以进行标签的显示与隐藏，示例如下： 1&lt;p class=\"hidden\"&gt;show和hidden可以进行便签的显示与隐藏&lt;/p&gt; Bootstrap中还提供了一些与响应类开发相关的类，开发者可以设置某些元素在某个尺寸的屏幕中可见或者隐藏，也可以设置某个元素在浏览器或打印机上可见或隐藏，如下： 屏幕尺寸响应式类： 显示设备响应式类： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/images.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS开发CoreGraphics核心图形框架之九——PDF文件的渲染与创建","slug":"272iOS开发CoreGraphics核心图形框架之九——PDF文件的渲染与创建","date":"2016-12-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.355Z","comments":true,"path":"2016/12/07/272iOS开发CoreGraphics核心图形框架之九——PDF文件的渲染与创建/","link":"","permalink":"http://huishao.cc/2016/12/07/272iOS开发CoreGraphics核心图形框架之九——PDF文件的渲染与创建/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之九——PDF文件的渲染与创建一、渲染已有的PDF文档在CoreGraphics框架中，有两个类型与PDF文档的渲染有关，分别为CGPDFDocumentRef与CGPDFPageRef。其中，CGPDFDocumentRef对应整个PDF文档，里面封装了许多文档相关的信息，CGPDFPageRef对应PDF文档中某一页的内容，通过它开发者可以将PDF内容通过CGContext上下文渲染到指定目标上。 如下代码演示了在自定义View的drawRect:方法中进行PDF文档的绘制： 12345678910111213141516171819202122-(void)drawRect:(CGRect)rect&#123; //由于坐标系不同，需要进行翻转 CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); //获取pdf文件的路径 NSString * path = [[NSBundle mainBundle] pathForResource:@\"MyText\" ofType:@\"pdf\"]; CFStringRef pathString = CFStringCreateWithCString(NULL, [path cStringUsingEncoding:NSUTF8StringEncoding], kCFStringEncodingUTF8); //创建url CFURLRef url = CFURLCreateWithFileSystemPath(NULL, pathString, kCFURLPOSIXPathStyle, 0); CFRelease(pathString); //进行CGPDFDocumentRef引用的创建 CGPDFDocumentRef document = CGPDFDocumentCreateWithURL(url); CFRelease(url); //获取文档的第1页 CGPDFPageRef page1 = CGPDFDocumentGetPage(document, 1); //进行绘制 CGContextDrawPDFPage(contextRef, page1); CGPDFPageRelease(page1); CGPDFDocumentRelease(document);&#125; 效果如下： CGPDFDocument中提供的方法解析如下： 1234567891011121314151617181920212223242526272829303132//通过数据提供者类来创建PDF文档对象CGPDFDocumentRef CGPDFDocumentCreateWithProvider(CGDataProviderRef cg_nullable provider);//通过url来创建PDF文档CGPDFDocumentRef CGPDFDocumentCreateWithURL(CFURLRef cg_nullable url);//进行引用计数+1CGPDFDocumentRef CGPDFDocumentRetain(CGPDFDocumentRef cg_nullable document);//进行引用计数-1,需要注意，其作用和CFRelease()相似，不同的是如果document为NULL，不是发生crashvoid CGPDFDocumentRelease(CGPDFDocumentRef cg_nullable document);//获取PDF文档的版本void CGPDFDocumentGetVersion(CGPDFDocumentRef cg_nullable document, int * majorVersion, int * minorVersion);//判断文档是否是加密的bool CGPDFDocumentIsEncrypted(CGPDFDocumentRef cg_nullable document);//使用密码对PDF文档进行解密 返回值为1表示解密成功bool CGPDFDocumentUnlockWithPassword(CGPDFDocumentRef cg_nullable document, const char * password);//判断PDF文档是否已经解锁bool CGPDFDocumentIsUnlocked(CGPDFDocumentRef cg_nullable document);//获取此PDF文档是否允许绘制bool CGPDFDocumentAllowsPrinting(CGPDFDocumentRef cg_nullable document);//获取此文档是否允许拷贝bool CGPDFDocumentAllowsCopying(CGPDFDocumentRef cg_nullable document);//获取PDF文档的总页数size_t CGPDFDocumentGetNumberOfPages(CGPDFDocumentRef cg_nullable document);//获取文档中某页数据CGPDFPageRef __nullable CGPDFDocumentGetPage(CGPDFDocumentRef cg_nullable document, size_t pageNumber);//获取文档的目录信息CGPDFDictionaryRef __nullable CGPDFDocumentGetCatalog(CGPDFDocumentRef cg_nullable document);//获取文档详情信息CGPDFDictionaryRef __nullable CGPDFDocumentGetInfo(CGPDFDocumentRef cg_nullable document);//获取文档idCGPDFArrayRef __nullable CGPDFDocumentGetID(CGPDFDocumentRef cg_nullable document);//获取CGPDFDocument类在CoreGraphics框架中的idCFTypeID CGPDFDocumentGetTypeID(void); CGPDFDocument中还有一些已经弃用的方法，这些方法现在封装在CGPDFPage中，弃用的方法如下： 123456CGRect CGPDFDocumentGetMediaBox(CGPDFDocumentRef cg_nullable document,int page);CGRect CGPDFDocumentGetCropBox(CGPDFDocumentRef cg_nullable document, int page);CGRect CGPDFDocumentGetBleedBox(CGPDFDocumentRef cg_nullable document, int page);CGRect CGPDFDocumentGetTrimBox(CGPDFDocumentRef cg_nullable document, int page);CGRect CGPDFDocumentGetArtBox(CGPDFDocumentRef cg_nullable document, int page);int CGPDFDocumentGetRotationAngle(CGPDFDocumentRef cg_nullable document, int page); CGPDFPage中的主要方法列举如下： 1234567891011121314151617181920212223//进行引用计数+1CGPDFPageRef CGPDFPageRetain(CGPDFPageRef cg_nullable page);//进行引用计数-1void CGPDFPageRelease(CGPDFPageRef cg_nullable page);//获取对应的PDF文档对象CGPDFDocumentRef __nullable CGPDFPageGetDocument(CGPDFPageRef cg_nullable page);//获取当前页是文档中的第几页size_t CGPDFPageGetPageNumber(CGPDFPageRef cg_nullable page);//获取与文档此页相关联的媒体区域/*typedef CF_ENUM (int32_t, CGPDFBox) &#123; kCGPDFMediaBox = 0, kCGPDFCropBox = 1, kCGPDFBleedBox = 2, kCGPDFTrimBox = 3, kCGPDFArtBox = 4&#125;;*/CGRect CGPDFPageGetBoxRect(CGPDFPageRef cg_nullable page, CGPDFBox box);//获取此页的旋转角度int CGPDFPageGetRotationAngle(CGPDFPageRef cg_nullable page);//transform变换CGAffineTransform CGPDFPageGetDrawingTransform(CGPDFPageRef cg_nullable page, CGPDFBox box, CGRect rect, int rotate, bool preserveAspectRatio); 二、使用代码创建PDF文件如下示例代码演示了创建PDF文档的过程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354-(void)creatPDF&#123; //绘图上下文 CGContextRef pdfContext; CFStringRef path; CFURLRef url; CFDataRef boxData = NULL; CFMutableDictionaryRef myDictionary = NULL; CFMutableDictionaryRef pageDictionary = NULL; //文件存放的路径 NSString * filePath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, true).firstObject; NSLog(@\"%@\",filePath); const char * filename = [[NSString stringWithFormat:@\"%@/MyText\",filePath] cStringUsingEncoding:kCFStringEncodingUTF8]; path = CFStringCreateWithCString (NULL, filename,kCFStringEncodingUTF8); url = CFURLCreateWithFileSystemPath (NULL, path,kCFURLPOSIXPathStyle, 0); CFRelease (path); //文档信息字典 myDictionary = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); //设置文档名称 CFDictionarySetValue(myDictionary, kCGPDFContextTitle, CFSTR(\"My PDF File\")); //设置创建者 CFDictionarySetValue(myDictionary, kCGPDFContextCreator, CFSTR(\"My Name\")); //设置文档尺寸 CGRect pageRect = CGRectMake(0, 0, 200, 200); //创建文档 pdfContext = CGPDFContextCreateWithURL (url, &amp;pageRect, myDictionary); CFRelease(myDictionary); CFRelease(url); //设置内容信息字典 pageDictionary = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); boxData = CFDataCreate(NULL,(const UInt8 *)&amp;pageRect, sizeof (CGRect)); CFDictionarySetValue(pageDictionary, kCGPDFContextMediaBox, boxData); //开始渲染一页 CGPDFContextBeginPage (pdfContext, pageDictionary); CGFloat colors[4] = &#123;1,0,0,1&#125;; CGContextSetFillColorSpace(pdfContext, CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB)); CGContextSetFillColor(pdfContext, colors); CGContextFillRect(pdfContext, CGRectMake(0, 0, 100, 100)); //结束此页的渲染 CGPDFContextEndPage (pdfContext); //开始新一页内容的渲染 CGPDFContextBeginPage (pdfContext, pageDictionary); CGContextSetFillColorSpace(pdfContext, CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB)); CGContextSetFillColor(pdfContext, colors); CGContextFillRect(pdfContext, CGRectMake(0, 0, 100, 100)); CGPDFContextEndPage (pdfContext); CGContextRelease (pdfContext); CFRelease(pageDictionary); CFRelease(boxData);&#125; 上面代码创建出的PDF文件如下图所示： 在创建PDF文档时，开发者还可以使用如下列举的方法来对文档进行超链接添加，内容信息设置等： 1234567891011121314//关闭文档上下文，关闭后将不能再次写入void CGPDFContextClose(CGContextRef cg_nullable context);//开启新一页内容的绘制void CGPDFContextBeginPage(CGContextRef cg_nullable context, CFDictionaryRef __nullable pageInfo);//结束当前页内容的绘制void CGPDFContextEndPage(CGContextRef cg_nullable context);//添加元数据void CGPDFContextAddDocumentMetadata(CGContextRef cg_nullable context, CFDataRef __nullable metadata);//为某个区域添加超链接void CGPDFContextSetURLForRect(CGContextRef cg_nullable context, CFURLRef url, CGRect rect);//在文档的某个点添加一个目标void CGPDFContextAddDestinationAtPoint(CGContextRef cg_nullable context, CFStringRef name, CGPoint point);//为某个区域添加跳转目标功能void CGPDFContextSetDestinationForRect(CGContextRef cg_nullable context, CFStringRef name, CGRect rect); 在设置文档信息字典时，支持的常用键如下： 1234567891011121314151617181920//设置文档标题 可选设置const CFStringRef kCGPDFContextTitle;//设置文档的作者 可选设置const CFStringRef kCGPDFContextAuthor;//设置文档的副标题 可选设置const CFStringRef kCGPDFContextSubject;//为文档设置关键字 可选设置 可以设置为一个数组 设置多个关键字const CFStringRef kCGPDFContextKeywords;//设置文档的创建者const CFStringRef kCGPDFContextCreator;//为文档设置所有者密码const CFStringRef kCGPDFContextOwnerPassword;//为文档设置用户密码const CFStringRef kCGPDFContextUserPassword;//设置加密密钥长度const CFStringRef kCGPDFContextEncryptionKeyLength;//设置是否允许绘制const CFStringRef kCGPDFContextAllowsPrinting;//设置是否允许复制const CFStringRef kCGPDFContextAllowsCopying; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Bootstrap响应式前端框架笔记四——表单","slug":"271 Bootstrap响应式前端框架笔记四——表单","date":"2016-12-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.355Z","comments":true,"path":"2016/12/06/271 Bootstrap响应式前端框架笔记四——表单/","link":"","permalink":"http://huishao.cc/2016/12/06/271 Bootstrap响应式前端框架笔记四——表单/","excerpt":"","text":"Bootstrap响应式前端框架笔记四——表单一、基本表单样式在Bootstrap框架中，可以为表单标签添加form-control属性来为其设置默认样式，默认表单控件的宽度将充满父容器标签。需要注意，在布局表单时，可以为其设置一个label标签用于说明，将label标签的for属性与表单标签的id相对应，可以实现当用户点击label标签时使其对应的表单自动获取输入焦点。示例代码如下： 1234567891011121314151617&lt;p&gt;Bootstrap为默认的表单便签添加了样式&lt;/p&gt;&lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail1\"&gt;Email address&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Enter email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputPassword1\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt;性别 &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt; 需要注意，将label和表单标签包裹在form-group类内，会自动进行间距的布局设置。效果如下： 默认情况下，label与表单元素的排列是竖直布局的，可以使用form-horizontal类来将其设置为水平布局，示例如下： 1234567891011121314151617181920&lt;p&gt;使用from-horizontal类可以将label与表单进行水平排列，并可以结合栅格系统使用&lt;/p&gt;&lt;form class=\"form-horizontal\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputEmail3\" class=\"col-sm-2\"&gt;Email&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"email\" class=\"form-control\" id=\"inputEmail3\" placeholder=\"Email\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputPassword3\" class=\"col-sm-2\"&gt;Password&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"password\" class=\"form-control\" id=\"inputPassword3\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-offset-2 col-sm-10\"&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 效果如下： 二、选择框与下拉列表HTML中有单选框和复选框两种选择框标签。示例代码如下： 123456789101112131415161718192021222324252627282930313233&lt;p&gt;默认的单选框与复选框样式&lt;/p&gt;&lt;p&gt;复选框&lt;/p&gt;&lt;div class=\"checkbox\"&gt;&lt;label&gt; &lt;input type=\"checkbox\" name=\"\" id=\"\" value=\"\" /&gt; 足球&lt;/label&gt;&lt;/div&gt;&lt;div class=\"checkbox\"&gt;&lt;label&gt; &lt;input type=\"checkbox\" name=\"\" id=\"\" value=\"\" /&gt; 篮球&lt;/label&gt;&lt;/div&gt;&lt;div class=\"checkbox\"&gt;&lt;label&gt; &lt;input type=\"checkbox\" name=\"\" id=\"\" value=\"\" /&gt; 乒乓球&lt;/label&gt;&lt;/div&gt;&lt;p&gt;单选框&lt;/p&gt;&lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"sex\"/&gt; 男 &lt;/label&gt;&lt;/div&gt;&lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"sex\"/&gt; 女 &lt;/label&gt;&lt;/div&gt; 可以看到，默认的单选框与复选框的排列也是垂直布局的，使用checkbox-inline类和radio-inline类可以实现水平排列布局，示例如下： 123456789101112131415161718192021222324252627282930313233&lt;p&gt;水平排列的单选框与复选框样式&lt;/p&gt;&lt;p&gt;复选框&lt;/p&gt;&lt;div class=\"checkbox-inline\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" name=\"\" id=\"\" value=\"\" /&gt; 足球&lt;/label&gt;&lt;/div&gt;&lt;div class=\"checkbox-inline\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" name=\"\" id=\"\" value=\"\" /&gt; 篮球&lt;/label&gt;&lt;/div&gt;&lt;div class=\"checkbox-inline\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" name=\"\" id=\"\" value=\"\" /&gt; 乒乓球&lt;/label&gt;&lt;/div&gt;&lt;p&gt;单选框&lt;/p&gt;&lt;div class=\"radio-inline\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"sex\"/&gt; 男 &lt;/label&gt;&lt;/div&gt;&lt;div class=\"radio-inline\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"sex\"/&gt; 女 &lt;/label&gt;&lt;/div&gt; 效果如下图： Bootstrap框架中默认的下拉列表样式示例如下： 12345678&lt;p&gt;默认的下拉列表&lt;/p&gt;&lt;select class=\"form-control\"&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;郑州&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt;&lt;/select&gt; 效果如下： 开发者也可以通过添加multiple参数的方式来进行下拉选项的全部展示，示例如下： 12345678&lt;p&gt;使用multiple参数来进行下拉选项的全部展示&lt;/p&gt;&lt;select multiple class=\"form-control\"&gt; &lt;option&gt;上海&lt;/option&gt; &lt;option&gt;北京&lt;/option&gt; &lt;option&gt;郑州&lt;/option&gt; &lt;option&gt;深圳&lt;/option&gt; &lt;option&gt;广州&lt;/option&gt;&lt;/select&gt; 效果如下： 三、表单状态为表单元素添加disabled属性来将表单设置为禁用状态，示例如下： 1234567&lt;p&gt;禁用表单&lt;/p&gt;&lt;input class=\"form-control\" placeholder=\"被禁用的输入框\" type=\"text\" disabled/&gt;&lt;div class=\"checkbox\"&gt;&lt;label&gt; &lt;input type=\"checkbox\" disabled/&gt;被禁用的复选框&lt;/label&gt;&lt;/div&gt; 效果如下： 如果在开发中需要使一组的表单元素全部处于禁用状态，可以使用fieldset标签进行包裹，并为fieldset标签添加disabled属性。示例如下： 123456789101112131415161718192021 &lt;p&gt;进行一组表单元素的禁用&lt;/p&gt; &lt;form&gt; &lt;fieldset disabled&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"disabledTextInput\"&gt;被禁用的输入框&lt;/label&gt; &lt;input type=\"text\" id=\"disabledTextInput\" class=\"form-control\" placeholder=\"被禁用的输入框\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"disabledSelect\"&gt;被禁用的下拉菜单&lt;/label&gt; &lt;select id=\"disabledSelect\" class=\"form-control\"&gt; &lt;option&gt;被禁用的下拉菜单&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; 被禁用的选择框&lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;被禁用的按钮&lt;/button&gt; &lt;/fieldset&gt; &lt;/form&gt; 效果如下： Bootstrap中也定义好了一些校验状态的样式，例如警告，成功，错误等状态，为表单元素的父标签添加这些状态类即可，示例如下： 123456789101112&lt;p&gt;校验状态&lt;/p&gt;&lt;form&gt; &lt;div class=\"has-error form-group\"&gt; &lt;input class=\"form-control\" placeholder=\"错误状态的表单\" type=\"text\" /&gt; &lt;/div&gt; &lt;div class=\"has-success form-group\"&gt; &lt;input class=\"form-control\" placeholder=\"成功状态的表单\" type=\"text\" /&gt; &lt;/div&gt; &lt;div class=\"has-warning form-group\"&gt; &lt;input class=\"form-control\" placeholder=\"警告状态的表单\" type=\"text\" /&gt; &lt;/div&gt;&lt;/form&gt; 效果如下： 开发者也可以为验证表单的右侧添加一个小图标，前提需要为表单元素的父元素设置has-feedback类，示例如下： 123456789101112131415&lt;p&gt;为表单添加右侧icon&lt;/p&gt;&lt;form&gt; &lt;div class=\"form-group has-error has-feedback \"&gt; &lt;input class=\"form-control\" placeholder=\"错误状态的表单\" type=\"text\" /&gt; &lt;span class=\"glyphicon glyphicon-eur form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"has-success form-group has-feedback\"&gt; &lt;input class=\"form-control\" placeholder=\"成功状态的表单\" type=\"text\" /&gt; &lt;span class=\"glyphicon glyphicon-ok form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"has-warning form-group has-feedback\"&gt; &lt;input class=\"form-control\" placeholder=\"警告状态的表单\" type=\"text\" /&gt; &lt;span class=\"glyphicon glyphicon-off form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 效果如下： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/form.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记三——代码与表格","slug":"270Bootstrap响应式前端框架笔记三——代码与表格","date":"2016-12-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.354Z","comments":true,"path":"2016/12/05/270Bootstrap响应式前端框架笔记三——代码与表格/","link":"","permalink":"http://huishao.cc/2016/12/05/270Bootstrap响应式前端框架笔记三——代码与表格/","excerpt":"","text":"Bootstrap响应式前端框架笔记三——代码与表格一、代码在技术博客文章类页面的开发中，常常需要在文本总插入说明代码，使用code便签可以创建这种效果，示例如下： 12&lt;p&gt;code标签用于在文本中插入代码&lt;/p&gt;&lt;div&gt;定义变量a:&lt;code&gt;int a = 3; &lt;/code&gt;&lt;/div&gt; 效果如下： kbd标签可以用来提示进行键盘输入，示例如下： 12&lt;p&gt;kbd标签可以创建用户键盘输入的效果&lt;/p&gt;&lt;div&gt;使用键盘上的&lt;kbd&gt;control&lt;/kbd&gt;+&lt;kbd&gt;v&lt;/kbd&gt;来进行文本的粘贴&lt;/div&gt; 效果： 可以使用pre标签来进行成段代码的插入，同时可以使用pre-scrollable类来将代码块修饰为可滚动的，示例如下： 1234567&lt;pre class=\"pre-scrollable\"&gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=\"UTF-8\"&amp;gt; &amp;lt;link rel=\"stylesheet\" href=\"../bower_components/bootstrap/dist/css/bootstrap.min.css\" /&amp;gt; &amp;lt;title&amp;lt;代码与表格&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&lt;/pre&gt; 效果如下： 除了上面描述的标签和类外，一般情况下，程序中的变量会以斜体来显示，也可以使用var标签来包裹，程序输出结果可以使用samp标签来包裹。 二、表格为H5标签table添加table类可以使用Bootstrap定义的表格样式，示例如下: 1234567891011121314&lt;p&gt;使用table标签添加table类可以进行表格的创建&lt;/p&gt;&lt;table class=\"table\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： 为表格添加tabke-striped类可以实现斑马纹样式的表格，示例如下： 12345678910111213141516171819&lt;p&gt;使用table-striped类可以为表格添加斑马纹&lt;/p&gt;&lt;table class=\"table table-striped\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： Bootstrap默认的列表样式是不带边框的，可以使用table-bordered类来为列表添加边框，示例如下： 12345678910111213141516171819&lt;p&gt;使用table-boardered类可以为表格添加边框&lt;/p&gt;&lt;table class=\"table table-striped table-bordered\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： 使用table-hover类修饰的列表，当鼠标悬停时会有高亮效果，示例如下： 12345678910111213141516171819&lt;p&gt;使用table-hover类修饰的列表，当鼠标悬停时 会有高亮效果&lt;/p&gt;&lt;table class=\"table table-hover\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 使用.table-condensed类可以是默认的列表padding减半。 对于行标签tr与列表前th，开发者也可以使用如下类来修饰，为其指定状态： .active类：将此行或者此列标记为高亮状态。 .success类：将此行或者此列标记为成功状态。 .info类：将此行或者此列标记为详情状态。 .warning类：将此行或者此列标记为警告状态。 .danger类：将此行或者此列标记为危险状态。 示例代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;p&gt;为列表设置状态&lt;/p&gt;&lt;table class=\"table table-hover table-condensed\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"active\"&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"info\"&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;CJ&lt;/th&gt; &lt;th&gt;19&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"warning\"&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th class=\"danger\"&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： 列表元素也可以包裹在table-responsive类内，此时列表会变成响应式列表，当屏幕尺寸小于768px时，会自动出现水平滚动条。 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/codeAndGroup.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS开发CoreGraphics核心图形框架之八——层聚合","slug":"269iOS开发CoreGraphics核心图形框架之八——层聚合","date":"2016-12-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.354Z","comments":true,"path":"2016/12/04/269iOS开发CoreGraphics核心图形框架之八——层聚合/","link":"","permalink":"http://huishao.cc/2016/12/04/269iOS开发CoreGraphics核心图形框架之八——层聚合/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之八——层聚合正常情况下，在使用CoreGraphics框架中的方法进行图形绘制时，每一闭合的图形都是一个独立的层，如果在绘制时添加了阴影效果，则通过阴影可以很明显的看到图形的分层情况，后绘制的图形在上层，先绘制的图形在下层，示例代码如下： 123456789101112131415-(void)drawRect:(CGRect)rect&#123; float width = rect.size.width/2; CGPoint center = CGPointMake(rect.size.width/2, rect.size.height/2); CGSize myShadowOffset = CGSizeMake (10, -20); CGContextRef myContext = UIGraphicsGetCurrentContext(); //设置阴影 CGContextSetShadow (myContext, myShadowOffset, 10); //绘制三个圆形 CGContextSetRGBFillColor (myContext, 0, 1, 0, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/2, center.y-width/4*3, width, width)); CGContextSetRGBFillColor (myContext, 0, 0, 1, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/4, center.y-width/4, width, width)); CGContextSetRGBFillColor (myContext, 1, 0, 0, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/4*3, center.y-width/4, width, width));&#125; 运行效果如下图所示： 从图中可以发现，所绘制的3个圆形并非是在同一层级上，有时开发者可能需要绘制边界复杂的图形，还以上面的例子来说，如果开发者需要绘制某个图形的边界是有3个圆形拼接而成，出现这样的层级效果是不合理的。CoreGraphics框架中也提供了进行图形聚合绘制的方法，示例如下： 123456789101112131415161718-(void)drawRect:(CGRect)rect&#123; float width = rect.size.width/2; CGPoint center = CGPointMake(rect.size.width/2, rect.size.height/2); CGSize myShadowOffset = CGSizeMake (10, -20); CGContextRef myContext = UIGraphicsGetCurrentContext(); CGContextSetShadow (myContext, myShadowOffset, 10); CGContextBeginTransparencyLayer (myContext, NULL); //开启图形聚合绘制 //之后的绘制代码都将绘制到统一层上 CGContextSetRGBFillColor (myContext, 0, 1, 0, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/2, center.y-width/4*3, width, width)); CGContextSetRGBFillColor (myContext, 0, 0, 1, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/4, center.y-width/4, width, width)); CGContextSetRGBFillColor (myContext, 1, 0, 0, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/4*3, center.y-width/4, width, width)); //结束聚合绘制 CGContextEndTransparencyLayer (myContext);&#125; 效果如下图所示： 有了聚合绘制这样的方法，进行复杂图形的绘制将更加灵活！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Bootstrap响应式前端框架笔记二——排版标签与类","slug":"268Bootstrap响应式前端框架笔记二——排版标签与类","date":"2016-12-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.354Z","comments":true,"path":"2016/12/03/268Bootstrap响应式前端框架笔记二——排版标签与类/","link":"","permalink":"http://huishao.cc/2016/12/03/268Bootstrap响应式前端框架笔记二——排版标签与类/","excerpt":"","text":"Bootstrap响应式前端框架笔记二——排版标签与类Bootstrap中对h标签的字体和字号进行了微调，开发者除了可以直接使用这些标签进行标题的修饰外，还可以使用.h1到.h6类来将其他元素的字体进行修饰，示例如下： 123456789101112131415&lt;p&gt;h1 到 h6 标签的样式&lt;/p&gt;&lt;h1&gt;h1. Bootstrap heading&lt;/h1&gt;&lt;h2&gt;h2. Bootstrap heading&lt;/h2&gt;&lt;h3&gt;h3. Bootstrap heading&lt;/h3&gt;&lt;h4&gt;h4. Bootstrap heading&lt;/h4&gt;&lt;h5&gt;h5. Bootstrap heading&lt;/h5&gt;&lt;h6&gt;h6. Bootstrap heading&lt;/h6&gt;&lt;hr /&gt;&lt;p&gt;.h1 到 .h6 类的样式&lt;/p&gt;&lt;div class=\"h1\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h2\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h3\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h4\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h5\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h6\"&gt;h1. Bootstrap heading&lt;/div&gt; 在标题或者其他标签中使用small标签或者small类可以添加内部副标题，副标题除了字号会进行缩小调整外，还会修改文字的颜色，示例如下： 123&lt;p&gt;可以使用small标签或者.samll类来向标题中添加副标题&lt;/p&gt;&lt;h3&gt;h3标题 &lt;small&gt;small标签副标题&lt;/small&gt;&lt;/h3&gt;&lt;span class=\"h3\"&gt;h3Class类 &lt;span class=\"small\"&gt;small类副标题&lt;/span&gt;&lt;/span&gt; 效果如下： 使用.lead可以实现段落的强调显示，示例如下： 123&lt;p&gt;这是一个普通段落&lt;/p&gt;&lt;p class=\"lead\"&gt;这是一个强调段落&lt;/p&gt;&lt;p&gt;这是一个普通段落&lt;/p&gt; 效果如下： 使用mark标签或者mark类可以进行特殊文本的标记，如下： 12&lt;p&gt;使用mark标签可以实现部分文本进行标记&lt;/p&gt;&lt;div class=\"mark\"&gt;进行&lt;mark&gt;特殊文字&lt;/mark&gt;的标记&lt;/div&gt; 效果如下： 使用del标签或者s标签可以实现对文本添加删除线效果，如下： 1234&lt;p&gt;使用del标签或者s标签可以实现文本的删除效果&lt;/p&gt;&lt;del&gt;del标签的删除效果&lt;/del&gt;&lt;br /&gt;&lt;s&gt;s标签的删除效果&lt;/s&gt; 效果如下： 使用ins标签或者u标签可以实现为本文添加下划线效果，示例如下： 1234&lt;p&gt;使用ins标签或者u标签可以实现文本添加下划线&lt;/p&gt;&lt;ins&gt;ins标签的下划线效果&lt;/ins&gt;&lt;br /&gt;&lt;u&gt;u标签的下划线效果&lt;/u&gt; 效果如下： 使用strong标签可以对特殊本文进行着重标记，如下: 12&lt;p&gt;使用strong标签可以实现对特殊文本进行着重标记&lt;/p&gt;&lt;div&gt;进行文本的&lt;strong&gt;着重&lt;/strong&gt;标记&lt;/div&gt; 效果如下图 使用em标签可以进行特殊文本的斜体处理，如下： 12&lt;p&gt;使用em标签可以进行文本的斜体处理&lt;/p&gt;&lt;p&gt;进行&lt;em&gt;特殊文本&lt;/em&gt;的斜体处理&lt;/p&gt; 效果如下： 使用text-left类可以实现文本的左对齐布局，与之对应text-center将文本进行中心对齐布局，text-right类来将文本进行右对齐布局，text-justufy类设置文本进行自适应对齐，text-nowarp类将设置文本不换行的进行布局，示例如下： 12345678910&lt;mark&gt;text-left类进行左对齐布局&lt;/mark&gt;&lt;p class=\"text-left \"&gt;文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。&lt;/p&gt;&lt;mark&gt;text-center类进行中心对齐布局&lt;/mark&gt;&lt;p class=\"text-center \"&gt;文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。&lt;/p&gt;&lt;mark&gt;text-right类进行右对齐布局&lt;/mark&gt;&lt;p class=\"text-right \"&gt;文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。&lt;/p&gt;&lt;mark&gt;text-justify类进行自适应布局&lt;/mark&gt;&lt;p class=\"text-justify \"&gt;正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。&lt;/p&gt;&lt;mark&gt;text-nowarp类进行不换行布局&lt;/mark&gt;&lt;p class=\"text-nowrap\"&gt;不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。&lt;/p&gt; 效果如下图： text-lowercase类可以将所有修饰的文本转换成小写，与之对应text-uppercase类可以将所有修饰的文本转换成大写，text-capitalize类则只会处理每个单词的首字母，将其转换为大写。示例如下： 123456&lt;mark&gt;将所有字母转换成小写字母&lt;/mark&gt;&lt;p class=\"text-lowercase\"&gt;My name is Jaki.&lt;/p&gt;&lt;mark&gt;将所有字母转换成大写字母&lt;/mark&gt;&lt;p class=\"text-uppercase\"&gt;My name is Jaki.&lt;/p&gt;&lt;mark&gt;将所有单词首字母字母转换成大写字母&lt;/mark&gt;&lt;p class=\"text-capitalize\"&gt;My name is Jaki.&lt;/p&gt; 效果如下图： 使用abbr标签可以进行某些内容的缩略显示，示例如下： 12使用abbr标签可以将某些文本进行缩略设置，当鼠标放置在对应文本上时，会显示标签中title所设置的内容&lt;abbr title=\"这个是详细信息\"&gt;信息&lt;/abbr&gt; 效果如下： 如果要在页面中进行内容的引用，可以使用blockquote标签进行包裹，在blockquote标签中可以继续嵌套footer标签来进行引用的标注，如下： 12345使用blockquote标签可以进行内容的引用，其中可以嵌套fooer标签进行标注&lt;blockquote&gt; &lt;p&gt;冰冻三尺，非一日之寒。&lt;/p&gt; &lt;footer&gt;俗语&lt;/footer&gt;&lt;/blockquote&gt; 效果如下图所示： .blockquote-reverse类可以将blockquote中的内容进行右对齐，示例如下： 12345&lt;hr /&gt; 使用blockquote标签可以进行内容的引用，其中可以嵌套fooer标签进行标注&lt;blockquote class=\"blockquote-reverse\"&gt; &lt;p&gt;冰冻三尺，非一日之寒。&lt;/p&gt; &lt;footer&gt;俗语&lt;/footer&gt;&lt;/blockquote&gt; 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/typeset.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记一——强大的栅格布局","slug":"267Bootstrap响应式前端框架笔记一——强大的栅格布局","date":"2016-11-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.354Z","comments":true,"path":"2016/12/01/267Bootstrap响应式前端框架笔记一——强大的栅格布局/","link":"","permalink":"http://huishao.cc/2016/12/01/267Bootstrap响应式前端框架笔记一——强大的栅格布局/","excerpt":"","text":"Bootstrap响应式前端框架笔记一——强大的栅格布局一、Bootstrap？Bootstrap是一款HTML，Css和JavaScript开发框架，其也支持开发者进行自定义构建，开发者也可以只打包自己需要的功能模块使用。Bootstrap的中文网址如下： http://v3.bootcss.com/。 Bootstrap是一款响应式的编程框架，所谓响应式，是指在不同屏幕尺寸的设备上，使用Bootstrap开发的项目可以自动进行布局调整适配。其响应式布局的核心是栅格系统，栅格系统将浏览器分隔成一定数量的行和列。默认栅格系统将浏览器窗口分为12列，开发者可以为元素设置其在对应设备尺寸中所占的列数。 二、均分与尺寸适配Bootstrap将浏览器尺寸分为4个等级，分别为xs，sm，md和lg。xs是指浏览器宽度小于768时的状态，一般对应移动手机设备，sm指浏览器宽度大于768且小于992时的状态，其一般对应平板设备，md指浏览器宽度大于768且小于1200时的状态，一般对应正常的个人电脑，lg是指浏览器宽度大于1200时的状态。如下表所示： 在开发者使用栅格类对标签进行定义的时候，需要注意，如果只设置了高等级的栅格类，则在此等级以下的浏览器尺寸都将采用竖直堆叠，此等级及以上等级的浏览器尺寸中都将水平排列。例如，如果配置了两个标签的类都为为col-md-6，则在992以下尺寸的的浏览器中竖直堆叠布局，在992即以上尺寸的浏览器中都将水平均分一行。 栅格系统的一行中被分成了12列，默认一行中也最多可以添加12个列，如下代码演示了竖直堆叠布局与水平布局在栅格系统中的应用： 123456789101112131415161718192021222324252627282930313233343536373839&lt;body class=\"container\"&gt; &lt;p&gt;将md以上尺寸窗口宽度分为12份，md一下尺寸的窗口将竖直堆叠排列&lt;/p&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p&gt;将md以上尺寸的窗口宽度进行2等分，md一下尺寸的窗口将竖直堆叠排列&lt;/p&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p&gt;将md以上尺寸的窗口宽度进行2:1等分，md一下尺寸的窗口将竖直堆叠排列&lt;/p&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;.col-md-8&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p&gt;将xs以上尺寸的窗口宽度进行6等分，xs为最小等级&lt;/p&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 上面代码在窗口尺寸大于等于992时的效果如下所示： 将浏览器窗口缩小，可以看到，除了第4行可以继续保持6等分外，其它行等变成了竖直堆叠布局： 如果需要对移动设备和桌面是被进行布局的区别化，可以为某个标签配置多套不同等级下的栅格类，示例如下： 1234567&lt;p&gt;在md及以上尺寸窗口中进行4等分，在md以下尺寸sm以上尺寸窗口进行2等分布局，在sm以下储存窗口进行竖直堆叠布局&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-3 col-sm-6\"&gt;.col-md-3 .col-sm-6&lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6\"&gt;.col-md-3 .col-sm-6&lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6\"&gt;.col-md-3 .col-sm-6&lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6\"&gt;.col-md-3 .col-sm-6&lt;/div&gt;&lt;/div&gt; 需要注意，默认Bootstrap中一行最多可以包含12列，如果列数超出12，将另起一行进行布局，示例如下： 123456&lt;p&gt;Bootstrap最多一行可以分配12列，超出将另起一行，例如下面三个div，宽度分别为8，3，4，第3个div将另起一行布局&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;.col-md-8&lt;/div&gt; &lt;div class=\"col-md-3\"&gt;.col-md-3&lt;/div&gt; &lt;div class=\"col-md-4 \"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt; 效果如下图： 三、列的调整很多场景下，每列元素的高度并不一定均等，在列高度不均等情况下的栅格布局，很可能会出现开发者意想不到的布局差错，示例代码如下： 123456&lt;p&gt;列高度不均等造成的布局错乱&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-4 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4 \"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt; 上面代码的栅格布局效果如下： 如图所示，开发者本意是将第3个div另起一行进行布局，由于前两个div高度的不均等，导致第3个div直接布局在了第2个div下面，可以通过visible-md-block等类来进行强制另起一行，示例如下： 12345678&lt;p&gt;解决列高度不均等造成的布局错乱&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-4 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"clearfix visible-md-block\"&gt;&lt;/div&gt; &lt;div class=\"col-md-4 \"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt; 效果如下： 在使用栅格布局时，开发者也不需要将每一行中的12列都占满，可以通过列偏移设置来进行列的定位，示例如下： 123456789&lt;p&gt;进行列偏移操作&lt;/p&gt;&lt;p&gt;将占1/3行的一列向右便宜1/3行 使其固定在中间&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-offset-4\"&gt;.col-md-4 .col-md-offset-4&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-2\"&gt;.col-md-2&lt;/div&gt; &lt;div class=\"col-md-2 col-md-offset-8\"&gt;.col-md-2 .col-md-offset-8&lt;/div&gt;&lt;/div&gt; 效果如下： Bootstrap的栅格系统也支持进行列的嵌套，需要注意，在嵌套中也不可以超过12列，示例如下： 123456789&lt;p&gt;进行列的嵌套&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;.col-md-8 &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下图所示： .col-md-push- 和 .col-md-pull-两个类可以方便的实现对列的移动，示例如下： 12345&lt;p&gt;进行列的移动&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-2 col-md-push-8\"&gt;.col-md-8 向右移动8格&lt;/div&gt; &lt;div class=\"col-md-2 col-md-pull-2\"&gt;.col-md-2 向左移动2格&lt;/div&gt;&lt;/div&gt; 效果如下： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/gridSystem.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS开发CoreGraphics核心图形框架之七——图像处理","slug":"266iOS开发CoreGraphics核心图形框架之七——图像处理","date":"2016-11-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.353Z","comments":true,"path":"2016/11/28/266iOS开发CoreGraphics核心图形框架之七——图像处理/","link":"","permalink":"http://huishao.cc/2016/11/28/266iOS开发CoreGraphics核心图形框架之七——图像处理/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之七——图像处理一、引言位图图像数据实际上一个像素阵列，其中每个像素代表了图像中的一个点。位图实际上只支持矩形区域的渲染，但是使用透明技术可以实现任意形状图像的渲染。开发者也可以对要进行渲染的图像进行旋转、切割等操作。 二、通过图像裁剪创建图像CoreGraphics框架中提供了许多方法来创建位图数据引用CGImageRef对象，其中封装在CGImage.h文件中。在UIKit框架中也提供了方便的接口供开发者进行CGImageRef与UIImage对象的相互转换。 通过CoreGraphics框架中提供的图像裁剪方法，开发者可以截取一张大图片中的一部分作为新的图像进行渲染。在Web开发中，为了减少请求次数，常常会将许多小图片合成一张大图片返回给前端，同时还会给前端返回一个json文件，文件中存放着每个独立小图的坐标位置，前端在使用时进行截取即可，这种图片常常被称作雪碧图。在iOS开发中游戏开发中，很多游戏引擎也提供了类似的方法，方便开发者对游戏素材进行管理。实际上，通过CoreGraphics框架，开发者也可以自己实现一套这样的图片加载逻辑，如果在自己的应用中，同时需要异步加载的小图片很多，也可以设计成下载一张大图后从中截取需要的图片。进行图像截取的示例代码如下： 123456789101112-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image\"].CGImage; CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), orignImage); CGImageRef rectImage = CGImageCreateWithImageInRect(orignImage, CGRectMake(300, 400, 800, 400)); CGContextDrawImage(contextRef, CGRectMake(0, 220, 320, 200), rectImage); CGImageRelease(orignImage); CGImageRelease(rectImage);&#125; 效果如下图所示： 需要注意，CGContextDrawImage()方法渲染的图像是上下翻转的，可以通过调整坐标系来将图片翻转回来。 三、通过膜层来实现图像的自定义裁剪通过Mask膜层可以实现炫酷的图像裁剪与风格重绘。膜层可以简单的理解为将一个图层追加到原图层上，但需要注意，图层中颜色为纯黑的部分，会按照原图绘制，纯白的部分会被完全遮挡，这中间的颜色会以特定的算法进行alpha值的更改。例如将如下图片作为膜层绘制到原图像上： 代码如下： 123456789101112131415161718192021-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image\"].CGImage; CGImageRef maskRef = [UIImage imageNamed:@\"maskImage\"].CGImage; //通过图片数据创建膜层 CGImageRef mask = CGImageMaskCreate(CGImageGetWidth(maskRef), CGImageGetHeight(maskRef), CGImageGetBitsPerComponent(maskRef), CGImageGetBitsPerPixel(maskRef), CGImageGetBytesPerRow(maskRef), CGImageGetDataProvider(maskRef), nil, YES); CGImageRef resultImage = CGImageCreateWithMask(orignImage, mask); CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), resultImage); CGImageRelease(orignImage); CGImageRelease(maskRef); CGImageRelease(mask);&#125; 效果如下图所示： 除了使用图片膜层来对原图像数据进行裁剪处理外，还可以通过颜色数据定义膜层来进行裁剪。这个方法就能加强大了，其可以将图像中某个范围的颜色所对应的所有区域裁剪出来。示例代码如下： 1234567891011121314-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image2\"].CGImage; const CGFloat myMaskingColors[6] = &#123;35, 154, 23, 194, 103, 214&#125;; CGImageRef mask2 = CGImageCreateWithMaskingColors(orignImage, myMaskingColors); CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), mask2); CGImageRelease(orignImage); CGImageRelease(mask2);&#125; CGImageCreateWithMaskingColors()这个方法需要两个参数，第一个参数是要进行裁剪的图像，那二个参数需要设置为一个表示色彩的数组，需要注意，这个数组中元素的个数需要是当前色彩空间颜色原色数的两倍，例如RGB色彩空间对应这个数组需要有6个元素{min1,max1,min2,max2,min3,max3}。之后会对图像数据中的每一个像素点进行遍历，假如此像素点的颜色值为{c1,c2,c3}。则当满足如下条件时，这个像素点会被裁剪： min1&lt;c1&lt;max1,min2&lt;c2&lt;max2,min3&lt;c3&lt;max3 需要注意，使用这种方式进行膜层裁剪，原图像不可以有alpha通道，色值的取值范围为0-255之间。上面示例代码会将原图像裁剪成如下效果： 对于被裁剪出来的部分，开发者可以使用其他颜色进行填充，示例代码如下： 123456789101112131415-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image2\"].CGImage; //设置填充 [[UIColor redColor] setFill]; CGContextFillRect(contextRef, CGRectMake(0, 0, 320, 200)); const CGFloat myMaskingColors[6] = &#123;35, 154, 23, 194, 103, 214&#125;; CGImageRef mask2 = CGImageCreateWithMaskingColors(orignImage, myMaskingColors); CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), mask2); CGImageRelease(orignImage);&#125; 效果如下图： 除了上面介绍了两种对图像进行裁剪的方法外，CoreGraphics框架中还提供了一种裁剪方式，示例代码如下： 12345678910111213141516171819-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image2\"].CGImage; CGImageRef maskRef = [UIImage imageNamed:@\"maskImage\"].CGImage; CGImageRef mask = CGImageMaskCreate(CGImageGetWidth(maskRef), CGImageGetHeight(maskRef), CGImageGetBitsPerComponent(maskRef), CGImageGetBitsPerPixel(maskRef), CGImageGetBytesPerRow(maskRef), CGImageGetDataProvider(maskRef), nil, YES); //进行膜层的裁剪 CGContextClipToMask(contextRef, CGRectMake(0, 0, 320, 200), mask); CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), orignImage); CGImageRelease(orignImage);&#125; 四、进行图像混合使用CoreGraphics框架也可以绘制复杂的图像混合效果，在进行图像混合时，需要先绘制背景图像，之后设置图像混合模式，在绘制前景图像，CoreGraphics会根据混合模式来进行最后图像的绘制。例如使用如下背景图像来与前景图像来进行混合： 背景图像： 前景图像： 示例代码如下： 12345678910111213-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef background = [UIImage imageNamed:@\"background\"].CGImage; CGContextDrawImage(contextRef, CGRectMake(60, 25, 200, 150), background); CGContextSetBlendMode(contextRef, kCGBlendModeNormal); CGImageRef orignImage = [UIImage imageNamed:@\"image2\"].CGImage; CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), orignImage); CGImageRelease(background); CGImageRelease(orignImage);&#125; kCGBlendModeNormal模式的混合就是简单覆盖，前景图像会完全将背景图像覆盖，运行效果如下： kCGBlendModeMultiply模式是叠加混合模式，其会将前景图alpha化，效果如下： kCGBlendModeScreen模式会将前景图进行裁剪，最终的结果颜色将比原图轻，效果如下： kCGBlendModeOverlay模式也会将前景图进行裁剪，会保持原图色彩，效果如下： kCGBlendModeDarken混合模式会将原图色值加深，效果如下： kCGBlendModeLighten在混合时则会选择色值较轻的图像进行混合，效果如下： kCGBlendModeColorDodge混合模式效果如下： kCGBlendModeColorBurn混合模式效果如下： kCGBlendModeSoftLight为柔光混合模式，效果如下： kCGBlendModeHardLight为重光混合模式，效果如下： kCGBlendModeDifference差异混合模式会取颜色的逆向值，效果如下： kCGBlendModeExclusion混合模式效果如下： kCGBlendModeHue混合模式会改变色彩的饱和度，效果如下： kCGBlendModeSaturation混合模式效果如下： kCGBlendModeColor混合模式效果如下： kCGBlendModeLuminosity光影混合模式会将前景图进行黑白化，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"使用Express快速搭建前端项目框架","slug":"265使用Express快速搭建前端项目框架","date":"2016-11-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.353Z","comments":true,"path":"2016/11/27/265使用Express快速搭建前端项目框架/","link":"","permalink":"http://huishao.cc/2016/11/27/265使用Express快速搭建前端项目框架/","excerpt":"","text":"使用Express快速搭建前端项目框架Express是基于Node.js的前端Web开发框架，使用其可以简洁快速的创建健壮友好的API服务。在前端或移动端的开发过程中，可以借助Express的这项功能模拟API数据，方便开发调试。 Express是基于Node.js平台的，因此在安装Express之前，需要先安装Node.js。使用如下命令来检查系统中所安装的node版本： 1node -v 如果系统中没有安装Node.js，可以在如下网站进行下载安装： https://nodejs.org/en/。 创建一个测试工程目录，用于存放Express项目框架，首先在终端，使用如下命令进行Express的全局安装： 1npm install express-generator -g 需要注意，很多时候国内网络使用npm的时候会非常慢，可以通过如下命令来修改仓库源。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 之后使用cnpm来进行包的安装： 1cnpm install express-generator -g 安装好Express后，在新建的文件夹目录下，执行Express的初始化： 1express 如果文件夹不为空，会提示是否继续操作，输入yes后回车即可。 初始化完成后的Express项目结构如下： 其中会默认创建一个package.json文件，其中会添加许多依赖包，在项目目录中执行如下命令来安装这些依赖： 1npm install 依赖安装完成后，工程中会多一个node_modules的文件夹，里面是所有依赖包文件。 再来看Express模板中的文件，其中bin文件夹下面的www.js文件是服务的启动文件，其中启动了HTTP的服务，默认端口为3000。routes文件夹下面的文件用于配置api路由，默认有index.js与users.js两个。app.js文件中对api进行了初始化与配置。可以在users.js中添加一个测试api如下： 123456789101112var express = require('express');var router = express.Router();/* 这个是默认生成的. */router.get('/', function(req, res, next) &#123; res.send('respond with a resource');&#125;);/* 添加一个测试api*/router.get('/testAPi',function(rep,res,next)&#123; res.send('&#123;name:jaki,age:24&#125;');&#125;);module.exports = router; 在项目目录下通过终端执行如下命令来将服务开启： 1node bin/www 如果服务启动成功，在浏览器输入http://127.0.0.1:3000/users/testAPi会返回我们send()方法传递的字符串。 小提示：MacOS系统在服务进行中，可以使用control+c来释放端口的监听，如果不小心使用control+z或者关闭了终端，会导致所监听端口的无法释放，下次如果再次启动node服务，会报Port 3000 is already in use的错误，可以使用如下方法来进行所监听端口的释放： 首先使用如下命令查看所有监听某个端口的服务，例如3000端口： 1sudo lsof -i:3000 之后终端会将服务名与进行id告诉我们，如下： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 829 vip 13u IPv6 0x9c3536500e84e203 0t0 TCP *:hbci (LISTEN) 使用如下命令来杀死对应进程即可： 1sudo kill -9 829","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS开发CoreGraphics核心图形框架之六——梯度渐变","slug":"264iOS开发CoreGraphics核心图形框架之六——梯度渐变","date":"2016-11-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.353Z","comments":true,"path":"2016/11/15/264iOS开发CoreGraphics核心图形框架之六——梯度渐变/","link":"","permalink":"http://huishao.cc/2016/11/15/264iOS开发CoreGraphics核心图形框架之六——梯度渐变/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之六——梯度渐变一、引言 关于颜色梯度渐变视图的创建，CoreGraphics框架中提供了两个类型CGShadingRef与CGGradientRef。CoreGraphics框架在绘制梯度渐变时，有两种绘制方式，分别为轴向绘制与径向绘制。轴向绘制是指确定两个点，起点与终点连接的直线作为梯度渐变的轴，垂直于此轴的线共享相同的颜色，由起点向终点进行颜色渐变。径向渐变是指由两个圆连接成圆台，在同一圆周上的所有点共享相同的颜色，由起始圆向终点圆进行颜色渐变。 轴向渐变： 径向渐变： 前面说到，CGShadingRef与CGGradientRef都可以用于创建梯度渐变视图，这两个类型在使用使又有一些不同，CGShadingRef在使用使需要开发者为其提供一个颜色计算方法，CGGradientRef则不需要，相比之下，CGGradientRef更像是为了方便开发者使用而从CGShadingRef中扩展出的一个类型。 二、使用CGGradientRef创建梯度渐变视图创建一个UIView子类，在其drawRect:方法中编写如下测试代码： 123456789101112131415-(void)drawRect:(CGRect)rect&#123; CGGradientRef gradientRef; CGColorSpaceRef colorSpaceRef; CGFloat locs[2] = &#123;0,1&#125;; CGFloat colors[8] = &#123; 1.0, 0, 0, 1.0, // 前4个为起始颜色的rgba 0, 1, 0, 1.0 &#125;; // 后4个为结束颜色的rgba colorSpaceRef = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB); gradientRef = CGGradientCreateWithColorComponents (colorSpaceRef, colors, locs, 2); CGContextRef contextRef = UIGraphicsGetCurrentContext(); //这个方法用于创建轴向渐变// CGContextDrawLinearGradient(contextRef, gradientRef, rect.origin, CGPointMake(rect.origin.x+rect.size.width, rect.origin.y+rect.size.height), 0); //这个方法用于创建径向渐变 CGContextDrawRadialGradient(contextRef, gradientRef, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2), rect.size.width/2, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2), rect.size.width/4, 0);&#125; CGContextDrawRadiaGradient()方法中的参数解析如下： 1234567891011121314151617/*c:绘图上下文gradieent:渐变对象startCenter:渐变起始圆心startRadius:渐变起始圆半径endCenter:渐变终止圆心endRadius:渐变终止圆半径options:渐变的填充风格 设置为0则不进行填充typedef CF_OPTIONS (uint32_t, CGGradientDrawingOptions) &#123; kCGGradientDrawsBeforeStartLocation = (1 &lt;&lt; 0), //起点以前也进行填充 kCGGradientDrawsAfterEndLocation = (1 &lt;&lt; 1) //终点之后也进行填充&#125;;*/ CG_EXTERN void CGContextDrawRadialGradient(CGContextRef cg_nullable c, CGGradientRef cg_nullable gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options) CG_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0); CGGradient中定义的方法解析如下： 1234567891011121314151617181920212223242526//获取CGGradient类在CoreGraphics框架中的idCFTypeID CGGradientGetTypeID(void);//创建CGGradientRef/*space:色彩空间components:色值数组locations:渐变临界点count:locations数组中元素个数*/CGGradientRef __nullable CGGradientCreateWithColorComponents( CGColorSpaceRef cg_nullable space, const CGFloat * cg_nullable components, const CGFloat * __nullable locations, size_t count);//创建CGGradientRef 这个方法locations中的元素个数需要与colors中的对应/*space:色彩空间colors:颜色数组locations:渐变临界点*/CGGradientRef __nullable CGGradientCreateWithColors( CGColorSpaceRef __nullable space, CFArrayRef cg_nullable colors, const CGFloat * __nullable locations);//进行引用计数+1CGGradientRef cg_nullable CGGradientRetain( CGGradientRef cg_nullable gradient);//进行引用计数-1void CGGradientRelease(CGGradientRef cg_nullable gradient); 三、CGShadingRef的应用CGShadingRef的使用就不像CGGradientRef那么方便，其中方法解析如下： 1234567891011121314151617181920212223//获取CGShadingRef在CoreGraphics框架中的idCFTypeID CGShadingGetTypeID(void);//创建轴向渐变的CGShadingRef对象/*space:色彩空间start:起始点end:结束点function:颜色计算函数extendStart:是否填充起始点以前extendEnd:是否填充结束点之后*/CGShadingRef __nullable CGShadingCreateAxial( CGColorSpaceRef cg_nullable space, CGPoint start, CGPoint end, CGFunctionRef cg_nullable function, bool extendStart, bool extendEnd);//创建径向渐变的CGShadingRef对象 参数同上CGShadingRef __nullable CGShadingCreateRadial( CGColorSpaceRef cg_nullable space, CGPoint start, CGFloat startRadius, CGPoint end, CGFloat endRadius, CGFunctionRef cg_nullable function, bool extendStart, bool extendEnd);//引用计数+1CGShadingRef cg_nullable CGShadingRetain(CGShadingRef cg_nullable shading);//引用计数-1void CGShadingRelease(CGShadingRef cg_nullable shading); 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//颜色计算函数/*info 是开发者后面将传入的色彩空间的参数个数in 为输入参数 对应0-1之间out 为输出参数 为所对应颜色空间的每个色值*/static void myCalculateShadingValues (void *info, const CGFloat *in, CGFloat *out)&#123; size_t k, components; double frequency[4] = &#123; 55, 220, 110, 0 &#125;; //获取色彩空间的色值数 components = (size_t)info; for (k = 0; k &lt; components - 1; k++) //*out++ 的作用是指针右移 out指针可以理解为数组 右移作用和数组赋值一致 *out++ = (1 + sin(*in * frequency[k]))/2; //最后追加上透明度值 *out++ = 1; // alpha&#125;-(void)drawRect:(CGRect)rect&#123; size_t numComponents; //输入参数的范围 其中元素个数是 输入参数个数的两倍 static const CGFloat input_value_range [2] = &#123; 0, 1 &#125;; //输出参数的范围 其中元素个数是 输出参数个数的两倍 static const CGFloat output_value_ranges [8] = &#123; 0, 1, 0, 1, 0, 1, 0, 1 &#125;; //组合回调函数 static const CGFunctionCallbacks callbacks = &#123; 0, &amp;myCalculateShadingValues, NULL &#125;; //获取色彩空间的色值数 numComponents = 1 + CGColorSpaceGetNumberOfComponents (CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB)); //创建CGFunctionRef CGFunctionRef func = CGFunctionCreate ((void *) numComponents, 1, input_value_range, numComponents, output_value_ranges, &amp;callbacks); CGPoint startPoint, endPoint; CGFloat startRadius, endRadius; CGAffineTransform myTransform; //起始圆位置 startPoint = CGPointMake(0.25,0.3); //半径 startRadius = .1; //终止圆位置 endPoint = CGPointMake(.7,0.7); //半径 endRadius = .25; //创建CGShadingRef CGShadingRef myShading = CGShadingCreateRadial (CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB), startPoint, startRadius, endPoint, endRadius, func, false, false); CGContextRef context = UIGraphicsGetCurrentContext(); //进行transform的映射 myTransform = CGAffineTransformMakeScale(320, 568); CGContextConcatCTM(context, myTransform); CGContextSaveGState(context); //进行绘制 CGContextDrawShading(context, myShading); &#125; 上面的示例代码效果如下图： 四、一些小技巧灵活的应用CGContextDrawRadialGradient()方法可以创建出伪立体效果的图形，例如如下代码： 123456789101112-(void)drawRect:(CGRect)rect&#123; CGGradientRef gradientRef; CGColorSpaceRef colorSpaceRef; CGFloat locs[2] = &#123;0,1&#125;; CGFloat colors[8] = &#123; 1.0, 0, 0, 1.0, // 前4个为起始颜色的rgba 1, 1, 1, 1.0 &#125;; // 后4个为结束颜色的rgba colorSpaceRef = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB); gradientRef = CGGradientCreateWithColorComponents (colorSpaceRef, colors, locs, 2); CGContextRef contextRef = UIGraphicsGetCurrentContext(); CGContextDrawRadialGradient(contextRef, gradientRef, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2), rect.size.width/2, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2-100), 0, 0);&#125; 通过调整内圆的位置和半径，可以做到光影的移动，效果如下： 1234567891011121314151617181920//模拟金属原子-(void)drawRect:(CGRect)rect&#123; CGGradientRef gradientRef; CGColorSpaceRef colorSpaceRef; CGFloat locs[8] = &#123;0,0.2,0.4,0.5,0.6,0.8,0.9,1.0&#125;; CGFloat colors[64] = &#123; 1.0, 0, 0, 1.0, // 前4个为起始颜色的rgba 0.0, 1, 0, 1.0, 0.0, 0, 1, 1.0, 1.0, 0, 0, 1.0, 0.0, 1, 0, 1.0, 1.0, 0, 0, 1.0, 1.0, 1, 0, 1.0, 1, 1, 1, 1.0 &#125;; // 后4个为结束颜色的rgba colorSpaceRef = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB); gradientRef = CGGradientCreateWithColorComponents (colorSpaceRef, colors, locs, 8); CGContextRef contextRef = UIGraphicsGetCurrentContext();// CGContextDrawLinearGradient(contextRef, gradientRef, rect.origin, CGPointMake(rect.origin.x+rect.size.width, rect.origin.y+rect.size.height), 0); CGContextDrawRadialGradient(contextRef, gradientRef, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2), rect.size.width/2, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2-100), 0, 0);&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之四——变换函数","slug":"263iOS开发CoreGraphics核心图形框架之五——Patterns模型的应用","date":"2016-11-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.353Z","comments":true,"path":"2016/11/02/263iOS开发CoreGraphics核心图形框架之五——Patterns模型的应用/","link":"","permalink":"http://huishao.cc/2016/11/02/263iOS开发CoreGraphics核心图形框架之五——Patterns模型的应用/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之五——Patterns模型的应用一、引言Patterns称为模型可能并不直观，说一个场景我们或许就可以更加容易的理解Patterns。在开发中，开发者经常会遇到这样的需求，将某个图片或者某个图形进行平铺作为界面的背景，当然iOS中有现成的方法来将图片转换为背景色进行背景的渲染，但是这种方式并不太灵活，例如背景花纹的着色，背景图片的平铺间距设置等需求都无法满足。Patterns就是用来处理这样的需求。 Patterns可以理解为一个模型单元，即花纹背景中的一个花纹单元，开发者可以自定义这个单元的绘制内容，一旦创建了CGPatternRef引用，开发者就可以将它向普通颜色一样进行使用，可以进行填充，可以进行路径绘制等。 二、创建CGPatternRef模型引用在UIView子类的drawRect:方法中来做如下的测试： 12345678910111213141516171819- (void)drawRect:(CGRect)rect &#123; // Drawing code //创建回调结构体 后面会介绍 CGPatternCallbacks callback = &#123;0,&amp;drawPatternCallback,&amp;releaseInfoCallback&#125;; //创建模型引用 CGPatternRef pattren = CGPatternCreate(NULL, CGRectMake(0, 0, 30,30), CGAffineTransformIdentity, 35, 35, kCGPatternTilingConstantSpacing, false, &amp;callback); //创建颜色数组 代表RGBA的值 static const CGFloat color[4] = &#123; 0, 1, 0, 1 &#125;; //创建颜色空间 CGColorSpaceRef baseSpace = CGColorSpaceCreateWithName (kCGColorSpaceGenericRGB); CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern (baseSpace); //设置填充颜色空间 CGContextSetFillColorSpace (UIGraphicsGetCurrentContext(), patternSpace); //设置填充模型 CGContextSetFillPattern(UIGraphicsGetCurrentContext(), pattren, color); //进行填充 CGContextFillRect(UIGraphicsGetCurrentContext(), CGRectMake(0, 0, 200, 200)); &#125; 上面的示例代码中，有几个地方需要进行介绍： CGPatternCallBacks是CoreGraphics框架的CGPattern.h文件中定义的一个结构体，这个结构体组合了模型Pattern的版本，创建回调和释放回调。创建回调和释放回调需要传入两个方法块的地址，即block。这两个block的格式定义如下： 1234567//创建模型回调的格式定义//info参数为需要传递给回调函数的数据//content参数为所绘制的图形上下文typedef void (*CGPatternDrawPatternCallback)(void * __nullable info, CGContextRef cg_nullable context);//释放回调 开发者可以在其中进行内存的释放typedef void (*CGPatternReleaseInfoCallback)(void * __nullable info); 我们所实现的drawPatternCallback(),releaseInfoCallback()方法示例如下： 123456789101112131415161718192021222324252627// 绘制 回调#define PSIZE 16void drawPatternCallback(void *info,CGContextRef myContext)&#123;//这里我借用了官方文档中的代码 如下的代码将绘制出五角星 int k; double r, theta; r = 0.8 * PSIZE / 2; theta = 2 * M_PI * (2.0 / 5.0); // 144 degrees CGContextTranslateCTM (myContext, PSIZE/2, PSIZE/2); CGContextMoveToPoint(myContext, 0, r); for (k = 1; k &lt; 5; k++) &#123; CGContextAddLineToPoint (myContext, r * sin(k * theta), r * cos(k * theta)); &#125; CGContextClosePath(myContext); CGContextFillPath(myContext);&#125;// 移除 回调void releaseInfoCallback(void *info) &#123; &#125; 在回过来看创建CGPatternRef的方法： 123456789101112/*这个方法第1个参数为要传递进创建模型方法的信息第2个参数为设置每个模型单元的尺寸第3个参数设置模型的几何变换第4个参数设置模型的整体宽度 通过这个参数可以设置边距第5个参数设置模型的整体高度 通过这个参数可以设置边距第6个参数设置模型的渲染方式第7个参数设置为有色渲染还是无色渲染 第8个参数设置相关回调结构体*/CGPatternRef pattren = CGPatternCreate(NULL, CGRectMake(0, 0, 30,30), CGAffineTransformIdentity, 35, 35, kCGPatternTilingConstantSpacing, false, &amp;callback); 关于模型的渲染方式，需要设置为CGPatternTiling类型的枚举，如下： 12345678typedef CF_ENUM (int32_t, CGPatternTiling) &#123; //无失真的平铺 将调整单元之间的间距 kCGPatternTilingNoDistortion, //细微调整单元大小 kCGPatternTilingConstantSpacingMinimalDistortion, //恒定间距，通过调整单元大小实现 会失真 kCGPatternTilingConstantSpacing&#125;; CGContextSetFillPattern()方法用于将模型设置为要渲染界面的颜料，之后调用CGContextStrokePath(), CGContextFillPath(), CGContextFillRect()等相关方法都可以实现将模型铺平渲染到指定容器。需要注意，CGContextSetFillPattern()方法中第1个参数为绘图上下文，第2个参数为模型CGPatternRef引用，第3个参数为一个色值数组，这里如果模式是无色渲染方式创建的，需要传入4个元素的RGBA数组，如果是有色模式创建的，需要传入一个透明度值，可以是float类型的指针。 运行工程，效果如下图所示: 将代码简单修改如下，就可以实现以五角星围成的矩形： 1234567891011121314- (void)drawRect:(CGRect)rect &#123; // Drawing code CGPatternCallbacks callback = &#123;0,&amp;drawPatternCallback,&amp;releaseInfoCallback&#125;; CGPatternRef pattren = CGPatternCreate(NULL, CGRectMake(0, 0, 30,30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, false, &amp;callback); static const CGFloat color[4] = &#123; 1, 0, 0, 1 &#125;; CGColorSpaceRef baseSpace; CGColorSpaceRef patternSpace; baseSpace = CGColorSpaceCreateWithName (kCGColorSpaceGenericRGB); patternSpace = CGColorSpaceCreatePattern (baseSpace); CGContextSetStrokeColorSpace (UIGraphicsGetCurrentContext(), patternSpace); CGContextSetStrokePattern(UIGraphicsGetCurrentContext(), pattren, color); CGContextSetLineWidth(UIGraphicsGetCurrentContext(), 40); CGContextStrokeRect(UIGraphicsGetCurrentContext(), CGRectMake(0, 0, 200, 200));&#125; 效果如下: 三、CGPattern中其他方法123456//获取CGPattern在CoreGraphics框架中的idCFTypeID CGPatternGetTypeID(void);//进行引用计数加1CGPatternRef cg_nullable CGPatternRetain(CGPatternRef cg_nullable pattern);//进行引用计数减1void CGPatternRelease(CGPatternRef cg_nullable pattern); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之四——变换函数","slug":"262iOS开发CoreGraphics核心图形框架之四——变换函数","date":"2016-10-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.353Z","comments":true,"path":"2016/10/30/262iOS开发CoreGraphics核心图形框架之四——变换函数/","link":"","permalink":"http://huishao.cc/2016/10/30/262iOS开发CoreGraphics核心图形框架之四——变换函数/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之四——变换函数一、引言在上一篇博客中，介绍了有关CGContext相关操作方法，其中可以直接调用一些方法来进行所绘制图形的平移，缩放，翻转等变换。对于图形了几何变换，开发者也可以采用另一种方式实现，CoreGraphics框架中提供了CGAffineTransform结构体，这个结构体中定义了图形变换的相关信息。 关于CGContext的相关内如博地址客如下：https://my.oschina.net/u/2340880/blog/759070。 二、使用CGAffineTransform相关函数进行绘制图形的几何变换CGAffineTransform中定义的方法即意义列举如下： 123456789101112131415161718192021222324252627282930//创建标准的变换矩阵CGAffineTransform CGAffineTransformIdentity;//手动创建变换矩阵CGAffineTransform CGAffineTransformMake(CGFloat a, CGFloat b, CGFloat c, CGFloat d, CGFloat tx, CGFloat ty);//创建平移变换CGAffineTransform CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);//创建缩放变换CGAffineTransform CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);//创建旋转变换CGAffineTransform CGAffineTransformMakeRotation(CGFloat angle);//判断某个变化是否是来自标准矩阵的变换bool CGAffineTransformIsIdentity(CGAffineTransform t);//对某个变换矩阵进行平移变换CGAffineTransform CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty);//对某个变换矩阵进行缩放变换CGAffineTransform CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy);//对某个变换矩阵进行旋转变换CGAffineTransform CGAffineTransformRotate(CGAffineTransform t, CGFloat angle);//对某个变换矩阵进行翻转变换CGAffineTransform CGAffineTransformInvert(CGAffineTransform t);//对两个变换矩阵进行计算CGAffineTransform CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);//比较两个变换矩阵是否相同bool CGAffineTransformEqualToTransform(CGAffineTransform t1, CGAffineTransform t2);//获取应用变换后某点的坐标CGPoint CGPointApplyAffineTransform(CGPoint point, CGAffineTransform t);//获取应用变换后某个区域的尺寸CGSize CGSizeApplyAffineTransform(CGSize size, CGAffineTransform t);//获取应用变换后某个区域的位置和尺寸CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform t); 上述变换方法可以直接作用于View，示例如下： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 200, 200)]; view.backgroundColor =[UIColor whiteColor]; view.image = [UIImage imageNamed:@\"image\"]; view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, M_PI_4); [self.view addSubview:view];&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间","slug":"261 iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间","date":"2016-10-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.353Z","comments":true,"path":"2016/10/20/261 iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间/","link":"","permalink":"http://huishao.cc/2016/10/20/261 iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间一、引言颜色的实质是表示颜色的二进制数据，如果没有确定的规则，则这些二进制数据完全没有意义。所谓色彩空间，即是表示这些颜色数据信息是如何解释的。同样的一张图片，在不同的色彩空间下，其渲染的模样将有很大的不同。在CoreGraphics框架中，与色彩相关的功能主要有CGColor与CGColorSpace构成。 二、关于CGColor相关方法的解析CGColorRef是CoreGraphics框架中用于描述颜色的引用类型，其中常用方法解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//根据色彩空间创建一个CGColorRef实例/*需要注意，这个方法中的第2个参数需要传递一个float数据，其需要和第1个参数的色彩空间意义对应例如在RGBA色彩空间中，float数组中需要传递4个值，分别表示红绿蓝和透明度*/CGColorRef __nullable CGColorCreate(CGColorSpaceRef cg_nullable space, const CGFloat * cg_nullable components);//创建黑白色彩空间下的颜色/*参数 gray为灰度alpha 为透明度*/CGColorRef CGColorCreateGenericGray(CGFloat gray, CGFloat alpha);//创建RGB色彩空间下的颜色CGColorRef CGColorCreateGenericRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha);//创建CMYB印刷模式色彩空间下的颜色CGColorCreateGenericCMYK(CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha);//获取颜色常量/*colorName定义如下： //标准白色 CFStringRef kCGColorWhite; //标准黑色 CFStringRef kCGColorBlack; //标准透明色 CFStringRef kCGColorClear;*/CGColorRef __nullable CGColorGetConstantColor(CFStringRef cg_nullable colorName);//通过模式与色彩空间创建颜色CGColorRef __nullable CGColorCreateWithPattern(CGColorSpaceRef cg_nullable space, CGPatternRef cg_nullable pattern, const CGFloat * cg_nullable components);//复制一个CGColorRefCGColorRef __nullable CGColorCreateCopy(CGColorRef cg_nullable color);//复制颜色 并追加透明度CGColorRef __nullable CGColorCreateCopyWithAlpha(CGColorRef cg_nullable color, CGFloat alpha);//将原色彩空间与目标色彩空间相匹配 创建颜色实例/*CGColorRenderingInter设置颜色渲染模式typedef CF_ENUM (int32_t, CGColorRenderingIntent) &#123; kCGRenderingIntentDefault, //默认的渲染模式 kCGRenderingIntentAbsoluteColorimetric, //绝对比色模式 kCGRenderingIntentRelativeColorimetric, //相对比色模式 kCGRenderingIntentPerceptual, //压缩色域模式 kCGRenderingIntentSaturation //转换色域模式&#125;;*/CGColorRef __nullable CGColorCreateCopyByMatchingToColorSpace(cg_nullable CGColorSpaceRef, CGColorRenderingIntent intent, CGColorRef cg_nullable color, __nullable CFDictionaryRef options);//内存引用+1CGColorRef cg_nullable CGColorRetain(CGColorRef cg_nullable color);//内存引用-1void CGColorRelease(CGColorRef cg_nullable color);//比较两个颜色引用是否相同bool CGColorEqualToColor(CGColorRef cg_nullable color1, CGColorRef cg_nullable color2);//获取颜色内容的色彩描述值个数 包括alpha通道size_t CGColorGetNumberOfComponents(CGColorRef cg_nullable color);//获取颜色色彩描述值数组CGFloat * __nullable CGColorGetComponents(CGColorRef cg_nullable color);//获取颜色的透明度CGFloat CGColorGetAlpha(CGColorRef cg_nullable color);//获取颜色的色彩空间CGColorSpaceRef __nullable CGColorGetColorSpace(CGColorRef cg_nullable color);//获取与此颜色相关的模型CGPatternRef __nullable CGColorGetPattern(CGColorRef cg_nullable color);//获取CGColorRef类在CoreGraphics框架中的idCFTypeID CGColorGetTypeID(void); 三、关于CGColorSpace相关方法解析CGColorSpace用来描述色彩空间，其中方法解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//创建一个基于设备的黑白色彩空间CGColorSpaceRef cg_nullable CGColorSpaceCreateDeviceGray(void);//创建一个基于设备的RGB色彩空间CGColorSpaceRef cg_nullable CGColorSpaceCreateDeviceRGB(void);//创建一个基于设备的CMYK色彩空间CGColorSpaceRef cg_nullable CGColorSpaceCreateDeviceCMYK(void);//创建一个经过校准的黑白色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateCalibratedGray(const CGFloat whitePoint[3], const CGFloat blackPoint[3], CGFloat gamma);//创建一个经过校准的RGB色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateCalibratedRGB(const CGFloat whitePoint[3], const CGFloat blackPoint[3], const CGFloat gamma[3], const CGFloat matrix[9]);//创建一个经过校准的LAB色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateLab(const CGFloat whitePoint[3], const CGFloat blackPoint[3], const CGFloat range[4]);//使用ICC文件创建ICC-based色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateWithICCProfile(CFDataRef cg_nullable data);CGColorSpaceRef __nullable CGColorSpaceCreateICCBased(size_t nComponents, const CGFloat * __nullable range, CGDataProviderRef cg_nullable profile, CGColorSpaceRef __nullable alternate);//使用索引创建色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateIndexed(CGColorSpaceRef cg_nullable baseSpace, size_t lastIndex, const unsigned char * cg_nullable colorTable);//通过名称创建色彩空间/*标准的黑白色彩空间CFStringRef kCGColorSpaceGenericGray;标准的RGB色彩空间const CFStringRef kCGColorSpaceGenericRGB;标准的CMYK色彩空间CFStringRef kCGColorSpaceGenericCMYK;displatP3色彩空间CFStringRef kCGColorSpaceDisplayP3;LinearRGB色彩空间CFStringRef kCGColorSpaceGenericRGBLinear;Adobe RGB 1998 版本的色彩空间CFStringRef kCGColorSpaceAdobeRGB1998;黑白色彩空间 设置伽马值为2.2CFStringRef kCGColorSpaceGenericGrayGamma2_2;XYZ色彩空间CFStringRef kCGColorSpaceGenericXYZ;ACEScg色彩空间kCGColorSpaceACESCGLinear;ITU-R Recommendation BT.709 色彩空间kCGColorSpaceITUR_709;ITU-R Recommendation BT.2020色彩空间kCGColorSpaceITUR_2020;RGB色彩空间kCGColorSpaceROMMRGB;DCI P3 色彩空间kCGColorSpaceDCIP3;扩展的sRGB色彩空间kCGColorSpaceExtendedSRGB;线性sRGB色彩空间kCGColorSpaceLinearSRGB;扩展的线性sRGB扩展空间CFStringRef kCGColorSpaceExtendedLinearSRGB;扩展的黑白色彩空间CFStringRef kCGColorSpaceExtendedGray;扩展的线性黑白色彩空间CFStringRef kCGColorSpaceLinearGray;扩展的Generic Gray 2.2色彩空间CFStringRef kCGColorSpaceExtendedLinearGray;*/CGColorSpaceRef __nullable CGColorSpaceCreateWithName(CFStringRef cg_nullable name);//内存引用计数+1CGColorSpaceRef cg_nullable CGColorSpaceRetain(CGColorSpaceRef cg_nullable space);//内存引用计数-1void CGColorSpaceRelease(CGColorSpaceRef cg_nullable space);//进行色彩空间的复制CFStringRef __nullable CGColorSpaceCopyName(CGColorSpaceRef cg_nullable space);//获取CGColorRef类在CoreGraphics框架中的idCFTypeID CGColorSpaceGetTypeID(void);//获取色彩空间颜色值参数个数CGColorSpaceGetNumberOfComponents(CGColorSpaceRef cg_nullable space);//获取色彩空间模式/*typedef CF_ENUM (int32_t, CGColorSpaceModel) &#123; kCGColorSpaceModelUnknown = -1, 未知模式 kCGColorSpaceModelMonochrome, 单色色彩空间模式 kCGColorSpaceModelRGB, RGB色彩空间模式 kCGColorSpaceModelCMYK, CMYK色彩空间模式 kCGColorSpaceModelLab, LAB色彩空间模式 kCGColorSpaceModelDeviceN, 设备色彩空间模式 kCGColorSpaceModelIndexed, 引用色彩空间模式 kCGColorSpaceModelPattern 模型色彩空间模式&#125;;*/CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef cg_nullable space); 相同的图像，使用不同的色彩空间进行渲染，得到的结果可能大不一样，例如如下代码修改图片的色彩空间： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; CGImageRef image = CGImageCreateCopyWithColorSpace([UIImage imageNamed:@\"image\"].CGImage, CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB)); CGImageRef image2 = CGImageCreateCopyWithColorSpace([UIImage imageNamed:@\"image\"].CGImage, CGColorSpaceCreateWithName(kCGColorSpaceROMMRGB)); UIImageView * imageView = [[UIImageView alloc]initWithImage:[UIImage imageWithCGImage:image]]; UIImageView * imageView2 = [[UIImageView alloc]initWithImage:[UIImage imageWithCGImage:image2]]; imageView.frame = CGRectMake(100, 100, 200, 200); imageView2.frame = CGRectMake(100, 300, 200, 200); [self.view addSubview:imageView]; [self.view addSubview:imageView2];&#125; 效果如下： 原图如下： 模拟器运行如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文","slug":"260iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文","date":"2016-10-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.352Z","comments":true,"path":"2016/10/16/260iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文/","link":"","permalink":"http://huishao.cc/2016/10/16/260iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文一、引言在上一篇博客中，介绍了有关CGPath绘制路径的相关方法，其中在View视图的drawRect方法中，已经使用过上下文将Path路径绘制到当前视图上，上一篇博客只是抛砖引玉，本片博客将更深入的介绍下有关上下文的更多内容。关于接胡搜啊CGPath应用的博客地址如下： iOS开发CoreGraphics核心图形框架之一——CGPath的应用：https://my.oschina.net/u/2340880/blog/757072。 二、关于图形上下文Graphics Context GraphicsContext对于开发者来说是完全透明的，开发者不需要关心其实现，也不需要关心其绘制方式，开发者只需要将要绘制的内容传递给图形上下文，由图形上下文来将内容绘制到对应的目标上。这个目标可以是视图，窗口，打印机，PDF文档或者位图对象。需要注意，绘制的顺序在CoreGraphics框架中十分重要，如果后绘制的内容和先绘制的内容有位置冲突，后绘制的内容将覆盖先绘制的内容。 特定的上下文用于将内容绘制到特定的输出源上，CoreGraphics中提供如下几种图形上下文： 1.位图图形上下文：位图图形上下文用于将RGB图像，GMYK图像或者黑白图像绘制到一个位图(bitmap)对象中。 2.PDF图形上下文：PDF图形上下文可以帮助开发者创建PDF文件，将内容绘制进PDF文件中，其与位图上下文最大的区别在于PDF数据可以保存多页图像。 3.窗口上下文：用于OS系统中的窗口绘制。 4.图层上下文：用于将内容绘制在Layer图层上。 5.打印上下文：使用Mac打印功能时，此上下文用于将内容绘制在打印输出源上。 三、在UIKit框架中操作图形上下文在UIKit框架中有一个UIGraphics头文件，其中封装了许多对当前图形上下文进行操作的方法。首先任何UIView和其子类的视图控件都有一个drawRect方法，当视图将要被绘制时会调用这个方法，在drawRect方法中开发者可以获取到当前视图的图形上下文，通过这个图形上下文可以对视图进行自定义的绘制。UIGraphics头文件中定义的如下方法可以对当前的图形上下文进行操作： 123456//这个方法用于获取当前的图形上下文UIKIT_EXTERN CGContextRef __nullable UIGraphicsGetCurrentContext(void) CF_RETURNS_NOT_RETAINED;//这个方法用于将某个图形上下文对象压入栈中 使其变为当前的图形上下文UIKIT_EXTERN void UIGraphicsPushContext(CGContextRef context);//这个方法用于将当前的图形上下文出栈 当前的图形上下文始终是栈顶的图形上下文UIKIT_EXTERN void UIGraphicsPopContext(void); 需要注意，上面的UIGraphicsPushContext()与UIGraphicsPopContext()方法常用于切换当前的图形上下文。 12345678//下面这两个方法用于向当前的图形上下文中填充矩形 UIKIT_EXTERN void UIRectFillUsingBlendMode(CGRect rect, CGBlendMode blendMode);UIKIT_EXTERN void UIRectFill(CGRect rect);//下面这两个方法用于向当前的图形上下文中绘制矩形边框UIKIT_EXTERN void UIRectFrameUsingBlendMode(CGRect rect, CGBlendMode blendMode);UIKIT_EXTERN void UIRectFrame(CGRect rect);//这个方法用于裁剪当前的图形上下文的绘制区域UIKIT_EXTERN void UIRectClip(CGRect rect); 上面方法中的CGBlendMode参数用于设置图像的混合模式，意义列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152typedef CF_ENUM (int32_t, CGBlendMode) &#123; //在背景图像之上绘制原图像 kCGBlendModeNormal, //将背景与原图像进行混合 kCGBlendModeMultiply, //将背景与原图像进行逆向混合 kCGBlendModeScreen, //覆盖原图像 同时保持背景阴影 kCGBlendModeOverlay, //进行灰度复合 kCGBlendModeDarken, //进行亮度复合 kCGBlendModeLighten, //复合时 黑色不进行复合 kCGBlendModeColorDodge, //复合时 白色不进行复合 kCGBlendModeColorBurn, //复合时 根据黑白色值比例进行复合 kCGBlendModeSoftLight, kCGBlendModeHardLight, //复合时 将原图像中有关背景图像的色值去除 kCGBlendModeDifference, //与kCGBlendModeDifference类似 对比度更低 kCGBlendModeExclusion, //使用原图像的色调与饱和度 kCGBlendModeHue, //同kCGBlendModeHue 纯灰度的区域不产生变化 kCGBlendModeSaturation, //同kCGBlendModeHue 保留灰度等级 kCGBlendModeColor, //与kCGBlendModeHue效果相反 kCGBlendModeLuminosity, //下面这些枚举定义了MacOS中图像复合的计算方式 //R 结果 //S 原图像 //D 背景图像 //Ra Sa Da为带透明alpha通道 kCGBlendModeClear, /* R = 0 */ kCGBlendModeCopy, /* R = S */ kCGBlendModeSourceIn, /* R = S*Da */ kCGBlendModeSourceOut, /* R = S*(1 - Da) */ kCGBlendModeSourceAtop, /* R = S*Da + D*(1 - Sa) */ kCGBlendModeDestinationOver, /* R = S*(1 - Da) + D */ kCGBlendModeDestinationIn, /* R = D*Sa */ kCGBlendModeDestinationOut, /* R = D*(1 - Sa) */ kCGBlendModeDestinationAtop, /* R = S*(1 - Da) + D*Sa */ kCGBlendModeXOR, /* R = S*(1 - Da) + D*(1 - Sa) */ kCGBlendModePlusDarker, /* R = MAX(0, (1 - D) + (1 - S)) */ kCGBlendModePlusLighter /* R = MIN(1, S + D) */&#125;; 下面这些方法用于操作位图图形上下文： 12345678//这个方法会创建一个位图图形上下文 并将其push进图形上下文栈中 size参数设置图像的大小UIKIT_EXTERN void UIGraphicsBeginImageContext(CGSize size);//方法同上，其中opaque参数设置是否为不透明的 scale设置缩放因子UIKIT_EXTERN void UIGraphicsBeginImageContextWithOptions(CGSize size, BOOL opaque, CGFloat scale) NS_AVAILABLE_IOS(4_0);//这个方法用于将当前的位图图形上下文内容画成UIImage对象UIKIT_EXTERN UIImage* __nullable UIGraphicsGetImageFromCurrentImageContext(void);//结束位图图形上下文的编辑 会POP出栈UIKIT_EXTERN void UIGraphicsEndImageContext(void); 我们可以通过代码来画一个简单的UIImage图像，示例如下： 12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123; [super viewDidLoad]; //创建位图图形上下文 设置大小为200*200 UIGraphicsBeginImageContext(CGSizeMake(200, 200)); //获取到当前图形上下文 CGContextRef ref = UIGraphicsGetCurrentContext(); //裁剪其进行绘制的尺寸为100*100 UIRectClip(CGRectMake(0, 0, 100, 100)); //设置线条颜色 [[UIColor redColor] setStroke]; //设置填充颜色 [[UIColor grayColor] setFill]; //设置边框宽度 CGContextSetLineWidth(ref, 10); //进行填充 UIRectFill(CGRectMake(0, 0, 100, 100)); //进行边框绘制 UIRectFrame(CGRectMake(0, 0, 200, 200)); //拿到UIImage实例 UIImage * image = UIGraphicsGetImageFromCurrentImageContext(); //结束位图上下文编辑 UIGraphicsEndImageContext(); //将UIImage展示到界面上 UIImageView * imageView = [[UIImageView alloc]initWithImage:image]; imageView.contentMode = UIViewContentModeCenter; imageView.frame = CGRectMake(100, 100, 200, 200); [self.view addSubview:imageView];&#125; 效果如下图所示： 与操作PDF图形上下文的相关方法如下： 1234567891011121314151617181920212223//这个方法用于创建一个PDF图形上下文 将其入栈 作为当前的图形上下文 /*其中path为PDF文件写入的路径bounds为PDF文档的尺寸decumentInfo地点为设置PDF文档信息 后面会介绍*/UIKIT_EXTERN BOOL UIGraphicsBeginPDFContextToFile(NSString *path, CGRect bounds, NSDictionary * __nullable documentInfo) NS_AVAILABLE_IOS(3_2);//这个方法用于穿件一个PDF图形上下文 但是将PDF内容写成Data数据 参数意义同上UIKIT_EXTERN void UIGraphicsBeginPDFContextToData(NSMutableData *data, CGRect bounds, NSDictionary * __nullable documentInfo) NS_AVAILABLE_IOS(3_2);//结束PDF图形上下文的编辑 将其出栈UIKIT_EXTERN void UIGraphicsEndPDFContext(void) NS_AVAILABLE_IOS(3_2);//这个方法用于将当前的PDF图形上下文新开一页内容UIKIT_EXTERN void UIGraphicsBeginPDFPage(void) NS_AVAILABLE_IOS(3_2);//同上UIKIT_EXTERN void UIGraphicsBeginPDFPageWithInfo(CGRect bounds, NSDictionary * __nullable pageInfo) NS_AVAILABLE_IOS(3_2);//返回当前PDF图形上下文所在页的尺寸UIKIT_EXTERN CGRect UIGraphicsGetPDFContextBounds(void) NS_AVAILABLE_IOS(3_2);//向PDF文档中的某个区域添加链接UIKIT_EXTERN void UIGraphicsSetPDFContextURLForRect(NSURL *url, CGRect rect) NS_AVAILABLE_IOS(3_2);//向PDF文档中的某个区域添加一个跳转目标 使其滚动到某点UIKIT_EXTERN void UIGraphicsAddPDFContextDestinationAtPoint(NSString *name, CGPoint point) NS_AVAILABLE_IOS(3_2);//向PDF文档中的某个区域添加一个跳转目标 使其滚动到某个区域UIKIT_EXTERN void UIGraphicsSetPDFContextDestinationForRect(NSString *name, CGRect rect) NS_AVAILABLE_IOS(3_2); 上面有提到，在创建PDF图形上下文时，可以设置一个信息字典，这个字典中常用的可以进行配置的键值如下： 1234567891011121314151617181920212223//这个键是可选的 对应需要设置为字符串类型的值 表明文档作者kCGPDFContextAuthor//这个键是可选的 对应需要设置为字符串类型的值 表示生成文档的命名名称kCGPDFContextCreator//这个键是可选的 对应需要设置为字符串类型的值 表示文档名称kCGPDFContextTitle//这个键设置所有者密码 需要设置为CFString的值kCGPDFContextOwnerPassword//这个键设置用户密码 需要设置为CFString的值kCGPDFContextUserPassword//这个键设置是否允许在未解锁状态下进行打印 需要设置为CFBollean的值 默认为允许kCGPDFContextAllowsPrinting//这个键设置是否允许在未解锁状态下进行复制 需要设置为CFBollean的值 默认为允许kCGPDFContextAllowsCopying//设置输出规范kCGPDFContextOutputIntentkCGPDFContextOutputIntents//设置文档的主题 需要设置为CFString的值kCGPDFContextSubject//设置文档的关键字kCGPDFContextKeywords//设置密钥长度kCGPDFContextEncryptionKeyLength 四、CGContext功能解析前边介绍了如何拿到对应的图形上下文，拿到图形上下文后，开发者便可以随心所欲的通过图形上下文向目标上绘制内容。CoreGraphics框架中提供的CGContext绘制相关方法解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243//获取CGContext类在CoreGraphics框架中的id值CFTypeID CGContextGetTypeID(void);//将当前图形上下文进行保存 会执行push入栈void CGContextSaveGState(CGContextRef cg_nullable c);//将图形上下文恢复到保存时的状态 void CGContextRestoreGState(CGContextRef cg_nullable c);//对context内容进行缩放操作void CGContextScaleCTM(CGContextRef cg_nullable c, CGFloat sx, CGFloat sy);//对context内容进行平移操作void CGContextTranslateCTM(CGContextRef cg_nullable c, CGFloat tx, CGFloat ty);//对context内容进行旋转操作void CGContextRotateCTM(CGContextRef cg_nullable c, CGFloat angle);//对context内容进行transform变换操作void CGContextConcatCTM(CGContextRef cg_nullable c,CGAffineTransform transform);//获取某个context的transform变换对象CGAffineTransform CGContextGetCTM(CGContextRef cg_nullable c);//设置绘制的线宽void CGContextSetLineWidth(CGContextRef cg_nullable c, CGFloat width);//设置绘制的线帽风格void CGContextSetLineCap(CGContextRef cg_nullable c, CGLineCap cap);//设置绘制的线连接处风格void CGContextSetLineJoin(CGContextRef cg_nullable c, CGLineJoin join);//设置绘制的先转折处风格void CGContextSetMiterLimit(CGContextRef cg_nullable c, CGFloat limit);//设置虚线配置参数void CGContextSetLineDash(CGContextRef cg_nullable c, CGFloat phase, const CGFloat * __nullable lengths, size_t count);//设置平滑度void CGContextSetFlatness(CGContextRef cg_nullable c, CGFloat flatness);//设置透明度void CGContextSetAlpha(CGContextRef cg_nullable c, CGFloat alpha);//设置图像复合模式void CGContextSetBlendMode(CGContextRef cg_nullable c, CGBlendMode mode);//开始新的路径 旧的路径将被抛弃void CGContextBeginPath(CGContextRef cg_nullable c);//将路径起点移动到某个点void CGContextMoveToPoint(CGContextRef cg_nullable c, CGFloat x, CGFloat y);//向路径中添加一条线void CGContextAddLineToPoint(CGContextRef cg_nullable c,CGFloat x, CGFloat y);//向路径中添加三次贝塞尔曲线void CGContextAddCurveToPoint(CGContextRef cg_nullable c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y);//向路径中添加二次贝塞尔曲线void CGContextAddQuadCurveToPoint(CGContextRef cg_nullable c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y);//闭合路径void CGContextClosePath(CGContextRef cg_nullable c);//向路径中添加一个矩形void CGContextAddRect(CGContextRef cg_nullable c, CGRect rect);//向路径中添加一组矩形void CGContextAddRects(CGContextRef cg_nullable c, const CGRect * __nullable rects, size_t count);//向路径中添加一组线条void CGContextAddLines(CGContextRef cg_nullable c, const CGPoint * __nullable points, size_t count);//向路径中添加椭圆CGContextAddEllipseInRect(CGContextRef cg_nullable c, CGRect rect);//向路径中添加圆弧void CGContextAddArc(CGContextRef cg_nullable c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise);void CGContextAddArcToPoint(CGContextRef cg_nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius);//直接向上下文中添加一个路径对象void CGContextAddPath(CGContextRef cg_nullable c, CGPathRef cg_nullable path);//将上下文中的路径内容替换掉 只留下边框void CGContextReplacePathWithStrokedPath(CGContextRef cg_nullable c);//判断某个Context的路径是否为空bool CGContextIsPathEmpty(CGContextRef cg_nullable c);//获取一个Context路径当前端点的位置CGPoint CGContextGetPathCurrentPoint(CGContextRef cg_nullable c);//获取路径的尺寸CGRect CGContextGetPathBoundingBox(CGContextRef cg_nullable c);//进行图形上下文的拷贝CGPathRef __nullable CGContextCopyPath(CGContextRef cg_nullable c);//获取context的路径中是否包含某个点bool CGContextPathContainsPoint(CGContextRef cg_nullable c, CGPoint point, CGPathDrawingMode mode);//进行路径的绘制/*mode枚举意义如下： kCGPathFill, //进行填充 kCGPathEOFill, //补集进行填充绘制 kCGPathStroke, //边框绘制 kCGPathFillStroke, //边框绘制并填充 kCGPathEOFillStroke //补集进行边框和填充绘制*/void CGContextDrawPath(CGContextRef cg_nullable c, CGPathDrawingMode mode)；//进行路径的填充void CGContextFillPath(CGContextRef cg_nullable c);//进行路径所围成区域的补集区域填充void CGContextEOFillPath(CGContextRef cg_nullable c);//进行边框绘制void CGContextStrokePath(CGContextRef cg_nullable c);//填充某个矩形区域void CGContextFillRect(CGContextRef cg_nullable c, CGRect rect);//填充一组矩形区域void CGContextFillRects(CGContextRef cg_nullable c, const CGRect * __nullable rects, size_t count);//进行矩形区域的边框绘制void CGContextStrokeRect(CGContextRef cg_nullable c, CGRect rect);//进行矩形区域的边框绘制 可以设置边框宽度void CGContextStrokeRectWithWidth(CGContextRef cg_nullable c, CGRect rect, CGFloat width);//清除某个矩形区域void CGContextClearRect(CGContextRef cg_nullable c, CGRect rect);//进行虚线区域的填充void CGContextFillEllipseInRect(CGContextRef cg_nullable c, CGRect rect);//进行虚线区域边框的绘制void CGContextStrokeEllipseInRect(CGContextRef cg_nullable c,CGRect rect);//绘制一组线void CGContextStrokeLineSegments(CGContextRef cg_nullable c, const CGPoint * __nullable points, size_t count);//依据Context当前路径进行裁剪void CGContextClip(CGContextRef cg_nullable c);//进行路径区域的补集区域裁剪void CGContextEOClip(CGContextRef cg_nullable c);//这个方法十分重要 其可以将图片裁剪成图形上下文定义的形状void CGContextClipToMask(CGContextRef cg_nullable c, CGRect rect, CGImageRef cg_nullable mask);//获取裁剪的区域尺寸CGRect CGContextGetClipBoundingBox(CGContextRef cg_nullable c);//进行区域裁剪void CGContextClipToRect(CGContextRef cg_nullable c, CGRect rect);//进行一组区域的裁剪void CGContextClipToRects(CGContextRef cg_nullable c, const CGRect * rects, size_t count);//设置图形上下文的填充颜色void CGContextSetFillColorWithColor(CGContextRef cg_nullable c, CGColorRef cg_nullable color);//设置图形上下文的边框颜色void CGContextSetStrokeColorWithColor(CGContextRef cg_nullable c, CGColorRef cg_nullable color);//设置图形上下文填充颜色的色彩空间void CGContextSetFillColorSpace(CGContextRef cg_nullable c,CGColorSpaceRef cg_nullable space);//设置图形上下文边框颜色的色彩空间void CGContextSetStrokeColorSpace(CGContextRef cg_nullable c, CGColorSpaceRef cg_nullable space);//下面这些函数与设置颜色和组件模块属性相关void CGContextSetFillColor(CGContextRef cg_nullable c, const CGFloat * cg_nullable components);void CGContextSetStrokeColor(CGContextRef cg_nullable c, const CGFloat * cg_nullable components);void CGContextSetFillPattern(CGContextRef cg_nullable c, CGPatternRef cg_nullable pattern, const CGFloat * cg_nullable components);void CGContextSetStrokePattern(CGContextRef cg_nullable c, CGPatternRef cg_nullable pattern, const CGFloat * cg_nullable components);void CGContextSetPatternPhase(CGContextRef cg_nullable c, CGSize phase);void CGContextSetGrayFillColor(CGContextRef cg_nullable c, CGFloat gray, CGFloat alpha);void CGContextSetGrayStrokeColor(CGContextRef cg_nullable c, CGFloat gray, CGFloat alpha);void CGContextSetRGBFillColor(CGContextRef cg_nullable c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha);void CGContextSetRGBStrokeColor(CGContextRef cg_nullable c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha);void CGContextSetCMYKFillColor(CGContextRef cg_nullable c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha);void CGContextSetCMYKStrokeColor(CGContextRef cg_nullable c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha);//将当前上下文内容渲染进颜色intent中void CGContextSetRenderingIntent(CGContextRef cg_nullable c, CGColorRenderingIntent intent);//在指定区域内渲染图片void CGContextDrawImage(CGContextRef cg_nullable c, CGRect rect, CGImageRef cg_nullable image);//在区域内进行瓦片方式的图片渲染void CGContextDrawTiledImage(CGContextRef cg_nullable c, CGRect rect, CGImageRef cg_nullable image);//获取上下文渲染的图像质量CGInterpolationQuality CGContextGetInterpolationQuality(CGContextRef cg_nullable c);//设置上下文渲染时的图像质量void CGContextSetInterpolationQuality(CGContextRef cg_nullable c, CGInterpolationQuality quality);//设置进行阴影的渲染void CGContextSetShadowWithColor(CGContextRef cg_nullable c, CGSize offset, CGFloat blur, CGColorRef __nullable color);void CGContextSetShadow(CGContextRef cg_nullable c, CGSize offset, CGFloat blur);//绘制线性渐变效果void CGContextDrawLinearGradient(CGContextRef cg_nullable c, CGGradientRef cg_nullable gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options);//绘制半径渐变效果void CGContextDrawRadialGradient(CGContextRef cg_nullable c, CGGradientRef cg_nullable gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options);//用渐变填充上下文的裁剪区域void CGContextDrawShading(CGContextRef cg_nullable c, cg_nullable CGShadingRef shading);//设置绘制的文字间距void CGContextSetCharacterSpacing(CGContextRef cg_nullable c, CGFloat spacing);//设置绘制的文字位置void CGContextSetTextPosition(CGContextRef cg_nullable c, CGFloat x, CGFloat y);//获取绘制的文字位置CGPoint CGContextGetTextPosition(CGContextRef cg_nullable c);//设置文字transform变换void CGContextSetTextMatrix(CGContextRef cg_nullable c, CGAffineTransform t);//获取文字的transform变换CGAffineTransform CGContextGetTextMatrix(CGContextRef cg_nullable c);//设置文字的绘制模式/* kCGTextFill, //填充 kCGTextStroke, //空心 kCGTextFillStroke, //填充加边框 kCGTextInvisible, //在可是区域内 kCGTextFillClip, //裁剪填充 kCGTextStrokeClip, //裁剪绘制边框 kCGTextFillStrokeClip,//进行裁剪 kCGTextClip*/void CGContextSetTextDrawingMode(CGContextRef cg_nullable c, CGTextDrawingMode mode);//设置绘制文字的字体void CGContextSetFont(CGContextRef cg_nullable c, CGFontRef cg_nullable font);//设置绘制文字的字号void CGContextSetFontSize(CGContextRef cg_nullable c, CGFloat size);void CGContextShowGlyphsAtPositions(CGContextRef cg_nullable c, const CGGlyph * cg_nullable glyphs, const CGPoint * cg_nullable Lpositions, size_t count);//设置绘制的字符风格void CGContextShowGlyphsAtPositions(CGContextRef cg_nullable c, const CGGlyph * cg_nullable glyphs, const CGPoint * cg_nullable Lpositions, size_t count);//进行PDF页的绘制void CGContextDrawPDFPage(CGContextRef cg_nullable c, CGPDFPageRef cg_nullable page);//开启一个新的PDF页void CGContextBeginPage(CGContextRef cg_nullable c, const CGRect * __nullable mediaBox);//结束当前的PDF页void CGContextEndPage(CGContextRef cg_nullable c);//内存引用加1CGContextRef cg_nullable CGContextRetain(CGContextRef cg_nullable c);//内存引用计数减1void CGContextRelease(CGContextRef cg_nullable c);//将上下文中的内容立即渲染到目标void CGContextFlush(CGContextRef cg_nullable c);//将上下文中的内容进行同步void CGContextSynchronize(CGContextRef cg_nullable c);//是否开启抗锯齿效果void CGContextSetShouldAntialias(CGContextRef cg_nullable c, bool shouldAntialias);//是否允许抗锯齿效果void CGContextSetAllowsAntialiasing(CGContextRef cg_nullable c, bool allowsAntialiasing);//是否开启字体平滑void CGContextSetShouldSmoothFonts(CGContextRef cg_nullable c, bool shouldSmoothFonts);//是否允许字体平滑void CGContextSetAllowsFontSmoothing(CGContextRef cg_nullable c, bool allowsFontSmoothing);//设置是否开启subpixel状态渲染符号void CGContextSetShouldSubpixelPositionFonts(CGContextRef cg_nullable c, bool shouldSubpixelPositionFonts);//是否允许subpixel状态渲染符号void CGContextSetAllowsFontSubpixelPositioning(CGContextRef cg_nullable c, bool allowsFontSubpixelPositioning);//这个方法会在当前Context中开启一个透明的层 之后的绘制会绘制到这个透明的层上void CGContextBeginTransparencyLayer(CGContextRef cg_nullable c, CFDictionaryRef __nullable auxiliaryInfo);//在Context中开启一个透明的层void CGContextBeginTransparencyLayerWithRect(CGContextRef cg_nullable c, CGRect rect, CFDictionaryRef __nullable auxInfo);//完成透明层的渲染void CGContextEndTransparencyLayer(CGContextRef cg_nullable c);//返回用户控件的transform变换CGAffineTransform CGContextGetUserSpaceToDeviceSpaceTransform(CGContextRef cg_nullable c);//将用户控件点的坐标转换为设备控件坐标CGPoint CGContextConvertPointToDeviceSpace(CGContextRef cg_nullable c, CGPoint point);//将设备空间的点坐标转换为用户空间的点坐标CGPoint CGContextConvertPointToUserSpace(CGContextRef cg_nullable c, CGPoint point);//将用于空间的尺寸转换为设备空间的尺寸CGSize CGContextConvertSizeToDeviceSpace(CGContextRef cg_nullable c, CGSize size);//将设备空间的尺寸转换为用户空间的尺寸CGSize CGContextConvertSizeToUserSpace(CGContextRef cg_nullable c, CGSize size);//将用户空间的rect转换为设备空间的rectCGRect CGContextConvertRectToDeviceSpace(CGContextRef cg_nullable c, CGRect rect);//将设备空间的rect转换为用户空间的rectCGRect CGContextConvertRectToUserSpace(CGContextRef cg_nullable c, CGRect rect);//下面这些方法已经被弃用 //设置字体 使用CoreText相关的API代替void CGContextSelectFont(CGContextRef cg_nullable c, const char * cg_nullable name, CGFloat size, CGTextEncoding textEncoding);//绘制文本 使用CoreText相关API代替void CGContextShowText(CGContextRef cg_nullable c, const char * cg_nullable string, size_t length);//在相应位置绘制文本 使用CoreText相关API代替void CGContextShowTextAtPoint(CGContextRef cg_nullable c, CGFloat x, CGFloat y, const char * cg_nullable string, size_t length);//进行符号的绘制 使用CoreText相关API代替void CGContextShowGlyphs(CGContextRef cg_nullable c, const CGGlyph * __nullable g, size_t count);//在相应位置绘制符号 使用CoreText相关API代替void CGContextShowGlyphsAtPoint(CGContextRef cg_nullable c, CGFloat x, CGFloat y, const CGGlyph * __nullable glyphs, size_t count);//绘制符号 使用一个固定的缩进值 使用CoreText相关API代替void CGContextShowGlyphsWithAdvances(CGContextRef cg_nullable c, const CGGlyph * __nullable glyphs, const CGSize * __nullable advances, size_t count);//进行PDF文档绘制 CGPDFPage相关API代替void CGContextDrawPDFDocument(CGContextRef cg_nullable c, CGRect rect, CGPDFDocumentRef cg_nullable document, int page); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之一——CGPath的应用","slug":"259iOS开发CoreGraphics核心图形框架之一——CGPath的应用","date":"2016-10-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.352Z","comments":true,"path":"2016/10/11/259iOS开发CoreGraphics核心图形框架之一——CGPath的应用/","link":"","permalink":"http://huishao.cc/2016/10/11/259iOS开发CoreGraphics核心图形框架之一——CGPath的应用/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之一——CGPath的应用一、引言CoreGraphics核心图形框架相较于UIKit框架更加偏于底层。在Objective-C工程中，CoreGraphics其中方法都是采用C语言风格进行编写的，同时其并不支持Objective-C的自动引用计数，在使用这个框架进行编程时，开发者要手动对内存进行管理。在Swift工程中，Apple使用Swift语言对CoreGraphics矿建进行了重构，将CGPath，CGMutablePaht等都重新定义为了类。CGPath可以理解为图形的路径，在Objective-C工程中，其实系统定义的一个内部结构体，开发者不可以直接使用，开发者CGPathRef和CGMutablePathRef别名作为CGPath的引用，实际上，CGPathRef和CGMutablePathRef都是CGPath结构体类型的指针，不同的是一个是const类型不可修改的，一个是可以修改的，系统定义如下： 12typedef struct CGPath *CGMutablePathRef;typedef const struct CGPath *CGPathRef; 二、CGPath创建与内存管理的相关方法关于CGPath的创建与内存管理的相关方法，列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//这个方法获取CGPath类在CoreGraphics框架中的唯一标识//CFTypeID 实际上是无符号整型的别名 其为CoreGraphics框架中每个类都定义了一个标识 CGPath为280CFTypeID CGPathGetTypeID(void);//这个方法创建一个srtuct CGPath * 指针 可以理解为可变的CGPath类CGMutablePathRef CGPathCreateMutable(void);//这个方法通过一个CGPathRef来创建CGPathRef CGPathRef CGPathCreateCopy(CGPathRef path);//这个方法在通过CGPathRef创建CGPathRef时会将得路径进行transform变换后返回CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform * transform);//这个方法通过CGPathRef创建可变的CGMutablePathRefCGMutablePathRef CGPathCreateMutableCopy(CGPathRef path);//意义同上，在创建的CGMutablePathRef基础上进行一次transform变换在返回CGMutablePathRef CGPathCreateMutableCopyByTransformingPath(CGPathRef path, const CGAffineTransform * transform)//这个方法将创建矩形路径 第一个参数为要绘制的矩形区域 第2个参数为要进行的transform变换CGPathRef CGPathCreateWithRect(CGRect rect,const CGAffineTransform * transform);//这个方法将创建椭圆形路径CGPathRef CGPathCreateWithEllipseInRect(CGRect rect, const CGAffineTransform * transform);//这个方法用于创建圆角矩形路径/*rect :绘制的矩形区域cornerWidth: 横向圆角尺寸cornerHeight:纵向圆角尺寸*/CGPathRef CGPathCreateWithRoundedRect(CGRect rect, CGFloat cornerWidth, CGFloat cornerHeight,const CGAffineTransform * transform);//这个方法用于创建虚线路径/*这个方法略微有些复杂 其中参数意义如下：path：要进行虚线化的路径phase：从lengths数组的第几部分开始绘制虚线lengths:C风格的数组 其中为CGFloat值 表示每段虚线的绘制长度 例如传入数组为&#123;10,5&#125;，则虚线的先绘制长度为10的实线 在绘制长度为5的空白 在进行循环count：这个参数需要设置为lengths数组的长度*/CGPathRef CGPathCreateCopyByDashingPath(CGPathRef path, const CGAffineTransform * transform,CGFloat phase, const CGFloat *lengths, size_t count);//通过CGPathRef来创建斜线/*lineWidth:设置线宽lineCap:设置线帽风格 可选参数如下：typedef CF_ENUM(int32_t, CGLineCap) &#123; kCGLineCapButt, 默认的风格 线的端点精确到点 kCGLineCapRound, 圆滑的端点 线的端点为半径为线宽一半的圆弧 kCGLineCapSquare 尖锐的过渡&#125;;lineJoin：设置连接线处的风格 可选参数如下：typedef CF_ENUM(int32_t, CGLineJoin) &#123; kCGLineJoinMiter, //以锋利的角作为连接线的转折 kCGLineJoinRound, //以圆角作为连接线的转折 kCGLineJoinBevel //贝塞尔风格的转折&#125;;miterLimit：这个值将决定线连接处角的锋利程度*/CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef cg_nullable path, const CGAffineTransform * __nullable transform,CGFloat lineWidth, CGLineCap lineCap,CGLineJoin lineJoin, CGFloat miterLimit);//手动使CGPathRef引用计数+1CGPathRef CGPathRetain(CGPathRef cg_nullable path);//手动使CGPathRef引用计数-1void CGPathRelease(CGPathRef cg_nullable path); 自定义一个View视图，在其drawRect方法中进行界面的绘制，示例代码如下： 123456789101112131415161718- (void)drawRect:(CGRect)rect &#123; //获取当前绘图上下文 CGContextRef contextRef = UIGraphicsGetCurrentContext(); CGPoint center = CGPointMake(rect.size.width/2, rect.size.height/2); //创建圆角矩形路径 CGPathRef pathRef = CGPathCreateWithRoundedRect(CGRectMake(center.x-50, center.y-50, 100, 100), 30, 10, nil); //将路径虚线化 CGFloat floats[] = &#123;10,5&#125;; pathRef = CGPathCreateCopyByDashingPath(pathRef, nil, 0, floats, 2); //设置绘制颜色 [[UIColor redColor] setStroke]; //将路径添加到绘图上下文中 CGContextAddPath(contextRef, pathRef); //进行绘制 CGContextDrawPath(contextRef, kCGPathStroke); //内存释放 CGPathRelease(pathRef);&#125; 运行后效果如下图所示： 三、CGPath的路径绘制相关方法123456789101112131415161718192021222324252627282930313233343536373839404142434445//将路径移动到一个点作为起点void CGPathMoveToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat x, CGFloat y);//将路径移动到某个点画出一条线void CGPathAddLineToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat x, CGFloat y);//向路径中添加一段二次贝塞尔曲线/*cpx:控制点的x坐标cpy:控制点的y坐标*/void CGPathAddQuadCurveToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat cpx, CGFloat cpy,CGFloat x, CGFloat y);//添加一段三次贝塞尔曲线void CGPathAddCurveToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat cp1x, CGFloat cp1y,CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y);//这个方法用于闭合路径 调用这个方法后 路径最后的端点将和起点闭合void CGPathCloseSubpath(CGMutablePathRef path);//向路径中追加一个矩形void CGPathAddRect(CGMutablePathRef path, const CGAffineTransform * m, CGRect rect);//向路径中追加一组矩形void CGPathAddRects(CGMutablePathRef path, const CGAffineTransform * m, const CGRect * rects,size_t count);//向路径中追加一组线条void CGPathAddLines(CGMutablePathRef path, const CGAffineTransform * m, const CGPoint * __nullable points, size_t count);//添加一组椭圆void CGPathAddEllipseInRect(CGMutablePathRef cg_nullable path,const CGAffineTransform * m, CGRect rect);//向路径中追加一组圆弧/*x:圆心x坐标y:圆心y坐标radius:弧线半径startAngle:起始角度endAngle:终止角度clockwise:是否顺时针绘制*/void CGPathAddArc(CGMutablePathRef path, const CGAffineTransform * m, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, bool clockwise);//向路径中追加一组圆弧/*x:圆心x坐标y:圆心y坐标radius:弧线半径startAngle:起始角度delta:圆弧绘制的长度 为弧度制 2π为整个圆*/void CGPathAddRelativeArc(CGMutablePathRef path, const CGAffineTransform * __nullable matrix, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat delta);//向路径中追加一段圆弧 弧线是以(x1,y1)到(x2,y2)为切线的弧线void CGPathAddArcToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius);//向路径中追加一段路径void CGPathAddPath(CGMutablePathRef path1,const CGAffineTransform * m, CGPathRef path2); 示例代码如下： 123456789101112131415- (void)drawRect:(CGRect)rect &#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); CGPoint center = CGPointMake(rect.size.width/2, rect.size.height/2); CGMutablePathRef pathRef = CGPathCreateMutable(); CGPathMoveToPoint(pathRef, nil, center.x, center.y-50); CGPathAddLineToPoint(pathRef, nil, center.x+100, center.y); CGPathAddQuadCurveToPoint(pathRef, nil, 0, 0, center.x+100, center.y-100); CGPathAddRelativeArc(pathRef, nil, 100, 100, 50, 0, M_PI); CGPathCloseSubpath(pathRef); [[UIColor redColor] setStroke]; CGContextAddPath(contextRef, pathRef); CGContextDrawPath(contextRef, kCGPathStroke); CGPathRelease(pathRef); CGContextRelease(contextRef);&#125; 效果如下图所示： 四、CGPath中的其他方法汇总123456789101112//判断某个路径是否为空bool CGPathIsEmpty(CGPathRef path);//判断某个路径是否为某个矩形bool CGPathIsRect(CGPathRef cg_nullable path, CGRect * rect);//获取某个路径当前绘制所在的点CGPoint CGPathGetCurrentPoint(CGPathRef path);//获取某个路径包含所有点的尺寸CGPathGetBoundingBox(CGPathRef cg_nullable path);//获取某个路径的尺寸CGRect CGPathGetPathBoundingBox(CGPathRef path);//判断路径是否包含某个点bool CGPathContainsPoint(CGPathRef path, const CGAffineTransform * m, CGPoint point, bool eoFill); 五、关于CGPathElement结构体当每次向CGPath路径做操作时，操作的过程实际上都会被记录下来，每个操作行为节点都被封装为了CGPathElement结构体，开发者可以通过如下方法来获取所有操作行为： 1CGPathApply(pathRef, nil, func); CGPathApply()方法中的第3个参数为一个函数指针，示例C函数实现如下： 1234void func(void * __nullable info, const CGPathElement * element)&#123; printf(\"%d\",(*element).type);&#125; CGPathElement结构体的定义如下： 12345678910111213141516171819struct CGPathElement &#123; //操作节点的类型 CGPathElementType type; //对应的点集 CGPoint * points;&#125;;//CGPathElementType枚举定义如下typedef CF_ENUM(int32_t, CGPathElementType) &#123; //移动到点的操作行为 kCGPathElementMoveToPoint, //添加线的操作行为 kCGPathElementAddLineToPoint, //添加二次贝塞尔曲线的操作行为 kCGPathElementAddQuadCurveToPoint, //添加三次贝塞尔曲线的操作行为 kCGPathElementAddCurveToPoint, //闭合路径的操作行为 kCGPathElementCloseSubpath&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS10中更加灵活的色彩API","slug":"258iOS10中更加灵活的色彩API","date":"2016-10-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.352Z","comments":true,"path":"2016/10/09/258iOS10中更加灵活的色彩API/","link":"","permalink":"http://huishao.cc/2016/10/09/258iOS10中更加灵活的色彩API/","excerpt":"","text":"iOS10中更加灵活的色彩API一、创建sRGB模式的色彩在iOS10中，UIColor类中新增加了两个方法，用来创建sRGB模式的色彩。与RGB相比，sRGB是更加标准的色彩模式，RGB色彩在不同设备上可能存在颜色偏差，sRGB则更加精准但同时色域范围也更窄一些。UIColor中新添加的方法如下： 1234//类方法创建sRGB模式色彩+ (UIColor *)colorWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);//初始化方法创建sRGB模式色彩- (UIColor *)initWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0); 二、全局的设置色彩风格一般情况下，iOS系统会根据用户所在环境的光线进行屏幕色彩的调节，在iOS10系统中，开发者可以在info.plist文件中全局的配置色彩风格来设置外界光线对APP内色彩的影响程度。 在info.plist文件中可以添加如下键： White Point Adaptivity Style 这个键可以设置的值列举如下： Standard White Point Adaptivity Style 标准色彩模式 Reading White Point Adaptivity Style 阅读色彩模式 Photo White Point Adaptivity Style 照片色彩模式 Video White Point Adaptivity Style 视频色彩模式 Game White Point Adaptivity Style 游戏色彩模式 上面几种模式从上到下，对色彩的保真度依次提高。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"iOS10语音识别框架SpeechFramework应用","slug":"257iOS10语音识别框架SpeechFramework应用","date":"2016-09-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.352Z","comments":true,"path":"2016/09/25/257iOS10语音识别框架SpeechFramework应用/","link":"","permalink":"http://huishao.cc/2016/09/25/257iOS10语音识别框架SpeechFramework应用/","excerpt":"","text":"iOS10语音识别框架SpeechFramework应用一、引言iOS10系统是一个较有突破性的系统，其在Message，Notification等方面都开放了很多实用性的开发接口。本篇博客将主要探讨iOS10中新引入的SpeechFramework框架。有个这个框架，开发者可以十分容易的为自己的App添加语音识别功能，不需要再依赖于其他第三方的语音识别服务，并且，Apple的Siri应用的强大也证明了Apple的语音服务是足够强大的，不通过第三方，也大大增强了用户的安全性。 二、SpeechFramework框架中的重要类SpeechFramework框架比较轻量级，其中的类并不十分冗杂，在学习SpeechFramework框架前，我们需要对其中类与类与类之间的关系有个大致的熟悉了解。 SFSpeechRecognizer：这个类是语音识别的操作类，用于语音识别用户权限的申请，语言环境的设置，语音模式的设置以及向Apple服务发送语音识别的请求。 SFSpeechRecognitionTask：这个类是语音识别服务请求任务类，每一个语音识别请求都可以抽象为一个SFSpeechRecognitionTask实例，其中SFSpeechRecognitionTaskDelegate协议中约定了许多请求任务过程中的监听方法。 SFSpeechRecognitionRequest:语音识别请求类，需要通过其子类来进行实例化。 SFSpeechURLRecognitionRequest：通过音频URL来创建语音识别请求。 SFSpeechAudioBufferRecognitionRequest:通过音频流来创建语音识别请求。 SFSpeechRecognitionResult：语音识别请求结果类。 SFTranscription：语音转换后的信息类。 SFTranscriptionSegment：语音转换中的音频节点类。 了解了上述类的作用于其之间的联系，使用SpeechFramework框架将十分容易。 三、申请用户语音识别权限与进行语音识别请求开发者若要在自己的App中使用语音识别功能，需要获取用户的同意。首先需要在工程的Info.plist文件中添加一个Privacy-Speech Recognition Usage Description键，其实需要对应一个String类型的值，这个值将会在系统获取权限的警告框中显示，Info.plist文件如下图所示： 使用SFSpeechRecognize类的requestAuthorization方法来进行用户权限的申请，用户的反馈结果会在这个方法的回调block中传入，如下： 123//申请用户语音识别权限[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123; &#125;]; SFSpeechRecognizerAuthorzationStatus枚举中定义了用户的反馈结果，如下： 12345678910typedef NS_ENUM(NSInteger, SFSpeechRecognizerAuthorizationStatus) &#123; //结果未知 用户尚未进行选择 SFSpeechRecognizerAuthorizationStatusNotDetermined, //用户拒绝授权语音识别 SFSpeechRecognizerAuthorizationStatusDenied, //设备不支持语音识别功能 SFSpeechRecognizerAuthorizationStatusRestricted, //用户授权语音识别 SFSpeechRecognizerAuthorizationStatusAuthorized,&#125;; 如果申请用户语音识别权限成功，开发者可以通过SFSpeechRecognizer操作类来进行语音识别请求，示例如下： 123456789//创建语音识别操作类对象SFSpeechRecognizer * rec = [[SFSpeechRecognizer alloc]init];//通过一个音频路径创建音频识别请求SFSpeechRecognitionRequest * request = [[SFSpeechURLRecognitionRequest alloc]initWithURL:[[NSBundle mainBundle] URLForResource:@\"7011\" withExtension:@\"m4a\"]];//进行请求[rec recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; //打印语音识别的结果字符串 NSLog(@\"%@\",result.bestTranscription.formattedString);&#125;]; 四、深入SFSpeechRecognizer类SFSpeechRecognizer类的主要作用是申请权限，配置参数与进行语音识别请求。其中比较重要的属性与方法如下： 123456789101112131415161718192021222324252627282930313233//获取当前用户权限状态+ (SFSpeechRecognizerAuthorizationStatus)authorizationStatus;//申请语音识别用户权限+ (void)requestAuthorization:(void(^)(SFSpeechRecognizerAuthorizationStatus status))handler;//获取所支持的所有语言环境+ (NSSet&lt;NSLocale *&gt; *)supportedLocales;//初始化方法 需要注意 这个初始化方法将默认以设备当前的语言环境作为语音识别的语言环境- (nullable instancetype)init;//初始化方法 设置一个特定的语言环境- (nullable instancetype)initWithLocale:(NSLocale *)locale NS_DESIGNATED_INITIALIZER;//语音识别是否可用@property (nonatomic, readonly, getter=isAvailable) BOOL available;//语音识别操作类协议代理@property (nonatomic, weak) id&lt;SFSpeechRecognizerDelegate&gt; delegate;//设置语音识别的配置参数 需要注意 在每个语音识别请求中也有这样一个属性 这里设置将作为默认值//如果SFSpeechRecognitionRequest对象中也进行了设置 则会覆盖这里的值/*typedef NS_ENUM(NSInteger, SFSpeechRecognitionTaskHint) &#123; SFSpeechRecognitionTaskHintUnspecified = 0, // 无定义 SFSpeechRecognitionTaskHintDictation = 1, // 正常的听写风格 SFSpeechRecognitionTaskHintSearch = 2, // 搜索风格 SFSpeechRecognitionTaskHintConfirmation = 3, // 短语风格&#125;;*/@property (nonatomic) SFSpeechRecognitionTaskHint defaultTaskHint;//使用回调Block的方式进行语音识别请求 请求结果会在Block中传入- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler;//使用代理回调的方式进行语音识别请求- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request delegate:(id &lt;SFSpeechRecognitionTaskDelegate&gt;)delegate;//设置请求所占用的任务队列@property (nonatomic, strong) NSOperationQueue *queue; SFSpeechRecognizerDelegate协议中只约定了一个方法，如下: 12//当语音识别操作可用性发生改变时会被调用- (void)speechRecognizer:(SFSpeechRecognizer *)speechRecognizer availabilityDidChange:(BOOL)available; 通过Block回调的方式进行语音识别请求十分简单，如果使用代理回调的方式，开发者需要实现SFSpeechRecognitionTaskDelegate协议中的相关方法，如下： 123456789101112131415//当开始检测音频源中的语音时首先调用此方法- (void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task;//当识别出一条可用的信息后 会调用/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法*/- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription;//当识别完成所有可用的结果后调用- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult;//当不再接受音频输入时调用 即开始处理语音识别任务时调用- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task;//当语音识别任务被取消时调用- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task;//语音识别任务完成时被调用- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully; SFSpeechRecognitionTask类中封装了属性和方法如下： 12345678910111213141516171819//此任务的当前状态/*typedef NS_ENUM(NSInteger, SFSpeechRecognitionTaskState) &#123; SFSpeechRecognitionTaskStateStarting = 0, // 任务开始 SFSpeechRecognitionTaskStateRunning = 1, // 任务正在运行 SFSpeechRecognitionTaskStateFinishing = 2, // 不在进行音频读入 即将返回识别结果 SFSpeechRecognitionTaskStateCanceling = 3, // 任务取消 SFSpeechRecognitionTaskStateCompleted = 4, // 所有结果返回完成&#125;;*/@property (nonatomic, readonly) SFSpeechRecognitionTaskState state;//音频输入是否完成@property (nonatomic, readonly, getter=isFinishing) BOOL finishing;//手动完成音频输入 不再接收音频- (void)finish;//任务是否被取消@property (nonatomic, readonly, getter=isCancelled) BOOL cancelled;//手动取消任务- (void)cancel; 关于音频识别请求类，除了可以使用SFSpeechURLRecognitionRequest类来进行创建外，还可以使用SFSpeechAudioBufferRecognitionRequest类来进行创建： 12345678910@interface SFSpeechAudioBufferRecognitionRequest : SFSpeechRecognitionRequest@property (nonatomic, readonly) AVAudioFormat *nativeAudioFormat;//拼接音频流- (void)appendAudioPCMBuffer:(AVAudioPCMBuffer *)audioPCMBuffer;- (void)appendAudioSampleBuffer:(CMSampleBufferRef)sampleBuffer;//完成输入- (void)endAudio;@end 五、语音识别结果类SFSpeechRecognitionResultSFSpeechRecognitionResult类是语音识别结果的封装，其中包含了许多套平行的识别信息，其每一份识别信息都有可信度属性来描述其准确程度。SFSpeechRecognitionResult类中属性如下： 123456//识别到的多套语音转换信息数组 其会按照准确度进行排序@property (nonatomic, readonly, copy) NSArray&lt;SFTranscription *&gt; *transcriptions;//准确性最高的识别实例@property (nonatomic, readonly, copy) SFTranscription *bestTranscription;//是否已经完成 如果YES 则所有所有识别信息都已经获取完成@property (nonatomic, readonly, getter=isFinal) BOOL final; SFSpeechRecognitionResult类只是语音识别结果的一个封装，真正的识别信息定义在SFTranscription类中，SFTranscription类中属性如下： 1234//完整的语音识别准换后的文本信息字符串@property (nonatomic, readonly, copy) NSString *formattedString;//语音识别节点数组@property (nonatomic, readonly, copy) NSArray&lt;SFTranscriptionSegment *&gt; *segments; 当对一句完整的话进行识别时，Apple的语音识别服务实际上会把这句语音拆分成若干个音频节点，每个节点可能为一个单词，SFTranscription类中的segments属性就存放这些节点。SFTranscriptionSegment类中定义的属性如下： 123456789101112//当前节点识别后的文本信息@property (nonatomic, readonly, copy) NSString *substring;//当前节点识别后的文本信息在整体识别语句中的位置@property (nonatomic, readonly) NSRange substringRange;//当前节点的音频时间戳@property (nonatomic, readonly) NSTimeInterval timestamp;//当前节点音频的持续时间@property (nonatomic, readonly) NSTimeInterval duration;//可信度/准确度 0-1之间@property (nonatomic, readonly) float confidence;//关于此节点的其他可能的识别结果 @property (nonatomic, readonly) NSArray&lt;NSString *&gt; *alternativeSubstrings; 温馨提示：SpeechFramework框架在模拟器上运行会出现异常情况，无法进行语音识别请求。会报出kAFAssistantErrorDomain的错误，还望有知道解决方案的朋友，给些建议，Thanks。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"iOS10通知框架UserNotification理解与应用","slug":"255iOS10通知框架UserNotification理解与应用","date":"2016-09-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.351Z","comments":true,"path":"2016/09/18/255iOS10通知框架UserNotification理解与应用/","link":"","permalink":"http://huishao.cc/2016/09/18/255iOS10通知框架UserNotification理解与应用/","excerpt":"","text":"iOS10通知框架UserNotification理解与应用一、引言关于通知，无论与远程Push还是本地通知，以往的iOS系统暴漏给开发者的接口都是十分有限的，开发者只能对标题和内容进行简单的定义，至于UI展示和用户交互行为相关的部分，开发者开发起来都十分困难。至于本地通知，iOS10之前采用的是UILocationNotification类，远程通知有苹果服务器进行转发，本地通知和远程通知其回调的处理都是通过AppDelegate中的几个回调方法来完成。iOS10系统中，通知功能的增强是一大优化之处，iOS10中将通知功能整合成了一个框架UserNotification，其结构十分类似于iOS8中的UIWebView向WebKit框架整合的思路。并且UserNotification相比之前的通知功能更加强大，主要表现在如下几点： 1.通知处理代码可以从AppDelegate中剥离。 2.通知的注册，设置，处理更加结构化，更易于模块化开发。 3.UserNotification支持自定义通知音效和启动图。 4.UserNotification支持向通知内容中添加媒体附件，例如音频，视频。 5.UserNotification支持开发者定义多套通知模板。 6.UserNotification支持完全自定义的通知界面。 7.UserNotification支持自定义通知中的用户交互按钮。 8.通知的触发更加容易管理。 从上面列举的几点就可以看出，iOS10中的UsreNotification真的是一个大的改进，温故而知新，关于iOS之前版本本地通知和远程通知的相关内容请查看如下博客： 本地推送：http://my.oschina.net/u/2340880/blog/405491。 远程推送：http://my.oschina.net/u/2340880/blog/413584。 二、UserNotification概览学习一个新的框架或知识模块时，宏观上了解其体系，大体上掌握其结构是十分必要的，这更有利于我们对这个框架或模块的整体把握与理解。UserNotification框架中拆分定义了许多类、枚举和结构体，其中还定义了许多常量，类与类之间虽然关系复杂，但脉络十分清晰，把握住主线，层层分析，边很容易理解和应用UserNotification框架。 下图中列举了UserNotification框架中所有核心的类： 如图中关系所示，UserNotification框架中的核心类列举如下： UNNotificationCenter：通知管理中心，单例，通知的注册，接收通知后的回调处理等，是UserNotification框架的核心。 UNNotification：通知对象，其中封装了通知请求。 UNNotificationSettings：通知相关设置。 UNNotificationCategory：通知模板。 UNNotificationAction：用于定义通知模板中的用户交互行为。 UNNotificationRequest：注册通知请求，其中定义了通知的内容和触发方式。 UNNotificationResponse：接收到通知后的回执。 UNNotificationContent：通知的具体内容。 UNNotificationTrigger：通知的触发器，由其子类具体定义。 UNNotificationAttachment：通知附件类，为通知内容添加媒体附件。 UNNotificationSound：定义通知音效。 UNPushNotificationTrigger：远程通知的触发器，UNNotificationTrigger子类。 UNTimeInervalNotificationTrigger：计时通知的触发器，UNNotificationTrigger子类。 UNCalendarNotificationTrigger：周期通知的触发器，UNNotificationTrigger子类。 UNLocationNotificationTrigger：地域通知的触发器，UNNotificationTrigger子类。 UNNotificationCenterDelegate：协议，其中方法用于监听通知状态。 三、进行通知用户权限申请与创建普通的本地通知要在iOS系统中使用通知，必须获取到用户权限，UserNotification框架中申请通知用户权限需要通过UNNotificationCenter来完成，示例如下： 12345678//进行用户权限的申请[[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionBadge|UNAuthorizationOptionSound|UNAuthorizationOptionAlert|UNAuthorizationOptionCarPlay completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; //在block中会传入布尔值granted，表示用户是否同意 if (granted) &#123; //如果用户权限申请成功，设置通知中心的代理 [UNUserNotificationCenter currentNotificationCenter].delegate = self; &#125;&#125;]; 申请用户权限的方法中需要传入一个权限内容的参数，其枚举定义如下： 12345678910typedef NS_OPTIONS(NSUInteger, UNAuthorizationOptions) &#123; //允许更新app上的通知数字 UNAuthorizationOptionBadge = (1 &lt;&lt; 0), //允许通知声音 UNAuthorizationOptionSound = (1 &lt;&lt; 1), //允许通知弹出警告 UNAuthorizationOptionAlert = (1 &lt;&lt; 2), //允许车载设备接收通知 UNAuthorizationOptionCarPlay = (1 &lt;&lt; 3),&#125;; 获取到用户权限后，使用UserNotification创建普通的通知，示例代码如下： 123456789101112131415161718192021//通知内容类UNMutableNotificationContent * content = [UNMutableNotificationContent new];//设置通知请求发送时 app图标上显示的数字content.badge = @2;//设置通知的内容content.body = @\"这是iOS10的新通知内容：普通的iOS通知\";//默认的通知提示音content.sound = [UNNotificationSound defaultSound];//设置通知的副标题content.subtitle = @\"这里是副标题\";//设置通知的标题content.title = @\"这里是通知的标题\";//设置从通知激活app时的launchImage图片content.launchImageName = @\"lun\";//设置5S之后执行UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefault\" content:content trigger:trigger];//添加通知请求[[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 效果如下面图示： 四、通知音效类UNNotificationSound通知可以进行自定义的音效设置，其中方法如下： 1234567//系统默认的音效+ (instancetype)defaultSound;//自定义的音频音效/*注意，音频文件必须在bundle中或者在Library/Sounds目录下*/+ (instancetype)soundNamed:(NSString *)name __WATCHOS_PROHIBITED; 五、通知触发器UNNotificationTrigger通知触发器可以理解为定义通知的发送时间，UNNotificationTrigger是触发器的基类，具体的触发器由它的四个子类实现，实际上，开发者在代码中可能会用到的触发器只有三种，UNPushNotificationTrigger远程推送触发器开发者不需要创建使用，远程通知有远程服务器触发，开发者只需要创建与本地通知有关的触发器进行使用。 1.UNTimeIntervalNotificationTriggerUNTimeIntervalNotificationTrigger是计时触发器，开发者可以设置其在添加通知请求后一定时间发送。 1234//创建触发器 在timeInterval秒后触发 可以设置是否循环触发+ (instancetype)triggerWithTimeInterval:(NSTimeInterval)timeInterval repeats:(BOOL)repeats;//获取下次触发的时间点- (nullable NSDate *)nextTriggerDate; 2.UNCalendarNotificationTriggerUNCalendarNotificationTrigger是日历触发器，开发者可以设置其在某个时间点触发。 1234//创建触发器 设置触发时间 可以设置是否循环触发+ (instancetype)triggerWithDateMatchingComponents:(NSDateComponents *)dateComponents repeats:(BOOL)repeats;//下一次触发的时间点- (nullable NSDate *)nextTriggerDate; 3.UNLocationNotificationTriggerUNLocationNotificationTrigger是地域触发器，开发者可以设置当用户进入某一区域时触发。 1234//地域信息@property (NS_NONATOMIC_IOSONLY, readonly, copy) CLRegion *region;//创建触发器+ (instancetype)triggerWithRegion:(CLRegion *)region repeats:(BOOL)repeats __WATCHOS_PROHIBITED; 六、为通知内容添加附件附件主要指的是媒体附件，例如图片，音频和视频，为通知内容添加附件需要使用UNNotificationAttachment类。示例代码如下： 1234567891011121314151617//创建图片附件UNNotificationAttachment * attach = [UNNotificationAttachment attachmentWithIdentifier:@\"imageAttach\" URL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"2\" ofType:@\"jpg\"]] options:nil error:nil];UNMutableNotificationContent * content = [UNMutableNotificationContent new];//设置附件数组content.attachments = @[attach];content.badge = @1;content.body = @\"这是iOS10的新通知内容：普通的iOS通知\";//默认的通知提示音content.sound = [UNNotificationSound defaultSound];content.subtitle = @\"这里是副标题\";content.title = @\"这里是通知的标题\";//设置5S之后执行UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefaultImage\" content:content trigger:trigger];[[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 效果如下图： 需要注意，UNNotificationContent的附件数组虽然是一个数组，但是系统的通知模板只能展示其中的第一个附件，设置多个附件也不会有额外的效果，但是如果开发者进行通知模板UI的自定义，则此数组就可以派上用场了。音频附件界面如下： 需要注意，添加附件的格式和大小都有一定的要求，如下表格所示： 创建通知内容附件UNNotificationAttachment实例的方法中有一个options配置字典，这个字典中可以进行配置的键值对如下： 12345678//配置附件的类型的键 需要设置为NSString类型的值，如果不设置 则默认从扩展名中推断extern NSString * const UNNotificationAttachmentOptionsTypeHintKey __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);//配置是否隐藏缩略图的键 需要配置为NSNumber 0或者1extern NSString * const UNNotificationAttachmentOptionsThumbnailHiddenKey __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);//配置使用一个标准的矩形来对缩略图进行裁剪，需要配置为CGRectCreateDictionaryRepresentation(CGRect)创建的矩形引用extern NSString * const UNNotificationAttachmentOptionsThumbnailClippingRectKey __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);//使用视频中的某一帧作为缩略图 配置为NSNumber时间extern NSString * const UNNotificationAttachmentOptionsThumbnailTimeKey __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0); 七、定义通知模板UNNotificationCategory聊天类软件在iOS系统中，常常采用后台推送的方式推送新消息，用户可以在不进入应用程序的情况下，直接在左面回复通知推送过来的信息，这种功能就是通过UNNotificationCategory模板与UNNotificationAction用户活动来实现的。关于文本回复框，UserNotification框架中提供了UNTextInputNotificationAction类，其是UNNotificationAction的子类。示例代码如下： 1234567891011121314151617181920212223242526272829303132//创建用户活动/*options参数可选如下：//需要在解开锁屏下使用UNNotificationActionOptionAuthenticationRequired//是否指示有破坏性UNNotificationActionOptionDestructive//是否允许活动在后台启动appUNNotificationActionOptionForeground//无设置UNNotificationActionOptionNone*/UNTextInputNotificationAction * action = [UNTextInputNotificationAction actionWithIdentifier:@\"action\" title:@\"回复\" options:UNNotificationActionOptionAuthenticationRequired textInputButtonTitle:@\"活动\" textInputPlaceholder:@\"请输入回复内容\"];//创建通知模板UNNotificationCategory * category = [UNNotificationCategory categoryWithIdentifier:@\"myNotificationCategoryText\" actions:@[action] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction];UNMutableNotificationContent * content = [UNMutableNotificationContent new];content.badge = @1;content.body = @\"这是iOS10的新通知内容：普通的iOS通知\";//默认的通知提示音content.sound = [UNNotificationSound defaultSound];content.subtitle = @\"这里是副标题\";content.title = @\"这里是通知的标题\";//设置通知内容对应的模板 需要注意 这里的值要与对应模板id一致content.categoryIdentifier = @\"myNotificationCategoryText\";//设置5S之后执行UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithObjects:category, nil]];UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefaultText\" content:content trigger:trigger]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 需要注意，要使用模板，通知内容UNNotificationContent的categoryIdentifier要与UNNotificationCategory的id一致。效果如下： 也可以为通知模板添加多个自定义的用户交互按钮，示例如下： 1234567891011121314151617181920UNNotificationAction * action = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题1\" options:UNNotificationActionOptionNone]; UNNotificationAction * action2 = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题2\" options:UNNotificationActionOptionNone]; UNNotificationAction * action3 = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题3\" options:UNNotificationActionOptionNone]; UNNotificationAction * action4 = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题4\" options:UNNotificationActionOptionNone]; UNNotificationCategory * category = [UNNotificationCategory categoryWithIdentifier:@\"myNotificationCategoryBtn\" actions:@[action,action2,action3,action4] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; UNMutableNotificationContent * content = [UNMutableNotificationContent new]; content.badge = @1; content.body = @\"这是iOS10的新通知内容：普通的iOS通知\"; //默认的通知提示音 content.sound = [UNNotificationSound defaultSound]; content.subtitle = @\"这里是副标题\"; content.title = @\"这里是通知的标题\"; content.categoryIdentifier = @\"myNotificationCategoryBtn\"; //设置5S之后执行 UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefault\" content:content trigger:trigger]; [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithObjects:category, nil]]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 需要注意，系统模板最多支持添加4个用户交互按钮，如下图： 八、自定义通知模板UI通过前边的介绍，我们发现通过UserNotification框架开发者已经可以完成许多从来很难实现的效果。然而这都不是UserNotification框架最强大的地方，UserNotification框架最强大的地方在于其可以完全自定义通知的UI界面。 完全自定义通知界面是通过iOS扩展来实现的，首先创建一个新的target，如下图： 选择Notification Content，如下： 创建完成后，会发现工程中多了一个Notification Content的扩展，其中自带一个storyboard文件和一个NotificationViewController类，开发者可以在storyboard文件或者直接在Controller类中进行自定义界面的编写。 需要注意，NotificationViewController自动遵守了UNNotificationContentExtension协议，这个协议专门用来处理自定义通知UI的内容展示，其中方法列举如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//接收到通知时会被调用/*开发者可以从notification对象中拿到附件等内容进行UI刷新*/- (void)didReceiveNotification:(UNNotification *)notification;//当用户点击了通知中的用户交互按钮时会被调用/*response对象中有通知内容相关信息在回调block块completion中，开发者可以传入一个UNNotificationContentExtensionResponseOption参数来告诉系统如何处理这次用户活动UNNotificationContentExtensionResponseOption枚举中可选值如下：typedef NS_ENUM(NSUInteger, UNNotificationContentExtensionResponseOption) &#123; //不关闭当前通知界面 UNNotificationContentExtensionResponseOptionDoNotDismiss, //关闭当前通知界面 UNNotificationContentExtensionResponseOptionDismiss, //关闭当前通知界面并将用户活动传递给宿主app处理 UNNotificationContentExtensionResponseOptionDismissAndForwardAction,&#125; __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE;*/- (void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption option))completion;/*这个属性作为get方法进行实现 这个方法用来返回一个通知界面要显示的媒体按钮typedef NS_ENUM(NSUInteger, UNNotificationContentExtensionMediaPlayPauseButtonType) &#123; //不显示媒体按钮 UNNotificationContentExtensionMediaPlayPauseButtonTypeNone, //默认的媒体按钮 当点击按钮后 进行播放与暂停的切换 按钮始终显示 UNNotificationContentExtensionMediaPlayPauseButtonTypeDefault, //Overlay风格 当点击按钮后，媒体播放，按钮隐藏 点击媒体后，播放暂停，按钮显示。 UNNotificationContentExtensionMediaPlayPauseButtonTypeOverlay,&#125; __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE;*/@property (nonatomic, readonly, assign) UNNotificationContentExtensionMediaPlayPauseButtonType mediaPlayPauseButtonType;//返回媒体按钮的位置@property (nonatomic, readonly, assign) CGRect mediaPlayPauseButtonFrame;//返回媒体按钮的颜色@property (nonatomic, readonly, copy) UIColor *mediaPlayPauseButtonTintColor;//点击播放按钮的回调- (void)mediaPlay;//点击暂停按钮的回调- (void)mediaPause;//媒体开始播放的回调- (void)mediaPlayingStarted __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE;//媒体开始暂停的回调- (void)mediaPlayingPaused __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE; 需要注意，自定义的通知界面上虽然可以放按钮，可以放任何UI控件，但是其不能进行用户交互，唯一可以进行用户交互的方式是通过协议中的媒体按钮及其回调方法。 定义好了通知UI模板，若要进行使用，还需要再Notification Content扩展中的info.plist文件的NSExtension字典的NSExtensionAttributes字典里进行一些配置，正常情况下，开发者需要进行配置的键有3个，分别如下： UNNotificationExtensionCategory：设置模板的categoryId，用于与UNNotificationContent对应。 UNNotificationExtensionInitialContentSizeRatio：设置自定义通知界面的高度与宽度的比，宽度为固定宽度，在不同设备上有差别，开发者需要根据宽度计算出高度进行设置，系统根据这个比值来计算通知界面的高度。 UNNotificationExtensionDefaultContentHidden：是有隐藏系统默认的通知界面。 配置info.plist文件如下： 用如下的代码创建通知： 123456789101112131415161718UNNotificationAction * action = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题1\" options:UNNotificationActionOptionNone]; //根据id拿到自定义UI的模板 UNNotificationCategory * category = [UNNotificationCategory categoryWithIdentifier:@\"myNotificationCategoryH\" actions:@[action] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; UNMutableNotificationContent * content = [UNMutableNotificationContent new]; content.badge = @1; content.body = @\"这是iOS10的新通知内容：普通的iOS通知\"; //默认的通知提示音 content.sound = [UNNotificationSound defaultSound]; content.subtitle = @\"这里是副标题\"; content.title = @\"这里是通知的标题\"; content.categoryIdentifier = @\"myNotificationCategoryH\"; //设置5S之后执行 UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefaultCustomUIH\" content:content trigger:trigger]; [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithObjects:category, nil]]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 效果如下图： 如果将UNNotificationExtensionDefaultContentHidden键值设置为0或者不设置，则不会隐藏系统默认的UI，如下： 九、通知回调的处理UserNotification框架对于通知的回调处理，是通过UNUserNotificationCenterDelegate协议来实现的，这个协议中有两个方法，如下： 1234567891011121314151617181920/*这个方法在应用在前台，并且将要弹出通知时被调用，后台状态下弹通知不会调用这个方法这个方法中的block块completionHandler()可以传入一个UNNotificationPresentationOptions类型的枚举有个这个参数，开发者可以设置在前台状态下，依然可以弹出通知消息，枚举如下：typedef NS_OPTIONS(NSUInteger, UNNotificationPresentationOptions) &#123; //只修改app图标的消息数 UNNotificationPresentationOptionBadge = (1 &lt;&lt; 0), //只提示通知音效 UNNotificationPresentationOptionSound = (1 &lt;&lt; 1), //只弹出通知框 UNNotificationPresentationOptionAlert = (1 &lt;&lt; 2),&#125; __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);//什么都不做static const UNNotificationPresentationOptions UNNotificationPresentationOptionNone */- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);/*这个方法当接收到通知后，用户点击通知激活app时被调用，无论前台还是后台*/- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0) __TVOS_PROHIBITED; 十、UserNotification框架中其他零散知识前面所介绍的内容基本涵盖了UserNotification框架中所有的内容，在以后的应用开发中，开发者可以在通知方面发挥更大的想象力与创造力，给用户更加友好的体验。除了前边所介绍过的核心内容外，UserNotification框架中还有一些零散的类、枚举等。 1.错误码描述1234567891011121314151617181920typedef NS_ENUM(NSInteger, UNErrorCode) &#123; //通知不被允许 UNErrorCodeNotificationsNotAllowed = 1, //附件无效url UNErrorCodeAttachmentInvalidURL = 100, //附件类型错误 UNErrorCodeAttachmentUnrecognizedType, //附件大小错误 UNErrorCodeAttachmentInvalidFileSize, //附件数据错误 UNErrorCodeAttachmentNotInDataStore, UNErrorCodeAttachmentMoveIntoDataStoreFailed, UNErrorCodeAttachmentCorrupt, //时间无效 UNErrorCodeNotificationInvalidNoDate = 1400, //无内容 UNErrorCodeNotificationInvalidNoContent,&#125; __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0); 2.UNNotification类123456789@interface UNNotification : NSObject &lt;NSCopying, NSSecureCoding&gt;//触发的时间@property (nonatomic, readonly, copy) NSDate *date;//内置的通知请求对象@property (nonatomic, readonly, copy) UNNotificationRequest *request;- (instancetype)init NS_UNAVAILABLE;@end 3.UNNotificationSettings类UNNotificationSettings类主要用来获取与通知相关的信息。 12345678910111213141516171819@interface UNNotificationSettings : NSObject &lt;NSCopying, NSSecureCoding&gt;//用户权限状态@property (NS_NONATOMIC_IOSONLY, readonly) UNAuthorizationStatus authorizationStatus;//音效设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting soundSetting __TVOS_PROHIBITED;//图标提醒设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting badgeSetting __WATCHOS_PROHIBITED;//提醒框设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting alertSetting __TVOS_PROHIBITED;//通知中心设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting notificationCenterSetting __TVOS_PROHIBITED;//锁屏设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting lockScreenSetting __TVOS_PROHIBITED __WATCHOS_PROHIBITED;//车载设备设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting carPlaySetting __TVOS_PROHIBITED __WATCHOS_PROHIBITED;//提醒框风格@property (NS_NONATOMIC_IOSONLY, readonly) UNAlertStyle alertStyle __TVOS_PROHIBITED __WATCHOS_PROHIBITED;@end UNNotificationSetting枚举如下： 12345678910typedef NS_ENUM(NSInteger, UNNotificationSetting) &#123; //不支持 UNNotificationSettingNotSupported = 0, //不可用 UNNotificationSettingDisabled, //可用 UNNotificationSettingEnabled,&#125; UNAuthorizationStatus枚举如下： 12345678910typedef NS_ENUM(NSInteger, UNAuthorizationStatus) &#123; //为做选择 UNAuthorizationStatusNotDetermined = 0, // 用户拒绝 UNAuthorizationStatusDenied, // 用户允许 UNAuthorizationStatusAuthorized&#125; UNAlertStyle枚举如下： 12345678typedef NS_ENUM(NSInteger, UNAlertStyle) &#123; //无 UNAlertStyleNone = 0, //顶部Banner样式 UNAlertStyleBanner, //警告框样式 UNAlertStyleAlert,&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"iOS10中Messages独立应用与扩展插件详析","slug":"256iOS10中Messages独立应用与扩展插件详析","date":"2016-09-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.351Z","comments":true,"path":"2016/09/18/256iOS10中Messages独立应用与扩展插件详析/","link":"","permalink":"http://huishao.cc/2016/09/18/256iOS10中Messages独立应用与扩展插件详析/","excerpt":"","text":"iOS10中Messages独立应用与扩展插件详析一、引言Messages是iOS系统中原生的信息应用，其既可以通过运营商网络发送短信息，也可以通过互联网进行类似微信类社交软件的即时聊天。但是由于其封闭性与功能的单一，使用其进行即时聊天的用户并不多。随着iOS10系统的推出，或许可以改变这一现状。在iOS10中，Messages的功能被扩展的十分强大，通过Messages，用户可以分享图片，音乐，视频，可以随手涂鸦，使用自定义的表情包，可以进行Apple Pay支付，购物，甚至可以在Messages中玩游戏。并且，上面所提到的这些功能都全面开发出了接口供开发者进行开发与扩展。 在iOS10中，开发者可以进行与Messages相关的开发有两类：独立的Messages应用与Messages应用扩展。其中，Messages应用扩展需要依附一个宿主App而存在。无论哪种类型的Messages应用，其都又分为两类，StickerPicks（表情包）与iMessage Apps(Messages应用)。 二、开发表情包StickerPicks1.开发独立的表情包Sticker Picks可谓是iOS10中一个十分强大的新功能。在iOS10系统的iPhone上，Messages应用中会内嵌一个Message App Store，用户可以直接从里面下载针对于Messages的独立表情包和独立第三方应用。开发者也可以独立开发表情包发布到这个Message App Store中。 开发Sticker Picks表情包十分简单，开发者可以不用写一句代码，将整理好的表情进行打包提交即可完成。使用Xcode8创建一个新的工程，选择Sticker Pack Application模板，如下图所示： 创建出工程后，可以发现模板中没有任何代码文件，只有一个Stickers.xcstickers包。将准备好的表情包图片导入这个Stickers中，其中支持静态图片，也支持动态表情gif图片。关于导入的图片，有如下几条规则： 1.图片文件的格式必须是PNG、APNG、GIF或者JPEG。 2.单个文件的大小不能超过500KB。 3.最优的效果是当图片尺寸在100*100到206*206之间。 注意：在提供图片的时候，开发者只需要提供@3倍图即可，即最优尺寸在300*300到618*618之间的图片。系统会自动生成@2与@1倍图。 开发的表情包会显示在Messages应用的工具中，需要注意，在表情列表的排版中，每个表情缩略图只支持3种尺寸的排版，对应的尺寸分别如下： Small类型：100*100 Medium类型：136*136 Large类型：206*206 在Xcode中，可以对要使用的模板进行选择，如下图： 在模拟器中运行工程，Messages中效果如下图： 和普通iOS应用程序一样，将设备选择为Generic iOS Device后直接Archives即可将表情包提交到AppStore，审核通过后，即可在Message App Store中进行下载。 小提示：其实StickerPicks翻译成表情包并不合适，其更有一层贴纸的概念。实际上其也确实有贴纸的功能，在Messages应用中，用户可以通过长按移动手势，来将某个Sticker添加在另一个Sticker上面。如下图： 2.开发寄宿于宿主App的表情包扩展扩展表情包与独立表情包最大的不同在于扩展需要寄宿于某个宿主App中，创建扩展target，选择Sticker Pick Extension，如下图，之后和独立表情包开发过程一致。 3.关于表情包的icon图标StickerPicks的图标和宿主App并不共用，其需要一套独特尺寸的icon，尺寸如下： 效果如下图所示： 三、开发Messages App应用1.认识Messages框架和StickerPicks表情包一样，Messages App也分为独立应用与扩展两种。其实它们的开发思路和方法完全一致，只是有无宿主App的区别。 开发Messages App需要使用到iOS中引入的一个新的开发框架Messages。Messages比较简单，其中涉及到的类并不十分多，下图中概述了其中重要的类和之间的关系： MSMessageAppViewController：这个类Messages App的基础视图控制器类，其继承自UIViewController，但其中添加了许多Messages App相关的声明周期方法。 MSConversation：描述一个会话实例。 MSSticker：表情贴图实例。 MSMessage：在Messages App之间进行传递的消息实体。 MSMessageLayout：抽象类，其并没有实现任何方法，有子类实现。 MSMessageTemplateLayout：用于对消息实体MSMessage进行布局排版。 MSStickerBorwserViewController：用于创建表情包视图控制器。 MSStickerBorwserView：表情包视图容器，类似CollectionView。 MSStickerView：表情承载视图。 2.实现一个Messages App的列表界面使用Xcode新建一个Messages App工程如下： 其会自动生成一个MessagesViewController类，这个类就是此Messages App的主界面视图控制器。需要注意，Messages App的视图控制器都分为两种状态，分别为Compact(紧凑的)和Expanded(扩宽的)。并且在这两种状态进行切换时，视图的底部的工具栏和头部的导航栏也会交替出现，这导致了即使是使用自动布局，依然无法完美的解决Messages App布局的统一性，需要手动进行调整处理，后面会介绍到。 在MessagesViewController类中添加其他视图控件，大部分iOS App开发中可以使用的UI控件这里都可以使用，但是有一点需要注意，对于可以弹出键盘的UI控件，例如UITextView与UITextField，当Messages App界面处理Compact模式时，键盘是不能弹出的，只有当界面处于Expanded模式时，键盘才被允许弹出。 为了使Messages App的界面在任何模式下都能保持统一，需要手动对其中视图约束进行修改，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.dataArray = [NSMutableArray array]; [self.dataArray addObjectsFromArray:@[@\"发送文本信息\",@\"插入表情\",@\"插入文件\",@\"插入消息实体\",@\"跳转第二个界面\",@\"贴图包\"]]; [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@\"cellId\"]; self.tableView.dataSource = self; self.tableView.delegate = self; self.session = [[MSSession alloc]init];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.dataArray.count;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"cellId\"]; cell.textLabel.text = self.dataArray[indexPath.row]; return cell;&#125;//这个方法在Messages App加载完成处于活跃状态时被调用 在其中根据模式设置布局参数-(void)didBecomeActiveWithConversation:(MSConversation *)conversation &#123; // Called when the extension is about to move from the inactive to active state. // This will happen when the extension is about to present UI. if (self.presentationStyle==MSMessagesAppPresentationStyleCompact) &#123; _topMargan.constant = 0; _leftMargan.constant = -15; _rightMargan.constant = -15; _bottomMargan.constant=-44; &#125;else&#123; _topMargan.constant = -85; _leftMargan.constant = -15; _rightMargan.constant = -15; _bottomMargan.constant=0; &#125; [self.view layoutIfNeeded]; &#125;//这个方法在视图控制器的模式发生了改变时调用 在其中根据模式修改布局参数-(void)didTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle &#123; // Called after the extension transitions to a new presentation style. // Use this method to finalize any behaviors associated with the change in presentation style. if (presentationStyle==MSMessagesAppPresentationStyleCompact) &#123; _topMargan.constant = 0; _leftMargan.constant = -15; _rightMargan.constant = -15; _bottomMargan.constant=-44; &#125;else&#123; _topMargan.constant = -85; _leftMargan.constant = -15; _rightMargan.constant = -15; _bottomMargan.constant=0; &#125; [self.view layoutIfNeeded];&#125; 3.解析MSMessagesAppViewController类由于MSMessagesAppViewController类是继承于UIViewController类的，因此UIViewController中的视图控制器切换方法这里都可以直接使用，MSMessagesAppViewController中供开发者进行调用的属性和方法如下： 12345678910111213141516//当前激活的会话实例 后面会介绍@property (nonatomic, strong, readonly, nullable) MSConversation *activeConversation;//当前界面所在的状态/*typedef NS_ENUM(NSUInteger, MSMessagesAppPresentationStyle) &#123; //紧凑状态 MSMessagesAppPresentationStyleCompact, //扩宽状态 MSMessagesAppPresentationStyleExpanded&#125; NS_ENUM_AVAILABLE_IOS(10_0);*/@property (nonatomic, assign, readonly) MSMessagesAppPresentationStyle presentationStyle;//切换界面状态-(void)requestPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;//调用此方法后，MessagesApp被收回 弹出键盘-(void)dismiss; MSMessagesAppViewController中新增加的声明周期方法如下： 12345678910111213141516171819202122//当Messages App将要激活时调用-(void)willBecomeActiveWithConversation:(MSConversation *)conversation;//当Messages App已经被激活后调用-(void)didBecomeActiveWithConversation:(MSConversation *)conversation;//当Messages App将要被注销时调用-(void)willResignActiveWithConversation:(MSConversation *)conversation;//当MessageApp已经被注销时调用-(void)didResignActiveWithConversation:(MSConversation *)conversation;//消息实体在会话中将要被选中时调用-(void)willSelectMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//消息实体在会话中已经被选中时调用-(void)didSelectMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//接收到同一Messages App发送的消息实体时调用-(void)didReceiveMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//开发发送消息时调用-(void)didStartSendingMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//取消发送时调用-(void)didCancelSendingMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//控制器界面模式将要改变时调用-(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;//控制器界面已经改变时调用-(void)didTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle; 4.使用MSConversation会话类来进行消息的发送MSConversation类用来描述会话，MSMessagesAppViewController中内置MSConversation对象，开发者可以用它来进行消息传递，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; switch (indexPath.row) &#123; case 0: &#123; [self.activeConversation insertText:@\"新的信息\" completionHandler:^(NSError * error) &#123; &#125;]; &#125; break; case 1: &#123; [self.activeConversation insertSticker:[[MSSticker alloc] initWithContentsOfFileURL:[[NSURL alloc] initFileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"productImage\" ofType:@\"png\"]] localizedDescription:@\"image\" error:nil] completionHandler:nil]; &#125; break; case 2: &#123; [self.activeConversation insertAttachment:[[NSURL alloc] initFileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"file\" ofType:nil]] withAlternateFilename:@\"文件\" completionHandler:nil]; &#125; break; case 3: &#123; MSMessage * message = [[MSMessage alloc]initWithSession:_session]; message.URL = [NSURL URLWithString:@\"http://www.baidu.com\"]; message.accessibilityLabel = @\"message\"; message.summaryText = @\"message\"; MSMessageTemplateLayout * layout = [[MSMessageTemplateLayout alloc]init]; layout.caption = @\"caption\"; layout.subcaption = @\"subcaption\"; layout.trailingCaption = @\"trailing\"; layout.trailingSubcaption =@\"subtrailing\"; layout.image = [UIImage imageNamed:@\"productImage\"]; layout.mediaFileURL =[[NSURL alloc] initFileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"productImage\" ofType:@\"png\"]]; layout.imageTitle = @\"杜康\"; layout.imageSubtitle = @\"酒水\"; message.layout = layout; [self.activeConversation insertMessage:message completionHandler:nil]; &#125; break; case 4: &#123; [self presentViewController:[StackerViewController new] animated:YES completion:nil ]; &#125; break; case 5: &#123; [self presentViewController:[StackController new] animated:YES completion:nil ]; &#125; break; default: break; &#125;&#125; MSConversation支持发送的消息分为4中，分别为文本消息，表情贴图消息，文件消息和Message实体消息，上面代码都做了演示。MSConversation中重要属性和方法解析如下： 1234567891011121314//本地的设备UUID@property (nonatomic, readonly) NSUUID *localParticipantIdentifier;//会话中远程设备的UUID 支持多人会话@property (nonatomic, readonly) NSArray&lt;NSUUID *&gt; *remoteParticipantIdentifiers;//当前选中的消息实体@property (nonatomic, readonly, nullable) MSMessage *selectedMessage;//插入文本消息- (void)insertText:(NSString *)text completionHandler:(nullable void (^)(NSError * _Nullable))completionHandler;//插入表情贴图消息- (void)insertSticker:(MSSticker *)sticker completionHandler:(nullable void (^)(NSError * _Nullable))completionHandler;//插入文件附件消息- (void)insertAttachment:(NSURL *)URL withAlternateFilename:(nullable NSString *)filename completionHandler:(nullable void (^)(NSError * _Nullable))completionHandler;//插入Message实体消息- (void)insertMessage:(MSMessage *)message completionHandler:(nullable void (^)(NSError * _Nullable))completionHandler; 效果图如下： 5.消息实体MSMessage的应用MSMessage是Messages App定义的一种消息实体，其可以用来在Messages App间传递信息，因为它的存在，通过Messages用用实现休闲对战游戏变得十分容易，开发者不需要在写即时通信链接，只需设计游戏逻辑即可。MSMessage不能够完全自定义UI，但是Messages框架中的MSMessageTemplateLayout类可以对其UI进行简单的配置。 MSMessage类中常用的属性和方法如下： 12345678910111213//初始化方法 可以绑定一个session，同一个session种的消息实体会被归为一类-(instancetype)initWithSession:(MSSession *)session NS_DESIGNATED_INITIALIZER;//发送此消息的设备@property (nonatomic, readonly) NSUUID *senderParticipantIdentifier;//消息的UI布局信息@property (nonatomic, copy, nullable) MSMessageLayout* layout;//消息附带的URL 开发者可以通过这个URL来传值 @property (nonatomic, copy, nullable) NSURL *URL;//是否保留过期的消息@property (nonatomic, assign) BOOL shouldExpire;//盲人模式中对应的文案@property (nonatomic, copy, nullable) NSString *accessibilityLabel; 6.消息实体布局类MSMessageLayout前面介绍，MSMessage类中并没有定义UI，UI部分需要配合MSMessageLayout类来配置。需要注意，MSMessageLayout类是一个抽象类，apple设计的目的可能是为了以后便于扩展多个消息布局模板。目前，开发者只需要使用MSMessageTemplateLayout类来对消息实体进行布局。 MSMessageTemplateLayout类中可以配置的属性如下： 12345678910111213141516//设置消息实体的标题@property (nonatomic, copy, nullable) NSString *caption;//设置消息实体的子标题@property (nonatomic, copy, nullable) NSString *subcaption;//设置消息实体的右侧标题@property (nonatomic, copy, nullable) NSString *trailingCaption;//设置消息实体的右侧子标题@property (nonatomic, copy, nullable) NSString *trailingSubcaption;//设置消息实体的图片@property (nonatomic, strong, nullable) UIImage *image;//设置消息实体的媒体地址 需要注意 如果设置的image属性 这个属性将被忽略@property (nonatomic, copy, nullable) NSURL *mediaFileURL;//设置消息实体的图标标题@property (nonatomic, copy, nullable) NSString *imageTitle;//设置消息实体的图片子标题@property (nonatomic, copy, nullable) NSString *imageSubtitle; 7.表情贴图类MSSticker与MSStickerView在制作表情包Sticker Picks的时候，开发者不需要编写一行代码，实际上如果要通过代码来开发表情包也是没有问题的，这里需要用到的一个类就是MSSticker类，简单理解，MSSticker类对象就是一个表情贴图，但是它不是一个View视图，若想在Messages App中看到这个表情贴图，还需要借助一个类MSStickerView，MSStickerView是用于承载表情贴图的视图类，用户选中它后，可以在Messages应用中进行发送。 首先，MSSticker类创建方法如下： 12//初始化方法 通过文件URL 来创建实例- (nullable instancetype)initWithContentsOfFileURL:(NSURL *)fileURL localizedDescription:(NSString *)localizedDescription error:(NSError * _Nullable *)error NS_DESIGNATED_INITIALIZER; MSStickerView类解析如下： 1234567891011//通过MSSticker来进行MSStickerView类的创建- (instancetype)initWithFrame:(CGRect)frame sticker:(nullable MSSticker *)sticker;//获取动画播放一遍的时间 如果是gif@property(nonatomic, readonly) NSTimeInterval animationDuration;//开始动画-(void) startAnimating;//结束动画-(void) stopAnimating;//获取动画状态- (BOOL)isAnimating; 需要注意，MSStickerView如果加载的是gif类型的表情贴图，默认不会播放动画，开发者可以调用开始动画的方法来进行gif动画的播放。 8.表情包视图控制器MSStickerBrowserViewController其实通过前面的内容，已经可以自定义开发一个表情包Messages App了，但是还有一个视图控制器类MSStickerBrowserViewController，这个类可以更加简单方面的创建表情包视图控制器。要了解MSStickerBrowserViewController类，首先应该先了解MSStickerBrowserView类，这两个类的关系十分类似于UITableViewController与UITableView类的关系。MSStickerBrowserView是用于展示表情视图的容器，其继承自UIView，但却和UICollectionView十分类似，其中方法解析如下： 12345678910111213141516171819202122//初始化方法 设置frame 和其中表情视图的尺寸模式/*typedef NS_ENUM(NSInteger, MSStickerSize) &#123; //小尺寸 MSStickerSizeSmall, //标准尺寸 MSStickerSizeRegular, //大尺寸 MSStickerSizeLarge&#125; NS_ENUM_AVAILABLE_IOS(10_0);*/- (instancetype)initWithFrame:(CGRect)frame stickerSize:(MSStickerSize)stickerSize NS_DESIGNATED_INITIALIZER;//数据源代理@property (nonatomic, weak, nullable) id &lt;MSStickerBrowserViewDataSource&gt; dataSource;//当前的滑动位置@property (nonatomic, assign, readwrite) CGPoint contentOffset;//内容偏移尺寸@property (nonatomic, assign, readwrite) UIEdgeInsets contentInset;//设置当前的滑动位置- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;//刷新数据- (void)reloadData; MSStickerBrowserView的数据填充需要在代理方法中实现，如下： 1234//设置表情贴图个数- (NSInteger)numberOfStickersInStickerBrowserView:(MSStickerBrowserView *)stickerBrowserView;//设置具体每个位置的表情贴图- (MSSticker *)stickerBrowserView:(MSStickerBrowserView *)stickerBrowserView stickerAtIndex:(NSInteger)index; 再看MSStickerBrowserViewController就十分容易了，它只是将MSStickerBrowserView封装在了一个UIViewController中，并且这个UIViewController遵守了MSStickerBrowserViewDataSource协议，开发者直接实现协议方法即可。 四、开发Messages App中的建议下面是Apple对Messages App的定位和一些建议，还有我的一些理解： 1.确保应用是有用的并且易于理解。 2.功能要聚焦单一，不要组合多种功能在一起。 3.Messages通常用在双人非正式的交谈中，应从这里入手，让交流更加有趣。 4.Messages的最大两点是分享，利用这一点出发开发Messages App。 5.插图内容布局要注意，系统会自动将内容变为圆角，不要把重要的信息放在角落。 6.注意，在紧凑模式下，Messages App的界面是不允许水平滚动的。 7.同样，在紧凑模式下，Messages App不允许键盘输入。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"iOS文本布局探讨之三——使用TextKit框架进行富文本布局","slug":"254iOS文本布局探讨之三——使用TextKit框架进行富文本布局","date":"2016-09-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.351Z","comments":true,"path":"2016/09/10/254iOS文本布局探讨之三——使用TextKit框架进行富文本布局/","link":"","permalink":"http://huishao.cc/2016/09/10/254iOS文本布局探讨之三——使用TextKit框架进行富文本布局/","excerpt":"","text":"iOS文本布局探讨之三——使用TextKit框架进行富文本布局一、引言关于图文混排，其实以前的博客已经讨论很多，在实际开发中，经常使用第三方的框架来完成排版的需求，其中RCLabel和RTLabel是两个比较好用的第三方库，他们的实现都是基于UIView的，通过更底层的CoreText相关API来进行图文处理。相关介绍博客地址如下： iOS中支持HTML标签渲染的MDHTMLLaebl：http://my.oschina.net/u/2340880/blog/703254。 扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计：http://my.oschina.net/u/2340880/blog/499311。 iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展：http://my.oschina.net/u/2340880/blog/550194。 二、原生UILabel真的只能渲染文字么？CoreText是一个比较底层且十分强大的文本渲染框架，但是其使用起来并不是十分方便。在较低版本的iOS系统中，要进行富文本排版十分困难。在iOS6中，系统为UILabel，UITextView等这类文本渲染控件引入了NSAttributedString属性，有了NSAttributedString这个类，创建灵活多彩的文本控件变得十分轻松，开发者只需要配置NSAttributedString属性字符串即可。但是要进行图文混排，依然比较困难。iOS7之后引入TextKit框架，就完美的解决了图文混排这样的问题。 首先，iOS7中新添加了一类NSTextAttachment，从类名理解它是一个文本附件，其实也正是如此，NSTextAttachment类可以向文本中添加一些附件，这有些向邮件系统，寄信者可以向邮件中添加附件一同发送出去。NSTextAttachment类并不直接参与富文本的渲染与布局，渲染和布局依然由NSAttributedString类来完成，NSAttributedString类中提供了方法将NSTextAttachment所描述的内容转换为NSAttributedString示例。以一个简单的图文混排为例： 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; //进行NSTextAttachment的创建 NSTextAttachment * attach = [[NSTextAttachment alloc]init]; //设置显示的图片 attach.image =[UIImage imageNamed:@\"image\"]; //设置尺寸 attach.bounds = CGRectMake(0, 0, 120, 60); NSTextAttachment * attach2 = [[NSTextAttachment alloc]init]; attach2.image =[UIImage imageNamed:@\"image2\"]; attach2.bounds = CGRectMake(0, 0, 100, 90); //创建文本NSAttributedString对象 NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:@\"Describes a dictionary that fully specifies a font.... UIFontDescriptorInherits From NSObject UIFontDescriptor NSObject UIFontDescriptor Conforms To CVarArgT... 这里是中文\"]; //将NSTextAttachment映射为NSAttributedString对象 NSMutableAttributedString * att = [[NSMutableAttributedString alloc]initWithAttributedString:[NSAttributedString attributedStringWithAttachment:attach]]; //将图片插入NSAttributedString中 [attri insertAttributedString:att atIndex:15]; [attri insertAttributedString:[NSAttributedString attributedStringWithAttachment:attach2] atIndex:130]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(20, 20, 280, 540)]; label.backgroundColor = [UIColor grayColor]; label.numberOfLines = 0; label.attributedText = attri; [self.view addSubview:label];&#125; 运行工程后，效果如下图所示，其实只使用UILabel也可以实现复杂的富文本和图文混排： 三、为富文本附件添加用户交互能力TextKit框架强大到只使用UILabel就可以完成复杂的富文本布局，但是UILabel有一个致命的缺陷，其无法进行用户交互。试想，如果可以向一段文本中添加任意数据类型的文件，当用户点击这个文件时，可以获取到文件数据并进行业务逻辑处理，这将十分酷。这样富文本布局其实就不只局限于图文混排了，我们可以插入音频，插入视频，甚至插入任意自定义格式的数据。结合使用NSTextAttachment与UITextView，这些都能实现。先看NSTextAttachment类中的一些常用属性与方法： 1234567891011121314//这个初始化方法用于创建携带任意数据的文本附件- (instancetype)initWithData:(nullable NSData *)contentData ofType:(nullable NSString *)uti NS_DESIGNATED_INITIALIZER NS_AVAILABLE(10_11, 7_0);//携带的数据内容@property(nullable, copy, NS_NONATOMIC_IOSONLY) NSData *contents NS_AVAILABLE(10_11, 7_0);//数据类型@property(nullable, copy, NS_NONATOMIC_IOSONLY) NSString *fileType NS_AVAILABLE(10_11, 7_0);//设置渲染的图片 需要注意 如果设置的这个 附件携带的数据 fileWrapper目录内容将无效@property(nullable, strong, NS_NONATOMIC_IOSONLY) UIImage *image NS_AVAILABLE(10_11, 7_0);//设置图片渲染的尺寸@property(NS_NONATOMIC_IOSONLY) CGRect bounds NS_AVAILABLE(10_11, 7_0);//设置附件携带的文件目录 需要注意 如果设置了这个属性 image和data将无效@property(nullable, strong, NS_NONATOMIC_IOSONLY) NSFileWrapper *fileWrapper; 结合UITextView可以为NSAttributedString属性字符串添加超链接，在代码回调中监听此超链接的回调可以获取NSTextAttachment携带的附件内容，如此就可以自由的进行业务处理了，示例代码如下： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; //保留一个数组存放附件 _attArray = [NSMutableArray array]; //创建附件数据 NSData * stringData = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"image3\" ofType:@\"gif\"]]; NSTextAttachment * attach = [[NSTextAttachment alloc]initWithData:stringData ofType:@\"gif\"]; [_attArray addObject:attach]; attach.bounds = CGRectMake(0, 0, 30, 40); NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:@\"Describes a dictionary that fully specifies a font.... UIFontDescriptorInherits From NSObject UIFontDescriptor NSObject UIFontDescriptor Conforms To CVarArgT... 这里是中文\"]; NSMutableAttributedString * att = [[NSMutableAttributedString alloc]initWithAttributedString:[NSAttributedString attributedStringWithAttachment:attach]]; //为NSTextAttachment转换为的NSAttributedString添加超链接 [att addAttributes:@&#123;NSLinkAttributeName:@\"url...\"&#125; range:NSMakeRange(0, att.string.length)]; [attri insertAttributedString:att atIndex:15]; UITextView * textView = [[UITextView alloc]initWithFrame:CGRectMake(20, 20, 280, 540)]; textView.backgroundColor = [UIColor grayColor]; textView.dataDetectorTypes = UIDataDetectorTypeLink; textView.delegate =self; textView.attributedText = attri; textView.editable = NO; [self.view addSubview:textView];&#125; 实现如下的TextView代理方法： 12345678-(BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange&#123; //可以获取到url 进行匹配 NSLog(@\"%@\",URL); //取出NSTextAttachment附件 NSTextAttachment * attach =_attArray.firstObject; NSLog(@\"%@--\",attach.contents); return YES;&#125; 向文本中添加任意数据的NSTextAttachment会展现一个文件的图标，如下图所示： 当用户点击文件图标时，会将携带的gif文件数据进行打印。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS文本布局探讨之二——关于TextKit框架中的字体描述","slug":"253iOS文本布局探讨之二——关于TextKit框架中的字体描述","date":"2016-09-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.351Z","comments":true,"path":"2016/09/09/253iOS文本布局探讨之二——关于TextKit框架中的字体描述/","link":"","permalink":"http://huishao.cc/2016/09/09/253iOS文本布局探讨之二——关于TextKit框架中的字体描述/","excerpt":"","text":"iOS文本布局探讨之二——关于TextKit框架中的字体描述一、引言UIFont是iOS开发中处理文本字体的类，关于UIFont的相关内容，以前的一篇博客有详细介绍，本片博客主要介绍关于动态字体的应用与字体描述类NSFontDescriptor的应用。 UIFont应用介绍：http://my.oschina.net/u/2340880/blog/397115。 二、iOS系统中的动态字体所谓动态字体，是指在应用使用中，用户可以动态调整字体的风格字号等。在iOS7及之后的iOS系统版本，TextKit框架中提供了一个新的类UIFontDescriptor。简单理解，UIFontDescriptor类是专门用来描述字体的，其中提供了许多方法可以直接创建出某种字体，也可以对字体进行设置和调整。动态字体也由这个类来创建。 在iOS7之后，系统增加了动态字体的功能，当用户在系统设置中修改字体的属性或者字号时，不仅会影响系统应用的字体，第三方应用的字体也可以进行相应调整。系统设置字体界面如下： 使用UIFontDescriptor类中的如下方法可以创建动态字体： 12//创建动态字体的字体描述类实例+ (UIFontDescriptor *)preferredFontDescriptorWithTextStyle:(NSString *)style; UIFont类中的如下方法可以将字体描述类转换成UIFont字体： 1+ (UIFont *)fontWithDescriptor:(UIFontDescriptor *)descriptor size:(CGFloat)pointSize NS_AVAILABLE_IOS(7_0); 系统定义了一组动态字体的风格字符创常量，开发者可以根据需求选用： 1234567891011121314151617181920//标题1UIKIT_EXTERN NSString *const UIFontTextStyleTitle1 NS_AVAILABLE_IOS(9_0);//标题2UIKIT_EXTERN NSString *const UIFontTextStyleTitle2 NS_AVAILABLE_IOS(9_0);//标题3UIKIT_EXTERN NSString *const UIFontTextStyleTitle3 NS_AVAILABLE_IOS(9_0);//大标题UIKIT_EXTERN NSString *const UIFontTextStyleHeadline NS_AVAILABLE_IOS(7_0);//子标题UIKIT_EXTERN NSString *const UIFontTextStyleSubheadline NS_AVAILABLE_IOS(7_0);//内容UIKIT_EXTERN NSString *const UIFontTextStyleBody NS_AVAILABLE_IOS(7_0);//标注UIKIT_EXTERN NSString *const UIFontTextStyleCallout NS_AVAILABLE_IOS(9_0);//注脚UIKIT_EXTERN NSString *const UIFontTextStyleFootnote NS_AVAILABLE_IOS(7_0);//字幕UIKIT_EXTERN NSString *const UIFontTextStyleCaption1 NS_AVAILABLE_IOS(7_0);//字幕2UIKIT_EXTERN NSString *const UIFontTextStyleCaption2 NS_AVAILABLE_IOS(7_0); 三、关于UIFontDescriptor类UIFontDescriptor类可以直接通过字体名称来进行创建： 1234//通过字体名称和字号尺寸来进行UIFontDescriptor对象的创建+ (UIFontDescriptor *)fontDescriptorWithName:(NSString *)fontName size:(CGFloat)size;//通过字体名称创建UIFontDescriptor对象，并且设置变换参数+ (UIFontDescriptor *)fontDescriptorWithName:(NSString *)fontName matrix:(CGAffineTransform)matrix; CGAffineTransform是一个结构体，其用于文本的控件变换十分强大，在CoreAnimation框架中有CATransform3D这个结构体，CGAffineTransform与其用法十分相似，使其它可以完成文字的形变，旋转等。示例如下： 123456789101112//进行旋转CGAffineTransform transfom = CGAffineTransformRotate(CGAffineTransformIdentity, 0.1);//进行纵向拉伸transfom = CGAffineTransformScale(transfom, 1, 3);UIFontDescriptor * fontDes = [UIFontDescriptor fontDescriptorWithName:[UIFont systemFontOfSize:14].fontName matrix:transfom];UIFont * font = [UIFont fontWithDescriptor:fontDes size:14];UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 280, 400)];label.backgroundColor = [UIColor grayColor];label.font = font;label.numberOfLines = 0;label.text = @\"Describes a dictionary that fully specifies a font.... UIFontDescriptorInherits From NSObject UIFontDescriptor NSObject UIFontDescriptor Conforms To CVarArgT... 这里是中文\";[self.view addSubview:label]; 效果如下： 开发者也可以通过配置地点的方式来创建UIFontDescriptor对象： 1- (instancetype)initWithFontAttributes:(NSDictionary&lt;NSString *, id&gt; *)attributes; 字典中可以配置的键值如下： 12345678910111213141516171819//需要配置为NSValue值 CGAffineTransformUIKIT_EXTERN NSString *const UIFontDescriptorMatrixAttribute;//需要配置为一个集合set 包含所有字体字符UIKIT_EXTERN NSString *const UIFontDescriptorCharacterSetAttribute;//需要配置为一个数组 数组中为字体描述对象UIKIT_EXTERN NSString *const UIFontDescriptorCascadeListAttribute;//需要配置为一个字典 其中进行字体特征的描述 后面会介绍UIKIT_EXTERN NSString *const UIFontDescriptorTraitsAttribute;//需要配置为NSNumber类型的 浮点数 其会影响到字体排版时的字符间距UIKIT_EXTERN NSString *const UIFontDescriptorFixedAdvanceAttribute;//需要配置为一个数组 数组中为字典 字典中对字型进行配置/*//字典中需要配置这两个键UIKIT_EXTERN NSString *const UIFontFeatureTypeIdentifierKey NS_AVAILABLE_IOS(7_0);UIKIT_EXTERN NSString *const UIFontFeatureSelectorIdentifierKey NS_AVAILABLE_IOS(7_0);*/UIKIT_EXTERN NSString *const UIFontDescriptorFeatureSettingsAttribute;//配置字体风格 可用的在前面列举过UIKIT_EXTERN NSString *const UIFontDescriptorTextStyleAttribute; 关于字体的特征藐视，即上面UIFontDescriptorTraitsAttribute键值所配置的字典，这个字典中可以设置的键值如下： 1234567891011121314151617181920//这个键值需要配置为一个NSNumber值，设置文字的渲染特征 后面会介绍UIKIT_EXTERN NSString *const UIFontSymbolicTrait;//设置字体的粗细属性 /*这个键可以设置的值如下UIKIT_EXTERN const CGFloat UIFontWeightUltraLight NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightThin NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightLight NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightRegular NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightMedium NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightSemibold NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightBold NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightHeavy NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightBlack NS_AVAILABLE_IOS(8_2);*/UIKIT_EXTERN NSString *const UIFontWeightTrait;//设置字体宽度UIKIT_EXTERN NSString *const UIFontWidthTrait;//设置字体倾斜UIKIT_EXTERN NSString *const UIFontSlantTrait; 关于上面UIFontSymbolicTrait键值，定义在UIFontDescriptorSymbolicTraits枚举中，如下： 12345678910111213141516171819202122232425typedef NS_OPTIONS(uint32_t, UIFontDescriptorSymbolicTraits) &#123; UIFontDescriptorTraitItalic = 1u &lt;&lt; 0, UIFontDescriptorTraitBold = 1u &lt;&lt; 1, UIFontDescriptorTraitExpanded = 1u &lt;&lt; 5, UIFontDescriptorTraitCondensed = 1u &lt;&lt; 6, UIFontDescriptorTraitMonoSpace = 1u &lt;&lt; 10, UIFontDescriptorTraitVertical = 1u &lt;&lt; 11, UIFontDescriptorTraitUIOptimized = 1u &lt;&lt; 12, UIFontDescriptorTraitTightLeading = 1u &lt;&lt; 15, UIFontDescriptorTraitLooseLeading = 1u &lt;&lt; 16, UIFontDescriptorClassMask = 0xF0000000, UIFontDescriptorClassUnknown = 0u &lt;&lt; 28, UIFontDescriptorClassOldStyleSerifs = 1u &lt;&lt; 28, UIFontDescriptorClassTransitionalSerifs = 2u &lt;&lt; 28, UIFontDescriptorClassModernSerifs = 3u &lt;&lt; 28, UIFontDescriptorClassClarendonSerifs = 4u &lt;&lt; 28, UIFontDescriptorClassSlabSerifs = 5u &lt;&lt; 28, UIFontDescriptorClassFreeformSerifs = 7u &lt;&lt; 28, UIFontDescriptorClassSansSerif = 8u &lt;&lt; 28, UIFontDescriptorClassOrnamentals = 9u &lt;&lt; 28, UIFontDescriptorClassScripts = 10u &lt;&lt; 28, UIFontDescriptorClassSymbolic = 12u &lt;&lt; 28&#125; NS_ENUM_AVAILABLE_IOS(7_0); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS文本布局探讨之一——文本布局框架TextKit浅析","slug":"252iOS文本布局探讨之一——文本布局框架TextKit浅析","date":"2016-09-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.351Z","comments":true,"path":"2016/09/08/252iOS文本布局探讨之一——文本布局框架TextKit浅析/","link":"","permalink":"http://huishao.cc/2016/09/08/252iOS文本布局探讨之一——文本布局框架TextKit浅析/","excerpt":"","text":"iOS文本布局探讨之一——文本布局框架TextKit浅析一、引言在iOS开发中，处理文本的视图控件主要有4中，UILabel，UITextField，UITextView和UIWebView。其中UILabel与UITextField相对简单，UITextView是功能完备的文本布局展示类，通过它可以进行复杂的富文本布局，UIWebView主要用来加载网页或者pdf文件，其可以进行HTML,CSS和JS等文件的解析。 TextKit是一个偏上层的开发框架，在iOS7以上可用，使用它开发者可以方便灵活处理复杂的文本布局，满足开发中对文本布局的各种复杂需求。TextKit实际上是基于CoreText的一个上层框架，其是面向对象的，如果TextKit中提供的API无法满足需求，可以使用CoreText中的API进行更底层的开发。 官方文档中的一张图片很确切，经常会被用来描述TextKit框架在iOS系统文本渲染中所处的位置。 二、TextKit框架的结构界面在进行文本的渲染时，有下面几个必要条件： 1.要渲染展示的内容。 2.将内容渲染在某个视图上。 3.内容渲染在视图上的尺寸位置和形状。 在TextKit框架中，提供了几个类分别对应处理上述的必要条件： 1.NSTextStorage对应要渲染展示的内容。 2.UITextView对应要渲染的视图。 3.NSTextContainer对应渲染的尺寸位置和形状信息。 除了上述3个类之外，TextKit框架中的NSLayoutManager类作为协调者来进行布局操作。 上述关系如下图所示： 三、使用TextKit进行文本布局流程个人理解，TextKit主要用于更精细的处理文本布局以及进行复杂的图文混排布局，使用TextKit进行文本的布局展示十分繁琐，首先需要将显示内容定义为一个NSTextStorage对象，之后为其添加一个布局管理器对象NSLayoutManager，在NSLayoutManager中，需要进行NSTextContainer的定义，定义多了NSTextContainer对象则会将文本进行分页。最后，将要展示的NSTextContainer绑定到具体的UITextView视图上。 示例代码如下： 12345678910111213//定义ContainerNSTextContainer * container = [[NSTextContainer alloc]initWithSize:CGSizeMake(150, 200)];//定义布局管理类NSLayoutManager * layoutManager = [[NSLayoutManager alloc]init];//将container添加进布局管理类管理[layoutManager addTextContainer:container];//定义一个StorageNSTextStorage * storage = [[NSTextStorage alloc]initWithString:@\"The NSTextContainer class defines a region where text is laid out. An NSLayoutManager uses NSTextContainer to determine where to break lines, lay out portions of text, and so on.\"];//为Storage添加一个布局管理器[storage addLayoutManager:layoutManager];//将要显示的container与视图TextView绑定UITextView * textView = [[UITextView alloc]initWithFrame:self.view.frame textContainer:container];[self.view addSubview:textView]; 上面代码演示的过程如下图所示： 需要注意，TextKit进行布局的核心思路是最终的视图对应一个文本块Container，并不是一段文本内容Storage，LayoutManager会将完整的内容根据其中Container的尺寸进行分页，TextView根据需要显示的部分进行Container的选择。 四、了解NSTextContainer类NSTextContainer可以简单理解为创建一个文本区块，文本内容将在这个区块中进行渲染，其中常用属性与方法如下： 1234567891011121314151617181920212223//初始化方法 设置区块的尺寸- (instancetype)initWithSize:(CGSize)size;//与其绑定的layoutManager 需要注意，不是设置这个属性 使用[NSLayoutManager addTextContainer:]方式来进行绑定@property(nullable, assign, NS_NONATOMIC_IOSONLY) NSLayoutManager *layoutManager;//替换绑定的布局管理类对象- (void)replaceLayoutManager:(NSLayoutManager *)newLayoutManager;//获取区块尺寸@property(NS_NONATOMIC_IOSONLY) CGSize size;//设置从区块中剔除某一区域@property(copy, NS_NONATOMIC_IOSONLY) NSArray&lt;UIBezierPath *&gt; *exclusionPaths;//设置截断模式 需要注意 这个属性的设置只是会影响此区块的最后一行的截断模式@property(NS_NONATOMIC_IOSONLY) NSLineBreakMode lineBreakMode;//设置每行文本左右空出的间距@property(NS_NONATOMIC_IOSONLY) CGFloat lineFragmentPadding;//设置TextView上可输入的文本最大行数@property(NS_NONATOMIC_IOSONLY) NSUInteger maximumNumberOfLines;//这个方法用于提供给子类进行重写 这里返回的Rect是可以布局文本的区域- (CGRect)lineFragmentRectForProposedRect:(CGRect)proposedRect atIndex:(NSUInteger)characterIndex writingDirection:(NSWritingDirection)baseWritingDirection remainingRect:(nullable CGRect *)remainingRect;//这个BOOL值的属性决定Container的宽度是否自适应TextView的宽度@property(NS_NONATOMIC_IOSONLY) BOOL widthTracksTextView;//这个BOOL值的属性决定Container的高度是否自适应TextView的高度@property(NS_NONATOMIC_IOSONLY) BOOL heightTracksTextView; 上面所列举的方法中，exclusionPaths属性十分强大，通过设置它，可以将布局区域内剔出一块区域不进行布局，示例代码如下： 123456789101112[super viewDidLoad]; NSTextContainer * container = [[NSTextContainer alloc]initWithSize:CGSizeMake(300, 500)]; UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:self.view.center radius:70 startAngle:0 endAngle:M_PI*2 clockwise:YES]; container.exclusionPaths = @[path]; container.lineBreakMode = NSLineBreakByCharWrapping; NSLayoutManager * layoutManager = [[NSLayoutManager alloc]init]; [layoutManager addTextContainer:container]; NSTextStorage * storage = [[NSTextStorage alloc]initWithString:@\"The NSTextContainer class defines a region where text is laid out. An NSLayoutManager uses NSTextContainer to determine where to break lines, lay out portions of text, and so on. An NSTextContainer object normally defines rectangular regions, but you can define exclusion paths inside the text container to create regions where text does not flow. You can also subclass to create text containers with nonrectangular regions, such as circular regions, regions with holes in them, or regions that flow alongside graphics.The NSTextContainer class defines a region where text is laid out. An NSLayoutManager uses NSTextContainer to determine where to break lines, lay out portions of text, and so on. An NSTextContainer object normally defines rectangular regions, but you can define exclusion paths inside the text container to create regions where text does not flow. You can also subclass to create text containers with nonrectangular regions, such as circular regions, regions with holes in them, or regions that flow alongside graphics.An NSLayoutManager uses NSTextContainer to determine where to break lines, lay out portions of text, and so on. An NSTextContainer object normally defines rectangular regions, but you can define exclusion paths inside the text container to create regions where text does not flow. You can also subclass to create text containers with nonrectangular regions, such as circular regions, regions with holes in them, or regions that flow alongside graphics.\"]; [storage addLayoutManager:layoutManager]; UITextView * textView = [[UITextView alloc]initWithFrame:self.view.frame textContainer:container]; [self.view addSubview:textView]; 效果如下图： 五、关于NSLayoutManager顾名思义，NSLayoutManager专门负责对文本的布局渲染，简单理解，其从NSTextStorage从拿去展示的内容，将去处理后布局到NSTextContainer中。 NSLayoutManager与NSTextContainer的关系为一对多，放入NSLayoutManager中的NSTextContainer会以有序数组的形式进行管理，在内容布局时，超出第一个NSTextContainer的内容会被布局到后一个NSTextContainer中。 NSLayoutManager中有关NSTextContainer操作的方法如下： 12345678910//container数组@property(readonly, NS_NONATOMIC_IOSONLY) NSArray&lt;NSTextContainer *&gt; *textContainers;//添加一个container- (void)addTextContainer:(NSTextContainer *)container;//在指定位置插入一个container- (void)insertTextContainer:(NSTextContainer *)container atIndex:(NSUInteger)index;//删除一个指定的container- (void)removeTextContainerAtIndex:(NSUInteger)index;//注意 这个方法不需要显式的调用 当布局Container发生变化时 系统会自动调用- (void)textContainerChangedGeometry:(NSTextContainer *)container; 与布局管理相关的属性与方法如下： 12345678910111213141516171819202122232425//是否显示隐形的符号/*默认为NO，如果设置为YES，则会将空格等隐形字符显示出来*/@property(NS_NONATOMIC_IOSONLY) BOOL showsInvisibleCharacters;//是否显示某些布局控制字符@property(NS_NONATOMIC_IOSONLY) BOOL showsControlCharacters;//这个属性可以用于设置断字/*这个属性的取值为0到1之间 默认为0 即单词换行时从来不会中断 越接近1 则使用连字符进行单词换行中断的概率越大*/@property(NS_NONATOMIC_IOSONLY) CGFloat hyphenationFactor;//是否使用字体定义的行距/*默认使用字体所定义的行距信息 通过设置这个属性为NO可以关闭此功能*/@property(NS_NONATOMIC_IOSONLY) BOOL usesFontLeading;//这个属性设置是否允许对相邻位置的内容进行布局 默认为YES，设置为NO后将可以提供大文本布局的效率@property(NS_NONATOMIC_IOSONLY) BOOL allowsNonContiguousLayout;//下面这几个方法用于移除某一范围内的布局- (void)invalidateGlyphsForCharacterRange:(NSRange)charRange changeInLength:(NSInteger)delta actualCharacterRange:(nullable NSRangePointer)actualCharRange;- (void)invalidateLayoutForCharacterRange:(NSRange)charRange actualCharacterRange:(nullable NSRangePointer)actualCharRange NS_AVAILABLE(10_5, 7_0);- (void)invalidateDisplayForCharacterRange:(NSRange)charRange;- (void)invalidateDisplayForGlyphRange:(NSRange)glyphRange; 六、文本内容类NSTextStorageNSTextStorage实际上是继承自NSMutableAttributedString。NSAttributedString是一种自带属性的字符串类，关于NSAttributedString的基本用法，如下博客中有介绍： http://my.oschina.net/u/2340880/blog/397500。 TextKit框架中在对文本进行布局时，主要关注于3个方面： 1.字符的属性，例如颜色，字体等。 2.行与段落的属性，如缩进，行间距等。 3.文档属性，包括四周边距、文档尺寸等。 这些都由NSAttributedString来进行定义。 如上所介绍的是TextKit框架的主要工作原理，文字渲染，图文混排的更多内容，后面博客会继续探讨。有疏漏之处，共同讨论进步。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Android开发中RelativeLayout相对布局","slug":"251Android开发中RelativeLayout相对布局","date":"2016-09-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.350Z","comments":true,"path":"2016/09/06/251Android开发中RelativeLayout相对布局/","link":"","permalink":"http://huishao.cc/2016/09/06/251Android开发中RelativeLayout相对布局/","excerpt":"","text":"Android开发中RelativeLayout相对布局RelativeLayout布局是Android界面布局中应用最广也最强大的一种布局，其不仅十分灵活，可以解决开发中各种界面布局需求，同时也很方便了解决了多屏幕尺寸的适配问题。在iOS开发中，Autolayout技术总是被赞不绝口，RelativeLayout布局就是Andriod系统中的Autolayout，其又被称为相对布局。 所谓相对布局，是指其坐标的确定并不是开发者写死的，而是有系统自动计算出来的，那么系统如何计算每个视图控件的位置呢？开发者需要为其添加一些规则进行约束，这些规则大致包括2类： 第1类 与父视图之间位置关系的规则： 此类规则包括在父视图中的居中、左对齐、右对齐、上对齐、下对齐等。 第2类 平级视图之间相对位置关系的规则： 此类规则包括同级视图间对其关系，相对位置关系，例如A在B左侧20像素位置，B与C上边缘对齐等。 使用RelativeLayout进行布局示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); RelativeLayout relativeLayout = new RelativeLayout(this); Button button1 = new Button(this); button1.setText(\"按钮一\"); button1.setId(R.id.button1); RelativeLayout.LayoutParams layoutParams1 = new RelativeLayout.LayoutParams(200,200); //添加约束 使其靠近父视图右上角 layoutParams1.addRule(RelativeLayout.ALIGN_PARENT_TOP); layoutParams1.addRule(RelativeLayout.ALIGN_PARENT_RIGHT); button1.setLayoutParams(layoutParams1); Button button2 = new Button(this); button2.setText(\"按钮二\"); button2.setId(R.id.button2); RelativeLayout.LayoutParams layoutParams2 = new RelativeLayout.LayoutParams(200,200); //添加约束 让其右侧靠近按钮一左侧 上侧靠近按钮一下侧 layoutParams2.addRule(RelativeLayout.BELOW,R.id.button1); layoutParams2.addRule(RelativeLayout.LEFT_OF,R.id.button1); button2.setLayoutParams(layoutParams2); Button button3 = new Button(this); button3.setText(\"按钮三\"); button3.setId(R.id.button3); RelativeLayout.LayoutParams layoutParams3 = new RelativeLayout.LayoutParams(200,200); //添加约束 让其固定距离按钮二 下方100px 左侧边缘对其 layoutParams3.addRule(RelativeLayout.ALIGN_LEFT,R.id.button2); layoutParams3.addRule(RelativeLayout.BELOW,R.id.button2); layoutParams3.topMargin = 100; button3.setLayoutParams(layoutParams3); relativeLayout.addView(button1); relativeLayout.addView(button2); relativeLayout.addView(button3); setContentView(relativeLayout);&#125; 小提示：使用代码创建的视图，可以通过xml文件配置id，如下： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;item name=\"button1\" type=\"id\"&gt;&lt;/item&gt; &lt;item name=\"button2\" type=\"id\"&gt;&lt;/item&gt; &lt;item name=\"button3\" type=\"id\"&gt;&lt;/item&gt;&lt;/resources&gt; 效果如下图： RelativeLayout布局中视图位置的配置主要使用其内部类LayoutParams，这个内部类LayoutParams是继承自MarginLayoutParams。其中常用方法和属性列举如下： 123456789101112131415//设置左边距public int leftMargin;//设置上边距public int topMargin;//设置右边距public int rightMargin;//设置下边距public int bottomMargin;//添加一个规则 这个方法添加的规则不需要参照视图 例如靠近父视图边缘public void addRule(int verb)//添加一个规则 这个方法添加的规则需要一个参照视图 例如某两个平级视图间的位置关系 anchor参数为视图idpublic void addRule(int verb, int anchor) //移除一个布局规则public void removeRule(int verb) 用于进行布局规则配置的参数如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*=======需要使用addRule(int verb, int anchor)方法添加的约束规则==========*///将当前视图约束到某个视图左边public static final int LEFT_OF//将当前视图约束到某个视图右边public static final int RIGHT_OF//将当前视图约束到某个视图上边public static final int ABOVE//将当前视图约束到某个视图下边public static final int BELOW//将当前视图约束与某个视图基线对齐public static final int ALIGN_BASELINE//将当前视图约束与某个视图左侧对齐public static final int ALIGN_LEFT//将当前视图约束与某个视图上侧对齐public static final int ALIGN_TOP//将当前视图约束与某个视图右侧对齐public static final int ALIGN_RIGHT//将当前视图约束与某个视图下侧对齐public static final int ALIGN_BOTTOM//将当前视图约束与某个视图起始对齐public static final int START_OF//当当前视图约束与某个视图末尾对齐public static final int END_OF/*========需要使用addRule(int verb)方法添加的约束规则====================*///约束当前视图与父视图左侧对齐public static final int ALIGN_PARENT_LEFT//约束当前视图与父视图上侧对齐public static final int ALIGN_PARENT_TOP//约束当前视图与父视图上侧对齐public static final int ALIGN_PARENT_RIGHT//约束当前视图与父视图下侧对齐public static final int ALIGN_PARENT_BOTTOM//约束当前视图与父视图居中对齐public static final int CENTER_IN_PARENT//约束当前视图与父视图水平居中public static final int CENTER_HORIZONTAL//约束当前视图与父视图垂直居中public static final int CENTER_VERTICAL//约束当前视图与父视图起始对齐public static final int ALIGN_PARENT_START//约束当前视图与父视图末尾对齐public static final int ALIGN_PARENT_END 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发中TableLayout表格布局","slug":"250Android开发中TableLayout表格布局","date":"2016-09-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.350Z","comments":true,"path":"2016/09/05/250Android开发中TableLayout表格布局/","link":"","permalink":"http://huishao.cc/2016/09/05/250Android开发中TableLayout表格布局/","excerpt":"","text":"Android开发中TableLayout表格布局一、引言在移动端应用程序开发中，常常会使用到表格布局，iOS和Android开发框架中都提供了独立的表格视图控件供开发者使用，例如iOS中的UITableView、UICollectionView，Android中的ListView、GridView等。除了独立的视图控件外，Android中还提供了一个布局容器类TableLayout，使用其也可以进行方便的表格布局。 前边博客有介绍过关于LinearLayout线性布局的相关内容，LinearLayout只能进行水平或者垂直方向上的排列布局，使用LinearLayout的布局嵌套，实际上也可以实现表格布局的样式。实际上，TableLayout就是采用这样的原理，TableLayout继承于LinearLayout，其中每个视图元素作为一行，同时Android中还提供了一个TableRow类，这个类同样继承自LinearLayout，其中每个视图元素作为当前行中的一列，结合使用TableLayout与TableRow，就实现了行列的表格布局。 二、关于TableRowTableRow可以简单理解为TableLayout布局中的一行，当然，TableLayout中也可以直接添加任意的View视图，但是默认添加的View视图将独占一行。TableRow中可以添加其他视图，每个视图被作为一列处理，通过TableRow的内部类LayoutParams来设置TableRow内部视图的布局方式，其中主要可以通过设置宽高或者设置权重来定制每列视图元素的尺寸，例如： 123456789101112131415161718192021222324252627282930TableLayout tableLayout = new TableLayout(this);//创建行 第一行用单个元素TextView textView = new TextView(this);textView.setText(\"1000\");textView.setTextSize(20);textView.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);tableLayout.addView(textView);//第二行使用TableRowTableRow tableRow1 = new TableRow(this);//设置本行中每一列的权重和tableRow1.setWeightSum(10);Button button11 = new Button(this);button11.setText(\"AC\");//设置固定宽高TableRow.LayoutParams layoutParams1 = new TableRow.LayoutParams(300,200);button11.setLayoutParams(layoutParams1);tableRow1.addView(button11);Button button12 = new Button(this);//通过权重设置列的宽度 占正常列宽的一半TableRow.LayoutParams layoutParams2 = new TableRow.LayoutParams(0,200,5);button12.setLayoutParams(layoutParams2);button12.setText(\"+/-\");tableRow1.addView(button12);Button button13 = new Button(this);button13.setText(\"%\");tableRow1.addView(button13);Button button14 = new Button(this);button14.setText(\"÷\");tableRow1.addView(button14);tableLayout.addView(tableRow1); 上面代码向TableRow中添加了4个视图，默认情况下会生成四列，setWeightSum()方法用于设置每列的权重和，需要注意，它作用的对象是每一列元素，而不是整行。上面的代码效果如下： 默认的列宽是评分整个行宽，可以通过指定宽度或者权重来修改特定列的列宽。 还有一点需要注意，如果一个TableLayout布局中多个TableRow，则表格的列数会以最多列的一行为准，例如在添加一行TableRow，而其中只有一列，则其依然会预留4列的位置，示例如下： 12345TableRow tableRow2 = new TableRow(this);Button button = new Button(this);button.setText(\"跳过\");tableRow2.addView(button);tableLayout.addView(tableRow2); 效果如下： 也可以设置跳过某列进行布局，或者进行列的合并，示例如下： 1234567891011TableRow tableRow2 = new TableRow(this);Button button = new Button(this);button.setText(\"跳过\");TableRow.LayoutParams layoutParams21 = new TableRow.LayoutParams();//从第2列开始layoutParams21.column = 1;//合并3列layoutParams21.span = 3;button.setLayoutParams(layoutParams21);tableRow2.addView(button);tableLayout.addView(tableRow2); 三、关于TableLayout在向TableLayout容器中添加或者移除视图的时候，开发者可以对其进行监听，示例如下： 123456789101112TableLayout tableLayout = new TableLayout(this);tableLayout.setOnHierarchyChangeListener(new ViewGroup.OnHierarchyChangeListener() &#123; @Override public void onChildViewAdded(View parent, View child) &#123; Toast.makeText(getBaseContext(),\"add\",Toast.LENGTH_SHORT).show(); &#125; @Override public void onChildViewRemoved(View parent, View child) &#123; Toast.makeText(getBaseContext(),\"remove\",Toast.LENGTH_SHORT).show(); &#125;&#125;); 开发者还可以对表格中视图元素的一些尺寸自适应做一些设置，其中还有一些常用的方法列举如下： 12345678910111213141516//获取表格中所有列是否是可收缩的public boolean isShrinkAllColumns()//设置表格中的所有列是否可收缩public void setShrinkAllColumns()//获取表格中的所有列是否可拉伸public boolean isStretchAllColumns()//设置表格中的所有列是否可拉伸public void setStretchAllColumns()//设置某一列是否可拉伸public void setColumnStretchable(int columnIndex, boolean isStretchable)//获取某一列是否可拉伸public boolean isColumnStretchable(int columnIndex)//设置某一列是否可收缩public void setColumnShrinkable(int columnIndex, boolean isShrinkable)//获取某一列是否可收缩public boolean isColumnShrinkable(int columnIndex) 所谓可收缩的列，是指如果此列的内容宽度超出一定宽度，为了使后面的列内容展示出来，此列宽度会自动收缩，高度会增加，如下图所示： 至于可拉伸的列，是指如果此行内容内有充满整行，此列会进行拉伸自动充满。 下面这些方法与表格中列的隐藏有关： 1234//设置某列是否隐藏public void setColumnCollapsed(int columnIndex, boolean isCollapsed)//获取某列是否被隐藏public boolean isColumnCollapsed(int columnIndex) 需要注意，在TableLayout中也定义了一个LayoutParams的内部类，其用于设置其中每一行视图元素的布局，但是开发者只能设置此布局类对应的高度参数，宽度将强制设置为MATCH_PARENT。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发之AbsoluteLayout绝对布局","slug":"249Android开发之AbsoluteLayout绝对布局","date":"2016-09-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.350Z","comments":true,"path":"2016/09/02/249Android开发之AbsoluteLayout绝对布局/","link":"","permalink":"http://huishao.cc/2016/09/02/249Android开发之AbsoluteLayout绝对布局/","excerpt":"","text":"Android开发之AbsoluteLayout绝对布局AbsoluteLayout绝对布局已经被弃用，但是相关API依然有效，其又被称为坐标布局，在iOS开发支持Autolayout之前，所有的布局模式都可以理解为绝对布局。但是iPhone设备的屏幕尺寸有限，使用绝对不觉并不会出现太多难以解决的问题，但是对于Android设备就不同了，Android设备的屏幕尺寸和分辨率都无规范，使用坐标绝对布局的缺陷就十分明显。 AbsoluteLayout直接通过定位其内部视图的位置坐标点和尺寸来进行布局，后添加的视图优先级更高，如果坐标有重合，会覆盖先添加的视图，示例代码如下： 123456789101112131415161718192021222324252627282930313233@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); AbsoluteLayout absoluteLayout = new AbsoluteLayout(this); absoluteLayout.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); setContentView(absoluteLayout); //添加4个TextView TextView textView1 = new TextView(this); textView1.setText(\"第1个textView\"); //需要注意 这里的LayoutParams()构造方法中的参数 前两个参数为视图的宽和高 后两个为x与y位置坐标点 textView1.setLayoutParams(new AbsoluteLayout.LayoutParams(800,300,10,10)); textView1.setBackgroundColor(Color.RED); absoluteLayout.addView(textView1); TextView textView2 = new TextView(this); textView2.setText(\"第2个textView\"); textView2.setLayoutParams(new AbsoluteLayout.LayoutParams(800,300,100,200)); textView2.setBackgroundColor(Color.YELLOW); absoluteLayout.addView(textView2); TextView textView3 = new TextView(this); textView3.setText(\"第3个textView\"); textView3.setLayoutParams(new AbsoluteLayout.LayoutParams(800,300,200,400)); textView3.setBackgroundColor(Color.BLUE); absoluteLayout.addView(textView3); TextView textView4 = new TextView(this); textView4.setText(\"第4个textView\"); textView4.setLayoutParams(new AbsoluteLayout.LayoutParams(800,300,300,600)); textView4.setBackgroundColor(Color.GREEN); absoluteLayout.addView(textView4);&#125; 布局效果如下图： 其实布局容器中子视图的布局参数主要有定义在各个布局容器类的内部类LayoutParams来设置。需要注意，在不同分辨率的屏幕上，使用AbsoluteLayout布局效果可能会难于把控。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发之FrameLayout布局","slug":"248Android开发之FrameLayout布局","date":"2016-09-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.350Z","comments":true,"path":"2016/09/02/248Android开发之FrameLayout布局/","link":"","permalink":"http://huishao.cc/2016/09/02/248Android开发之FrameLayout布局/","excerpt":"","text":"Android开发之FrameLayout布局在Android开发中，FrameLayout是所有布局容器中最简单的一种，在前边博客中有介绍关于Android开发中线性布局LinearLayout的应用。LinearLayout采用的是线性平铺的布局模式，FrameLayout也被称为帧布局。 LinearLayout应用介绍地址：http://my.oschina.net/u/2340880/blog/740714。 FrameLayout简单理解，可以将布局容器理解为一个单元素栈，先放入的视图在栈底，后放入的视图在栈顶，后放入的视图会覆盖先放入的视图。并且，FrameLayout不能够设置其内视图的位置，默认都是从左上角开始布局，这个布局模式在简单的重叠界面中使用十分方便。 使用代码进行FrameLayout布局示例如下： 1234567891011121314151617181920212223242526@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); FrameLayout frameLayout = new FrameLayout(this); setContentView(frameLayout); //添加子视图 TextView textView1 = new TextView(this); textView1.setLayoutParams(new FrameLayout.LayoutParams(600,600)); textView1.setBackgroundColor(Color.RED); frameLayout.addView(textView1); TextView textView2 = new TextView(this); textView2.setLayoutParams(new FrameLayout.LayoutParams(400,400)); textView2.setBackgroundColor(Color.YELLOW); frameLayout.addView(textView2); TextView textView3 = new TextView(this); textView3.setLayoutParams(new FrameLayout.LayoutParams(200,200)); textView3.setBackgroundColor(Color.BLUE); frameLayout.addView(textView3); TextView textView4 = new TextView(this); textView4.setLayoutParams(new FrameLayout.LayoutParams(100,100)); textView4.setBackgroundColor(Color.GREEN); frameLayout.addView(textView4);&#125; 上面示例代码在FrameLayout中放入4个TextView，后放入的视图依次减小，运行后效果如下图所示： FrameLayout应该是开发中很少使用到的一种布局模式，在十分简单的界面需求中，使用它往往十分方便。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发之LinearLayout布局详解","slug":"247Android开发之LinearLayout布局详解","date":"2016-08-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.350Z","comments":true,"path":"2016/08/31/247Android开发之LinearLayout布局详解/","link":"","permalink":"http://huishao.cc/2016/08/31/247Android开发之LinearLayout布局详解/","excerpt":"","text":"Android开发之LinearLayout布局详解LinaerLayout又被称为线性布局，是Android界面开发中常用的一种容器视图控件。可以使用XML布局文件配置和代码动态创建两种方式来使用LinearLayout。使用LinearLayout可以十分轻松的布局出横向或者纵向线性堆叠界面，并且，嵌套使用LinearLayout也可以方便的布局出复杂的平面组合布局，通常情况下，ScrollView会与LinearLayout进行结合使用。在iOS9中推出的UIStackView、在watchOS开发中使用和核心布局模型Group与LinearLayout的思路十分一致，可见这种线性堆叠的布局方式在一定场景下十分有优势。 使用代码动态创建LinearLayout示例如下： 12345678910111213141516171819202122232425@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //创建对象 LinearLayout linearLayout = new LinearLayout(this); linearLayout.setBackgroundColor(Color.WHITE); setContentView(linearLayout); //设置布局方向 /* 支持水平和竖直两种 public static final int HORIZONTAL = 0; 水平线性布局 public static final int VERTICAL = 1; 竖直线性布局 */ linearLayout.setOrientation(LinearLayout.VERTICAL); //设置显示分割线的模式 /* public static final int SHOW_DIVIDER_NONE = 0; 不显示分割线 public static final int SHOW_DIVIDER_BEGINNING = 1; 在开始处显示分割线 public static final int SHOW_DIVIDER_MIDDLE = 2; 在子视图之间显示分割线 public static final int SHOW_DIVIDER_END = 4; 在结束尾部显示分割线 */ linearLayout.setShowDividers(LinearLayout.SHOW_DIVIDER_MIDDLE); //设置分割线Drawable linearLayout.setDividerDrawable(ResourcesCompat.getDrawable(getResources(),R.drawable.line,null)); &#125; LinearLayout中常用属性与方法，列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//获取分割线Drawable对象Drawable getDividerDrawable ()//获取分割线的padding值int getDividerPadding ()//获取子视图布局模式int getGravity ()//获取线性布局方向int getOrientation ()//获取展示分割线模式int getShowDividers ()//获取布局权重和float getWeightSum ()//设置是否允许计量最大子元素 与权重有关boolean isMeasureWithLargestChildEnabled ()//设置分割线Drawablevoid setDividerDrawable (Drawable divider)//设置分割线padding值void setDividerPadding (int padding)//设置子视图布局模式/*可选参数AXIS_CLIP //原始对齐AXIS_PULL_AFTER AXIS_PULL_BEFOREAXIS_SPECIFIEDAXIS_X_SHIFTAXIS_Y_SHIFTBOTTOM //下对齐CENTER //居中对齐CENTER_HORIZONTAL // 水平居中对齐CENTER_VERTICAL // 竖直居中对齐CLIP_HORIZONTALCLIP_VERTICALDISPLAY_CLIP_HORIZONTALDISPLAY_CLIP_VERTICALEND //末尾对齐FILL //充满FILL_HORIZONTAL //水平充满FILL_VERTICAL //竖直充满HORIZONTAL_GRAVITY_MASKLEFT //左对齐NO_GRAVITY //空模式RELATIVE_HORIZONTAL_GRAVITY_MASKRELATIVE_LAYOUT_DIRECTIONRIGHT //右对齐START //起始对齐TOP //上对齐VERTICAL_GRAVITY_MASK*/void setGravity (int gravity)//设置水平布局模式void setHorizontalGravity (int horizontalGravity)//设置布局方向void setOrientation (int orientation)//设置竖直布局模式void setVerticalGravity (int verticalGravity)//设置布局权重和/*当布局容器内子视图是通过权重来计算所占比例时 这个值表示权重总和*/void setWeightSum (float weightSum)//设置子视图的触摸事件是否延迟执行/*这个属性用于类型ScrollView，ListView可以滑动的视图中，避免手势冲突*/boolean shouldDelayChildPressedState () 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"iOS开发中行高灵活可变的UITableView的性能优化","slug":"246iOS开发中行高灵活可变的UITableView的性能优化","date":"2016-08-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.350Z","comments":true,"path":"2016/08/27/246iOS开发中行高灵活可变的UITableView的性能优化/","link":"","permalink":"http://huishao.cc/2016/08/27/246iOS开发中行高灵活可变的UITableView的性能优化/","excerpt":"","text":"iOS开发中行高灵活可变的UITableView的性能优化一、UITableView的构建原理在新闻类，电商类等应用中，应用着大量的图文混排视图，在表视图UITableView中，开发者通常需要在如下代理方法中计算出当前cell填充内容后的高度，之后将其返回： 12345-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //先根据数据源中数据计算高度 CGFloat height = 0; return height;&#125; 然而，如果在如上方法中进行打印调试可以发现，heightForRowAtIndexPath方法会重复执行好多次，首先，并且heightForRowAtIndexPath方法的执行机制在不同版本的iOS系统还会有很大不同。以iOS9为例，一行cell要展示在屏幕上，至少要执行5遍TableView的heightForRowAtIndexPath方法： TableView配置部分： ① 当TableView视图即将展现在屏幕上时，会把所有行的行高数据进行拉取。 ②当TableView在执行setLayoutMargins方法进行自身布局时会把所有行高数据进行拉取。 ③TableView在执行layoutSubViews方法进行子视图布局时会再次把所有行高数据进行拉取。 TableViewCell配置部分： ④当使用cellID进行与TableView绑定的cell获取时会拉取本行cell的高度数据。 ⑤当cell进行layoutSubViews方法进行布局时会再次拉取本行cell的高度数据。 上面列举的5中拉取cell高度的场景中，TableView配置部分只会在TableView第一次展现在屏幕上时出现，但是其拉取的是所有行的行高数据，如果表视图有100行或者更多，这将是一个十分耗费性能的过程。TableViewCell配置部分，只有当cell将要出现在屏幕上时才会出现，并且只拉取当前行的行高，这两种场景会在用户滑动TableView时不断被执行，并且根据UITableView的布局cell原理，系统会默认准备当前一屏高度所能容纳cell个数加1个cell。 当执行TableView的reloadData方法进行界面刷新时，系统先会把所有行的行高数据拉取一遍，之后和UITableViewCell配置部分的场景一直，会拉取即将出现在屏幕上的cell的行高数据。 用示意图形象的表示上述逻辑如下： 通过上面分析，以10行数据的表格视图为例，若一屏幕可以呈现7行数据(TableView需要准备8行)，则在第一次展示TableView视图时，会执行44次heightForRwoAtIndexPath方法，每次刷新TableView需要执行24次heightForRwoAtIndexPath方法，如果TableView的行数增加到3位数，则这个方法的执行次数将会十分恐怖👿。 至于为何UITableView在进行配置时也需要拉取所有的行高数据，我猜想其为了进行视图的一些初始化操作，例如表视图右侧滚动条的宽度和所占比例等。并且，每次拉取高度都从代理方法拉取，而不是存入内部的一个变量属性中，避免了因为数据源更改时机巧合而产生的界面与预期不一致的风险。 二、对UITableView可变行高的计算方式进行优化通过前面的分析，可以理解如果将复杂的计算代码写在heightForRowAtIndexPath方法中，代价将是非常惨重的。滑动不流畅，屏幕卡顿很多性能问题都是由于这个原因。对于行高固定的表格视图，开发者可以直接设置TableView的固定行高，如下： 1_tableView.rowHeight = 200; 如果行高是不固定了，则应该想办法让heightForRowAtIndexPath方法完成最少的工作，其实最少的工作莫过于拿过一个高度，直接返回，因此开发者通常会将对应行的行高计算一次后，把值进行保存，之后在执行heightForRowAtIndexPath方法拉取行高时，直接返回已经计算过的行高数据，具体如何操作比较灵活，可以对应一个数组属性，将计算后的行高放入数组中，每次取行高时，检查数组中是否已经有计算过的行高数据，如果有直接返回。我个人更倾向将行高数据封装进cell的数据模型Model中。 通过优化，可以有效的减少重复的高度计算，这也是我原先处理此类问题的主要方式。然而，只是提高了代码的性能，对开发者来说，工作量和复杂度有增而无减。在开发中通常会遇到一些十分复杂的界面，而这些界面中cell的高度都是需要通过请求到的数据动态改变的，每个cell都要写复杂的尺寸计算代码十分令人心烦。在iOS7之后，系统提供了一种自动计算cell高度的方法，这无论在性能还是工作量上，都完全解放了开发者。 在iOS7系统之后，UITableView类中增加了一个estimatedRowHeight属性，顾名思义，这个属性是设置UITableViewCell中的大约行高值。这个值设置之后，开发者无需设置rowHeight属性，也不需要实现heightForRowAtIndexPath方法，系统会自动根据UITableViewCell中contentView的约束来计算自己的行高。estimatedRowHeight属性用于TableView进行初始化，其会影响到表格视图右侧滚动条的宽度。cell展现出来时真正的行高并不受这个属性值的影响。 那么现在问题来了，如何才能让cell正确计算自己的高度，这就要使用到Autolayout了，无论是通过xib文件创建的cell还是代码创建的cell，若想让cell自动正确的计算出自身的高度，必须添加足够压力的约束。所谓足够压力，是指UITableViewCell的contentView的上、下、左、右必须被内部控件的约束所撑满，需要注意，cell上的视图必须添加在contentView上，否则计算会出现问题。 例如下图所示，左侧的图标进行了与父视图的左侧距离约束，标题Label进行了与父视图的上侧距离约束和右侧距离约束，内容Label进行了与标题Label的上侧约束和与父视图的下册约束，并且对宽度进行了约束。此时，UITableViewCell的contentView四周都被子视图进行了约束，可以想象，内容Label的文本长度是不定的，当文本长度是的内容Label进行换行，内容Label的高度改变的时候，contentView下册会受到内容Label施加的压力，这时cell也会根据约束自动扩充自己的高度。 示例代码如下： 123456789101112131415161718192021222324252627282930313233- (void)viewDidLoad &#123; [super viewDidLoad]; self.title = @\"表视图\"; _tableView = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain]; [_tableView registerNib:[UINib nibWithNibName:@\"TableViewCell\" bundle:nil] forCellReuseIdentifier:@\"cellid\"]; _tableView.delegate = self; _tableView.dataSource = self; //设置一个模糊的行高用于配置TableView右侧滚动条 _tableView.estimatedRowHeight = 60; [self.view addSubview:_tableView]; titleArray = @[@\"标题1\",@\"标题2\",@\"标题3\",@\"标题4\",@\"标题5\",@\"标题6\",@\"标题7\",@\"标题8\",@\"标题9\",@\"标题10\"]; detailArray = @[@\"内容内容内容内容内容内容内容内容内容\", @\"内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\", @\"内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\", @\"内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\", @\"内容内容容内容内内容内容内容内容内容内容内容\", @\"容内容内内容内容\", @\"内容内容内容内容容内容内容内容\", @\"内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\", @\"内容内容内容内容内容内容容内容内内容内容内容\", @\"内容内容内容内容内容内容内容内容内容\"];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 10;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; TableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"cellid\" forIndexPath:indexPath]; cell.title.text = titleArray[indexPath.row]; cell.detail.text = detailArray[indexPath.row]; return cell;&#125; 通过上面示例可以看到，十分简单的代码完美的解决了图文混排cell高度的自适应。Autolayout真的是一种十分强大的技术😄。 关于细节方面，还有一个问题需要注意，预估的行高会影响到TableView右侧滚动条的展现，如果每个cell行高跳跃跨度十分大，滚动条宽度的配置会失准，随着用户滑动表视图，右侧滚动条可能会出现长短跳跃的情况，如果开发者需要精准这个滚动条的配置，可以在如下代理方法中返回具体cell的估计行高。 1234-(CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //这里根据不同分区 或者不同行 设置估计的行高 return 44;&#125; 关于estimatedHeightForRowAtIndexPath方法其实还有一种应用场景，前面介绍的优化方式都是以Autolyout为前提，对于没有使用自动布局，cell的高度需要手动计算的场景中，如果实现了这个方法，并且实现了heightForRowAtIndexPath方法，heightForRowAtIndexPath方法会以懒加载的方式执行，只有在cell将要展现在屏幕上时heightForRowAtIndexPath方法才会被执行，这也可以有效减小由于高度计算带来的性能负担。 三、关于高度不定的UITableView分区头尾视图一般情况下，TableView的分区头尾视图高度都是固定的，因此一般不需要考虑计算分区头尾视图高度产生的性能问题，类比如cell的布局原理，其实分区头尾视图也可以通过Autolayout实现自适应高度，示例代码如下： 123456789101112131415161718192021222324//返回一个估计的分区头视图高度-(CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section&#123; return 10;&#125;//使用自动布局给头视图添加足够的布局压力-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section&#123; UIView * view = [[UIView alloc]init]; UILabel * label = [[UILabel alloc]init]; label.numberOfLines = 0; if (section==0) &#123; label.text = @\"头视图头视图头视图\"; &#125;else&#123; label.text = @\"头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图\"; &#125; [view addSubview:label]; [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(@10); make.right.equalTo(@-10); make.top.equalTo(@10); make.bottom.equalTo(@-10); &#125;]; return view;&#125; 效果如下图： 分区为视图的设置方式与头视图一样。 UITableView类中还有一个十分有趣的常量： 1UIKIT_EXTERN const CGFloat UITableViewAutomaticDimension; UITableViewAutomaticDimension是一个CGFloat类型的常量，其需要和用来处理返回头尾视图标题的方法结合使用，用它来作为TableView分区头尾视图的高度返回，系统会自动根据标题是否存在来进行自适应，举个例子，如果返回的标题为nil，则头视图会被自动隐藏，示例代码如下： 1234567891011121314-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; //视图为nil则会自动返回0 return UITableViewAutomaticDimension;&#125;-(NSString*)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; if (section==0) &#123; return nil; &#125;else&#123; return @\"头视图头视图头视图头视图头视图头视图头视图头视\"; &#125;&#125; 小提示：UITableViewCell在创建出来时，其宽度并不一定和UITableView宽度一致，如果开发者需要通过获取cell的宽度来处理逻辑，要在cell的layoutSubViews里面进行，此时cell的宽度才正确。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Android Studio2.x版本无法自动关联源码的解决方法","slug":"245Android Studio2.x版本无法自动关联源码的解决方法","date":"2016-08-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.349Z","comments":true,"path":"2016/08/20/245Android Studio2.x版本无法自动关联源码的解决方法/","link":"","permalink":"http://huishao.cc/2016/08/20/245Android Studio2.x版本无法自动关联源码的解决方法/","excerpt":"","text":"Android Studio2.x版本无法自动关联源码的解决方法在学习android开发过程中，对于一个不熟悉的类，阅读源码是一个很好的学习方式，使用andorid studio开发工具的SDK Manager管理工具可以十分方便的下载SDK源码，打开SDK Manager工具，下载源码界面如下图所示： 在对应的SDK版本中可以下载SDK源码。 安卓源码下载完成后，在类名上按住command键，点击鼠标左键会跳转进对应源码文件，如果是Windows系统，使用按住control键点击鼠标左键。如果android studio的版本为2.0以上，需要注意，尽管下载了源码文件，可以在跳转源码的时候，会报错误找不到源码 Sources for &apos;Android API 23 Platform&apos; not found，并且会跳转类对应的class文件。如下图： 我猜想出现这样的原因是android studio2.x工具的一个小bug，下载源码后，它没有自动对源码路径进行关联，我们可以手段添加源码路径来解决这个问题。 1.检查andriod sdk源码是否下载成功：首先进入andorid sdk路径下的sources目录，如果其中有源码文件，说明andorid sdk的源码文件已经下载成功。在OS系统中，这个路径一般是：~/Library/Android/sdk/sources。 2.在android studio偏好设置jdk.table.xml文件中添加源码路径，这个文件在android studio开发工具的配置目录中，路径如下： 在Windows系统中，一般为：系统盘:\\Users\\username\\.你的android studio名称及版本\\config\\options 在OS系统中，一般为：~/Library/Preferences/你的android studio名称及版本/options 打开jdk.table.xml文件后，找到对应SDK版本的源码路径配置标签，将第一步中检查的源码文件路径添加进入，如下图： 3.完全关闭android studio开发工具，重新启动，这次可以成功跳进源码了，Have fun。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发中基础动画技巧的应用","slug":"244Android开发中基础动画技巧的应用","date":"2016-08-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.349Z","comments":true,"path":"2016/08/17/244Android开发中基础动画技巧的应用/","link":"","permalink":"http://huishao.cc/2016/08/17/244Android开发中基础动画技巧的应用/","excerpt":"","text":"Android开发中基础动画技巧的应用一、引言我是先入门iOS的移动开发者，提到动画开发，iOS开发者很容易联想到3种方式，UIImageView的帧动画，UIView层的属性动画和CoreAnimation动画。Android中也有3种方式创建基础动画效果，分别为View Animation，Property Animation和Drawable Animation。由于Android开发的固有特点，其在进行动画编程时也支持使用代码和xml配置文件两种方式。本篇博客，将主要向大家介绍这3种创建Android动画方式的使用方法与可以做到的效果。 二、View Animation动画的应用View Animation又被称为Tweened Animation，其应用于View视图变化的动画过渡效果。View Animation主要分为如下4类： ①.AlphaAnimation：透明度动画 ②.RotateAnimation：旋转动画 ③.ScaleAnimation:缩放动画 ④.TranslateAnimation：位移动画 1.AlphaAnimation的应用AlphaAnimation用于当视图透明度发生变化时展示过渡动画，可以渐隐也可以渐现。使用AlphaAnimation创建动画的核心代码如下： 123456//创建AlphaAnimation动画对象 构造方法中需要传入两个float值 分别是视图动画起始的alpha值与最终的alpha值AlphaAnimation alphaAnimation = new AlphaAnimation(1,0);//设置动画执行时间 alphaAnimation.setDuration(3000);//调用视图的startAnimation方法来开启动画animationImageView.startAnimation(alphaAnimation); 2.RotateAnimation的应用RotateAnimation用于创建视图的旋转动画。其相比AlphaAnimation要复杂一些，在使用时，除了需要设置其动画的起始角度和最终角度外，还可以设置视图旋转时的参照位置，示例代码如下： 123456//创建旋转动画对象RotateAnimation rotateAnimation = new RotateAnimation(0,360, Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);//设置动画时间rotateAnimation.setDuration(3000);//开始动画animationImageView.startAnimation(rotateAnimation); 这里使用了RotateAnimation类中最复杂的一个构造方法，其中需要传入6个参数，前两个参数分别为旋转动画的起始角度与终止角度，第3个参数为旋转参照点的x轴相对位置类型，第4个参数为参照点x轴位置，第5个和第6个参数分别为旋转参照点的y轴相对位置类型与y轴相对位置。 关于参照点的相对位置类型，Animation类中定义了几个常量供开发者选择使用，意义如下： 123456//绝对定位 以当前窗口做参照public static final int ABSOLUTE = 0;//以其父视图做为位置参照public static final int RELATIVE_TO_PARENT = 2;//以本身作为位置参照public static final int RELATIVE_TO_SELF = 1; 还有一点需要注意，如果选择的参照类型是RELATIVE_TO_SELF，则参照点的位置参数取值范围为0-1之间，代表的是相对于自身的位置比例，如果参照类型是RELATIVE_TO_PARENT，则参照点的位置参数取值范围为0-1之间，代表的是相对于父视图的位置比例，如果参照类型是ABSOLUTE，则参照点的位置参数取值为绝对坐标值，例如100，150，其代表了相对窗口视图的坐标位置。例如上面示例代码中，以视图本身为参照物，x、y轴位置都设置为0.5，则旋转动画以视图本身中心为旋转点，如果需要以视图右下角为旋转点，修改代码如下： 1RotateAnimation rotateAnimation = new RotateAnimation(0,360, Animation.RELATIVE_TO_SELF,1f,Animation.RELATIVE_TO_SELF,1f); 3.ScaleAnimation的应用ScaleAnimation用于创建放大或者缩小的形变动画，示例代码如下： 123456//创建缩放动画对象ScaleAnimation scaleAnimation = new ScaleAnimation(1,2,1,2,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);//设置动画时间scaleAnimation.setDuration(3000);//执行动画animationImageView.startAnimation(scaleAnimation); 上面示例代码中前4个参数分别设置缩放动画x轴方向的起始值、最终值和y轴方向的起始值、终止值。需要注意，这里的单位都是比例，1表示原视图尺寸，2表示原视图尺寸的2倍。这个方法后4个参数的意义是确定缩放参照点的位置，和RotateAniamtion构造方法中的参数意义一致。 4.TranslateAnimation的应用TranslateAnimation用于创建位移动画，示例代码如下： 123456//创建位移动画对象TranslateAnimation translateAnimation = new TranslateAnimation(Animation.ABSOLUTE,0,Animation.ABSOLUTE,100,Animation.RELATIVE_TO_SELF,0,Animation.RELATIVE_TO_SELF,1);//设置动画时间translateAnimation.setDuration(3000);//执行动画animationImageView.startAnimation(translateAnimation); 上面示例代码中使用的TranslateAnimation构造方法中的8个参数分别代表，起始位置的x轴参照点类型与起始位置的x轴值、终止位置的x轴参照点类型与终止位置的x轴值、起始位置的y轴参照点类型与起始位置的y轴值、终止位置的y轴参照点类型与终止位置的y轴值。 5.Animation类中的通用方法上面介绍的4种动画实际上都是Animation类的子类，Animation类中封装了许多动画通用的方法，例如前面使用的设置动画执行时间的方法setDuration就是Animation类的方法，其中更多常用方法列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//取消正在执行的动画public void cancel();//设置动画的执行函数public void setInterpolator(Interpolator i);//这只方法设置开始动画的延时值 单位为毫秒public void setStartOffset(long startOffset);//设置动画的执行时间public void setDuration(long durationMillis);//设置动画特效的最长运行时间public void restrictDuration(long durationMillis);//设置动画的执行强度比例 例如放大两倍的动画 这个值如果设置为2 将被放大4倍public void scaleCurrentDuration(float scale);//为动画设置一个开始的时间public void setStartTime(long startTimeMillis);//设置动画循环模式/*只有当动画的循环次数大于1时这个值才有效果，其可以设置为如下常量：RESTART 每次循环都从头执行REVERSE 正逆交替执行*/public void setRepeatMode(int repeatMode);//设置循环次数 设置为INFINITE则为无限循环public void setRepeatCount(int repeatCount);//设置是否允许填充动画 这个方法设置为true后setFillBefore()与setFillAfter()方法才会生效public void setFillEnabled(boolean fillEnabled);//动画结束后 是否以起始位置填充视图public void setFillBefore(boolean fillBefore);//动画结束后 是否以结束位置填充视图public void setFillAfter(boolean fillAfter)//设置动画执行时在Z轴上的位置/*可以设置为如下3中常量 public static final int ZORDER_BOTTOM = -1; //将动画放在Z轴最下边 public static final int ZORDER_NORMAL = 0; //将动画放在Z轴原位置 public static final int ZORDER_TOP = 1; //将动画放在Z轴最上边*/public void setZAdjustment(int zAdjustment);//设置动画的执行是否影响到壁纸public void setDetachWallpaper(boolean detachWallpaper);//获取动画是否开始执行了public boolean hasStarted();//获取动画是否结束执行了public boolean hasEnded(); 上面列举的方法中，setInterpolator()方法很有意思，其可以设置动画执行的时间函数，例如是先快后慢还是先慢后快等等，这个方法需要传入一个Interpolator类型的参数，实际上使用时是通过Interpolator的子类来实现的，示例如下： 1ranslateAnimation.setInterpolator(new AccelerateDecelerateInterpolator()); 对于Interpolator参数开发者可以设置的子类及意义列举如下： AccelerateDecelerateInterpolator：先加速后减速执行 AccelerateInterpolator：加速执行 AnticipateInterpolator：先后退执行一步后正向加速执行(类似弹簧效果) AnticipateOvershootInterpolator：先后退执行一步后加速执行到达极限后再前进一步后再回到极限(弹簧) BounceInterpolator：动画执行到结尾后进行阻尼效果 CycleInterpolator：以正弦规则循环执行数次动画，这个类来构造时需要传入循环次数，如下： 1new CycleInterpolator(3) DecelerateInterpolator：减速执行动画 FastOutLinearInInterpolator：基于贝塞尔曲线的速率变化 FastOutSlowInInterpolator：基于贝塞尔曲线的速率变化 LinearInterpolator：线性匀速执行 LinearOutSlowInInterpolator：基于贝塞尔曲线的速率变化 OvershootInterpolator：执行超出极限后在回退 PathInterpolator：自定义运动路径 6.实现对Animation动画状态的监听Animation类中也定义了一个监听器协议，其中提供了对动画状态进行监听的方法，如下： 12345678public interface AnimationListener &#123; //当动画开始执行时触发的方法 void onAnimationStart(Animation var1); //动画执行结束后触发的方法 void onAnimationEnd(Animation var1); //动画重复执行的时候会触发 void onAnimationRepeat(Animation var1);&#125; 7.使用xml文件配置View Animation上面介绍的全部是通过代码来创建View Animation动画，Android也支持使用xml文件来配置View Animation动画。 首先在Android Studio的res目录中创建一个动画文件目录，将其类型选择为anim，如下图所示： 在创建的目录中创建一个新的xml文件，在其中编写动画代码如下： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0\" android:duration = \"3000\"/&gt;&lt;/set&gt; 在代码中，使用如下代码来加载xml配置的动画： 1234//加载动画文件Animation animation = AnimationUtils.loadAnimation(this,R.anim.my_anmi);//执行动画animationImageView.startAnimation(animation); 8.复合的View AnimationView Animation也支持进行复合动画的操作，如果使用xml配置复合动画，十分简单，只需要将要要复合的动画都配置进xml文件的set标签中即可，如下： 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0\" android:duration = \"3000\"/&gt; &lt;scale android:fromXScale=\"1\" android:toXScale=\"2\" android:fromYScale=\"1\" android:toYScale=\"2\" android:duration=\"3000\"/&gt;&lt;/set&gt; 如果要用代码创建复合动画，需要使用到AnimationSet类进行复合，示例如下： 123456789101112//创建动画集合容器 参数决定容器中所有动画是否共用Interpolator时序函数AnimationSet set = new AnimationSet(true);//创建动画RotateAnimation rotateAnimation = new RotateAnimation(0,360, Animation.RELATIVE_TO_SELF,1f,Animation.RELATIVE_TO_SELF,1f);ScaleAnimation scaleAnimation = new ScaleAnimation(1,2,1,2,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);scaleAnimation.setDuration(3000);rotateAnimation.setDuration(3000);//将动画添加进集合中set.addAnimation(rotateAnimation);set.addAnimation(scaleAnimation);//执行动画animationImageView.startAnimation(set); 三、Property Animation动画的应用在前面介绍的View Animation动画体系中，虽然使用起来十分方便，但也有十分多的局限性，例如只能支持透明度，位置，缩放和旋转动画，并且在动画执行时，视图实际上并没有移动，如果需要做动画的是可以用户交互的按钮控件则会带来很多的不便。在Android3.0之后，系统推出了Property Animation动画，这种机制可以将对象任意属性的修改实现过渡动画效果。 1.ObjectAnimator动画的应用ObjectAnimator是Property Animation动画体系中最简单易用的一种方式，开发者只需要设置要改变的属性值和一些动画参数即可使用，例如若要实现视图以y方向为轴进行旋转操作，使用 如下代码实现： 123456//创建属性动画对象ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(animationImageView,\"rotationY\",0,360,0);//设置动画时间objectAnimator.setDuration(3000);//开始动画objectAnimator.start(); ObjectAnimator类的静态方法ofFloat()用于创建属性动画实例本身，与其类似的方法还有ofInt()与ofObject()。需要注意，这些方法第1个参数为要执行动画的视图，第2个参数为要发生动画改变的属性名，从第3个参数开始后面可以添加任意多个值，这些值代表了属性值改变的路径，例如上面示例代码表示将视图以y方向为轴从0°开始旋转到360°后再旋转回0°。 ObjectAnimator类继承自ValueAnimator，ValueAnimator类则更加灵活自由，其可以为自定义类的自定义属性做动画处理，后面会介绍，ValueAnimator类中提供了许多动画配置的方法，常用如下： 1234567891011121314151617181920//设置动画执行时间public ValueAnimator setDuration(long duration);//设置延时执行public void setStartDelay(long startDelay);//设置动画循环次数public void setRepeatCount(int value);//设置动画循环模式public void setRepeatMode(int value);//设置动画执行时序模式public void setInterpolator(TimeInterpolator value);//开始执行动画public void start();//结束动画public void end();//取消动画public void cancel();//恢复动画public void resume();//暂停动画public void pause(); 需要注意，使用ObjectAnimator创建动画的属性必须实现set和get方法。 2.ValueAnimator实现更加灵活的自定义动画ObjectAnimator是ValueAnimator的子类，可以理解，ValueAnimator要比ObjectAnimator更加灵活自由，其可以实现任意自定义属性的动画行为。示例代码如下： 1234567891011121314151617//创建ValueAnimator实例ValueAnimator valueAnimator = new ValueAnimator();//设置动画的路径值valueAnimator.setFloatValues(0,200,100,300,0);//设置动画的执行时间valueAnimator.setDuration(6000);//添加动画执行监听valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; //这个方法会在每次动画值改变时调用 @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; //设置视图的横坐标 animationImageView.setX((Float) valueAnimator.getAnimatedValue()); &#125;&#125;);//执行动画valueAnimator.start(); 如果运行上面代码，可以看到视图在6s内从x坐标点为0的地方平移到200后再次回到100后再次移动到300最终回到原点0。 上面的示例代码只是演示了ValueAnimator的工作原理，开发者可以在onAnimationUpdate()方法中进行任意属性的修改。仅从上面演示代码并不能体现出ValueAnimator的强大之处，可以通过实现类似抛物线的动画来理解ValueAnimator的灵活之处，示例代码如下： 12345678910111213141516171819202122232425262728293031//创建ValueAnimator实例final ValueAnimator animator = new ValueAnimator();//示例进行抛物线动画 让控件从(0,0)点位置移动到x轴为400的位置，y轴方向做自由落体animator.setObjectValues(new Point(0,0),new Point(400,0));//设置动画时间animator.setDuration(4000);//设置时序为线性函数animator.setInterpolator(new LinearInterpolator());//由于抛物线运动在x轴和y轴上的速度变化并不相同 需要自定义枚举器animator.setEvaluator(new TypeEvaluator&lt;Point&gt;() &#123; //这个枚举方法中传入的v值为动画执行的比例 0为初始状态 1为动画执行完成 开发者根据这个值模拟抛物线坐标 @Override public Point evaluate(float v, Point o,Point t1) &#123; //创建Point对象 模拟抛物运动 Point point = new Point(); point.x = (int)((v*8)*100); point.y = (int)((v*60)*(v*60)/4); return point; &#125;&#125;);//监听动画执行animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; //设置视图位置 animationImageView.setX(((Point)valueAnimator.getAnimatedValue()).x); animationImageView.setY(((Point)valueAnimator.getAnimatedValue()).y); &#125;&#125;);//执行动画animator.start(); 需要注意，Property Animation与View Animation最大的不同在于View Animation只是展示视图的界面动画，它并没有真正改变视图的属性，而Property Animation是实实在在的改变了发生动画控件的属性。 3.Property Animation动画的监听ValueAnimator对象可以使用addListener()方法来添加监听者，接口方法如下： 1234567891011//动画监听接口public interface AnimatorListener &#123; //动画开始 void onAnimationStart(Animator var1); //动画结束 void onAnimationEnd(Animator var1); //动画取消 void onAnimationCancel(Animator var1); //动画重复 void onAnimationRepeat(Animator var1);&#125; 4.使用PropertyValuesHolder进行动画复合对于Property Animation，开发者可以通过ValueAnimator实现自定义的复合动画，也可以使用PropertyValuesHolder进行属性动画的复合操作，示例如下： 123456789//创建子属性动画 翻转PropertyValuesHolder holder = PropertyValuesHolder.ofFloat(\"rotationY\",0,360,90);//创建子属性动画 透明PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(\"alpha\",1,0,1);//进行动画复合ObjectAnimator objectAnimation = ObjectAnimator.ofPropertyValuesHolder(animationImageView,holder,holder2);//执行动画objectAnimation.setDuration(3000);objectAnimation.start(); 三、Drawable Animation动画的应用相比前两种动画模式，Drawable Animation动画要容易的多，其使用一组图像快速切换的原理来实现动画效果。 在Android Studio的drawable文件夹中添加一个animation文件，xml代码如下： 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/bird1\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird2\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird3\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird4\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird5\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird6\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird7\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird8\" android:duration=\"200\" /&gt;&lt;/animation-list&gt; 将需要展示动画的视图背景设置为这个drawable文件，示例如下： 12345&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/anmi_draw_list\" android:id=\"@+id/animatedImageView\"/&gt; 在需要开始动画时，调用如下代码即可： 12//获取到drawable背景 调用start()方法开始动画((AnimationDrawable)animationImageView.getBackground()).start(); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"iOS开发中UITableViewCell点击时子视图背景透明的解决方法","slug":"243iOS开发中UITableViewCell点击时子视图背景透明的解决方法","date":"2016-08-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.349Z","comments":true,"path":"2016/08/10/243iOS开发中UITableViewCell点击时子视图背景透明的解决方法/","link":"","permalink":"http://huishao.cc/2016/08/10/243iOS开发中UITableViewCell点击时子视图背景透明的解决方法/","excerpt":"","text":"iOS开发中UITableViewCell点击时子视图背景透明的解决方法在做iOS项目的开发中，UITableView控件的应用十分广泛。在进行自定义UITableViewCell时，经常有小伙伴遇到这样的问题：在UITableViewCell上面添加了一个有背景颜色的子视图，当用户点击UITableViewCell或者选中UITableViewCell时，Cell上的子视图发生了奇怪的变化，其背景色变透明了，如果添加在Cell上的子视图只是一个色块，那么我们看起来，这个子视图好像莫名其妙的消失了一样。如下图所示： 产生这种情况的主要原因是由于UITableViewCell的选中风格所致。如果开发者不进行设置，UITableViewCell中的selectionStyle属性默认风格为UITableViewCellSelectionStyleBlue。这时，如果用户点击或者选中了某个Cell，系统会自动将其上子视图的背景色改成透明以便统一Cell的整体背景颜色。开发者可以将其设置为UITableViewCellSelectionStyleNone枚举值来不适用任何Cell的选中风格。 如果需要使用Cell的选中风格同时又不想让Cell上的子视图收到影响，我们可以继承UITableViewCell后在其中覆写父类的如下两个方法，在这些方法中重新设置子视图的背景色： 12345678910//这个方法在Cell被选中或者被取消选中时调用- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated]; self.testLabel.backgroundColor = [UIColor orangeColor];&#125;//这个方法在用户按住Cell时被调用-(void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated&#123; [super setHighlighted:highlighted animated:animated]; self.testLabel.backgroundColor = [UIColor orangeColor];&#125; 如下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"Android中SharedPreferences使用小记","slug":"242Android中SharedPreferences使用小记","date":"2016-08-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.349Z","comments":true,"path":"2016/08/03/242Android中SharedPreferences使用小记/","link":"","permalink":"http://huishao.cc/2016/08/03/242Android中SharedPreferences使用小记/","excerpt":"","text":"Android中SharedPreferences使用小记一、引言Android中使用SharedPreferences来进行简单数据的持久化处理，从名字就可以了解，其设计目的是为了保存应用程序的一些偏好设置，如音量，主题等信息。其与iOS开发中的NSUserDefault十分类似，并且，他们的实质都是采用XML格式的文件来存储数据。 二、SharedPreferences的简单应用对数据的持久化操作都会分为两个部分，一部分为存，另一部分为取。首先，开发者在Activity中使用如下方法可以获取获取创建一个SharedPreferences实例： 1234/*这个方法需要传入两个参数，第一个参数为文件名，第二个参数为文件模式*/SharedPreferences sharedPreferences = getSharedPreferences(\"MyPreference\",MODE_PRIVATE); 在getSharedPreference()方法中第一个参数决定这个存储文件的名字，在获取SharedPreferences实例时，如果系统创建过这个文件，则会返回本地的原文件，如果没有这个文件，则会进行创建。第二个参数决定这个文件的访问权限，可选参数如下： 123Activity.MODE_PRIVATE,//默认操作模式，代表该文件是私有数据，只能被应用本身访问Activity.MODE_WORLD_READABLE,//表示当前文件可以被其他应用读取， Activity.MODE_WORLD_WRITEABLE,//表示当前文件可以被其他应用写入； 有了SharedPreferences实例，在需要进行数据存储时，需要获取到SharedPreferences实例中的Editor对象，SharedPreferences类中有一个Editor的内部接口，其中提供了存储数据的相关方法，示例代码如下: 123456//获取Editor对象SharedPreferences.Editor editor = sharedPreferences.edit();//进行字符串存储editor.putString(\"password\",\"123456\");//提交存储内容editor.commit(); Editor采用键值对的存储方式，可以存储的数据即常用方法如下： 12345678910111213141516171819202122public interface Editor &#123; //进行字符串数据存储 SharedPreferences.Editor putString(String var1, String var2); //进行字符Set存储 SharedPreferences.Editor putStringSet(String var1, Set&lt;String&gt; var2); //进行Int值存储 SharedPreferences.Editor putInt(String var1, int var2); //进行Long值存储 SharedPreferences.Editor putLong(String var1, long var2); //进行Float值存储 SharedPreferences.Editor putFloat(String var1, float var2); //进行布尔值存储 SharedPreferences.Editor putBoolean(String var1, boolean var2); //删除一个键 与其对应的值 SharedPreferences.Editor remove(String var1); //清空所有数据 SharedPreferences.Editor clear(); //提交存储 boolean commit(); //提交存储请求 void apply(); &#125; 上面的方法中，有两点需要注意，首先clear()方法是将所有的键的值清空，并没有删除键，而remove是删除键和值。第二点，commit()方法和apply()方法都用于提交数据，不同的是，commit()方法会直接将数据同步到磁盘，返回值会告知开发者是否同步成功，而apply()方法只是将数据存储在内存，之后异步进行存盘操作，没有返回值，在开发中，如果要保证数据立马存入磁盘，要使用commit()方法。 对存储的数据进行读取，可以直接调用SharedPreferences实例的如下方法： 12345678910111213141516171819202122232425public interface SharedPreferences &#123; //获取所有键值映射表 Map&lt;String, ?&gt; getAll(); //通过键获取字符串值 第一个参数为键 第二个参数为此键不存在时使用的默认值 String getString(String var1, String var2); //通过键获取字符串值集合 第一个参数为键 第二个参数为此键不存在时使用的默认值 Set&lt;String&gt; getStringSet(String var1, Set&lt;String&gt; var2); //通过键获取整形值 第一个参数为键 第二个参数为此键不存在时使用的默认值 int getInt(String var1, int var2); //通过键获取长整形值 第一个参数为键 第二个参数为此键不存在时使用的默认值 long getLong(String var1, long var2); //通过键获取浮点值 第一个参数为键 第二个参数为此键不存在时使用的默认值 float getFloat(String var1, float var2); //通过键获取布尔值 第一个参数为键 第二个参数为此键不存在时使用的默认值 boolean getBoolean(String var1, boolean var2); //检查文件中是否包含某个键 boolean contains(String var1); //注册监听 void registerOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener var1); //取消注册监听 void unregisterOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener var1); public interface OnSharedPreferenceChangeListener &#123; void onSharedPreferenceChanged(SharedPreferences var1, String var2); &#125;&#125; 注册监听方法可以提供给开发者一个回调接口，当SharedPreferences中数据改变时，会通知给开发者进行逻辑处理，示例代码如下： 12345678910//创建监听者 final SharedPreferences.OnSharedPreferenceChangeListener listener = new SharedPreferences.OnSharedPreferenceChangeListener() &#123; //需要重写这个方法 这个方法中会传入发生变化的键s @Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String s) &#123; Log.d(\"**********\",s); &#125; &#125;;//进行注册sharedPreferences.registerOnSharedPreferenceChangeListener(listener); 温馨提示：可以在Android Device Monitor中查看创建的SharedPreferences文件，路径为data/data/APP包名/shared_prefs目录下，可以看到其为XML文件，如下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Objective-C中NSArray类的解读","slug":"241 Objective-C中NSArray类的解读","date":"2016-07-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.349Z","comments":true,"path":"2016/07/19/241 Objective-C中NSArray类的解读/","link":"","permalink":"http://huishao.cc/2016/07/19/241 Objective-C中NSArray类的解读/","excerpt":"","text":"Objective-C中NSArray类的解读NSArray数组类是Objective-C语言中常用的也是重要的一个类，除了开发中常用到的一些基础功能，NSArray及其相关类中还封装了许多更加强大的功能。有机会总结了一下，与需要的朋友们分享。 NSArray中属性与方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//获取数组中元素个数@property (readonly) NSUInteger count;//通过下标获数组中的元素- (ObjectType)objectAtIndex:(NSUInteger)index;//初始化方法- (instancetype)init;//通过C语言风格的数组创建NSArray对象 需要注意，C数组中需要为Objective对象，cnt参数为C数组的长度//如果cnt的值小于C数组的长度，则会对C数据进行截取赋值，如果大于则程序会崩溃- (instancetype)initWithObjects:(const ObjectType [])objects count:(NSUInteger)cnt;//数组的归档方法- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder;//像数组中追加一个元素 这个方法会返回一个新的数组- (NSArray&lt;ObjectType&gt; *)arrayByAddingObject:(ObjectType)anObject;//像数组中追加一组元素 这个方法会返回一个新的数组- (NSArray&lt;ObjectType&gt; *)arrayByAddingObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray;//返回一个字符串，将数组中的元素以separator为分隔符进行组合/*NSArray * array = @[@1,@2,@3,@4];将打印1,2,3,4NSString * res = [array componentsJoinedByString:@\",\"];*/- (NSString *)componentsJoinedByString:(NSString *)separator;//判断数组中是否包含某个元素- (BOOL)containsObject:(ObjectType)anObject;//数组的打印方法@property (readonly, copy) NSString *description;- (NSString *)descriptionWithLocale:(nullable id)locale;- (NSString *)descriptionWithLocale:(nullable id)locale indent:(NSUInteger)level;//获取第一个包含于另一个数组中的元素- (nullable ObjectType)firstObjectCommonWithArray:(NSArray&lt;ObjectType&gt; *)otherArray;//将数组中一定范围的元素读取到一个C数组中 objects参数需要为分配好空间的C指针- (void)getObjects:(ObjectType __unsafe_unretained [])objects range:(NSRange)range;//获取某个元素在数值中的下标值- (NSUInteger)indexOfObject:(ObjectType)anObject;//获取某个范围内的元素的下标值- (NSUInteger)indexOfObject:(ObjectType)anObject inRange:(NSRange)range;//获取与给定元素相同的元素在数组中的最小下标值- (NSUInteger)indexOfObjectIdenticalTo:(ObjectType)anObject;//在一定范围内 获取与给定元素相同的元素在数组中的最小下标值- (NSUInteger)indexOfObjectIdenticalTo:(ObjectType)anObject inRange:(NSRange)range;//判断两个数组是否相同- (BOOL)isEqualToArray:(NSArray&lt;ObjectType&gt; *)otherArray;//获取数组中第一个元素@property (nullable, nonatomic, readonly) ObjectType firstObject NS_AVAILABLE(10_6, 4_0);//获取数组中最后一个元素@property (nullable, nonatomic, readonly) ObjectType lastObject;//获取数组的枚举对象- (NSEnumerator&lt;ObjectType&gt; *)objectEnumerator;//获取数组的逆向枚举对象- (NSEnumerator&lt;ObjectType&gt; *)reverseObjectEnumerator;/*这个属性可以获取一个已经排序数组的排序规则 在使用- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))comparator context:(nullable void *)context hint:(nullable NSData *)hint;方法时可以将此排序规则传入 对于没有排序过的数组，使用- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))comparator context:(nullable void *)context;方法会自动产生一个这样的排序规则*/@property (readonly, copy) NSData *sortedArrayHint;//通过C排序函数进行排序/*示例：NSInteger sort(id obj1, id obj2, void *context)&#123; NSNumber *str1 =(NSNumber*) obj1; NSNumber *str2 =(NSNumber*) obj2; if ([str1 intValue] &lt; [str2 intValue]) &#123; return NSOrderedDescending; &#125; else if([str1 intValue] == [str2 intValue]) &#123; return NSOrderedSame; &#125; return NSOrderedAscending;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray * array = @[@1,@3,@2,@4]; array = [array sortedArrayUsingFunction:sort context:nil]; NSString * res = [array componentsJoinedByString:@\",\"]; NSLog(@\"%@\",res);&#125;*/- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))comparator context:(nullable void *)context;//通过C排序函数进行数组排序- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))comparator context:(nullable void *)context hint:(nullable NSData *)hint;//使用函数选择器进行数组排序- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingSelector:(SEL)comparator;//获取数组一定范围的子数组- (NSArray&lt;ObjectType&gt; *)subarrayWithRange:(NSRange)range;//将数组写入文件- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;//将数组写入指定url路径- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically;//是数组中的所有元素调用某个方法选择器- (void)makeObjectsPerformSelector:(SEL)aSelector;//功能同上 支持传参- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(nullable id)argument;//获取一个下标集合所对应的元素- (NSArray&lt;ObjectType&gt; *)objectsAtIndexes:(NSIndexSet *)indexes;//数组的下标方法 子类重写- (ObjectType)objectAtIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0);//对数组中的元素进行枚举遍历- (void)enumerateObjectsUsingBlock:(void (^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);//对数组中的元素进行枚举遍历/*typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) &#123; NSEnumerationConcurrent = (1UL &lt;&lt; 0),//正向枚举 NSEnumerationReverse = (1UL &lt;&lt; 1), //逆向枚举&#125;; */- (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);//在一个下标集合中枚举- (void)enumerateObjectsAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts usingBlock:(void (^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);//通过遍历的方式查找符合条件的元素下标- (NSUInteger)indexOfObjectPassingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//通常 可以设置遍历方式- (NSUInteger)indexOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//同上 在一定下标集合中遍历- (NSUInteger)indexOfObjectAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//通过遍历的方式查找所有符合条件的元素下标- (NSIndexSet *)indexesOfObjectsPassingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//同上- (NSIndexSet *)indexesOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//同上- (NSIndexSet *)indexesOfObjectsAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//通过block进行数组排序- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);//同上/*typedef NS_OPTIONS(NSUInteger, NSSortOptions) &#123; NSSortConcurrent = (1UL &lt;&lt; 0),//同步排序 NSSortStable = (1UL &lt;&lt; 4),//稳定排序&#125;;*/- (NSArray&lt;ObjectType&gt; *)sortedArrayWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);//二分查找的枚举参数typedef NS_OPTIONS(NSUInteger, NSBinarySearchingOptions) &#123; NSBinarySearchingFirstEqual = (1UL &lt;&lt; 8), NSBinarySearchingLastEqual = (1UL &lt;&lt; 9), NSBinarySearchingInsertionIndex = (1UL &lt;&lt; 10),&#125;;//对区域排序的数组进行二分查找- (NSUInteger)indexOfObject:(ObjectType)obj inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator)cmp NS_AVAILABLE(10_6, 4_0); // binary search//创建对象+ (instancetype)array;//通过一个元素创建数组对象+ (instancetype)arrayWithObject:(ObjectType)anObject;//通过C数组创建数组对象+ (instancetype)arrayWithObjects:(const ObjectType [])objects count:(NSUInteger)cnt;//通过一组元素创建数组对象+ (instancetype)arrayWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION;//通过另一个数组创建数组对象+ (instancetype)arrayWithArray:(NSArray&lt;ObjectType&gt; *)array;//初始化方法- (instancetype)initWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION;- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array;- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag;//通过文件创建数组+ (nullable NSArray&lt;ObjectType&gt; *)arrayWithContentsOfFile:(NSString *)path;//通过url创建数组+ (nullable NSArray&lt;ObjectType&gt; *)arrayWithContentsOfURL:(NSURL *)url;同上- (nullable NSArray&lt;ObjectType&gt; *)initWithContentsOfFile:(NSString *)path;- (nullable NSArray&lt;ObjectType&gt; *)initWithContentsOfURL:(NSURL *)url;//获取数组所有元素 需要传入分配了内存的C指针- (void)getObjects:(ObjectType __unsafe_unretained [])objects; NSMutableArray中属性与方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//向数组中追加一个元素- (void)addObject:(ObjectType)anObject;//向数组某个位置插入一个元素- (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;//删除数组中最后一个元素- (void)removeLastObject;//删除数组中指定位置的元素- (void)removeObjectAtIndex:(NSUInteger)index;//替换数组中一个位置的元素- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;//初始化- (instancetype)init NS_DESIGNATED_INITIALIZER;- (instancetype)initWithCapacity:(NSUInteger)numItems NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;//通过数组来追加元素- (void)addObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray;//交换两个元素- (void)exchangeObjectAtIndex:(NSUInteger)idx1 withObjectAtIndex:(NSUInteger)idx2;//删除所有元素- (void)removeAllObjects;//在一定范围内删除元素- (void)removeObject:(ObjectType)anObject inRange:(NSRange)range;//删除一个元素- (void)removeObject:(ObjectType)anObject;//删除指定范围内下标最小的某个元素- (void)removeObjectIdenticalTo:(ObjectType)anObject inRange:(NSRange)range;//删除某个元素 下标最小的- (void)removeObjectIdenticalTo:(ObjectType)anObject;//删除一定范围内的所有元素- (void)removeObjectsFromIndices:(NSUInteger *)indices numIndices:(NSUInteger)cnt NS_DEPRECATED(10_0, 10_6, 2_0, 4_0);//通过数组删除元素- (void)removeObjectsInArray:(NSArray&lt;ObjectType&gt; *)otherArray;//通过范围删除元素- (void)removeObjectsInRange:(NSRange)range;//替换一组元素- (void)replaceObjectsInRange:(NSRange)range withObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray range:(NSRange)otherRange;//替换一组元素- (void)replaceObjectsInRange:(NSRange)range withObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray;//设置数组元素- (void)setArray:(NSArray&lt;ObjectType&gt; *)otherArray;//进行数组排序- (void)sortUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))compare context:(nullable void *)context;//进行数组排序- (void)sortUsingSelector:(SEL)comparator;//插入一组元素- (void)insertObjects:(NSArray&lt;ObjectType&gt; *)objects atIndexes:(NSIndexSet *)indexes;//删除一组元素- (void)removeObjectsAtIndexes:(NSIndexSet *)indexes;//替换一组元素- (void)replaceObjectsAtIndexes:(NSIndexSet *)indexes withObjects:(NSArray&lt;ObjectType&gt; *)objects;//设置某个下标对应的元素 子类覆写- (void)setObject:(ObjectType)obj atIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0);//进行数组排序- (void)sortUsingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);//进行数组排序- (void)sortWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);//创建数组 numItems为元素个数+ (instancetype)arrayWithCapacity:(NSUInteger)numItems;//通过文件创建数组+ (nullable NSMutableArray&lt;ObjectType&gt; *)arrayWithContentsOfFile:(NSString *)path;//通过url创建数组+ (nullable NSMutableArray&lt;ObjectType&gt; *)arrayWithContentsOfURL:(NSURL *)url;同上- (nullable NSMutableArray&lt;ObjectType&gt; *)initWithContentsOfFile:(NSString *)path;- (nullable NSMutableArray&lt;ObjectType&gt; *)initWithContentsOfURL:(NSURL *)url; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS中Today扩展插件与宿主APP的交互","slug":"240iOS中Today扩展插件与宿主APP的交互","date":"2016-07-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.348Z","comments":true,"path":"2016/07/14/240iOS中Today扩展插件与宿主APP的交互/","link":"","permalink":"http://huishao.cc/2016/07/14/240iOS中Today扩展插件与宿主APP的交互/","excerpt":"","text":"iOS中Today扩展插件与宿主APP的交互扩展是iOS8后系统开发给开发者的新开发思路与接口，每一个扩展都可以理解为一个简单的小应用程序，只是其不是独立存在的，要寄附于某一个主应用上。介绍iOS8扩展与Today插件的专题见如下博客： iOS8中扩展与Today插件：http://my.oschina.net/u/2340880/blog/485533。 上述博客中只是简单的介绍扩展的应用场景与创建Today扩展插件的方法，在实际开发中，由于扩展是寄附于某个应用程序之上的，因此其通常需要和宿主APP进行数据交互。创建Today扩展Target后，Xcode模板会自动帮助开发者生成一个ViewController作为主界面，开发者可以向其中添加展示UI或者交互控件，十分强大的是，Today扩展中是支持对UIViewController的切换的。需要注意，扩展与原APP是在不同的目录结构中的，默认情况下，扩展与原APP的数据并不共享，代码也不能复用。例如原APP中可能有网络请求，数据持久化存储等结构框架，扩展中不可以直接使用，扩展需要提供自己的网络请求框架爱，数据持久化结构框架等。 如果项目是使用Pod进行的管理，则可以通过手动设置，使扩展中可以使用继承的Pod库，步骤如下： 完成上面两张图中的步骤，即可在扩展中使用Pod库了。 Xcode扩展模板创建的ViewController会自动遵守NSWidgetProviding这个协议，这个协议中的方法和意义如下，开发者可以根据需求选择实现： 1234//数据更新时调用的方法 系统会定期更新扩展- (void)widgetPerformUpdateWithCompletionHandler:(void (^)(NCUpdateResult result))completionHandler;//设置扩展UI边距 注意 在使用Storyboard时，若要所见即所得 这个方法中需要返回UIEdgeInsetsZero- (UIEdgeInsets)widgetMarginInsetsForProposedMarginInsets:(UIEdgeInsets)defaultMarginInsets; 注意：Today扩展有其自己的plist配置文件，若需要对扩展进行配置，注意不要与宿主工程的plist文件混淆。 在Today扩展中打开原宿主APP使用openURL的方式，示例如下： 1[viewController.extensionContext openURL:[NSURL URLWithString:[NSString stringWithFormat:@\"MyApp://action=%@\",@\"action\"]] completionHandler:nil]; 上面打开原宿主APP的代码中，MyApp是宿主APP配置的url Schemes，配置方式如下图： 可以通过为url配置参数的方式来进行Today扩展与原宿主APP的信息交互，当扩展使用openURL的方式打开原宿主APP时，宿主APP会调用AppDelegate中的如下方法： 123456-(BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123;//可以拿到url做相应逻辑处理 UIAlertView * alert = [[UIAlertView alloc]initWithTitle:url.absoluteString message:nil delegate:nil cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil]; [alert show]; return YES;&#125; 上面介绍的openURL的方式只是进行跳转交互，参数传递，并不能完成数据共享的需求，并且通过openURL的方式传递的数据是单向的。实际上，扩展和原宿主APP共享数据的应用场景十分广泛，例如电商类宿主APP中拉取到一批商品信息，Today扩展中也需要这些信息进行展示，如果数据不共享，同样的数据将在宿主APP内部和扩展都都请求一次，十分浪费，难很难同步。系统还提供了另一种方式来使宿主APP和Today扩展可以共享一块存储空间，这需要使用App Group技术来实现。开发者在进行App Group相关功能的测试时，必须与AppID进行关联。 首先，需要开启宿主APP的App Group，示例图如下： 在Today扩展中，选择相同的App Group，如下： 开启了App Group功能后，Xcode会自动生成一套匹配的权限文件，如下： 配置工作完成后，可以通过两种方式共享数据存储空间，示例如下： 123456789//使用数据共享的NSUserDefaults 这个NSUserDefaults是宿主APP与扩展所共享的NSUserDefaults * defaults =[NSUserDefaults alloc]initWithSuiteName:@\"开发者设置的AppGroup名称\"];//使用数据共享的文件目录NSFileManager * manager = [NSFileManager defaultManager];//共享目录NSURL * baseURL = [manager containerURLForSecurityApplicationGroupIdentifier:@\"开发者设置的AppGroup名称\"];//找文件NSURL * filePath = [baseURL URLByAppendingPathComponent:@\"file\"]; 注意：还有一点细节需要注意，扩展与原宿主APP素材文件也是互相独立的，要在扩展中使用的素材必须添加进扩展Target。 小提示：使用Xcode调试扩展时，需要运行扩展的Target，开发者有时会发现断点失效，将模拟器上的应用删掉，重新运行扩展即可解决。 Demo地址：http://pan.baidu.com/s/1bp0ZcYF。 截图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中UIPopoverController使用详解","slug":"239iOS中UIPopoverController使用详解","date":"2016-07-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.348Z","comments":true,"path":"2016/07/13/239iOS中UIPopoverController使用详解/","link":"","permalink":"http://huishao.cc/2016/07/13/239iOS中UIPopoverController使用详解/","excerpt":"","text":"iOS中UIPopoverController使用详解一、引言UIPopoverController是Pad设备中常用的一种视图控制器，其在UI表现上为在当前视图控制器上面弹出一个子视图控制器，通常用来展示交互列表。示例如下图： UIPopoverController只能用于iPad，在要兼容iPad和iPhone的项目中，需要根据设备类型使用两套代码。在iOS8之后，系统提供了UIPresentationController来代替她，UIPresentationController可以兼容iPhone与iPad。 二、UIPopoverController的使用详解首先UIPopoverController是一个容器控制器，其中需要承载一个ViewControler作为内容视图。UIPopoverController使用如下初始化方法创建： 12//创建视图控制器的方法 通过一个内容视图控制器创建- (instancetype)initWithContentViewController:(UIViewController *)viewController; 创建出控制器后，调用如下方法可以将控制器弹出： 12345678910111213141516//这个方法将控制器以一个CGRect区域为基准弹出/*UIPopoverArrowDirection为箭头出现的方向typedef NS_OPTIONS(NSUInteger, UIPopoverArrowDirection) &#123; UIPopoverArrowDirectionUp = 1UL &lt;&lt; 0,//上 UIPopoverArrowDirectionDown = 1UL &lt;&lt; 1,//下 UIPopoverArrowDirectionLeft = 1UL &lt;&lt; 2,//左 UIPopoverArrowDirectionRight = 1UL &lt;&lt; 3,//右 UIPopoverArrowDirectionAny = UIPopoverArrowDirectionUp | UIPopoverArrowDirectionDown | UIPopoverArrowDirectionLeft | UIPopoverArrowDirectionRight,//任意方向 UIPopoverArrowDirectionUnknown = NSUIntegerMax//未知&#125;;*///view参数为选择要在那个View视图上弹出 animated参数设置是否带动画- (void)presentPopoverFromRect:(CGRect)rect inView:(UIView *)view permittedArrowDirections:(UIPopoverArrowDirection)arrowDirections animated:(BOOL)animated;//以一个BarButtonItem为基准弹出 其余参数意义同上- (void)presentPopoverFromBarButtonItem:(UIBarButtonItem *)item permittedArrowDirections:(UIPopoverArrowDirection)arrowDirections animated:(BOOL)animated; UIPopoverController的相关设置方法如下： 12345678910111213141516171819202122232425//设置代理@property (nullable, nonatomic, weak) id &lt;UIPopoverControllerDelegate&gt; delegate;//设置内容视图控制器@property (nonatomic, strong) UIViewController *contentViewController;- (void)setContentViewController:(UIViewController *)viewController animated:(BOOL)animated;//设置界面展示尺寸@property (nonatomic) CGSize popoverContentSize;- (void)setPopoverContentSize:(CGSize)size animated:(BOOL)animated;//获取控制器当前是否正在展示@property (nonatomic, readonly, getter=isPopoverVisible) BOOL popoverVisible;//获取控制器箭头方向@property (nonatomic, readonly) UIPopoverArrowDirection popoverArrowDirection;//这个属性可以增强控制器的交互能力/*默认情况下，当视图控制器弹出时，点击界面上的其他位置，视图控制器会被隐藏 如果需要当视图控制爱弹出时界面上的其他控件依然可以进行用户交互，则需要将这些UI控件设置进这个数组中*/@property (nullable, nonatomic, copy) NSArray&lt;__kindof UIView *&gt; *passthroughViews;//隐藏视图控制器的方法- (void)dismissPopoverAnimated:(BOOL)animated;//设置视图控制器的背景颜色@property (nullable, nonatomic, copy) UIColor *backgroundColor NS_AVAILABLE_IOS(7_0);//设置视图Margin@property (nonatomic, readwrite) UIEdgeInsets popoverLayoutMargins NS_AVAILABLE_IOS(5_0);//这个属性用于自定义PopoverController的UI展现 传入自定义的背景视图类@property (nullable, nonatomic, readwrite, strong) Class popoverBackgroundViewClass NS_AVAILABLE_IOS(5_0); 三、自定义UI展现的UIPopoverController通过设置UIPopoverController对象的popoverBacjgroundViewClass属性可以将一个自定义的类作为控制器的背景视图，需要注意，此自定义的类必须继承自UIPopoverBackgroundView，并且子类必须覆写父类中的一些列方法，示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@interface MyView : UIPopoverBackgroundView@end@implementation MyView//这个方法返回箭头宽度+ (CGFloat)arrowBase&#123; return 20;&#125;//这个方法中返回内容视图的偏移+(UIEdgeInsets)contentViewInsets&#123; return UIEdgeInsetsMake(20, 20, 20, 20);&#125;//这个方法返回箭头高度+(CGFloat)arrowHeight&#123; return 30;&#125;//这个方法返回箭头的方向-(UIPopoverArrowDirection)arrowDirection&#123; return UIPopoverArrowDirectionUp;&#125;//这个在设置箭头方向时被调用 可以监听做处理-(void)setArrowDirection:(UIPopoverArrowDirection)arrowDirection&#123; &#125;//这个方法在设置箭头偏移量时被调用 可以监听做处理-(void)setArrowOffset:(CGFloat)arrowOffset&#123; &#125;//重写layout方法来来定义箭头样式- (void)layoutSubviews&#123; [super layoutSubviews]; CGSize arrowSize = CGSizeMake([[self class] arrowBase], [[self class] arrowHeight]); UIImage * image = [self drawArrowImage:arrowSize]; UIImageView * imageView = [[UIImageView alloc]initWithImage:image]; imageView.frame = CGRectMake(0, 0.0f, arrowSize.width, arrowSize.height); [self addSubview:imageView];&#125;//这个方法中进行背景色的设置- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor = [UIColor redColor]; &#125; return self;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; &#125; return self;&#125;//返回值决定是否渲染阴影+(BOOL)wantsDefaultContentAppearance&#123; return NO;&#125;//画箭头方法- (UIImage *)drawArrowImage:(CGSize)size&#123; UIGraphicsBeginImageContextWithOptions(size, NO, 0); CGContextRef ctx = UIGraphicsGetCurrentContext(); [[UIColor clearColor] setFill]; CGContextFillRect(ctx, CGRectMake(0.0f, 0.0f, size.width, size.height)); CGMutablePathRef arrowPath = CGPathCreateMutable(); CGPathMoveToPoint(arrowPath, NULL, (size.width/2.0f), 0.0f); CGPathAddLineToPoint(arrowPath, NULL, size.width, size.height); CGPathAddLineToPoint(arrowPath, NULL, 0.0f, size.height); CGPathCloseSubpath(arrowPath); CGContextAddPath(ctx, arrowPath); CGPathRelease(arrowPath); UIColor *fillColor = [UIColor yellowColor]; CGContextSetFillColorWithColor(ctx, fillColor.CGColor); CGContextDrawPath(ctx, kCGPathFill); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125;@end 四、UIPopoverPresentationController应用解析UIPopoverPresentationController是iOS8后系统新引入的控制器，其可以很好的兼容iPhone与iPad。UIPopoverPresentationContriller的使用需要和UIViewController结合进行，使用过程示例如下： 12345678UITableViewController tabCon = [[UITableViewController alloc]initWithStyle:UITableViewStylePlain];//设置跳转模式为popover模式tabCon.modalPresentationStyle = UIModalPresentationPopover;//获取到UIPopoverPresentationController对象UIPopoverPresentationController* con = tabCon.popoverPresentationController;//设置弹出的基准视图con.sourceView = self.view;[self presentViewController:tabCon animated:YES completion:nil]; UIPopoverPresentationController中属性如下： 12345678910111213141516171819//设置代理@property (nullable, nonatomic, weak) id &lt;UIPopoverPresentationControllerDelegate&gt; delegate;//设置允许的箭头方向@property (nonatomic, assign) UIPopoverArrowDirection permittedArrowDirections;//设置基准视图或者区域@property (nullable, nonatomic, strong) UIView *sourceView;@property (nonatomic, assign) CGRect sourceRect;//设置是否覆盖基准视图区域@property (nonatomic, assign) BOOL canOverlapSourceViewRect NS_AVAILABLE_IOS(9_0);//设置基准BarButtonItem@property (nullable, nonatomic, strong) UIBarButtonItem *barButtonItem;//设置可以进行用户交互的视图@property (nullable, nonatomic, copy) NSArray&lt;UIView *&gt; *passthroughViews;//设置背景颜色@property (nullable, nonatomic, copy) UIColor *backgroundColor;//设置Margin@property (nonatomic, readwrite) UIEdgeInsets popoverLayoutMargins;//设置自定义视图@property (nullable, nonatomic, readwrite, strong) Class &lt;UIPopoverBackgroundViewMethods&gt; popoverBackgroundViewClass; UIPopoverPresentationControllerDelegate中的方法如下： 12345678//控制器将要弹出时调用- (void)prepareForPopoverPresentation:(UIPopoverPresentationController *)popoverPresentationController;//控制器将要消失时调用- (BOOL)popoverPresentationControllerShouldDismissPopover:(UIPopoverPresentationController *)popoverPresentationController;//控制器已经消失时调用- (void)popoverPresentationControllerDidDismissPopover:(UIPopoverPresentationController *)popoverPresentationController;//控制器接收到弹出消息时调用- (void)popoverPresentationController:(UIPopoverPresentationController *)popoverPresentationController willRepositionPopoverToRect:(inout CGRect *)rect inView:(inout UIView * __nonnull * __nonnull)view; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS使用UIImagePickerController调用系统相机、相册与图库","slug":"238 iOS使用UIImagePickerController调用系统相机、相册与图库","date":"2016-07-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.348Z","comments":true,"path":"2016/07/12/238 iOS使用UIImagePickerController调用系统相机、相册与图库/","link":"","permalink":"http://huishao.cc/2016/07/12/238 iOS使用UIImagePickerController调用系统相机、相册与图库/","excerpt":"","text":"iOS使用UIImagePickerController调用系统相机、相册与图库一、引言UIImagePickerController是系统封装好的一个导航视图控制器，使用其开发者可以十分方便的进行相机相册相关功能的调用。UIImagePickerController继承于UINavigationController，其通过代理的方式将用户获取的图片或者视频文件传入给开发者。 二、UIImagePickerController中属性与方法的应用在使用UIImagePickerController之前，应该先判断设备做支持的媒体文件获取类型，使用如下方法进行判断： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//判断是否支持某个数据提供类型/*UIImagePickerControllerSourceType枚举定义如下:typedef NS_ENUM(NSInteger, UIImagePickerControllerSourceType) &#123; //系统图库 UIImagePickerControllerSourceTypePhotoLibrary, //相机 UIImagePickerControllerSourceTypeCamera, //系统相册 UIImagePickerControllerSourceTypeSavedPhotosAlbum&#125; __TVOS_PROHIBITED;*/+ (BOOL)isSourceTypeAvailable:(UIImagePickerControllerSourceType)sourceType;//判断某个数据提供者所支持的文件格式/*文件格式定义在&lt;MobileCoreServices/MobileCoreServices.h&gt;框架中*/+ (nullable NSArray&lt;NSString *&gt; *)availableMediaTypesForSourceType:(UIImagePickerControllerSourceType)sourceType; //判断所支持的相机设备/*typedef NS_ENUM(NSInteger, UIImagePickerControllerCameraDevice) &#123; //前置摄像头 UIImagePickerControllerCameraDeviceRear, //后置摄像头 UIImagePickerControllerCameraDeviceFront&#125; __TVOS_PROHIBITED;*/+ (BOOL)isCameraDeviceAvailable:(UIImagePickerControllerCameraDevice)cameraDevice NS_AVAILABLE_IOS(4_0); //判断对闪光灯的支持+ (BOOL)isFlashAvailableForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice NS_AVAILABLE_IOS(4_0);//判断相机设备支持的媒体模式/*返回值为如下枚举：typedef NS_ENUM(NSInteger, UIImagePickerControllerCameraCaptureMode) &#123; //照片模式 UIImagePickerControllerCameraCaptureModePhoto, //视频模式 UIImagePickerControllerCameraCaptureModeVideo&#125; __TVOS_PROHIBITED;*/+ (nullable NSArray&lt;NSNumber *&gt; *)availableCaptureModesForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice NS_AVAILABLE_IOS(4_0); 上面提到的定义于&lt;MobileCoreServices/MobileCoreServices.h&gt;框架中的文件类型，列举如下： 1234567891011121314151617181920212223242526272829303132333435363738//图片类型extern const CFStringRef kUTTypeImage __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);//JPEG格式extern const CFStringRef kUTTypeJPEG __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);//JPEG2000格式extern const CFStringRef kUTTypeJPEG2000 __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeTIFF __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypePICT __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeGIF __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypePNG __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeQuickTimeImage __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeAppleICNS __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeBMP __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeICO __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeRawImage __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeScalableVectorGraphics __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeLivePhoto __OSX_AVAILABLE_STARTING(__MAC_NA,__IPHONE_9_1);//视频格式extern const CFStringRef kUTTypeAudiovisualContent __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMovie __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeVideo __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeAudio __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeQuickTimeMovie __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMPEG __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMPEG2Video __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeMPEG2TransportStream __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeMP3 __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMPEG4 __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMPEG4Audio __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeAppleProtectedMPEG4Audio __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeAppleProtectedMPEG4Video __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeAVIMovie __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeAudioInterchangeFileFormat __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeWaveformAudio __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeMIDIAudio __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0); CFStringRef与NSString类型的转换，可以使用如下方法： 1NSString * str = (__bridge NSString*)kUTTypeMovie; UIImagePickerController中更多属性与方法解析如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//设置代理@property(nullable,nonatomic,weak) id &lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate&gt; delegate;//设置书体提供者类型 默认为图库@property(nonatomic) UIImagePickerControllerSourceType sourceType; //设置所需要的数据类型，需要设置为系统定义的文件类型字符串数组 默认为kUTTypeImage@property(nonatomic,copy) NSArray&lt;NSString *&gt; *mediaTypes;//设置是否允许编辑图片 设置为YES，则用户选择图片时可以编辑裁剪图片@property(nonatomic) BOOL allowsEditing;//设置媒体文件的最大时长 默认为10分钟@property(nonatomic) NSTimeInterval videoMaximumDuration; //设置媒体文件的质量 枚举如下：/*typedef NS_ENUM(NSInteger, UIImagePickerControllerQualityType) &#123; UIImagePickerControllerQualityTypeHigh = 0, // 高质量 UIImagePickerControllerQualityTypeMedium = 1, // 中等质量 UIImagePickerControllerQualityTypeLow = 2, // 低质量 UIImagePickerControllerQualityType640x480 NS_ENUM_AVAILABLE_IOS(4_0) = 3, UIImagePickerControllerQualityTypeIFrame1280x720 NS_ENUM_AVAILABLE_IOS(5_0) = 4, UIImagePickerControllerQualityTypeIFrame960x540 NS_ENUM_AVAILABLE_IOS(5_0) = 5,&#125; __TVOS_PROHIBITED;*/@property(nonatomic) UIImagePickerControllerQualityType videoQuality;//设置是否显示相机控制界面@property(nonatomic) BOOL showsCameraControls;//自定义的拍照界面 其会覆盖在原拍照界面上@property(nullable, nonatomic,strong) __kindof UIView *cameraOverlayView NS_AVAILABLE_IOS(3_1); //设置拍照界面的transform@property(nonatomic) CGAffineTransform cameraViewTransform ;//拍照- (void)takePicture NS_AVAILABLE_IOS(3_1); //进行视频捕获- (BOOL)startVideoCapture NS_AVAILABLE_IOS(4_0);//停止视频捕获- (void)stopVideoCapture NS_AVAILABLE_IOS(4_0);//设置相机捕获模式 照片或视频@property(nonatomic) UIImagePickerControllerCameraCaptureMode cameraCaptureMode;//设置相机设备 前置或后置摄像头@property(nonatomic) UIImagePickerControllerCameraDevice cameraDevice;//设置闪光灯模式/*typedef NS_ENUM(NSInteger, UIImagePickerControllerCameraFlashMode) &#123; UIImagePickerControllerCameraFlashModeOff = -1, //关闭 UIImagePickerControllerCameraFlashModeAuto = 0, //自动 UIImagePickerControllerCameraFlashModeOn = 1 //开启&#125; __TVOS_PROHIBITED;*/@property(nonatomic) UIImagePickerControllerCameraFlashMode cameraFlashMode; 三、UIImagePickerControllerDelegate中方法解析123456//相机拍照完成或者从图库相册选择相片完成后触发的回调方法 editingInfo字典中将传入编辑信息- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingImage:(UIImage *)image editingInfo:(nullable NSDictionary&lt;NSString *,id&gt; *)editingInfo NS_DEPRECATED_IOS(2_0, 3_0);//相机录像或者从图库相册选择视频完成后触发的回调方法 info字典中是具体信息- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info;//ImagePickerController取消选择是回调的方法- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker; 上面方法中的编辑字典与信息字典中，约定好了一些键值对，开发者可以通过相应的键获取需要的信息，规则如下： 12345678910111213141516//这个键对应NSString类型的值 意义为媒体文件的格式UIKIT_EXTERN NSString *const UIImagePickerControllerMediaType;//这个键对应UIImage类型的值 意义为获取的原始图片UIKIT_EXTERN NSString *const UIImagePickerControllerOriginalImage;//这个件对应UIIImage类型的值 意义为获取编辑后的图片UIKIT_EXTERN NSString *const UIImagePickerControllerEditedImage;//这个键对应一个NSValue值 可以转为CGRect类型 意义为编辑的图片范围UIKIT_EXTERN NSString *const UIImagePickerControllerCropRect;//这个键对应媒体文件的URLUIKIT_EXTERN NSString *const UIImagePickerControllerMediaURL;//这个键对应图库中的URLUIKIT_EXTERN NSString *const UIImagePickerControllerReferenceURL;//这个键对应一个NSDictionary 里面存放媒体数据UIKIT_EXTERN NSString *const UIImagePickerControllerMediaMetadata;//现场图片数据 相机捕捉图片时会记录声音UIKIT_EXTERN NSString *const UIImagePickerControllerLivePhoto; 四、对捕获的图片与视频进行持久化系统也提供了对相机照片和视频进行存储的方式，列举如下： 12345//将图片数据存储到相册void UIImageWriteToSavedPhotosAlbum(UIImage *image, __nullable id completionTarget, __nullable SEL completionSelector, void * __nullable contextInfo);//将视频保存到相册BOOL UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(NSString *videoPath);void UISaveVideoAtPathToSavedPhotosAlbum(NSString *videoPath, __nullable id completionTarget, __nullable SEL completionSelector, void * __nullable contextInfo); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS第三方文件压缩框架——Godzippa","slug":"237iOS第三方文件压缩框架——Godzippa","date":"2016-07-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.348Z","comments":true,"path":"2016/07/11/237iOS第三方文件压缩框架——Godzippa/","link":"","permalink":"http://huishao.cc/2016/07/11/237iOS第三方文件压缩框架——Godzippa/","excerpt":"","text":"iOS第三方文件压缩框架——GodzippaGodzippa是iOS开发中常用的一个第三方数据压缩框架，其采用类别的方式，为NSData类与NSFileManager类提供了压缩和解压缩数据的方法。 Godzippa的github地址如下：[https://github.com/mattt/Godzippa](https://github.com/mattt/Godzippa)。 NSData类别中提供的方法如下： 123456789101112//进行数据压缩操作- (NSData *)dataByGZipCompressingWithError:(NSError * __autoreleasing *)error;//进行数据压缩操作，支持配置缓存区大小，压缩比等参数- (NSData *)dataByGZipCompressingAtLevel:(int)level windowSize:(int)windowBits memoryLevel:(int)memLevel strategy:(int)strategy error:(NSError * __autoreleasing *)error;//进行数据解压缩操作- (NSData *)dataByGZipDecompressingDataWithError:(NSError * __autoreleasing *)error;- (NSData *)dataByGZipDecompressingDataWithWindowSize:(int)windowBits error:(NSError * __autoreleasing *)error; NSFileManager类别中提供的方法如下： 12345678910111213//压缩文件并写入磁盘 返回值确定压缩操作是否成功- (BOOL)GZipCompressFile:(NSURL *)sourceFile writingContentsToFile:(NSURL *)destinationFile error:(NSError * __autoreleasing *)error;//进行文件压缩，支持配置压缩级别- (BOOL)GZipCompressFile:(NSURL *)sourceFile writingContentsToFile:(NSURL *)destinationFile atLevel:(int)level error:(NSError *__autoreleasing *)error;//进行文件的解压缩- (BOOL)GZipDecompressFile:(NSURL *)sourceFile writingContentsToFile:(NSURL *)destinationFile error:(NSError * __autoreleasing *)error; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS第三方网络诊断库——LDNetDiagnoService","slug":"236iOS第三方网络诊断库——LDNetDiagnoService","date":"2016-07-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.347Z","comments":true,"path":"2016/07/08/236iOS第三方网络诊断库——LDNetDiagnoService/","link":"","permalink":"http://huishao.cc/2016/07/08/236iOS第三方网络诊断库——LDNetDiagnoService/","excerpt":"","text":"iOS第三方网络诊断库——LDNetDiagnoService_IOSLDNetDiagnoService\\_IOS是一个开源的第三方网络诊断框架，它通过ping与traceroute原理来对指定域名进行网络诊断。并且这个库一直在跟进维护，进行IPV\\_6-Only的支持。 LDNetDiagnoService_IOS的git地址如下：[https://github.com/Lede-Inc/LDNetDiagnoService_IOS](https://github.com/Lede-Inc/LDNetDiagnoService_IOS)。 LDNetDiagnoService的使用十分简单，只需要3步即可完成。 首先需要对服务引擎进行初始化，代码如下： 12345678910111213//进行服务引擎的初始化 其中AppCode，AppName，UserID与dormain参数必须填写，其他参数会自动生成service = [[LDNetDiagnoService alloc]initWithAppCode:@\"app编码\" appName:@\"demo\" appVersion:nil userID:@\"UserID\" deviceID:nil dormain:@\"www.baidu.com\" carrierName:nil ISOCountryCode:nil MobileCountryCode:nil MobileNetCode:nil];//设置代理service.delegate = self; 初始化完成服务引擎后，需要开启检测，如下： 1234//开始诊断网络- (void)startNetDiagnosis;//停止诊断网络- (void)stopNetDialogsis; 开始诊断网络后，会通过代理方法将诊断信息回调给开发者，代码如下： 12345678910111213141516171819202122232425/** * 告诉调用者诊断开始 */- (void)netDiagnosisDidStarted&#123; NSLog(@\"开始进行诊断~~\");&#125;/** * 逐步返回监控信息， * 如果需要实时显示诊断数据，实现此接口方法 */- (void)netDiagnosisStepInfo:(NSString *)stepInfo&#123; NSLog(@\"正在诊断：%@\",stepInfo);&#125;/** * 因为监控过程是一个异步过程，当监控结束后告诉调用者； * 在监控结束的时候，对监控字符串进行处理 */- (void)netDiagnosisDidEnd:(NSString *)allLogInfo&#123; NSLog(@\"诊断结束\"); NSLog(@\"%@\",allLogInfo);&#125; Xcode调试区信息如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS第三方星级视图控件——HCSStarRatingView","slug":"235iOS第三方星级视图控件——HCSStarRatingView","date":"2016-07-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.347Z","comments":true,"path":"2016/07/06/235iOS第三方星级视图控件——HCSStarRatingView/","link":"","permalink":"http://huishao.cc/2016/07/06/235iOS第三方星级视图控件——HCSStarRatingView/","excerpt":"","text":"iOS第三方星级视图控件——HCSStarRatingViewHCStarRatingView是一款十分小巧的星级视图控件，其通过原生画图的方式来渲染星级视图页面，同时，其也支持开发者对星级图片的自定义操作。 HCStarRatingView的git地址如下：[https://github.com/hsousa/HCSStarRatingView](https://github.com/hsousa/HCSStarRatingView)。 HCStarRatingView的使用十分简单，示例如下： 1234HCSStarRatingView * starView = [[HCSStarRatingView alloc]initWithFrame:CGRectMake(20, 100, 280, 50)];starView.tintColor = [UIColor redColor];[starView addTarget:self action:@selector(didChange:) forControlEvents:UIControlEventValueChanged];[self.view addSubview:starView]; 效果如下图： 开发者也对其进行一些自定义的设置，列举如下： 12345678910111213141516171819202122232425//设置最大值@property (nonatomic) IBInspectable NSUInteger maximumValue;//设置最小值@property (nonatomic) IBInspectable CGFloat minimumValue;//星级视图当前值@property (nonatomic) IBInspectable CGFloat value;//星星间间距@property (nonatomic) IBInspectable CGFloat spacing;//是否允许选择半星@property (nonatomic) IBInspectable BOOL allowsHalfStars;//是否是否允许精确选择 可以根据选择位置进行精确@property (nonatomic) IBInspectable BOOL accurateHalfStars;//是否连续调用回调方法 如果设置为YES 则在手指拖动时 会持续调用回调方法 如果设置为NO，则只有拖动结束后才调用回调@property (nonatomic) IBInspectable BOOL continuous;//是否允许成为第一响应@property (nonatomic) BOOL shouldBecomeFirstResponder;//添加手势时使用@property (nonatomic, copy) HCSStarRatingViewShouldBeginGestureRecognizerBlock shouldBeginGestureRecognizerBlock;//自定义星星视图UI//设置空星的图片@property (nonatomic, strong) IBInspectable UIImage *emptyStarImage;//设置半星的图片@property (nonatomic, strong) IBInspectable UIImage *halfStarImage;//设置全星时的图片@property (nonatomic, strong) IBInspectable UIImage *filledStarImage; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayout","slug":"234iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayout","date":"2016-07-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.347Z","comments":true,"path":"2016/07/05/234iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayout/","link":"","permalink":"http://huishao.cc/2016/07/05/234iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayout/","excerpt":"","text":"iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayoutUICollectionViewLeftAlignedLayout是第三方的左对齐布局管理类，其继承自UICollectionViewFlowLayout，使用其可以方便的进行左对齐的瀑布流界面布局。 UICollectionViewLeftAlignedLayout的git地址如下：[https://github.com/mokagio/UICollectionViewLeftAlignedLayout](https://github.com/mokagio/UICollectionViewLeftAlignedLayout)。 使用示例如下： 12345678910111213141516171819202122232425262728293031323334#import &lt;UICollectionViewLeftAlignedLayout.h&gt;@interface ViewController ()&lt;UICollectionViewDataSource,UICollectionViewDelegateFlowLayout&gt;@property(nonatomic,strong)UICollectionView * collectionView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UICollectionViewLeftAlignedLayout* layout = [[UICollectionViewLeftAlignedLayout alloc]init]; self.collectionView = [[UICollectionView alloc]initWithFrame:self.view.frame collectionViewLayout:layout]; self.collectionView.dataSource = self; self.collectionView.delegate=self; [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@\"cellID\"]; [self.view addSubview:self.collectionView];&#125;-(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; return CGSizeMake(arc4random()%100+50, 100);&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"cellID\" forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125;@end 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS中表单视图第三方控件——FXForms","slug":"233iOS中表单视图第三方控件——FXForms","date":"2016-07-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.347Z","comments":true,"path":"2016/07/04/233iOS中表单视图第三方控件——FXForms/","link":"","permalink":"http://huishao.cc/2016/07/04/233iOS中表单视图第三方控件——FXForms/","excerpt":"","text":"iOS中表单视图第三方控件——FXForms一、引言表单视图是移动开发中十分常用的一种UI方式。在iOS开发中，系统的UITableView可以用来创建表单视图，其界面的渲染与逻辑的处理需要开发者实现许多代理方法。FXForms是一个第三方的表单创建工具，其通过配置的方式来进行表单界面的创建，并且其中为开发者封装好了各种常用类型的表单cell。 FXForms的github地址如下：[https://github.com/nicklockwood/FXForms](https://github.com/nicklockwood/FXForms)。 二、使用FXForms进行表单视图的创建FXForms框架中提供了一个FXFormViewController视图控制器类，开发者可以直接编写继承于这个类的ViewController来便捷的创建表单界面，首先，FXForms是通过节点配置的方式来进行表单的创建的，表单中每一个cell都是一个节点，这个节点可以是简单的单节点，也可以是父节点，点击父节点后，会跳转新的视图控制器，父节点中可以进行层层嵌套。对于每一个节点，开发者可以设置一个节点类型，不同的节点类型将展现不同的UI，实现不同的功能。 FXForms中的节点由FXForm协议来进行配置，创建一个简单的表单视图，示例如下： 123456789101112131415161718//视图控制器类部分@interface ViewController : FXFormViewController@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //节点信息设置 self.formController.form = [MyForm new];&#125;@end//节点类配置@interface MyForm : NSObject&lt;FXForm&gt;@property(nonatomic,strong)NSString * email;@property(nonatomic,strong)NSString * password;@property(nonatomic,assign)BOOL rememberMe;@end@implementation MyForm@end 上面的MyForm类中只定义了一些属性，并没有进行任何方法的实现，FXForms框架中实现了这样的功能，如果开发者不进行节点信息的配置，则FXForms会自动根据节点配置类中所有的属性来推断节点的类型，如上所示，NSString类型的属性会被自动推断成带文本框的cell，BOOL类型的属性会被自动推断成带UISwitch控件的cell。运行效果如下： 开发者可以为节点配置类中的每一个属性提供一个约定好的方法，在方法中对此属性对应的节点进行配置，这个约定好的方法名需要与属性对应，其格式是使用属性名加上Field，示例如下： 12345678910111213141516@implementation MyForm//方法名必须是 属性名+Field 返回为NSDictionary字典 字典中为节点的配置信息-(NSDictionary *)emailField&#123; //配置节点的类型 点击后 将弹出时间选择控件 return @&#123;FXFormFieldType:FXFormFieldTypeDate&#125;;&#125;-(NSDictionary *)passwdField&#123; //设置节点名称 return @&#123;FXFormFieldTitle:@\"名称\"&#125;;&#125;-(NSDictionary *)rememberMeField&#123; //设置节点头视图名称 return @&#123;FXFormFieldHeader:@\"配置\"&#125;;&#125;@end 运行工程，效果如下图所示： 返回的配置字典中可以用来配置的属性定义如下： 12345678910111213141516171819202122232425262728293031323334//配置此节点的标识符UIKIT_EXTERN NSString *const FXFormFieldKey;//配置此节点的类型UIKIT_EXTERN NSString *const FXFormFieldType; //指定当前节点属性对应的类 一般不需设置UIKIT_EXTERN NSString *const FXFormFieldClass;//设置当前节点对应的cell类UIKIT_EXTERN NSString *const FXFormFieldCell;//设置当前节点显示的名称UIKIT_EXTERN NSString *const FXFormFieldTitle;//设置当前节点的placeHolderUIKIT_EXTERN NSString *const FXFormFieldPlaceholder;//设置节点上默认显示的文字UIKIT_EXTERN NSString *const FXFormFieldDefaultValue; //设置选项数组 这个属性的设置 必须配合特定配型的cell使用UIKIT_EXTERN NSString *const FXFormFieldOptions;//如果某个节点是一个数组 则FXFormFieldTemplate可以用来设置数组中节点的属性UIKIT_EXTERN NSString *const FXFormFieldTemplate;//进行类型转换UIKIT_EXTERN NSString *const FXFormFieldValueTransformer;//设置节点的触发方法UIKIT_EXTERN NSString *const FXFormFieldAction;//连接StoryboardSegueUIKIT_EXTERN NSString *const FXFormFieldSegue;//设置节点头部内容UIKIT_EXTERN NSString *const FXFormFieldHeader;//设置节点尾部内容UIKIT_EXTERN NSString *const FXFormFieldFooter;//设置是否是内嵌节点 对于父节点或者数组类界定 这个如果设置为@YES 则会在当前界面中展示表单 如果设置为@NO，则会在新的视图控制器中展示UIKIT_EXTERN NSString *const FXFormFieldInline;//对于数组类型的节点，设置是否支持排序 设置为@YES则为支持排序UIKIT_EXTERN NSString *const FXFormFieldSortable;//设置选中cell后跳转的ViewControllerUIKIT_EXTERN NSString *const FXFormFieldViewController; 关于设置节点的类型，FXFormFieldType可以设置的值有如下几种： 123456789101112131415161718192021222324252627282930313233343536//默认的节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeDefault;//文本标签节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeLabel;//输入框节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeText;//长文本输入节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeLongText; //URL节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeURL;//Email节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeEmail; //号码节点类型UIKIT_EXTERN NSString *const FXFormFieldTypePhone; //密码框节点类型UIKIT_EXTERN NSString *const FXFormFieldTypePassword;//数字节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeNumber;//只允许输入整数的节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeInteger;//无符号整数节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeUnsigned; //浮点节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeFloat;//BOOL节点类型 默认带UISwitch控件UIKIT_EXTERN NSString *const FXFormFieldTypeBoolean;//选项节点类型 默认带对号符号UIKIT_EXTERN NSString *const FXFormFieldTypeOption;//日期节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeDate;//时间节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeTime;//日期时间节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeDateTime;//图片节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeImage; FXForms中也提供了许多封装好的cell，列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//默认的cell@interface FXFormDefaultCell : FXFormBaseCell@end//带文本输入框的cell@interface FXFormTextFieldCell : FXFormBaseCell@property (nonatomic, readonly) UITextField *textField;@end//带文本输入视图的cell@interface FXFormTextViewCell : FXFormBaseCell@property (nonatomic, readonly) UITextView *textView;@end//带UISwitch控件的cell@interface FXFormSwitchCell : FXFormBaseCell@property (nonatomic, readonly) UISwitch *switchControl;@end//带UIStepper控件的cell@interface FXFormStepperCell : FXFormBaseCell@property (nonatomic, readonly) UIStepper *stepper;@end//带UISlider控件的cell@interface FXFormSliderCell : FXFormBaseCell@property (nonatomic, readonly) UISlider *slider;@end//带日期选择控件的cell@interface FXFormDatePickerCell : FXFormBaseCell@property (nonatomic, readonly) UIDatePicker *datePicker;@end//带图片选择控件的cell@interface FXFormImagePickerCell : FXFormBaseCell@property (nonatomic, readonly) UIImageView *imagePickerView;@property (nonatomic, readonly) UIImagePickerController *imagePickerController;@end//带自定义PickerView的cell@interface FXFormOptionPickerCell : FXFormBaseCell@property (nonatomic, readonly) UIPickerView *pickerView;@end//带UISegmentedControl控件的cell@interface FXFormOptionSegmentsCell : FXFormBaseCell@property (nonatomic, readonly) UISegmentedControl *segmentedControl;@end 还有一点需要注意，如果是继承与FXFormViewController的视图控制器，其节点设置的action方法要在视图控制器中进行实现。 三、通过协议方法来进行节点配置上面演示的创建表格视图的方式是在节点配置类中创建属性，分别配置属性的节点信息来创建每一个cell，开发者也可以不创建属性，或者创建属性但是不以属性为节点来进行cell配置，使用FXFrom协议的方法，也可以完成节点的创建和配置，示例如下： 12345678910111213141516@interface MyForm : NSObject&lt;FXForm&gt;@end@implementation MyForm//创建与配置节点- (NSArray *)fields&#123; return @[ //这里面配置字典的方法和属性字典的配置方法一一致 @&#123;FXFormFieldKey: @\"email\", FXFormFieldTitle: @\"email\"&#125;, @&#123;FXFormFieldKey: @\"phone\", FXFormFieldTitle: @\"phone\"&#125;, @&#123;FXFormFieldKey: @\"address\", FXFormFieldTitle: @\"address\"&#125;, @&#123;FXFormFieldKey: @\"name\", FXFormFieldTitle: @\"name\"&#125; ];&#125;@end 效果如下： -(NSArray *)fields方法是FXForm协议中的一个方法，在这个方法中，可以直接进行节点的创建和配置，FXForm协议中还提供了两个方法，意义如下： 1234//这个方法用于配置额外的节点，如果需要某些节点不对应任何属性，可以在这个方法中配置- (NSArray *)extraFields;//这个方法需要返回一个字符串数组，如果需要某些属性不对应节点，即有属性的存在，但是不生成cell，可以将属性名传入返回- (NSArray *)excludedFields; 节点也可以进行复合，例如可以将一个节点配置类作为属性设置给另一个节点配置类，示例如下： 123456789101112131415161718//子节点信息配置类@interface SubForm : NSObject&lt;FXForm&gt;@property(nonatomic,assign)NSInteger age;@property(nonatomic,assign)NSDate * date;@end@implementation SubForm@end//父节点信息配置类@interface MyForm : NSObject&lt;FXForm&gt;@property(nonatomic,strong)NSString * email;@property(nonatomic,strong)NSString * passwd;@property(nonatomic,assign)BOOL rememberMe;//其中有属性为子节点@property(nonatomic,strong)SubForm * subForm;@end@implementation MyForm@end 子节点会被默认包装在新的视图控制器中，也可以设置FXFormFieldInline为@YES来使其复合进当前视图控制器，效果如下： 四、关于自定义视图控制器如果开发者的视图控制器并不是继承于FXFormViewController，也可以使用FXForms来快捷的创建表单视图，开发者自定义的视图控制器需要遵守FXFormControllerDelegate协议，示例如下: 12345678910111213141516171819@interface ViewController : UIViewController&lt;FXFormControllerDelegate&gt;//系统的tableView@property(nonatomic,strong)UITableView * tableView;//FX表单控制器@property(nonatomic,strong)FXFormController * formController;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.tableView = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStyleGrouped]; self.formController = [[FXFormController alloc] init]; self.formController.tableView = self.tableView; self.formController.delegate = self; self.formController.form = [[MyForm alloc] init]; self.formController.form = [MyForm new]; [self.view addSubview:self.tableView];&#125;@end 上面的代码极大了简化了ViewController中的代码量。 五、对Cell进行属性设置在进行节点属性字典的配置时，可以通过访问属性路径的方式来对cell的属性进行一些配置，例如： 123-(NSDictionary *)passwdField&#123; return @&#123;@\"textLabel.textColor\":[UIColor redColor]&#125;;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS中第三方有序字典框架——M13OrderedDictionary","slug":"232iOS中第三方有序字典框架——M13OrderedDictionary","date":"2016-06-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.347Z","comments":true,"path":"2016/07/01/232iOS中第三方有序字典框架——M13OrderedDictionary/","link":"","permalink":"http://huishao.cc/2016/07/01/232iOS中第三方有序字典框架——M13OrderedDictionary/","excerpt":"","text":"iOS中第三方有序字典框架——M13OrderedDictionary一、引言M13OrderedDictionary是拥有字典和数组功能的第三方集合序列，开发者可以通过索引和键值来实现对其中元素的访问。其实现了NSArray和NSDictionary中的所有方法，并且支持KVC与KVO。 M13OederedDictionary中提供的方法包括： 1.创建与初始化。 2.访问键和值 3.查询与搜索。 4.发送消息。 5.比较与排序。 6.枚举与遍历。 7.描述与存储。 8.KVO键值监听。 9.KVC键值编码。 10.索引与下标。 另外，M13OrderedDictionary针对Xcode7也做了许多优化，例如引入了泛型的代码支持的风格。M13OrderedDictionary库的git地址如下：[https://github.com/Marxon13/M13OrderedDictionary](https://github.com/Marxon13/M13OrderedDictionary)。 二、M13OrderedDictionary中方法与属性解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228//类方法创建实例对象//默认的初始化方法+ (instancetype)orderedDictionary;//使用M13OrderedDictionary来创建实例对象+ (instancetype)orderedDictionaryWithOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;//通过文件来创建实例对象+ (instancetype)orderedDictionaryWithContentsOfFile:(NSString *)path;//通过URL来创建实例对象+ (instancetype)orderedDictionaryWithContentsOfURL:(NSURL *)URL;//创建单键值实例对象+ (instancetype)orderedDictionaryWithObject:(M13GenericType(ObjectType, id))anObject pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))aKey;//通过NSDictionary创建实例对象+ (instancetype)orderedDictionaryWithDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)entries;//初始化方法创建实例对象//默认的初始化方法- (instancetype)init;//使用M13OrderedDictionary来进行初始化- (instancetype)initWithOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;//使用M13OrderedDictionary来进行初始化 可选是否对其中元素进行复制操作- (instancetype)initWithOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary copyEntries:(BOOL)flag;//通过文件来进行初始化- (instancetype)initWithContentsOfFile:(NSString *)path;//通过url来进行初始化- (instancetype)initWithContentsOfURL:(NSURL *)URL;//通过NSDictionary对象来进行初始化- (instancetype)initWithContentsOfDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)entries;//通过键数组与值数组来进行初始化- (instancetype)initWithObjects:(NSArray M13Generics(ObjectType) *)orderedObjects pairedWithKeys:(NSArray M13Generics(KeyType) *)orderedKeys NS_DESIGNATED_INITIALIZER;//方法//判断字典中是否包含某个元素- (BOOL)containsObject:(M13GenericType(ObjectType, id))object;//判断字典中是否包含某个键值对- (BOOL)containsObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;//判断字典中是否包含某个键值对 传入的字典参数需要为单键值字典- (BOOL)containsEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;//获取字典中元素个数@property (nonatomic, readonly) NSUInteger count;//获取字典中最后一个元素的值@property (nonatomic, readonly, M13_NULLABLE) M13GenericType(ObjectType, id) lastObject;//获取字典中最后一个元素的键@property (nonatomic, readonly, M13_NULLABLE) M13GenericType(KeyType, id&lt;NSCopying&gt;) lastKey;//获取字典中最后一个元素键值对@property (nonatomic, readonly, M13_NULLABLE) NSDictionary M13Generics(KeyType, ObjectType) *lastEntry;//通过某个下标获取字典中的元素的值- (M13GenericType(ObjectType, id))objectAtIndex:(NSUInteger)index;//通过某个下标获取字典中的元素的键- (M13GenericType(KeyType, id&lt;NSCopying&gt;))keyAtIndex:(NSUInteger)index;//通过某个下标获取字段中的元素 返回的为单键值对NSDictionary对象- (NSDictionary M13Generics(KeyType, ObjectType) *)entryAtIndex:(NSUInteger)index;//通过一组下标获取一组元素的值- (NSArray M13Generics(ObjectType) *)objectsAtIndices:(NSIndexSet *)indeces;//通过一组下标获取一组元素的键- (NSArray M13Generics(KeyType) *)keysAtIndices:(NSIndexSet *)indices;//通过一组下标获取一组元素 这个方法获取的是有序集合- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)entriesAtIndices:(NSIndexSet *)indices;//通过一组下标获取一组元素 这个方法获取的是无序集合- (NSDictionary M13Generics(KeyType, ObjectType) *)unorderedEntriesAtIndices:(NSIndexSet *)indices;//示例中包含的无序字典集合@property (nonatomic, readonly) NSDictionary M13Generics(KeyType, ObjectType) *unorderedDictionary;//所有键组成的数组@property (nonatomic, readonly) NSArray M13Generics(KeyType) *allKeys;//所有值组成的数组@property (nonatomic, readonly) NSArray M13Generics(ObjectType) *allObjects;//获取某个值对应的所有键组成的数组- (NSArray M13Generics(KeyType) *)allKeysForObject:(M13GenericType(ObjectType, id))anObject;//获取某个键对应的值- (M13_NULLABLE M13GenericType(ObjectType, id))objectForKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;//获取某些键对应的值 如果没有找到 则可以设置默认返回的值 即参数anObject- (NSArray M13Generics(ObjectType) *)objectForKeys:(NSArray M13Generics(KeyType) *)keys notFoundMarker:(M13GenericType(ObjectType, id))anObject;//所有值的枚举@property (nonatomic, readonly) NSEnumerator M13Generics(ObjectType) *objectEnumerator;//所有键的枚举@property (nonatomic, readonly) NSEnumerator M13Generics(KeyType) *keyEnumerator;//所有元素的枚举@property (nonatomic, readonly) NSEnumerator M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *entryEnumerator;//所有值的反向枚举@property (nonatomic, readonly) NSEnumerator M13Generics(ObjectType) *reverseObjectEnumerator;//所有键的反向枚举@property (nonatomic, readonly) NSEnumerator M13Generics(KeyType) *reverseKeyEnumerator;//所有元素的反向枚举@property (nonatomic, readonly) NSEnumerator M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *reverseEntryEnumerator;//获取某个值的下标 找不到会返回NSNotFound- (NSUInteger)indexOfObject:(M13GenericType(ObjectType, id))object;//获取某个键的下标 找不到会返回NSNotFound- (NSUInteger)indexOfKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;//获取某个元素的下标 找不到会返回NSNotFound- (NSUInteger)indexOfEntryWithObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;//通过NSDictionary来获取某个元素的下标 找不到会返回NSNotFound- (NSUInteger)indexOfEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;//通过元素的值在某个范围内查询下标- (NSUInteger)indexOfObject:(M13GenericType(ObjectType, id))object inRange:(NSRange)range;//通过元素的键在某个范围内查询下标- (NSUInteger)indexOfKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key inRange:(NSRange)range;//在某个范围内查询某个元素的下标- (NSUInteger)indexOfEntryWithObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key inRange:(NSRange)range;- (NSUInteger)indexOfEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry inRange:(NSRange)range;//查找与某个元素的值相同的元素下标- (NSUInteger)indexOfObjectIdenticalTo:(M13GenericType(ObjectType, id))object;//查找获取与某个元素的值相同的元素的键- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectIdenticalTo:(M13GenericType(ObjectType, id))object;//查找与某个元素的值相同的元素下标 在某个范围内进行查找- (NSUInteger)indexOfObjectIdenticalTo:(M13GenericType(ObjectType, id))object inRange:(NSRange)range;//查找获取与某个元素的值相同的元素的键 在某个范围内进行查找- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectIdenticalTo:(M13GenericType(ObjectType, id))object inRange:(NSRange)range;//符合查找block中检测条件的元素的下标/*开发者可以在block中获取到遍历出的 object与index，返回值决定是否停止查找*/- (NSUInteger)indexOfObjectPassingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//同上 获取到的是键- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectPassingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx,BOOL *stop))predicate;//同上 只是这个方法可以设置枚举类型/*typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) &#123; NSEnumerationConcurrent = (1UL &lt;&lt; 0), //正向枚举 NSEnumerationReverse = (1UL &lt;&lt; 1), //逆向枚举&#125;;*/- (NSUInteger)indexOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//同上 获取到的是元素- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx,BOOL *stop))predicate;//在一定下标集合中进行查找- (NSUInteger)indexOfObjectAtIndices:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//同上- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectAtIndices:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj,NSUInteger idx,BOOL *stop))predicate;//在范围内进行比较查询- (NSUInteger)indexOfObject:(M13GenericType(ObjectType, id))object inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator)cmp;//同上- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObject:(M13GenericType(ObjectType, id))object inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator)cmp;//进行一组元素下标的查询- (NSIndexSet *)indicesOfObjectsPassingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;- (NSIndexSet *)indicesOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//进行一组元素键的查询- (NSArray M13Generics(KeyType) *)keysOfObjectsPassingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;- (NSArray M13Generics(KeyType) *)keysOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//向字典中的每一个元素发送消息- (void)makeObjectsPerformSelector:(SEL)aSelector;//向字典中的每一个元素发送消息 带参数- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)anObject;//对字典中的元素进行枚举遍历- (void)enumerateObjectsUsingBlock:(void (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))block;- (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))block;//在一定范围内进行枚举- (void)enumerateObjectsAtIndices:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts usingBlock:(void (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))block;//获取与另一个数组中第一个相同的元素的值- (M13GenericType(ObjectType, id))firstObjectInCommonWithOrderedDictionary:(M13OrderedDictionary *)otherOrderedDictionary;//获取与另一个数组中第一个相同的元素的键- (M13GenericType(ObjectType, id&lt;NSCopying&gt;))firstKeyInCommonWithOrderedDictionary:(M13OrderedDictionary *)otherOrderedDictionary;//获取与另一个数组中第一个相同的元素- (NSDictionary M13Generics(KeyType, ObjectType) *)firstEntryInCommonWithOrderedDictionary:(M13OrderedDictionary *)otherOrderedDictionary;//判断两个字典是否相同- (BOOL)isEqualToOrderedDictionary:(M13OrderedDictionary *)otherOrderedDictionary;//向字典中追加键值对- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionaryByAddingObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))aKey;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionaryByAddingEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;//向字典中追加一组键值对- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionaryByAddingObjects:(NSArray M13Generics(ObjectType) *)orderedObjects pairedWithKeys:(NSArray M13Generics(KeyType) *)orderedKeys;//筛选元素- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)filteredOrderDictionarysUsingPredicateForObjects:(NSPredicate *)predicate;//获取一定范围内的子字典- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)subOrderedDictionaryWithRange:(NSRange)range;//进行元素排序相关的方法- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingFunction:(NSInteger (*)(M13GenericType(ObjectType, id),M13GenericType(ObjectType, id),void * M13__NULLABLE))comparator context:(M13_NULLABLE void *)context;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingFunction:(NSInteger (*)(M13GenericType(KeyType, id&lt;NSCopying&gt;),M13GenericType(KeyType, id&lt;NSCopying&gt;),void * M13__NULLABLE))comparator context:(M13_NULLABLE void *)context;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingFunction:(NSInteger (*)(M13GenericType(ObjectType, id),M13GenericType(ObjectType, id), void * M13__NULLABLE))comparator context:(M13_NULLABLE void *)context hint:(M13_NULLABLE NSData *)hint;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingFunction:(NSInteger (*)(M13GenericType(KeyType, id&lt;NSCopying&gt;),M13GenericType(KeyType, id&lt;NSCopying&gt;),void * M13__NULLABLE))comparator context:(M13_NULLABLE void *)context hint:(M13_NULLABLE NSData *)hint;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingDescriptors:(NSArray *)descriptors;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingDescriptors:(NSArray *)descriptors;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingSelector:(SEL)comparator;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingSelector:(SEL)comparator;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingComparator:(NSComparator)cmptr;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingComparator:(NSComparator)cmptr;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr;//写入文件- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)flag;//写入到URL- (BOOL)writeToURL:(NSURL *)aURL atomically:(BOOL)flag;//添加监听- (void)addObserver:(NSObject *)anObserver toObjectsAtIndices:(NSIndexSet *)indices forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(M13_NULLABLE void *)context;- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(M13_NULLABLE void *)context;//移除监听- (void)removeObserver:(NSObject *)anObserver fromObjectsAtIndices:(NSIndexSet *)indices forKeyPath:(NSString *)keyPath;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(M13_NULLABLE void *)context;//KVC相关方法- (void)setValue:(M13_NULLABLE id)value forKey:(NSString *)key;- (void)setValue:(M13_NULLABLE id)value forKeyPath:(NSString *)keyPath;- (id)valueForKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;//归档相关方法- (void)encodeWithCoder:(NSCoder *)aCoder;- (id)initWithCoder:(NSCoder *)decoder;//copy相关方法- (id)copy;- (id)copyWithZone:(M13_NULLABLE NSZone *)zone;- (id)mutableCopy;- (id)mutableCopyWithZone:(NSZone *)zone; 三、M13MutableOrderedDictionary基于M13OrderedDictionary，M13MutableOrderedDictionary为可变的有序字典类，其中方法解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//类创建方法+ (instancetype)orderedDictionaryWithCapacity:(NSUInteger)numEntries;//初始化方法- (id)initWithCapacity:(NSUInteger)numEntries;//添加键值对的方法- (void)addObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)addEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;- (void)addEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;- (void)addEntriesFromDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)dictionary;//插入键值对的方法- (void)insertObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key atIndex:(NSUInteger)index;- (void)insertEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry atIndex:(NSUInteger)index;- (void)insertEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary atIndex:(NSUInteger)index;- (void)insertEntriesFromDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)dictionary atIndex:(NSUInteger)index;//设置键值对的方法- (void)setObject:(M13GenericType(ObjectType, id))object forKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))aKey;- (void)setEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;- (void)setEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;- (void)setEntriesFromDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)dictionary;- (void)setObject:(M13GenericType(ObjectType, id))object forKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))aKey atIndex:(NSUInteger)index;- (void)setEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry atIndex:(NSUInteger)index;- (void)setEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary atIndex:(NSUInteger)index;- (void)setEntriesFromDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)dictionary atIndex:(NSUInteger)index;//移除键值对的方法- (void)removeObjectForKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)removeObjectsForKeys:(NSArray M13Generics(KeyType) *)keys;- (void)removeAllObjects;- (void)removeAllEntries;- (void)removeLastEntry;- (void)removeEntryWithObject:(M13GenericType(ObjectType, id))object;- (void)removeEntryWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)removeEntryWithObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)removeEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;- (void)removeEntryWithObject:(M13GenericType(ObjectType, id))object inRange:(NSRange)range;- (void)removeEntryWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key inRange:(NSRange)range;- (void)removeEntryWithObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key inRange:(NSRange)ramge;- (void)removeEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry inRange:(NSRange)range;- (void)removeEntryAtIndex:(NSUInteger)index;- (void)removeEntriesAtIndices:(NSIndexSet *)indices;- (void)removeEntryWithObjectIdenticalTo:(M13GenericType(ObjectType, id))anObject;- (void)removeEntryWithObjectIdenticalTo:(M13GenericType(ObjectType, id))anObject inRange:(NSRange)range;- (void)removeEntriesWithObjectsInArray:(NSArray M13Generics(ObjectType) *)array;- (void)removeEntriesWithKeysInArray:(NSArray M13Generics(KeyType) *)array;- (void)removeEntriesInRange:(NSRange)range;//替换键值对的方法- (void)replaceEntryAtIndex:(NSInteger)index withObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)replaceEntryAtIndex:(NSUInteger)index withEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;- (void)replaceEntriesAtIndices:(NSIndexSet *)indices withObjects:(NSArray M13Generics(ObjectType) *)objects pairedWithKeys:(NSArray M13Generics(KeyType) *)keys;- (void)replaceEntriesAtIndices:(NSIndexSet *)indices withEntries:(NSArray M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *)orderedEntries;- (void)replaceEntriesAtIndices:(NSIndexSet *)indiceswithEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;- (void)replaceEntriesInRange:(NSRange)range withObjectsFromArray:(NSArray M13Generics(ObjectType) *)objects pairedWithKeysFromArray:(NSArray M13Generics(KeyType) *)keys inRange:(NSRange)range2;- (void)replaceEntriesInRange:(NSRange)range withEntriesFrom:(NSArray M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *)orderedEntries inRange:(NSRange)range2;- (void)replaceEntriesInRange:(NSRange)rangewithEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)dictionary inRange:(NSRange)range2;- (void)replaceEntriesInRange:(NSRange)range withObjectsFromArray:(NSArray M13Generics(ObjectType) *)objects pairedWithKeysFromArray:(NSArray M13Generics(KeyType) *)keys;- (void)replaceEntriesInRange:(NSRange)range withEntriesFrom:(NSArray M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *)orderedEntries;- (void)replaceEntriesInRange:(NSRange)rangewithEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)dictionary;- (void)setEntriesToObjects:(NSArray M13Generics(ObjectType) *)objects pairedWithKeys:(NSArray M13Generics(KeyType) *)keys;- (void)setEntriesToOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;//进行元素筛选- (void)filterEntriesUsingPredicateForObjects:(NSPredicate *)predicate;//进行元素交换- (void)exchangeEntryAtIndex:(NSUInteger)idx1 withEntryAtIndex:(NSUInteger)idx2;//进行元素排序- (void)sortEntriesByObjectUsingDescriptors:(NSArray *)descriptors;- (void)sortEntriesByKeysUsingDescriptors:(NSArray *)descriptors;- (void)sortEntriesByObjectUsingComparator:(NSComparator)cmptr;- (void)sortEntriesByKeysUsingComparator:(NSComparator)cmptr;- (void)sortEntriesByObjectWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr;- (void)sortEntriesByKeysWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr;- (void)sortEntriesByObjectUsingFunction:(NSInteger (*)(M13GenericType(ObjectType, id), M13GenericType(ObjectType, id), void * M13__NULLABLE))compare context:(M13_NULLABLE void *)context;- (void)sortEntriesByKeysUsingFunction:(NSInteger (*)(M13GenericType(KeyType, id&lt;NSCopying&gt;), M13GenericType(KeyType, id&lt;NSCopying&gt;), void * M13__NULLABLE))compare context:(M13_NULLABLE void *)context;- (void)sortEntriesByObjectUsingSelector:(SEL)comparator;- (void)sortEntriesByKeysUsingSelector:(SEL)comparator; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS中支持HTML文本的标签控件——MDHTMLLabel","slug":"230iOS中支持HTML文本的标签控件——MDHTMLLabel","date":"2016-06-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.346Z","comments":true,"path":"2016/06/30/230iOS中支持HTML文本的标签控件——MDHTMLLabel/","link":"","permalink":"http://huishao.cc/2016/06/30/230iOS中支持HTML文本的标签控件——MDHTMLLabel/","excerpt":"","text":"iOS中支持HTML文本的标签控件——MDHTMLLabel一、引言在iOS开发中对HTML的处理很多时候除了使用WebView外，还需要原生的控件对其进行渲染，例如将HTML字符串渲染为图文混排的View视图。Git上有很多轻量级的HTML渲染框架，列举一些如下： RTLabel：基于UIView的HTML文本渲染控件，git地址：https://github.com/honcheng/RTLabel。 RCLabel：与RTLabel思路相同，基于RCLabel之上，也是UIView的子类，支持了对HTML中的本地图片标签进行渲染。git地址：https://github.com/Janak-Nirmal/RichContentLabel。 MDHTMLLabel：与RTLabel和RCLabel不同的是，其是UILabel的子类，更加轻量级，不能支持图片标签。git地址：https://github.com/mattdonnelly/MDHTMLLabel。 关于RCLabel对图片便签的支持，其只能支持本地的图片，不能支持远程URL图片链接，这在开发中将十分局限，以前我曾加RCLabel做了改造，加了支持远程图片URL的方法，我把它集成在了一个基础框架中，需要的伙伴可以参考下，git地址：[https://github.com/ZYHshao/YHBaseFoundationTest](https://github.com/ZYHshao/YHBaseFoundationTest)。配套的讲解博客地址如下：[http://my.oschina.net/u/2340880/blog/499311](http://my.oschina.net/u/2340880/blog/499311)。 本篇博客主要讨论MDHTMLLabel的使用。 二、MDHTMLLabel的创建与设置MDHTMLLabel框架十分小巧，其中只有两个文件，总计2000余行代码。通过HTML字符串来创建一个MDHTMLLabel控件示例代码如下： 12345NSString * kDemoText = @\"&lt;a href='http://github.com/mattdonnelly/MDHTMLLabel'&gt;MDHTMLLabel&lt;/a&gt; is a lightweight, easy to use replacement for &lt;b&gt;UILabel&lt;/b&gt; which allows you to fully &lt;font face='Didot-Italic' size='19'&gt;customize&lt;/font&gt; the appearence of the text using HTML (with a few added features thanks to &lt;b&gt;CoreText&lt;/b&gt;), as well letting you handle whenever a user taps or holds down on link and automatically detects ones not wrapped in anchor tags/&gt;\";MDHTMLLabel *htmlLabel = [[MDHTMLLabel alloc] initWithFrame:self.view.frame];htmlLabel.numberOfLines = 0;htmlLabel.htmlText = kDemoText;[self.view addSubview:htmlLabel]; 效果如下图所示： MDHTMLLabel中可以设置的一些属性解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940//设置超链接文字的属性字典 和设置AttributeString方法一致@property (nonatomic, strong) NSDictionary *linkAttributes;//设置超链接文字激活时的属性字典@property (nonatomic, strong) NSDictionary *activeLinkAttributes;//设置超链接非激活时的属性字典@property (nonatomic, strong) NSDictionary *inactiveLinkAttributes;//设置超链接文字触发长按事件的最小按下时间@property (nonatomic, assign) NSTimeInterval minimumPressDuration;//设置label文件阴影的模糊半径@property (nonatomic, assign) CGFloat shadowRadius;//设置label在高亮状态下的文字模糊半径 注：非高亮状态的由原生UILabel的属性设置@property (nonatomic, assign) CGFloat highlightedShadowRadius;//设置label在高亮状态下的文字阴影偏移 注：非高亮状态的由原生UILabel的属性设置@property (nonatomic, assign) CGSize highlightedShadowOffset;//设置在label高亮状态下的文字阴影颜色 注：非高亮状态的由原生UILabel的属性设置@property (nonatomic, strong) UIColor *highlightedShadowColor;//设置首行文字的缩进距离@property (nonatomic, assign) CGFloat firstLineIndent;//设置文字的行间距@property (nonatomic, assign) CGFloat leading;//设置行高的倍数@property (nonatomic, assign) CGFloat lineHeightMultiple;//设置文字内容的边距@property (nonatomic, assign) UIEdgeInsets textInsets;//设置文字垂直方向的对其模式 默认为居中对其 MDHTMLLabelVerticalAlignment枚举意义如下:/*typedef NS_ENUM(NSUInteger, MDHTMLLabelVerticalAlignment) &#123; MDHTMLLabelVerticalAlignmentCenter = 0, //居中对其 MDHTMLLabelVerticalAlignmentTop = 1, //顶部对其 MDHTMLLabelVerticalAlignmentBottom = 2, //底部对其&#125;;*/@property (nonatomic, assign) MDHTMLLabelVerticalAlignment verticalAlignment;//设置文字的截断模式@property (nonatomic, strong) NSString *truncationTokenString;//根据内容获取控件尺寸+ (CGFloat)sizeThatFitsHTMLString:(NSString *)htmlString withFont:(UIFont *)font constraints:(CGSize)size limitedToNumberOfLines:(NSUInteger)numberOfLines; 关于HTML数据中的超链接的相应，MDHTMLLabel是通过代理回调的方式处理的，如下： 1234567@protocol MDHTMLLabelDelegate &lt;NSObject&gt;@optional//点击超链接的时候触发的方法- (void)HTMLLabel:(MDHTMLLabel *)label didSelectLinkWithURL:(NSURL*)URL;//长按超链接时触发的方法- (void)HTMLLabel:(MDHTMLLabel *)label didHoldLinkWithURL:(NSURL*)URL;@end 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS运行时函数替换框架——RSSwizzle","slug":"231iOS运行时函数替换框架——RSSwizzle","date":"2016-06-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.346Z","comments":true,"path":"2016/06/30/231iOS运行时函数替换框架——RSSwizzle/","link":"","permalink":"http://huishao.cc/2016/06/30/231iOS运行时函数替换框架——RSSwizzle/","excerpt":"","text":"iOS运行时函数替换框架——RSSwizzle一、引言Objective-C是的运行时特性在iOS开发中应用广泛，通过runtime方法，开发者可以在运行时动态为类添加方法，修改类的方法，系统的class\\_addMethod()方法和class\\_replaceMethod()方法可以十分简单的添加和修改方法，然而，直接使用这两个函数有时并不安全，其主要问题有如下几点： 1.在进行动态函数修改的时候，有可能其他线程也在做同样的操作。 2.在继承中，子类执行父类替换的方法会出现问题。 3.函数的替换必须依靠_cmd参数。 4.可能会出现命名冲突。 有关Objective-C运行时的相关内容可在如下博客中查看：http://my.oschina.net/u/2340880/blog/489072。 RSSwizzle框架可以解决上面所有问题，在要求比较高的项目中如果需要使用到运行时函数替换的需求，可以直接使用这个框架。git地址如下： https://github.com/rabovik/RSSwizzle。 二、RSSwizzle的使用RSSwizzle中提供了两种使用方式，一种是通过调用类方法来实现函数的替换，另一种是使用RSSwizzle定义的宏来进行函数的替换。使用类方法的方式示例如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //替换类方法 [RSSwizzle swizzleClassMethod:NSSelectorFromString(@\"log\") inClass:NSClassFromString(@\"ViewController\") newImpFactory:^id(RSSwizzleInfo *swizzleInfo) &#123; return ^(__unsafe_unretained id self)&#123; NSLog(@\"Class log Swizzle\"); &#125;; &#125;];&#125;+(void)log&#123; NSLog(@\"Class log\");&#125; 这个函数用来替换类方法，第1个参数为要替换的函数选择器，第2个参数为要替换此函数的类，block参数中需要返回一个方法函数，这个函数为要替换成的函数，要和原函数类型相同。在类中的函数默认都会有一个名为self的id参数。进行实例函数的替换实例代码如下： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //进行实例方法的替换 /* 第一个参数为要替换的函数，第二个参数为要替换方法的类，第三个的block中返回替换后的方法，第四个参数设置替换模式，最后一个参数是此替换操作的标识符 */ [RSSwizzle swizzleInstanceMethod:NSSelectorFromString(@\"touchesBegan:withEvent:\") inClass:NSClassFromString(@\"ViewController\") newImpFactory:^id(RSSwizzleInfo *swizzleInfo) &#123; return ^(__unsafe_unretained id self,NSSet* touches,UIEvent* event)&#123; NSLog(@\"text Swizzle\"); &#125;; &#125; mode:RSSwizzleModeAlways key:@\"key\"];&#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@\"test\"); [ViewController log];&#125; 替换模式的枚举RSSwizzleMode意义如下： 12345678typedef NS_ENUM(NSUInteger, RSSwizzleMode) &#123; //任何情况下 始终执行替换操作 RSSwizzleModeAlways = 0, //相同key标识的替换操作只会被执行一次 RSSwizzleModeOncePerClass = 1, //相同key标识的替换操作在子类父类中只会被执行一次 RSSwizzleModeOncePerClassAndSuperclasses = 2&#125;; 使用宏的模式进行方法替换操作的代码更加简单，示例如下： 123456789101112131415//进行类方法的替换/* 第1个参数为要替换方法的类 第二个参数为要替换的方法选择器 第三个参数为方法的返回值类型，第四个参数为方法的参数列表，最后一个参数为要替换的方法代码块 */RSSwizzleClassMethod(NSClassFromString(@\"ViewController\"), NSSelectorFromString(@\"log\"), RSSWReturnType(void), RSSWArguments(), RSSWReplacement( &#123; //先执行原始方法 RSSWCallOriginal(); NSLog(@\"Class log Swillze\"); &#125;));//进行实例方法的替换/* 第一个参数为要替换方法的类，第二个参数为要替换的方法选择器，第三个参数为返回值类型，第四个参数为参数列表 第五个参数为要替换的代码块，第六个参数为执行模式，最后一个参数为key值标识。 */RSSwizzleInstanceMethod(NSClassFromString(@\"ViewController\"),NSSelectorFromString(@\"touchesBegan:withEvent:\"), RSSWReturnType(void), RSSWArguments(NSSet* touchs,UIEvent * event), RSSWReplacement(&#123; NSLog(@\"test Swizzle\");&#125;), RSSwizzleModeAlways, @\"key\"); 在宏内，可以直接调用RSSWCallOriginal()来执行替换前的原始函数，十分方便。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS好用的第三方侧边栏控件——MMDrawerController","slug":"229iOS好用的第三方侧边栏控件——MMDrawerController","date":"2016-06-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.346Z","comments":true,"path":"2016/06/29/229iOS好用的第三方侧边栏控件——MMDrawerController/","link":"","permalink":"http://huishao.cc/2016/06/29/229iOS好用的第三方侧边栏控件——MMDrawerController/","excerpt":"","text":"iOS好用的第三方侧边栏控件——MMDrawerController一、引言很多应用程序都采用了侧边栏这样的界面结构，MMDrawerController是一个轻量级的侧边栏抽屉控件，其支持左侧抽屉和右侧抽屉，可以很好的支持导航控制器，并且支持开发者对手势和动画进行自定义。MMDrawerController的git地址如下： https://github.com/mutualmobile/MMDrawerController。 二、MMDrawerController的使用及相关设置MMDrawerController的使用十分简单，只需将中心视图控制器和左边栏视图控制器传入初始化方法即可完成MMDrawerController的创建。示例代码如下： 12345678UIViewController * leftViewController = [[UIViewController alloc]init];leftViewController.view.backgroundColor = [UIColor redColor];UIViewController * rightViewController = [[UIViewController alloc]init];rightViewController.view.backgroundColor = [UIColor greenColor];ViewController * centerViewController = [[ViewController alloc]init];centerViewController.view.backgroundColor = [UIColor blueColor];//创建控件MMDrawerController * rootController = [[MMDrawerController alloc]initWithCenterViewController:centerViewController leftDrawerViewController:leftViewController rightDrawerViewController:rightViewController]; MMDrawerController中还提供了两个方法供开发者创建单侧边栏，如下： 1234//只创建带左侧边栏的视图控制器-(id)initWithCenterViewController:(UIViewController *)centerViewController leftDrawerViewController:(UIViewController *)leftDrawerViewController;//只创建带右侧边栏的视图控制器-(id)initWithCenterViewController:(UIViewController *)centerViewController rightDrawerViewController:(UIViewController *)rightDrawerViewController; MMDrawerController中也提供了许多属性和方法供开发者进行自定义的设置，其中可用属性解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//设置左侧边栏的最大宽度 默认280@property (nonatomic, assign) CGFloat maximumLeftDrawerWidth;//设置右侧边栏的最大宽度 默认280@property (nonatomic, assign) CGFloat maximumRightDrawerWidth;//这个是一个只读属性，用于获取可见的左侧边栏宽度@property (nonatomic, assign, readonly) CGFloat visibleLeftDrawerWidth;//这个是一个只读属性，用于获取可见的右侧边栏宽度@property (nonatomic, assign, readonly) CGFloat visibleRightDrawerWidth;//动画速度，这个参数的意义是每秒移动多少单位 默认为800/s@property (nonatomic, assign) CGFloat animationVelocity;//设置是否允许回弹效果，如果设置为YES，当使用手势进行侧边栏的开启时会出现回弹效果@property (nonatomic, assign) BOOL shouldStretchDrawer;//获取当前开启的侧边栏类型，MMDrawerSide枚举如下：/*typedef NS_ENUM(NSInteger,MMDrawerSide)&#123; MMDrawerSideNone = 0,//无侧边栏 MMDrawerSideLeft, //左侧边栏 MMDrawerSideRight, //右侧边栏&#125;;*/@property (nonatomic, assign, readonly) MMDrawerSide openSide;//开启侧边栏的手势模式 MMOpenDrawerGestureMode枚举意义如下/*typedef NS_OPTIONS(NSInteger, MMOpenDrawerGestureMode) &#123; //没有手势 此模式为默认模式 MMOpenDrawerGestureModeNone = 0, //在导航栏上拖动时可以打开侧边栏 MMOpenDrawerGestureModePanningNavigationBar = 1 &lt;&lt; 1, //在中心视图控制器的视图上拖动时可以打开侧边栏 MMOpenDrawerGestureModePanningCenterView = 1 &lt;&lt; 2, //在中心视图控制器的视图边缘20个单位内拖动时可以打开侧边栏 MMOpenDrawerGestureModeBezelPanningCenterView = 1 &lt;&lt; 3, //自定义手势 需配合自定义手势的方法使用 MMOpenDrawerGestureModeCustom = 1 &lt;&lt; 4, //所有模式兼容 MMOpenDrawerGestureModeAll = MMOpenDrawerGestureModePanningNavigationBar | MMOpenDrawerGestureModePanningCenterView | MMOpenDrawerGestureModeBezelPanningCenterView | MMOpenDrawerGestureModeCustom,&#125;;*/@property (nonatomic, assign) MMOpenDrawerGestureMode openDrawerGestureModeMask;//关闭侧边栏的手势模式 MMCloseDrawerGestureMode枚举的意义如下/*typedef NS_OPTIONS(NSInteger, MMCloseDrawerGestureMode) &#123; //没有关闭手势 MMCloseDrawerGestureModeNone = 0, //在导航栏上拖动时可以关闭侧边栏 MMCloseDrawerGestureModePanningNavigationBar = 1 &lt;&lt; 1, //在中心视图控制器上推动时可以关闭侧边栏 MMCloseDrawerGestureModePanningCenterView = 1 &lt;&lt; 2, //在中心视图控制器边缘20单位内拖动是可以关闭侧边栏 MMCloseDrawerGestureModeBezelPanningCenterView = 1 &lt;&lt; 3, //点击导航栏时可以关闭侧边栏 MMCloseDrawerGestureModeTapNavigationBar = 1 &lt;&lt; 4, //点击中心视图控制器视图时可以关闭侧边栏 MMCloseDrawerGestureModeTapCenterView = 1 &lt;&lt; 5, //在侧边栏视图上拖动时可以关闭侧边栏 MMCloseDrawerGestureModePanningDrawerView = 1 &lt;&lt; 6, //自定义关闭手势，需要和自定义手势的方法结合使用 MMCloseDrawerGestureModeCustom = 1 &lt;&lt; 7, //所有模式兼容 MMCloseDrawerGestureModeAll = MMCloseDrawerGestureModePanningNavigationBar | MMCloseDrawerGestureModePanningCenterView | MMCloseDrawerGestureModeBezelPanningCenterView | MMCloseDrawerGestureModeTapNavigationBar | MMCloseDrawerGestureModeTapCenterView | MMCloseDrawerGestureModePanningDrawerView | MMCloseDrawerGestureModeCustom,&#125;;*/@property (nonatomic, assign) MMCloseDrawerGestureMode closeDrawerGestureModeMask;//设置侧边栏显示时的中心视图控制器的用户交互规则 MMDrawerOpenCenterInteractionMode枚举意义如下/*typedef NS_ENUM(NSInteger, MMDrawerOpenCenterInteractionMode) &#123; //中心视图控制器不能进行用户交互 默认为此枚举 MMDrawerOpenCenterInteractionModeNone, //中心视图控制器完全可以进行用户交互 MMDrawerOpenCenterInteractionModeFull, //中心视图控制器只有导航可以进行用户交互 MMDrawerOpenCenterInteractionModeNavigationBarOnly,&#125;;*/@property (nonatomic, assign) MMDrawerOpenCenterInteractionMode centerHiddenInteractionMode;//设置是否显示阴影效果@property (nonatomic, assign) BOOL showsShadow;//设置是否显示状态栏的自定义视图 只有在iOS7之后可用@property (nonatomic, assign) BOOL showsStatusBarBackgroundView;//设置状态栏视图颜色 只有在iOS7之后可用@property (nonatomic, strong) UIColor * statusBarViewBackgroundColor; 相关方法解析如下： 123456789101112131415161718192021222324//切换侧边栏的状态，drawerSide参数为要切换的侧边栏，animated设置是否有动画效果，completion会在切换完成后执行//注意：如果在切换一个关着的侧边栏时，如果另一个侧边栏正在开启状态，则此方法不会有任何效果-(void)toggleDrawerSide:(MMDrawerSide)drawerSide animated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//关闭侧边栏-(void)closeDrawerAnimated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//开启侧边栏-(void)openDrawerSide:(MMDrawerSide)drawerSide animated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//更换中心视图控制器-(void)setCenterViewController:(UIViewController *)centerViewController withCloseAnimation:(BOOL)closeAnimated completion:(void(^)(BOOL finished))completion;-(void)setCenterViewController:(UIViewController *)newCenterViewController withFullCloseAnimation:(BOOL)fullCloseAnimated completion:(void(^)(BOOL finished))completion;//设置左侧边栏最大宽度-(void)setMaximumLeftDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//设置右侧边栏最大宽度-(void)setMaximumRightDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//进行侧边栏的预览操作 默认预览距离为40个单位-(void)bouncePreviewForDrawerSide:(MMDrawerSide)drawerSide completion:(void(^)(BOOL finished))completion;//进行侧边栏的预览操作 可以设置预览距离-(void)bouncePreviewForDrawerSide:(MMDrawerSide)drawerSide distance:(CGFloat)distance completion:(void(^)(BOOL finished))completion;//这个方法用于进行视图侧边栏视图出现动画的自定义-(void)setDrawerVisualStateBlock:(void(^)(MMDrawerController * drawerController, MMDrawerSide drawerSide, CGFloat percentVisible))drawerVisualStateBlock;//这个方法用于设置当一个手势触发完成后的回调-(void)setGestureCompletionBlock:(void(^)(MMDrawerController * drawerController, UIGestureRecognizer * gesture))gestureCompletionBlock;//这个方法用于定义自定义的手势操作 要将开启侧边栏与关闭侧边栏的模式设置为MMOpenDrawerGestureModeCustom和MMCloseDrawerGestureModeCustom才有效-(void)setGestureShouldRecognizeTouchBlock:(BOOL(^)(MMDrawerController * drawerController, UIGestureRecognizer * gesture, UITouch * touch))gestureShouldRecognizeTouchBlock; 对于自定义过渡动画的方法： -(void)setDrawerVisualStateBlock:(void(^)(MMDrawerController * drawerController, MMDrawerSide drawerSide, CGFloat percentVisible))drawerVisualStateBlock; 回调block中会传递进来侧边栏显示完成的百分比，并且在侧边栏出现过程中，这个回调block会被不停刷新调用，开发者可以直接在其中对要过渡的属性进行设置，例如透明度的渐变动画，示例如下： 123456789101112//进行自定义动画 [rootController setDrawerVisualStateBlock:^(MMDrawerController *drawerController, MMDrawerSide drawerSide, CGFloat percentVisible) &#123; UIViewController * sideDrawerViewController; if(drawerSide == MMDrawerSideLeft)&#123; sideDrawerViewController = drawerController.leftDrawerViewController; &#125; else if(drawerSide == MMDrawerSideRight)&#123; sideDrawerViewController = drawerController.rightDrawerViewController; &#125; [sideDrawerViewController.view setAlpha:percentVisible]; &#125;]; 三、关于MMDrawerController的子类开发者如果有特殊的需求，也可以通过继承MMDrawerController来实现自己的侧边栏控制器类，MMDrawerController框架中提供了一个扩展，在编写MMDrawerController时，开发者可以导入MMDrawerController+Subclass.h文件，这个文件中提供了许多控制器的监听方法供开发者重写，解析如下： 123456789101112131415//出现单击手势会回调的方法 如果要重写 必须调用父类的此方法-(void)tapGestureCallback:(UITapGestureRecognizer *)tapGesture __attribute((objc_requires_super));//出现滑动手势会回调的方法 如果要重写 必须调用父类的此方法-(void)panGestureCallback:(UIPanGestureRecognizer *)panGesture __attribute((objc_requires_super));//决定是否响应某个手势-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch __attribute((objc_requires_super));//准备展示侧边栏时调用的方法-(void)prepareToPresentDrawer:(MMDrawerSide)drawer animated:(BOOL)animated __attribute((objc_requires_super));//关闭侧边栏时调用的方法-(void)closeDrawerAnimated:(BOOL)animated velocity:(CGFloat)velocity animationOptions:(UIViewAnimationOptions)options completion:(void (^)(BOOL))completion __attribute((objc_requires_super));//打开侧边栏时调用的方法-(void)openDrawerSide:(MMDrawerSide)drawerSide animated:(BOOL)animated velocity:(CGFloat)velocity animationOptions:(UIViewAnimationOptions)options completion:(void (^)(BOOL))completion __attribute((objc_requires_super));//设备旋转方向时调用的方法-(void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration __attribute((objc_requires_super));-(void)willAnimateRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration __attribute((objc_requires_super)); 四、一些辅助类MMDrawerController框架中还提供了一个MMDrawerBarButtonItem的辅助类，这个类可以创建三道杠的菜单按钮。其中方法如下： 123456//初始化方法-(id)initWithTarget:(id)target action:(SEL)action;//获取某个状态下的按钮颜色-(UIColor *)menuButtonColorForState:(UIControlState)state __attribute__((deprecated(\"Use tintColor instead\")));//设置某个状态的按钮颜色-(void)setMenuButtonColor:(UIColor *)color forState:(UIControlState)state __attribute__((deprecated(\"Use tintColor instead\"))); MMDrawerBarButtonItem继承自UIBarButtonItem，可以直接在导航栏上使用。 前面有提到，侧边栏的展现动画开发者可以进行自定义，为了使开发者在使用MMDrawerController时更加方便，MMDrawerController框架中还提供了一个动画辅助类MMDrawerVisualState，这个类中封装好了许多动画效果，开发者可以直接使用，示例如下： 12//使用提供的动画模板[rootController setDrawerVisualStateBlock:[MMDrawerVisualState slideAndScaleVisualStateBlock]]; MMDrawerVisualState中所提供的动画模板列举如下： 12345678//从后向前渐现+(MMDrawerControllerDrawerVisualStateBlock)slideAndScaleVisualStateBlock;//滑动渐现+(MMDrawerControllerDrawerVisualStateBlock)slideVisualStateBlock;//立方动画+(MMDrawerControllerDrawerVisualStateBlock)swingingDoorVisualStateBlock;//视差动画+(MMDrawerControllerDrawerVisualStateBlock)parallaxVisualStateBlockWithParallaxFactor:(CGFloat)parallaxFactor; 五、MMDrawerController无法完成的需求为了确保MMDrawerController库的轻量级，其作者在设计时也做了功能上的取舍权衡，MMDrawerController无法完成以下需求： 1.上边栏与下边栏。 2.同时展示左边栏与又边栏。 3.无法设置显示一个最小的抽屉宽度。 4.不能支持UITabBarController容器。 5.不能在中心视图控制器之上呈现侧边栏视图。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"Swift3.0带来的变化汇总系列三——函数和闭包写法上的微调","slug":"228Swift3.0带来的变化汇总系列三——函数和闭包写法上的微调","date":"2016-06-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.346Z","comments":true,"path":"2016/06/26/228Swift3.0带来的变化汇总系列三——函数和闭包写法上的微调/","link":"","permalink":"http://huishao.cc/2016/06/26/228Swift3.0带来的变化汇总系列三——函数和闭包写法上的微调/","excerpt":"","text":"Swift3.0带来的变化汇总系列三——函数写法上的微调一、函数方面Swift3.0相比Swift2.2的版本在API上做了大量的修改，代码风格也更加统一。在函数方面，Swift3.0中做的最大修改是修改了内部名称与外部名称的默认规则。 在Swift2.2中，函数参数列表的第一个参数如果开发者不手动设置外部名称，默认是匿名的，除第一个参数以外的其他参数，开发者如果不设置外部名称，默认外部名称是和内部名称相同的，因此在调用函数时，代码常常是这样的： 1234567//多参数函数Swift2.2中 第一个参数默认匿名，其他参数默认内部命名与外部命名相同func myFunc5(param1: Int,param2: Int,param3: Int) &#123; //这里使用的param1，param2，param3是参数的内部命名 param1+param2+param3&#125;//调用函数的参数列表中使用的param2和param3为外部命名myFunc5(1, param2: 2, param3: 3) Swift3.0中将这一规则修改为：如果开发者不设置函数中参数的外部名称，则全部参数都默认外部名称和内部名称相同，上面相同的代码，在Swift3.0的环境下是下面这样的： 12345678//多参数函数 默认内部命名与外部命名相同func myFunc5(param1: Int,param2: Int,param3: Int) &#123; //这里使用的param1，param2，param3是参数的内部命名 param1+param2+param3&#125;//调用函数的参数列表中使用的param1、param2和param3为外部命名//swift3.0myFunc5(param1: 1, param2: 2, param3: 3) Swift3.0在函数参数名方面的微调使得函数的参数名规则更加统一也更加符合Swift语言的风格。 在函数方面，Swift3.0中做的另一项更改是关于inout参数的声明方式，修改了inout关键字的声明位置，Swift2.2与Swift3.0版本比如如下： 123456789//在函数内部修改参数变量的值//swift2.2func myFunc12(inout param:Int)&#123; param+=1&#125;//swift3.0func myFunc12( param:inout Int)&#123; param+=1&#125; 有关Swift中函数的更多内容，可以在如下博客连接中找到： http://my.oschina.net/u/2340880/blog/674616 二、闭包方面在闭包方面，Swift3.0版本中只对某些修饰符的位置做了修改。示例如下： 1234567891011121314151617//逃逸闭包//swift2.2//func myFunc(@noescape closure:(Int,Int)-&gt;Bool)&#123;// //&#125;//swift3.0func myFunc( closure:@noescape(Int,Int)-&gt;Bool)&#123;&#125;//自动闭包//swift2.2//func myFunc2(@autoclosure(escaping) closure:()-&gt;Bool) &#123;// //&#125;func myFunc2( closure:@autoclosure(escaping)()-&gt;Bool) &#123; &#125; 关于Swift中闭包的更多内容，可以在如下博客链接中找到： http://my.oschina.net/u/2340880/blog/675233。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"iOS中WebKit框架应用与解析","slug":"227iOS中WebKit框架应用与解析","date":"2016-06-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.345Z","comments":true,"path":"2016/06/24/227iOS中WebKit框架应用与解析/","link":"","permalink":"http://huishao.cc/2016/06/24/227iOS中WebKit框架应用与解析/","excerpt":"","text":"iOS中WebKit框架应用与解析一、引言在iOS8之前，在应用中嵌入网页通常需要使用UIWebView这样一个类，这个类通过URL或者HTML文件来加载网页视图，功能十分有限，只能作为辅助嵌入原生应用程序中。虽然UIWebView也可以做原生与JavaScript交互的相关处理，然而也有很大的局限性，JavaScript要调用原生方法通常需要约定好协议之后通过Request来传递。WebKit框架中添加了一些原生与JavaScript交互的方法，增强了网页视图与原生的交互能力。并且WebKit框架中采用导航堆栈的模型来管理网页的跳转，开发者也可以更加容易的控制和管理网页的渲染。关于UIWebView的相关使用，在前面的博客中有详细介绍，地址如下。 UIWebView的使用详解：http://my.oschina.net/u/2340880/blog/469916。 二、WebKit框架概览WebKit框架中涉及的类很多，框架的设计十分面向对象和模块化，开发者在使用时可以轻松的写出结构清晰的代码。在进行使用前，我们首先应该清楚整个框架的结构和开发思路，下面一张脑图中基本列出了WebKit框架中所涉及到的所有重要的类以及他们之间的相互关系： 如上图所示，WebKit框架中最核心的类应该属于WKWebView了，这个类专门用来渲染网页视图，其他类和协议都将基于它和服务于它。 WKWebView：网页的渲染与展示，通过WKWebViewConfiguration可以进行配置。 WKWebViewConfiguration：这个类专门用来配置WKWebView。 WKPreference:这个类用来进行M相关设置。 WKProcessPool：这个类用来配置进程池，与网页视图的资源共享有关。 WKUserContentController：这个类主要用来做native与JavaScript的交互管理。 WKUserScript：用于进行JavaScript注入。 WKScriptMessageHandler：这个类专门用来处理JavaScript调用native的方法。 WKNavigationDelegate：网页跳转间的导航管理协议，这个协议可以监听网页的活动。 WKNavigationAction：网页某个活动的示例化对象。 WKUIDelegate：用于交互处理JavaScript中的一些弹出框。 WKBackForwardList：堆栈管理的网页列表。 WKBackForwardListItem：每个网页节点对象。 三、使用WKWebViewConfiguration对WebView进行配置使用下面的代码可以创建一个WKWebView视图，创建WebView视图时，需要使用WKWebViewConfiguration来进行配置： 1234WKWebView * WK;WKWebViewConfiguration * config = [[WKWebViewConfiguration alloc]init];WK = [[WKWebView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height-40) configuration:config];[WK loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://www.baidu.com\"]]]; WKWebViewConfiguration中可以进行配置的方法和属性如下： 123//设置进程池WKProcessPool * pool = [[WKProcessPool alloc]init];config.processPool = pool; WKProcessPool类中没有暴露任何属性和方法，配置为同一个进程池的WebView会共享数据，例如Cookie、用户凭证等，开发者可以通过编写管理类来分配不同维度的WebView在不同进程池中。 123456789//进行偏好设置WKPreferences * preference = [[WKPreferences alloc]init];//最小字体大小 当将javaScriptEnabled属性设置为NO时，可以看到明显的效果preference.minimumFontSize = 0;//设置是否支持javaScript 默认是支持的preference.javaScriptEnabled = YES;//设置是否允许不经过用户交互由javaScript自动打开窗口preference.javaScriptCanOpenWindowsAutomatically = YES;config.preferences = preference; WKPerference实例为WebView提供一个偏好设置。 123456789//设置内容交互控制器 用于处理JavaScript与native交互WKUserContentController * userController = [[WKUserContentController alloc]init];//设置处理代理并且注册要被js调用的方法名称[userController addScriptMessageHandler:self name:@\"name\"];//js注入，注入一个测试方法。NSString *javaScriptSource = @\"function userFunc()&#123;window.webkit.messageHandlers.name.postMessage( &#123;\\\"name\\\":\\\"HS\\\"&#125;)&#125;\";WKUserScript *userScript = [[WKUserScript alloc] initWithSource:javaScriptSource injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:YES];// forMainFrameOnly:NO(全局窗口)，yes（只限主窗口）[userController addUserScript:userScript];config.userContentController = userController; WKUserContentController专门用来管理native与JavaScript的交互行为，addScriptMessageHandler:name:方法来注册要被js调用的方法名称，之后再JavaScript中使用window.webkit.messageHandlers.name.postMessage()方法来像native发送消息，支持OC中字典，数组，NSNumber等原生数据类型，JavaScript代码中的name要和上面注册的相同。在native代理的回调方法中，会获取到JavaScript传递进来的消息，如下： 123-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123; //这里可以获取到JavaScript传递进来的消息&#125; WKScriptMessage类是JavaScript传递的对象实例，其中属性如下： 12345678//传递的消息主体@property (nonatomic, readonly, copy) id body;//传递消息的WebView@property (nullable, nonatomic, readonly, weak) WKWebView *webView;//传递消息的WebView当前页面对象@property (nonatomic, readonly, copy) WKFrameInfo *frameInfo;//消息名称@property (nonatomic, readonly, copy) NSString *name; WKUserContentController实例的addUserScript:用于注入JavaScript代码，后面会专门介绍。 12//设置数据存储storeconfig.websiteDataStore = [WKWebsiteDataStore defaultDataStore]; WebKit框架采用其本身的缓存框架，WKWebsiteDataStore类用来处理数据的存储，其中属性和方法如下： 12345678910@interface WKWebsiteDataStore : NSObject//获取默认的存储器 此存储器为持久性的会被写入磁盘+ (WKWebsiteDataStore *)defaultDataStore;//获取一个临时的存储器+ (WKWebsiteDataStore *)nonPersistentDataStore;//存储器是否是临时的@property (nonatomic, readonly, getter=isPersistent) BOOL persistent;//所有可以存储的类型+ (NSSet&lt;NSString *&gt; *)allWebsiteDataTypes;@end 12345678910111213141516171819202122//设置是否将网页内容全部加载到内存后再渲染config.suppressesIncrementalRendering = NO;//设置HTML5视频是否允许网页播放 设置为NO则会使用本地播放器config.allowsInlineMediaPlayback = YES;//设置是否允许ariPlay播放config.allowsAirPlayForMediaPlayback = YES;//设置视频是否需要用户手动播放 设置为NO则会允许自动播放config.requiresUserActionForMediaPlayback = NO;//设置是否允许画中画技术 在特定设备上有效config.allowsPictureInPictureMediaPlayback = YES;//设置选择模式 是按字符选择 还是按模块选择/*typedef NS_ENUM(NSInteger, WKSelectionGranularity) &#123; //按模块选择 WKSelectionGranularityDynamic, //按字符选择 WKSelectionGranularityCharacter,&#125; NS_ENUM_AVAILABLE_IOS(8_0);*/config.selectionGranularity = WKSelectionGranularityCharacter;//设置请求的User-Agent信息中应用程序名称 iOS9后可用config.applicationNameForUserAgent = @\"HS\"; 四、WKWebView中的属性和方法解析下面列举了WKWebView中常用的属性和方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//设置导航代理@property (nullable, nonatomic, weak) id &lt;WKNavigationDelegate&gt; navigationDelegate;//设置UI代理@property (nullable, nonatomic, weak) id &lt;WKUIDelegate&gt; UIDelegate;//导航列表@property (nonatomic, readonly, strong) WKBackForwardList *backForwardList;//通过url加载网页视图- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;//通过文件加载网页视图- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL NS_AVAILABLE(10_11, 9_0);//通过HTML字符串加载网页视图- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;//通过data数据加载网页视图- (nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL NS_AVAILABLE(10_11, 9_0);//渲染导航列表中的某个网页节点- (nullable WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item;//网页标题@property (nullable, nonatomic, readonly, copy) NSString *title;//网页的url@property (nullable, nonatomic, readonly, copy) NSURL *URL;//网页是否正在加载中@property (nonatomic, readonly, getter=isLoading) BOOL loading;//加载进度 可以监听这个属性的值配合UIProgressView来设计进度条@property (nonatomic, readonly) double estimatedProgress;//是否全部是安全连接@property (nonatomic, readonly) BOOL hasOnlySecureContent;//证书列表@property (nonatomic, readonly, copy) NSArray *certificateChain;//是否可以回退@property (nonatomic, readonly) BOOL canGoBack;//是否可以前进@property (nonatomic, readonly) BOOL canGoForward;//回退网页- (nullable WKNavigation *)goBack;//前进网页- (nullable WKNavigation *)goForward;//刷新网页- (nullable WKNavigation *)reload;//忽略缓存的刷新- (nullable WKNavigation *)reloadFromOrigin;//停止加载- (void)stopLoading;//执行JavaScript代码- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ __nullable)(__nullable id, NSError * __nullable error))completionHandler;//是否允许右滑返回手势@property (nonatomic) BOOL allowsBackForwardNavigationGestures; WKBackForwardList类为导航管理的网页列表类，其中属性方法意义如下： 1234567891011121314@interface WKBackForwardList : NSObject//当前所在的网页节点@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *currentItem;//前进的一个网页节点@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *forwardItem;//回退的一个网页节点@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *backItem;//获取某个index的网页节点- (nullable WKBackForwardListItem *)itemAtIndex:(NSInteger)index;//获取回退的节点数组@property (nonatomic, readonly, copy) NSArray&lt;WKBackForwardListItem *&gt; *backList;//获取前进的节点数组@property (nonatomic, readonly, copy) NSArray&lt;WKBackForwardListItem *&gt; *forwardList;@end 在WebKit中，网页节点被抽象成为了WKBackForwardListItem类，这个类中封装的属性如下： 1234567@interface WKBackForwardListItem : NSObject//当前节点的URL@property (readonly, copy) NSURL *URL;//当前节点的标题@property (nullable, readonly, copy) NSString *title;//创建此WebView的初始URL@property (readonly, copy) NSURL *initialURL; 五、关于native与JavaScript交互WebKit中的native与JavaScript的交互主要有4类。 1.JavaScript调用native方法这种方式是由WKUserContentController注册，并在代理方法中实现的。 2.native调用JavaScript方法这种方式通过WKWebView直接调用evaluteJavaScript:completionHandler:方法来实现。 3.将JavaScript代码注入这种方式可以在网页中注入一些自定义的JavaScript代码，也可以注入自定义的方法，再使用evaluteJavaScript:completionHandler:来调用方法。JavaScript代码的注入也是通过WKUserContentController来完成的，使用addUserScript:方法来注入JavaScript，其中需要通过WKUserScript类来生成要注入的对象，这个类使用如下方法来进行实例化： 12345678910111213/*source为要注入的js代码WKUserScriptInjectionTime设置注入的时机forMainFrameOnly参数设置是否只在主页面注入typedef NS_ENUM(NSInteger, WKUserScriptInjectionTime) &#123; //原js代码运行前注入 WKUserScriptInjectionTimeAtDocumentStart, //原js代码运行后注入 WKUserScriptInjectionTimeAtDocumentEnd&#125; NS_ENUM_AVAILABLE(10_10, 8_0);*/- (instancetype)initWithSource:(NSString *)source injectionTime:(WKUserScriptInjectionTime)injectionTime forMainFrameOnly:(BOOL)forMainFrameOnly; 4.通过WKUIDelegate来交互这种方式主要用于相应JavaScript中的弹出框，后面会详细介绍这个协议。 六、WKNavagationDelegate中方法解析WKNavagationDelegate协议重要有两个作用，监听页面渲染流程与控制页面跳转，其中方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*决定是否响应网页的某个动作，例如加载，回退，前进，刷新等，在这个方法中，必须执行decisionHandler()代码块，并将是否允许这个活动执行在block中进行传入*//*WKNavigationAction是网页动作的抽象化，其中封装了许多行为信息，后面会介绍WKNavigationActionPolicy为开发者回执，枚举如下：typedef NS_ENUM(NSInteger, WKNavigationActionPolicy) &#123; //取消此次行为 WKNavigationActionPolicyCancel, //允许此次行为 WKNavigationActionPolicyAllow,&#125; NS_ENUM_AVAILABLE(10_10, 8_0);*/-(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; decisionHandler(WKNavigationActionPolicyAllow);&#125;//需要响应身份验证时调用 同样在block中需要传入用户身份凭证-(void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler&#123; //用户身份信息 NSURLCredential *newCred = [NSURLCredential credentialWithUser:@\"\" password:@\"\" persistence:NSURLCredentialPersistenceNone]; // 为 challenge 的发送方提供 credential [[challenge sender] useCredential:newCred forAuthenticationChallenge:challenge]; completionHandler(NSURLSessionAuthChallengeUseCredential,newCred);&#125;//接收到数据后是否允许执行渲染/*其中，WKNavigationResponse为请求回执信息WKNavigationResponsePokicy为开发者回执，枚举如下：typedef NS_ENUM(NSInteger, WKNavigationResponsePolicy) &#123; //取消渲染 WKNavigationResponsePolicyCancel, //允许渲染 WKNavigationResponsePolicyAllow,&#125; NS_ENUM_AVAILABLE(10_10, 8_0);*/-(void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler&#123; decisionHandler(WKNavigationResponsePolicyAllow);&#125;//=====================下面这个协议方法用于监听流程=========================================//页面加载启动时调用-(void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation&#123;&#125;//当主机接收到的服务重定向时调用-(void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation&#123;&#125;//内容到达主机时调用-(void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation&#123;&#125;//主页加载完成时调用-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123;&#125;//提交发生错误时调用-(void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error&#123;&#125;//主页数据加载发生错误时调用-(void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(nonnull NSError *)error&#123;&#125;//进程被终止时调用-(void)webViewWebContentProcessDidTerminate:(WKWebView *)webView&#123;&#125; 七、WKUIDelegate协议中方法解析123456789101112131415161718192021222324//创建新的webView时调用的方法-(WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures&#123; return webView;&#125;//关闭webView时调用的方法-(void)webViewDidClose:(WKWebView *)webView&#123;&#125;//下面这些方法是交互JavaScript的方法//JavaScript调用alert方法后回调的方法 message中为alert提示的信息 必须要在其中调用completionHandler()-(void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; NSLog(@\"%@\",message); completionHandler();&#125;//JavaScript调用confirm方法后回调的方法 confirm是js中的确定框，需要在block中把用户选择的情况传递进去-(void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler&#123; NSLog(@\"%@\",message); completionHandler(YES);&#125;//JavaScript调用prompt方法后回调的方法 prompt是js中的输入框 需要在block中把用户输入的信息传入-(void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler&#123; NSLog(@\"%@\",prompt); completionHandler(@\"123\");&#125; 八、扩展首先，在注册要被JavaScript调用的方法时需要设置代理，在不需要时需要将代理移除，WKUserContentController中也提供了移除这个代理的方法，如果不移除，将会造成WebView不能释放。方法如下： 1234//注册一个监听方法- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;//移除一个方法的监听- (void)removeScriptMessageHandlerForName:(NSString *)name; 同样与注入JavaScript对应，也可以将注入的代码移除，方法如下： 1234//注入一个JavaScript抽象对象- (void)addUserScript:(WKUserScript *)userScript;//移除所有注入- (void)removeAllUserScripts; 在上面，经常会见到WKNavagationAction这个类，这个类中封装的是一些页面活动信息，如下： 1234567891011121314151617181920212223242526@interface WKNavigationAction : NSObject//原页面@property (nonatomic, readonly, copy) WKFrameInfo *sourceFrame;//目标页面@property (nullable, nonatomic, readonly, copy) WKFrameInfo *targetFrame;//请求URL@property (nonatomic, readonly, copy) NSURLRequest *request;//活动类型/*typedef NS_ENUM(NSInteger, WKNavigationType) &#123; //链接激活 WKNavigationTypeLinkActivated, //提交操作 WKNavigationTypeFormSubmitted, //前进操作 WKNavigationTypeBackForward, //刷新操作 WKNavigationTypeReload, //重提交操作 例如前进 后退 刷新 WKNavigationTypeFormResubmitted, //其他类型 WKNavigationTypeOther = -1,&#125; NS_ENUM_AVAILABLE(10_10, 8_0);*/@property (nonatomic, readonly) WKNavigationType navigationType;@end 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Swift3.0带来的变化汇总系列二——集合类型中的变化","slug":"226Swift3.0带来的变化汇总系列二——集合类型中的变化","date":"2016-06-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.345Z","comments":true,"path":"2016/06/18/226Swift3.0带来的变化汇总系列二——集合类型中的变化/","link":"","permalink":"http://huishao.cc/2016/06/18/226Swift3.0带来的变化汇总系列二——集合类型中的变化/","excerpt":"","text":"Swift3.0带来的变化汇总系列二——集合类型中的变化与字符串类似，Swift中集合的类型在3.0版本中也做了大量API上面的修改。 一、Array数组的更改array数组中修改的API示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//创建大量相同元素的数组//创建有10个String类型元素的数组，并且每个元素都为字符串\"Hello\"//swift2.2//var array3 = [String](count: 10, repeatedValue: \"Hello\")//swift3.0var array3 = [String](repeating: \"Hello\", count: 10)//创建有10个Int类型元素的数组，且每个元素都为1//swift2.2//var array4 = Array(count: 10, repeatedValue: 1)//swift3.0var array4 = Array(repeating: 1, count: 10)var array = [1,2,3,4,5,6,7,8,9]//向数组中追加一组元素//swift2.2//array.appendContentsOf([11,12,13])//swift3.0array.append(contentsOf: [11,12,13])//向数组中的某个位置插入一个元素//swift2.2//array.insert(0, atIndex: 0)//swift3.0array.insert(0, at: 0)//向数组中的某个位置插入一组元素//swift2.2//array.insertContentsOf([-2,-1], at: 0)//swift3.0array.insert(contentsOf: [-2,-1], at: 0)//移除数组中某个位置的元素//swift2.2//array.removeAtIndex(1)//swift3.0array.remove(at: 1)//移除一个范围内的元素//swift2.2//array.removeRange(0...2)//swift3.0array.removeSubrange(0...2)//修改一个范围内的元素//swift2.2//array.replaceRange(0...2, with: [0,1])//swift3.0array.replaceSubrange(0...2, with: [0,1])//进行数组枚举遍历 将输出 (0,0) (1,1) (2,2) (3,3) (4,4)//swift3.0 中将枚举属性enumerate 修改为enumerated()方法for item in arrayLet.enumerated()&#123; print(item)&#125;var arraySort = [1,3,5,6,7]//获取数组中的最大值//swift2.2//arraySort.maxElement()//swift3.0arraySort.max()//获取数组中的最小值//swift2.2//arraySort.minElement()//swift3.0arraySort.min()//从大到小排序//swift2.2//arraySort = arraySort.sort(&gt;)//swift3.0arraySort = arraySort.sorted(isOrderedBefore: &gt;)//从小到大排序//swift2.2//arraySort = arraySort.sort(&lt;)//swift3.0arraySort = arraySort.sorted(isOrderedBefore: &lt;) 二、Set集合中的更改Set集合中的修改示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//创建set集合var set1:Set&lt;Int&gt; = [1,2,3,4]//进行下标的移动//获取某个下标后一个元素//swlft2.2//set1[set1.startIndex.successor()]//swift3.0set1[set1.index(after: set1.startIndex)]//获取某个下标后几位的元素//swift2.2//set1[set1.startIndex.advancedBy(3)]//swift3.0set1[set1.index(set1.startIndex, offsetBy: 3)]//获取集合中的最大值//swift2.2//set1.maxElement()//swift3.0set1.max()//获取集合中的最小值//swift2.2//set1.minElement()//swift3.0set1.min()//移除集合中某个位置的元素//swift2.2//set1.removeAtIndex(set1.indexOf(3)!)//swift3.0set1.remove(at: set1.index(of: 3)!)var set3:Set&lt;Int&gt; = [1,2,3,4]var set4:Set&lt;Int&gt; = [1,2,5,6]//返回交集 &#123;1，2&#125;//swift2.2//var setInter = set3.intersect(set4)//swift3.0var setInter = set3.intersection(set4)//返回交集的补集&#123;3，4，5，6&#125;//swift2.2//var setEx = set3.exclusiveOr(set4)//swift3.0var setEx = set3.symmetricDifference(set4)var set5:Set = [1,2]var set6:Set = [2,3]var set7:Set = [1,2,3]var set8:Set = [1,2,3]//判断是否是某个集合的子集 set5是set7的子集 返回ture//swift2.2//set5.isSubsetOf(set7)//swift3.0set5.isSubset(of: set7)//判断是否是某个集合的超集 set7是set5的超集 返回ture//swift2.2//set7.isSupersetOf(set5)//swift3.0set7.isSuperset(of: set5)//判断是否是某个集合的真子集 set5是set7的真子集 返回ture//swift2.2//set5.isStrictSubsetOf(set7)//swift3.0set5.isStrictSubset(of: set7)//判断是否是某个集合的真超集 set7不是set8的真超集 返回false//swift2.2//set7.isStrictSupersetOf(set8)//swift3.0set7.isStrictSuperset(of: set8) 三、Dictionary字典中的更改Dictionary字典中修改示例如下： 12345//通过键删除某个键值对//swift2.2//dic1.removeValueForKey(1)//swift3.0dic1.removeValue(forKey: 1) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化","slug":"225Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化","date":"2016-06-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.345Z","comments":true,"path":"2016/06/16/225Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化/","link":"","permalink":"http://huishao.cc/2016/06/16/225Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化/","excerpt":"","text":"Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化一、引言Apple与今年6月13日正式发布了Swift3.0的第一个预览版本，并且相应推出了Xcode8的第一个bate版本。开发者已经可以在Xcode8bate版上来体验Swift3.0的新特性。首先，Swift3.0确实带来了很大改变，许多Swift中的结构体API都进行了更新，例如String，Array等，Swift3.0版本将许多类Objective-C风格的API都更换成了Swift风格的，其目的使开发者可以使用Swift更加惬意有趣的编程。本系列博客，是我观看WWDC视频中介绍的内容以及Swift3.0的开发者帮助文档整理总结而来，在期间，我也参考对比了Swift2.2中的实现方式，希望可以帮助需要的朋友尽快熟悉和上手Swift3.0。 二、String类中的API变化除了Swift版的Cocoa框架中的API有了大范围的修改外，Swift的一些核心库也有了很大的改动。 Swift3.0中的字符串类型String在方法API上更加简洁，其中变动较大的是与下标相关的方法，列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var string = \"Hello-Swift\"//获取某个下标后一个下标对应的字符 char=\"e\"//swift2.2//var char = string[startIndex.successor()]//swift3.0var char = string[string.index(after: startIndex)]//获取某个下标前一个下标对应的字符 char2 = \"t\"//swift2.2//var char2 = string[endIndex.predecessor()]//swift3.0var char2 = string[string.index(before: string.endIndex)]//通过范围获取字符串中的一个子串 Hello//swift2.2//var subString = string[startIndex...startIndex.advancedBy(4)]//swift3.0var subString = string[startIndex...string.index(startIndex, offsetBy: 4)]//swift2.2//var subString2 = string[endIndex.advancedBy(-5)...endIndex.predecessor()]//swift3.0var subString2 = string[string.index(endIndex, offsetBy: -5)..&lt;endIndex]//获取某个子串在父串中的范围//swift2.2//var range = string.rangeOfString(\"Hello\")//swift3.0var range = string.range(of: \"Hello\")//追加字符串操作 此时string = \"Hello-Swift! Hello-World\"//swift2.2//string.appendContentsOf(\" Hello-World\")//swift3.0string.append(\" Hello-World\")//在指定位置插入一个字符 此时string = \"Hello-Swift!~ Hello-World\"//swift2.2//string.insert(\"~\", atIndex: string.startIndex.advancedBy(12))//swift3.0string.insert(\"~\", at: string.index(string.startIndex, offsetBy: 12))//在指定位置插入一组字符 此时string = \"Hello-Swift!~~~~ Hello-World\"//swift2.2//string.insertContentsOf([\"~\",\"~\",\"~\"], at: string.startIndex.advancedBy(12))//swift3.0string.insert(contentsOf: [\"~\",\"~\",\"~\"], at: string.index(string.startIndex, offsetBy: 12))//在指定范围替换一个字符串 此时string = \"Hi-Swift!~~~~ Hello-World\"//swift2.2//string.replaceRange(string.startIndex...string.startIndex.advancedBy(4), with: \"Hi\")//swift3.0string.replaceSubrange(string.startIndex...string.index(string.startIndex, offsetBy: 4), with: \"Hi\")//在指定位置删除一个字符 此时string = \"Hi-Swift!~~~~ Hello-Worl\"//swift2.2//string.removeAtIndex(string.endIndex.predecessor())//swift3.0string.remove(at: string.index(before:string.endIndex))//删除指定范围的字符 此时string = \"Swift!~~~~ Hello-Worl\"//swift2.2//string.removeRange(string.startIndex...string.startIndex.advancedBy(2))//swift3.0string.removeSubrange(string.startIndex...string.index(string.startIndex, offsetBy: 2))var string2 = \"My name is Jaki\"//全部转换为大写//swift2.2//string2 = string2.uppercaseString//swift3.0string2 = string2.uppercased()//全部转换为小写//swift2.2//string2 = string2.lowercaseString//swift3.0string2 = string2.lowercased() 需要注意，在Swift3.0中Range结构体被划分成了两种类型，Range和ClosedRange，分别用来描述左闭右开区间和闭区间，对应到运算符为0..&lt;10和0…10。 从上面的示例代码中可以看出，String类型中的很多方法命名进行了Swift风格的简化，改动较大的一个点是关于下标index的改变，移除了两个Index下标移动的方法，使用String类型的index()方法来进行下标的移动操作，编程更加安全。 三.基础运算符中的改变Swift3.0中的基础运算符并无太大改动，只是移除了取余运算符的浮点数取余功能，取余运算符可以进行浮点运算本是Swift独有的一个特点，3.0版本的改变后，Swift中的&quot;%&quot;运算符功能将与Objective-C与C语言中的取余运算符保持一致。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解二十三——高级运算符","slug":"224Swift专题讲解二十三——高级运算符","date":"2016-05-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.345Z","comments":true,"path":"2016/05/31/224Swift专题讲解二十三——高级运算符/","link":"","permalink":"http://huishao.cc/2016/05/31/224Swift专题讲解二十三——高级运算符/","excerpt":"","text":"Swift专题讲解二十三——高级运算符一、引言除了前边博客中介绍的基本运算符外，Swift中还支持更多高级运算符，也支持开发者进行运算符的自定义。Swift中的算符运算符有一个特点，其不会产生溢出，如果有操作产生溢出，程序会直接抛出异常。如果开发者在开发中需要有溢出操作，需要使用溢出操作符来实现。 二、位运算符Swift支持C语言中的全部位运算符，示例如下： 1234567891011121314//二进制数据8 实际上a = 00001000 8位var a:UInt8 = 0b1000//使用~ 进行按位取反运算 a = 0b11110111 247a = ~a//使用&amp; 进行按位与运算 a = 0b11110000 240a = 0b11110000&amp;a//使用|进行按位或运算 a=0b11111111 255a = 0b11111111|a//使用^进行按位异或运算 a = 0b00001111 15a = 0b11110000^a//使用&lt;&lt;进行按位左移运算 a = 0b00011110 30a = a&lt;&lt;1//使用&gt;&gt;进行按位右移运算 a = 0b00001111a = a&gt;&gt;1 Swift中还提供了一种检查机制，当存在溢出操作时，程序会抛出异常，这样可以是开发者编写的代码更加安全，如果开发者真的需要使用溢出操作，Swift中还额外提供了支持溢出操作的运算符： 123456//a = 255 + 1 这样的运算会报错 &amp;+ 为溢出加运算符 计算后a=0a = 255 &amp;+ 1//&amp;- 为溢出减运算符 计算后 a = 255a = a &amp;- 1//&amp;* 为溢出乘运算符a = a &amp;* 2 三、重载运算符运算符的重载是为原有的运算符增加新的功能，开发者可以自定义一些运算符函数来实现对具体类和结构体运算的功能，示例如下： 12345678910111213class Circle &#123; //圆心 var point:(p1:Float,p2:Float) //半径 var r:Float init(point:(Float,Float),r:Float)&#123; self.point = point self.r = r &#125;&#125;func + (c1:Circle,c2:Circle) -&gt; Circle &#123; return Circle(point: c1.point, r: c1.r+c2.r)&#125; 上面代码演示的例子中重载了中缀运算符，即运算符是出现在两个操作数和中间的，还可以进行前缀运算符与后缀运算符的重载，使用prefix与postfix即可。示例如下： 123prefix func + (c:Circle) -&gt; Circle &#123; return Circle(point: c.point, r: c.r*2)&#125; 复合运算符也可以支持重载，需要注意的是，复合运算符的参数必须是inout修饰的，因为复合运算符会直接操作参数值： 123func += (inout c1:Circle,c2:Circle) &#123; c1 = Circle(point: c1.point, r: c1.r+c2.r)&#125; 等价运算符也可以用来重载，通常用来进行比较操作，示例如下： 123456func == (c1:Circle,c2:Circle) -&gt; Bool &#123; return (c1.point==c2.point &amp;&amp; c1.r==c2.r)&#125;func != (c1:Circle,c2:Circle) -&gt; Bool &#123; return ((c1.point != c2.point) || (c1.r != c2.r))&#125; 四、自定义运算符Swift中除了可以对一些已经存在的运算符进行重载操作外，开发者还可以自定义一些运算符，在自定义运算符时，必须指定运算符是前缀、中缀或是后缀，示例如下： 1234567//定义一个中缀运算符+!+ operator关键字用于定义运算符infix operator +!+&#123;&#125;//进行运算符的实现func +!+ (param:Int,param2:Int)-&gt;Int&#123; return (param+param2)*param2&#125;var b = 5 +!+ 5 还有一点需要注意，在进行自定义运算符时，开发者也可以为其设置结合性与优先级，结合性由associativity关键字定义，可选left，right，none，优先级的默认值为100，由precedence关键字指定，示例如下： 1234567//定义一个中缀运算符+!+infix operator +!+&#123;associativity left precedence 140&#125;//进行运算符的实现func +!+ (param:Int,param2:Int)-&gt;Int&#123; return (param+param2)*param2&#125;var b = 5 +!+ 5 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解二十二——泛型","slug":"223Swift专题讲解二十二——泛型","date":"2016-05-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.345Z","comments":true,"path":"2016/05/30/223Swift专题讲解二十二——泛型/","link":"","permalink":"http://huishao.cc/2016/05/30/223Swift专题讲解二十二——泛型/","excerpt":"","text":"Swift专题讲解二十二——泛型一、以泛型为参数的函数泛型是Swift语言强大的核心，泛型是对类型的抽象，使用泛型开发者可以更加灵活方便的表达代码意图。我们知道，有参函数的参数必须有一个明确的参数类型，有些时候开发者会遇到这样一种情况，编写一个函数用于交换两个变量的值，由于变量有类型之分，实现相同的功能，可能需要重载成多个函数来实现，这大大浪费了开发成本，使用泛型，可以完美的解决这个问题，示例代码如下： 12345678func exchange&lt;T&gt;(inout param1:T,inout param2:T)&#123; let tmp = param1 param1 = param2 param2 = tmp&#125;var p1 = \"15\"var p2 = \"40\"exchange(&amp;p1, param2: &amp;p2) 上面的方法可以实现对任意相同类型变量的交换，函数参数中使用泛型，需要在函数名后的&lt;&gt;中定义参数占位符，如有多个参数占位符，用逗号隔开即可。 二、泛型在类型中的应用泛型除了可以作为函数的参数、返回值外，在定义类型时，灵活应用泛型也可以解决很多十分棘手的问题，例如实现一个栈结构的集合类型，示例代码如下： 1234567891011121314151617struct Stack&lt;ItemType&gt; &#123; var items:[ItemType] = [] mutating func push(param:ItemType) &#123; self.items.append(param) &#125; mutating func pop()-&gt;ItemType&#123; return self.items.removeLast() &#125;&#125;//整型栈var obj1 = Stack&lt;Int&gt;()obj1.push(1)obj1.pop()//字符串栈var obj2 = Stack&lt;String&gt;()obj2.push(\"HS\")obj2.pop() 在对使用了泛型的类型进行扩展时，不需要在使用&lt;&gt;进行泛型的定义，直接使用原定义的泛型占位符即可，示例如下： 12345extension Stack&#123; func getArray() -&gt; [ItemType] &#123; return items &#125;&#125; 有时候，开发者需要对泛型进行一些约束，例如只允许此泛型是继承自某个类或者实现了某个协议，示例代码如下： 12345678910111213class MyClass &#123; &#125;//只有MyClass的子类可以进行Stack栈的创建struct Stack&lt;ItemType:MyClass&gt; &#123; var items:[ItemType] = [] mutating func push(param:ItemType) &#123; self.items.append(param) &#125; mutating func pop()-&gt;ItemType&#123; return self.items.removeLast() &#125;&#125; 在协议中，可以使用另一种方式来进行泛型编程，使用associatedtype关键字可以进行类型关联，示例如下： 123456789protocol MyProtocol &#123; //实现协议时才指定类型 associatedtype ItemType var param:ItemType &#123;get set&#125;&#125;class MyClass:MyProtocol &#123; //由于Swift可以自动识别类型 这是MyProtocol中的ItemType为Int var param: Int = 0&#125; 三、泛型与where子句的结合使用使用where子句可以对泛型进行更加严格约束，使其符合开发者需要的逻辑，示例如下： 123456789101112//T和C都要遵守整型协议class MyClassTwo&lt;T,C where T:IntegerType,C:IntegerType&gt; &#123; var param1:T var param2:C init(param1:T,param2:C)&#123; self.param1=param1 self.param2=param2 &#125;&#125;var obj3 = MyClassTwo(param1: 1, param2: 1) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解二十——扩展","slug":"221Swift专题讲解二十——扩展","date":"2016-05-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.344Z","comments":true,"path":"2016/05/29/221Swift专题讲解二十——扩展/","link":"","permalink":"http://huishao.cc/2016/05/29/221Swift专题讲解二十——扩展/","excerpt":"","text":"Swift专题讲解二十——扩展一、简介Swift中的扩展与Objective-C中的类别功能相似，扩展可以为一个已有的类、结构体、枚举或者协议添加新的属性或方法，与Objective-C的类别不同的是，Swift中的扩展没有名称。 Swift中的扩展支持如下功能： 1.添加计算属性 2.定义实例方法和类型方法 3.定义新的构造方法 4.定义下标方法 5.定义嵌套类型 6.使一个已有的类遵守协议 7.对协议进行扩展添加新的方法 二、使用扩展添加计算属性使用extension来声明扩展，示例代码如下： 1234567891011121314151617//创建一个类 有两个属性class MyClass &#123; var name:String var age:Int init()&#123; name = \"HS\" age = 24 &#125;&#125;//为MyClass类扩展一个计算属性extension MyClass &#123; var nameAndAge:String&#123; return \"\\(name)\"+\"\\(age)\" &#125;&#125;var obj = MyClass()obj.nameAndAge 三、使用扩展添加构造方法需要注意的是，扩展不能为类添加指定构造方法，只可以为其添加便利构造方法，示例代码如下： 1234567891011121314151617//创建一个类 有两个属性class MyClass &#123; var name:String var age:Int init()&#123; name = \"HS\" age = 24 &#125;&#125;extension MyClass&#123; convenience init(name:String,age:Int)&#123; self.init() self.name=name self.age=age &#125;&#125;var obj2 = MyClass(name: \"ZYH\", age: 24) 四、使用扩展添加实例方法与类型方法扩展可以为一个类型添加实例方法与类型方法，示例如下： 1234567891011121314151617181920212223//创建一个类 有两个属性class MyClass &#123; var name:String var age:Int init()&#123; name = \"HS\" age = 24 &#125;&#125;extension MyClass&#123; func logName() -&gt; String &#123; print(name) return name &#125; class func logClassName()&#123; print(\"MyClass\") &#125;&#125;var obj3 = MyClass()obj3.logName()MyClass.logClassName() 对于值类型的扩展，可以使用可变方法来修改实例本身，示例如下： 12345678910extension Int&#123; //修改本身需要使用nutating mutating func change() &#123; self = self*self &#125;&#125;var count = 3count.change()//打印9print(count) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解二十一——协议","slug":"222Swift专题讲解二十一——协议","date":"2016-05-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.345Z","comments":true,"path":"2016/05/29/222Swift专题讲解二十一——协议/","link":"","permalink":"http://huishao.cc/2016/05/29/222Swift专题讲解二十一——协议/","excerpt":"","text":"Swift专题讲解二十一——协议一、引言协议约定了一些属性与方法，其作用类似Java中的抽象类，Swift中类型通过遵守协议来实现一些约定的属性和方法。Swift中的协议使用protocol关键字来声明。Swift中的协议还有一个十分有意思的特性，协议可以通过扩展来实现一些方法和附加功能。 二、在协议中定义属性和方法协议中定义的属性只约定名称和类型，在具体类型的实现中，其可以是存储属性也可以是计算属性，协议中还需要指定属性是可读的还是可读可写的。示例代码如下： 12345678910111213141516171819202122232425262728protocol MyPortocol &#123; //定义实例属性 //可读的 var name:String&#123;get&#125; //可读可写的 var age:Int&#123;set get&#125; //可读的 var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125;&#125;class MyClass: MyPortocol &#123; var name: String var age: Int var nameAndAge: String&#123; get&#123; return \"\\(name)\"+\"\\(age)\" &#125; &#125; static var className: String&#123; get&#123; return \"MyClass\" &#125; &#125; init()&#123; name = \"HS\" age = 24 &#125;&#125; 有一点需要注意，协议中的可读并不是只读，协议中的属性约定成可读可写，则在实现时，这个属性必须是可读可写的，但是如果协议中约定成可读的，则此属性可以是只读的也可以是可读可写的，看具体的实现。 协议中约定的方法可以是实例方法也可以是类型方法，示例如下： 123456789101112131415161718protocol MyPortocol &#123; func logName() static func logClassName()&#125;class MyClass: MyPortocol &#123; var name: String var age: Int init()&#123; name = \"HS\" age = 24 &#125; func logName() &#123; print(name) &#125; static func logClassName() &#123; print(className) &#125;&#125; 同样，协议中也可以对构造方法进行定义约定。 三、协议的特点协议中虽然没有任何属性和方法的实现，但是其仍然可以当做类型来使用，在函数参数、返回值中应用广泛，示例如下： 12345678910111213protocol MyPortocol &#123; //定义实例属性 var name:String&#123;get&#125; var age:Int&#123;set get&#125; var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125; func logName() static func logClassName()&#125;//将协议类型作为参数func test(param:MyPortocol) &#123; param.logName()&#125; 协议作为类型这种用法另一个应用点是在集合类型中，协议可以作为所有遵守此协议的集合类型。 协议可以像其他类型一样进行继承，子协议将自动拥有父协议约定的属性和方法。协议也可以通过class关键字来定义只有类可以进行遵守，示例如下： 12345678910111213protocol MyPortocol &#123; //定义实例属性 var name:String&#123;get&#125; var age:Int&#123;set get&#125; var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125; func logName() static func logClassName()&#125;//只有类可以继承此协议protocol MySubPortocol:class,MyPortocol &#123; &#125; 协议既然可以像其他类型一样进行使用，当然它也可以使用is，as?，as!进行检查和转换，关于is，as的更多用法可以查看Swift关于类型转换的内容。 协议也可定义其中的属性或方法为可选的，即遵守此协议的类可以实现也可以不实现可选的属性和方法，然而，声明为可选的需要此协议为@objc类型的，示例如下： 12345678910@objc protocol MyPortocol &#123; //定义实例属性 var name:String&#123;get&#125; var age:Int&#123;set get&#125; var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125; func logName() //可选实现 optional static func logClassName()&#125; Swift中的协议还有一个十分重要的特性，其可以通过扩展来进行属性、方法以及下标的实现。这对于一些通用类的方法十分方便，这相当于所有继承此协议的类都默认实现了这样的方法，示例如下： 1234567891011121314protocol MyPortocol &#123; //定义实例属性 var name:String&#123;get&#125; var age:Int&#123;set get&#125; var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125; func logName() static func logClassName()&#125;extension MyPortocol&#123; var name:String&#123; return \"HS\" &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十九——类型转换","slug":"220Swift专题讲解十九——类型转换","date":"2016-05-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.344Z","comments":true,"path":"2016/05/27/220Swift专题讲解十九——类型转换/","link":"","permalink":"http://huishao.cc/2016/05/27/220Swift专题讲解十九——类型转换/","excerpt":"","text":"Swift专题讲解十九——类型转换一、类型检查与转换在Objective-C和Java中，任何类型实例都可以通过强转使编译器认为它是另一种类型的实例，这么做其实是将所有的安全检查工作都交给了开发者自己来做。先比之下，Swift中的Optional类型转换就会比较安全与可靠。 Swift中使用is关键字来进行类型的检查，其会返回一个布尔值true或者false来表明检查是否成立，示例如下： 1234var str = \"HS\"if str is String &#123; print(str)&#125; Swift中有向上兼容与向下转换的特性，就是说，一个父类类型的集合可以接收子类的实例，同样，在使用这些实例变量时可以将其向下转换为子类类型，示例如下： 1234567891011121314151617181920212223242526272829303132333435//自定义一个类及其子类class MyClass &#123; var name:String?&#125;class MySubClassOne: MyClass &#123; var count:Int?&#125;class MySubClassTwo: MyClass &#123; var isBiger:Bool?&#125;//创建3个实例var obj1 = MyClass()obj1.name = \"HS\"var obj2 = MySubClassOne()obj2.count = 100var obj3 = MySubClassTwo()obj3.isBiger=true//将实例存放在其公共父类类型的数组集合中var array:[MyClass] = [obj1,obj2,obj3]//进行遍历for var i in 0..&lt;array.count &#123; var obj = array[i] if obj is MySubClassOne &#123; print((obj as! MySubClassOne).count!) continue &#125; if obj is MySubClassTwo &#123; print((obj as! MySubClassTwo).isBiger!) continue &#125; if obj is MyClass &#123; print(obj.name!) &#125;&#125; 有一点需要注意，在进行类型转换时，可以使用as!或者as?来进行，as!是一种强制转换方法，它在开发者确定类型无误是使用，如果用as!转换的类型有误，则会出现运行时错误。as?是Optional类型转换，如果转换失败，则会返回nil。 二、Any和AnyObject类型在Objective-C中，常常使用id来表示引用类型的泛型，Swift中的AnyObject与之类似。示例如下： 123456789101112131415//进行遍历for var i in 0..&lt;array.count &#123; var obj = array[i] if obj is MySubClassOne &#123; print((obj as! MySubClassOne).count!) continue &#125; if obj is MySubClassTwo &#123; print((obj as! MySubClassTwo).isBiger!) continue &#125; if obj is MyClass &#123; print((obj as! MyClass).name!) &#125;&#125; Any类型则比AnyOject类型更加强大，其可以混合值类型和引用类型一起工作，示例如下： 1var anyArray:[Any] = [100,\"HS\",obj1,obj2,false,(1.1),obj3,&#123;()-&gt;() in print(\"Closures\")&#125;] 上面示例的数组中包含了整型，字符串类型，引用类型，布尔类型和闭包。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十八——异常处理","slug":"219Swift专题讲解十八——异常处理","date":"2016-05-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.344Z","comments":true,"path":"2016/05/26/219Swift专题讲解十八——异常处理/","link":"","permalink":"http://huishao.cc/2016/05/26/219Swift专题讲解十八——异常处理/","excerpt":"","text":"Swift专题讲解十八——异常处理一、异常的抛出与传递代码的运行很多时候并不会完全按照程序员的设想进行，编写代码时进行可控的异常处理机制是十分必要的。通常，对于一个特定的操作，程序员可以定义一个继承自ErrorType的枚举来进行异常类型的描述，使用throw关键字来进行异常的抛出，示例代码如下： 12345678//定义一个自定义的错误类型enum MyError:ErrorType &#123; case DesTroyError case NormalError case SimpleError&#125;//进行异常的抛出throw MyError.NormalError 函数可以进行错误的传递，需要使用throws关键字来声明这个函数可能会抛出错误，如果不如此声明，则函数内部抛出的错误只能在函数内部解决，throws关键字标记的函数内部抛出的错误会被传递到调用函数的地方，开发者可以在调用函数的地方捕获到错误描述来做相应处理，示例如下： 123func MyFunc()throws -&gt; Void &#123; throw MyError.NormalError&#125; 对于可能抛出异常的函数调用，开发者要么在调用函数的地方捕获处理这些异常，要么使用try关键字将异常继续抛出去，等待下一层捕获者处理。异常的处理后面会介绍，继续抛出异常示例如下： 1try MyFunc() 二、异常的处理除了将错误继续向上抛出之外，Swift还提供了3种处理异常的方式。 1.使用do-catch语句来捕获异常开发者可以使用do-catch语句来捕获异常，通过异常类型的判断来分别做处理，示例代码如下: 123456789101112do&#123; try MyFunc()&#125;catch MyError.DesTroyError&#123;//将打印error1 print(\"error1\")&#125;catch MyError.NormalError&#123; print(\"error2\")&#125;catch MyError.SimpleError&#123; print(\"error3\")&#125;catch&#123;//如果上面所有的catch都没有捕获 会走这个异常捕获判断 print(\"all\")&#125; 2.将异常映射为Optional值处理异常抛出的第2中方式是使用try?将异常映射为Optional值，可以简单理解为，对一个可能抛出异常的函数的调用，如果有异常抛出，则返回值为nil，如果没有，则函数顺利执行，返回值为其原返回值，示例如下: 12//将返回niltry? MyFunc() 注意：返回值为Void并非为nil，结合if-let语句可以编写十分飘逸的代码，示例如下： 12345if let _=try?MyFunc() &#123; print(\"success\")&#125;else&#123; print(\"fail\")&#125; 3.终止异常传递有时候开发者可以保证一个可能抛出异常的函数绝对不会抛出异常，这时开发者可以使用try!的方式来终止异常的传递，但是这样做有一定风险，如果这个函数真的抛出了异常，则会产生运行时错误。示例如下： 1try! MyFunc() 三、延时执行语句对于某些释放资源类的操作，开发者总是希望其离开当前代码块时被执行，然后一个复杂流程结构可能会因异常抛出，return，break这些方式被终止，因此，Swift中提供了defer语句来进行延时执行一些操作，defer中的语句总是会在当前代码块将要结束时才执行，无论它是以哪种方式结束的，示例如下： 1234567891011121314//执行此函数将打印/* Care finish */func MyFunc()throws -&gt; Void &#123; defer&#123; print(\"finish\") &#125; print(\"Care\") throw MyError.DesTroyError &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十七——Optional链","slug":"218Swift专题讲解十七——Optional链","date":"2016-05-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.343Z","comments":true,"path":"2016/05/24/218Swift专题讲解十七——Optional链/","link":"","permalink":"http://huishao.cc/2016/05/24/218Swift专题讲解十七——Optional链/","excerpt":"","text":"Swift专题讲解十七——Optional链Swift中的Optional值有这样的特性，当对其进行可选拆包时，即使用?进行Optional类型值的取值时，如果Optional值不为nil，则会返回原始类型的数据值，如果为nil，则会返回nil。因此，当使用?对Optional拆包后进行方法、属性或者下标的调用时，如果有值，则会成功相应调用，如果没有值，则会调用失败，返回nil。 注意：使用!则会进行强制拆包，这时如果Optional值为nil，则会出现运行时错误，因此开发者在使用!进行强制拆包时，必须确认Optional类型值不为nil。 当对可选值进行可选拆包并调用其属性或方法后，无论原属性或者方法返回值是什么类型的，都会被包装成Optional值类型。当使用?对一个Optional值进行拆包并调用其方法时，方法的返回值一会被包装为Optional类型，示例如下： 12345678910111213class Myclass &#123; var cls:MyClassTwo? &#125;class MyClassTwo &#123; func run() -&gt; String &#123; return \"run\" &#125;&#125;let obj:Myclass = Myclass()//将返回nilobj.cls?.run() 在进行Optional链调用的时候，会遵守如下一些特性： 1.如果进行?拆包Optional值的属性或者方法返回值原来为非Optional值，则会包装成Optional值。 2.如果进行?拆包Optional值的属性或者方法返回值原来为Optional值，则依然会返回Optional值，并且并不会进行Optional值类型的嵌套。 3.由于使用Optional值?可选拆包时会将其属性和方法的返回值都包装成Optional类型的，因此使用?可以进行Optional链式调用，这其间，有一个环节调用失败，整个链都会返回nil。示例如下： 123let obj:Myclass = Myclass()//将返回nil(obj.cls?.run())?.startIndex 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"iOS进度指示器——NSProgress","slug":"217iOS进度指示器——NSProgress","date":"2016-05-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.343Z","comments":true,"path":"2016/05/22/217iOS进度指示器——NSProgress/","link":"","permalink":"http://huishao.cc/2016/05/22/217iOS进度指示器——NSProgress/","excerpt":"","text":"iOS进度指示器——NSProgress一、引言在iOS7之前，系统一直没有提供一个完整的框架来描述任务进度相关的功能。这使得在开发中进行耗时任务进度的监听将什么麻烦，在iOS7之后，系统提供了NSProgress类来专门报告任务进度。 二、创建单任务进度监听器单任务进度的监听是NSProgress最简单的一种运用场景，我们来用定时器模拟一个耗时任务，示例代码如下： 123456789101112131415161718192021222324252627282930@interface ViewController ()&#123; NSProgress * progress;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //这个方法将创建任务进度管理对象 UnitCount是一个基于UI上的完整任务的单元数 progress = [NSProgress progressWithTotalUnitCount:10]; NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(task) userInfo:nil repeats:YES]; //对任务进度对象的完成比例进行监听 [progress addObserver:self forKeyPath:@\"fractionCompleted\" options:NSKeyValueObservingOptionNew context:nil];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; NSLog(@\"进度= %f\",progress.fractionCompleted);&#125;-(void)task&#123; //完成任务单元数+1 if (progress.completedUnitCount&lt;progress.totalUnitCount) &#123; progress.completedUnitCount +=1; &#125; &#125; 上面的示例代码中，fractionCompleted属性为0-1之间的浮点值，为任务的完成比例。NSProgress对象中还有两个字符串类型的属性，这两个属性将进度信息转化成固定的格式： 1234//显示完后比例 如：10% completed@property (null_resettable, copy) NSString *localizedDescription;//完成数量 如：1 of 10@property (null_resettable, copy) NSString *localizedAdditionalDescription; 三、创建多任务进度监听器上面演示了只有一个任务时的进度监听方法，实际上，在开发中，一个任务中往往又有许多子任务，NSProgress是以树状的结构进行设计的，其支持子任务的嵌套，示例如下： 1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //这个方法将创建任务进度管理对象 UnitCount是一个基于UI上的完整任务的单元数 progress = [NSProgress progressWithTotalUnitCount:10]; //对任务进度对象的完成比例进行监听 [progress addObserver:self forKeyPath:@\"fractionCompleted\" options:NSKeyValueObservingOptionNew context:nil]; //向下分支出一个子任务 子任务进度总数为5个单元 即当子任务完成时 父progerss对象进度走5个单元 [progress becomeCurrentWithPendingUnitCount:5]; [self subTaskOne]; [progress resignCurrent]; //向下分出第2个子任务 [progress becomeCurrentWithPendingUnitCount:5]; [self subTaskOne]; [progress resignCurrent];&#125;-(void)subTaskOne&#123; //子任务总共有10个单元 NSProgress * sub =[NSProgress progressWithTotalUnitCount:10]; int i=0; while (i&lt;10) &#123; i++; sub.completedUnitCount++; &#125;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; NSLog(@\"= %@\",progress.localizedAdditionalDescription);&#125; NSProgress的这种树状设计模式乍看起来确实有些令人费解，有一点需要注意，becomeCurrentWithPendingUnitCount:方法的意义是将此NSProgress对象注册为当前线程任务的根进度管理对象，resignCurrent方法为取消注册，这两个方法必须成对出现，当一个NSProgress对象被注册为当前线程的根节点时，后面使用类方法 progressWithTotalUnitCount:创建的NSProgress对象都默认作为子节点添加。 四、iOS9之后进行多任务进度监听的新设计方法正如上面的例子所演示，注册根节点的方式可读性很差，代码结构也不太清晰，可能Apple的工程师们也觉得如此，在iOS9之后，NSProgress类中又添加了一些方法，通过这些方法可以更加清晰的表达进度指示器之间的层级结构，示例代码如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //这个方法将创建任务进度管理对象 UnitCount是一个基于UI上的完整任务的单元数 progress = [NSProgress progressWithTotalUnitCount:10]; //对任务进度对象的完成比例进行监听 [progress addObserver:self forKeyPath:@\"fractionCompleted\" options:NSKeyValueObservingOptionNew context:nil]; //创建子节点 NSProgress * sub = [NSProgress progressWithTotalUnitCount:10 parent:progress pendingUnitCount:5]; NSProgress * sub2 = [NSProgress progressWithTotalUnitCount:10 parent:progress pendingUnitCount:5]; for (int i=0; i&lt;10; i++) &#123; sub.completedUnitCount ++; sub2.completedUnitCount ++; &#125;&#125; 如上面代码所示，代码结构变得更加清晰，可操作性也更强了。 五、一点小总结123456789101112131415161718192021222324252627282930313233//获取当前线程的进度管理对象根节点//注意：当有NSProgress对象调用了becomeCurrentWithPendingUnitCount:方法后，这个方法才能获取到+ (nullable NSProgress *)currentProgress;//创建一个NSProgress对象，需要传入进度的单元数量+ (NSProgress *)progressWithTotalUnitCount:(int64_t)unitCount;//和上一个方法功能相似 iOS9之后的新方法+ (NSProgress *)discreteProgressWithTotalUnitCount:(int64_t)unitCount;//iOS9之后的新方法 创建某个进度指示器节点的子节点+ (NSProgress *)progressWithTotalUnitCount:(int64_t)unitCount parent:(NSProgress *)parent pendingUnitCount:(int64_t)portionOfParentTotalUnitCount;//NSProgress实例的初始化方法 自父节点参数可以为nil- (instancetype)initWithParent:(nullable NSProgress *)parentProgressOrNil userInfo:(nullable NSDictionary *)userInfoOrNil;//注册为当前线程根节点- (void)becomeCurrentWithPendingUnitCount:(int64_t)unitCount;//取消注册 与注册方法必须同步出现- (void)resignCurrent;//iOS9新方法 向一个节点中添加一个子节点- (void)addChild:(NSProgress *)child withPendingUnitCount:(int64_t)inUnitCount;//进度单元总数@property int64_t totalUnitCount;//已完成的进度单元数@property int64_t completedUnitCount;//是否可取消@property (getter=isCancellable) BOOL cancellable;//是否可暂停@property (getter=isPausable) BOOL pausable;//进度比例 0-1之间@property (readonly) double fractionCompleted;//取消- (void)cancel;//暂停- (void)pause;//恢复- (void)resume 六、关于NSProgress对象的用户配置字典在NSProgress对象的用户字典中可以设置一些特定的键值来进行显示模式的设置，示例如下： 123456789101112131415161718192021222324252627//设置剩余时间 会影响localizedAdditionalDescription的值/*例如：0 of 10 — About 10 seconds remaining*/[progress setUserInfoObject:@10 forKey:NSProgressEstimatedTimeRemainingKey];//设置完成速度信息 会影响localizedAdditionalDescription的值/*例如：Zero KB of 10 bytes (15 bytes/sec)*/[progress setUserInfoObject:@15 forKey:NSProgressThroughputKey];/*下面这些键值的生效 必须将NSProgress对象的kind属性设置为 NSProgressKindFileNSProgressFileOperationKindKey键对应的是提示文字类型 会影响localizedDescription的值NSProgressFileOperationKindKey可选的对应值如下：NSProgressFileOperationKindDownloading： 显示Downloading files…NSProgressFileOperationKindDecompressingAfterDownloading： 显示Decompressing files…NSProgressFileOperationKindReceiving： 显示Receiving files…NSProgressFileOperationKindCopying： 显示Copying files…*/ [progress setUserInfoObject:NSProgressFileOperationKindDownloading forKey:NSProgressFileOperationKindKey];/*NSProgressFileTotalCountKey键设置显示的文件总数 例如：Copying 100 files…*/ [progress setUserInfoObject:@100 forKey:NSProgressFileTotalCountKey];//设置已完成的数量[progress setUserInfoObject:@1 forKey:NSProgressFileCompletedCountKey]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Swift专题讲解十五——类型构造","slug":"215Swift专题讲解十五——类型构造","date":"2016-05-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.343Z","comments":true,"path":"2016/05/19/215Swift专题讲解十五——类型构造/","link":"","permalink":"http://huishao.cc/2016/05/19/215Swift专题讲解十五——类型构造/","excerpt":"","text":"Swift专题讲解十五——类型构造一、引言构造是类、结构体、枚举在实例化中必须执行的过程，在构造过程中，类、结构体必须完成其中存储属性的构造。Swift中的构造通过构造方法来完成，和Objective-C中的init初始化系列方法不同，Swift中的构造方法并不会也无需返回值，它的任务即是完成实例化过程。 二、属性的构造类和结构体的存储属性必须在实例化完成前被构造完成，因此，有两种方式来这么做： 1.类或者结构体中声明存储属性时直接为其设置默认值。 2.在类或者结构体的构造方法中对存储属性进行构造。 这里有一点需要注意：在存储属性设置默认值或者在构造方法中进行构造时，并不会触发属性监听器willSet、didSet方法。示例代码如下： 1234567891011121314class MyClass &#123; var count:Int=0&#123; willSet&#123; print(&quot;willset&quot;) &#125; &#125; var name:String init()&#123; //必须进行构造或者设置值 count=5 count=6 name = &quot;HS&quot; &#125;&#125; init()方法为不带参数的构造方法，所有构造方法都需要用init()来标识，开发者可以使用函数重载的方式来创建不同的构造方法。官方推荐，如果一个类的大多实例的某个存储属性都需要相同的值，强烈推荐开发者设置此存储属性的默认值，这样可以很好的应用Swift语言的类型推断功能并且可以使代码结构更加紧凑。 如果一个属性在逻辑上是允许为nil的，则开发者可以将其声明称Optional值类型，在进行类的实例化时，Optional类型的属性如果没有赋值会被自动赋值为nil。 注意，常量也需要在构造完成之前进行赋值，一旦赋值或构造完成，常量将不能被修改。 三、构造方法首先，如果类或者结构体中的所有存储属性都有默认值，那个如果开发者不提供构造方法，Swift也会自动生成一个默认构造方法，无参的init()，在进行类型的实例化时，将默认构造所有存储属性都是默认值的实例。示例如下： 1234567class MyClassTwo &#123; var count = 10 var name = &quot;HS&quot;&#125;//默认的init()构造方法var obj = MyClassTwo()print(obj.count,obj.name) 结构体会比较特殊，就算没有为其存储属性设置初值，它也会自动生成构造方法，这个构造方法中会自带所有没有赋默认值的属性名作为参数，示例如下： 12345struct Shape &#123; var center:(Int,Int) var name:String&#125;var shape = Shape(center: (1,1), name: &quot;circle&quot;) 还有一点需要注意，对于值类型(结构体，枚举)，如果开发者自定义了一个构造方法，则默认的构造方法将会失效，这样设计是为了安全性考虑，防止误用到系统的默认构造方法。并且，对于值类型(结构体，枚举)的构造方法，是支持嵌套调用的，示例如下： 123456789101112struct Shape &#123; var center:(Int,Int) var name:String init() &#123; center = (0,0) name = &quot;HS&quot; &#125; init(param:String)&#123; self.init() &#125;&#125;var shape = Shape(param: &quot;&quot;) 四、类的Designated构造方法与Convenience构造方法在前面的一篇博客中，我曾经专门讨论过Swift中的构造方法，博客地址如下，可供参考： Swift中的构造方法解析：http://my.oschina.net/u/2340880/blog/660134。 Designated构造方法也被称为指定构造方法，它是类的核心构造方法，指定构造方法将完成类中所有需要构造或赋值过程。如果一个类继承于另一个类而来，则指定构造方法需要调用父类的构造方法来完成父类中属性的初始。Convenience工作方法也被称为便利构造方法，其主要作为辅助的构造方法存在，便利构造方法需要调用类中的指定构造方法来完成构造，从这一点看，实际上类是通过便利构造方法来实现类似值类型的构造方法的嵌套使用。指定构造方法不需要多余关键字来修饰，其默认就是Designated类型的，便利构造方法需要使用convenience关键字类修饰，示例如下： 12345678910111213class MyClassTwo &#123; var count = 10 var name = \"HS\" init(name:String)&#123; self.name = name &#125; convenience init(count:Int)&#123; self.init(name:\"HS\") self.count = count &#125;&#125;var obj = MyClassTwo(count:5)print(obj.count,obj.name) 类的构造方法需要遵守下面3条规则： 1.指定构造方法必须调用其父类的指定构造方法。 2.便利构造方法必须调用同类中的其他构造方法。 3.便利构造方法调用到最上层必须调用一个指定构造方法。 语言文档中提供如下示例图来结束指定构造方法和便利构造方法的关系： 五、构造方法的安全特性Swift是一种十分注重类型安全的语言，这种语言特性的优势在于类在实例化后，所有的属性都是开发者明确可控的。Swift的编译器在类的构造方法中会进行4中安全性检查： 检查1：指定构造器中必须完成所有存储属性的赋值后才能调用父类的指定构造方法，示例如下： 1234567class MyClassThree: MyClassTwo &#123; var param:Int init()&#123; param = 100 super.init(name: \"HS\") &#125;&#125; 检查2：子类如果要自定义父类中存储属性的值，必须要调用父类的构造方法之后设置，示例如下： 123456789class MyClassThree: MyClassTwo &#123; var param:Int init()&#123; param = 100 super.init(name: \"HS\") //重设继承父类属性的name值 self.name = \"New\" &#125;&#125; 检查3：如果便利构造方法中需要重新设置某些属性的值，必须在调用指定构造方法之后设置，否则会被覆盖。 检查4：在完成父类构造方法之前，不能使用self来引用属性。 六、构造方法的继承Swift和Objective-C有很大不同，其构造方法不会被子类无条件的继承。Swift中类的构造方法的继承遵守下面两个原则： 1.如果子类没有定义任何的指定构造方法，则子类会默认继承父类所有的指定构造方法。 2.如果子类中提供了父类所有指定构造方法，无论是覆写的还是继承的，则子类会默认继承下来父类的便利构造方法。 上面两个原则可能有些难以理解，第1个原则实际上也说明子类如果定义了自己的指定构造方法，或者覆写了父类的某个指定构造方法，则子类不再继承父类所有的指定构造方法。第2个原则可以这样理解：因为所有便利构造方法最终都要调用到指定构造方法，所以只要子类中有提供这个便利构造方法需要调用的指定构造方法，这个便利构造方法就会被继承。 重写父类的指定构造方法需要使用override关键字，但是，便利构造方法并不存在重写的概念，因为其必须调用本类的其他构造方法，因此无论子类中定义的便利构造方法与父类是否相同，都是子类独立的便利构造方法。 七、可失败构造方法在开发中还会遇到一种情况，某些构造方法需要传入一些参数，当参数不符合要求时，此构造过程可能会失败，这时，开发者可以使用可失败的构造方法来进行类型的构造，例如在类中创建可失败的构造方法示例示例如下： 12345678910111213141516class MyClassThree: MyClassTwo &#123; var param:Int init()&#123; param = 100 super.init(name: \"HS\") //重设继承父类属性的name值 self.name = \"New\" &#125; init?(suc:Bool)&#123; guard(suc)else&#123; return nil &#125; param=1 super.init(name: \"1\") &#125;&#125; 八、必要构造方法如果某些构造方法是类与其子类都必须实现的，则可以使用required关键字来将其修饰为必要的构造方法，子类必须继承或者覆写父类的必要构造方法，示例如下： 12345678910111213141516class MyClassThree: MyClassTwo &#123; var param:Int required init()&#123; param = 100 super.init(name: \"HS\") //重设继承父类属性的name值 self.name = \"New\" &#125; init?(suc:Bool)&#123; guard(suc)else&#123; return nil &#125; param=1 super.init(name: \"1\") &#125;&#125; 还有一点需要注意，如果某些属性的值设置十分复杂，开发者可以使用闭包的方式来为属性设置初始值，示例如下： 12345678910111213141516171819class MyClassThree: MyClassTwo &#123; //注意 闭包的后面必须加()，否则会将param当成一个闭包属性来处理 var param:Int = &#123; return 6*6+6 &#125;() required init()&#123; param = 100 super.init(name: \"HS\") //重设继承父类属性的name值 self.name = \"New\" &#125; init?(suc:Bool)&#123; guard(suc)else&#123; return nil &#125; param=1 super.init(name: \"1\") &#125;&#125; 九、析构方法当类实例将要被释放时，系统会自动调用类的析构方法，析构方法deinit()没有参数和返回值，并且只有类有析构方法，开发者可以在其中进行一些资源的释放操作，当var类型变量被赋值为nil时，实例会被释放。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十六——ARC在Swift中的应用","slug":"216Swift专题讲解十六——ARC在Swift中的应用","date":"2016-05-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.343Z","comments":true,"path":"2016/05/19/216Swift专题讲解十六——ARC在Swift中的应用/","link":"","permalink":"http://huishao.cc/2016/05/19/216Swift专题讲解十六——ARC在Swift中的应用/","excerpt":"","text":"Swift专题讲解十六——ARC在Swift中的应用一、引言ARC（自动引用计数）是Objective-C和Swift中用于解决内存管理问题的方案。在学习Objective-C编程时经常会学习到一个关于ARC的例子：在一个公用的图书馆中，每次进入一人就将卡插入，走的时候将自己的卡拔出拿走。图书馆系统会判定只要有卡插入，就将图书馆的灯打开，当所有卡都被取走后，将图书馆的灯关掉。这个例子对应于Objective-C中的对象声明周期管理十分贴切。每当一个对象增加一个引用时，其引用计数会加1，当一个引用被取消时，对象的引用计数减1，当引用计数减为0时，说明此对象将不再有任何引用，对象会被释放掉，让出内存。Swift也采用同样的方式进行内存管理。 注意：在Swift中只有引用类型有自动引用计数，结构体、枚举这类值类型是没有引用计数的。关于引用计数的示例代码如下： 123456789101112class MyClass &#123; deinit&#123; print(&quot;MyClass deinit&quot;) &#125;&#125;var cls1:MyClass? = MyClass()var cls2:MyClass? = cls1var cls3:MyClass? = cls2cls2 = nilcls1 = nil//执行下面代码后才会打印“MyClass deinit”cls3 = nil 二、循环引用的处理方法在开发中，开发者一不小心就会写出产生循环引用的代码，在上面的示例中可以看出，除非实例的引用全部解除，否则实例将不会调用析构方法，内存不会被释放，如果在写代码时，A引用了B，同样B也引用了A，那么实际上现在A和B的引用计数都是2，将A和B都置为nil后，A和B实例依然保有1个引用计数，都不会被释放，实例如下： 12345678910111213141516171819class MyClassOne &#123; var cls:MyClassTwo? deinit&#123; print(\"ClassOne deinit\") &#125;&#125;class MyClassTwo &#123; var cls:MyClassOne? deinit&#123; print(\"ClassTwo deinit\") &#125;&#125;var obj1:MyClassOne? = MyClassOne()var obj2:MyClassTwo? = MyClassTwo()obj1?.cls = obj2obj2?.cls = obj1obj1=nilobj2=nil//没有打印析构函数的调用信息 对于上面的情况，可以将属性声明称weak类型来防止这种循环引用，weak的作用在于只是弱引用实例，原实例的引用计数并不会加1，示例如下： 1234567891011121314151617181920//关于弱引用的演示class MyClassThree&#123; weak var cls:MyClassFour? deinit&#123; print(\"ClassThree deinit\") &#125;&#125;class MyClassFour &#123; var cls:MyClassThree? deinit&#123; print(\"ClassFour deinit\") &#125;&#125;var obj3:MyClassThree? = MyClassThree()var obj4:MyClassFour? = MyClassFour()obj3?.cls = obj4obj4?.cls = obj3obj4=nil//此时obj3中的cls也为nilobj3?.cls 若引用的实例被释放后，其在另一个实例中的引用也将被置为nil，所以weak只能用于optional类型的属性，然而在开发中还有一种情况，某个类必须保有另一个类的示例，这个实例不能为nil，但是这个属性又不能影响其原始实例的释放，这种情况也会造成循环引用，示例如下： 123456789101112131415161718192021class MyClassFive&#123; var cls:MyClassSix init(param:MyClassSix)&#123; cls = param &#125; deinit&#123; print(\"ClassFive deinit\") &#125;&#125;class MyClassSix&#123; var cls:MyClassFive? deinit&#123; print(\"ClassSix deinit\") &#125;&#125;var obj6:MyClassSix? = MyClassSix()var obj5:MyClassFive? = MyClassFive(param: obj6!)obj6?.cls = obj5obj5=nilobj6=nil//没有打印任何信息 上面的示例也会造成循环引用，然而MyClassFive类中的cls属性为常量不可为nil，不可使用weak弱引用来做Swift中又提供了一个关键字unowned无主引用来处理这样的问题，示例如下： 1234567891011121314151617181920class MyClassFive&#123; unowned var cls:MyClassSix init(param:MyClassSix)&#123; cls = param &#125; deinit&#123; print(\"ClassFive deinit\") &#125;&#125;class MyClassSix&#123; var cls:MyClassFive? deinit&#123; print(\"ClassSix deinit\") &#125;&#125;var obj6:MyClassSix? = MyClassSix()var obj5:MyClassFive? = MyClassFive(param: obj6!)obj6?.cls = obj5obj5=nilobj6=nil 关于弱引用和无主引用，其区别主要是在于： 1.弱引用用于解决Optional值的引起的循环引用。 2.无主引用用于解决非Optional值引起的循环引用。 3.个人以为，弱引用可用下图表示： 4.无主引用可用如下图表示： 若将上面的代码修改如下，程序会直接崩溃： 1234567891011121314151617181920class MyClassFive&#123; unowned var cls:MyClassSix init(param:MyClassSix)&#123; cls = param &#125; deinit&#123; print(\"ClassFive deinit\") &#125;&#125;class MyClassSix&#123; var cls:MyClassFive? deinit&#123; print(\"ClassSix deinit\") &#125;&#125;var obj6:MyClassSix? = MyClassSix()var obj5:MyClassFive? = MyClassFive(param: obj6!)obj6?.cls = obj5obj6=nilobj5?.cls 上面所举的例子满足了两种情况，一种是两类实例引用的属性都是Optional值的时候使用weak来解决循环引用，一种是两类实例有一个为非Optional值的时候使用unowned来解决循环引用，然而还有第三种情况，两类实例引用的属性都为非Optional值的时候，可以使用无主引用与隐式拆包结合的方式来解决，这也是无主引用最大的应用之处，示例如下： 1234567891011121314151617181920class MyClassSeven&#123; unowned var cls:MyClassEight init(param:MyClassEight)&#123; cls = param &#125; deinit&#123; print(\"ClassSeven deinit\") &#125;&#125;class MyClassEight&#123; var cls:MyClassSeven! init()&#123; cls = MyClassSeven(param:self) &#125; deinit&#123; print(\"ClassEight deinit\") &#125;&#125;var obj7:MyClassEight? = MyClassEight()obj7=nil 除了在两个类实例间会产生循环引用，在闭包中，也可能出现循环引用，当某个类中包含一个闭包属性，同时这个闭包属性中又使用了类实例，则会产生循环引用，示例如下： 1234567891011121314class MyClassNine &#123; var name:String = \"HS\" lazy var closure:()-&gt;Void = &#123; //闭包中使用引用值会使引用+1 print(self.name) &#125; deinit&#123; print(\"ClassNine deinit\") &#125;&#125;var obj9:MyClassNine? = MyClassNine()obj9?.closure()obj9=nil//不会打印析构信息 Swift中提供了闭包的捕获列表来对引用类型进行弱引用或者无主引用的转换： 12345678910111213class MyClassNine &#123; var name:String = \"HS\" lazy var closure:()-&gt;Void = &#123; [unowned self]()-&gt;Void in print(self.name) &#125; deinit&#123; print(\"ClassNine deinit\") &#125;&#125;var obj9:MyClassNine? = MyClassNine()obj9?.closure()obj9=nil 捕获列表以中括号标识，多个捕获参数则使用逗号分隔。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十四——继承","slug":"214Swift专题讲解十四——继承","date":"2016-05-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.342Z","comments":true,"path":"2016/05/18/214Swift专题讲解十四——继承/","link":"","permalink":"http://huishao.cc/2016/05/18/214Swift专题讲解十四——继承/","excerpt":"","text":"Swift专题讲解十四——继承一、引言Swift中，一个类可以从另一个类继承方法、属性、下标及其他特性。当一个类继承于另一个类时，这个类被称为子类，所继承的类被称为父类。在Swift中，继承是类区别于其他类型的主要特征。子类除了可以调用父类的属性，下标，方法外，其也可以对父类的属性，下标，方法进行覆写。 二、定义一个基类不继承于任何类的类被称为基类，示例如下： 123456class Shape &#123; var center:(Double,Double) init()&#123; center = (0,0) &#125;&#125; 上面代码定义了一个图形类，其中定义了一个中心点，任何图形都会有中心点，所以把其作为基类属性。 三、定义一个子类图形基类可以派生出许多图形子类，例如矩形，圆形等，示例代码如下： 12345678class Circle: Shape &#123; var Radio:Double = 0&#125;class Rect: Shape &#123; var size:(Double,Double)=(0,0)&#125;var circle = Circle()circle.center = (1,1) 可以看到，Circle类从父类中继承到了center属性。默认子类也会继承父类的构造方法，如果子类需要实现自己的构造方法，可以对父类的方法进行覆写，使用override关键字： 1234567class Rect: Shape &#123; var size:(Double,Double)=(0,0) override init()&#123; super.init() super.center = (1,1) &#125;&#125; 通过super关键字可以调用父类的属性和方法，同样，也可以使用override关键字来对属性进行get和set的覆写。同样也可以重写属性的观察期willset和didset。 四、final关键字在开发中很多情况下为了安全考虑，有些方法和属性是不允许子类进行覆写的，使用final声明这些属性，方法或者下标可以起到这样的作用。示例如下： 123456class Shape &#123; final var center:(Double,Double) init()&#123; center = (0,0) &#125;&#125; 如果想将某个类设置为不可继承的，可以将此类使用final关键字修饰，示例如下： 123456final class Shape &#123; final var center:(Double,Double) init()&#123; center = (0,0) &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题十二——方法","slug":"212Swift讲解专题十二——方法","date":"2016-05-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.342Z","comments":true,"path":"2016/05/17/212Swift讲解专题十二——方法/","link":"","permalink":"http://huishao.cc/2016/05/17/212Swift讲解专题十二——方法/","excerpt":"","text":"Swift讲解专题十二——方法一、引言方法只是一个术语，其实就是将函数与特定的类型结合，类、结构体、枚举都可以定义方法，方法又分为实例方法和类型方法，类型方法类似于Objective-C中的类方法。Swift和Objective-C的一大不同是，Objective-C只有在类中可以定义方法。 二、实例方法基础实例方法的语法和函数完全一致，其和具体类型的实例所关联，实例方法在调用时由类型的实例点语法进行调用来完成一些功能模块。示例如下： 12345678910class Math &#123; //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; return param1+param2 &#125;&#125;//创建类型实例var obj = Math()//调用方法进行计算obj.add(5, param2: 5) 与Objective-C类似，Swift中每一个类的实例中都隐藏含有一个self属性，self属性就是实例本身，开发者可以在实例方法中使用self来调用属性或者其他实例方法，示例如下： 1234567891011class Math &#123; //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; return param1+param2 &#125; func mul(param1:Double,param2:Double) -&gt; Double &#123; //使用self调用实例方法 self.add(param1, param2: param2) return param1*param2 &#125;&#125; 然而，Swift并不要求开发者必须写self，默认情况下，开发者可以直接省略self来调用属性和方法： 1234567891011class Math &#123; //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; return param1+param2 &#125; func mul(param1:Double,param2:Double) -&gt; Double &#123; //使用self调用实例方法 add(param1, param2: param2) return param1*param2 &#125;&#125; 有一种情况需要注意，对于属性的调用，如果方法中的参数名和类实例的属性名相同，则必须使用self来调用类的实例属性，防止歧义的产生： 12345678910111213class Math &#123; var param1 = 10.0 //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; //这里将使用param1=10，如果不加self 将使用参数中的param1 return self.param1+param2 &#125; func mul(param1:Double,param2:Double) -&gt; Double &#123; //使用self调用实例方法 add(param1, param2: param2) return param1*param2 &#125;&#125; 三、在实例方法中修改值类型的值首先需要清楚一个概念，Swift中有两种类型，值类型和引用类型，具体在类、结构体、枚举一节中有相关介绍，这里需要注意的是，对于值类型，即结构体和枚举，其并不能直接在实例方法中修改实例属性的值，Swift中提供了另一种方式，如果真有如此的需求，开发者可以使用mutating关键字将实例方法声明成可变的，实际上，如果在可变的实例方法中修改了值类型属性的值，是会创建一个新的实例来代替原来的实例的，示例如下： 123456789101112struct Point &#123; var x:Double var y:Double mutating func move(x:Double,y:Double) &#123; self.x+=x self.y+=y &#125;&#125;var point = Point(x: 1, y: 1)print(point)point.move(3, y: 3)print(point) 在值类型实例的可变方法中修改属性的值，实际上就是创建了一个新的实例，上面的写法和下面的写法原理是一样的： 1234567struct Point &#123; var x:Double var y:Double mutating func move(x:Double,y:Double) &#123; self = Point(x: self.x+x,y: self.y+y) &#125;&#125; 四、类型方法正如实例方法是通过类型的实例来进行调用的，类型方法是通过类型直接来调用的，相比于实例方法，类型方法中的self指当前类型，同样开发者可以使用self来区别类型属性和类型方法中的参数。使用Static关键字来进行类型方法的创建： 1234567891011struct Point &#123; var x:Double var y:Double mutating func move(x:Double,y:Double) &#123; self = Point(x: self.x+x,y: self.y+y) &#125; static func name()&#123; print(&quot;Point&quot;) &#125;&#125;Point.name() 如果是在类中创建类型方法，若此方法可以被子类进行重写，则应该使用class关键字来创建，示例如下： 1234567891011121314151617class Math &#123; var param1 = 10.0 //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; //这里将使用param1=10，如果不加self 将使用参数中的param1 return self.param1+param2 &#125; func mul(param1:Double,param2:Double) -&gt; Double &#123; //使用self调用实例方法 add(param1, param2: param2) return param1*param2 &#125; class func name()&#123; print(&quot;Math&quot;) &#125;&#125;Math.name() 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题十三——下标访问","slug":"213Swift讲解专题十三——下标访问","date":"2016-05-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.342Z","comments":true,"path":"2016/05/17/213Swift讲解专题十三——下标访问/","link":"","permalink":"http://huishao.cc/2016/05/17/213Swift讲解专题十三——下标访问/","excerpt":"","text":"Swift讲解专题十三——下标访问一、引言在以前的博客中，讨论过在Objective-C中，通过下标的方式访问自定义数据模型的方法。Objective-C中主要是通过实现一系列方法来使自定义的数据类型支持下标的访问方式，博客地址如下： 在Objective-C中使用下标访问自定义数据模型：http://my.oschina.net/u/2340880/blog/632294。 Swift中的Array，Dictionary类型可以通过下标或者键值的方式来进行数据的访问，实际上在Swift的语法中，下标可以定义在类、结构体、枚举中。开发者可以通过下标的方式来对属性进行访问而不用使用专门的存取方法。并且定义的下标不限于一维，开发者可以定义多维的下标来满足需求。 二、下标的语法结构下标使用subscript来定义，其有些类似于方法，参数和返回值分别作为下标入参和通过下标所取的值。但是在subscript实现部分，又十分类似于计算属性，其需要实现一个get块和可选实现一个set块，get块用于使用下标取值，set块用于使用下标设置值，因此，subscript结构更像是计算属性和方法的混合体，示例如下： 12345678910111213class MyClass &#123; var array=[1,1,1,1,1] subscript(param1:Int)-&gt;Int&#123; set&#123; array[param1] = newValue &#125; get&#123; return array[param1] &#125; &#125;&#125;var obj = MyClass()obj[0] = 3 开发者可以只编写get块来实现只读的下标访问。对于多维下标的访问方式，只需修改subscript中的参数个数即可，示例如下： 12345678910111213class MyClass &#123; var array=[1,1,1,1,1] subscript(param1:Int,param2:Int)-&gt;Int&#123; set&#123; array[param1] = newValue &#125; get&#123; return array[param1] &#125; &#125;&#125;var obj = MyClass()obj[0,1] = 3 三、下标的特性Swift中的下标可以自定参数个数和参数类型，返回数据的类型开发者也可以进行自定义。但是有一点需要注意，下标的参数不能设置默认值，也不能设置为in-out类型。多维下标常用语行列数据的访问，示例如下： 1234567891011121314151617class SectionAndRow &#123; var array:Array&lt;Array&lt;Int&gt;&gt; = [ [1,2] ,[3,4] ,[5,6] ,[7,8] ] subscript(section:Int,row:Int)-&gt;Int&#123; get&#123; let temp = array[section] return temp[row] &#125; &#125; &#125;var data = SectionAndRow()//通过二维下标取值data[1,1] 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题十——类与结构体","slug":"210Swift讲解专题十——类与结构体","date":"2016-05-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.341Z","comments":true,"path":"2016/05/16/210Swift讲解专题十——类与结构体/","link":"","permalink":"http://huishao.cc/2016/05/16/210Swift讲解专题十——类与结构体/","excerpt":"","text":"Swift讲解专题十——类与结构体一、引言Swift中的类与结构体十分相似，和Objective-C不同的是，Swift中的结构体不仅可以定义属性，也可以像类一样为其定义方法。 Swift中的类与结构体有如下相似点： 1.定义属性来存储值。 2.定义函数来提供功能。 3.通过定义下标语法使用下标的方式取值。 4.定义构造方法来对其进行初始化。 5.通过扩展来在原始基础上添加功能。 6.通过协议来定义实现标准。 当然类和结构体也有许多不同点，下面这些功能是类独有的，结构体没有： 1.通过继承来创建类的子类。 2.在运行时允许对类的实例进行类型的检查和解释。 3.析构方法可以释放被类引用的资源。 4.通过引用计数允许一个类实例的多处引用。 当开发者在代码中传递这些实例时，结构体总是被复制，而类则是被引用。这是结构体和类的最本质区别。 二、类与结构体的定义类与结构体在定义语法上相似，示例代码如下： 1234567891011121314class MyClass &#123; var name = &quot;HS&quot; var age = 25&#125;struct MyStruct &#123; var param1:Int var param2:String&#125;//创建类的实例var obj1 = MyClass()//创建结构体的实例 所有结构体会默认生成一个逐个设置属性的构造方法 而类不会var obj2 = MyStruct(param1: 1,param2: &quot;1&quot;)//可以通过点语法来获取类或者结构体中的属性值print(obj1.age,obj2.param1) 通过实例间的传递，可以证明Swift中类被引用于结构体被复制这样的特点，示例如下： 123456789//将类实例传递给另一个变量var obj3 = obj1//将结构体实例传递给另一个变量var obj4 = obj2//修改变量的值obj3.name = &quot;NewHS&quot;obj4.param1 = 2//将 打印 NewHS 1 //说明类是被引用的 结构体则被赋值print(obj1.name,obj2.param1) 注意：在实例传递时同样采用复制原理的还有枚举类型。 由于类是通过引用来进行传递，Swift中还提供了一种运算符用来比较两个实例变量或常量是否指向同一个引用，示例如下： 12345if obj1===obj3&#123; print(&quot;same refer&quot;)&#125;else if obj1 !== obj3 &#123; print(&quot;not same refer&quot;)&#125; 实际上，===与!==运算符比较的是指针内容。 三、类和结构体的选择由于类和结构体有着不同的传递机制，因此其也适用于不同的开发任务，下面这些情况下，官方推荐开发者使用结构体来创建数据类型： 1.该数据类型封装少量的简单数据值。 2.该类型数据来传递时，应该被复制。 3.该类型中定义的数据类型在传递时也应该被赋值。 4.不需要通过继承另一个数据类型而来。 除了上面列举的一些情况，其它情况下，都推荐开发者使用类来描述数据，这也是开发中最后常用的手段。 扩展：在Swift中，Array，String，Dictionary这些类型都是采用的结构体的方式来实现，并不是采用引用的方式，NSString，NSArray，NSDictionary这些Objective-C的类是采用引用的方式实现的，因此在Swift中，String，Array，Dictionary在传递时总是被赋值。然而官方文档中还有一句话十分有意思： The description above refers to the “copying” of strings, arrays, and dictionaries. The behavior you see in your code will always be as if a copy took place. However, Swift only performs an actual copy behind the scenes when it is absolutely necessary to do so. Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization. 大致意思是，在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题十一——属性","slug":"211Swift讲解专题十一——属性","date":"2016-05-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.342Z","comments":true,"path":"2016/05/16/211Swift讲解专题十一——属性/","link":"","permalink":"http://huishao.cc/2016/05/16/211Swift讲解专题十一——属性/","excerpt":"","text":"Swift讲解专题十一——属性一、引言属性将值与类，结构体，枚举进行关联。Swift中的属性分为存储属性和计算属性两种，存储属性用于存储一个值，其只能用于类与结构体，计算属性用于计算一个值，其可以用于类，结构体和枚举。 二、存储属性存储属性使用变量或者常量来存储一个值，在声明存储属性时，可以为其设置一个默认值，也可以在构造示例是进行值的设置，属性可以通过点语法来访问，结构体的存储属性示例代码如下： 1234567struct MyStruct &#123; var property1 = 1 var property2:Int&#125;var obj = MyStruct(property1: 1, property2: 2)//通过点语法进行属性的访问print(obj.property1,obj.property2) 如上结构体，如果有属性被声明成let常量，则此属性不能够被修改。还有一点需要注意，如果在创建结构体的实例时，使用的是let进行创建，则即便结构体中的属性是变量也不可进行修改。这和类有很大区别。 还有一类存储属性叫做延时存储属性，可以设想一下这样的情形，类的某些属性可能并不是在每次类实例后都会用到，并且有些属性的构造可能会消耗大量的时间，这时一个比较聪明的设计便是在类进行实例化时，这类属性并不被构造，当次类的实例使用到这个属性时，这个属性才被构造出来，这样的属性被称为延时存储属性，使用lazy关键字来声明，示例如下： 1234567891011121314//第一个类class MyClass1 &#123; init()&#123; print(&quot;MyClass1类被构造&quot;) &#125;&#125;class MyClass2 &#123; //声明为延时存储属性 lazy var body = MyClass1()&#125;//在构造MyClass2时 并不会进行body属性的构造 不会有打印信息var obj2 = MyClass2()//执行下面代码后 会有打印信息 使用body属性使得body被构造obj2.body 注意，如果在多个线程中对延时构造属性进行使用，不能保证其只被构造一次。 三、计算属性简单的理解，计算属性并不是独立的用于存储值的属性，开发者甚至可以将其理解为一个计算方法，其主要用于通过计算来获取或者设置其他存储属性的值。示例如下： 123456789101112131415161718192021struct Circle &#123; //圆心 var center:(Double,Double) //半径 var r:Double //周长 将其作为计算属性 var l:Double&#123; get&#123; //计算圆的周长 return 2.0*r*M_PI &#125; set&#123; //通过周长重新计算半径 默认传入的参数名为newValue r = newValue/(M_PI*2) &#125; &#125;&#125;var circle = Circle(center: (0,0), r: 2)print(circle.l)circle.l=24print(circle.r) 通过上面的演示代码可以了解，l属性并非是一个新的属性，只是通过r属性来计算出l，或者通过l来反推出r，其中有一点需要注意，计算属性中可以创建两个代码块set和get，set代码块是可选的，其中会默认生成一个newValue参数来传递外界传进来的数据，get代码块是必须要实现的，当然也可以只实现get代码块，这时这个属性将是只读的计算属性，只可以获取，不能够设置。还有一点需要注意，开发者也可以在set代码块后面自定义一个参数名来接收外界传入的参数，示例如下： 1234567891011121314151617struct Circle &#123; //圆心 var center:(Double,Double) //半径 var r:Double //周长 将其作为计算属性 var l:Double&#123; get&#123; //计算圆的周长 return 2.0*r*M_PI &#125; set(newL)&#123; //通过周长重新计算半径 默认传入的参数名为newValue r = newL/(M_PI*2) &#125; &#125;&#125; 只读的计算属性可以进行进一步的简写，因为没有了set代码块，所以关键字get和括号也可以给省略掉，不会产生歧义，示例如下： 1234567struct Point &#123; var x:Double var y:Double var center:(Double,Double)&#123; return (x/2,y/2) &#125;&#125; 四、属性监听器Swift中的计算属性中的get和set方法和Objective-C中的get和set方法其实并非是一回事，Objective-C提供set和get方法可以让开发者在属性将要获取或者设置的时候来进行一些自定义的操作，这部分的开发需求在Swift中通过属性监听器来实现。 属性监听器有willSet和didSet两种，willSet在属性值将要变化时执行，didSet在属性值已经变化时执行，并且其中会传入变化前后的值。示例如下： 123456789101112131415161718192021struct Point &#123; var x:Double var y:Double&#123; willSet&#123; print(&quot;将要进行值的更新设置,新的值是:&quot;,newValue) &#125; didSet&#123; print(&quot;已经进行值得更新设置,旧的值是:&quot;,oldValue) &#125; &#125; var center:(Double,Double)&#123; return (x/2,y/2) &#125;&#125;var point = Point(x: 3, y: 3)//将打印/* 将要进行值的更新设置,新的值是: 4.0 已经进行值得更新设置,旧的值是: 3.0 */point.y=4 willSet中默认会生成一个命名为newValue的参数，didSet中会默认生成一个命名为oldValue的参数，也可以自定义这些参数的命名，示例如下： 1234567891011121314struct Point &#123; var x:Double var y:Double&#123; willSet(new)&#123; print(&quot;将要进行值的更新设置,新的值是:&quot;,new) &#125; didSet(old)&#123; print(&quot;已经进行值得更新设置,旧的值是:&quot;,old) &#125; &#125; var center:(Double,Double)&#123; return (x/2,y/2) &#125;&#125; 五、实例属性与类型属性实例属性是针对与一个类型的实例，类型属性则是直接针对与类型。 每对类型进行一次实例化，其实例都有一套独立的实例属性，而类型属性则是类的所有实例所共用的，在Objective-C中，通常使用全局的属性来实现这样的效果，在Swift中，使用static关键字来声明类型属性，示例如下： 12345678910111213141516171819202122struct Point &#123; //类型存储属性 static var name:String = &quot;Point&quot; //类型计算属性 static var subName:String&#123; return &quot;sub&quot;+name &#125; var x:Double var y:Double&#123; willSet(new)&#123; print(&quot;将要进行值的更新设置,新的值是:&quot;,new) &#125; didSet(old)&#123; print(&quot;已经进行值得更新设置,旧的值是:&quot;,old) &#125; &#125; var center:(Double,Double)&#123; return (x/2,y/2) &#125;&#125;//类型属性 通过类型点语法来获取print(Point.name,Point.subName) 注意，有一种特殊的情况是针对于类的类型计算属性，如果其需要子类进行继承重写，需要将static关键字，换成class关键字，示例如下： 12345678910class SomeClass &#123; static var storedTypeProperty = &quot;Some value.&quot; static var computedTypeProperty: Int &#123; return 27 &#125; //支持子类进行重写的计算属性 class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题九——枚举","slug":"209Swift讲解专题九——枚举","date":"2016-05-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.341Z","comments":true,"path":"2016/05/15/209Swift讲解专题九——枚举/","link":"","permalink":"http://huishao.cc/2016/05/15/209Swift讲解专题九——枚举/","excerpt":"","text":"Swift讲解专题九——枚举一、引言在Objective-C语言中，没有实际上是整型数据，Swift中的枚举则更加灵活，开发者可以不为其分配值类型把枚举作为独立的类型来使用，也可以为其分配值，可以是字符，字符串，整型或者浮点型数据。 二、枚举语法Swift中enum关键字来进行枚举的创建，使用case来创建每一个枚举值，示例如下： 123456789101112//创建姓氏枚举,和Objective-C不同，Swift枚举不会默认分配值enum Surname &#123; case 张 case 王 case 李 case 赵&#125;//创建一个枚举类型的变量var myName = Surname.张//如果可以自动推断出类型 则枚举类型可以省略myName = .李var myName2:Surname = .王 同样可以将枚举值都写在同一个case中，使用逗号分隔： 123enum Planet &#123; case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125; 枚举经常会和Switch语句结合使用，示例如下： 12345678910switch myName &#123;case .张: print(&quot;姓氏张&quot;)case .王: print(&quot;姓氏王&quot;)case .李: print(&quot;姓氏李&quot;)case .赵: print(&quot;姓氏赵&quot;)&#125; 三、枚举的相关值Swift中的枚举有一个很有意思的特点，其可以设置一些相关值，通过相关值，开发者可以从公用的枚举值中获取到传递的额外相关值，示例如下： 12345678910111213141516171819202122enum Number &#123; case one(count:Int) case two(count:Int) case three(count:Int) case four(count:Int)&#125;var num = Number.one(count: 5)switch num &#123; //获取num的相关值case Number.one(let count): print(count)default: print(num)&#125;//如果一个枚举值所有的相关中都是常量，let关键字也可以提取到括号外面switch num &#123; //获取num的相关值case let Number.one(count): print(count)default: print(num)&#125; 有了相关值这样的句法，大大的增加了枚举的灵活性，例如一个形状枚举，可能的枚举值有矩形，圆形等，矩形的枚举值就可以提供宽高的相关值，圆形的枚举值就可以提供半径的相关值，是开发更加灵活。 四、枚举的原始值原始值也可以理解为为枚举设置一个具体类型，示例如下： 1234567enum Char:String &#123; case a = &quot;A&quot; case b = &quot;B&quot; case c = &quot;C&quot;&#125;//”A“var char = Char.a.rawValue 注意，如果枚举是Int类型的，则类似于Objective-C，枚举的原始值会从第一个开始之后依次递增： 1234567enum Char:Int&#123; case a = 0 case b case c&#125;//1var char = Char.b.rawValue 同样可以通过原始值的方式来进行枚举对象的创建，示例如下： 123456789enum Char:Int&#123; case a = 0 case b case c&#125;//1var char = Char.b.rawValue//bvar char2 = Char(rawValue:1) 在通过原始值进行枚举对象创建的时候，有可能创建失败，例如传入的原始值并不存在，这时会返回Optional值nil。 四、递归枚举递归枚举是Swift枚举中一个难于理解的地方，实际上也并非十分难于理解，开发者只要明白枚举的实质，递归枚举就很好理解。首先，递归是一种算法，可以简单理解为自己调用自己，而枚举实际上并不是函数，它并不执行某项运算，它只是表达一个数据或者说他也可以表达一种表达式，示例如下： 123456enum Expression &#123; //表示加 case add //表示减 case mul&#125; 前面有提到过相关值的概念，因此，对于上述例子，可以为add和mul枚举值添加两个相关值作为参数。 123456enum Expression &#123; //表示加 case add(Int,Int) //表示减 case mul(Int,Int)&#125; 如此，如下的写法实际上就可以代表一个5+5的表达式： 1var exp = Expression.add(5, 5) 还是需要强调一点，这个exp只是表达了5+5这样一个约定的表达式，它并没有真正进行5+5的运算。现在问题就来了，使用如上的枚举，怎样来表达类似(5+5)*5这样的复合表达式呢？可以使用递归枚举来实现，即将(5+5)作为枚举值得相关值再次创建枚举，改造如下： 123456789101112enum Expression &#123; //单值数据 case num(Int) //表示加 indirect为递归枚举关键字 indirect case add(Expression,Expression) //表示减 indirect case mul(Expression,Expression)&#125;var exp1 = Expression.num(5)var exp2 = Expression.num(5)var exp3 = Expression.add(exp1, exp2)var exp4 = Expression.mul(exp1, exp3) 上面exp4实际上就表达了(5+5)*5这样一个过程，注意递归的枚举值必须加上indirect关键字来声明。处理递归枚举最好的方式是通过递归函数，示例如下： 12345678910111213141516func expFunc(param:Expression) -&gt; Int &#123; //进行枚举判断 switch param &#123; //如果是单独数字 直接返回 case .num(let p): return p //如果是加法 则进行递归加 case .add(let one, let two): return expFunc(one)+expFunc(two) //如果是乘法 则进行递归乘 case .mul(let one, let two): return expFunc(one)*expFunc(two) &#125;&#125;//50expFunc(exp4) 如果枚举中所有的case都是可递归的，可以将整个枚举声明为可递归的： 12345678indirect enum Expression &#123; //单值数据 case num(Int) //表示加 indirect为递归枚举关键字 case add(Expression,Expression) //表示减 case mul(Expression,Expression)&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题八——闭包","slug":"208Swift讲解专题八——闭包","date":"2016-05-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.341Z","comments":true,"path":"2016/05/14/208Swift讲解专题八——闭包/","link":"","permalink":"http://huishao.cc/2016/05/14/208Swift讲解专题八——闭包/","excerpt":"","text":"Swift讲解专题八——闭包一、引言Swift中的闭包是有一定功能的代码块，这十分类似于Objective-C中的block语法。Swift中的闭包语法风格十分简洁，其作用和函数的作用相似。 二、从一个系统函数看闭包Swift标准函数库中提供了一个sort排序函数，对于已经元素类型的数组，调用sort函数会进行重新排序并返回新的排序后的数组。这个sort函数可以接收一个返回值为Bool类型的闭包，来确定第一个元素是否排在第二个元素前面。代码示例如下： 123456789101112var array = [3,21,5,2,64]func func1(param1:Int,param2:Int) -&gt; Bool &#123; return param1&gt;param2&#125;//通过传入函数的方式//array = [64,21,5,3,2]array = array.sort(func1)//通过闭包的方式//array = [2,3,5,21,64]array = array.sort(&#123;(param:Int,param2:Int)-&gt;Bool in return param&lt;param2 &#125;) Swift语言有一个很显著的特点就是简洁，可以通过上下文推断出类型的情况一般开发都可以将类型的书写省略，这也是Swift语言设计的一个思路，由于闭包是作为函数的参数传入函数中的，因为函数参数的类型是确定，因此闭包的类型是可以被编译器推断出来的，开发者也可以将闭包的参数类型和返回值省略，上面的代码可以简写如下： 12//将闭包的参数类型和返回值都省略array = array.sort(&#123;(p1,p2) in return p1&gt;p2&#125;) 实际上，如果闭包中的函数体只有一行代码，可以将return关键字也省略，这时会隐式的返回此行代码的值，如下： 1array = array.sort(&#123;(p1,p2) in p1&gt;p2&#125;) 看到上面的表达式，是不是有点小震惊，闭包表达式竟然可以简写成这样！然而，你还是小看的Swift开发团队，后面的语法规则会让你明白什么是简洁的极致。可以看到上面的代码实现还是有3部分：参数和返回值，闭包关键字，函数体。参数和返回值即是参数列表，p1，p2，虽然省略了参数类型和返回值类型，但这部分的模块还在，闭包关键字即是in，它用来表示下面将是闭包的函数体，p1&gt;p2即是函数体，只是这里省略了return关键字。闭包中既然参数类型和返回值类型编译器都可以自己推断出来，那么参数的数量编辑器也是可以自行推断的，因此，参数列表实际上也是多余的，闭包中会自动生成一些参数名称，和实际的参数数量向对应，例如上面sort函数中的闭包有两个参数，系统会自动生成$0和$1这两个参数名，开发者可以直接使用，因为参数列表都会省略了，那么也不再需要闭包关键字in来分隔参数列表与函数体，这时，闭包的写法实际上变成了如下的模样： 1array = array.sort(&#123;$0&lt;$1&#125;) 你没有看错，加上左右的大括号，一共7个字符，完成了一个排序算法。除了Swift，我不知道是否还有第二种语言可以做到。抛开闭包不说，Swift中还有一种语法，其可以定义类型的运算符方法，例如String类型可以通过=，&lt;，&gt;来进行比较，实际上是String类中实现了这些运算符方法，在某种意义上说，一个运算符即类似与一个函数，那么好了，sort函数中需要传入的方法对于某些类型来说实际上只是需要一个运算符，示例如下： 1array = array.sort(&gt;) 这次你可以真的震惊了，完成排序新算法只需要一个字符，不折不扣的一个字符。 三、Swift中闭包的更多特点Swift中的闭包还有一个有趣的特点，首先闭包是作为参数传入另一个函数中的，因此常规的写法是将闭包的大括号写在函数的参数列表小括号中，如果闭包中的代码很多，这时在代码结构上来看会变得并不太清晰，为了解决这个问题，Swift中这样规定：如果这个闭包参数是函数的最后一个参数，开发者可以将其拉出小括号，在函数尾部实现闭包代码，示例如下： 12345678//闭包结尾func func2(param1:Int,param2:()-&gt;Void)-&gt;Void&#123; param2() print(&quot;调用了func2函数&quot;)&#125;func2(0)&#123; print(&quot;闭包中的内容&quot;)&#125; 如果一个函数中只有一个参数，且这个参数是一个闭包，那么开发者使用闭包结尾这种写法，完全可以将函数的参数列表小括号也省略掉，示例如下： 1234567func func3(param:()-&gt;Void)-&gt;Void&#123; param() print(&quot;调用了func3函数&quot;)&#125;func3&#123; print(&quot;闭包中的内容&quot;)&#125; Swift中还有一个闭包逃逸的概念，这个很好理解，当闭包作为参数传递进函数时，如果这个闭包只在函数中被使用，则开发者可以将这个闭包声明成非逃逸的，即告诉系统当此函数结束后，这个闭包的声明周期也将结束，这样做的好处是可以提高代码性能，将闭包声明称非逃逸的类型使用@noescape关键字，示例如下： 1234567func func3(@noescape param:()-&gt;Void)-&gt;Void&#123; param() print(&quot;调用了func3函数&quot;)&#125;func3&#123; print(&quot;闭包中的内容&quot;)&#125; 逃逸的闭包常用于异步的操作，例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的声明周期才结束。非逃逸的闭包还有一个有趣的特点，在其内部如果需要使用self这个关键字，self可以被省略。 闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包可以自动将表达式封装成闭包，开发者不需要再写闭包的大括号格式，自动闭包不接收参数，返回值为其中表达式的值。示例如下： 1234567891011121314151617181920212223242526272829//自动闭包演示var list = [1,2,3,4,5,6]//创建一个显式闭包let closures = &#123; list.removeFirst() list.append(7)&#125;//将打印[1,2,3,4,5,6]print(list)//执行闭包closures()//将打印[2,3,4,5,6,7]print(list)func func4(closure:()-&gt;Void) -&gt; Void &#123; //执行显式的闭包 closures()&#125;func func5(@autoclosure auto:()-&gt;Void) -&gt; Void &#123; //执行自动闭包 auto()&#125;//显式闭包 需要大括号func4(closures)//将打印[3,4,5,6,7,7]print(list)//将表达式自动生成闭包func5(list.append(8))//将打印[3,4,5,6,7,7,8]print(list) 自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要手动声明，如下： 1234func func5(@autoclosure(escaping) auto:()-&gt;Void) -&gt; Void &#123; //执行自动闭包 auto()&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题七——函数","slug":"207Swift讲解专题七——函数","date":"2016-05-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.340Z","comments":true,"path":"2016/05/13/207Swift讲解专题七——函数/","link":"","permalink":"http://huishao.cc/2016/05/13/207Swift讲解专题七——函数/","excerpt":"","text":"Swift讲解专题七——函数一、引言函数是有特定功能的代码段，函数会有一个特定的名称调用时来使用。Swift提供了十分灵活的方式来创建与调用函数。事实上在Swift，每个函数都是一种类型，这种类型由参数和返回值来决定。Swift和Objective-C的一大区别就在于Swift中的函数可以进行嵌套。 二、函数的创建与调用函数通过函数名，参数和返回值来定义，参数和返回值决定一个函数的类型，在调用函数时，使用函数名来进行调用，示例如下： 1234567//传入一个名字 打印并将其返回func printName(name:String) -&gt; String &#123; print(name) return name&#125;//进行函数的调用printName(&quot;HS&quot;) 也可以创建没有参数的函数： 1234func onePuseTwo()-&gt;Int &#123; return 1+2&#125;onePuseTwo() 同样也可以创建没有返回值的函数： 1234func sayHello()&#123; print(&quot;Hello&quot;)&#125;sayHello() 上面介绍的函数类型都比较常见，对于多返回值的函数，在Objective-C中十分难处理，开发者通常会采用字典、数组等集合方式或者干脆使用block回调，在Swift中，可以使用元组作为函数的返回值，示例如下： 1234func tuples()-&gt;(Int,String)&#123; return (1,&quot;1&quot;)&#125;tuples() 也可以是函数返回一个Optional类型的值，支持返回nil，示例如下： 12345678func func1(param:Int)-&gt;Int? &#123; guard(param&gt;0)else&#123; return nil &#125; return param&#125;func1(0)func1(1) 在函数的参数名前，开发者还可以再为其添加一个参数名称作为外部参数名，示例如下： 12345678910func func1(count param:Int ,count2 param2:Int)-&gt;Int? &#123; //内部依然使用param guard(param&gt;0)else&#123; return nil &#125; return param&#125;//外部调用使用countfunc1(count: 0,count2: 0)func1(count: 1,count2: 1) 其实Swift函数中的参数列表有这样一个特点，除了第一个参数外，之后的参数都默认添加一个一个和内部名称相同的外部名称，如果开发者不想使用这个外部名称，使用_符号设置，示例如下： 12345678910func func2(param:Int,param2:Int,param3:Int) &#123; &#125;//有外部名称func2(0, param2: 0, param3: 0)func func3(param:Int,_ param2:Int,_ param3:Int) &#123; &#125;//没有外部名称func3(0, 0, 0) Swift也支持开发者为函数的参数创建一个默认值，如果函数的某个参数有设置默认值，则开发者在调用时可以省略此参数，示例如下： 1234func func4(param:Int=1,param2:Int=2,param3:Int) &#123; print(param,param2,param3)&#125;func4(3,param3:3) 还有一种情形在Objective-C中也很处理，对于参数数量不定的函数，在前面章节介绍过，Objective-C一般会使用list指针来完成，在Swift中编写这样的函数十分简单，示例如下： 123456func func5(param:Int...) &#123; for index in param &#123; print(index) &#125;&#125;func5(1,2,3,4) Swift中参数默认是常量，在函数中是不能修改外部传入参数的值得，如果有需求，需要将参数声明成inout类型，示例如下： 1234567func func6(inout param:Int) &#123; param = 10&#125;var count = 1//实际上传入的是参数地址func6(&amp;count)print(count) 三、函数类型函数是一种特殊的数据类型，每一个函数属于一种数据类型，示例如下： 12345func func7(a:Int,_ b:Int)-&gt;Int&#123; return a+b&#125;var addFunc:(Int,Int)-&gt;Int = func7addFunc(1,2) 函数也可以作为参数传入另一个函数，这十分类似于Objective-C中的block语法，示例如下： 1234567891011121314func func7(a:Int,_ b:Int)-&gt;Int&#123; return a+b&#125;var addFunc:(Int,Int)-&gt;Int = func7addFunc(1,2)func func8(param:Int,param2:Int,param3:(Int,Int)-&gt;Int) -&gt; Int &#123; return param3(param,param2)&#125;//传入函数func8(1, param2: 2, param3: addFunc)//闭包的方式func8(2, param2: 2, param3:&#123; (a:Int,b:Int) -&gt; Int in return a*b &#125;) 一个人函数也可以作为另一个函数的返回值，示例如下： 123456789func func9()-&gt;(Int)-&gt;Int&#123; //Swift支持嵌套函数 func tmp(a:Int)-&gt;Int&#123; return a*a &#125; return tmp&#125;var myFunc = func9()myFunc(3) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题六——流程控制","slug":"206Swift讲解专题六——流程控制","date":"2016-05-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.340Z","comments":true,"path":"2016/05/12/206Swift讲解专题六——流程控制/","link":"","permalink":"http://huishao.cc/2016/05/12/206Swift讲解专题六——流程控制/","excerpt":"","text":"Swift讲解专题六——流程控制一、引言一种编程语言的强大与否，很大程度上取决于其提供的程序流程控制方案，就如使用汇编语言实现复杂的程序流程是一件痛苦的事情。Swift中提供了许多强大的流程控制语句，例如快速遍历for-in，while循环，repeat-while循环，switch选择等，需要注意的是，在Swift2.2中，for(a;b;c)循环已经被弃用掉，并且Swift中的Switch语句也更加强大，可以处理任意数据类型。 二、for-in循环配合范围运算符，for-in循环可以用来执行确定次数的循环，示例如下： 12345678for index in 1...5 &#123; print(index)&#125;//如果不需要获取循环中每次的循环次数 可以使用如下方式var sum=0;for _ in 1...3 &#123; sum += 1&#125; for-in循环也通常会用来遍历数组，字典，集合等，示例如下： 123456789101112var collection1:Array = [1,2,3,4]var collection2:Dictionary = [1:1,2:2,3:4,4:4]var collection3:Set = [1,2,3,4]for obj in collection1 &#123; print(obj)&#125;for (key , value) in collection2 &#123; print(key,value)&#125;for obj in collection3 &#123; print(obj)&#125; 三、while循环while语句进行循环操作，直到循环条件为false为止，这类型的循环通常适用于循环次数不定的循环需求，while循环提供两种语法格式，示例如下： 12345678910var i=0//当i不小于10时跳出循环while i&lt;10 &#123; print(&quot;while&quot;,i) i+=1&#125;//先进行一次操作 在判断循环条件repeat &#123; print(&quot;repeat while&quot;)&#125; while i&lt;10 四、if语句if语句是程序开发中最常用的语句之一，通过if将判断一个条件是否成立来进行程序的流程控制，if语句通常会和else语句结合进行使用，示例如下： 12345678var c:Intif 1&gt;2 &#123; c=1&#125;else if 1&lt;0 &#123; c=2&#125;else&#123; c=3&#125; 五、Switch语句Switch语句作为开关选择语句，用来处理一组值的分支选择，Swift中的Switch语句格外强大，相比于Objective-C，Swift中的Switch语句每个case后不需要使用break进行手动中断，当代码匹配到一个case后语句将自行中断。用法示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var charac:Character = &quot;b&quot;//使用switch语句进行字符分支判断switch charac &#123;case &quot;a&quot;: print(&quot;chara is a&quot;)case &quot;b&quot;: print(&quot;chara is b&quot;)case &quot;c&quot;: print(&quot;chara is c&quot;)default ://default用于处理其他额外情况 print(&quot;no charac&quot;)&#125;//同一个case中可以包含多个分支switch charac &#123;case &quot;a&quot;,&quot;b&quot;,&quot;c&quot; : print(&quot;chara is word&quot;)case &quot;1&quot;,&quot;2&quot;,&quot;3&quot; : print(&quot;chara is num&quot;)default : print(&quot;no charac&quot;)&#125;//在case中也可以使用一个范围var num = 3switch num &#123;case 1...3 : print(&quot;1&lt;=num&lt;=3&quot;)case 4 : print(&quot;chara is num&quot;)default : print(&quot;no charac&quot;)&#125;//使用Switch语句进行元组的匹配var tuple = (0,0)switch tuple &#123;case (0,1): print(&quot;Sure&quot;) //也可以只对元组中的某个元素进行匹配case (_,1): print(&quot;Sim&quot;) //也可以对元组中的元素进行范围匹配case(0...3,0...3): print(&quot;SIM&quot;)default: print(&quot;&quot;)&#125;//进行数据绑定switch tuple &#123;case (let a,1): print(a)case (let b,0): print(b) //let(a,b) 与 (let a,let b)意义相同case let(a,b): print(a,b)default: print(&quot;&quot;)&#125;//对于进行了数据绑定的Switch语句 可以使用where关键字来进行条件判断switch tuple &#123;case (let a,1): print(a)case (let b,0): print(b)//let(a,b) 与 (let a,let b)意义相同case let(a,b) where a==b: print(a,b)default: print(&quot;&quot;)&#125; 六、跳转语句Swift中提供了5种跳转语句，continue，break，fallthrough，return，throw。 continue：跳出到循环起始位置，直接开始下次循环。 break：break如果在循环语句中则是直接中断循环，跳出，若是在Switch结构中，则立即跳出Switch结构。 fallthrough语句需要和switch语句配合使用，在case中使用fallthrough，则会继续执行下一个case，需要注意，在下一个case中有进行数据绑定的，不可以使用fallthrough，示例如下： 12345678910111213141516var tuple = (0,0)switch tuple &#123;case (0,0): print(&quot;Sure&quot;) //fallthrough会继续执行下面的case fallthrough //也可以只对元组中的某个元素进行匹配case (_,0): print(&quot;Sim&quot;) fallthrough //也可以对元组中的元素进行范围匹配case(0...3,0...3): print(&quot;SIM&quot;)default: print(&quot;&quot;)&#125; return：return语句直接从函数中返回。 throw：throw用于抛出异常。 Swift还支持另一种语法，可以为while循环设置一个tip标签，使用break和continue等关键字来进行流程的控制，示例如下： 1234567891011var tmp = 0;tip:while tmp&lt;10 &#123; print(&quot;ccc&quot;) tmp+=1 switch tmp &#123; case 3: break tip default: break &#125;&#125; Swift2.0之后，提供了一种新的语法，guard-else，这也被称作守护语句，只有当条件不满足时，才执行else后面的代码，示例如下： 12345678910var name = &quot;HS&quot;func nameChange(name:String) &#123; guard name==&quot;HS&quot; else&#123; print(name) return &#125; print(&quot;name is HS&quot;)&#125;nameChange(name) 在开发中，函数中常常会需要检查传入的参数是否符合标准，guard-else语句就是为这种需求所生，正如其名，它用于守护函数执行的精确度。 七、系统版本检查使用如下示例代码进行系统支持版本的检查： 123if #available(iOS 9, *)&#123; print(&quot;iOS 9&quot;)&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题五——集合类型","slug":"205Swift讲解专题五——集合类型","date":"2016-05-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.340Z","comments":true,"path":"2016/05/11/205Swift讲解专题五——集合类型/","link":"","permalink":"http://huishao.cc/2016/05/11/205Swift讲解专题五——集合类型/","excerpt":"","text":"Swift讲解专题五——集合类型一、引言Swift中提供了3种集合类型，Array数据类型，Set集合类型，Dictionary字典类型。Array用于存放一组有序的数据，数据角标从0开始一次递增；Set用于存放一组无序的数据，数据不可以重复；Dictionary也用于存放一组无序的数据，只是其是按照键值对的方式存储，键值必须唯一。这里借用官方文档中的一张图来表示3种集合类型的特点： 二、Array类型Array通常也被称为数组，Swift是一种类型安全语言，其中的Array类型也必须确定其元素的类型，声明数组类型有两种方法，示例如下： 123456//将数组声明为Int类型值集合的数组var array1:[Int]var array2:Array&lt;Int&gt;//创建空数组array1 = []array2 = Array() 数组对象如果通过var变量也接收，则其为可变的数组，可以通过append方法来追加元素，示例如下： 12//向数组中追加元素array1.append(3) 在创建数组时，也可以对数组进行初始化，示例如下： 123456//创建数组[0,0,0]var array3 = [Double](count: 3, repeatedValue: 0)//创建数组[2.5,2.5,2.5]var array4 = Array(count: 3, repeatedValue: 2.5)//数组可以使用+号直接进行追加 [0,0,0,2.5,2.5,2.5]var array5 = array3+array4 Swift中提供了许多访问和修改数组的方法，示例代码如下： 1234567891011121314151617181920212223242526//获取数组中元素个数array5.count//判断数组是否为空array5.isEmpty//通过下标访问数组中的元素array5[1]//通过下标修改数组元素array5[1]=2//修改数据中的一组数据array5[0...3] = [1,1,1,1]//向数组中某个位置插入一个数据array5.insert(3, atIndex: 1)//移除数组某个角标处的元素array5.removeAtIndex(1)//移除数组的最后一个元素array5.removeLast()//移除数组第一个元素array5.removeFirst()//遍历整个数组for item in array5 &#123; print(item)&#125;//遍历数组枚举for (index,item) in array5.enumerate() &#123; print(index,item)&#125; 三、Set类型Set类型集合不关注元素的顺序，但是其可以保证其中元素的唯一性。和Array类型一样，Set类型来声明时也需要确定其内元素的类型，示例如下： 1var set1:Set&lt;Character&gt; = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;] 下面示例代码演示对集合进行操作： 12345678910111213141516171819202122var set1:Set&lt;Character&gt; = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]var set2:Set&lt;Character&gt; = [&quot;e&quot;,&quot;f&quot;,&quot;g&quot;]//向集合中插入元素set1.insert(&quot;z&quot;)//获取集合中元素个数set1.count//判断集合是否为空set1.isEmpty//将集合中的某个元素移除set1.remove(&quot;a&quot;)//移除集合中的所有元素set1.removeAll()//判断集合中是否包含某个元素set2.contains(&quot;e&quot;)//遍历集合for item in set2 &#123; print(item)&#125;//进行从小到大的排序遍历for item in set2.sort() &#123; print(item)&#125; Set也支持进行一些集合的数学运算，例如交集，并集，补集等，下面一张图演示了Set进行集合运算的一些特性： intersect()方法返回两个集合的交集。 exclusiveOr()方法用于返回两个集合交集的补集。 union()方法用于返回两个集合的并集。 subtract()方法用于返回第二个集合的补集。 示例代码如下： 12345678910var set3:Set&lt;Int&gt; = [1,2,3,4]var set4:Set&lt;Int&gt; = [1,2,5,6]//返回交集 &#123;1，2&#125;var setInter = set3.intersect(set4)//返回交集的补集&#123;3，4，5，6&#125;var setEx = set3.exclusiveOr(set4)//返回并集&#123;1，2，3，4，5，6&#125;var setUni = set3.union(set4)//返回第二个集合的补集&#123;3，4&#125;var setSub = set3.subtract(set4) 使用比较运算符==可以比较两个Set集合是否相等，当两个Set集合中所有元素都相等时，这两个集合才相等。下面代码显示了与子集相关的运算： 123456789101112var set5:Set = [1,2]var set6:Set = [2,3]var set7:Set = [1,2,3]var set8:Set = [1,2,3]//判断是否是某个集合的子集 set5是set7的子集 返回tureset5.isSubsetOf(set7)//判断是否是某个集合的超集 set7是set5的超集 返回tureset7.isSupersetOf(set5)//判断是否是某个集合的真子集 set5是set7的真子集 返回tureset5.isStrictSubsetOf(set7)//判断是否是某个集合的真超集 set7不是set8的真超集 返回falseset7.isStrictSupersetOf(set8) 四、Dictionary类型Swift中的Dictionary在声明时必须明确键的类型和值的类型，示例如下： 12var dic:Dictionary&lt;Int,String&gt;var dic2:[Int:String] = [1:&quot;one&quot;,2:&quot;Two&quot;] 访问与操作Dictionary的方法，代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940var dic2:[Int:String] = [1:&quot;One&quot;,2:&quot;Two&quot;,3:&quot;Three&quot;,4:&quot;Four&quot;]//获取字典键值对个数dic2.count//判断字典是否为空dic2.isEmpty//通过键获取值dic2[1]//通过键修改值dic2[1] = &quot;First&quot;//添加键值dic2[0] = &quot;Zero&quot;//updateValue 方法将更新一个键值 如果此键存在 则更新键值 并且将旧的键值返回 如果此键不存在 则添加键值 返回nil 其返回的为一个Optional类型值 可以使用if let进行处理dic2.updateValue(&quot;9&quot;, forKey: 1)//使用if let 处理updateValue的返回值if let oldValue = dic2.updateValue(&quot;One&quot;, forKey: 1) &#123; print(&quot;Old Value is \\(oldValue)&quot;)&#125;//通过键值获取的数据也将是有个Optional类型的值 也可以使用if letif let value = dic2[1] &#123; print(&quot;The Value is \\(value)&quot;)&#125;//移除某个键值对dic2[9]=nildic2.removeValueForKey(9)//对字典进行遍历for (key,value) in dic2 &#123; print(key,value)&#125;//遍历所有键for key in dic2.keys &#123; print(key)&#125;//遍历所有值for value in dic2.values &#123; print(value)&#125;//进行从小到大的排序遍历for key in dic2.keys.sort() &#123; print(key)&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift解读专题四——字符串与字符","slug":"204Swift解读专题四——字符串与字符","date":"2016-05-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.340Z","comments":true,"path":"2016/05/10/204Swift解读专题四——字符串与字符/","link":"","permalink":"http://huishao.cc/2016/05/10/204Swift解读专题四——字符串与字符/","excerpt":"","text":"Swift解读专题四——字符串与字符一、引言Swift中提供了String类型与Characters类型来处理字符串和字符数据，Swift中的String类型除了提供了许多方便开发者使用的方法外，还可以与Foundation框架的NSString类进行转换，使用起来十分方便。 二、String基础在Swift中，使用双引号来定义字符串，开发者可以通过如下代码来创建一个字符串常量： 1let str = &quot;Hello, playground&quot; 可以通过下面两种方式来创建空字符串： 12let str1 = &quot;&quot;let str2 = String() 调用isEmpty方法可以判断某个字符串是否为空字符串，这个方法将返回一个Bool值，可以直接用于if语句： 123if str1.isEmpty &#123; print(&quot;this String Object is Empty&quot;)&#125; 不像Objective-C有NSString与NSMutableString的区别，在Swift中，如果需要创建可变的字符串，只需用变量来接收： 12var str3 = &quot;Hello&quot;str3 += &quot; &quot;+&quot;World&quot;//str3 = Hello World String也可以使用插值的方法来构造新的字符串，使用\\()的方式来将插值的表达式写在小括号内，示例如下： 12let multiplier = 3let message = &quot;\\(multiplier) times 2.5 is \\(Double(multiplier) * 2.5)&quot;//3 times 2.5 is 7.5 获取字符串的长度使用如下代码： 1str3.characters.count Swift中的String可以直接使用==运算符来进行比较，示例如下： 123let comStr1 = &quot;one two&quot;let comStr2 = &quot;one two&quot;comStr1==comStr2//true 下面示例的代码，用来检验字符串是否包含前缀与后缀： 123let tmp3 = &quot;thank you&quot;tmp3.hasPrefix(&quot;thank&quot;)//truetmp3.hasSuffix(&quot;you&quot;)//true 三、Character的使用Character为Swift中的字符类型，在for-in循环中，可以将字符串中所有的字符进行遍历： 123for chara in str3.characters &#123; print(chara)&#125; 也可以创建单独的字符类型量值，示例如下： 12let char1 = &quot;🐶&quot;var cgar2 = &quot;HS&quot; 事实上，Sting字符串也可以通过Character字符数组进行初始化： 12let chars:[Character] = [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]let str4 = String(chars) 向字符串中追加字符使用如下方法： 123var str5 = &quot;&quot;let ca:Character = &quot;a&quot;str5.append(ca) 四、字符串中的特殊字符字符串中的特殊字符主要指转义字符，Swift中的转义字符列举如下： 12345678&quot;\\0&quot;//&quot;&quot; 空白符&quot;\\\\&quot;//&quot;\\&quot;反斜杠符号&quot;\\t&quot;//&quot; &quot;制表符&quot;\\n&quot;//换行符&quot;\\r&quot;//回车符&quot;\\&apos;&quot;//&quot;&apos;&quot;单引号&quot;\\&quot;&quot;//&quot;&quot;&quot;双引号&quot;\\u&#123;24&#125;&quot;//&quot;$&quot;unicode字符 五、关于字符串下标在Swift中，字符串也可以通过下标的方式来访问其中字符，并且提供了相关方法来方便的移动下标，示例代码如下： 1234567891011121314151617let tmp = &quot;Hello Swift&quot;//获取字符开始的下标值 0let indexStart = tmp.startIndex//获取某个下标后一个字符的下标 1let next = indexStart.successor()//获取最后一个字符的下标值 注意有\\0的存在 let indexEnd = tmp.endIndex//获取某个下标前一个字符的下标let pre = indexEnd.predecessor()//通过下标获取字符串中的字符 tvar c = tmp[pre]//进行下标移动 ovar c2 = tmp[indexStart.advancedBy(4)]//通过遍历下标来遍历字符 H e l l o S w i f tfor index in tmp.characters.indices &#123; print(&quot;\\(tmp[index]) &quot;, terminator: &quot;&quot;)&#125; 六、在字符串中插入和移除字符使用insert函数来向字符串中插入一个字符，示例如下： 12var tmp2 = &quot;Hello&quot;tmp2.insert(&quot;!&quot;, atIndex: tmp2.endIndex) 注意，上面示例代码中的insert函数只能用于插入一个字符，如果需要插入一组字符，需要使用如下方法： 1tmp2.insertContentsOf(&quot; Swift&quot;.characters, at: tmp2.endIndex) 使用removeAtIndex函数来移除字符串中的一个字符，示例如下： 1tmp2.removeAtIndex(tmp2.endIndex.predecessor()) 如果要移除一组字符，主要通过Range来实现，示例如下： 12let range = tmp2.endIndex.advancedBy(-4)..&lt;tmp2.endIndextmp2.removeRange(range) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift解读专题三——基础运算符","slug":"203Swift解读专题三——基础运算符","date":"2016-05-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.340Z","comments":true,"path":"2016/05/09/203Swift解读专题三——基础运算符/","link":"","permalink":"http://huishao.cc/2016/05/09/203Swift解读专题三——基础运算符/","excerpt":"","text":"Swift解读专题三——基础运算符一、引言运算符是编程语言不可缺少的一个部分，Swift中除了支持C中的运算符外，还提供了一些更加强大的运算符功能，例如取余符%可以用来计算浮点数，另外新增了两种范围运算符。Swift中有3类运算符: 1.一元运算符 运算符作用于一个操作数，可以出现在操作数前或者操作数后。 2.二元运算符 运算符作用于两个操作数，出现在两个操作数中间。 3.三元运算符 运算符作用于三个操作数间。 二、赋值运算符赋值运算符用=符号表示，用于初始化或者更新一个量值，示例如下： 1234//将字符串“hello world” 赋值给变量strvar str = &quot;Hello, world&quot;//更新变量str的值str = &quot;new value&quot; 如果赋值运算符的右边是一个元组，其也可以将元组进行分解赋值，示例如下： 12//对元组进行分解赋值var (x,y) = (1,2) 与C与Objective-C不同，Swift的中赋值运算符并不会返回一个值，很多初学者在进行if语句的使用时，经常会犯的一个错误就是将赋值运算符当做等于运算符来使用，这些错误在Swift语言中都将被避免，因为如果在if语句的判断条件中使用的是赋值运算符，编译器将会直接抛出错误。 三、算术运算符Swift中支持的基础的算数运算符有7种，加(+)、减(-)、乘(*)、除(/)、取余(%)、正号(+)、负号(-)。Sring类型的数据是支持通过+运算符来进行拼接的，示例如下： 1var newStr = &quot;hello&quot;+&quot;world&quot; Swift中的%运算符比Objective-C更加强大，其除了支持整数的取余操作外，还可以支持浮点数的取余操作，示例如下： 1234var value1 = 10%3 //余数1var value2 = -10%3 //余数-1var value3 = 10%4.5 //余数1var value4 = -10%4.5 //余数-1 对于正号和负号操作符也被称为一元加操作符与一元减操作符，一元减操作符会改变数据的正负性，一元加操作符只会返回数值本身，并没有做任何操作，示例如下： 123var tmp = -3;+tmp//-3-tmp//3 四、复合赋值运算符Swift中提供了将一个算术运算符与赋值运算符结合使用的复合赋值功能，示例如下： 12345tmp+=3 //tmp = tmp +3tmp-=3 //tmp = tmp -3tmp*=3 //tmp = tmp *3tmp/=3 //tmp = tmp /3tmp%=3 //tmp = tmp %3 五、比较运算符Swift支持Objective-C中所有的比较运算符，比较运算符将会返回一个Bool类型的值： 1234561==2 //等于比较1&lt;2 //小于比较1&gt;2 //大于比较1 != 2 //不等于比较1&lt;=2 //小于等于比较1&gt;=2 //大于等于比较 除了上面列举出的6种比较运算符外，Swift中还提供了两个特殊的比较运算符===和!==，这两个比较运算符用于比较引用是否相同。 Swift中的元组也可以进行比较，但是其有两个前提需要注意： 1.元组中元素的个数相同且对应位置的元素类型相同。 2.元组中的元素可以进行比较操作。 当元组进行比较时，按元素顺序进行逐个比较，直道某个元素比较出结果后作为元组的比较结果。 12(1,&quot;123&quot;)&gt;(0,&quot;234&quot;) //true(1,&quot;123&quot;)&gt;(1,&quot;456&quot;) //false 三元运算符可以理解为一个简写的if else 语句，示例如下： 1var a = 1&gt;2 ? 1:2 //如果1&gt;2成立 a=1 a=2 六、空聚合运算符空聚合运算符也是Swift语言中独有的一个运算符，其设计的思路是基于更加方便的使用Optional值的目的。对于Optional类型的值，开发者一般会需要使用?进行可选拆包或者!进行强制拆包来获取其原始值，空聚合运算符??提供了更加使用的方式，示例如下： 123456var Op1:String?var Op2:String? = &quot;123&quot;//这个表达式将返回Op2 其意义是 如果Op1不为nil，则对其进行强制拆包 将值返回，如果为nil，则返回Op2var realStr = Op1 ?? Op2//上面的表达式和下面这个表达式意义相同Op1 != nil ? Op1! : Op2 七、区间运算符Swift中还提供了区间运算符，在for-in循环中，区间运算符会被经常使用到，示例如下： 12345678//a...b为闭区间写法for index in 0...3 &#123; print(index)&#125;//a..&lt;b为左闭右开区间for index in 0..&lt;3 &#123; print(index)&#125; 八、逻辑运算符Swift中支持与&amp;&amp;、或||、非!三种逻辑运算符，逻辑运算符只能操作Bool值，示例如下： 12345var one = truevar two = falseone&amp;&amp;two //falseone||two //true!one //false 逻辑运算符在复合使用时，最好使用小括号进行模块分隔，增强可读性。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift解读专题二——基本类型","slug":"202Swift解读专题二——基本类型","date":"2016-05-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.339Z","comments":true,"path":"2016/05/08/202Swift解读专题二——基本类型/","link":"","permalink":"http://huishao.cc/2016/05/08/202Swift解读专题二——基本类型/","excerpt":"","text":"Swift解读专题二——基本类型一、常量和变量Swift语言的常量和变量在使用之前，必须被定义。常量用于处理程序中只在初始化时设置的量值，之后不能进行赋值改变，变量用于处理程序中可以进行改变的量值。分别用let和var来声明常量和变量，示例如下： 12var varValue = 1let letValue = 10 Swift语法也支持在一行中声明多个量值，示例如下： 1var a=1,b=2.9,c=&quot;string&quot; 在声明量值时，编译器会根据第一次赋值的类型来推断出变量的类型，一旦量值的类型被推断，则不能够进行更改，开发者也可以手动注释量值的类型，示例如下： 1var a:Int=1,b:Float=2.9,c:String=&quot;string&quot; 在一行中声明多了变量并且没有提供初始值时，为最后一个变量注释的变量类型也会应用于本行中的所有变量，示例如下： 1var one,two,three:Int 官方文档建议，在实际应用中，注释量值的类型是十分少用的，一般都会为其赋值初始值后让编译器自行推断。 量值的命名可以包含Unicode字符和数字，需要注意，是不能以数字作为量值名称的开头的。空格，数学符号，制表符，箭头等符号也不可以使用。示例如下： 12345678//中文符作变量名var 珲少 = &quot;me&quot;//表情符作为变量名var 😄 = &quot;开心&quot;//含有数字的变量名var one2three = &quot;123&quot;//含有下划线的变量名var _d_s = &quot;C++&quot; 注意：如果使用Swift中的保留关键字作为量值的名，需要加上左右个加上`符号包围，除非特殊情况，否则不要使用这种方式命名量值，示例如下： 1var `let` = &quot;c&quot; 使用print()方法可以进行量值的打印，在字符串中使用\\()格式可以插入变量，示例如下： 12var _d_s = &quot;C++&quot;print(&quot;123\\(_d_s)&quot;) 二、关于注释与编写结构Swift语言可以使用//进行单行注释和/**/进行多行注释，除此之外，Swift语言还支持多行注释的嵌套，示例如下： 123456789101112//我是单行注释/* 我是多行注释 我是多行注释 我是多行注释 *//* 嵌套注释 /* 嵌套注释 */ */ 使用Swift在编写代码时，以行为每句代码的分隔，当然，开发者也可以将多句代码写在一行中，但是需要以分号进行分隔。示例如下： 1var tmp = 3;print(tmp) 三、整型与浮点型Swift中提供8位、16位、32位、64位类型的整型，整型数组不包含小数，包含负整数，0和正整数。在Swift语言中，整型是由结构体定义的，可以调用max和min方法获取对应位数的最大值和最小值，示例如下： 12345678var maxInt8 = Int8.max //127var mimInt8 = Int8.min //-128var maxInt16 = Int16.max //32767var minInt16 = Int16.min //-32768var maxInt32 = Int32.max //2147483647var minInt32 = Int32.min //-2147483648var maxInt64 = Int64.max //9223372036854775807var minInt64 = Int64.min //-9223372036854775808 Int类型的值在不同位数的系统会有不同的结果，在32位系统上，Int与Int32相同，在64位系统上，Int与Int64相同。 Swift语言也提供了无符号整型，示例如下： 1234var maxUInt8 = UInt8.max //255var maxUInt16 = UInt16.max //65535var maxUInt32 = UInt32.max //4294967295var maxUInt64 = UInt64.max //18446744073709551615 UInt类型在32位系统为UInt32，在64位系统为UInt64。 浮点型用于创建小数，Swift提供了两种类型的浮点型，Float对应32位的浮点值，Double对应64位的浮点值。 在定义整型或浮点型数据时，可以通过添加前缀的方式来指定其进制类型，示例如下： 1234var type_10 = 17; //十进制的17var type_2 = 0b10001 //二进制的17var type_8 = 0o21 //八进制的17var type_16 = 0x11 //16进制的17 对于科学计数法，在Swift中使用e和p来标识，在十进制中使用e代表10的n次方，在十六进制中，使用p代表2的n次方，示例如下： 12var sum = 1.25e3 //1.25*10^3 = 1250var sun2 = 0x1p3 //1*2^3 = 8 Swift中还有一个非常有意思的特性，无论是整型还是浮点型，都可以在数前使用0进行填充，并且可以使用下划线进行可读性分隔，是代码看起来更加清晰，这些都不会改变原数据值，示例如下： 123var num1 = 001.23var num2 = 1_000var num3 = 1_000.1_001 开发者也可以使用typealias关键字来为某个数据类型添加一个别名，示例如下： 1typealias MyType = Int 四、布尔类型在Objective-C中，BOOL值实际上是无符号的整型数据，其约定0为NO，非0都为YES。在Swift中，Bool被作为一种独立的数据类型，提供true和false两种值。示例如下： 1var boolVale:Bool = true 五、元组元组是Swift语言十分重要的一个特点，它允许开发者将任意个不同类型的数据组合成一个数据类型，这也是Swift语言的一个强大之处。例如如下示例代码可以创建一个元组： 1var tuples:(param1:Int,param2:Float,param3:String,param4:Bool) = (3,3.14,&quot;圆周率&quot;,true) tuples就是一个类型为(param1:Int,parame:Float,param3:String,param4:Bool)类型的元组。取元组数据的对应值有两种方式，一种是使用数据参数名称，一种是直接使用数据的角标，示例如下： 12345678910//通过参数名取元组中的数据var tuplesInt = tuples.param1;var tuplesFloat = tuples.param2;var tuplesString = tuples.param3;var tuplesBool = tuples.param4;//通过角标取元组中的数据var tuplesInt2 = tuples.0;var tuplesFloat2 = tuples.1;var tuplesString2 = tuples.2;var tuplesBool2 = tuples.3; 开发者也可以将元组分解成单独的常量进行访问，示例如下： 12let (fir,sec,thr,four) = tuplesprint(fir,sec,thr,four) 有时候，某个元组中的所有数据开发者并不一定都需要使用，开发者可以选择只提取元组中所需要的值，示例如下： 12let (fir,_,thr,_) = tuplesprint(fir,thr) 开发文档提示，元组只适合临时的简单组合数据，并不适合处理复杂的数据逻辑，对复杂数据逻辑的处理更提倡使用类。 六、Optionals值Optional也是一种具体的数据类型，其寄附与其他数据类型上，其只有两个值： 1.如果有值，则它为具体的值。 2.如果没有值，则它为nil。 对于习惯了Objective-C语言设计风格的开发者来说，Optional的概念可能有些难于理解，通过一个例子就很好理解，示例代码如下： 12let tmp = 123let tmp2 = Int(&quot;123&quot;) 上面创建的两个常量tmp和tmp2虽然值都是123，然而其并不是相同的类型，tmp是严格的Int类型值，tmp2是基于Int类型的Optional值，他们在使用时，Optional值需要使用!进行拆包操作，示例如下： 123let tmp = 123let tmp2 = Int(&quot;123&quot;)let tmp3 = tmp + tmp2! 有时候，Int()构造方法并不一定能构造成功，这时tmp2是会为nil值的，示例如下： 1let tmp2 = Int(&quot;a&quot;) 将普通类型声明为Optional类型，只需在类型名后添加?符号即可，示例如下： 1let optionalValue:Int? = 1 Swift中的nil与Objective-C中的nil意义并不相同，在Objective-C中，nil代表指针指向一个不存在的对象，Swift中的nil并不是指针，它是一种抽象类型的值，在Swift不只对象的Optional类型可以设置为nil，任何数据类型的Optional类型都可以设置为nil。 Optional值经常会和if条件语句一起使用，用来判断某个值是否被初始化了，示例如下： 123if optionalValue != nil &#123; print(optionalValue)&#125; Swift还提供了if let语法进行Optional值得绑定，示例如下： 1234//如果optionalValue值不为nil，则会将拆包后的值赋值给tipif let tip=optionalValue &#123; print(tip)&#125; 开发者还可以在一个绑定语句后进行多个Optional值的绑定，并使用where进行条件判断，示例如下： 12345let optionalValue:Int? = 1let optionalValue2:Int? = 2if let tip=optionalValue,tip2=optionalValue2 where tip&lt;tip2&#123; print(tip,&quot;&lt;&quot;,tip2)&#125; 七、异常处理Swift中也有一套十分强大的异常处理系统。在编写函数时，如果这个函数可能抛出异常，则需要加上throw关键字，并且在函数中也是使用throw关键字来进行异常的抛出。示例如下： 123456789101112131415161718192021222324252627//异常的捕获 自定义的异常必须继承与ErrorType类enum MyErrorType:ErrorType &#123; case CanNotZero case Other&#125;//可能抛出异常的函数func ErrorTest() throws &#123; let a=0; if a==0 &#123; throw MyErrorType.CanNotZero &#125;&#125;//进行异常捕获do &#123; //使用try进行可能抛异常函数的执行 try ErrorTest() //没有错误执行的代码块 //catch加错误类型 为捕获相应的异常&#125;catch MyErrorType.Other &#123; //抛异常后执行的代码块 print(&quot;MyErrorType.Other&quot;)&#125;catch MyErrorType.CanNotZero &#123; print(&quot;MyErrorType.CanNotZero&quot;)&#125;catch&#123; //如果不写捕获的异常类型 则会捕获所有异常 并且传入一个error异常参数 print(error)&#125; 八、断言在Objective-C中，使用Assert相关的宏来进行断言处理，在Swift中也同样有断言的相关操作，断言可以帮助开发者为某种情况添加一个异常中断，为开发者提供调试信息。断言会要求提供一个条件进行判断，当条件为真时，程序继续运行，如果条件为假，则程序会断开，示例如下： 12let age = -3assert(age&gt;0, &quot;age must be bigger than zero&quot;) 官方文档为开发者提供了几种断言使用的场景，参考如下： 1.对于索引过小或过大的检查。 2.当无效的参数传递进函数时。 3.对于一个可能为nil的值，当为nil时后续代码无法工作时。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift解读专题一——Swift2.2语言预览","slug":"201Swift解读专题一——Swift2.2语言预览","date":"2016-05-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.339Z","comments":true,"path":"2016/05/05/201Swift解读专题一——Swift2.2语言预览/","link":"","permalink":"http://huishao.cc/2016/05/05/201Swift解读专题一——Swift2.2语言预览/","excerpt":"","text":"专题一——Swift2.2语言预览一、引言本系列专题是我通过阅读Swift2.2语言开发文档，翻译总结加上自己的理解整理而成。其中大部分结构和内容都来自开发文档，有疏漏和错误之处，还望更多朋友指出，共同交流进步，我的QQ：316045346。 二、从HelloWorld开始在学习很多编程语言时，都是从HelloWorld入门，下面代码就是一个完整的HelloWorld程序： 1print(&quot;Hello, World!&quot;) 分析上面代码，可以发现Swift语言的3个十分明显的特点： 1.开发者不需要引入输入输出相关的函数库。 2.在编写代码时，不需要在语句的结尾处添加分号。 3.全局的代码就是程序的入口，不需要类似C系语言的main()方法来作为程序入口。 三、常量与变量常量和变量是编程语言中最基础的两类数据类型，常量可以理解为为某个值起一个特定的名字，常量通常提供给开发者用于某些只赋值一次但却在程序中多处使用的量值。变量也可以进行多次修改。分别使用let和var创建常量和变量。例如： 123let letValue = 4var varValue = 8varValue = 16 开发者在进行常量和变量的创建时，并不需要制定类型，编译器与根据第一次赋值的类型来推断出常量或者变量的类型，然而这并不是说Swift语言不严格要求变量或常量的类型，一旦编译器推断了值的类型，之后开发者若要修改变量，则必须严格遵守既定的变量类型，否则编译器会报错。 如果开发者第一次对变量或常量进行的赋值不能够使编译器正确的推断出常量或变量的类型，开发者也可以通过冒号后跟类型的方式来强制定义变量或常量的类型，如下： 12var varValue:Float = 8varValue = 16.0 在Swift语言中，不存在隐式转换的概念，这也是Swift语言更加安全的特性之一，这样的设计可以保证变量在任何时候类型都被明确的指定。在进行类型转换时，可以通过类实例化的方式进行，示例如下： 1234//Float值转成IntletValue+Int(varValue)//Int转为FloatFloat(letValue)+varValue 对于在字符串中使用其他类型的变量，Swift语言提供了一种更加便捷的写法，使用\\()的方式来转换，小括号内为变量的名称，例如： 123var strValue = &quot;Hello&quot;//Hello16.0strValue+&quot;\\(varValue)&quot; 四、数组与字典数组与字典是最常用的两种数据集合，在Swift语言中，使用\\[\\]来创建数组或字典，示例如下： 12var array = [1,2,3]var dic = [1:&quot;one&quot;,2:&quot;two&quot;,3:&quot;three&quot;] 同Int，Float类型的数据一样，数组和字典在第一次赋值时，也会根据赋值的类型来推断出变量类型，开发者同样也可以强制指定，如下： 12var array:[Int] = [1,2,3]var dic:[Int:String] = [1:&quot;one&quot;,2:&quot;two&quot;,3:&quot;three&quot;] Swift允许创建或者重新赋值为空的数据或者字典，但是这有一个前提条件，被赋值为空的数据或字典必须是类型确定的，示例如下： 1234567891011121314//这样写会报错//var errorArray = []//创建空的数据集合//方式一var array:[Int] = []var dic:[Int:String] = [:]//方式二var array2 = [Int]()var dic2 = [Int:String]()//方式三var array3 = [1]var dic3 = [1:&quot;1&quot;]array3 = []dic3 = [:] 五、optional类型的值在理解optional类型的值之前，我们可以先来看一段C代码： 123456int a=1;if(a)&#123; &#125;else&#123; &#125; 上面这段代码对于C语言来说完全没有问题，当a为非0值时，就代表条件为真，在Swift语言中则不同，if选择语句中的条件必须为Bool类型的值，因此，对于某些可以为空的值，Swift中提供了optional类型，这种类型相当于对其他实际类型进行了包装，如果有值，则他拆包后为相应类型的值，如果没有值，则为空值nil。示例如下： 1234var optionalString: String? = &quot;Hello&quot;if optionalString == nil &#123; &#125; 在Swift中，当if与let共同使用时，将会构成一种更加奇特的语法方式，这种方式对于处理optional类型的值十分方便，示例如下： 12345678910/* if let 后面赋值为optional类型的值有这样的效果 如果optional的值不为nil 则会走if条件为真的语句块并且将optional变量的值赋值给let常量 可以在if为真的语句块中使用 如果optional的值为nil 则会走else语句块 并且name常量被释放 不能再else块中使用*/if let name=optionalName &#123; greeting = &quot;Hello, \\(name)&quot;&#125;else&#123; print(greeting)&#125; 除了if let语法外，还有一种方式可以用来处理optional类型的值，示例如下： 12var greeting = &quot;Hello!&quot;greeting = &quot;Hello&quot; + (optionalString ?? &quot;&quot;) ??运算符用来为optional类型的值设置一个默认值，如果optional值为nil，则会使用后面设置的默认值来代替。 Swift语言的switch语句相比于C系的语言要强大的多，其不只可以用于判断整型，其可以处理任意类型的数据，同样，它也不只限于比较是否相等的运算，其可以支持各种负责运算，示例如下： 1234567891011let vegetable = &quot;red pepper&quot;switch vegetable &#123;case &quot;celery&quot;: print(&quot;Add some raisins and make ants on a log.&quot;)case &quot;cucumber&quot;, &quot;watercress&quot;: print(&quot;That would make a good tea sandwich.&quot;)case let x where x.hasSuffix(&quot;pepper&quot;): print(&quot;Is it a spicy \\(x)?&quot;)default: print(&quot;Everything tastes good in soup.&quot;)&#125; 如果匹配上了一个case，程序会结束switch选择，各个case之间是互斥的。 六、循环语句Swift2.2中，弃用了for i；param;param{}格式的循环语句，提供给开发者使用的循环语句主要有3种。 1.for in语句 for in语句多用于快速遍历字典，示例如下： 123456789101112131415let interestingNumbers = [ &quot;Prime&quot;: [2, 3, 5, 7, 11, 13], &quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8], &quot;Square&quot;: [1, 4, 9, 16, 25],]var largest = 0for (kind, numbers) in interestingNumbers &#123; for number in numbers &#123; //找出最大值 if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest) 在for in循环中可以使用一个索引来指定循环次数，通过这种方式可以实现有序的遍历操作，示例如下： 123for i in 0..&lt;10 &#123; print(i)&#125; 2.while语句 while语句用于条件循环，直到不再满足某个条件为止，示例如下： 12345var n = 2while n &lt; 100 &#123; n = n * 2&#125;print(n) 3.repeat {}while语句 repeat{}while语句与C语言中的do{}while作用相同，保证至少循环一次。示例如下： 12345var m = 2repeat &#123; m = m * 2&#125; while m &lt; 100print(m) 七、函数与闭包Swift中的函数使用关键字func来标识，格式如下： func name(param1,param2…)-&gt;returnValue{} 示例代码如下： 12345func add(param1:Int,param2:Int) -&gt; Int &#123; return param1+param2&#125;//下面表达式将返回8add(5, param2: 3) 我比较了Swift语言与Objective-C、Java语言的函数特点： Objective-C实际上并没有函数重载的概念，不同参数的函数实际上拥有不同的函数名，Objective-C的风格将参数名嵌套进函数名中，这样有一个好处，开发者可以通过函数名明确的知道此函数的用途以及每个参数的意义，当然也有其局限性，Objective-C的函数大多十分冗长，不够简洁。 Java不同参的函数采用重载的方式，这样的效果是，相同的函数名，参入不同的参数则会执行不同的操作，是不同的两个方法，这样的有点是使代码十分简洁，然而对开发者来说并不友好，开发者在开发时不能便捷的看出每个参数的意义和用法。 个人见解，Swift对函数的设计综合了上面两种语言的有事，参数列表与函数名分离，简化了函数，同时，参数列表中保留了每个参数的名称，使开发者在调用函数时更加直观。 在Objective-C中，如果需要某个函数返回一组值，开发者通常会需要使用字典或者数组，这样做有一个问题，在调用此函数时，返回值的意义十分模糊，开发者需要明确的知道其中数据的顺序与意义。Swift中可以采用返回元组的方式来处理一组返回值，示例如下： 1234567891011121314151617181920212223//返回一组数据的函数func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) &#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min, max, sum)&#125;//元组数据let statistics = calculateStatistics([5, 3, 100, 3, 9])//通过名称取元组中的最大值print(statistics.max)//通过角标取元组中的最小值print(statistics.0) 对于可变参数个数的函数，在Objective-C中，开发者大多会采用va_list指针的方式实现，示例如下： 12345678910-(void)myLog:(NSString *)str,...&#123;//省略参数的写法 va_list list;//创建一个列表指针对象 va_start(list, str);//进行列表的初始化，str为省略前的第一个参数，及...之前的那个参数 NSString * temStr = str; while (temStr!=nil) &#123;//如果不是nil，则继续取值 NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*);//返回取到的值，并且让指针指向下一个参数的地址 &#125; va_end(list);//关闭列表指针&#125; 在Swift语言中，实现这样的函数要简单的多，通过…来进行参数的省略，并且将这些省略的函数包装为数组传入函数内部，示例如下： 12345678910func sumOf(numbers: Int...) -&gt; Int &#123; var sum = 0 //多参被包装为数组 for number in numbers &#123; sum += number &#125; return sum&#125;sumOf()sumOf(42, 597, 12) 与Java类似，Swift中的函数也支持嵌套操作，嵌套内部的函数可以使用外部的变量，示例如下： 1234567891011func returnFifteen() -&gt; Int &#123; var y = 10 //嵌套函数 func add() &#123; y += 5 &#125; //调用 add() return y&#125;returnFifteen() 由于函数也是一种特殊的数据类型，函数也可以作为返回值，示例如下： 12345678func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; return addOne&#125;var increment:((Int)-&gt;Int) = makeIncrementer()increment(7) 一个函数也可以作为另一个函数的参数来使用，示例如下： 123456789//参数中有函数func func1(param1:Int,param2:(count:Int)-&gt;Void) &#123; param2(count: param1+1)&#125;func tmpFunc(count:Int) -&gt; Void &#123; print(count)&#125;//将函数作为参数传入func1(3, param2: tmpFunc) 与Objective-C中的block对应，Swift中有闭包的概念来创建一个代码块，可以理解为闭包为没有名字的函数，使用{()in }格式来创建闭包，示例代码如下： 12var f:(count:Int)-&gt;Void = &#123;(Count) in print(132) &#125;f(count:0) 通过这种写法，开发者在将函数作为参数传递时，无需再创建中间函数，示例如下： 123456789//参数中有函数func func1(param1:Int,param2:(count:Int)-&gt;Void,param3:(count:Int)-&gt;Void) &#123; param2(count: param1+1)&#125;func1(3, param2: &#123; (count) in print(count) &#125;, param3: &#123; (count) in print(count)&#125;) 还有一种更加简单的闭包书写方法，如果闭包类型是确定的，全完可以省略小括号中的参数名称与闭包格式in，使用角标来获取参数，示例如下： 123456//优化前var f:(a:Int,b:Int)-&gt;Bool = &#123;(a,b) in return a&gt;b&#125;f(a: 3,b: 4)//优化后var f:(a:Int,b:Int)-&gt;Bool = &#123;$0&gt;$1&#125;f(a: 3,b: 4) 八、类与属性Swift中使用class关键字来定义类，类内部可以声明与定义一些属性与方法，类的实例对象可以通过点语法来调用类的属性和方法，示例如下： 1234567891011class MyClass &#123; var count = 100 let name = &quot;珲少&quot; func run() &#123; print(&quot;run 100 miter&quot;) &#125;&#125;var obj = MyClass()let count = obj.countlet name = obj.nameobj.run() 类名加括号用于创建类的实例对象，可以通过重写init方法来重写类的默认构造方法，如果这个类有继承的父类，则需要遵守如下3条规则： 1.必须先将子类的属性初始化完成。 2.调用父类的构造方法。 3.修改父类需要修改的属性。 在Swift中同样也有set和get方法，只是这里的set和get方法与Objective-C中的set和get方法有很大的不同，Objective-C中的get和set方法是截获了属性和存取过程，在其中加入额外的其他操作，Swift中的set和get方法原理上将属性的存取与其他逻辑操作进行了分离，抽象出了一种计算属性，示例如下： 12345678910111213141516171819class MyClass &#123; var count:Int //实际上并不存在privateCount属性 通过pricatecount来操作count的值 var privateCount:Int&#123; get&#123; return count; &#125; set &#123; count=newValue+100 &#125; &#125; let name = &quot;珲少&quot; func run() &#123; print(&quot;run 100 miter&quot;) &#125; init()&#123; count=200 &#125;&#125; Swift采用这样的设计思路也有其一定的优化道理，我比较了一下，给大家举一个最简单的例子，在使用Objective-C进行iOS开发时，经常会遇到这样的情况，某个控件中有一个UILabel控件，开发者在不想将控件暴漏在.h文件中的情况下经常会声明一个NSString类型的变量，重写此变量的set方法来完成对UILabel控件的赋值，仔细想来，实际上声明的这个NSString变量完全是多余的，它只是为了用来做中间值得传递，Swift的set和get方法就在这里进行了优化。另外，在set方法中会自动生成一个命名为newValue的变量作为传递进来的值，开发者也可以自定义这个变量的名称，在set后加小括号即可，示例如下： 12345678var privateCount:Int&#123; get&#123; return count; &#125; set(myValue) &#123; count=myValue+100 &#125; &#125; Swift中也提供了监听属性赋值过程的方法，其使用的是willSet与didSet机制，示例如下： 12345678910111213141516171819class MyClass &#123; var count:Int&#123; //赋值前执行(除了第一次初始赋值) 将要赋值的值以newValue传入 willSet&#123; print(&quot;will set \\(newValue)&quot;) &#125; //赋值后执行(除了第一次初始赋值) 原来的值以oldValue传入 didSet&#123; print(&quot;did set \\(oldValue)&quot;) &#125; &#125; let name = &quot;珲少&quot; func run() &#123; print(&quot;run 100 miter&quot;) &#125; init()&#123; count=200 &#125;&#125; 九、枚举和结构体Swift中的枚举和C与Objective-C有很大的差别，在Swift中，枚举也被作为一种数据类型来处理，其中可以添加函数方法。最基本的枚举用法如下所示： 12345678//枚举可以多个case并列 也可以写在一个case中以逗号分隔enum MyEnum &#123; case one case tew case three case Fir,Sec,Thr&#125;var em = MyEnum.one 如果变量是类型确定的枚举，在赋值时可以省略枚举名，示例如下： 1var em:MyEnum = .one Swift中的枚举还有一个原始值的概念，要使用原始值，必须在创建枚举类型时设置原始值的类型，示例如下： 1234567enum MyEnum:Int &#123; case one=1 case tew case three case Fir,Sec,Thr&#125;var em = MyEnum.one.rawValue 如果原始值是Int类型，则默认从0开始依次递增，开发者也可以手动设置每个枚举值的原始值。同样，也支持使用原始值来创建枚举实例，如下： 1var em = MyEnum(rawValue:1) 通过原始值实例的枚举对象实际上回返回一个optional类型的值，如果传入的原始值参数不能匹配到任何一个枚举case，则可以使用if let结构进行判断处理。 在枚举中封装方法示例如下： 12345678910111213141516enum MyEnum:Int &#123; case one case tew case three case Fir,Sec,Thr func des() &#123; switch self &#123; case .one: print(&quot;one&quot;) default: print(&quot;else&quot;) &#125; &#125;&#125;var em = MyEnum(rawValue:1)em?.des() Swift中的枚举也可以添加附加值，在switch语句中取到对应的枚举类型后，可以获取开发者设置的附加值进行逻辑处理，示例如下： 1234567891011121314151617181920212223enum MyEnum &#123;//为这个类型天啊及一组附加值 case one(String,Int) case tew case three case Fir,Sec,Thr func des() &#123; switch self &#123; case .one: print(&quot;one&quot;) default: print(&quot;else&quot;) &#125; &#125;&#125;var em = MyEnum.one(&quot;第一个元素&quot;, 1)switch em &#123;//前面的let指定附加值为常量 或者用var指定为变量，括号内为附加值参数名case let .one(param1, param2): print(&quot;One param is \\(param1) and two param is \\(param2).&quot;)default: print(&quot;else&quot;)&#125; Swift中使用struct关键字来进行结构体的创建，结构体的功能和类相似，支持属性与方法，但不同的是，结构体在传递时会被赋值，类的实例则会以引用的方式传递。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"iOS头部渐变的表格视图设计","slug":"200iOS头部渐变的表格视图设计","date":"2016-04-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.339Z","comments":true,"path":"2016/04/26/200iOS头部渐变的表格视图设计/","link":"","permalink":"http://huishao.cc/2016/04/26/200iOS头部渐变的表格视图设计/","excerpt":"","text":"iOS头部渐变的表格视图设计今天再来给大家带来一个开发中常用到的视图控制器，在很多应用中，可能都会遇到这样的一个需求：表视图控制器最上方有一个头图控件，当表格视图滑动在顶部时，导航栏透明，当表格视图逐渐向下滑动时，导航栏渐渐出现，并且在滑动期间，头图会展示相关的渐变动画效果。以前经常会遇到这样的需求，但从没有整理与封装完善，这次将其封装成完整的控件，无论有无导航，都可以很好的支持，方便以后使用也提供给需要的朋友。 在设计控件之前，我们应该先编写控件的头文件，头文件中将控件需要的属性和方法列举，之后再按定义好的接口一步步的来实现控件的编写设计，这样可以结构清晰，并且不会显得无从下手，控件的头文件设计如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//// YHBaseHeaderAnimatedViewController.h// YHBaseFoundationTest//// Created by vip on 16/4/26.// Copyright © 2016年 jaki.zhang. All rights reserved./* * 这个视图控制器创建出带缩放头图效果的视图控制器 * tip： * 1.这个视图控制器如果是被导航push出来的 则内部会使用假导航进行渐隐模拟 * 2.这个视图控制器如果是被present出来的 则不会出现假导航栏 * 3.这个视图控制器中自带一个TableView 设置TableView的头图不会影响原动画效果 * */#import &lt;UIKit/UIKit.h&gt;/** * 这个枚举设置头图动画滑动的速度等级 */typedef enum &#123; YHBaseHeaderAnimatedLevelSlow, YHBaseHeaderAnimatedLevelNormal, YHBaseHeaderAnimatedLevelFast&#125;YHBaseHeaderAnimatedLevel;@interface YHBaseHeaderAnimatedViewController : UIViewController&lt;UITableViewDataSource,UITableViewDelegate&gt;@property(nonatomic,strong,readonly)UITableView * tableView;/** * 设置动画头图图片 */@property(nonatomic,strong)UIView * animatedHeaderView;/** * 设置TableView的头视图 * * 注意：设置tableView的头视图不能够在使用tableHeatherView方法 要使用这个属性设置 * */@property(nonatomic,strong)UIView * tableHeaderView;/** * 设置动画头图高度 * * 这个属性如果不设置或者设置为0 则默认会使用设置的image图片比例 * */@property(nonatomic,assign)CGFloat headerHeight;/** * * 设置动画滑动速率 */@property(nonatomic,assign)YHBaseHeaderAnimatedLevel animatedlevel;/** * * 设置头图可方法的最大scrollView偏移量 默认为40 * */@property(nonatomic,assign)CGFloat maxScrollOffset;/** * 设置是否带渐隐效果 * */@property(nonatomic,assign)BOOL alphaAnimated;/** * 设置最小渐变到的alpha渐隐值 &lt;0 &gt;1之间 默认为0.5 * */@property(nonatomic,assign)CGFloat minAlpha;/** * * 是否显示毛玻璃模糊效果 * */@property(nonatomic,assign)BOOL bluerAnimated;/** * * 设置最大小模糊度 默认为1 * */@property(nonatomic,assign)CGFloat maxBluer;/** * 设置导航栏颜色 默认白色 * */@property(nonatomic,strong)UIColor * naviColor;/** * 设置导航左侧按钮数组 如果不设置 会自动带一个返回按钮 * */@property(nonatomic,strong)NSArray * leftBarButtons;/** * 设置导航左侧按钮数组 如果不设置 会自动带一个返回按钮 * */@property(nonatomic,strong)NSArray * rightBarButtons;/** * 这个方法在修改了头图相关属性后 需要调用刷新 * * 注意：如果重新设置了TableView的tableheaderView属性 也需要调用这个方法刷新 * */-(void)reloadAnimatedView;@end 在设计这个控件时，我主要考虑两个需要优化的地方，第一是这个控制器在不同的场景下可能会有不同的结构，例如在导航结构中被push出来或者通过模态跳转被present出来，我在这个控件的实现时做了兼容，实际上无论有无导航，控件内部都没有使用系统的导航栏，而是模拟实现了一个自定义的导航栏来与系统的导航无缝衔接。 .m文件中实现的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#import &quot;YHBaseHeaderAnimatedViewController.h&quot;@interface YHBaseHeaderAnimatedViewController ()&#123; //承载视图 UIView * _privteBGHeaderView; //宽高比例 CGFloat _privteRate; //原始宽高 CGFloat _privteOriWidth; CGFloat _privteOriHeught; UIVisualEffectView * _blurView; UINavigationBar * _naviBar;&#125;@end@implementation YHBaseHeaderAnimatedViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.edgesForExtendedLayout = UIRectEdgeNone; _tableView = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain]; [self.view addSubview:_tableView]; _tableView.delegate=self; _tableView.dataSource=self; [self YHCreatView]; // Do any additional setup after loading the view.&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;//对导航进行处理-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; if (self.navigationController) &#123; [self.navigationController setNavigationBarHidden:YES animated:YES]; [self showNavigationBar]; &#125;&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; if (self.navigationController) &#123; [self.navigationController setNavigationBarHidden:NO animated:YES]; &#125;&#125;-(void)showNavigationBar&#123; if (_naviBar==nil) &#123; _naviBar = [[UINavigationBar alloc]init]; [self.view addSubview:_naviBar]; _naviBar.frame = CGRectMake(0, 0, self.view.frame.size.width, 64); [_naviBar setBackgroundImage:[UIImage imageNamed:@&quot;clear&quot;] forBarMetrics:UIBarMetricsDefault]; [_naviBar setShadowImage:[UIImage imageNamed:@&quot;clear&quot;]]; _naviBar.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0]; UINavigationItem * item = [[UINavigationItem alloc]initWithTitle:self.title]; _naviBar.items = @[item]; item.leftBarButtonItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;返回&quot; style:UIBarButtonItemStyleDone target:self action:@selector(popToLast)]; &#125; if (self.animatedHeaderView==nil) &#123; _naviBar.hidden=YES; &#125;else&#123; _naviBar.hidden=NO; &#125;&#125;-(void)popToLast&#123; [self.navigationController popViewControllerAnimated:YES];&#125;-(void)YHCreatView&#123; if (self.maxScrollOffset==0) &#123; self.maxScrollOffset=40; &#125; if (self.minAlpha==0) &#123; self.minAlpha = 0.5; &#125; if (self.maxBluer==0) &#123; self.maxBluer = 1; &#125; _privteBGHeaderView = [[UIView alloc]init]; _privteBGHeaderView.backgroundColor = [UIColor clearColor]; self.tableView.backgroundColor = [UIColor clearColor]; _blurView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]]; [self reloadAnimatedView];&#125;-(void)reloadAnimatedView&#123; CGFloat viewH=0; CGFloat aniH=0; for (UIView * view in _privteBGHeaderView.subviews) &#123; [view removeFromSuperview]; &#125; if (self.tableHeaderView) &#123; viewH = viewH+self.tableHeaderView.bounds.size.height; [_privteBGHeaderView addSubview:self.tableHeaderView]; &#125; if (self.animatedHeaderView) &#123; _privteRate = self.animatedHeaderView.frame.size.width/self.animatedHeaderView.frame.size.height; [self.animatedHeaderView addSubview:_blurView]; _blurView.frame= self.animatedHeaderView.bounds; _blurView.alpha=0; _privteOriWidth = self.animatedHeaderView.frame.size.width; _privteOriHeught = self.animatedHeaderView.frame.size.height; if (self.headerHeight!=0) &#123; viewH+=self.headerHeight; aniH = self.headerHeight; &#125;else&#123; viewH+=self.view.frame.size.width/self.animatedHeaderView.bounds.size.width*self.animatedHeaderView.frame.size.height; aniH = self.animatedHeaderView.bounds.size.height; &#125; [self.view insertSubview:self.animatedHeaderView atIndex:0]; &#125; self.tableHeaderView.frame=CGRectMake(0, aniH, self.tableHeaderView.frame.size.width, self.tableHeaderView.frame.size.height); _privteBGHeaderView.frame=CGRectMake(0, 0, self.view.frame.size.width, viewH); self.tableView.tableHeaderView = _privteBGHeaderView;&#125;-(void)setAnimatedHeaderView:(UIView *)animatedHeaderView&#123; if (animatedHeaderView==nil) &#123; if (_animatedHeaderView) &#123; [_animatedHeaderView removeFromSuperview]; &#125; &#125; _animatedHeaderView = animatedHeaderView; &#125;-(void)setMinAlpha:(CGFloat)minAlpha&#123; if (minAlpha&lt;=0) &#123; minAlpha=0.001; &#125; if (minAlpha&gt;=1) &#123; minAlpha=0.999; &#125; _minAlpha=minAlpha;&#125;-(void)setMaxBluer:(CGFloat)maxBluer&#123; if (maxBluer&lt;=0) &#123; maxBluer = 0.001; &#125; if (maxBluer&gt;=1) &#123; maxBluer = 0.999; &#125; _maxBluer = maxBluer;&#125;-(void)setNaviColor:(UIColor *)naviColor&#123; _naviColor = naviColor; _naviBar.backgroundColor = naviColor;&#125;-(void)setLeftBarButtons:(NSArray *)leftBarButtons&#123; _naviBar.topItem.leftBarButtonItems = leftBarButtons; _leftBarButtons = leftBarButtons;&#125;-(void)setRightBarButtons:(NSArray *)rightBarButtons&#123; _naviBar.topItem.rightBarButtonItems = rightBarButtons; _rightBarButtons = rightBarButtons;&#125;-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (self.animatedHeaderView==nil) &#123; return; &#125; if (self.tableView==scrollView) &#123; //获取到偏移量 默认两倍 CGFloat offset = scrollView.contentOffset.y*2; //如果小于0 则进行形变拉伸操作 if (offset&lt;=0) &#123; if (offset&lt;-self.maxScrollOffset*2) &#123; &#125;else&#123; CGFloat height = _privteOriHeught+abs((int)offset); CGFloat width = height*_privteRate; self.animatedHeaderView.frame = CGRectMake(self.view.frame.size.width/2-width/2, offset/2, width, height); &#125; if (_naviBar) &#123; if (_naviBar.shadowImage==nil) &#123; [_naviBar setShadowImage:[UIImage imageNamed:@&quot;clear&quot;]]; &#125; &#125; &#125;else&#123; //如果大于零 进行推出操作 if (self.animatedlevel==YHBaseHeaderAnimatedLevelSlow) &#123; //慢速 self.animatedHeaderView.frame = CGRectMake(0, -offset/8, self.animatedHeaderView.frame.size.width, self.animatedHeaderView.frame.size.height); &#125;else if(self.animatedlevel==YHBaseHeaderAnimatedLevelFast)&#123; //快速 self.animatedHeaderView.frame = CGRectMake(0, -offset/2, self.animatedHeaderView.frame.size.width, self.animatedHeaderView.frame.size.height); &#125;else&#123; //正常 self.animatedHeaderView.frame = CGRectMake(0, -offset/4, self.animatedHeaderView.frame.size.width, self.animatedHeaderView.frame.size.height); &#125; //进行渐隐动画处理 CGFloat tmp = offset/2/_privteOriHeught; if (self.alphaAnimated) &#123; self.animatedHeaderView.alpha = 1-(1-self.minAlpha)*tmp; &#125; //进行模糊动画 if (self.bluerAnimated) &#123; _blurView.alpha = self.maxBluer*tmp; &#125; //进行导航显示 if (_naviBar) &#123; _naviBar.backgroundColor = [_naviBar.backgroundColor colorWithAlphaComponent:tmp]; if (_naviBar.shadowImage) &#123; [_naviBar setShadowImage:nil]; &#125; &#125; &#125; &#125;&#125;@end 在使用时，创建一个视图控制器继承于它，在其viewDidLoad方法中进行一些简单的设置即可，如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //设置头图 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 200)]; imageView.image = [UIImage imageNamed:@&quot;image&quot;]; self.animatedHeaderView = imageView; //设置tableView的头视图 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 30)]; label.backgroundColor = [UIColor purpleColor]; label.textColor = [UIColor whiteColor]; label.textAlignment =NSTextAlignmentCenter; label.text = @&quot;下面进行功能演示&quot;; self.tableHeaderView = label; [self reloadAnimatedView];&#125; 我写了一个完整的演示Demo，Demo中有完整的功能演示，需要的朋友可以自行下载：http://pan.baidu.com/s/1c1VKT00。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"配合LLDB调试器进行iOS代码调试","slug":"199配合LLDB调试器进行iOS代码调试","date":"2016-04-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.338Z","comments":true,"path":"2016/04/24/199配合LLDB调试器进行iOS代码调试/","link":"","permalink":"http://huishao.cc/2016/04/24/199配合LLDB调试器进行iOS代码调试/","excerpt":"","text":"配合LLDB调试器进行iOS代码调试在一款完整iOS移动应用的开发中，代码的调试和编写占着同等重要的地位。Xcode默认使用LLDB作为代码调试器，LLDB功能丰富且强大，恰当的使用它，可以帮助开发者事半功倍的完成代码调试的工作。 1.expression代码执行指令关于LLDB调试器，最常用的指令应该是p与po了，开发者常用这两个命令来进行对象的打印操作，p会打印出对象地址和类型，po则会额外打印出对象的值得内容，实际上，这两个命令都是expression相关命令的简写。expression命令也并非简单的打印命令，实际上它是一个执行代码命令，执行后将返回值进行打印，这个命令有一个十分强大的特点，它可以真实改变程序运行中变量的值。例如在如下代码中的int c = a+b 一行添加一个断点，运行工程。 1234 int a = 0; int b = 1; int c = a+b; NSLog(@&quot;%d&quot;,c); 如果开发者不进行任何认为操作，此时打印出的值应该是1，为了测试，可以在调试区输入如下命令： 1(lldb) expression a=1 此后跳过断点继续运行程序，可以看到打印的结果如下，c变成2。 123(lldb) expression a=1(int) $0 = 12016-04-24 11:39:40.213 BreakPointTest[1010:79065] 2 通过上面的演示，我们发现使用LLDB调试代码十分方便的一个特点，当我们知道程序某个地方可能会出现问题，为了找到解决方法，不使用LLDB时我们可能需要在代码中添加大量的打印函数，并且多次尝试修改源代码才能解决问题，如果使用LLDB的expression命令，我们不仅不需要添加额外的打印代码，也不需要直接修改源代码，在调试区进行多次调试，直到找到正确的修改方法后再对源代码修改一次即可。 2.frame代码堆栈块信息相关指令当Xcode进入断点调试或者遇到异常程序崩溃时，在Xcode左侧的导航区都会将程序运行中的相关堆栈块信息列举出来，例如使用如下测试代码，在text方法中的int c = a+b 一行添加一个断点。 12345678910111213141516171819#import &quot;ViewController.h&quot;@interface ViewController ()&#123; int ab;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ab = 1; [self test]; &#125;-(void)test&#123; int a = 0; int b = 1; int c = a+b; NSLog(@&quot;%d&quot;,c);&#125;@end 当程序运行到断点处断开时，Xcode左侧的堆栈块如下图所示： 从图中可以看出，程序当前处于激活状态的线程有5个，程序目前断在线程1中的test方法堆栈块中，使用frame info指令可以打印当前堆栈块的信息，示例如下： 12(lldb) frame infoframe #0: 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39 在打印的信息中，会有所在的文件名称和函数名称及堆栈块标号和内存地址。 在实际代码调试过程中，程序运行的回溯是一个重要的方法，例如上面的代码例子，虽然现在断点断在test方法中，开发者可能需要在viewDidLoad方法中进行相关调试，例如上面viewDidLoad方法中有一个变量ab，如果想查看ab变量的值，我们就需要将当前选中调试的堆栈块选择为viewDidLoad方法所在的堆栈块，从Xcode左侧导航区可以看到，viewDidLoad方法堆栈块的标号为1，执行如下LLDB指令即可切换： 12345678(lldb) frame select 1frame #1: 0x00000001024978cb BreakPointTest`-[ViewController viewDidLoad](self=0x00007fcd5b413320, _cmd=&quot;viewDidLoad&quot;) + 91 at ViewController.m:31 28 int a = 0; 29 int b = 1; 30 int c = a+b;-&gt; 31 NSLog(@&quot;%d&quot;,c); 32 &#125; 33 @end 从打印信息可以看到，现在选中的调试堆栈块已经切换到viewDidLoad方法，再使用expression指令时就可以操作这个方法中的相关变量了。 在使用LLDB工具前，遇到这样的情况，我往往会采用打多个断点，一步步追溯代码的运行过程并检查过程中变量的值是否正确，调试起来并不十分方便，如果不小心错过了某个断点，又要重新开始，通过选择调试的frame堆栈块可以十分方便的解决这个问题。 与frame相关的还有一个指令十分有用，下面的指令可以打印出当前堆栈块中所有对象的内容： 123456(lldb) frame variable(ViewController *) self = 0x00007fcd5b413320(SEL) _cmd = &quot;test&quot;(int) a = 0(int) b = 1(int) c = 0 variable后面也可以添加参数名来打印特定对象的内容： 12(lldb) frame variable a(int) a = 0 3.thread线程操作相关指令上面提到过，程序运行中会有多个激活的线程，每个线程中又有许多堆栈块，frame相关指令用于综合调试各个堆栈块，thread指令则是用于综合调试各个线程。首先Xcode左侧导航区为我们列出的线程堆栈块并不是当前线程中的所有堆栈块，使用如下命令可以打印出当前线程的所有堆栈块： 123456789101112131415161718192021222324(lldb) thread backtrace* thread #1: tid = 0x152f8, 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 * frame #0: 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39 frame #1: 0x00000001024978cb BreakPointTest`-[ViewController viewDidLoad](self=0x00007fcd5b413320, _cmd=&quot;viewDidLoad&quot;) + 91 at ViewController.m:31 frame #2: 0x0000000103475984 UIKit`-[UIViewController loadViewIfRequired] + 1198 frame #3: 0x0000000103475cd3 UIKit`-[UIViewController view] + 27 frame #4: 0x000000010334bfb4 UIKit`-[UIWindow addRootViewControllerViewIfPossible] + 61 frame #5: 0x000000010334c69d UIKit`-[UIWindow _setHidden:forced:] + 282 frame #6: 0x000000010335e180 UIKit`-[UIWindow makeKeyAndVisible] + 42 frame #7: 0x00000001032d2ed9 UIKit`-[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 4131 frame #8: 0x00000001032d9568 UIKit`-[UIApplication _runWithMainScene:transitionContext:completion:] + 1769 frame #9: 0x00000001032d6714 UIKit`-[UIApplication workspaceDidEndTransaction:] + 188 frame #10: 0x0000000105d438c8 FrontBoardServices`__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 24 frame #11: 0x0000000105d43741 FrontBoardServices`-[FBSSerialQueue _performNext] + 178 frame #12: 0x0000000105d43aca FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + 45 frame #13: 0x0000000102e4a301 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17 frame #14: 0x0000000102e4022c CoreFoundation`__CFRunLoopDoSources0 + 556 frame #15: 0x0000000102e3f6e3 CoreFoundation`__CFRunLoopRun + 867 frame #16: 0x0000000102e3f0f8 CoreFoundation`CFRunLoopRunSpecific + 488 frame #17: 0x00000001032d5f21 UIKit`-[UIApplication _run] + 402 frame #18: 0x00000001032daf09 UIKit`UIApplicationMain + 171 frame #19: 0x0000000102497c3f BreakPointTest`main(argc=1, argv=0x00007fff5d768668) + 111 at main.m:14 frame #20: 0x00000001056fe92d libdyld.dylib`start + 1 frame #21: 0x00000001056fe92d libdyld.dylib`start + 1 thread list指令则可以打印出当前所有激活的线程，如下： 1234567(lldb) thread listProcess 1049 stopped* thread #1: tid = 0x152f8, 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 thread #2: tid = 0x1531b, 0x0000000105a43ee2 libsystem_kernel.dylib`kevent64 + 10, queue = &apos;com.apple.libdispatch-manager&apos; thread #3: tid = 0x1531c, 0x0000000105a435e2 libsystem_kernel.dylib`__workq_kernreturn + 10 thread #4: tid = 0x15324, 0x0000000105a435e2 libsystem_kernel.dylib`__workq_kernreturn + 10 thread #5: tid = 0x15328, 0x0000000105a435e2 libsystem_kernel.dylib`__workq_kernreturn + 10 thread info可以打印出当前选中调试的线程的信息： 12(lldb) thread infothread #1: tid = 0x152f8, 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 同样也可以使用thread select指令来切换选中调试的线程： 1(lldb) thread select 2 thread continue指令用于继续执行当前的线程： 1234(lldb) thread continue2016-04-24 12:29:54.562 BreakPointTest[1049:86776] 1Resuming thread 0x152f8 in process 1049Process 1049 resuming 4.disassemble代码反汇编相关指令disassemble相关指令用于输出某段程序的汇编代码，执行disassemble指令将会反汇编当前函数： 12345678910111213141516171819BreakPointTest`-[ViewController test]: 0x10aab7940 &lt;+0&gt;: pushq %rbp 0x10aab7941 &lt;+1&gt;: movq %rsp, %rbp 0x10aab7944 &lt;+4&gt;: subq $0x20, %rsp 0x10aab7948 &lt;+8&gt;: leaq 0x1711(%rip), %rax ; @&quot;%d&quot; 0x10aab794f &lt;+15&gt;: movq %rdi, -0x8(%rbp) 0x10aab7953 &lt;+19&gt;: movq %rsi, -0x10(%rbp) 0x10aab7957 &lt;+23&gt;: movl $0x0, -0x14(%rbp) 0x10aab795e &lt;+30&gt;: movl $0x1, -0x18(%rbp)-&gt; 0x10aab7965 &lt;+37&gt;: movl -0x14(%rbp), %ecx 0x10aab7968 &lt;+40&gt;: addl -0x18(%rbp), %ecx 0x10aab796b &lt;+43&gt;: movl %ecx, -0x1c(%rbp) 0x10aab796e &lt;+46&gt;: movl -0x1c(%rbp), %esi 0x10aab7971 &lt;+49&gt;: movq %rax, %rdi 0x10aab7974 &lt;+52&gt;: movb $0x0, %al 0x10aab7976 &lt;+54&gt;: callq 0x10aab7c80 ; symbol stub for: NSLog 0x10aab797b &lt;+59&gt;: addq $0x20, %rsp 0x10aab797f &lt;+63&gt;: popq %rbp 0x10aab7980 &lt;+64&gt;: retq 使用disassemble -b则会输出带字节信息的汇编代码： 1234567891011121314151617181920(lldb) disassemble -bBreakPointTest`-[ViewController test]: 0x10aab7940 &lt;+0&gt;: 55 pushq %rbp 0x10aab7941 &lt;+1&gt;: 48 89 e5 movq %rsp, %rbp 0x10aab7944 &lt;+4&gt;: 48 83 ec 20 subq $0x20, %rsp 0x10aab7948 &lt;+8&gt;: 48 8d 05 11 17 00 00 leaq 0x1711(%rip), %rax ; @&quot;%d&quot; 0x10aab794f &lt;+15&gt;: 48 89 7d f8 movq %rdi, -0x8(%rbp) 0x10aab7953 &lt;+19&gt;: 48 89 75 f0 movq %rsi, -0x10(%rbp) 0x10aab7957 &lt;+23&gt;: c7 45 ec 00 00 00 00 movl $0x0, -0x14(%rbp) 0x10aab795e &lt;+30&gt;: c7 45 e8 01 00 00 00 movl $0x1, -0x18(%rbp)-&gt; 0x10aab7965 &lt;+37&gt;: 8b 4d ec movl -0x14(%rbp), %ecx 0x10aab7968 &lt;+40&gt;: 03 4d e8 addl -0x18(%rbp), %ecx 0x10aab796b &lt;+43&gt;: 89 4d e4 movl %ecx, -0x1c(%rbp) 0x10aab796e &lt;+46&gt;: 8b 75 e4 movl -0x1c(%rbp), %esi 0x10aab7971 &lt;+49&gt;: 48 89 c7 movq %rax, %rdi 0x10aab7974 &lt;+52&gt;: b0 00 movb $0x0, %al 0x10aab7976 &lt;+54&gt;: e8 05 03 00 00 callq 0x10aab7c80 ; symbol stub for: NSLog 0x10aab797b &lt;+59&gt;: 48 83 c4 20 addq $0x20, %rsp 0x10aab797f &lt;+63&gt;: 5d popq %rbp 0x10aab7980 &lt;+64&gt;: c3 retq 使用disassemble -c 指令可以设置输出汇编代码的行数，如下： 1234567(lldb) disassemble -c 5BreakPointTest`-[ViewController test]: 0x10aab7940 &lt;+0&gt;: pushq %rbp 0x10aab7941 &lt;+1&gt;: movq %rsp, %rbp 0x10aab7944 &lt;+4&gt;: subq $0x20, %rsp 0x10aab7948 &lt;+8&gt;: leaq 0x1711(%rip), %rax ; @&quot;%d&quot; 0x10aab794f &lt;+15&gt;: movq %rdi, -0x8(%rbp) 使用disassemble -l只输出当前断点处汇编代码： 123456BreakPointTest`-[ViewController test] + 37 at ViewController.m:30 29 int b = 1;-&gt; 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c);BreakPointTest`-[ViewController test]:-&gt; 0x10aab7965 &lt;+37&gt;: movl -0x14(%rbp), %ecx 使用disassemble -m混合显示汇编代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556(lldb) disassemble -mBreakPointTest`-[ViewController test] at ViewController.m:27 26 &#125; 27 -(void)test&#123; 28 int a = 0;BreakPointTest`-[ViewController test]: 0x10aab7940 &lt;+0&gt;: pushq %rbp 0x10aab7941 &lt;+1&gt;: movq %rsp, %rbp 0x10aab7944 &lt;+4&gt;: subq $0x20, %rsp 0x10aab7948 &lt;+8&gt;: leaq 0x1711(%rip), %rax ; @&quot;%d&quot; 0x10aab794f &lt;+15&gt;: movq %rdi, -0x8(%rbp) 0x10aab7953 &lt;+19&gt;: movq %rsi, -0x10(%rbp)BreakPointTest`-[ViewController test] + 23 at ViewController.m:28 27 -(void)test&#123; 28 int a = 0; 29 int b = 1; 0x10aab7957 &lt;+23&gt;: movl $0x0, -0x14(%rbp)BreakPointTest`-[ViewController test] + 30 at ViewController.m:29 28 int a = 0; 29 int b = 1; 30 int c = a+b; 0x10aab795e &lt;+30&gt;: movl $0x1, -0x18(%rbp)BreakPointTest`-[ViewController test] + 37 at ViewController.m:30 29 int b = 1;-&gt; 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c);-&gt; 0x10aab7965 &lt;+37&gt;: movl -0x14(%rbp), %ecxBreakPointTest`-[ViewController test] + 40 at ViewController.m:30 29 int b = 1; 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c); 0x10aab7968 &lt;+40&gt;: addl -0x18(%rbp), %ecxBreakPointTest`-[ViewController test] + 43 at ViewController.m:30 29 int b = 1; 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c); 0x10aab796b &lt;+43&gt;: movl %ecx, -0x1c(%rbp)BreakPointTest`-[ViewController test] + 46 at ViewController.m:31 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c); 32 &#125; 0x10aab796e &lt;+46&gt;: movl -0x1c(%rbp), %esiBreakPointTest`-[ViewController test] + 49 at ViewController.m:31 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c); 32 &#125; 0x10aab7971 &lt;+49&gt;: movq %rax, %rdi 0x10aab7974 &lt;+52&gt;: movb $0x0, %al 0x10aab7976 &lt;+54&gt;: callq 0x10aab7c80 ; symbol stub for: NSLogBreakPointTest`-[ViewController test] + 59 at ViewController.m:32 31 NSLog(@&quot;%d&quot;,c); 32 &#125; 33 @end 0x10aab797b &lt;+59&gt;: addq $0x20, %rsp 0x10aab797f &lt;+63&gt;: popq %rbp 0x10aab7980 &lt;+64&gt;: retq 使用disassemble -p进行当前行的汇编代码输出： 123456(lldb) disassemble -pBreakPointTest`-[ViewController test]:-&gt; 0x10aab7965 &lt;+37&gt;: movl -0x14(%rbp), %ecx 0x10aab7968 &lt;+40&gt;: addl -0x18(%rbp), %ecx 0x10aab796b &lt;+43&gt;: movl %ecx, -0x1c(%rbp) 0x10aab796e &lt;+46&gt;: movl -0x1c(%rbp), %esi 5.其他LLDB常用指令bt指令用于打印当前线程所有堆栈块信息： 123456789101112131415161718192021222324(lldb) bt* thread #1: tid = 0x19f11, 0x000000010aab7965 BreakPointTest`-[ViewController test](self=0x00007fee9c11e330, _cmd=&quot;test&quot;) + 37 at ViewController.m:30, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 * frame #0: 0x000000010aab7965 BreakPointTest`-[ViewController test](self=0x00007fee9c11e330, _cmd=&quot;test&quot;) + 37 at ViewController.m:30 frame #1: 0x000000010aab792b BreakPointTest`-[ViewController viewDidLoad](self=0x00007fee9c11e330, _cmd=&quot;viewDidLoad&quot;) + 91 at ViewController.m:22 frame #2: 0x000000010ba95984 UIKit`-[UIViewController loadViewIfRequired] + 1198 frame #3: 0x000000010ba95cd3 UIKit`-[UIViewController view] + 27 frame #4: 0x000000010b96bfb4 UIKit`-[UIWindow addRootViewControllerViewIfPossible] + 61 frame #5: 0x000000010b96c69d UIKit`-[UIWindow _setHidden:forced:] + 282 frame #6: 0x000000010b97e180 UIKit`-[UIWindow makeKeyAndVisible] + 42 frame #7: 0x000000010b8f2ed9 UIKit`-[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 4131 frame #8: 0x000000010b8f9568 UIKit`-[UIApplication _runWithMainScene:transitionContext:completion:] + 1769 frame #9: 0x000000010b8f6714 UIKit`-[UIApplication workspaceDidEndTransaction:] + 188 frame #10: 0x000000010e3638c8 FrontBoardServices`__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 24 frame #11: 0x000000010e363741 FrontBoardServices`-[FBSSerialQueue _performNext] + 178 frame #12: 0x000000010e363aca FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + 45 frame #13: 0x000000010b46a301 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17 frame #14: 0x000000010b46022c CoreFoundation`__CFRunLoopDoSources0 + 556 frame #15: 0x000000010b45f6e3 CoreFoundation`__CFRunLoopRun + 867 frame #16: 0x000000010b45f0f8 CoreFoundation`CFRunLoopRunSpecific + 488 frame #17: 0x000000010b8f5f21 UIKit`-[UIApplication _run] + 402 frame #18: 0x000000010b8faf09 UIKit`UIApplicationMain + 171 frame #19: 0x000000010aab7c5f BreakPointTest`main(argc=1, argv=0x00007fff55148668) + 111 at main.m:14 frame #20: 0x000000010dd1e92d libdyld.dylib`start + 1 frame #21: 0x000000010dd1e92d libdyld.dylib`start + 1 c指令**继续运行线程和process continue**效果一样。 call指令**运行一个表达式，**和 expression 效果一样。 detach指令**结束当前调试的线程。** di指令**反汇编当前函数与disassemble**相同。 exit指令**退出lldb调试器。** finish指令**完成当前堆栈块的调试，**程序会继续运行。 n指令**进行单步调试，与next**作用一样。 p指令**与expression作用一样。** print指令用于变量的打印。 r指令**重新运行应用程序。** quit指令结束调试。 bugreport指令用于创建堆栈信息报告。 command history指令用于打印LLDB调试命令记录。 help指令用于查询LLDB相关调试指令的用法。 apropo指令用于查询某些包含某些关键字的指令。 version指令用于查询LLDB调试器的版本，如下： 12(lldb) versionlldb-350.0.21.3 image list命令用于打印工程中所有用到的库文件。 image相关指令还有一个十分有用的命令，image lookup --address可以查询某个内存地址的内容，如下： 123(lldb) image lookup --address 0x000000010373e885 Address: CoreFoundation[0x00000000000f4885] (CoreFoundation.__TEXT.__text + 996309) Summary: CoreFoundation`-[__NSArray0 objectAtIndex:] + 101 image lookup --type用于查询某种类型中包含的属性，如下： 123456789101112131415161718192021222324(lldb) image lookup --type UILabelBest match found in /Users/vip/Library/Developer/Xcode/DerivedData/BreakPointTest-cearqrjqbntqcnfgiqzpxhyadewi/Build/Products/Debug-iphonesimulator/BreakPointTest.app/BreakPointTest:id = &#123;0x000082c1&#125;, name = &quot;UILabel&quot;, byte-size = 8, decl = UILabel.h:18, compiler_type = &quot;@interface UILabel : UIView@property ( getter = text,setter = setText:,readwrite,copy,nonatomic ) NSString * text;@property ( getter = font,setter = setFont:,readwrite,nonatomic ) UIFont * font;@property ( getter = textColor,setter = setTextColor:,readwrite,nonatomic ) UIColor * textColor;@property ( getter = shadowColor,setter = setShadowColor:,readwrite,nonatomic ) UIColor * shadowColor;@property ( getter = shadowOffset,setter = setShadowOffset:,assign,readwrite,nonatomic ) CGSize shadowOffset;@property ( getter = textAlignment,setter = setTextAlignment:,assign,readwrite,nonatomic ) NSTextAlignment textAlignment;@property ( getter = lineBreakMode,setter = setLineBreakMode:,assign,readwrite,nonatomic ) NSLineBreakMode lineBreakMode;@property ( getter = attributedText,setter = setAttributedText:,readwrite,copy,nonatomic ) NSAttributedString * attributedText;@property ( getter = highlightedTextColor,setter = setHighlightedTextColor:,readwrite,nonatomic ) UIColor * highlightedTextColor;@property ( getter = isHighlighted,setter = setHighlighted:,assign,readwrite,nonatomic ) BOOL highlighted;@property ( getter = isUserInteractionEnabled,setter = setUserInteractionEnabled:,assign,readwrite,nonatomic ) BOOL userInteractionEnabled;@property ( getter = isEnabled,setter = setEnabled:,assign,readwrite,nonatomic ) BOOL enabled;@property ( getter = numberOfLines,setter = setNumberOfLines:,assign,readwrite,nonatomic ) NSInteger numberOfLines;@property ( getter = adjustsFontSizeToFitWidth,setter = setAdjustsFontSizeToFitWidth:,assign,readwrite,nonatomic ) BOOL adjustsFontSizeToFitWidth;@property ( getter = baselineAdjustment,setter = setBaselineAdjustment:,assign,readwrite,nonatomic ) UIBaselineAdjustment baselineAdjustment;@property ( getter = minimumScaleFactor,setter = setMinimumScaleFactor:,assign,readwrite,nonatomic ) CGFloat minimumScaleFactor;@property ( getter = allowsDefaultTighteningForTruncation,setter = setAllowsDefaultTighteningForTruncation:,assign,readwrite,nonatomic ) BOOL allowsDefaultTighteningForTruncation;@property ( getter = preferredMaxLayoutWidth,setter = setPreferredMaxLayoutWidth:,assign,readwrite,nonatomic ) CGFloat preferredMaxLayoutWidth;@property ( getter = minimumFontSize,setter = setMinimumFontSize:,assign,readwrite,nonatomic ) CGFloat minimumFontSize;@property ( getter = adjustsLetterSpacingToFitWidth,setter = setAdjustsLetterSpacingToFitWidth:,assign,readwrite,nonatomic ) BOOL adjustsLetterSpacingToFitWidth;@end&quot; x指令可以读取某段内存的二进制数据： 123(lldb) x 0x000000010373e8850x10373e885: 66 66 2e 0f 1f 84 00 00 00 00 00 55 48 89 e5 48 ff.........UH..H0x10373e895: 8d 3d 6d f2 28 00 e8 c0 d9 f0 ff 48 89 05 c1 58 .=m.(......H...X LLDB的用法和技巧还有很多，它可以大大提高我们调试代码的效率，有疏漏和错误之处，还望与志同道合的朋友共同学习进步。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"带动画渐进效果与颜色渐变的圆弧进度控件设计","slug":"198带动画渐进效果与颜色渐变的圆弧进度控件设计","date":"2016-04-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.338Z","comments":true,"path":"2016/04/16/198带动画渐进效果与颜色渐变的圆弧进度控件设计/","link":"","permalink":"http://huishao.cc/2016/04/16/198带动画渐进效果与颜色渐变的圆弧进度控件设计/","excerpt":"","text":"带动画渐进效果与颜色渐变的圆弧进度控件设计今天帮朋友写了一个小巧的圆弧进度控件，控件十分简单，主要设计思路采用CAShapeLayer来创建控件圆弧形状，使用CAGradientLayer来进行颜色渐变的渲染，两者结合来创建出颜色渐变的圆弧进度条控件，关于进度动画采用CoreAnimation动画处理。控件进行了简洁的封装，提供了面向使用的接口，需要的朋友可以自取，Demo地址如下： http://pan.baidu.com/s/1gfqDbtp。 控件中主要提供了，改变进度条渐变颜色，圆弧进度条宽度，带动画效果的改变进度，改变进度百分比字体颜色等方法。效果是例如如下： 改变字体颜色 改变进度 改变进度条颜色 改变进度条宽度 控件接口的设计： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &lt;UIKit/UIKit.h&gt;@interface YHBaseCircleView : UIView//==============下面三个渐变色必须全部设置 否则效果可能与预期不同================///** *设置圆弧渐变色的起始色 */@property(nonatomic,strong)UIColor * minLineColor;/** *设置圆弧渐变色的中间色 */@property(nonatomic,strong)UIColor * midLineColor;/** *设置圆弧渐变色的终止色 */@property(nonatomic,strong)UIColor * maxLineColor;/** *设置圆弧背景色 */@property(nonatomic,strong)UIColor * lineTintColor;/** *设置进度 */@property(nonatomic,assign)CGFloat progress;/** *设置线的宽度 max = 20 min = 0.5 */@property(nonatomic,assign)CGFloat lineWidth;/** *设置是否显示百分比标签 */@property(nonatomic,assign)BOOL showTipLabel;/** *设置百分比标签进度颜色 */@property(nonatomic,strong)UIColor * textColor;/** * @brief 设置进度 * * @param progress 进度 取值0-1 * * @param animated 是否显示动画 * */-(void)setProgress:(CGFloat)progress animated:(BOOL)animated;@end 实现方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#import &quot;YHBaseCircleView.h&quot;@implementation YHBaseCircleView&#123; //进度控件内容尺寸 float _contentWidth; float _contentHeight; //形状layer CAShapeLayer * _shapeLayer; //颜色渐变layer CAGradientLayer * _gradLayerR; CAGradientLayer * _gradLayerL; CALayer * _gradLayer; //内容layer CAShapeLayer * _contentLayer; UILabel * _tipLabel; //专门用来更新label NSTimer * _timer; float _oldProgress; //进度新旧进度值 int old; int new;&#125;-(void)awakeFromNib&#123; [self reloadView];&#125;-(instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self reloadView]; &#125; return self;&#125;-(void)reloadView&#123; self.backgroundColor = [UIColor clearColor]; //取设置的frame的最小长或款作为内容区域 _contentWidth = _contentHeight = CGRectGetWidth(self.frame)&gt;CGRectGetHeight(self.frame)?CGRectGetHeight(self.frame):CGRectGetWidth(self.frame); //创建内容layer _contentLayer = [CAShapeLayer layer]; _contentLayer.bounds = CGRectMake(0, 0, _contentWidth, _contentHeight); _contentLayer.position = CGPointMake(_contentWidth/2, _contentHeight/2); _contentLayer.backgroundColor = [UIColor clearColor].CGColor; //进行边界描绘 默认线宽为4px UIBezierPath * pathT = [UIBezierPath bezierPathWithArcCenter:_contentLayer.position radius:_contentWidth/2-2 startAngle:-M_PI_2 endAngle:M_PI_2*3 clockwise:YES]; _contentLayer.path = pathT.CGPath; //默认填充颜色为白色 _contentLayer.fillColor = [UIColor whiteColor].CGColor; _contentLayer.lineWidth = 4; _contentLayer.strokeColor = [UIColor grayColor].CGColor; [self.layer addSublayer:_contentLayer]; _shapeLayer = [CAShapeLayer layer]; _shapeLayer.bounds = CGRectMake(0, 0, _contentWidth, _contentHeight); _shapeLayer.position = CGPointMake(_contentWidth/2, _contentHeight/2); _shapeLayer.backgroundColor = [UIColor clearColor].CGColor;// _shapeLayer.lineCap = kCALineCapRound; //进行边界描绘 默认线宽为4px UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:_shapeLayer.position radius:_contentWidth/2-2 startAngle:-M_PI_2 endAngle:M_PI_2*3 clockwise:YES]; _shapeLayer.path = path.CGPath; _shapeLayer.fillColor = [UIColor clearColor].CGColor; _shapeLayer.lineWidth = 4; _shapeLayer.strokeColor = [UIColor redColor].CGColor; //默认黄转橙转红的边界线 分别由两个gradLayer进行控制 _gradLayer = [CALayer layer]; _gradLayer.bounds = _contentLayer.bounds; _gradLayer.position = _contentLayer.position; _gradLayer.backgroundColor = [UIColor clearColor].CGColor; _gradLayerL = [CAGradientLayer layer]; _gradLayerL.bounds = CGRectMake(0, 0, _contentWidth/2, _contentHeight); _gradLayerL.locations = @[@0.6]; [_gradLayerL setColors:@[(id)[UIColor redColor].CGColor,(id)[UIColor orangeColor].CGColor]]; _gradLayerL.position = CGPointMake(_gradLayerL.bounds.size.width/2, _gradLayerL.bounds.size.height/2); [_gradLayer addSublayer:_gradLayerL]; _gradLayerR = [CAGradientLayer layer]; _gradLayerR.locations = @[@0.6]; _gradLayerR.bounds = CGRectMake(_contentWidth/2, 0, _contentWidth/2, _contentHeight); [_gradLayerR setColors:@[(id)[UIColor yellowColor].CGColor,(id)[UIColor orangeColor].CGColor]]; _gradLayerR.position = CGPointMake(_gradLayerR.bounds.size.width/2+_contentWidth/2, _gradLayerR.bounds.size.height/2); [_gradLayer addSublayer:_gradLayerR]; [_gradLayer setMask:_shapeLayer]; [_contentLayer addSublayer:_gradLayer]; //setter方法初始化 _minLineColor = [UIColor yellowColor]; _midLineColor = [UIColor orangeColor]; _maxLineColor = [UIColor redColor]; _lineTintColor = [UIColor grayColor]; _progress = 1; _lineWidth = 4; _lineTintColor = [UIColor grayColor]; _textColor = [UIColor orangeColor]; _oldProgress = 1; //创建tiplabel [self creatTipLabel]; _timer = [NSTimer scheduledTimerWithTimeInterval:1/60.0 target:self selector:@selector(updateLabel) userInfo:nil repeats:YES]; _timer.fireDate = [NSDate distantFuture]; &#125;-(void)removeFromSuperview&#123; _timer.fireDate = [NSDate distantFuture]; [_timer invalidate]; _timer =nil; [super removeFromSuperview];&#125;-(void)updateLabel&#123; if (old&lt;new) &#123; old++; NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%d%%&quot;,old]]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:22] range:NSMakeRange(0, attri.length-1)]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(attri.length-1, 1)]; [attri addAttribute:NSForegroundColorAttributeName value:_textColor range:NSMakeRange(0, attri.length)]; _tipLabel.attributedText = attri; &#125;else if (old&gt;new)&#123; old--; NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%d%%&quot;,old]]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:22] range:NSMakeRange(0, attri.length-1)]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(attri.length-1, 1)]; [attri addAttribute:NSForegroundColorAttributeName value:_textColor range:NSMakeRange(0, attri.length)]; _tipLabel.attributedText = attri; &#125;else&#123; _timer.fireDate = [NSDate distantFuture]; &#125;&#125;-(void)setMinLineColor:(UIColor *)minLineColor&#123; _minLineColor = minLineColor; [_gradLayerR setColors:@[(id)_minLineColor.CGColor,(id)_midLineColor.CGColor]]; [_gradLayerL setColors:@[(id)_maxLineColor.CGColor,(id)_midLineColor.CGColor]];&#125;-(void)setMidLineColor:(UIColor *)midLineColor&#123; _midLineColor = midLineColor; [_gradLayerR setColors:@[(id)_minLineColor.CGColor,(id)_midLineColor.CGColor]]; [_gradLayerL setColors:@[(id)_maxLineColor.CGColor,(id)_midLineColor.CGColor]];&#125;-(void)setMaxLineColor:(UIColor *)maxLineColor&#123; _maxLineColor = maxLineColor; [_gradLayerR setColors:@[(id)_minLineColor.CGColor,(id)_midLineColor.CGColor]]; [_gradLayerL setColors:@[(id)_maxLineColor.CGColor,(id)_midLineColor.CGColor]];&#125;-(void)setTintColor:(UIColor *)tintColor&#123; _lineTintColor = tintColor; _contentLayer.strokeColor = tintColor.CGColor;&#125;-(void)setProgress:(CGFloat)progress&#123; _oldProgress = _progress; _progress=progress; _shapeLayer.strokeStart = 0; _shapeLayer.strokeEnd = progress&gt;1?1:progress; NSMutableAttributedString * attri ; if (progress==1) &#123; attri = [[NSMutableAttributedString alloc]initWithString:@&quot;100%&quot;]; &#125;else&#123; attri = [[NSMutableAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%2d%%&quot;,(int)(progress*100)]]; &#125; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:22] range:NSMakeRange(0, attri.length-1)]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(attri.length-1, 1)]; [attri addAttribute:NSForegroundColorAttributeName value:_textColor range:NSMakeRange(0, attri.length)]; _tipLabel.attributedText = attri;&#125;-(void)setProgress:(CGFloat)progress animated:(BOOL)animated&#123; _oldProgress = _progress; _progress = progress; old = (int)(_oldProgress*100); new = (int)(_progress*100); CABasicAnimation * ani = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;]; ani.toValue = progress&gt;1?@1:@(progress); ani.duration = 0.3; ani.delegate=self; ani.fillMode=kCAFillModeForwards; ani.removedOnCompletion=NO; [_shapeLayer addAnimation:ani forKey:nil]; _timer.fireDate = [NSDate distantPast]; &#125;- (void)dealloc&#123; &#125;-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; if (flag) &#123; [_shapeLayer removeAllAnimations]; _shapeLayer.strokeEnd = _progress&gt;1?1:_progress; &#125;&#125;-(void)setLineWidth:(CGFloat)lineWidth&#123; if (lineWidth&lt;0.5) &#123; lineWidth=0.5; &#125; if (lineWidth&gt;20) &#123; lineWidth = 20; &#125; _lineWidth = lineWidth; UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:_shapeLayer.position radius:_contentWidth/2-lineWidth/2 startAngle:-M_PI_2 endAngle:M_PI_2*3 clockwise:YES]; _shapeLayer.path = path.CGPath; _shapeLayer.fillColor = [UIColor clearColor].CGColor; _shapeLayer.lineWidth = lineWidth; _shapeLayer.strokeColor = [UIColor redColor].CGColor; [_gradLayer setMask:_shapeLayer]; UIBezierPath * pathT = [UIBezierPath bezierPathWithArcCenter:_contentLayer.position radius:_contentWidth/2-lineWidth/2 startAngle:-M_PI_2 endAngle:M_PI_2*3 clockwise:YES]; _contentLayer.path = pathT.CGPath; _contentLayer.lineWidth = lineWidth;&#125;-(void)setTextColor:(UIColor *)textColor&#123; _textColor = textColor; NSMutableAttributedString * attr = [[NSMutableAttributedString alloc]initWithAttributedString:_tipLabel.attributedText]; [attr addAttribute:NSForegroundColorAttributeName value:textColor range:NSMakeRange(0, attr.length)]; _tipLabel.attributedText = attr;&#125;-(void)creatTipLabel&#123; _tipLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, sqrt(2)/2*(_contentWidth-_lineWidth*2), sqrt(2)/2*(_contentWidth-_lineWidth*2))]; _tipLabel.center = CGPointMake(self.frame.size.width/2, self.frame.size.height/2); _tipLabel.backgroundColor = [UIColor clearColor]; _tipLabel.textAlignment = NSTextAlignmentCenter; NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:@&quot;100%&quot;]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:22] range:NSMakeRange(0, 3)]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(3, 1)]; [attri addAttribute:NSForegroundColorAttributeName value:[UIColor orangeColor] range:NSMakeRange(0, 4)]; _tipLabel.attributedText = attri; [self addSubview:_tipLabel];&#125;@end 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Swift中构造方法的解析","slug":"197Swift中构造方法的解析","date":"2016-04-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.338Z","comments":true,"path":"2016/04/15/197Swift中构造方法的解析/","link":"","permalink":"http://huishao.cc/2016/04/15/197Swift中构造方法的解析/","excerpt":"","text":"Swift中构造方法的解析一、引言构造方法是一个类创建对象最先也是必须调用的方法，在Objective-C中，开发者更习惯称这类方法为初始化方法。在Objective-C中的初始化方法与普通函数相比除了要以init抬头外并无太严格的分界，而在Swift语言体系中，构造方法与普通的方法分界十分严格，从格式写法上就有不同，普通方法函数要以func声明，构造方法统一为init命名，不需要func关键字声明，不同的构造方法采用方法重载的方式创建。 二、构造方法的复写与重载在Objective-C中，不同的初始化方法就是不同的函数，这便不存在方法重载的概念。Swift中要创建自定义的构造方法，需要开发者对init构造方法进行重载操作。任何一个自定义的类，只要其有父类，除了可以继承下来父类已有的构造方法外，还可以复写父类的构造方法，使其适用于自身。和Objective-C类似，复写父类的构造方法时，要在其中调用父类的构造方法，重载可以理解为一种特殊的复写父类构造方法，因此在重载的构造方法中也要调用父类的构造方法。 创建一个继承于NSObject的类，复写构造方法，代码示例如下： 12345678910111213141516171819202122232425class ClassOne: NSObject &#123; //声明一个本类特有的常量 var tip:Int //复写父类的构造方法 需要用override关键字 override init() &#123; //构造方法中要对所有成员常量完成创建 tip = 1; //在创建完所有成员常量后 调用父类构造方法 super.init() &#125; //重载构造方法1 init(one:Int)&#123; tip=one super.init() &#125; //重载构造方法2 使用convenience关键字进行修饰 convenience init(two:String) &#123; //使用convenience关键字进行修饰的构造方法要调用本类的构造方法进行 self.init(one: two.characters.count) &#125; //重载构造方法3 使用required关键字进行修饰 使用required关键字进行修饰的构造方法子类必须继承或复写 required init(three:Float) &#123; tip=10 super.init() &#125; 上面示例代码中，不带参数的init()方法为复写父类的方法，因此需要使用关键字override来修饰。重载构造方法1带一个Int类型的 参数，父类中并没有这个构造方法，但是在其实现中，依然需要调用父类中的某个构造方法完成。构造方法2是一个带String类型参数的构造方法，其用convenience关键字为构造方法的一个修饰关键字，后面会介绍。构造方法3为一个带Float类型参数的构造方法，但其使用required关键字进行了修饰，使用required关键字进行修饰的构造方法子类必须继承或者复写。构造方法1，2，3都是对init()构造方法的一种重载，但却是3中类型全然不同的构造方法。 三、Designated构造方法与Convenience构造方法Swift中的构造方法分为Designated构造方法与Convenience构造方法两类，Designated构造方法也被称为指定构造方法，Convenience构造方法也被称为方便构造方法。Designated构造方法不加任何修饰关键字，Convenience构造方法需要使用Convenience关键字进行修饰。可以这样理解，Convenience类型的构造方法是为了方便使用从Designated构造方法中分支出来的构造方法，官方文档中有如下描述： 1.子类Designated构造方法中必须调用父类的Designated构造方法。 2.Convenience构造方法中必须调用当前类的构造方法。 3.Convenience构造方法归根结底要调用到Designated构造方法。 官方文档的一张图可以清晰的描述上述关系： 四、构造方法的继承关系关于子类继承父类的构造方法有这样几个特性： 1.如果子类没有复写任何父类的构造方法，则默认子类将继承所有父类的构造方法，包括Designated构造方法与Convenience构造方法。 2.如果子类复写了父类某一构造方法，则子类默认不在继承所有父类的构造方法，对于Designated类型的构造方法，子类复写了哪些，哪些才能够被使用，对于Convenienve类型的构造方法，子类复写的其调用的Designated构造方法后会被自动继承。 3.如果父类中的构造方法是required修饰的，则子类必须进行继承或复写。 曾经有朋友和我抱怨，Objective-C中的继承是一种十分不人性，它强制子类继承所有父类的方法与属性无论子类是否需要，分析上面的一些规则可以发现，Swift与Objective-C相比，在构造方法方面语法会更加严格，这样做在编程上更加安全。在Objective-C中，子类将被强制继承所有父类的初始化方法，这样开发者在使用时常常会出现疑惑，有时一个子类往往有特定的初始化方法，仅仅通过父类的初始化方法不能够正确的完成初始化，在编程时，往往需要特殊注释来提示开发者。Swift设定的这些构造方法原则可以将无关的父类构造方法剔除在外，在编程时更加严格安全，减少疑惑与不可控因素。 五、构造方法的实现原则无论Designated类型的构造方法还是Convenience类型的构造方法，只要其有父类，最终都要实现父类的Designated构造方法。Swift语言要求，在构造方法中要完成所有成员常量或者变量的构造或赋值(optional值除外)。在对成员常量或变量进行构造赋值时，要在调用父类的初始化方法之前，这里还有一点需要注意，父类的成员属性也会被子类继承，如果要在子类复写的父类方法中对继承来的父类成员属性进行重新构造或赋值，则必须在调用父类构造方法之后，例如创建ClassTwo类继承于ClassOne，复写方法如下： 123456789101112131415161718class ClassTwo: ClassOne &#123; //子类自己的属性 let tipTwo:Int override init() &#123; //调用父类构造方法前进行自己属性的构造 tipTwo = 1 //调用父类构造方法 super.init() //对从父类继承来的属性进行重构造 tip = 1000; &#125; required init(three: Float) &#123; fatalError(&quot;init(three:) has not been implemented&quot;) &#125; &#125; Swift语言这种强制化得构造规则，能够保证一个类在完成构造时，其内部的所有属性都构造完成。在使用Objective-C进行开发时，很多初学者都可能会遇到这样一种情况，完成了某个类的初始化，但向类的属性进行赋值时却没有成功，因为Objective-C中并没有这样的语法，在类初始化成功后，其属性是否初始化了完全取决于开发者，Swift优化了这一设计。 综上可以了解，Swift语言虽然更加严格，却将更多本来需要开发者注意的地方交由了编译器，实际上是减轻了开发者的负担。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"Mac修改主机host地址","slug":"195Mac修改主机host地址","date":"2016-04-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.337Z","comments":true,"path":"2016/04/13/195Mac修改主机host地址/","link":"","permalink":"http://huishao.cc/2016/04/13/195Mac修改主机host地址/","excerpt":"","text":"Mac修改主机host地址在终端键入如下命令： 1vim /etc/hosts 如果提示没有操作权限，使用如下命令： 1sudo vim /etc/hosts 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"Mac系统Git生成ssh公钥","slug":"196Mac系统Git生成ssh公钥","date":"2016-04-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.337Z","comments":true,"path":"2016/04/13/196Mac系统Git生成ssh公钥/","link":"","permalink":"http://huishao.cc/2016/04/13/196Mac系统Git生成ssh公钥/","excerpt":"","text":"Mac系统Git生成ssh公钥在使用Git仓库进行代码管理时，新的电脑上往往需要生成ssh公钥进行匹配，Mac系统生成Git公钥过程如下： 1.检查本机是否已有公钥 在终端中输入如下命令： 1$ cd ~/.ssh 2.如果电脑中有以前遗留的密钥，将其删除掉 使用如下命令： 123$ mkdir key_backup$ cp id_rsa* key_backup$ rm id_rsa* 3.生成新的公钥 终端中输入如下命令 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 之后终端会提示几次密码设置，如果设置了密码，在向Git仓库进行代码交互操作时需要键入密码，也可以全部回车带过，表示不需要密码。 4.向Git仓库中导入公钥 在.ssh文件夹下使用ls命令查看所有文件，可以看到生成了一个id_rsa.pub的文件，使用vi工具打开它，将其内容复制出来，在Git仓库中新建公钥，复制上去即可。例如github中导入密钥过程如下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法","slug":"194Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法","date":"2016-04-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.337Z","comments":true,"path":"2016/04/12/194Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法/","link":"","permalink":"http://huishao.cc/2016/04/12/194Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法/","excerpt":"","text":"Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法 在iOS开发中，如果使用到了storyboard与xib文件并且使用autolayout进行自动布局，有时会报出Automatic Preferred Max Layout Width before iOS8.0的警告。工程中如果兼容的iOS版本为iOS8.0一下，并且使用了多行UILabel控件，往往在autolayout自动布局时会出现上述警告，上述警告的主要原因是在iOS8.0后系统会自动计算多行UILabel控件的理想换行宽度，iOS8以下则不会，需要开发者手动设置一个确定的值。 解决方案如下，找到xib或storyboard中的多行UILabel控件，勾选Explicit属性，设置为一个固定的值，例如0。如下图所示： 之后上述警告即可消除，事实上，使用了autolayout后，这个属性并没有任何效果，仅仅为了消除警告，直接设置为0即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"iOS剪切板UIPasteboard开发应用解析","slug":"192iOS剪切板UIPasteboard开发应用解析","date":"2016-04-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.337Z","comments":true,"path":"2016/04/06/192iOS剪切板UIPasteboard开发应用解析/","link":"","permalink":"http://huishao.cc/2016/04/06/192iOS剪切板UIPasteboard开发应用解析/","excerpt":"","text":"iOS剪切板UIPasteboard开发应用解析一、自带剪切板操作的原生UI控件 在iOS的UI系统中，有3个控件自带剪切板操作，分别是UITextField、UITextView与UIWebView。在这些控件的文字交互处进行长按手势可以在屏幕视图上唤出系统的剪切板控件，用户可以进行复制、粘贴，剪切等操作，其效果分别如下图所示。 UITextField的文字操作 UITextView的文字操作 UIWebView的文字操作 二、系统的剪切板管理类UIPasteboard 实际上，当用户通过上面的空间进行复制、剪切等操作时，被选中的内容会被存放到系统的剪切板中，并且这个剪切板并不只能存放字符串数据，其还可以进行图片数据与网址URL数据的存放。这个剪切板就是UIPasteboard类，开发者也可以直接通过它来操作数据进行应用内或应用间传值。 UIPasteboard类有3个初始化方法，如下： 123456//获取系统级别的剪切板+ (UIPasteboard *)generalPasteboard;//获取一个自定义的剪切板 name参数为此剪切板的名称 create参数用于设置当这个剪切板不存在时 是否进行创建+ (nullable UIPasteboard *)pasteboardWithName:(NSString *)pasteboardName create:(BOOL)create;//获取一个应用内可用的剪切板+ (UIPasteboard *)pasteboardWithUniqueName; 上面3个初始化方法，分别获取或创建3个级别不同的剪切板，系统级别的剪切板在整个设备中共享，即是应用程序被删掉，其向系统级的剪切板中写入的数据依然在。自定义的剪切板通过一个特定的名称字符串进行创建，它在应用程序内或者同一开发者开发的其他应用程序中可以进行数据共享。第3个方法创建的剪切板等价为使用第2个方法创建的剪切板，只是其名称字符串为nil，它通常用于当前应用内部。 注意：使用第3个方法创建的剪切板默认是不进行数据持久化的，及当应用程序退出后，剪切板中内容将别抹去。若要实现持久化，需要设置persistent属性为YES。 UIPasteboard中常用方法及属性如下： 12345678//剪切板的名称@property(readonly,nonatomic) NSString *name;//根据名称删除一个剪切板+ (void)removePasteboardWithName:(NSString *)pasteboardName;//是否进行持久化@property(getter=isPersistent,nonatomic) BOOL persistent;//此剪切板的改变次数 系统级别的剪切板只有当设备重新启动时 这个值才会清零@property(readonly,nonatomic) NSInteger changeCount; 下面这些方法用于设置与获取剪切板中的数据： 最新一组数据对象的存取： 123456789101112//获取剪切板中最新数据的类型- (NSArray&lt;NSString *&gt; *)pasteboardTypes;//获取剪切板中最新数据对象是否包含某一类型的数据- (BOOL)containsPasteboardTypes:(NSArray&lt;NSString *&gt; *)pasteboardTypes;//将剪切板中最新数据对象某一类型的数据取出- (nullable NSData *)dataForPasteboardType:(NSString *)pasteboardType;//将剪切板中最新数据对象某一类型的值取出- (nullable id)valueForPasteboardType:(NSString *)pasteboardType;//为剪切板中最新数据对应的某一数据类型设置值- (void)setValue:(id)value forPasteboardType:(NSString *)pasteboardType;//为剪切板中最新数据对应的某一数据类型设置数据- (void)setData:(NSData *)data forPasteboardType:(NSString *)pasteboardType; 多组数据对象的存取： 12345678910111213141516//数据组数@property(readonly,nonatomic) NSInteger numberOfItems;//获取一组数据对象包含的数据类型- (nullable NSArray *)pasteboardTypesForItemSet:(nullable NSIndexSet*)itemSet;//获取一组数据对象中是否包含某些数据类型- (BOOL)containsPasteboardTypes:(NSArray&lt;NSString *&gt; *)pasteboardTypes inItemSet:(nullable NSIndexSet *)itemSet;//根据数据类型获取一组数据对象- (nullable NSIndexSet *)itemSetWithPasteboardTypes:(NSArray *)pasteboardTypes;//根据数据类型获取一组数据的值- (nullable NSArray *)valuesForPasteboardType:(NSString *)pasteboardType inItemSet:(nullable NSIndexSet *)itemSet;//根据数据类型获取一组数据的NSData数据- (nullable NSArray *)dataForPasteboardType:(NSString *)pasteboardType inItemSet:(nullable NSIndexSet *)itemSet;//所有数据对象@property(nonatomic,copy) NSArray *items;//添加一组数据对象- (void)addItems:(NSArray&lt;NSDictionary&lt;NSString *, id&gt; *&gt; *)items; 上面方法中很多需要传入数据类型参数，这些参数是系统定义好的一些字符窜，如下： 12345678//所有字符串类型数据的类型定义字符串数组UIKIT_EXTERN NSArray&lt;NSString *&gt; *UIPasteboardTypeListString;//所有URL类型数据的类型定义字符串数组UIKIT_EXTERN NSArray&lt;NSString *&gt; *UIPasteboardTypeListURL;//所有图片数据的类型定义字符串数据UIKIT_EXTERN NSArray&lt;NSString *&gt; *UIPasteboardTypeListImage;//所有颜色数据的类型定义字符串数组UIKIT_EXTERN NSArray&lt;NSString *&gt; *UIPasteboardTypeListColor; 相比于上面两组方法，下面这些方法更加面向对象，在开发中使用更加方便与快捷： 12345678910111213141516//获取或设置剪切板中的字符串数据@property(nullable,nonatomic,copy) NSString *string;//获取或设置剪切板中的字符串数组@property(nullable,nonatomic,copy) NSArray&lt;NSString *&gt; *strings;//获取或设置剪切板中的URL数据@property(nullable,nonatomic,copy) NSURL *URL;//获取或设置剪切板中的URL数组@property(nullable,nonatomic,copy) NSArray&lt;NSURL *&gt; *URLs;//获取或s何止剪切板中的图片数据@property(nullable,nonatomic,copy) UIImage *image;//获取或设置剪切板中的图片数组@property(nullable,nonatomic,copy) NSArray&lt;UIImage *&gt; *images;//获取或设置剪切板中的颜色数据@property(nullable,nonatomic,copy) UIColor *color;//获取或设置剪切板中的颜色数组@property(nullable,nonatomic,copy) NSArray&lt;UIColor *&gt; *colors; 对剪切板的某些操作会触发如下通知： 12345678//剪切板内容发生变化时发送的通知UIKIT_EXTERN NSString *const UIPasteboardChangedNotification;//剪切板数据类型键值增加时发送的通知UIKIT_EXTERN NSString *const UIPasteboardChangedTypesAddedKey;//剪切板数据类型键值移除时发送的通知UIKIT_EXTERN NSString *const UIPasteboardChangedTypesRemovedKey;//剪切板被删除时发送的通知UIKIT_EXTERN NSString *const UIPasteboardRemovedNotification; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS系统菜单控制器UIMenuController使用简介","slug":"193iOS系统菜单控制器UIMenuController使用简介","date":"2016-04-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.337Z","comments":true,"path":"2016/04/06/193iOS系统菜单控制器UIMenuController使用简介/","link":"","permalink":"http://huishao.cc/2016/04/06/193iOS系统菜单控制器UIMenuController使用简介/","excerpt":"","text":"iOS系统菜单控制器UIMenuController使用简介一、引言 在许多iOS应用中，当用户进行某文字或图片区域的长按操作时，都会弹出一个系统菜单控件，用户可以通过操作菜单控件上的按钮进行数据的复制、剪切、粘贴等操作。系统原生的某些控件已经支持了对UIMenuController的唤出操作，然而并不是所有控件都支持，开发者可以通过自定义UIMenuController来更加灵活的使用菜单控件，在前面博客中有介绍iOS剪切板相关知识，地址如下： iOS剪切板UIPasteboard使用简介：http://my.oschina.net/u/2340880/blog/653228。 二、UIMenuController的使用 UIMenuController的展现需要基于一个View视图，其交互则需要基于其所在View视图的Responder。举例来说，如果一个UIMenuController展现在当前ViewController的View上，则此UIMenuController的交互逻辑交由当前的ViewController进行管理。 在界面展示出UIMenuController需要3个条件： 1.当前的Responder处于第一响应。 2.UIMenuController对象调用menuVisible方法。 3.当前的Responder实现了如下两个方法： 12345678//是否可以成为第一相应-(BOOL)canBecomeFirstResponder&#123; return YES;&#125;//是否可以接收某些菜单的某些交互操作-(BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; return YES;&#125; 实现了上面的两个方法，使用如下的代码可以唤出UIMenuController控件： 12345 [self becomeFirstResponder]; //设置菜单显示的位置 frame设置其文职 inView设置其所在的视图 [[UIMenuController sharedMenuController] setTargetRect:frame inView:self.view]; //将菜单控件设置为可见 [UIMenuController sharedMenuController].menuVisible = YES; 在执行了上面的代码后，系统第一次调用canperformAction:withSender:方法会进行是否显示菜单栏的检测，如果返回为NO，则不能显示菜单栏，如果返回为YES，之后系统会多次调用canPerformAction:withSender:方法，用于检测当前Responder对象是否实现了菜单栏上某个选项的触发方法，如果实现了，菜单栏上面的相应按钮会显示，否则不会显示。开发者可以在这个方法中通过判断action来确定菜单控件中显示的按钮种类。系统默认为开发者提供了一系列的菜单按钮，例如要显示剪切和赋值操作的菜单按钮，示例代码如下： 123456-(BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if (action == @selector(cut:)||action == @selector(copy:)) &#123; return YES; &#125; return NO;&#125; 效果如下图所示： 系统默认支持提供的按钮触发方法列举如下： 12345678910111213141516//剪切按钮的方法- (void)cut:(nullable id)sender NS_AVAILABLE_IOS(3_0);//复制按钮的方法- (void)copy:(nullable id)sender NS_AVAILABLE_IOS(3_0);//粘贴按钮的方法- (void)paste:(nullable id)sender NS_AVAILABLE_IOS(3_0);//选择按钮的方法- (void)select:(nullable id)sender NS_AVAILABLE_IOS(3_0);//全选按钮的方法- (void)selectAll:(nullable id)sender NS_AVAILABLE_IOS(3_0);//删除按钮的方法- (void)delete:(nullable id)sender NS_AVAILABLE_IOS(3_2);//改变书写模式为从左向右按钮触发的方法- (void)makeTextWritingDirectionLeftToRight:(nullable id)sender NS_AVAILABLE_IOS(5_0);//改变书写模式为从右向左按钮触发的方法- (void)makeTextWritingDirectionRightToLeft:(nullable id)sender NS_AVAILABLE_IOS(5_0); 上面所列举的方法声明在UIResponder头文件中，实际上，除了上面的方法，关于UIMenuController上面的按钮，系统中还有许多私有方法，列举如下： 12345678910111213141516171819202122232425262728293031323334//替换按钮- (void)_promptForReplace:(id)arg1&#123; NSLog(@&quot;promptForReplace&quot;);&#125;//简体繁体转换按钮-(void)_transliterateChinese:(id)sender&#123; NSLog(@&quot;transliterateChinese&quot;);&#125;//文字风格按钮-(void)_showTextStyleOptions:(id)sender&#123; NSLog(@&quot;showTextStyleOptions&quot;);&#125;//定义按钮-(void)_define:(id)sender&#123; NSLog(@&quot;define&quot;);&#125;-(void)_addShortcut:(id)sender&#123; NSLog(@&quot;addShortcut&quot;);&#125;-(void)_accessibilitySpeak:(id)sender&#123; NSLog(@&quot;accessibilitySpeak&quot;);&#125;//语言选择按钮-(void)_accessibilitySpeakLanguageSelection:(id)sender&#123; NSLog(@&quot;accessibilitySpeakLanguageSelection&quot;);&#125;//暂停发音按钮-(void)_accessibilityPauseSpeaking:(id)sender&#123; NSLog(@&quot;accessibilityPauseSpeaking&quot;);&#125;//分享按钮-(void)_share:(id)sender&#123; NSLog(@&quot;share&quot;);&#125; 在实际开发中，开发这完全不需要使用这些私有的方法，UIMenuItem类提供给开发者进行自定义菜单按钮与触发方法，示例如下： 12345[self becomeFirstResponder]; UIMenuItem * item = [[UIMenuItem alloc]initWithTitle:@&quot;自定义&quot; action:@selector(newFunc)]; [[UIMenuController sharedMenuController] setTargetRect:[sender frame] inView:self.view]; [UIMenuController sharedMenuController].menuItems = @[item]; [UIMenuController sharedMenuController].menuVisible = YES; 123456789101112-(BOOL)canBecomeFirstResponder&#123; return YES;&#125;-(BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if (action == @selector(newFunc)) &#123; return YES; &#125; return NO;&#125;-(void)newFunc&#123; NSLog(@&quot;自定义方法&quot;);&#125; 效果如下图所示： UIMenuController还有如下的属性用来设置其显示的位置： 1234567891011121314151617//显示的位置@property(nonatomic) UIMenuControllerArrowDirection arrowDirection;//枚举如下：/*typedef NS_ENUM(NSInteger, UIMenuControllerArrowDirection) &#123; //默认 基于当前屏幕状态 UIMenuControllerArrowDefault, // up or down based on screen location //箭头在上的显示模式 UIMenuControllerArrowUp NS_ENUM_AVAILABLE_IOS(3_2), //箭头在下的显示模式 UIMenuControllerArrowDown NS_ENUM_AVAILABLE_IOS(3_2), //箭头在左的显示模式 UIMenuControllerArrowLeft NS_ENUM_AVAILABLE_IOS(3_2), //箭头在右的显示模式 UIMenuControllerArrowRight NS_ENUM_AVAILABLE_IOS(3_2),&#125;;*/ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中动态更新补丁策略JSPatch运用基础二","slug":"191iOS中动态更新补丁策略JSPatch运用基础二","date":"2016-03-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.336Z","comments":true,"path":"2016/03/30/191iOS中动态更新补丁策略JSPatch运用基础二/","link":"","permalink":"http://huishao.cc/2016/03/30/191iOS中动态更新补丁策略JSPatch运用基础二/","excerpt":"","text":"iOS中动态更新补丁策略JSPatch运用基础二一、引言上篇博客中介绍了iOS开发中JSPatch引擎进行动态热修复的一些基础功能，其中包括向Objective-C类中添加类方法与成员方法、添加临时成员变量，使用JavaScript调用原生的Objective-C属性和方法等。本篇博客将基于上一篇继续介绍Objective-C中的一些特殊数据类型在JavaScript文件中的使用方法，博客中大部分内容扩展自JSPatch开源git的wiki：[https://github.com/bang590/JSPatch](https://github.com/bang590/JSPatch)。 iOS中动态更新补丁策略JSPatch运用基础一：http://my.oschina.net/u/2340880/blog/646688。 二、JavaScript与Objective-C交互的几种常用类型1.结构体在Objective-C代码中，我们经常会使用到结构体，JSPatch中原生支持的结构体有如下几种：CGPoint，CGSize，CGRect，NSRange。并且这几种结构体在进行界面操作时也会经常使用到。 对于CGRect类型，JavaScript使用如下代码创建： 12 var view = require(&apos;UIView&apos;).alloc().init() view.setFrame(&#123;x:100,y:100,width:100,height:100&#125;) 对于CGPoint类型，JavaScript使用如下代码创建： 1 view.setCenter(&#123;x:200,y:200&#125;) 对于CGSize类型，JavaScript使用如下代码创建： 12 var size = &#123;width:200,height:200&#125; view.setFrame(&#123;x:100,y:100,width:size.width,height:size.height&#125;) 对于NSRange类型，JavaScript使用如下代码创建： 1 var range = &#123;location: 0, length: 1&#125; 2.选择器Selector对于Objective-C中的方法选择器Selector，在JavaScript中使用字符串的形式创建，例如： 1self.performSelector_withObject(&quot;func:&quot;, 1) 3.关于空对象在JavaScript中，null与undefined都对应于Objective-C中的nil，Objective-C中的NSNull空对象，在JavaScript中使用nsnull来代替。 4.在Objective-C与JavaScript中进行block的交互 在JavaScript与Objective-C进行block交互有两种方式，一种是在JavaScript文件中调用Objective-C中的block，一种是将JavaScript文件中的函数块作为block参数传递给Objective-C。 在JavaScript文件中使用Objective-C中的block十分简单，因为JavaScript中没有block的概念，Objective-C会被自动转换为函数，示例如下： Objective-C： 123456789typedef void(^block)(NSString * str);@interface ViewController ()@end@implementation ViewController-(block)getBlock&#123; block block = ^(NSString * str)&#123;NSLog(@&quot;%@&quot;,str);&#125;; return block;&#125;@end JavaScript： 123456defineClass(&quot;ViewController&quot;, &#123; viewDidAppear: function(animated) &#123; var func = self.getBlock() func(&quot;123&quot;) &#125; &#125;) 在JavaScript文件中将func作为参数block传递给Objective-C就复杂一些，需要使用block()方法进行包装，例如： Objective-C： 12345678@interface ViewController ()@end@implementation ViewController-(void)run:(void(^)(NSString * str))block&#123; block(@&quot;123&quot;);&#125;@end JavaScript： 123456defineClass(&quot;ViewController&quot;, &#123; viewDidAppear: function(animated) &#123; //run 方法中需要传入一个block self.run(block(&quot;NSString*&quot;,function(str)&#123;console.log(str)&#125;)) &#125; &#125;) 在使用block()方法对JavaScript中的Func进行包装时，block(param1,param2)有两个参数，第1个参数设置func中的参数类型，如果有多个参数，使用逗号分割；第2个参数为func函数体。 注意：在block()包装的func中不可以使用self指针，如果需要使用self，需要在block外进行临时变量的转换，示例如下： 1234567891011defineClass(&quot;ViewController&quot;, &#123; viewDidAppear: function(animated) &#123; //run 方法中需要传入一个block var slf = self self.run(block(&quot;NSString*&quot;, function(str)&#123; console.log(str) slf.log(str) &#125;)) &#125; &#125;) 在JavaScript中分别使用\\_\\_weak()与\\_\\_strong来声明弱引用与强引用对象，例如： 12 var slf = __weak(self) var stgSef = __strong(self) 5.关于GCD与枚举在JSPatch中，可以使用如下JavaScript代码来调用GCD方法： 123456789101112//阻塞当前线程一定时间dispatch_after(1.0, function()&#123; &#125;)//为主线程添加异步任务dispatch_async_main(function()&#123; &#125;)//为主线程添加同步任务dispatch_sync_main(function()&#123; &#125;)//向全局队列中添加任务dispatch_async_global_queue(function()&#123; &#125;) JSPatch中不可以直接使用Objective-C中定义的枚举，但是可以用其枚举的真实值进行传递。例如： 12//UIControlEventTouchUpInside的值是1&lt;&lt;6btn.addTarget_action_forControlEvents(self, &quot;handleBtn&quot;, 1&lt;&lt;6); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}],"tags":[],"keywords":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}]},{"title":"iOS中动态更新补丁策略JSPatch运用基础一","slug":"190iOS中动态更新补丁策略JSPatch运用基础一","date":"2016-03-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.336Z","comments":true,"path":"2016/03/24/190iOS中动态更新补丁策略JSPatch运用基础一/","link":"","permalink":"http://huishao.cc/2016/03/24/190iOS中动态更新补丁策略JSPatch运用基础一/","excerpt":"","text":"iOS中动态更新补丁策略JSPatch运用基础JSPatch是GitHub上一个开源的框架，其可以通过Objective-C的run-time机制动态的使用JavaScript调用与替换项目中的Objective-C属性与方法。其框架小巧，代码简洁，并且通过系统的JavaScriptCore框架与Objective-C进行交互，这使其在安全性和审核风险上都有很强的优势。Git源码地址：[https://github.com/bang590/JSPatch](https://github.com/bang590/JSPatch)。 一、从一个官方的小demo看起通过cocoapods将JSPath集成进一个Xcode工程中，在AppDelegate类的中编写如下代码： 123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; //开始初始化引擎 [JPEngine startEngine]; //读取js文件 NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;demo&quot; ofType:@&quot;js&quot;]; NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; //运行js文件 [JPEngine evaluateScript:script]; self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds]; self.window.rootViewController = [[ViewController alloc]init]; [self.window addSubview:[self genView]]; [self.window makeKeyAndVisible]; return YES;&#125;- (UIView *)genView&#123; UIView * view= [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 320)]; view.backgroundColor = [UIColor redColor]; return view;&#125; 在工程中添加一个js文件，编写如下： 123456789101112131415 require(&apos;UIView, UIColor, UILabel&apos;) //要替换函数的类 defineClass(&apos;AppDelegate&apos;, &#123; //替换函数 //要替换函数的名称 genView: function() &#123; var view = self.ORIGgenView(); view.setBackgroundColor(UIColor.greenColor()) var label = UILabel.alloc().initWithFrame(view.frame()); label.setText(&quot;JSPatch&quot;); label.setTextAlignment(1); view.addSubview(label); return view; &#125; &#125;); 运行工程，可以看到genView方法被替换成了js文件中的方法，原本红色的视图被修改成了绿色。 二、使用JavaScript代码向Objective-C中修改或添加方法JSPatch引擎中支持3中方式进行JavaScript代码的调用，分别是使用JavaScript字符串进行代码运行，读取本地的JavaScript文件进行代码运行和获取网络的JavaScript文件进行代码运行。例如，如果想要通过JavaScript代码在项目中弹出一个警告框，在Objective-C代码中插入如下代码： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // ‘\\’符用于进行换行 [JPEngine evaluateScript:@&quot;\\ var alertView = require(&apos;UIAlertView&apos;).alloc().init();\\ alertView.setTitle(&apos;Alert&apos;);\\ alertView.setMessage(&apos;AlertView from js&apos;); \\ alertView.addButtonWithTitle(&apos;OK&apos;);\\ alertView.show(); \\ &quot;];&#125; 开发者也可以动态在Objective-C类文件中添加方法，例如在ViewController类中编写如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; [JPEngine startEngine]; NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;demo&quot; ofType:@&quot;js&quot;]; NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; [self performSelectorOnMainThread:@selector(creatView) withObject:nil waitUntilDone:nil];&#125; JavaScript文件代码如下： 12345678910111213 require(&apos;UIView, UIColor, UILabel&apos;) defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method creatView: function() &#123; var view = UIView.alloc().initWithFrame(&#123;x:20, y:20, width:100, height:100&#125;); view.setBackgroundColor(UIColor.greenColor()); var label = UILabel.alloc().initWithFrame(&#123;x:0, y:0, width:100, height:100&#125;); label.setText(&quot;JSPatch&quot;); label.setTextAlignment(1); view.addSubview(label); self.view().addSubview(view) &#125; &#125;); 除了上面的代码，在ViewController.m文件中没有编写任何其他的方法，运行工程，可以看到程序并没有崩溃，ViewController执行了creatView方法。 通过上面的示例，我们发现使用JSPatch可以做一些十分有趣的事。对于iOS应用来说，通过官方渠道AppStore进行应用程序的发布要通过人工审核，有时这个审核周期会非常长，如果在开发者在编写代码时留下了一些小漏洞，应用一旦上线，若要修改掉这个bug就十分艰难了。有了JSPatch，我们可以想象，如果可以定位到线上应用有问题的方法，使用JS文件来修改掉这个方法，这将是多么cool的一件事，事实上，JSPatch的主要用途也是可以实现线上应用极小问题的hotfix。 三、JavaScript与Objective-C交互的基础方法要使用JSPatch来进行Objective-C风格的方法编写，需要遵守一些JavaScript与Objective-C交互的规则。 1.在JavaScript文件中使用Objective-C类 在编写JavaScript代码时如果需要用到Objective-C的类，必须先对这个类进行require引用，例如，如果需要使用UIView这个类，需要在使用前进行如下引用： 1require(&apos;UIView&apos;) 同样也可以一次对多个Objective-C类进行引用： 1require(&apos;UIView, UIColor, UILabel&apos;) 还有一种更加简便的写法，直接在使用的时候对其进行引用： 1require(&apos;UIView&apos;).alloc().init() 2.在JavaScript文件中进行Objective-C方法的调用在进行Objective-C方法的调用时，分为两种，一种是调用类方法，一种是调用类的对象方法。 调用类方法：通过类名打点的方式来调用类方法，格式类似如下，括号内为参数传递： 1UIColor.redColor() 调用实例方法：通过对象打点的方式调用类的实例方法，格式如下，括号内为参数传递： 1view.addSubview(label) 对于Objective-C中的多参数方法，转化为JavaScript将参数分割的位置以_进行分割，参数全部放入后面的括号中，以逗号分割，示例如下： 1view.setBackgroundColor(UIColor.colorWithRed_green_blue_alpha(0,0.5,0.5,1)) 对于Objective-C类的属性变量，在JavaScript中只能使用getter与setter方法来访问，示例如下： 1label.setText(&quot;JSPatch&quot;) 提示：如果原Objective-C的方法中已经包含了_符号，则在JavaScript中使用__代替。 3.在JavaScript中操作与修改Objective-C类JSPatch的最大应用是在应用运行时动态的操作和修改类。 重写或者添加类的方法： 在JavaScript中使用defineClass来定义和修改类中的方法，其编写格式如下所示： 123456/*classDeclaration:要添加或者重写方法的类名 字符串 如果此类不存在 则会创建新的类instanceMethods:要添加或者重写的实例方法 &#123;&#125;classMethods:要添加或者重写的类方法 &#123;&#125;*/defineClass(classDeclaration, instanceMethods, classMethods) 示例如下: 123456789101112131415defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method newFunc: function() &#123; //编写实例方法 self.view().setBackgroundColor(UIColor.redColor()) &#125; &#125;,&#123; myLoad:function()&#123; //编写类方法 &#125; &#125; ) 如果在重写了类中的方法后要调用原方法，需要使用ORIG前缀，示例如下： 123456789defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.ORIGviewDidLoad() &#125; &#125; ) 对于Objective-C中super关键字调用的方法，在JavaScript中可以使用self.super()来调用，例如： 123456789defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.super().viewDidLoad() &#125; &#125; ) 同样JSPatch也可以为类添加临时属性，用于在方法间参数传递，使用set_Prop_forKey()来添加属性，使用getProp()来获取属性，注意，JSPatch添加的属性不能使用Objective-C的setter与getter方法访问，如下： 1234567891011121314defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.super().viewDidLoad() self.setProp_forKey(&quot;JSPatch&quot;, &quot;data&quot;) &#125;, touchesBegan_withEvent(id,touch)&#123; self.getProp(&quot;data&quot;) self.view().setBackgroundColor(UIColor.redColor()) &#125; &#125; ) 关于为类添加协议的遵守，和Objective-C中遵守协议的方式一致，如下： 1234567891011121314151617defineClass(&quot;ViewController2: UIViewController &lt;UIAlertViewDelegate&gt;&quot;, &#123; viewDidAppear: function(animated) &#123; var alertView = require(&apos;UIAlertView&apos;) .alloc() .initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles( &quot;Alert&quot;, &quot;content&quot;, self, &quot;OK&quot;, null ) alertView.show() &#125;, alertView_clickedButtonAtIndex:function(alertView, buttonIndex) &#123; console.log(&apos;clicked index &apos; + buttonIndex) &#125; &#125;) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}],"tags":[],"keywords":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}]},{"title":"设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框","slug":"189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框","date":"2016-03-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.336Z","comments":true,"path":"2016/03/23/189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框/","link":"","permalink":"http://huishao.cc/2016/03/23/189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框/","excerpt":"","text":"设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框文本输入框是多数与社交相关的app中不可或缺的一个控件，这些文本输入框应该具备如下的功能： 1.在键盘为弹起时，输入框悬浮在界面底部。 2.当键盘弹起时，输入框位置上移至键盘上方，并且动画应与键盘同步。 3.当输入的文字超出一行时，输入框应想用的进行高度扩展。 4.当输入框的高度达到某一极限值时，输入框高度不应继续扩展，文字区域应该支持滑动。 使用autolayout布局技术加上对键盘的相关监听，可以十分方便的实现上述效果。首先在xib文件中进行相关约束的添加，如下图： 将需要的属性与约束对象关联到文件中： 12345678910//整体文本控件的高度 @IBOutlet weak var textViewHeight: NSLayoutConstraint! //文本控件中的文字输入控件UITestView的高度 @IBOutlet weak var textFieldHeight: NSLayoutConstraint! //文本控件中文字输入控件 @IBOutlet weak var ourTextField: UITextView! //文本控件与父视图底部的约束距离 @IBOutlet weak var textViewBottom: NSLayoutConstraint! //文本控件 @IBOutlet weak var ourTextView: UIView! 在初始化方法中进行通知的注册和代理的设置： 123 NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector(&quot;keyboardWillShow:&quot;), name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector(&quot;keyboardWillHidden:&quot;), name: UIKeyboardWillHideNotification, object: nil) ourTextField.delegate=self 实现通知的监听方法如下： 123456789101112131415161718192021222324252627282930 //键盘将要展示时触发的方法 func keyboardWillShow(noti:NSNotification)&#123; //获取通知信息 let info:Dictionary = noti.userInfo! //获取信息中的键盘尺寸和位置信息 let value:NSValue = info[UIKeyboardFrameBeginUserInfoKey] as! NSValue //获取键盘动画的时间信息 let value2:NSValue = info[UIKeyboardAnimationDurationUserInfoKey] as! NSValue let keyboardSize = value.CGRectValue() let height = keyboardSize.height var time:NSTimeInterval=0 value2.getValue(&amp;time) //重设约束 textViewBottom.constant = height //动画展示 UIView.animateWithDuration(time) &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125; &#125; //键盘将要隐藏时触发的方法 func keyboardWillHidden(noti:NSNotification)&#123; let info:Dictionary = noti.userInfo! let value2:NSValue = info[UIKeyboardAnimationDurationUserInfoKey] as! NSValue var time:NSTimeInterval=0 value2.getValue(&amp;time) textViewBottom.constant = 0 UIView.animateWithDuration(time) &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125; &#125; 监听的键盘状态发送的通知中，会传递进来许多键盘信息，可取的键值如下： 12345678910@available(iOS 3.2, *)public let UIKeyboardFrameBeginUserInfoKey: String //键盘的初始位置尺寸 为CGRect类型的NSValue值@available(iOS 3.2, *)public let UIKeyboardFrameEndUserInfoKey: String // 键盘的末位位置尺寸 为CGRect类型的NSValue值@available(iOS 3.0, *)public let UIKeyboardAnimationDurationUserInfoKey: String // 键盘动画时间 double类型的NSValue@available(iOS 3.0, *)public let UIKeyboardAnimationCurveUserInfoKey: String // 键盘动画效果 (UIViewAnimationCurve)枚举类型的NSNumber值@available(iOS 9.0, *)public let UIKeyboardIsLocalUserInfoKey: String //与多任务相关 判断键盘是否属于当前应用 iOS9后可用 可以监听的与键盘相关信息的通知有如下几种： 12345678public let UIKeyboardWillShowNotification: String//键盘将要出现public let UIKeyboardDidShowNotification: String//键盘已经出现public let UIKeyboardWillHideNotification: String//键盘将要隐藏public let UIKeyboardDidHideNotification: String//键盘已经隐藏@available(iOS 5.0, *)public let UIKeyboardWillChangeFrameNotification: String//键盘frame将要改变@available(iOS 5.0, *)public let UIKeyboardDidChangeFrameNotification: String//键盘frame已经改变 还需要实现当输入框文字长度改变时的回调方法如下： 123456789101112131415161718192021222324func textViewDidChange(textView: UITextView) &#123; let height = textView.contentSize.height if height &lt;= 37 &#123; textFieldHeight.constant = 37 textViewHeight.constant = 53 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) return //临界值 &#125;else if height&lt;100 &#123; textFieldHeight.constant = height textViewHeight.constant = height+16 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) &#125;else&#123; textFieldHeight.constant = 100 textViewHeight.constant = 116 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) &#125; &#125; 上面代码是实现可自适应高度和位置的文本输入框控件的核心代码，效果图下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计","slug":"187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计","date":"2016-03-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.335Z","comments":true,"path":"2016/03/21/187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计/","link":"","permalink":"http://huishao.cc/2016/03/21/187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计/","excerpt":"","text":"iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计一、引言本系列博客将系统的介绍一款蓝牙对战五子棋的开发思路与过程，其中的核心部分有两个，一部分是蓝牙通讯中对战双方信息交互框架的设计与开发，一部分是五子棋游戏中棋盘逻辑与胜负判定的算法实现。本篇博客将介绍游戏中蓝牙通讯类的设计思路 二、设计通讯类的核心想法 在前篇的一篇博客中，我们有详细的介绍iOS中蓝牙4.0技术的应用与系统框架CoorBluetooth.framework中提供的编程接口的用法。博客地址如下，如果读者需要更详细的了解iOS中蓝牙技术的使用，可以先阅读这篇博客： iOS开发之蓝牙通讯：http://my.oschina.net/u/2340880/blog/548127。 在使用蓝牙进行应用间通讯交互时，必须有一方作为中心设备，有一方作为外围设备。举一个简单的例子，通过手机蓝牙可以和刷卡设备、打印机等进行信息交互，这里的刷卡设备、打印机就充当着外围设备的角色，手机就充当着中心设备的角色。在中心设备与外围设备间，外设负责向周围广播广告告知其他设备自己的存在，中心设备接收到外设广播的广告后可以选择目标设备进行连接，当然，外设的广播的广告中会携带一些身份信息供中心设备进行识别。一旦中心设备与外设建立连接，中心设备变可以使用外设提供的服务，一个外设可以提供多个服务，例如一款蓝牙打印机外设可能会提供两种服务，一种服务向中心设备发送约定信息，告知中心设备支持的打印格式，一种服务获取中心设备的数据来进行打印服务。服务是中心设备与外设机型通讯的功能标识，然而具体的通讯媒介则是由服务中的特征值来完成的，一个服务也可以提供多个特征值。可以这样理解，特征值是两设备进行蓝牙通讯的最小通讯单元，是读写数据的载体。 上面简单介绍了在蓝牙通讯中的一些基本流程与相关概念，应用于游戏中略微有一些区别，首先我们这款游戏应该具备既可以作为中心设备也可以作为外设的能力，因此，我们需要将中心设备的通讯模式与外设的通讯模式都集成与游戏的通讯框架中。游戏的双方要建立连接应该有如下几个过程： 1.有一方建立游戏，作为房主。 2.由一方作为游戏的加入者，扫描附近的游戏。 3.外设提供的服务中应该至少有两个特征值，一个用于己方下子后通知对方设备，一个用于监听对方设备的下子操作。 由上面分析可知，游戏中的房主正是充当蓝牙通讯中的外设，它将广播广告告知周围设备自己的存在。而游戏中的加入者则是充当着蓝牙通讯中的中心设备，扫描到周围的游戏房间后进行连接加入，开始游戏。 三、游戏中蓝牙通讯类的设计 创建一个命名为BlueToothTool的工具类，作为游戏的蓝牙通讯类，编写其头文件如下： BlueToothTool.h 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;CoreBluetooth/CoreBluetooth.h&gt;//这个代理用于处理接收到对方设备发送来的数据后的回调@protocol BlueToothToolDelegate &lt;NSObject&gt;//获取对方数据-(void)getData:(NSString *)data;@end@interface BlueToothTool : NSObject&lt;CBPeripheralManagerDelegate,CBCentralManagerDelegate,CBPeripheralDelegate,UIAlertViewDelegate&gt;//代理@property(nonatomic,weak)id&lt;BlueToothToolDelegate&gt;delegate;//标记是否是游戏中的房主@property(nonatomic,assign)BOOL isCentral;/** *获取单例对象的方法 */+(instancetype)sharedManager;/* *作为游戏的房主建立游戏房间 */-(void)setUpGame:(NSString *)name block:(void(^)(BOOL first))finish;/* *作为游戏的加入者查找附近的游戏 */-(void)searchGame;/** *断块连接 */-(void)disConnect;/* *进行写数据操作 */-(void)writeData:(NSString *)data;@end 实现BlueToothTool.m文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274#import &quot;BlueToothTool.h&quot;@implementation BlueToothTool&#123; //外设管理中心 CBPeripheralManager * _peripheralManager; //外设提供的服务 CBMutableService * _ser; //服务提供的读特征值 CBMutableCharacteristic * _readChara; //服务提供的写特征值 CBMutableCharacteristic * _writeChara; //等待对方加入的提示视图 UIView * _waitOtherView; //正在扫描附近游戏的提示视图 UIView * _searchGameView; //设备中心管理对象 CBCentralManager * _centerManger; //要连接的外设 CBPeripheral * _peripheral; //要交互的外设属性 CBCharacteristic * _centerReadChara; CBCharacteristic * _centerWriteChara; //开始游戏后的回调 告知先手与后手信息 void(^block)(BOOL first);&#125;//实现单例方法+(instancetype)sharedManager&#123; static BlueToothTool *tool = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; tool = [[self alloc] init]; &#125;); return tool;&#125;//实现创建游戏的方法-(void)setUpGame:(NSString *)name block:(void (^)(BOOL))finish&#123; block = [finish copy]; if (_peripheralManager==nil) &#123; //初始化服务 _ser= [[CBMutableService alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;] primary:YES]; //初始化特征 _readChara = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;] properties:CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable]; _writeChara = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00068&quot;] properties:CBCharacteristicPropertyWriteWithoutResponse value:nil permissions:CBAttributePermissionsWriteable]; //向服务中添加特征 _ser.characteristics = @[_readChara,_writeChara]; _peripheralManager = [[CBPeripheralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)]; &#125; //设置为房主 _isCentral=YES; //开始广播广告 [_peripheralManager startAdvertising:@&#123;CBAdvertisementDataLocalNameKey:@&quot;WUZIGame&quot;&#125;];&#125;//外设检测蓝牙状态-(void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral&#123; //判断是否可用 if (peripheral.state==CBPeripheralManagerStatePoweredOn) &#123; //添加服务 [_peripheralManager addService:_ser]; //开始广播广告 [_peripheralManager startAdvertising:@&#123;CBAdvertisementDataLocalNameKey:@&quot;WUZIGame&quot;&#125;]; &#125;else&#123; //弹提示框 dispatch_async(dispatch_get_main_queue(), ^&#123; [self showAlert]; &#125;); &#125;&#125;//开始放广告的回调-(void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error&#123; if (_waitOtherView==nil) &#123; _waitOtherView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; dispatch_async(dispatch_get_main_queue(), ^&#123; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;等待附近玩家加入&quot;; [_waitOtherView addSubview:label]; _waitOtherView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [[[UIApplication sharedApplication].delegate window]addSubview:_waitOtherView]; &#125;); &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_waitOtherView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_waitOtherView]; &#125;); &#125;&#125;//添加服务后回调的方法-(void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error&#123; if (error) &#123; NSLog(@&quot;添加服务失败&quot;); &#125; NSLog(@&quot;添加服务成功&quot;);&#125;//中心设备订阅特征值时回调-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic&#123; [_peripheralManager stopAdvertising]; if (_isCentral) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;&quot; message:@&quot;请选择先手后手&quot; delegate:self cancelButtonTitle:@&quot;我先手&quot; otherButtonTitles:@&quot;我后手&quot;, nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [_waitOtherView removeFromSuperview]; [alert show]; &#125;); &#125;&#125;//收到写消息后的回调-(void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.delegate getData:[[NSString alloc]initWithData:requests.firstObject.value encoding:NSUTF8StringEncoding]]; &#125;);&#125;//弹提示框的方法-(void)showAlert&#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;温馨提示&quot; message:@&quot;请确保您的蓝牙可用&quot; delegate:nil cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show];&#125;//===============================================================作为游戏加入这实现的方法========//搜索周围游戏-(void)searchGame&#123; if (_centerManger==nil) &#123; _centerManger = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)]; &#125;else&#123; [_centerManger scanForPeripheralsWithServices:nil options:nil]; if (_searchGameView==nil) &#123; _searchGameView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;正在扫加入描附近游戏&quot;; _searchGameView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [_searchGameView addSubview:label]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;else&#123; [_searchGameView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125; &#125; //设置为游戏加入方 _isCentral = NO;&#125;//设备硬件检测状态回调的方法 可用后开始扫描设备-(void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; if (_centerManger.state==CBCentralManagerStatePoweredOn) &#123; [_centerManger scanForPeripheralsWithServices:nil options:nil]; if (_searchGameView==nil) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; _searchGameView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;正在扫加入描附近游戏&quot;; _searchGameView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [_searchGameView addSubview:label]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;); &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_searchGameView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;); &#125; &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self showAlert]; &#125;); &#125;&#125;//发现外设后调用的方法-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; //获取设备的名称 或者广告中的相应字段来配对 NSString * name = [advertisementData objectForKey:CBAdvertisementDataLocalNameKey]; if ([name isEqualToString:@&quot;WUZIGame&quot;]) &#123; //保存此设备 _peripheral = peripheral; //进行连接 [_centerManger connectPeripheral:peripheral options:@&#123;CBConnectPeripheralOptionNotifyOnConnectionKey:@YES&#125;]; &#125;&#125;//连接外设成功的回调-(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; NSLog(@&quot;连接成功&quot;); //设置代理与搜索外设中的服务 [peripheral setDelegate:self]; [peripheral discoverServices:nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [_searchGameView removeFromSuperview]; &#125;);&#125;//连接断开-(void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@&quot;连接断开&quot;); [_centerManger connectPeripheral:peripheral options:@&#123;CBConnectPeripheralOptionNotifyOnConnectionKey:@YES&#125;];&#125;//发现服务后回调的方法-(void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; for (CBService *service in peripheral.services) &#123; //发现服务 比较服务的UUID if ([service.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;]]) &#123; NSLog(@&quot;Service found with UUID: %@&quot;, service.UUID); //查找服务中的特征值 [peripheral discoverCharacteristics:nil forService:service]; break; &#125; &#125;&#125;//开发服务中的特征值后回调的方法-(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; for (CBCharacteristic *characteristic in service.characteristics) &#123; //发现特征 比较特征值得UUID 来获取所需要的 if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;]]) &#123; //保存特征值 _centerReadChara = characteristic; //监听特征值 [_peripheral setNotifyValue:YES forCharacteristic:_centerReadChara]; &#125; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00068&quot;]]) &#123; //保存特征值 _centerWriteChara = characteristic; &#125; &#125;&#125;//所监听的特征值更新时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; //更新接收到的数据 NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:characteristic.value encoding:NSUTF8StringEncoding]); //要在主线程中刷新 dispatch_async(dispatch_get_main_queue(), ^&#123; [self.delegate getData:[[NSString alloc]initWithData:characteristic.value encoding:NSUTF8StringEncoding]]; &#125;);&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; //告诉开发者先后手信息 if (buttonIndex==0) &#123; if (_isCentral) &#123; block(1); &#125;else&#123; block(0); &#125; &#125;else&#123; if (_isCentral) &#123; block(0); &#125;else&#123; block(1); &#125; &#125;&#125;//断开连接-(void)disConnect&#123; if (!_isCentral) &#123; [_centerManger cancelPeripheralConnection:_peripheral]; [_peripheral setNotifyValue:NO forCharacteristic:_centerReadChara]; &#125;&#125;//写数据-(void)writeData:(NSString *)data&#123; if (_isCentral) &#123; [_peripheralManager updateValue:[data dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:_readChara onSubscribedCentrals:nil]; &#125;else&#123; [_peripheral writeValue:[data dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:_centerWriteChara type:CBCharacteristicWriteWithoutResponse]; &#125;&#125;@end 附录：游戏的源码已经放在git上，时间比较仓促，只用了一下午来写，其中还有许多细节与bug没有进行调整，有需要的可以作为参考： git地址：https://github.com/ZYHshao/BlueGame。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法","slug":"188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法","date":"2016-03-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.335Z","comments":true,"path":"2016/03/21/188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法/","link":"","permalink":"http://huishao.cc/2016/03/21/188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法/","excerpt":"","text":"iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法一、引言上一篇博客我们介绍了在开发一款蓝牙对战五子棋游戏中核心的蓝牙通讯框架的设计与编写，本篇博客将来完成独立的棋盘逻辑与胜负判定算法。上篇博客地址如下： 五子棋游戏中和核心通讯类设计：http://my.oschina.net/u/2340880/blog/644432。 二、棋盘中独立棋格的设计我们知道，五子棋游戏的棋盘是由横纵交叉的两组平行线组成，每一个横纵线的交点即是棋盘上可以落子的点。因此，在设计棋盘前，我们可以先来设计创建棋盘上每一个独立的落子点，这里称之为棋格，在iOS中，可以使用UIButton类来进行棋格的设计。 创建一个类，命名为TipButton作为棋格类，实现其头文件如下： TipButton.h 1234567891011#import &lt;UIKit/UIKit.h&gt;@interface TipButton : UIButton//标记此瓦片是否已经落子 0 空 1 己方落子 2 敌方落子@property(nonatomic,assign)int hasChess;//落子 BOOL类型的参数 决定是己方还是敌方-(void)dropChess:(BOOL)isMine;//设置白子或者黑子@property(nonatomic,assign)BOOL isWhite;//瓦片编号@property(nonatomic,assign)int index;@end 实现.m文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &quot;TipButton.h&quot;@implementation TipButton- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self creatView]; &#125; return self;&#125;-(void)creatView&#123; //创建横竖两条线 UIView * line1 = [[UIView alloc]initWithFrame:CGRectMake(self.frame.size.width/2-0.25, 0, 0.5, self.frame.size.height)]; line1.backgroundColor = [UIColor grayColor]; [self addSubview:line1]; UIView * line2 = [[UIView alloc]initWithFrame:CGRectMake(0, self.frame.size.height/2-0.25, self.frame.size.width, 0.5)]; line2.backgroundColor = [UIColor grayColor]; [self addSubview:line2];&#125;-(void)dropChess:(BOOL)isMine&#123; UIView * view = [[UIView alloc]initWithFrame:CGRectMake(self.frame.size.width/2-5, self.frame.size.height/2-5, 10, 10)]; view.layer.masksToBounds = YES; view.layer.cornerRadius = 5; UIColor * myColor; UIColor * otherColor; if (_isWhite) &#123; myColor = [UIColor whiteColor]; otherColor = [UIColor blackColor]; &#125;else&#123; myColor = [UIColor blackColor]; otherColor = [UIColor whiteColor]; &#125; if (isMine) &#123; view.backgroundColor = myColor; self.hasChess = 1; &#125;else&#123; view.backgroundColor = otherColor; self.hasChess = 2; &#125; [self addSubview:view]; &#125;@end 三、游戏棋盘的设计创建一个继承于UIView的类，作为五子棋游戏的棋盘，命名为GameView实现如下： GameView.h 1234567891011121314#import &lt;UIKit/UIKit.h&gt;#import &quot;TipButton.h&quot;#import &quot;BlueToothTool.h&quot;//用于处理用户下子后的逻辑@protocol GameViewDelegate&lt;NSObject&gt;-(void)gameViewClick:(NSString *)index;@end@interface GameView : UIView&lt;UIAlertViewDelegate&gt;//存放所有棋格@property(nonatomic,strong)NSMutableArray&lt;TipButton *&gt; * tipArray;@property(nonatomic,weak)id&lt;GameViewDelegate&gt;delegate;//进行下子-(void)setTipIndex:(int)index;@end GameView.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391#import &quot;GameView.h&quot;@implementation GameView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _tipArray = [[NSMutableArray alloc]init]; [self creatView]; &#125; return self;&#125;//创建表格视图 横16 竖20-(void)creatView&#123; self.layer.borderColor = [UIColor colorWithRed:222/255.0 green:222/255.0 blue:222/255.0 alpha:1].CGColor; self.layer.borderWidth = 0.5; CGFloat width = self.frame.size.width/12; CGFloat height = self.frame.size.height/20; //排列布局 for (int i=0; i&lt;240; i++) &#123; TipButton * btn = [[TipButton alloc]initWithFrame:CGRectMake(width*(i%12), height*(i/12), width, height)]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.isWhite = NO; btn.index=i; [self addSubview:btn]; [_tipArray addObject:btn]; &#125;&#125;-(void)click:(TipButton *)btn&#123; if (btn.hasChess==0) &#123; //下子 [btn dropChess:YES]; //进行胜负判定 [self cheak]; [self.delegate gameViewClick:[NSString stringWithFormat:@&quot;%d&quot;,btn.index]]; &#125;&#125;//进行胜负判定-(void)cheak&#123; //判定己方是否胜利 if ([self cheakMine]) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;您胜利啦&quot; message:@&quot;&quot; delegate:self cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show]; &#125; //判断对方是否胜利 if ([self cheakOther]) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;您失败了&quot; message:@&quot;&quot; delegate:self cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show]; &#125;&#125;-(void)setTipIndex:(int)index&#123; //下子 for (TipButton * btn in _tipArray) &#123; if (btn.index==index) &#123; [btn dropChess:NO]; [self cheak]; &#125; &#125;&#125;-(BOOL)cheakOther&#123; //遍历所有棋子 for (int i=0; i&lt;_tipArray.count; i++) &#123; TipButton * tip = _tipArray[i]; //获取是否是己方棋子 if (tip.hasChess==2) &#123; //进行五子判定逻辑 //横向 if ( [self cheak1HasMineOrOther:NO index:i]) &#123; return YES; &#125; //左上到右下的对角线 if ( [self cheak2HasMineOrOther:NO index:i]) &#123; return YES; &#125; //纵向 if ( [self cheak3HasMineOrOther:NO index:i]) &#123; return YES; &#125; //右上到左下的对角线 if ( [self cheak4HasMineOrOther:NO index:i]) &#123; return YES; &#125; &#125; &#125; return NO;&#125;-(BOOL)cheakMine&#123; //遍历所有棋子 for (int i=0; i&lt;_tipArray.count; i++) &#123; TipButton * tip = _tipArray[i]; //获取是否是己方棋子 if (tip.hasChess==1) &#123; //进行五子判定逻辑 //横向 if ( [self cheak1HasMineOrOther:YES index:i]) &#123; return YES; &#125; //左上到右下的对角线 if ( [self cheak2HasMineOrOther:YES index:i]) &#123; return YES; &#125; //纵向 if ( [self cheak3HasMineOrOther:YES index:i]) &#123; return YES; &#125; //右上到左下的对角线 if ( [self cheak4HasMineOrOther:YES index:i]) &#123; return YES; &#125; &#125; &#125; return NO;&#125;-(BOOL)cheak1HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //左侧右侧同时进行可以增加效率 //左侧 count = count +[self algorithmic1:index param:mineOrOther num:4]; //右侧 count = count +[self algorithmic2:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak2HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //左上右下同时进行可以增加效率 //左上 count = count +[self algorithmic3:index param:mineOrOther num:4]; //右下 count = count +[self algorithmic4:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak3HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //纵向 //向上 count = count +[self algorithmic5:index param:mineOrOther num:4]; //向下 count = count +[self algorithmic6:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak4HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //纵向 //向上 count = count +[self algorithmic7:index param:mineOrOther num:4]; //向下 count = count +[self algorithmic8:index param:mineOrOther num:4]; NSLog(@&quot;%d&quot;,count); if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;/* 左侧递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic1:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左侧有子 if (index-tem&gt;=0) &#123; //左侧无换行 if(((index-tem)%12)!=11)&#123; if (_tipArray[index-tem].hasChess==param) &#123; return [self algorithmic1:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;/* 右侧递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic2:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //右侧有子 if (index+tem&lt;240) &#123; //右侧无换行 if(((index+tem)%12)!=11)&#123; if (_tipArray[index+tem].hasChess==param) &#123; return [self algorithmic2:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;/* 左上递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic3:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index-(tem*12)-tem)&gt;=0) &#123; //右侧无换行 if(((index-(tem*12)-tem)%12)!=11)&#123; if (_tipArray[(index-(tem*12)-tem)].hasChess==param) &#123; return [self algorithmic3:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic4:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index+(tem*12)+tem)&lt;240) &#123; //右侧无换行 if(((index+(tem*12)+tem)%12)!=0)&#123; if (_tipArray[(index+(tem*12)+tem)].hasChess==param) &#123; return [self algorithmic4:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic5:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //上有子 if ((index-(tem*12))&gt;=0) &#123; if (_tipArray[(index-(tem*12))].hasChess==param) &#123; return [self algorithmic5:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic6:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //上有子 if ((index+(tem*12))&lt;240) &#123; if (_tipArray[(index+(tem*12))].hasChess==param) &#123; return [self algorithmic6:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic7:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index-(tem*12)+tem)&gt;=0) &#123; //右侧无换行 if(((index-(tem*12)+tem)%12)!=0)&#123; if (_tipArray[(index-(tem*12)+tem)].hasChess==param) &#123; return [self algorithmic7:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic8:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index+(tem*12)-tem)&lt;240) &#123; //右侧无换行 if(((index+(tem*12)-tem)%12)!=11)&#123; if (_tipArray[(index+(tem*12)-tem)].hasChess==param) &#123; return [self algorithmic8:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; [[BlueToothTool sharedManager]disConnect]; [(UIViewController *)[self.superview nextResponder] dismissViewControllerAnimated:YES completion:nil];&#125;@end 关于胜负判定的算法逻辑，这里采用了向各个方向进行递归查找的方式，这里有一点需要主要，在4个方向进行递归查找时，理论上每个方向只需要单面递归即可，但是代码中采用了双面递归在进行累加的方式，这样的设计可以遍历更少的棋子判定出胜负情况。 四、整合通讯与游戏逻辑 创建一个继承于UIViewController的类作为游戏视图控制器，实现如下： GameViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#import &quot;GameViewController.h&quot;#import &quot;GameView.h&quot;#import &quot;BlueToothTool.h&quot;@interface GameViewController ()&lt;BlueToothToolDelegate,GameViewDelegate&gt;&#123; UIView * _bgView; UILabel * _tipLabel; GameView * _view;&#125;@end@implementation GameViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor brownColor]; //创建游戏视图 _view = [[GameView alloc]initWithFrame:CGRectMake(20, 40, (self.view.frame.size.width-40), (self.view.frame.size.width-40)/12*20)]; _view.delegate=self; [self.view addSubview:_view]; //创建背景视图 _bgView = [[UIView alloc]initWithFrame:self.view.frame]; _bgView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.1]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeSystem]; btn.frame = CGRectMake(self.view.frame.size.width/2-50, 150, 100, 30); UIButton * btn2 = [UIButton buttonWithType:UIButtonTypeSystem]; btn2.frame = CGRectMake(self.view.frame.size.width/2-50, 250, 100, 30); [btn setTitle:@&quot;创建游戏&quot; forState:UIControlStateNormal]; [btn2 setTitle:@&quot;扫描附近游戏&quot; forState:UIControlStateNormal]; btn.backgroundColor = [UIColor orangeColor]; btn2.backgroundColor = [UIColor orangeColor]; [btn addTarget:self action:@selector(creatGame) forControlEvents:UIControlEventTouchUpInside]; [btn2 addTarget:self action:@selector(searchGame) forControlEvents:UIControlEventTouchUpInside]; [_bgView addSubview:btn]; [_bgView addSubview:btn2]; [self.view addSubview:_bgView]; //设置蓝牙通讯类代理 [BlueToothTool sharedManager].delegate=self; //创建提示标签 _tipLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width,40)]; [self.view addSubview:_tipLabel]; _tipLabel.textAlignment = NSTextAlignmentCenter;&#125;-(void)creatGame&#123; [[BlueToothTool sharedManager]setUpGame:@&quot;&quot; block:^(BOOL first) &#123; [_bgView removeFromSuperview]; if (first) &#123; _tipLabel.text = @&quot;请您下子&quot;; //进行发送下子信息 &#125;else&#123; _tipLabel.text = @&quot;请等待对方下子&quot;; self.view.userInteractionEnabled = NO; [self gameViewClick:@&quot;-1&quot;]; &#125; &#125;];&#125;-(void)searchGame&#123; [[BlueToothTool sharedManager]searchGame];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;-(void)getData:(NSString *)data&#123; if (_bgView.superview) &#123; [_bgView removeFromSuperview]; &#125; if ([data integerValue]==-1) &#123; _tipLabel.text = @&quot;请您下子&quot;; self.view.userInteractionEnabled = YES; return; &#125; _tipLabel.text = @&quot;请您下子&quot;; [_view setTipIndex:[data intValue]]; self.view.userInteractionEnabled = YES;&#125;-(void)gameViewClick:(NSString *)index&#123; _tipLabel.text = @&quot;请等待对方下子&quot;; [[BlueToothTool sharedManager]writeData:index]; self.view.userInteractionEnabled = NO;&#125;@end 游戏运行的主要界面如下图所示： 附录：游戏的源码已经放在git上，时间比较仓促，只用了一下午来写，其中还有许多细节与bug没有进行调整，有需要的可以作为参考： git地址：https://github.com/ZYHshao/BlueGame。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS音频播放器锁屏歌词显示与性能优化","slug":"186iOS音频播放器锁屏歌词显示与性能优化","date":"2016-03-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.335Z","comments":true,"path":"2016/03/13/186iOS音频播放器锁屏歌词显示与性能优化/","link":"","permalink":"http://huishao.cc/2016/03/13/186iOS音频播放器锁屏歌词显示与性能优化/","excerpt":"","text":"iOS音频播放器锁屏歌词显示与性能优化一、引言前边有博客探讨了有关iOS开发中音频播放的技术与进行后台音频播放并在后台与用户进行交互的方法，本篇将探讨一种在锁屏界面同步显示歌词歌词的方法，并在应用性能上进行一些处理。前边博客地址如下： iOS音频开发AVAudioPlayer的应用：http://my.oschina.net/u/2340880/blog/420129。 iOS后台音频开发与交互技术：http://my.oschina.net/u/2340880/blog/420183。 二、在锁屏界面同步显示歌词 我们知道，在音频后台播放时，锁屏界面的信息是由MPNowPlayingInfoCenter来设置的，其中的歌曲信息字典可以设置类似歌曲封面，艺术家，歌曲名，歌曲时间等。然而，对于MPNowPlayingInfoCenter中可以由开发者掌握的接口十分有限，若要在锁屏界面同步的显示歌曲歌词，一个比较简单的方法是不停的将当前歌词与封面进行图片合成，之后刷新锁屏界面的图片。下面代码是根据解析好的LRC歌词数据进行图片合成的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//这个方法通过传入的LRC歌词数据进行图片的合成 array参数为每行lrc歌词数据集合 index为当前需要播放的lrc歌词行数-(void)setCurretLRCArray:(NSArray *)array index:(int)index&#123; //LRCItem是歌词模型 里面的lrc方法获取歌词文字字符串 NSString * lineLRC = [(LRCItem *)array[index] lrc]; //提高性能 进行判断 当前显示的歌词有无变化 如果没变化 不进行后续操作 if ([_lrcLabel.text isEqualToString:lineLRC]) &#123; return; &#125; _lrcLabel.text = lineLRC; //将歌词整理成整齐数据 //进行行数设置 NSMutableString * lrcStr = [[NSMutableString alloc]init]; if (index&lt;_lines/2) &#123; //前面用\\n补齐 int offset = (int)_lines/2-index; for (int j=0; j&lt;offset; j++) &#123; [lrcStr appendFormat:@&quot;\\n&quot;]; &#125; for (int j=0; j&lt;_lines-offset; j++) &#123; [lrcStr appendFormat:@&quot;%@\\n&quot;,[(LRCItem *)array[j] lrc]]; &#125; &#125; else if (array.count-1-index&lt;_lines/2) &#123; //后面用\\n补齐 int offset = (int)_lines/2-(int)(array.count-index-1); for (int j=index-(_lines/2); j&lt;array.count; j++) &#123; [lrcStr appendFormat:@&quot;%@\\n&quot;,[(LRCItem *)array[j] lrc]]; &#125; for (int j=0; j&lt;offset; j++) &#123; [lrcStr appendFormat:@&quot;\\n&quot;]; &#125; &#125;else &#123; for (int j=0; j&lt;_lines; j++) &#123; [lrcStr appendString:[(LRCItem *)array[index-_lines/2+j] lrc]]; [lrcStr appendString:@&quot;\\n&quot;]; &#125; &#125; //将当前显示的歌词部分高亮 NSMutableAttributedString * attriStr = [[NSMutableAttributedString alloc]initWithString:lrcStr]; NSRange range = [lrcStr rangeOfString:[array[index] lrc]]; [attriStr setAttributes:@&#123;NSForegroundColorAttributeName:[UIColor greenColor]&#125; range:range]; _lrcView.attributedText = attriStr; _lrcIMGLabel.attributedText = attriStr; //进行截屏 if (!_lrcIMGbg) &#123; _lrcIMGbg = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)]; _lrcIMGbg.image = [UIImage imageNamed:@&quot;BG.jpeg&quot;]; [_lrcIMGbg addSubview:_lrcIMGLabel]; &#125; //获取添加了歌词数据的背景图 UIGraphicsBeginImageContext(_lrcIMGbg.frame.size); CGContextRef context = UIGraphicsGetCurrentContext(); [_lrcIMGbg.layer renderInContext:context]; UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); _lrcImage = [img copy];&#125; 锁屏歌词的显示效果如下： 三、应用性能的优化 从功能上来说，通过一直合成刷新锁屏界面的封面图是可行的，然而在使用中我发现，不停和合成图片和刷新操作将使设备非常耗电，如果可以完成下面的优化，则可以大大提高应用的性能： 1.应用在前台时不进行后台锁屏界面的刷新操作。 2.应用在后台时不进行前台歌词信息、歌曲信息的相应更新。 3.当屏幕变黑关闭时，停止所有刷新操作。 4.当屏幕从新被点亮时，进行后台信息刷新。 上面4点需求，前两点十分容易搞定，在AppDelegate中有如下的方法可以监听应用程序前台与后台的切换： 123456789//应用进入后台时调用- (void)applicationWillResignActive:(UIApplication *)application &#123; //发送通知 [[NSNotificationCenter defaultCenter]postNotificationName:@&quot;goBack&quot; object:nil];&#125;//应用进入前台时调用- (void)applicationDidBecomeActive:(UIApplication *)application &#123; [[NSNotificationCenter defaultCenter]postNotificationName:@&quot;goForward&quot; object:nil];&#125; 在相应的类中监听这两个通知即可以做到刷新模式的切换。 对于上面需求的第3点与第4点，Foundation框架中没有提供公开的方法来监听屏幕设备的点亮状态，但是可以通过notify\\_register\\_dispath()方法来监听。使用示例代码如下： 123456789101112#import &lt;notify.h&gt; //在定时器中使用如下代码实时监听屏幕状态 uint64_t locked; __block int token = 0; notify_register_dispatch(&quot;com.apple.springboard.hasBlankedScreen&quot;,&amp;token,dispatch_get_main_queue(),^(int t)&#123; &#125;); notify_get_state(token, &amp;locked); //如果屏幕变暗 直接不走更新方法 lock为1则为变暗关闭状态 0则为点亮状态 if (locked) &#123; return; &#125; 通过上面优化的代码，性能将会强很多。 由于前面博客已经详细的介绍了音频开发与后台交互的内容，这篇博客主要探讨了锁屏歌词相关的开发思路与优化方向，提供的示例代码都是片段，并不完整，经过优化的音频播放器源码在如下git地址上，需要的朋友可以作为参考： 同步显示锁屏歌词的音乐播放器：https://github.com/ZYHshao/MyPlayer。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C中通过下标的方式访问自定义数据模型中属性","slug":"185Objective-C中通过下标的方式访问自定义数据模型中属性","date":"2016-03-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.334Z","comments":true,"path":"2016/03/07/185Objective-C中通过下标的方式访问自定义数据模型中属性/","link":"","permalink":"http://huishao.cc/2016/03/07/185Objective-C中通过下标的方式访问自定义数据模型中属性/","excerpt":"","text":"Objective-C中通过下标的方式访问自定义数据模型中属性在Objective-C中，可以通过下标来访问数组中的元素，如果数组是NSMutableArray类型的可变数组，则还可以通过下标来对数组中的元素进行赋值操作。例如： 1234 NSMutableArray * array = [[NSMutableArray alloc]init]; array[0] = @&quot;one&quot;; NSString * str = array[0]; NSLog(@&quot;%@&quot;,str); 对于Objective-C中的字典对象，可以通过键值下标的方式来进行访问，例如： 123 NSMutableDictionary * dic = [[NSMutableDictionary alloc]init]; dic[@&quot;name&quot;] = @&quot;name&quot;; NSLog(@&quot;%@&quot;,dic[@&quot;name&quot;]); 对于开发者自定义的的数据结构，一般会采用getter与setter方法来对其属性进行访问，虽然官方文档上没有提及，实际上，可以通过实现一些方法，来使自定义的数据模型支持使用下标来进行访问。 创建一个数据模型类，使其继承自NSObject，如下： MyModel.h 12@interface MyModel : NSObject@end MyModel.m 123456789101112131415161718192021222324@implementation MyModel&#123; NSString * _index0; NSString * _index1; NSString * _value;&#125;//通过下标获取属性值-(id) objectAtIndexedSubscript:(NSUInteger)idx &#123; return [self valueForKey:[NSString stringWithFormat:@&quot;_index%lu&quot;,idx]];&#125;//通过下标设置属性值- (void)setObject:(id)anObject atIndexedSubscript:(NSUInteger)index&#123; [self setValue:anObject forKey:[NSString stringWithFormat:@&quot;_index%lu&quot;,index]];&#125;//通过键值下标获取属性-(id) objectForKeyedSubscript:(id)key &#123; return [self valueForKey:key];&#125;//通过键值下标设置属性- (void)setObject:(id)object forKeyedSubscript:(id &lt; NSCopying &gt;)aKey&#123; [self setValue:object forKey:aKey];&#125;@end 使用如下代码进行测试： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; id model = [[MyModel alloc]init]; model[@&quot;_value&quot;] = @&quot;name&quot;; model[0] = @&quot;one&quot;; model[1] = @&quot;two&quot;; NSLog(@&quot;%@,%@,%@&quot;,model[0],model[1],model[@&quot;_value&quot;]);&#125; 这里有一点需要注意，若使用下标访问属性这种方法，必须将model声明为id类型，否则会影响编译。 在打印信息的可以看到，模型数据的设置和获取都没有问题，这种方法可以完全解放.h文件，如上所示，我们在数据模型的.h文件中一行代码都没有编写即可完成与MyModel模型数据的交互。然而其也有很大的弊端，代码的易调试和可读性都大大的降低，因此，没有特殊需求，一般不要使用这种方式来构建模型。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS翻页视图控制器UIPageViewController的应用","slug":"184iOS翻页视图控制器UIPageViewController的应用","date":"2016-03-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.334Z","comments":true,"path":"2016/03/03/184iOS翻页视图控制器UIPageViewController的应用/","link":"","permalink":"http://huishao.cc/2016/03/03/184iOS翻页视图控制器UIPageViewController的应用/","excerpt":"","text":"iOS翻页视图控制器UIPageViewController的应用一、引言UIPageViewController是iOS中少见的动画视图控制器之一，通过它既可以创建类似UIScrollView与UIPageControl结合的滚屏视图，也可以创建类似图书效果的炫酷翻页视图。UIPageViewController类似一个视图容器，其中每个具体的视图由各自的ViewController进行维护管理，UIPageViewController只进行协调与动画布置。下图可以很好的展现出UIPageViewControlelr的使用结构： 上图中，UIPageViewControllerDataSource协议为UIPageViewController提供数据支持，DataSource协议提供的数据来自各个ViewContoller自行维护，UIPageViewControllerDelegate中的回调可以对翻页动作，屏幕旋转动作等进行监听。UIPageViewController把从DataSource中获取到的视图数据渲染给View用于当前视图控制器的展示。 二、创建一个UIPageViewController首先新建一个类作为翻页视图控制器中具体每一页视图的控制器，使其继承于UIViewController： ModelViewController.h 12345#import &lt;UIKit/UIKit.h&gt;@interface ModelViewController : UIViewController+(ModelViewController *)creatWithIndex:(int)index;@property(nonatomic,strong)UILabel * indexLabel;@end ModelViewController.m 1234567891011121314151617#import &quot;ModelViewController.h&quot;@interface ModelViewController ()@end@implementation ModelViewController+(ModelViewController *)creatWithIndex:(int)index&#123; ModelViewController * con = [[ModelViewController alloc]init]; con.indexLabel = [[UILabel alloc]initWithFrame:CGRectMake(110, 200, 100, 30)]; con.indexLabel.text = [NSString stringWithFormat:@&quot;第%d页&quot;,index]; [con.view addSubview:con.indexLabel]; return con;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.view.backgroundColor = [UIColor redColor];&#125;@end 在工程模板自带的ViewController.m文件中实现如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#import &quot;ViewController.h&quot;#import &quot;ModelViewController.h&quot;//遵守协议@interface ViewController ()&lt;UIPageViewControllerDataSource,UIPageViewControllerDelegate&gt;&#123; //翻页视图控制器对象 UIPageViewController * _pageViewControl; //数据源数组 NSMutableArray * _dataArray;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //进行初始化 _pageViewControl = [[UIPageViewController alloc]initWithTransitionStyle:UIPageViewControllerTransitionStyleScroll navigationOrientation:UIPageViewControllerNavigationOrientationHorizontal options:@&#123;UIPageViewControllerOptionSpineLocationKey:@0,UIPageViewControllerOptionInterPageSpacingKey:@10&#125;]; self.view.backgroundColor = [UIColor greenColor]; //设置翻页视图的尺寸 _pageViewControl.view.bounds=self.view.bounds; //设置数据源与代理 _pageViewControl.dataSource=self; _pageViewControl.delegate=self; //创建初始界面 ModelViewController * model = [ModelViewController creatWithIndex:1]; //设置初始界面 [_pageViewControl setViewControllers:@[model] direction:UIPageViewControllerNavigationDirectionReverse animated:YES completion:nil]; //设置是否双面展示 _pageViewControl.doubleSided = NO; _dataArray = [[NSMutableArray alloc]init]; [_dataArray addObject:model]; [self.view addSubview:_pageViewControl.view];&#125;//翻页控制器进行向前翻页动作 这个数据源方法返回的视图控制器为要显示视图的视图控制器- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerBeforeViewController:(UIViewController *)viewController&#123; int index = (int)[_dataArray indexOfObject:viewController]; if (index==0) &#123; return nil; &#125;else&#123; return _dataArray[index-1]; &#125;&#125;//翻页控制器进行向后翻页动作 这个数据源方法返回的视图控制器为要显示视图的视图控制器- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerAfterViewController:(UIViewController *)viewController&#123; int index = (int)[_dataArray indexOfObject:viewController]; if (index==9) &#123; return nil; &#125;else&#123; if (_dataArray.count-1&gt;=(index+1)) &#123; return _dataArray[index+1]; &#125;else&#123; ModelViewController * model = [ModelViewController creatWithIndex:index+2]; [_dataArray addObject:model]; return model; &#125; &#125;&#125;//屏幕旋转触发的代理方法- (UIPageViewControllerSpineLocation) pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation&#123; return UIPageViewControllerSpineLocationMin;&#125;//设置分页控制器的分页数- (NSInteger)presentationCountForPageViewController:(UIPageViewController *)pageViewController &#123; return 10;&#125;//设置初始的分页点- (NSInteger)presentationIndexForPageViewController:(UIPageViewController *)pageViewController&#123; return 0;&#125;@end 上面创建了最简单的翻页视图控制器示例，效果如下图： 三、UIPageViewController中方法使用解析12//创建翻页视图控制器对象- (instancetype)initWithTransitionStyle:(UIPageViewControllerTransitionStyle)style navigationOrientation:(UIPageViewControllerNavigationOrientation)navigationOrientation options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 上面方法用于创建视图控制器对象，其中UIPageViewControllerTransitionStyle参数设置翻页控制器的风格，枚举如下： 1234typedef NS_ENUM(NSInteger, UIPageViewControllerTransitionStyle) &#123; UIPageViewControllerTransitionStylePageCurl = 0, //类似于书本翻页效果 UIPageViewControllerTransitionStyleScroll = 1 // 类似于ScrollView的滑动效果&#125;; 如果设置为UIPageViewControllerTransitionStyleCurl，翻页效果如下图所示： 上面初始化方法中的UIPageViewControllerNavigationOrientation属性设置翻页的方向，枚举如下： 1234typedef NS_ENUM(NSInteger, UIPageViewControllerNavigationOrientation) &#123; UIPageViewControllerNavigationOrientationHorizontal = 0,//水平翻页 UIPageViewControllerNavigationOrientationVertical = 1//竖直翻页&#125;; options参数用于设置翻页视图控制器的配置字典，其可以设置的配置键值如下： 1234//这个键需要设置为UIPageViewControllerOptionSpineLocationKey枚举值对应的NSNumber对象 设置翻页控制器的书轴 后面会介绍NSString * const UIPageViewControllerOptionSpineLocationKey;//这个键需要设置为NSNumber类型 设置每页视图的间距 用于滚动视图风格的NSString * const UIPageViewControllerOptionInterPageSpacingKey; 下面是UIPageViewController的一些常用属性与方法： 1234567891011121314//设置数据源@property (nullable, nonatomic, weak) id &lt;UIPageViewControllerDelegate&gt; delegate;//设置代理@property (nullable, nonatomic, weak) id &lt;UIPageViewControllerDataSource&gt; dataSource;//获取翻页风格@property (nonatomic, readonly) UIPageViewControllerTransitionStyle transitionStyle;//获取翻页方向@property (nonatomic, readonly) UIPageViewControllerNavigationOrientation navigationOrientation;//获取书轴类型@property (nonatomic, readonly) UIPageViewControllerSpineLocation spineLocation;//设置是否双面显示@property (nonatomic, getter=isDoubleSided) BOOL doubleSided;//设置要显示的视图控制器- (void)setViewControllers:(nullable NSArray&lt;UIViewController *&gt; *)viewControllers direction:(UIPageViewControllerNavigationDirection)direction animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion; 上面只有spineLocation属性有些难于理解，其枚举如下： 12345678910typedef NS_ENUM(NSInteger, UIPageViewControllerSpineLocation) &#123; //对于SCrollView类型的滑动效果 没有书轴 会返回下面这个枚举值 UIPageViewControllerSpineLocationNone = 0, //以左边或者上边为轴进行翻转 界面同一时间只显示一个View UIPageViewControllerSpineLocationMin = 1, //以中间为轴进行翻转 界面同时可以显示两个View UIPageViewControllerSpineLocationMid = 2, //以下边或者右边为轴进行翻转 界面同一时间只显示一个View UIPageViewControllerSpineLocationMax = 3 &#125;; 将上面的示例代码修改几个地方如下： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. _pageViewControl = [[UIPageViewController alloc]initWithTransitionStyle:UIPageViewControllerTransitionStylePageCurl navigationOrientation:UIPageViewControllerNavigationOrientationVertical options:@&#123;UIPageViewControllerOptionSpineLocationKey:@2,UIPageViewControllerOptionInterPageSpacingKey:@10&#125;]; self.view.backgroundColor = [UIColor greenColor]; _pageViewControl.view.bounds=self.view.bounds; _pageViewControl.dataSource=self; _pageViewControl.delegate=self; ModelViewController * model = [ModelViewController creatWithIndex:1]; ModelViewController * model2 = [ModelViewController creatWithIndex:2]; [_pageViewControl setViewControllers:@[model,model2] direction:UIPageViewControllerNavigationDirectionReverse animated:YES completion:nil]; _pageViewControl.doubleSided = YES; _dataArray = [[NSMutableArray alloc]init]; [_dataArray addObject:model]; [self.view addSubview:_pageViewControl.view];&#125;- (UIPageViewControllerSpineLocation) pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation&#123; return UIPageViewControllerSpineLocationMid;&#125; 运行效果如下图所示： 四、UIPageViewControllerDataSource中方法解析12345678//向前翻页展示的ViewController- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerBeforeViewController:(UIViewController *)viewController;//向后翻页展示的ViewController- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerAfterViewController:(UIViewController *)viewController;//设置分页控制器的分页点数- (NSInteger)presentationCountForPageViewController:(UIPageViewController *)pageViewController NS_AVAILABLE_IOS(6_0);//设置当前分页控制器所高亮的点- (NSInteger)presentationIndexForPageViewController:(UIPageViewController *)pageViewController NS_AVAILABLE_IOS(6_0); 五、UIPageViewControllerDelegate中方法解析123456//翻页视图控制器将要翻页时执行的方法- (void)pageViewController:(UIPageViewController *)pageViewController willTransitionToViewControllers:(NSArray&lt;UIViewController *&gt; *)pendingViewControllers NS_AVAILABLE_IOS(6_0);//翻页动画执行完成后回调的方法- (void)pageViewController:(UIPageViewController *)pageViewController didFinishAnimating:(BOOL)finished previousViewControllers:(NSArray&lt;UIViewController *&gt; *)previousViewControllers transitionCompleted:(BOOL)completed;//屏幕防线改变时回到的方法，可以通过返回值重设书轴类型枚举- (UIPageViewControllerSpineLocation)pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS网络编程之七——本地用户凭证Cookie的应用","slug":"183iOS网络编程之七——本地用户凭证Cookie的应用","date":"2016-02-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.334Z","comments":true,"path":"2016/03/01/183iOS网络编程之七——本地用户凭证Cookie的应用/","link":"","permalink":"http://huishao.cc/2016/03/01/183iOS网络编程之七——本地用户凭证Cookie的应用/","excerpt":"","text":"iOS网络编程之七——本地用户凭证Cookie的应用一、何为CookieCookie是网站为了便是终端身份，保存在终端本地的用户凭证信息。Cookie中的字段与意义由服务端进行定义。例如，当用户在某个网站进行了登录操作后，服务端会将Cookie信息返回给终端，终端会将这些信息进行保存，在下一次再次访问这个网站时，终端会将保存的Cookie信息一并发送到服务端，服务端根据Cookie信息是否有效来判断此用户是否可以自动登录。 二、iOS中进行Cookie管理的两个类iOS中进行HTTP网络请求Cookie管理主要由两个类负责，一个类是NSHTTPCookieStorage类，一个是NSHTTPCookie类。 1.NSHTTPCookieStorageNSHTTPCookieStorage类采用单例的设计模式，其中管理着所有HTTP请求的Cookie信息，常用方法如下： 123456789101112131415161718192021222324//获取单例对象+ (NSHTTPCookieStorage *)sharedHTTPCookieStorage;//所有Cookie数据数组 其中存放NSHTTPCookie对象@property (nullable , readonly, copy) NSArray&lt;NSHTTPCookie *&gt; *cookies;//手动设置一条Cookie数据- (void)setCookie:(NSHTTPCookie *)cookie;//删除某条Cookie信息- (void)deleteCookie:(NSHTTPCookie *)cookie;//删除某个时间后的所有Cookie信息 iOS8后可用- (nullable NSArray&lt;NSHTTPCookie *&gt; *)cookiesForURL:(NSURL *)URL;//获取某个特定URL的所有Cookie数据- (void)removeCookiesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//为某个特定的URL设置Cookie- (void)setCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies forURL:(nullable NSURL *)URL mainDocumentURL:(nullable NSURL *)mainDocumentURL;//Cookie数据的接收协议/*枚举如下：typedef NS_ENUM(NSUInteger, NSHTTPCookieAcceptPolicy) &#123; NSHTTPCookieAcceptPolicyAlways,//接收所有Cookie信息 NSHTTPCookieAcceptPolicyNever,//不接收所有Cookie信息 NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain//只接收主文档域的Cookie信息&#125;;*/@property NSHTTPCookieAcceptPolicy cookieAcceptPolicy; 系统下面的两个通知与Cookie管理有关： 1234//Cookie数据的接收协议改变时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerAcceptPolicyChangedNotification;//管理的Cookie数据发生变化时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerCookiesChangedNotification; 2.NSHTTPCookieNSHTTPCookie是具体的HTTP请求Cookie数据对象，其中属性方法如下： 12345678910111213141516171819202122232425262728293031//下面两个方法用于对象的创建和初始化 都是通过字典进行键值设置- (nullable instancetype)initWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;+ (nullable NSHTTPCookie *)cookieWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;//返回Cookie数据中可用于添加HTTP头字段的字典+ (NSDictionary&lt;NSString *, NSString *&gt; *)requestHeaderFieldsWithCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies;//从指定的响应头和URL地址中解析出Cookie数据+ (NSArray&lt;NSHTTPCookie *&gt; *)cookiesWithResponseHeaderFields:(NSDictionary&lt;NSString *, NSString *&gt; *)headerFields forURL:(NSURL *)URL;//Cookie数据中的属性字典@property (nullable, readonly, copy) NSDictionary&lt;NSString *, id&gt; *properties;//请求响应的版本@property (readonly) NSUInteger version;//请求相应的名称@property (readonly, copy) NSString *name;//请求相应的值@property (readonly, copy) NSString *value;//过期时间@property (nullable, readonly, copy) NSDate *expiresDate;//请求的域名@property (readonly, copy) NSString *domain;//请求的路径@property (readonly, copy) NSString *path;//是否是安全传输@property (readonly, getter=isSecure) BOOL secure;//是否只发送HTTP的服务@property (readonly, getter=isHTTPOnly) BOOL HTTPOnly;//响应的文档@property (nullable, readonly, copy) NSString *comment;//相应的文档URL@property (nullable, readonly, copy) NSURL *commentURL;//服务端口列表@property (nullable, readonly, copy) NSArray&lt;NSNumber *&gt; *portList; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之六——数据缓存类NSURLCache使用解析","slug":"182iOS网络编程之六——数据缓存类NSURLCache使用解析","date":"2016-02-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.334Z","comments":true,"path":"2016/02/26/182iOS网络编程之六——数据缓存类NSURLCache使用解析/","link":"","permalink":"http://huishao.cc/2016/02/26/182iOS网络编程之六——数据缓存类NSURLCache使用解析/","excerpt":"","text":"iOS网络编程之六——数据缓存类NSURLCache使用解析一、引言在前面博客中，介绍了NSURLRequest请求类的相关使用方法，其中有介绍关于请求返回数据的缓存策略，实际上，iOS中具体缓存操作的管理是由NSURLCache类来实现的。NSURLRequest类介绍的博客地址如下： iOS中NSURLRequest相关使用：http://my.oschina.net/u/2340880/blog/620225。 二、NSURLCache中方法与属性123456789101112131415161718192021222324252627282930//获取当前应用的缓存管理对象+ (NSURLCache *)sharedURLCache;//设置自定义的NSURLCache作为应用缓存管理对象+ (void)setSharedURLCache:(NSURLCache *)cache;//初始化一个应用缓存对象/*memoryCapacity 设置内存缓存容量diskCapacity 设置磁盘缓存容量path 磁盘缓存路径内容缓存会在应用程序退出后 清空 磁盘缓存不会*/- (instancetype)initWithMemoryCapacity:(NSUInteger)memoryCapacity diskCapacity:(NSUInteger)diskCapacity diskPath:(nullable NSString *)path;//获取某一请求的缓存- (nullable NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request;//给请求设置指定的缓存- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;//移除某个请求的缓存- (void)removeCachedResponseForRequest:(NSURLRequest *)request;//移除所有缓存数据- (void)removeAllCachedResponses;//移除某个时间起的缓存设置- (void)removeCachedResponsesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//内存缓存容量大小@property NSUInteger memoryCapacity;//磁盘缓存容量大小@property NSUInteger diskCapacity;//当前已用内存容量@property (readonly) NSUInteger currentMemoryUsage;//当前已用磁盘容量@property (readonly) NSUInteger currentDiskUsage; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之五——请求回执类NSURLResponse属性简介","slug":"180iOS网络编程之五——请求回执类NSURLResponse属性简介","date":"2016-02-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.333Z","comments":true,"path":"2016/02/25/180iOS网络编程之五——请求回执类NSURLResponse属性简介/","link":"","permalink":"http://huishao.cc/2016/02/25/180iOS网络编程之五——请求回执类NSURLResponse属性简介/","excerpt":"","text":"iOS网络编程之五——请求回执类NSURLResponse属性简介NSURLResponse类中存放请求的回执信息，在发送网络请求时，如果请求成功，首先会接收到服务端的回执信息，直接开始接收具体的返回数据。NSURLResponse对象中主要有以下属性： 12345678910//请求的URL地址@property (nullable, readonly, copy) NSURL *URL;//返回数据的数据类型@property (nullable, readonly, copy) NSString *MIMEType;//获取返回数据的内容长度@property (readonly) long long expectedContentLength;//获取返回数据的编码方式@property (nullable, readonly, copy) NSString *textEncodingName;//返回拼接的数据文件名 以url为名 数据没醒MIMEType为扩展名@property (nullable, readonly, copy) NSString *suggestedFilename; 对于HTTP请求，请求回执会被封装为NSHTTPURLResponse对象，其中除了有上面那些属性外，还有如下的扩展属性： 1234//请求的状态码@property (readonly) NSInteger statusCode;//请求头中所有的字段@property (readonly, copy) NSDictionary *allHeaderFields; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS新的视频开发框架AVPlayerViewContoller与画中画技术","slug":"181iOS新的视频开发框架AVPlayerViewContoller与画中画技术","date":"2016-02-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.334Z","comments":true,"path":"2016/02/25/181iOS新的视频开发框架AVPlayerViewContoller与画中画技术/","link":"","permalink":"http://huishao.cc/2016/02/25/181iOS新的视频开发框架AVPlayerViewContoller与画中画技术/","excerpt":"","text":"iOS新的视频开发框架AVPlayerViewContoller与画中画技术一、引言前面有一篇博客探讨了iOS中视频播放的开发相关类和方法，那篇博客中主要讲解的是MeidaPlayer框架中的MPMoviePlayerController类和MPMoviePlayerViewController类。在iOS8中，iOS开发框架中引入了一个新的视频框架AVKit，其中提供了视频开发类AVPlayerViewController用于在应用中嵌入播放视频的控件。在iOS8中，这两个框架中的视频播放功能并无太大差异，基本都可以满足开发者的需求。iOS9系统后，iPad Air正式开始支持多任务与画中画的分屏功能，所谓画中画，即是用户可以将当前播放的视频缩小放在屏幕上同时进行其他应用程序的使用。这个革命性的功能将极大的方便用户的使用。于此同时，在iOS9中，MPMoviePlayerController与MPMoviePlayerViewController类也被完全易用，开发者使用AVPlayerViewController可以十分方便的实现视频播放的功能并在一些型号的iPad上集成画中画的功能。 二、AVPlayerViewController的使用与其中方法属性解析使用AVPlayerViewController首先需要引入两个框架，如下： 12#import &lt;AVKit/AVKit.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt; 使用如下代码进行视频的播放： 12345 NSString * path = [[NSBundle mainBundle]pathForResource:@&quot;iphone&quot; ofType:@&quot;mp4&quot;]; NSURL *url = [NSURL fileURLWithPath:path]; AVPlayerViewController * play = [[AVPlayerViewController alloc]init]; play.player = [[AVPlayer alloc]initWithURL:url]; [self presentViewController:play animated:YES completion:nil]; 运行工程，可以看到如下图所示的视频播放界面： AVPlayerViewController中还有如下属性和方法提供给开发者使用： 1234567891011121314151617181920//是否显示视频播放控制控件@property (nonatomic) BOOL showsPlaybackControls;//设置视频播放界面的尺寸缩放选项/*可以设置的值及意义如下：AVLayerVideoGravityResizeAspect 不进行比例缩放 以宽高中长的一边充满为基准AVLayerVideoGravityResizeAspectFill 不进行比例缩放 以宽高中短的一边充满为基准AVLayerVideoGravityResize 进行缩放充满屏幕*/@property (nonatomic, copy) NSString *videoGravity;//获取是否已经准备好开始播放@property (nonatomic, readonly, getter = isReadyForDisplay) BOOL readyForDisplay;//获取视频播放界面的尺寸@property (nonatomic, readonly) CGRect videoBounds;//视频播放器的视图 自定义的控件可以添加在其上@property (nonatomic, readonly, nullable) UIView *contentOverlayView;//画中画代理 iOS9后可用@property (nonatomic, weak, nullable) id &lt;AVPlayerViewControllerDelegate&gt; delegate NS_AVAILABLE_IOS(9_0);//是否支持画中画 iOS9后可用 默认支持@property (nonatomic) BOOL allowsPictureInPicturePlayback NS_AVAILABLE_IOS(9_0); 三、画中画编程技术应用AVPlayerViewController是默认支持画中画操作的，如上图所示，视频的播放界面右下角出现一个画中画的按钮，点击这个按钮当前播放的视频界面会缩小显示在屏幕角落，这时点击Home键回到主界面，或者切换到其他应用程序，视频播放不会中断。如下图所示： 两指的捏合操作可以将缩小的视频播放窗口进行任意尺寸的放大，如果将视频窗口拖进屏幕的边界，视频窗口会被吸进边界，用户可以通过拖拽手势将其拉出，如下图： AVPlayerViewControllerDelegate中的方法可以对用户画中画的操作进行监听： 12345678910111213141516171819202122//将要开始画中画时调用的方法- (void)playerViewControllerWillStartPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//已经开始画中画时调用的方法- (void)playerViewControllerDidStartPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//开始画中画失败调用的方法- (void)playerViewController:(AVPlayerViewController *)playerViewController failedToStartPictureInPictureWithError:(NSError *)error&#123;&#125;//将要停止画中画时调用的方法- (void)playerViewControllerWillStopPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//已经停止画中画时调用的方法- (void)playerViewControllerDidStopPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//是否在开始画中画时自动将当前的播放界面dismiss掉 返回YES则自动dismiss 返回NO则不会自动dismiss- (BOOL)playerViewControllerShouldAutomaticallyDismissAtPictureInPictureStart:(AVPlayerViewController *)playerViewController&#123; return YES;&#125;//用户点击还原按钮 从画中画模式还原回app内嵌模式时调用的方法- (void)playerViewController:(AVPlayerViewController *)playerViewController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL restored))completionHandler&#123;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之四——请求类NSURLRequest使用详解","slug":"179iOS网络编程之四——请求类NSURLRequest使用详解","date":"2016-02-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.333Z","comments":true,"path":"2016/02/24/179iOS网络编程之四——请求类NSURLRequest使用详解/","link":"","permalink":"http://huishao.cc/2016/02/24/179iOS网络编程之四——请求类NSURLRequest使用详解/","excerpt":"","text":"iOS网络编程之四——请求类NSURLRequest使用详解一、引言在前面几篇博客中，介绍了iOS开发中的网络编程相关内容并且介绍了常用了两个平行的网络框架NSURLSession和NSURLConnection。无论是NSURLSession类还是NSURLConnection类，其网络请求都是通过NSURLRequest类进行发起的，本篇博客将介绍NSURLRequest类的用法和其中请求属性的设置。 前几篇博客地址如下： 1.iOS网络框架介绍：http://my.oschina.net/u/2340880/blog/618460。 2.NSURLSesstion的使用：http://my.oschina.net/u/2340880/blog/618888。 3.NSURLConnection的使用：http://my.oschina.net/u/2340880/blog/618920。 二、NSURLRequest类中常用方法和属性总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//通过类方法创建默认的请求对象/*通过这种方式创建的请求对象 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s*/+ (instancetype)requestWithURL:(NSURL *)URL;//返回一个BOOL值 用于判断是否支持安全编码+ (BOOL)supportsSecureCoding;//请求对象的初始化方法 创建时设置缓存逻辑和超时时限+ (instancetype)requestWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval;//init方法进行对象的创建 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s- (instancetype)initWithURL:(NSURL *)URL;//init方法进行对象的创建- (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval;//只读属性 获取请求对象的URL@property (nullable, readonly, copy) NSURL *URL;//只读属性 缓存策略枚举/*NSURLRequestCachePolicy枚举如下：typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)&#123; //默认的缓存协议 NSURLRequestUseProtocolCachePolicy = 0, //无论有无本地缓存数据 都进行从新请求 NSURLRequestReloadIgnoringLocalCacheData = 1, //忽略本地和远程的缓存数据 未实现的策略 NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, //无论有无缓存数据 都进行从新请求 NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, //先检查缓存 如果没有缓存再进行请求 NSURLRequestReturnCacheDataElseLoad = 2, //类似离线模式，只读缓存 无论有无缓存都不进行请求 NSURLRequestReturnCacheDataDontLoad = 3, //未实现的策略 NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented&#125;;*/@property (readonly) NSURLRequestCachePolicy cachePolicy;//只读属性 获取请求的超时时限@property (readonly) NSTimeInterval timeoutInterval;//请求主文档地址 @property (nullable, readonly, copy) NSURL *mainDocumentURL;//获取网络请求的服务类型 枚举如下/*typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)&#123; NSURLNetworkServiceTypeDefault = 0, // Standard internet traffic NSURLNetworkServiceTypeVoIP = 1, // Voice over IP control traffic NSURLNetworkServiceTypeVideo = 2, // Video traffic NSURLNetworkServiceTypeBackground = 3, // Background traffic NSURLNetworkServiceTypeVoice = 4 // Voice data&#125;;*/@property (readonly) NSURLRequestNetworkServiceType networkServiceType;//获取是否允许使用服务商蜂窝网络@property (readonly) BOOL allowsCellularAccess; NSURLRequest请求类除了在初始化时可以设定一些属性，创建出来后则大部分属性都为只读的，无法设置与修改。另一个类NSMutableURLRequest可以更加灵活的设置请求的相关属性。 三、NSMutableURLRequest类中常用方法与属性总结123456789101112//设置请求的URL@property (nullable, copy) NSURL *URL;//设置请求的缓存策略@property NSURLRequestCachePolicy cachePolicy;//设置超时时间@property NSTimeInterval timeoutInterval;//请求主文档地址@property (nullable, copy) NSURL *mainDocumentURL;//设置网络服务类型@property NSURLRequestNetworkServiceType networkServiceType NS_AVAILABLE(10_7, 4_0);//设置是否允许使用服务商蜂窝网@property BOOL allowsCellularAccess NS_AVAILABLE(10_8, 6_0); 四、NSURLRequest请求对象与HTTP/HTTPS协议相关请求的属性设置一下属性的设置必须使用NSMutableURLRequest类，如果是NSURLRequest，则只可以读，不可以修改。 12345678910111213141516//设置HPPT请求方式 默认为“GET”@property (copy) NSString *HTTPMethod;//通过字典设置HTTP请求头的键值数据@property (nullable, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields;//设置http请求头中的字段值- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//向http请求头中添加一个字段- (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//设置http请求体 用于POST请求@property (nullable, copy) NSData *HTTPBody;//设置http请求体的输入流@property (nullable, retain) NSInputStream *HTTPBodyStream;//设置发送请求时是否发送cookie数据@property BOOL HTTPShouldHandleCookies;//设置请求时是否按顺序收发 默认禁用 在某些服务器中设为YES可以提高网络性能@property BOOL HTTPShouldUsePipelining; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS应用内跳转系统设置相关界面的方法","slug":"178iOS应用内跳转系统设置相关界面的方法","date":"2016-02-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.333Z","comments":true,"path":"2016/02/23/178iOS应用内跳转系统设置相关界面的方法/","link":"","permalink":"http://huishao.cc/2016/02/23/178iOS应用内跳转系统设置相关界面的方法/","excerpt":"","text":"iOS应用内跳转系统设置相关界面的方法在iOS开发中，有时会有跳转系统设置界面的需求，例如提示用户打开蓝牙或者WIFI，提醒用户打开推送或者位置权限等。在iOS6之后，第三方应用需要跳转系统设置界面，需要在URL type中添加一个prefs值，如下图： 跳转系统设置根目录中的项目使用如下的方法： 123456789101112131415161718 _array = @[ @&#123;@&quot;系统设置&quot;:@&quot;prefs:root=INTERNET_TETHERING&quot;&#125;, @&#123;@&quot;WIFI设置&quot;:@&quot;prefs:root=WIFI&quot;&#125;, @&#123;@&quot;蓝牙设置&quot;:@&quot;prefs:root=Bluetooth&quot;&#125;, @&#123;@&quot;系统通知&quot;:@&quot;prefs:root=NOTIFICATIONS_ID&quot;&#125;, @&#123;@&quot;通用设置&quot;:@&quot;prefs:root=General&quot;&#125;, @&#123;@&quot;显示设置&quot;:@&quot;prefs:root=DISPLAY&amp;BRIGHTNESS&quot;&#125;, @&#123;@&quot;壁纸设置&quot;:@&quot;prefs:root=Wallpaper&quot;&#125;, @&#123;@&quot;声音设置&quot;:@&quot;prefs:root=Sounds&quot;&#125;, @&#123;@&quot;隐私设置&quot;:@&quot;prefs:root=privacy&quot;&#125;, @&#123;@&quot;APP Store&quot;:@&quot;prefs:root=STORE&quot;&#125;, @&#123;@&quot;Notes&quot;:@&quot;prefs:root=NOTES&quot;&#125;, @&#123;@&quot;Safari&quot;:@&quot;prefs:root=Safari&quot;&#125;, @&#123;@&quot;Music&quot;:@&quot;prefs:root=MUSIC&quot;&#125;, @&#123;@&quot;photo&quot;:@&quot;prefs:root=Photos&quot;&#125; ]; NSURL * url = [NSURL URLWithString:[_array[index] allValues].firstObject]; [[UIApplication sharedApplication]openURL:url]; 如果要跳转第三方应用的设置界面中，使用prefs:root=boundleId的方式，boundleId是第三方应用的boundleId。 如果需要继续向项目内层进行跳转，可以通过添加path路径的方式，如下： 1234567891011121314 _array = @[ @&#123;@&quot;关于本机&quot;:@&quot;prefs:root=General&amp;path=About&quot;&#125;, @&#123;@&quot;软件升级&quot;:@&quot;prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK&quot;&#125;, @&#123;@&quot;日期时间&quot;:@&quot;prefs:root=General&amp;path=DATE_AND_TIME&quot;&#125;, @&#123;@&quot;Accessibility&quot;:@&quot;prefs:root=General&amp;path=ACCESSIBILITY&quot;&#125;, @&#123;@&quot;键盘设置&quot;:@&quot;prefs:root=General&amp;path=Keyboard&quot;&#125;, @&#123;@&quot;VPN&quot;:@&quot;prefs:root=General&amp;path=VPN&quot;&#125;, @&#123;@&quot;壁纸设置&quot;:@&quot;prefs:root=Wallpaper&quot;&#125;, @&#123;@&quot;声音设置&quot;:@&quot;prefs:root=Sounds&quot;&#125;, @&#123;@&quot;隐私设置&quot;:@&quot;prefs:root=privacy&quot;&#125;, @&#123;@&quot;APP Store&quot;:@&quot;prefs:root=STORE&quot;&#125;, @&#123;@&quot;还原设置&quot;:@&quot;prefs:root=General&amp;path=Reset&quot;&#125;, @&#123;@&quot;应用通知&quot;:@&quot;prefs:root=NOTIFICATIONS_ID&amp;path=应用的boundleId&quot;&#125; ]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之一——iOS网络框架简介","slug":"175iOS网络编程之一——iOS网络框架简介","date":"2016-02-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.332Z","comments":true,"path":"2016/02/22/175iOS网络编程之一——iOS网络框架简介/","link":"","permalink":"http://huishao.cc/2016/02/22/175iOS网络编程之一——iOS网络框架简介/","excerpt":"","text":"iOS网络编程之一——iOS网络框架简介一、引言通过网络，一款应用才能够内容丰富，才能够完成用户操作与后台数据的交互。网络编程是移动应用或游戏开发开发中不可缺少的技术。iOS原生的网络框架也十分完善，其中涉及到的许多类和协议用于处理网络开发中的各种需求 二、URL加载框架iOS的URL加载系统包含许多类与协议，这些类和协议相互协作完成URL加载的信息配置，协议支持，身份验证，cookie和缓存等功能。APPLE开发文档中有如下图表示他们之间的关系： 关于URL加载系统，在iOS7之后，NSURLSession是首选的API框架，在iOS9中NSURLConnection相关的方法被弃用，如果需要兼容十分旧的版本，依然需要使用NSURLConnection。 三、一些辅助类1.NSURLRequestNSURLRequest类负责一个具体的网络请求，其内部封装一个请求路径NSURL对象。如果需要对请求参数进行配置，可以使用NSMutableURLRequest。 2.NSURLResponseNSURLResponse类封装了相应数据，相应数据包括两部分，一部分是返回数据的状态码，数据长度、编码等信息，另一部分是内容数据本身。 3.NSURLCredential、NSURLProtectionSpace、NSURLCredentialStorage、NSURLAuthenticatioChallenge一些访问请求需要证书或者身份凭证进行验证，上面4个类对请求凭证进行相关设置。 4.NSURLCache在应用程序的开发中，为了减小对网络的依赖，提高程序性能，常常会对一些非实时性的数据进行缓存处理，NSURLCache类用于管理NSURLRequest请求缓存。 5.NSHTTPCookieStorage、NSHTTPCookieNSHTTPCookieStorage与NSHTTPCookie用于持久化的存储HTTP请求的Cookie数据。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之二——NSURLSession的简单使用","slug":"176iOS网络编程之二——NSURLSession的简单使用","date":"2016-02-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.332Z","comments":true,"path":"2016/02/22/176iOS网络编程之二——NSURLSession的简单使用/","link":"","permalink":"http://huishao.cc/2016/02/22/176iOS网络编程之二——NSURLSession的简单使用/","excerpt":"","text":"iOS网络编程之二——NSURLSession的简单使用一、NSURLSession简介在iOS7之后，NSURLSession作为系统推荐使用的HTTP请求框架，在进行前台请求的情况下，NSURLSession与NSURLConnection并无太大差异，对于后台的请求，NSURLSession更加灵活的优势就将展现无遗。 1.NSURLSession集合的类型NSURLSession类提供3中Session类型： Default类型：提供前台请求相关方法，支持配置缓存，身份凭证等。 Ephemeral类型：即时的请求类型，不使用缓存，身份凭证等。 Background：后台类型，支持在后台完成请求任务。 2.NSURLSession任务的类型在NSURLSession中添加的请求任务支持3中类型： 数据任务：使用NSData对象进行数据的发送和获取，一般用于短数据的任务。 下载任务：从文件下载数据，支持后台下载。 上传任务：以文件的形式上传数据，支持后台上传。 二、创建并配置NSURLSession通过NSURLSessionConfiguration类对象对NSURLSession进行配置与创建，创建和配NSURLSession的示例代码如下： 1234567891011 //默认类型的 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; //即时类型的 NSURLSessionConfiguration * ephemeralConfiguration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; //后台类型的 NSURLSessionConfiguration * backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;SessionId&quot;]; //创建并设置session NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration]; NSURLSession * ephemeralSession = [NSURLSession sessionWithConfiguration:ephemeralConfiguration]; NSURLSession * backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfiguration]; NSURLSessionConfiguration还可以配置如缓存，网络模式等参数 三、使用NSURLSession进行网络请求的两种方式NSURLSession有两种方式进行网络数据的请求，一种是通过block的方式获取网络数据，一种是通过代理回调的方式获取网络数据。通过block的方式进行请求代码如下： 123456789101112 //创建session配置对象 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; //创建请求对象 NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; //创建session对象 NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration]; //添加任务 NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;,data); &#125;]; //开始任务 [task resume]; 使用代理回调的方式进行请求需要遵守如下协议： 12@interface ViewController ()&lt;NSURLSessionDataDelegate&gt;@end 将请求代码修改如下： 123456 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration delegate:self delegateQueue:[NSOperationQueue mainQueue]]; NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request]; [task resume]; 实现代理方法如下： 12345678//开始接受数据-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSLog(@&quot;=======%@&quot;,data);&#125;//接受数据结束-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;完成：error%@&quot;,error);&#125; 四、进行后台下载任务NSURLSession最大的优势在于其后台下载的灵活性，使用如下的代码进行后台数据下载： 1234 NSURLSessionConfiguration * backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;com.zyprosoft.backgroundsession&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; NSURLSession * backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfiguration delegate:self delegateQueue:nil]; [[backgroundSession downloadTaskWithRequest:request]resume]; 在下面的回调方法中可以进行下载进度的监听： 1234- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; NSLog(@&quot;######&quot;);&#125; 如果在下载过程中点击Home键使应用程序进入后台，NSURLSession的相关代理方法将不再被回调，但是下载任务依然在进行，当后台下载完成后会与AppDelegate进行交互，会调用AppDelegate中的如下方法： 123-(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler&#123; NSLog(@&quot;1111&quot;);&#125; 之后应用程序在后台会调用NSURLSesstion代理的如下方法来通知下载结果： 12345678//此方法无论成功失败都会调用-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;完成：error%@&quot;,error);&#125;//此方法只有下载成功才会调用 文件放在location位置-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location&#123; &#125; 最后将调用NSURLSesstion的如下方法： 123456-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session&#123; NSLog(@&quot;All tasks are finished&quot;); &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之三——NSURLConnection的简单使用","slug":"177iOS网络编程之三——NSURLConnection的简单使用","date":"2016-02-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.332Z","comments":true,"path":"2016/02/22/177iOS网络编程之三——NSURLConnection的简单使用/","link":"","permalink":"http://huishao.cc/2016/02/22/177iOS网络编程之三——NSURLConnection的简单使用/","excerpt":"","text":"iOS网络编程之三——NSURLConnection的简单使用一、引言在iOS7后，NSURLSession基本代替了NSURLConnection进行网络开发，在iOS9后，NSURLConnection相关方法被完全的弃用，iOS系统有向下兼容的特性，尽管NSURLConnection已经被弃用，但在开发中，其方法依然可以被使用，并且如果需要兼容到很低版本的iOS系统，有时就必须使用NSURLConnection类了。 二、使用NSURLConnection进行同步请求对于网络请求分为同步和异步两种，同步是指在请求结果返回之前，程序代码会卡在请求处，之后的代码不会被执行，异步是指在发送请求之后，一边在子线程中接收返回数据，一边执行之后的代码，当返回数据接收完毕后，采用回调的方式通知主线程做处理。 使用如下方法进行NSURLConnection的同步请求： 12345 NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; NSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil]; NSLog(@&quot;%@&quot;,data); NSLog(@&quot;继续执行&quot;); 打印信息如下图所示，从中可以看出，当数据返回结束时才执行后面的代码： 三、使用NSURLConnection进行异步请求使用同步的方式进行请求有一个很大的弊端，在进行网络请求时，数据的返回往往需要一定时间，不可能瞬间完成，使用同步的方式将导致界面卡死，没有提示也不能交互任何用户操作，这样的话，很有可能会给用户程序卡死的假象。 NSURLConnection类提供两种方式进行异步请求操作。 1.使用block的方式进行异步请求使用如下代码进行block方式的异步请求，在block中会传入请求到的返回数据和数据信息等参数： 1234567 NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; //其中的queue参数决定block中的代码在哪个队列中执行 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; NSLog(@&quot;%@&quot;,data); &#125;]; NSLog(@&quot;继续执行&quot;); 2.使用代理回调的异步请求方式首先遵守协议与生命一个可变的NSData用于接收数据： 12345@interface ViewController ()&lt;NSURLConnectionDataDelegate&gt;&#123; NSMutableData * _data;&#125;@end 使用如下的代码进行请求： 1234 _data = [[NSMutableData alloc]init]; NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [NSURLConnection connectionWithRequest:request delegate:self]; 请求发出后，会一次调用如下代理方法进行请求过程的监听和数据的获取： 12345678910111213141516-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; //开始接收数据 [_data setLength:0];&#125;-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; //正在接收数据 [_data appendData:data];&#125;-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; //接收数据失败 NSLog(@&quot;%@&quot;,error);&#125;-(void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; //接收数据完成 NSLog(@&quot;%@&quot;,_data);&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列四——进行数据与页面的绑定","slug":"174iOS中CoreData数据管理系列四——进行数据与页面的绑定","date":"2016-01-31T16:00:00.000Z","updated":"2023-04-14T11:50:08.332Z","comments":true,"path":"2016/02/01/174iOS中CoreData数据管理系列四——进行数据与页面的绑定/","link":"","permalink":"http://huishao.cc/2016/02/01/174iOS中CoreData数据管理系列四——进行数据与页面的绑定/","excerpt":"","text":"iOS中CoreData数据管理系列四——进行数据与页面的绑定一、引言在上一篇博客中，我们讨论了CoreData框架中添加与查询数据的操作，事实上，在大多数情况下，这些数据都是由一个UITableView表视图进行展示的，因此，CoreData框架中还未开发者提供了一个类NSFetchedResultsController，这个类作为桥接，将视图与数据进行绑定。 添加与查询数据操作：http://my.oschina.net/u/2340880/blog/611430。 二、进行数据初始化NSFetchedResultsController的初始化需要一个查询请求和一个数据操作上下文。代码示例如下： 12345678910111213141516171819202122232425262728293031//遵守协议@interface ViewController ()&lt;NSFetchedResultsControllerDelegate&gt;&#123; //数据桥接对象 NSFetchedResultsController * _fecCon;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //进行初始化操作 NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; NSPersistentStoreCoordinator * psc = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:mom]; NSURL * path =[NSURL fileURLWithPath:[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]]; [psc addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:path options:nil error:nil]; NSManagedObjectContext * moc = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType]; [moc setPersistentStoreCoordinator:psc]; NSFetchRequest * request = [NSFetchRequest fetchRequestWithEntityName:@&quot;SchoolClass&quot;]; //设置数据排序 [request setSortDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@&quot;stuNum&quot; ascending:YES]]]; //进行数据桥接对象的初始化 _fecCon = [[NSFetchedResultsController alloc]initWithFetchRequest:request managedObjectContext:moc sectionNameKeyPath:nil cacheName:nil]; //设置代理 _fecCon.delegate=self; //进行数据查询 [_fecCon performFetch:nil];&#125;@end 用于初始化NSFecthedResultsController的数据请求对象必须设置一个排序规则。在initWithFetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:方法中，如果设置第三个参数，则会以第三个参数为键值进行数据的分区。当数据发生变化时，将通过代理进行方法的回调。 三、与UITableView进行数据绑定12345678910111213141516171819-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cellid&quot;]; if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;cellid&quot;]; &#125; //获取相应数据模型 SchoolClass * obj = [_fecCon objectAtIndexPath:indexPath]; cell.textLabel.text = obj.name; cell.detailTextLabel.text = [NSString stringWithFormat:@&quot;有%@人&quot;,obj.stuNum]; return cell;&#125;-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return [_fecCon sections].count;&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; id&lt;NSFetchedResultsSectionInfo&gt; info = [_fecCon sections][section]; return [info numberOfObjects]; &#125; 效果如下： 四、将数据变化映射到视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//数据将要改变时调用的方法- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller&#123; //开启tableView更新预处理 [[self tableView] beginUpdates];&#125;//分区数据改变时调用的方法- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;NSFetchedResultsSectionInfo&gt;)sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type&#123; //判断行为类型 switch(type) &#123; //插入新分区 case NSFetchedResultsChangeInsert: [[self tableView] insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; //删除分区 case NSFetchedResultsChangeDelete: [[self tableView] deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; //移动分区 case NSFetchedResultsChangeMove: //更新分区 case NSFetchedResultsChangeUpdate: break; &#125;&#125;//数据改变时回调的代理- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath&#123; switch(type) &#123; //插入数据 case NSFetchedResultsChangeInsert: [[self tableView] insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade]; break; //删除数据 case NSFetchedResultsChangeDelete: [[self tableView] deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; break; //更新数据 case NSFetchedResultsChangeUpdate: [self reloadData]; break; //移动数据 case NSFetchedResultsChangeMove: [[self tableView] deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; [[self tableView] insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade]; break; &#125;&#125;//数据更新结束调用的代理- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller&#123; [[self tableView] endUpdates];&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列三——添加与查询数据","slug":"173iOS中CoreData数据管理系列三——添加与查询数据","date":"2016-01-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.331Z","comments":true,"path":"2016/01/29/173iOS中CoreData数据管理系列三——添加与查询数据/","link":"","permalink":"http://huishao.cc/2016/01/29/173iOS中CoreData数据管理系列三——添加与查询数据/","excerpt":"","text":"iOS中CoreData数据管理系列三——添加与查询数据一、引言在前两篇博客中，分别介绍了iOS中CoreData框架创建数据模型和CoreData框架中的三个核心类。博客地址如下： iOS中CoreData框架简介：http://my.oschina.net/u/2340880/blog/610488。 CoreData框架中三个核心的类：http://my.oschina.net/u/2340880/blog/610948。 本篇博客将综合使用三个核心的类，进行数据创建和查询的操作介绍。 二、建立数据对象类前面博客介绍的NSManagedObjectModel是数据管理模型，可以将其类比如数据库，NSManagedObjectModel中存放着数据库的结构信息。NSEntityDescription是实体描述对象，它可以类比如数据库中的表，NSEntityDescription存放的是表的结构信息。这些类都是一些抽象的结构类，并不存储实际每条数据的信息，具体的数据由NSManagedObject类来描述，我们一般会将实体类化继承于NSManagedObject。 Xocde工具提供了快捷的实体类化功能，还拿我们一开始创建的班级与学生实体来演示，点击.xcdatamodeld文件，点击Xcode工具上方导航栏的Editor标签，选择Creat NSManagedObject Subclass选项，在弹出的窗口中勾选要类化的实体，如下图： 这时，Xcode会自动为我们创建一个文件，这些文件中有各个类中属性的声明。 三、创建一条数据使用如下代码进行数据的创建： 12345678910111213141516171819202122232425262728293031323334 //读取数据模型文件 NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; //创建数据模型 NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; //创建持久化存储协调者 NSPersistentStoreCoordinator * psc = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:mom]; //数据库保存路径 NSURL * path =[NSURL fileURLWithPath:[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]]; //为持久化协调者添加一个数据接收栈 /* 可以支持的类型如下： NSString * const NSSQLiteStoreType;//sqlite NSString * const NSXMLStoreType;//XML NSString * const NSBinaryStoreType;//二进制 NSString * const NSInMemoryStoreType;//内存 */ [psc addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:path options:nil error:nil]; //创建数据管理上下文 NSManagedObjectContext * moc = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType]; //关联持久化协调者 [moc setPersistentStoreCoordinator:psc]; //创建数据对象 /* 数据对象的创建是通过实体名获取到的 */ SchoolClass * modelS = [NSEntityDescription insertNewObjectForEntityForName:@&quot;SchoolClass&quot; inManagedObjectContext:moc]; //对数据进行设置 modelS.name = @&quot;第一班&quot;; modelS.stuNum = @60; //进行存储 if ([moc save:nil]) &#123; NSLog(@&quot;新增成功&quot;); &#125; NSLog(@&quot;%@&quot;,[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]); 找到在打印出的路径，会发现里面多了一个sqlite文件，其中有一张表中添加进了一条数据。 四、查询数据CoreData中通过查询请求来对数据进行查询操作，查询请求由NSFetchRequest来进行管理和维护。 NSFetchRequest主要提供两个方面的查询服务： 1.提供范围查询的相关功能 2.提供查询结果返回类型与排序的相关功能 NSFetchRequest中常用方法如下： 12345678910111213141516171819202122//创建一个实体的查询请求 可以理解为在某个表中进行查询+ (instancetype)fetchRequestWithEntityName:(NSString*)entityName;//查询条件@property (nullable, nonatomic, strong) NSPredicate *predicate;//数据排序@property (nullable, nonatomic, strong) NSArray&lt;NSSortDescriptor *&gt; *sortDescriptors;//每次查询返回的数据条数@property (nonatomic) NSUInteger fetchLimit;//设置查询到数据的返回类型/*typedef NS_OPTIONS(NSUInteger, NSFetchRequestResultType) &#123; NSManagedObjectResultType = 0x00, NSManagedObjectIDResultType = 0x01, NSDictionaryResultType NS_ENUM_AVAILABLE(10_6,3_0) = 0x02, NSCountResultType NS_ENUM_AVAILABLE(10_6,3_0) = 0x04&#125;;*/@property (nonatomic) NSFetchRequestResultType resultType;//设置查询结果是否包含子实体@property (nonatomic) BOOL includesSubentities;//设置要查询的属性值@property (nullable, nonatomic, copy) NSArray *propertiesToFetch; 在SchoolClass实体中查询数据，使用如下的代码： 1234567 //创建一条查询请求 NSFetchRequest * request = [NSFetchRequest fetchRequestWithEntityName:@&quot;SchoolClass&quot;]; //设置条件为 stuNum=60的数据 [request setPredicate:[NSPredicate predicateWithFormat:@&quot;stuNum == 60&quot;]]; //进行查询操作 NSArray * res = [moc executeFetchRequest:request error:nil]; NSLog(@&quot;%@&quot;,[res.firstObject stuNum]); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列二——CoreData框架中三个重要的类","slug":"172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类","date":"2016-01-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.331Z","comments":true,"path":"2016/01/28/172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类/","link":"","permalink":"http://huishao.cc/2016/01/28/172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类/","excerpt":"","text":"iOS中CoreData数据管理系列二——CoreData框架中三个重要的类一、引言在上一篇博客中，介绍了iOS中使用CoreData框架设计数据模型的相关步骤。CoreData框架中通过相关的类将数据——数据模型——开发者无缝的衔接起来。NSManagedObjectModel对应数据模型，即上篇博客中我们创建的.xcdatamodeld文件；NSPersistentStoreCoordinator相当于数据库与数据模型之间的桥接器，通过NSPersistentStoreCoordinator将数据模型存入数据库；NSManagedObjectContext是核心的数据管理类，开发者通过操作它来执行对数据的相关操作。 二、数据模型管理类NSManagedObjectModel通过NSManagedObjectModel，可以将创建的数据模型文件读取为模型管理类对象，使用如下方法： 1234 //获取.xcdatamodeld文件url NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; //读取文件 NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; 其中还有一些属性和方法进行数据模型的管理： 123456789101112131415161718//将多个数据模型管理文件进行合并+ (nullable NSManagedObjectModel *)mergedModelFromBundles:(nullable NSArray&lt;NSBundle *&gt; *)bundles; //将多个数据模型管理类对象进行合并 + (nullable NSManagedObjectModel *)modelByMergingModels:(nullable NSArray&lt;NSManagedObjectModel *&gt; *)models;//存放数据中所有实体模型的字典 字典中是实体名和实体描述对象@property (readonly, copy) NSDictionary&lt;NSString *, NSEntityDescription *&gt; *entitiesByName;//存放数据中所有实体描述对象@property (strong) NSArray&lt;NSEntityDescription *&gt; *entities;//返回所有可用的配置名称@property (readonly, strong) NSArray&lt;NSString *&gt; *configurations;//获取关联某个配置的所有实体- (nullable NSArray&lt;NSEntityDescription *&gt; *)entitiesForConfiguration:(nullable NSString *)configuration;//为某个实体关联配置- (void)setEntities:(NSArray&lt;NSEntityDescription *&gt; *)entities forConfiguration:(NSString *)configuration;//创建请求模板- (void)setFetchRequestTemplate:(nullable NSFetchRequest *)fetchRequestTemplate forName:(NSString *)name;//获取请求模板- (nullable NSFetchRequest *)fetchRequestTemplateForName:(NSString *)name; 关于实体描述对象NSEntityDescription： 实体类似于数据库中的表结构，例如上次我们创建的班级实体模型，一个实体模型中可以添加许多属性与关系，NSEntityDescription对象中存放这些信息，常用如下： 1234567891011121314151617181920212223242526//实体所在的模型管理对象@property (readonly, assign) NSManagedObjectModel *managedObjectModel;//实体所在的模型管理对象的名称@property (null_resettable, copy) NSString *managedObjectClassName;//实体名@property (nullable, copy) NSString *name;//设置是否是抽象实体@property (getter=isAbstract) BOOL abstract;//子类实体字典@property (readonly, copy) NSDictionary&lt;NSString *, NSEntityDescription *&gt; *subentitiesByName;//所有子类实体对象数组@property (strong) NSArray&lt;NSEntityDescription *&gt; *subentities;//父类实体@property (nullable, readonly, assign) NSEntityDescription *superentity;//所有属性字典@property (readonly, copy) NSDictionary&lt;NSString *, __kindof NSPropertyDescription *&gt; *propertiesByName;//所有属性数组 @property (strong) NSArray&lt;__kindof NSPropertyDescription *&gt; *properties;//所有常类型属性@property (readonly, copy) NSDictionary&lt;NSString *, NSAttributeDescription *&gt; *attributesByName;//所有关系@property (readonly, copy) NSDictionary&lt;NSString *, NSRelationshipDescription *&gt; *relationshipsByName;//某个实体类型的所有关系- (NSArray&lt;NSRelationshipDescription *&gt; *)relationshipsWithDestinationEntity:(NSEntityDescription *)entity;//判断是否是某种实体- (BOOL)isKindOfEntity:(NSEntityDescription *)entity; NSPropertyDescription类是数据模型属性的父类，NSAttributeDescription和NSRelationshipDescription都是继承于NSPropertyDescription类，NSAttributeDescription描述正常类型的属性，NSRelationshipDescription用于描述自定义类型的关系。 三、持久化存储协调者类NSPersistentStoreCoordinatorNSPersistentStoreCoordinator建立数据模型与本地文件或数据库之间的联系，通过它将本地数据读入内存或者将修改过的临时数据进行持久化的保存。其初始化与链接数据持久化接收对象方法如下： 123456//通过数据模型管理对象进行初始化- (instancetype)initWithManagedObjectModel:(NSManagedObjectModel *)model；//添加一个持久化的数据接收对象- (nullable __kindof NSPersistentStore *)addPersistentStoreWithType:(NSString *)storeType configuration:(nullable NSString *)configuration URL:(nullable NSURL *)storeURL options:(nullable NSDictionary *)options error:(NSError **)error;//移除一个持久化的数据接收对象- (BOOL)removePersistentStore:(NSPersistentStore *)store error:(NSError **)error; 四、数据对象管理上下文NSManagedObjectContextNSManagedObjectContext是进行数据管理的核心类，我们通过这个类来进行数据的增删改查等操作。其中常用方法如下： 1234567891011121314151617181920212223242526272829303132//初始化方法 通过一个并发类型进行初始化 参数枚举如下：/*typedef NS_ENUM(NSUInteger, NSManagedObjectContextConcurrencyType) &#123; NSPrivateQueueConcurrencyType = 0x01,//上下文对象与私有队列关联 NSMainQueueConcurrencyType = 0x02//上下文对象与主队列关联&#125;;*/- (instancetype)initWithConcurrencyType:(NSManagedObjectContextConcurrencyType)ct;//异步执行block- (void)performBlock:(void (^)())block;//同步执行block- (void)performBlockAndWait:(void (^)())block;//关联数据持久化对象@property (nullable, strong) NSPersistentStoreCoordinator *persistentStoreCoordinator;//是否有未提交的更改@property (nonatomic, readonly) BOOL hasChanges;//进行查询数据请求- (nullable NSArray *)executeFetchRequest:(NSFetchRequest *)request error:(NSError **)error;//进行查询数据条数请求- (NSUInteger) countForFetchRequest: (NSFetchRequest *)request error: (NSError **)error ; //插入元素- (void)insertObject:(NSManagedObject *)object;//删除元素- (void)deleteObject:(NSManagedObject *)object;//回滚一步操作- (void)undo;//清楚缓存- (void)reset;//还原数据- (void)rollback;//提交保存数据- (BOOL)save:(NSError **)error; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列一——初识CoreData","slug":"171iOS中CoreData数据管理系列一——初识CoreData","date":"2016-01-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.331Z","comments":true,"path":"2016/01/27/171iOS中CoreData数据管理系列一——初识CoreData/","link":"","permalink":"http://huishao.cc/2016/01/27/171iOS中CoreData数据管理系列一——初识CoreData/","excerpt":"","text":"iOS中CoreData数据管理系列一——初识CoreData一、何为CoreDataCoreData是一个专门用来管理数据的框架，其在性能与书写方便上都有很大的优势，在数据库管理方面，apple强烈推荐开发者使用CoreData框架，在apple的官方文档中称，使用CoreData框架可以减少开发者50%——70%的代码量，这虽然有些夸张，但由此可见，CoreData的确十分强大。 二、设计数据模型在iOS开发中，时常使用SQL数据库对大量的表结构数据进行处理，但是SQL有一个十分明显的缺陷，对于常规数据模型的表，其处理起来是没问题的，例如一个班级表，其中每条数据中有班级名称，人数这样的属性，一个学生表，其中每条数据有学生的姓名，性别，年龄这样的属性。但是如果要在表与表之间建立联系，自定义对象与自定义对象之间产生从属关系，使用SQL处理起来就十分麻烦了，例如如果这个班级表中有一个班长的属性，这个属性是一个学生类型。关于iOS中SQL的使用相关博客，地址如下： Sqlite数据库相关知识：http://my.oschina.net/u/2340880/blog/600820 iOS中sqlite3框架的使用和封装：http://my.oschina.net/u/2340880/blog/601802 CoreData的一大优势即是其可以方便的在对象之间建立关系。 1.创建实体类型及其属性使用Xcode创建一个工程，在工程中新建一个文件，选择Core Data分类中的DataModel创建，如下图： 这时在Xcode的文件导航区会出现一个以xcdatamodeld为扩展名的文件，这个文件就是数据模型文件，点击Add Entity按钮添加一个实体类型，取名为SchoolClass，为这个类型添加两个属性，分别为名字name和学生数量stuNum，如下图: 2.对实体类型进行设置在Xcode右侧的工具栏中可以对实体类型进行一些设置，选中一个实体类型，如下图： Name设置实体类型的名称，Abstract Entity设置是否是抽象实体，如果勾选，则此实体不能被实例化，只能被继承，类似于抽象类，比如定义人为一个实体类型，在定义继承于人实体类型的老师、学生等来进行实例化。Parent Entity用来选择父类实体，Class用于设置对应的类的。 3.在实体对象之间建立关系再创建一个学生类实体Student，添加name和age两个属性。选中SchoolClass，在其中的Relationships模块中点击+号，来添加一个关系，如下图： 这时，SchoolClass实体类型中就有了一个Student类型的班长属性。如果切换一下编辑风格，可以更加清晰的看到实体类型之间的关系，如下图： 4.对属性和关系进行设置选中一个属性或者关系，在右侧的工具栏中可以对属性进行一些设置，如下图： name设置属性的名字，Optional类型代表可选，即在实例化对象时可以赋值也可以不赋值。Attribute设置属性的数据类型，Default Value设置数据的默认值。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中播放gif动态图的方式探讨","slug":"170iOS中播放gif动态图的方式探讨","date":"2016-01-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.331Z","comments":true,"path":"2016/01/24/170iOS中播放gif动态图的方式探讨/","link":"","permalink":"http://huishao.cc/2016/01/24/170iOS中播放gif动态图的方式探讨/","excerpt":"","text":"iOS中播放gif动态图的方式探讨一、引言在iOS开发中，UIImageView类专门来负责图片数据的渲染，并且UIImageView也有帧动画的方法来播放一组图片，但是对于gif类型的数据，UIImageView中并没有现成的接口提供给开发者使用，在iOS中一般可以通过两种方式来播放gif动态图，一种方式是通过ImageIO框架中的方法将gif文件中的数据进行解析，再使用coreAnimation核心动画来播放gif动画，另一种方式计较简单，可以直接通过webView来渲染gif图。 二、为原生的UIImageView添加类别来支持gif动态图的播放 gif动态图文件中包含了一组图片及其信息，信息主要记录着每一帧图片播放的时间，我们如果获取到了gif文件中所有的图片同时又获取到每一帧图片播放的时间，就可以为UIImageView添加核心动画的方法来让其播放gif的内容了。 首先解析gif文件中的数据，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//要引入ImageIO库#import &lt;ImageIO/ImageIO.h&gt;//解析gif文件数据的方法 block中会将解析的数据传递出来-(void)getGifImageWithUrk:(NSURL *)url returnData:(void(^)(NSArray&lt;UIImage *&gt; * imageArray, NSArray&lt;NSNumber *&gt;*timeArray, CGFloat totalTime, NSArray&lt;NSNumber *&gt;* widths, NSArray&lt;NSNumber *&gt;* heights))dataBlock&#123; //通过文件的url来将gif文件读取为图片数据引用 CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)url, NULL); //获取gif文件中图片的个数 size_t count = CGImageSourceGetCount(source); //定义一个变量记录gif播放一轮的时间 float allTime=0; //存放所有图片 NSMutableArray * imageArray = [[NSMutableArray alloc]init]; //存放每一帧播放的时间 NSMutableArray * timeArray = [[NSMutableArray alloc]init]; //存放每张图片的宽度 （一般在一个gif文件中，所有图片尺寸都会一样） NSMutableArray * widthArray = [[NSMutableArray alloc]init]; //存放每张图片的高度 NSMutableArray * heightArray = [[NSMutableArray alloc]init]; //遍历 for (size_t i=0; i&lt;count; i++) &#123; CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL); [imageArray addObject:(__bridge UIImage *)(image)]; CGImageRelease(image); //获取图片信息 NSDictionary * info = (__bridge NSDictionary*)CGImageSourceCopyPropertiesAtIndex(source, i, NULL); CGFloat width = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelWidth] floatValue]; CGFloat height = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelHeight] floatValue]; [widthArray addObject:[NSNumber numberWithFloat:width]]; [heightArray addObject:[NSNumber numberWithFloat:height]]; NSDictionary * timeDic = [info objectForKey:(__bridge NSString *)kCGImagePropertyGIFDictionary]; CGFloat time = [[timeDic objectForKey:(__bridge NSString *)kCGImagePropertyGIFDelayTime]floatValue]; allTime+=time; [timeArray addObject:[NSNumber numberWithFloat:time]]; CFRelease(info); &#125; CFRelease(source); dataBlock(imageArray,timeArray,allTime,widthArray,heightArray);&#125; 为UIImageView添加一个设置gif图内容的方法： 1234567891011121314151617181920212223-(void)yh_setImage:(NSURL *)imageUrl&#123; __weak id __self = self; [self getGifImageWithUrk:imageUrl returnData:^(NSArray&lt;UIImage *&gt; *imageArray, NSArray&lt;NSNumber *&gt; *timeArray, CGFloat totalTime, NSArray&lt;NSNumber *&gt; *widths, NSArray&lt;NSNumber *&gt; *heights) &#123; //添加帧动画 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;contents&quot;]; NSMutableArray * times = [[NSMutableArray alloc]init]; float currentTime = 0; //设置每一帧的时间占比 for (int i=0; i&lt;imageArray.count; i++) &#123; [times addObject:[NSNumber numberWithFloat:currentTime/totalTime]]; currentTime+=[timeArray[i] floatValue]; &#125; [animation setKeyTimes:times]; [animation setValues:imageArray]; [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]]; //设置循环 animation.repeatCount= MAXFLOAT; //设置播放总时长 animation.duration = totalTime; //Layer层添加 [[(UIImageView *)__self layer]addAnimation:animation forKey:@&quot;gifAnimation&quot;]; &#125;];&#125; 使用代码示例如下： 1234 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0,0 , 320, 200)]; NSURL * url = [[NSURL alloc]initFileURLWithPath:[[NSBundle mainBundle] pathForResource:imageName ofType:nil]]; [imageView yh_setImage:url]; [self.view addSubview:imageView]; 三、使用UIWebView来加载gif动态图数据iOS中的UIWebView功能十分强大，可以通过UIWebView为载体，来展示gif图。并且这种方法也十分简单，代码如下： 12345678910 //读取gif数据 NSData *gifData = [NSData dataWithContentsOfURL:imageUrl]; UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)]; //取消回弹效果 webView.scrollView.bounces=NO; webView.backgroundColor = [UIColor clearColor]; //设置缩放模式 webView.scalesPageToFit = YES; //用webView加载数据 [webView loadData:gifData MIMEType:@&quot;image/gif&quot; textEncodingName:nil baseURL:nil]; 四、两种加载gif动态图方式的优劣经过测试，从加载速度上来说，通过UIImageView类别加载的方式更加快速，UIWebView的方式加载时间会稍长，但是从性能上来比较，WebView的方式性能更优，播放的gif动态图更加流畅。在开发中，可以根据需求，适当选择，例如虽然WebView加载的方式性能更好，但是在许多情况下，原生的UIImageView能够更加自由的让开发者进行扩展。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"使用iOS原生sqlite3框架对sqlite数据库进行操作","slug":"169使用iOS原生sqlite3框架对sqlite数据库进行操作","date":"2016-01-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.330Z","comments":true,"path":"2016/01/13/169使用iOS原生sqlite3框架对sqlite数据库进行操作/","link":"","permalink":"http://huishao.cc/2016/01/13/169使用iOS原生sqlite3框架对sqlite数据库进行操作/","excerpt":"","text":"使用iOS原生sqlite3框架对sqlite数据库进行操作一、引言sqlite数据库是一种小型数据库，由于其小巧与简洁，在移动开发领域应用深广，sqlite数据库有一套完备的sqlite语句进行管理操作，一些常用的语句和可视化的开发工具在上篇博客中有介绍，地址如下： sqlite数据库常用语句及可视化工具介绍：http://my.oschina.net/u/2340880/blog/600820。 在iOS的原生开发框架中可以对sqlite数据库进行很好的支持，这个框架中采用C风格且通过指针移动进行数据的操作，使用起来有些不便，我们可以对一些数据库的常用操作进行一些面向对象的封装。 二、libsqlite3系统库中操作数据库的常用方法libsqlite3是对sqlite数据库进行操作的系统库，在使用前，我们需要先导入，点击Xcode的Build Phases标签，展开Link Binary With Libraries，点击+号，在弹出的窗口中搜索libsqlite3.0，将其导入进工程，过程如下图： 在需要操作sqlite数据的文件中导入如下头文件： 1#import &lt;sqlite3.h&gt; 数据库文件的操作是由一个sqlite3类型的指针操作管理的，如下方法进行数据库的打开： 12sqlite3 *sqlite；sqlite3_open(dataBaePath, &amp;sqlite) sqlite3_open方法返回一个int值，实际上，在使用libsqlite3框架中的大多方法时都会返回一个int值，这个int值代表着方法执行的相应结果状态，这些状态再sqlite3.h文件中通过宏来定义，列举如下： 1234567891011121314151617181920212223242526272829303132#define SQLITE_OK 0 //操作成功/* 以下是错误代码 */#define SQLITE_ERROR 1 /* SQL数据库错误或者丢失*/#define SQLITE_INTERNAL 2 /* SQL内部逻辑错误 */#define SQLITE_PERM 3 /* 没有访问权限 */#define SQLITE_ABORT 4 /* 回调请求终止 */#define SQLITE_BUSY 5 /* 数据库文件被锁定 */#define SQLITE_LOCKED 6 /* 数据库中有表被锁定 */#define SQLITE_NOMEM 7 /* 分配空间失败 */#define SQLITE_READONLY 8 /* 企图向只读属性的数据库中做写操作 */#define SQLITE_INTERRUPT 9 /* 通过sqlite3_interrupt()方法终止操作*/#define SQLITE_IOERR 10 /* 磁盘发生错误 */#define SQLITE_CORRUPT 11 /* 数据库磁盘格式不正确 */#define SQLITE_NOTFOUND 12 /* 调用位置操作码 */#define SQLITE_FULL 13 /* 由于数据库已满造成的添加数据失败 */#define SQLITE_CANTOPEN 14 /* 不法打开数据库文件 */#define SQLITE_PROTOCOL 15 /* 数据库锁协议错误 */#define SQLITE_EMPTY 16 /* 数据库为空 */#define SQLITE_SCHEMA 17 /* 数据库模式更改 */#define SQLITE_TOOBIG 18 /* 字符或者二进制数据超出长度 */#define SQLITE_CONSTRAINT 19 /* 违反协议终止 */#define SQLITE_MISMATCH 20 /* 数据类型不匹配 */#define SQLITE_MISUSE 21 /* 库使用不当 */#define SQLITE_NOLFS 22 /* 使用不支持的操作系统 */#define SQLITE_AUTH 23 /* 授权拒绝 */#define SQLITE_FORMAT 24 /* 辅助数据库格式错误 */#define SQLITE_RANGE 25 /* sqlite3_bind 第二个参数超出范围 */#define SQLITE_NOTADB 26 /* 打开不是数据库的文件 */#define SQLITE_NOTICE 27 /* 来自sqlite3_log()的通知 */#define SQLITE_WARNING 28 /* 来自sqlite3_log() 的警告*/#define SQLITE_ROW 100 /* sqlite3_step() 方法准备好了一行数据 */#define SQLITE_DONE 101 /* sqlite3_step() 已完成执行*/ 执行非查询类的语句，例如创建，添加，删除等操作，使用如下方法： 123char * err;sqlite3 *sql;sqlite3_exec(sql, sqlStr, NULL, NULL, &amp;err); sqlite3_exec方法中第一个参数为成功执行了打开数据库操作的sqlite3指针，第二个参数为要执行的sql语句，最后一个参数为错误信息字符串。 执行查询语句的方法比较复杂，通过如下方法: 123456789 sqlite3 * sqlite; sqlite3_stmt *stmt =nil; int code = sqlite3_prepare_v2(sqlite, sqlStr, -1, &amp;stmt, NULL); while (sqlite3_step(stmt)==SQLITE_ROW) &#123; char * cString =(char*)sqlite3_column_text(stmt, 0); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; NSNumber * value = [NSNumber numberWithLongLong:sqlite3_column_int64(stmt, 1)]; &#125; sqlite3_finalize(stmt); stmt是一个数据位置指针，标记查询到数库的数据位置，sqlite3_prepare_v2()方法进行数据库查询的准备工作，第一个参数为成功打开的数据库指针，第二个参数为要执行的查询语句，第三个参数为sqlite3_stmt指针的地址，这个方法也会返回一个int值，作为标记状态是否成功。 sqlite3_step方法对stmt指针进行移动，会逐行进行移动，这个方法会返回一个int值，如果和SQLITE_ROW宏对应，则表明有此行数据，可以通过while循环来对数据进行读取。 sqlite3_column_XXX()是取行中每一列的数据，根据数据类型的不同，sqlite3_column_XXX()有一系列对应的方法，这个方法中第一个参数是stmt指针，第二个参数为列序号。 sqlite3_finalize()方法对stmt指针进行关闭。 三、面向对象的sqlite数据库操作框架封装网上不乏有许多优秀的第三方sqlite数据库使用框架，FFDM就是其中之一，并且apple自带的coreData也十分优秀。这篇博客中所述内容并不全面，代码也并不十分完善健壮，封装出来的代码除了能够完成基本的数据库操作外，更多主要是对设计思路的示例。 1.面向对象的sqlite管理类的设计思路为了便于使用，在设计时，我们尽量将libsqlite3中的方法不暴漏在使用层，通过面向应用的接口来进行方法的设计，设计思路类图如下： 图中，文件管理中心对文件进行存取删改管理，不暴漏在外，数据库管理中心负责对数据库的创建，删除打开等操作，具体的数据操作由数据库操作对象来完成。 2.文件管理中心方法的编写文件管理中心主要负责对数据库文件的存取，可以实现如下方法： YHBaseCecheCenter.h 12345678910111213141516/** * @brief 获取数据库方法的地址 * * @return 地址字符串 * */-(NSString *)getDataBaseFilePath;/** * @brief 获取某个数据库的大小 * * @param name 数据库名称 * * @return 文件大小 单位M * */-(float)getSizeFromDataBaseName:(NSString *)name; YHBaseCecheCenter.m 123456789101112131415-(NSString *)getDataBaseFilePath&#123; return NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;&#125;-(float)getSizeFromDataBaseName:(NSString *)name&#123; NSString * path = [NSString stringWithFormat:@&quot;/%@/%@&quot;,NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject,name]; return [self fileSizeAtPath:path]/(1024.0*1024.0);&#125;//获取文件大小- (long long) fileSizeAtPath:(NSString*) filePath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath])&#123; return [[manager attributesOfItemAtPath:filePath error:nil] fileSize]; &#125; return 0;&#125; 在iOS系统中因为其沙盒结构的限制，数据库必须方法documents目录下才能正常打开使用。 3.数据库管理中心的设计数据库管理中心主要负责对数据库的宏观操作，采用类方法的设计模式，如下 YHBaseSQLiteManager.h 123456789101112131415161718192021222324252627282930/** * @brief 打开一个数据库 如果不存在则会创建 * * @param name 数据库名称 * * @return 数据库操作对象 如果创建失败会返回nil * */+(YHBaseSQLiteContext *)openSQLiteWithName:(NSString *)name;/** * @brief 获取数据库文件的大小 单位M * * @param dataBase 数据库上下文对象 * * @return 数据库文件大小 */+(float)getSizeOfDataBase:(YHBaseSQLiteContext *)dataBase;/** * @brief 获取数据库文件的大小 单位M * * @param dataBaseName 数据库名称 * * @return 数据库文件大小 */+(float)getSizeOfDataBaseName:(NSString *)dataBaseName;/** * @brief 删除所有数据库 * */+(void)removeDataBase; YHBaseSQLiteManager.m 12345678910111213141516171819202122+(YHBaseSQLiteContext *)openSQLiteWithName:(NSString *)name&#123; NSString * path = [[YHBaseCecheCenter sharedTheSingletion]getDataBaseFilePath]; YHBaseSQLiteContext * context = [[YHBaseSQLiteContext alloc]init]; context.name = name; BOOL success = [context openDataBaeWithName:[NSString stringWithFormat:@&quot;%@/%@&quot;,path,name]]; if (success) &#123; return context; &#125;else&#123; return nil; &#125;&#125;+(float)getSizeOfDataBase:(YHBaseSQLiteContext *)dataBase&#123; return [[YHBaseCecheCenter sharedTheSingletion]getSizeFromDataBaseName:dataBase.name];&#125;+(float)getSizeOfDataBaseName:(NSString *)dataBaseName&#123; return [[YHBaseCecheCenter sharedTheSingletion]getSizeFromDataBaseName:dataBaseName];&#125;+(void)removeDataBase&#123; NSString * path = [[YHBaseCecheCenter sharedTheSingletion]getDataBaseFilePath]; return [[YHBaseCecheCenter sharedTheSingletion]removeCacheFromPath:path];&#125; 4.数据库操作对象将操作数据库的核心方法封装在这个类中： YHBaseSQLiteContext.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** *操作的数据库名称 */@property(nonatomic,strong)NSString * name;/** *内含sqlite3 对象 */@property(nonatomic,assign)sqlite3 * sqlite3_db;/** * @brief 打开一个数据库 不存在则创建 * * @param path 数据库路径 * * @return 是否操作成功 */-(BOOL)openDataBaeWithName:(NSString *)path;/** * @brief 再数据库中创建一张表 如果已经存在 会返回错误信息 * * @param name 表的名称 * * @prarm dic 表中的键 其中字典中需传入 键名：类型 类型的宏定义在YHBaseSQLTypeHeader.h中 * * @param callBack 结果回调 */-(void)createTableWithName:(NSString *)name keysDictionary:(NSDictionary&lt;NSString*,NSString*&gt; *) dic callBack:(void (^)(YHBaseSQLError * error))complete;/** * @brief 向表中添加一条数据 * * @param dataDic 添加数据的键值对 * * @param name 插入表的名称 * * @complete 回调 */-(void)insertData:(NSDictionary&lt;NSString *,id&gt;*)dataDic intoTable:(NSString *)name callBack:(void (^)(YHBaseSQLError * error))complete;/** * @brief 向表中添加一个键 * * @param kName 添加的键 * * @prarm type 类型 * * @prarm tableName 表名称 * * @prarm complete 结果回调 */-(void)addKey:(NSString *)kName keyType:(NSString *)type intoTable:(NSString *)tableName callBack:(void(^)(YHBaseSQLError *error))complete;/** * @brief 修改数据 * * @param dataDic 新的键值 * * @param wlStr 条件字符串 一般通过主键找到对应数据修改 可以为nil * * @param complete 结果回调 */-(void)update:(NSDictionary&lt;NSString*,id&gt; *)dataDic inTable:(NSString *)tableName whileString:(NSString *)wlStr callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 删除数据 * * @param tableName 表名 * * @param wlStr 条件字符串 一般通过主键找到对应数据删除 可以为nil 不传这个参数将删除所有数据 * */-(void)deleteDataFromTable:(NSString *)tableName whereString:(NSString *)wlStr callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 删除一张表 * * @param tableName 表名 * */-(void)dropTable:(NSString *)tableName callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 查询数据 * * @param keys 要查询的键值 及其对应的数据类型 可以为nil则查询全部 * * @param tableName 表名 * * @param orderKey 进行排序的键值 可以为nil 则不排序 * * @param type 排序方式 在YHBaseSQLTypeHeader中有宏定义 * * @param wlstr 查询条件 同于查询单个数据 * * @param complete dataArray为查询到的数据 其内为字典 * */-(void)selectKeys:(NSArray&lt;NSDictionary *&gt; *)keys fromTable:(NSString*)tableName orderBy:(NSString *)orderKey orderType:(NSString *)type whileStr:(NSString *)wlstr callBack:(void(^)(NSArray&lt;NSDictionary *&gt; * dataArray,YHBaseSQLError * error))complete;/** * @brief 关闭数据库上下文操作 * 调用此方法后 这个context对象将不再有效 如果再需要使用 需要YHBaseSQLiteManager中的类方法再次返回 */-(void)closeContext; YHBaseSQLiteContext.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262-(BOOL)openDataBaeWithName:(NSString *)path&#123; if (sqlite3_open([path UTF8String], &amp;_sqlite3_db)!=SQLITE_OK) &#123; sqlite3_close(_sqlite3_db); _sqlite3_db=nil; return NO; &#125;else&#123; return YES; &#125;&#125;-(void)createTableWithName:(NSString *)name keysDictionary:(NSDictionary&lt;NSString *,NSString *&gt; *)dic callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * keys = [[NSMutableString alloc]init]; for (int i=0; i&lt;dic.allKeys.count; i++) &#123; NSString * key = dic.allKeys[i]; if (i&lt;dic.allKeys.count-1) &#123; [keys appendFormat:@&quot;%@ %@,&quot;,key,[dic objectForKey:key]]; &#125;else&#123; [keys appendFormat:@&quot;%@ %@&quot;,key,[dic objectForKey:key]]; &#125; &#125; NSString * sqlStr = [NSString stringWithFormat:@&quot;create table %@(%@)&quot;,name,keys]; [self runSQL:sqlStr callBack:^(YHBaseSQLError * error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)insertData:(NSDictionary&lt;NSString *,id&gt; *)dataDic intoTable:(NSString *)name callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * keys = [[NSMutableString alloc]init]; NSMutableString * values = [[NSMutableString alloc]init]; for (int i=0; i&lt;dataDic.allKeys.count; i++) &#123; NSString * key = dataDic.allKeys[i]; if (i&lt;dataDic.count-1) &#123; [keys appendFormat:@&quot;%@,&quot;,key]; [values appendFormat:@&quot;\\&quot;%@\\&quot;,&quot;,[dataDic objectForKey:key]]; &#125;else&#123; [keys appendFormat:@&quot;%@&quot;,key]; [values appendFormat:@&quot;\\&quot;%@\\&quot;&quot;,[dataDic objectForKey:key]]; &#125; &#125; NSString * sqlStr = [NSString stringWithFormat:@&quot;insert into %@(%@) values(%@)&quot;,name,keys,values]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)addKey:(NSString *)kName keyType:(NSString *)type intoTable:(NSString *)tableName callBack:(void (^)(YHBaseSQLError *))complete&#123; NSString * sqlStr = [NSString stringWithFormat:@&quot;alter table %@ add %@ %@&quot;,tableName,kName,type]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)update:(NSDictionary&lt;NSString *,id&gt; *)dataDic inTable:(NSString *)tableName whileString:(NSString *)wlStr callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;update %@ set &quot;,tableName]; for (int i=0; i&lt;dataDic.allKeys.count; i++) &#123; NSString * key = dataDic.allKeys[i]; if (i&lt;dataDic.allKeys.count-1) &#123; [sqlStr appendFormat:@&quot;%@=\\&quot;%@\\&quot;,&quot;,key,[dataDic objectForKey:key]]; &#125;else&#123; [sqlStr appendFormat:@&quot;%@=\\&quot;%@\\&quot;&quot;,key,[dataDic objectForKey:key]]; if (wlStr!=nil) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlStr]; &#125; &#125; &#125; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)deleteDataFromTable:(NSString *)tableName whereString:(NSString *)wlStr callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;delete from %@&quot;,tableName]; if (wlStr!=nil) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlStr]; &#125; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)dropTable:(NSString *)tableName callBack:(void (^)(YHBaseSQLError *))complete&#123; NSString * sqlStr = [NSString stringWithFormat:@&quot;drop table %@&quot;,tableName]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)selectKeys:(NSArray&lt;NSDictionary *&gt; *)keys fromTable:(NSString *)tableName orderBy:(NSString *)orderKey orderType:(NSString *)type whileStr:(NSString *)wlstr callBack:(void (^)(NSArray&lt;NSDictionary *&gt; *, YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;select&quot;]; if (keys==nil||keys.count==0) &#123; [sqlStr appendFormat:@&quot; * from %@&quot;,tableName]; &#125;else&#123; for (int i=0; i&lt;keys.count; i++) &#123; if (i&lt;keys.count-1) &#123; [sqlStr appendFormat:@&quot; %@,&quot;,keys[i].allKeys.firstObject]; &#125;else&#123; [sqlStr appendFormat:@&quot; %@ from %@&quot;,keys[i].allKeys.firstObject,tableName]; &#125; &#125; &#125; if (wlstr) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlstr]; &#125; if (orderKey) &#123; [sqlStr appendFormat:@&quot; order by %@&quot;,orderKey]; &#125; if (type) &#123; [sqlStr appendFormat:@&quot; %@&quot;,type]; &#125; NSMutableArray * keysArr = [[NSMutableArray alloc]init]; NSMutableArray * keysTypeArr = [[NSMutableArray alloc]init]; if (keys==nil||keys.count==0) &#123; NSArray&lt;NSDictionary *&gt; * tmpArr = [self getTheTableAllKeys:tableName]; for (int i=0; i&lt;tmpArr.count; i++) &#123; NSString * key = tmpArr[i].allKeys.firstObject; [keysArr addObject:key]; [keysTypeArr addObject:[tmpArr[i] objectForKey:key]]; &#125; &#125;else&#123; for (int i=0; i&lt;keys.count; i++) &#123; NSString * key = keys[i].allKeys.firstObject; [keysArr addObject:key]; [keysTypeArr addObject:[keys[i] objectForKey:key]]; &#125; &#125; [self runSelectSQL:sqlStr withKeys:keysArr withDataType:keysTypeArr callBack:^(NSArray&lt;NSDictionary *&gt; *dataArray, YHBaseSQLError *error) &#123; if (complete) &#123; complete(dataArray,error); &#125; &#125;]; &#125;-(void)closeContext&#123; sqlite3_close(_sqlite3_db); _sqlite3_db = nil;&#125;//内部方法 运行创建独立的非查询SQL语句-(void)runSQL:(NSString *)sql callBack:(void(^)(YHBaseSQLError * error))complete&#123; char * err; int code = sqlite3_exec(_sqlite3_db, [sql UTF8String], NULL, NULL, &amp;err); if (code!=SQLITE_OK) &#123; YHBaseSQLError * error = [[YHBaseSQLError alloc]init]; error.errorInfo = [NSString stringWithCString:err encoding:NSUTF8StringEncoding]; error.errorCode = code; complete(error); &#125;else&#123; complete(nil); &#125;&#125;//运行查询语句-(void)runSelectSQL:(NSString *)sql withKeys:(NSArray *)keys withDataType:(NSArray *)dataType callBack:(void(^)(NSArray&lt;NSDictionary *&gt; * dataArray, YHBaseSQLError * error))complete&#123; sqlite3_stmt *stmt =nil; int code = sqlite3_prepare_v2(_sqlite3_db, [sql UTF8String], -1, &amp;stmt, NULL); if (code!=SQLITE_OK) &#123; YHBaseSQLError * error = [[YHBaseSQLError alloc]init]; error.errorInfo = @&quot;查询失败&quot;; error.errorCode=code; complete(nil,error); &#125;else&#123; NSMutableArray * resultArray = [[NSMutableArray alloc]init]; while (sqlite3_step(stmt)==SQLITE_ROW) &#123; //数据类型的分别解析 NSMutableDictionary * dic = [[NSMutableDictionary alloc]init]; for (int i=0; i&lt;dataType.count; i++) &#123; NSString * type = dataType[i]; if ([type isEqualToString:YHBASE_SQL_DATATYPE_BINARY]) &#123; int length = sqlite3_column_bytes(stmt, i); const void *data = sqlite3_column_blob(stmt, i); NSData * value = [NSData dataWithBytes:data length:length]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_BLOB])&#123; int length = sqlite3_column_bytes(stmt, i); const void *data = sqlite3_column_blob(stmt, i); NSData * value = [NSData dataWithBytes:data length:length]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_BOOLEAN])&#123; NSNumber * value = [NSNumber numberWithInt:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_CURRENCY])&#123; NSNumber * value = [NSNumber numberWithLong:sqlite3_column_int64(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_DATE])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_DOUBLE])&#123; NSNumber * value = [NSNumber numberWithFloat:sqlite3_column_double(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_FLOAT])&#123; NSNumber * value = [NSNumber numberWithFloat:sqlite3_column_double(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_INTRGER])&#123; NSNumber * value = [NSNumber numberWithInt:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_REAL])&#123; NSNumber * value = [NSNumber numberWithDouble:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_SMALLINT])&#123; NSNumber * value = [NSNumber numberWithShort:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TEXT])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TIME])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TIMESTAMP])&#123; NSNumber * value = [NSNumber numberWithLongLong:sqlite3_column_int64(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_VARCHAR])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125; &#125; [resultArray addObject:dic]; &#125; sqlite3_finalize(stmt); stmt=nil; complete(resultArray,nil); &#125;&#125;//获取表中所有字段名和类型-(NSArray&lt;NSDictionary *&gt; *)getTheTableAllKeys:(NSString *)tableName&#123; NSMutableArray * array = [[NSMutableArray alloc]init]; NSString * getColumn = [NSString stringWithFormat:@&quot;PRAGMA table_info(%@)&quot;,tableName]; sqlite3_stmt *statement; sqlite3_prepare_v2(_sqlite3_db, [getColumn UTF8String], -1, &amp;statement, nil); while (sqlite3_step(statement) == SQLITE_ROW) &#123; char *nameData = (char *)sqlite3_column_text(statement, 1); NSString *columnName = [[NSString alloc] initWithUTF8String:nameData]; char *typeData = (char *)sqlite3_column_text(statement, 2); NSString *columntype = [NSString stringWithCString:typeData encoding:NSUTF8StringEncoding]; NSDictionary * dic = @&#123;columnName:columntype&#125;; [array addObject:dic]; &#125; sqlite3_finalize(statement); statement=nil; return array;&#125; 5.错误信息类可以将数据库操作中的异常抛出提示开发者YHBaseSQLError.h 12345678/** *异常的提示信息 */__PROPERTY_NO_STRONG__(NSString *, errorInfo);/** *异常的对应code码 */__PROPERTY_NO_ASSIGN__(NSInteger, errorCode); 还有一个头文件中定义了sqlite数据库支持的数据类型和排序宏定义： YHBaseSQLTypeHeader.h 1234567891011121314151617#define YHBASE_SQL_DATATYPE_SMALLINT @&quot;smallint&quot; //short#define YHBASE_SQL_DATATYPE_INTRGER @&quot;integer&quot; //int#define YHBASE_SQL_DATATYPE_REAL @&quot;real&quot; //实数#define YHBASE_SQL_DATATYPE_FLOAT @&quot;float&quot; //float#define YHBASE_SQL_DATATYPE_DOUBLE @&quot;double&quot; //double#define YHBASE_SQL_DATATYPE_CURRENCY @&quot;currency&quot; //long#define YHBASE_SQL_DATATYPE_VARCHAR @&quot;varchar&quot; //char#define YHBASE_SQL_DATATYPE_TEXT @&quot;text&quot; //string#define YHBASE_SQL_DATATYPE_BINARY @&quot;binary&quot; //二进制#define YHBASE_SQL_DATATYPE_BLOB @&quot;blob&quot; //长二进制#define YHBASE_SQL_DATATYPE_BOOLEAN @&quot;boolean&quot; //bool#define YHBASE_SQL_DATATYPE_DATE @&quot;date&quot; //日期#define YHBASE_SQL_DATATYPE_TIME @&quot;time&quot; //时间#define YHBASE_SQL_DATATYPE_TIMESTAMP @&quot;timestamp&quot;//时间戳#define YHBASE_SQL_ORDERTYPE_ASC @&quot;asc&quot; //升序#define YHBASE_SQL_ORDERTYPE_DESC @&quot;desc&quot; //降序 四、使用在使用时，直接调用context的相应方法操作数据库即可，例如： 12345678YHBaseSQLiteContext * context = [YHBaseSQLiteManager openSQLiteWithName:@&quot;testDataBase&quot;]; if (context) &#123; [context selectKeys:nil fromTable:@&quot;MySQL&quot; orderBy:@&quot;age&quot; orderType:YHBASE_SQL_ORDERTYPE_DESC whileStr:@&quot;age&gt;18&quot; callBack:^(NSArray&lt;NSDictionary *&gt; *dataArray, YHBaseSQLError *error) &#123; NSLog(@&quot;%@&quot;,dataArray); NSLog(@&quot;%@&quot;,error.errorInfo); [context closeContext]; &#125;]; &#125; 上面的代码将查询textDataBase数据库中MySQL表里所有age列大于18的数据，并按照age从小到大进行排序，数据结果在回调的dataArray中。 外：完整的代码在下面的git地址中，这个git项目是一个基础的开发框架，里面封装了许多开发和调试常用功能，代码不完善之处，希望多多交流，QQ316045346. git：https://github.com/ZYHshao/YHBaseFoundationTest。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用","slug":"168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用","date":"2016-01-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.330Z","comments":true,"path":"2016/01/11/168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用/","link":"","permalink":"http://huishao.cc/2016/01/11/168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用/","excerpt":"","text":"SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用一、引言在移动开发中，通常会用到一些小型的数据库进行数据管理。SQLite是一款十分小巧便捷的数据库，在iOS开发中，原生框架也对其有很好的支持。 二、SQLite常用语句数据库存在的意义就在于其对数据的整合和管理，所以数据库的核心操作无非是对数据进行增，删，改，查得操作。 1.建立数据表语句一个数据库文件中可以由一些表组成，通过下面的语句在数据库文件中创建一张表： 1create table class(num integer PRIMARY KEY,name text NOT NULL DEFAULT &quot;1班&quot;,count integer CHECK(count&gt;10)) 上面的语句代码可以简化成如下的格式： create table 表名(参数名1 类型 修饰条件，参数名2，类型 修饰参数，···) sqlite中支持如下的类型： smallint 短整型 integer 整型 real 实数型 float 单精度浮点 double 双精度浮点 currency 长整型 varchar 字符型 text 字符串 binary 二进制数据 blob 二进制大对象 boolean 布尔类型 date 日期类型 time 时间类型 timestamp 时间戳类型 关于修饰条件，常用的有如下几种： PRIMARY KEY：将本参数这个为主键，主键的值必须唯一，可以作为数据的索引，例如编号。 NOT NULL ：标记本参数为非空属性。 UNIQUE：标记本参数的键值唯一，类似主键。 DEFAULT:设置本参数的默认值 CHECK：参数检查条件，例如上面代码，写入数据是count必须大于时才有效。 2.添加数据使用下面的语句来进行数据行的添加操作： 1insert into class(num,name,count) values(2,&quot;三年2班&quot;,58) 上面的语句代码可以简化成如下格式： insert into 表名(键1，键2，···) values(值1，值2，···) 使用下面的语句进行数据列的添加，即添加一个新的键： 1alter table class add new text alter table 表名 add 键名 键类型 3.修改数据使用如下语句来进行改操作： 1update class set num=3,name=&quot;新的班级&quot; where num=1 update 表名 set 键1=值1，键2=值2 where 条件 where后面添加修改数据的条件，例如上面代码修改num为1的班级的名字和mun值。 4.删除数据1delete from class where num=1 delete from 表名 where 条件 上面代码删除num为1的一条数据。 删除一张表适用下面的语句： 1drop table class drop table 表名 5.查询操作查询操作是数据库的核心功能，sqlite的许多查询命令可以快捷的完成复杂的查询功能。 查询表中某些键值： 1select num from class select 键名，键名··· from 表名 查询全部键值数据： 1select * from class select * from 表名 *是一个全通配符，代表不限个数任意字符 查询排序： 1select * from class order by count asc select 键名，键名，··· from 表名 order by 键名 排序方式 order by 后面写要进行排序的键名，排序方式有 asc升序 desc降序 查找数据条数与查找位置限制： 1select * from class limit 2 offset 0 select 键名 from 表名 limit 最大条数 offset 查询起始位置 条件查询： 1select * from class where num&gt;2 select 键名 from 表名 where 条件 查询数据条数： 1select count(*) from class select count(键名) from 表名 去重查询： 1select distinct num from class select distinct 键名 from 表名 三、MesaSQLite的简单使用MesaSQLite是一款可视化的SQLite数据库编辑软件，使用十分方便。如下地址是下载链接：[http://pan.baidu.com/s/1sjW6DC5](http://pan.baidu.com/s/1sjW6DC5)。 1.创建数据库文件打开MesaSQLite软件，在导航栏中选择File，选择弹出菜单中的New DataBase创建一个新的数据库文件，也可以选择Open Database打开一个数据库。 注意：默认创建的数据库文件为rdb格式，手动改成db格式即可。 2.创建表MesaSQLite有两种方式对数据库进行操作，一种是通过sql语句，一种是通过可视化的界面。在SQL Query工具窗口中，可以通过SQL语句对数据库进行操作，如下图： 或者在Structure工具窗口中进行可视化的创建： 3.查询操作对于数据的查询操作，同样可以通过SQL Query工具通过语句进行查询或者在Content窗口中填写查询条件进行查询，如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展","slug":"167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展","date":"2015-12-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.329Z","comments":true,"path":"2015/12/23/167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展/","link":"","permalink":"http://huishao.cc/2015/12/23/167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展/","excerpt":"","text":"iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展一、引言iOS系统是一个十分注重用户体验的系统，在iOS系统中，用户交互的方案也十分多，然而要在label中的某部分字体中添加交互行为确实不容易的，如果使用其他类似Button的控件来模拟，文字的排版又将是一个解决十分困难的问题。这个问题的由来是项目中的一个界面中有一些广告位标签，而这些广告位的标签却是嵌在文本中的，当用户点击文字标签的位置时，会跳转到响应的广告页。 CoreText框架和一些第三方库可以解决这个问题，但直接使用CoreText十分复杂，第三方库多注重于富文本的排版，对类似文字超链接的支持亦不是特别简洁，我们可以借助一些第三方的东西进行针对性更强，更易用的封装。 RCLabel是一个第三方的将html字符串进行文本布局的工具，代码十分轻巧，并且其是基于CoreText框架的，其原生性和扩展性十分强。在以前的一篇博客中，我将RCLabel进行了一些改进，使其支持异步加载远程图片，并且提供了更加简洁的面向应用的方法，博客地址如下： 扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计:http://my.oschina.net/u/2340880/blog/499311 。 本篇博文，将在其基础上，完成设计一个可以支持文本超链接的文字视图。 二、视图类与模型类的设计RCLabel的核心之处在于将HTML文本转换为富文本布局视图，因此我们可以将要显示的文本编程html字符串，将其可以进行用户交互的部分进行html超链接关联，RCLabel就检测到我们点击的区域进行响应逻辑的回调。设计类如下： .h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243//文本与超链接地址关联的model类 后面会说@class YHBaseLinkingLabelModel;@protocol YHBaseLinkingLabelProtocol &lt;NSObject&gt;@optional/** *点击超链接后出发的代理方法 model中有链接地址和文字 */-(void)YHBaseLinkingLabelClickLinking:(YHBaseLinkingLabelModel *)model;/** *尺寸改变后出发的方法 */-(void)YHBaseLinkingLabelSizeChange:(CGSize)size;@end@interface YHBaseLinkingLabel : YHBaseView/** *文字数组 里面存放这文字对应的超链接对象 */@property(nonatomic,strong)NSArray&lt;YHBaseLinkingLabelModel *&gt; * textArray;@property(nonatomic,weak)id&lt;YHBaseLinkingLabelProtocol&gt;delegate;/** *设置文字颜色 */@property(nonatomic,strong)UIColor * textColor;/** *设置超链接文字颜色 */@property(nonatomic,strong)UIColor * linkColor;/** *设置字体大小 */@property(nonatomic,assign)NSUInteger fontSize;/** *设置超链接字体大小 */@property(nonatomic,assign)int linkingFontSize;/** *设置是否显示下划线 */@property(nonatomic,assign)BOOL isShowUnderLine;@end .m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124@interface YHBaseLinkingLabel()&lt;YHBaseHtmlViewProcotop&gt;@end@implementation YHBaseLinkingLabel&#123; //以前博客中 封装的显示HTML字符串富文本的视图 YHBaseHtmlView * _label;&#125;/*// 重载一些初始化方法- (instancetype)init&#123; self = [super init]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super initWithCoder:coder]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;//设置文本数组-(void)setTextArray:(NSArray&lt;YHBaseLinkingLabelModel *&gt; *)textArray&#123; _textArray = textArray; //进行html转换 NSString * htmlString = [self transLinkingDataToHtmlStr:textArray]; //进行布局 [_label reSetHtmlStr:htmlString]; &#125;-(void)setTextColor:(UIColor *)textColor&#123; _textColor = textColor; _label.fontColor = textColor;&#125;-(void)setLinkColor:(UIColor *)linkColor&#123; _linkColor = linkColor; _label.linkingColor = linkColor;&#125;-(void)setFontSize:(NSUInteger)fontSize&#123; _fontSize = fontSize; [_label setFontSize:(int)fontSize];&#125;-(void)setLinkingFontSize:(int)linkingFontSize&#123; _linkingFontSize = linkingFontSize; [_label setLinkingSize:linkingFontSize];&#125;-(void)setIsShowUnderLine:(BOOL)isShowUnderLine&#123; _isShowUnderLine = isShowUnderLine; [_label setShowUnderLine:isShowUnderLine];&#125;-(NSString *)transLinkingDataToHtmlStr:(NSArray&lt;YHBaseLinkingLabelModel *&gt; *)data&#123; NSMutableString * mutStr = [[NSMutableString alloc]init]; for (int i=0; i&lt;data.count; i++) &#123; //这个model中存放的是超链接部分的文字和对应的url YHBaseLinkingLabelModel * model = data[i]; if (!model.linking) &#123; [mutStr appendString:model.text]; &#125;else &#123; [mutStr appendString:@&quot;&lt;a href=&quot;]; [mutStr appendString:model.linking]; [mutStr appendString:@&quot;&gt;&quot;]; [mutStr appendString:model.text]; [mutStr appendString:@&quot;&lt;/a&gt;&quot;]; &#125; &#125; return mutStr;&#125;#pragma mark delegate//点击的回调-(void)YHBaseHtmlView:(YHBaseHtmlView *)htmlView ClickLink:(NSString *)url&#123; for (YHBaseLinkingLabelModel * model in _textArray) &#123; if ([model.linking isEqualToString:url]) &#123; if ([self.delegate respondsToSelector:@selector(YHBaseLinkingLabelClickLinking:)]) &#123; [self.delegate YHBaseLinkingLabelClickLinking:model]; return; &#125; &#125; &#125;&#125;//布局尺寸改变的回调-(void)YHBaseHtmlView:(YHBaseHtmlView *)htmlView SizeChanged:(CGSize)size&#123; if ([self.delegate respondsToSelector:@selector(YHBaseLinkingLabelSizeChange:)]) &#123; [self.delegate YHBaseLinkingLabelSizeChange:size]; &#125;&#125;@end 上面我们有用到一个YHBaseLinkingLabelModel类，这个类进行了链接与字符的映射，设计如下： 1234567891011@interface YHBaseLinkingLabelModel : YHBaseModel/** *文字内容 */@property(nonatomic,strong)NSString * text;/** *超链接地址 nil则为无 */@property(nonatomic,strong)NSString * linking;@end YHBaseHtmlView类是对RCLabel的一层封装，其中也对RCLabel进行了一些优化和改动，代码较多且在上篇博客中有介绍，这里不再多做解释了。 在ViewController中写如下代码进行使用： 12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. YHBaseLinkingLabel * label = [[YHBaseLinkingLabel alloc]initWithFrame:CGRectMake(100, 100, 200, 100)]; NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i=0; i&lt;6; i++) &#123; YHBaseLinkingLabelModel * model = [[YHBaseLinkingLabelModel alloc]init]; if (!(i%2)) &#123; model.text =[NSString stringWithFormat:@&quot;第%d个标签&quot;,i]; model.linking = [NSString stringWithFormat:@&quot;第%d个标签&quot;,i]; &#125;else&#123; model.text = @&quot;,不能点得文字,&quot;; &#125; [array addObject:model]; &#125; label.textColor = [UIColor blackColor]; label.linkColor = [UIColor purpleColor]; label.fontSize = 15; label.linkingFontSize = 17; label.isShowUnderLine=YES; label.delegate=self; label.textArray = array; [self.view addSubview:label]; &#125;-(void)YHBaseLinkingLabelClickLinking:(YHBaseLinkingLabelModel *)model&#123; NSLog(@&quot;%@&quot;,model.linking);&#125; 运行效果如下： 效果不错，并且十分简单易用，对吧。 我将这部分的相关代码集成进了以前写的一个项目开发框架中，git地址是：[https://github.com/ZYHshao/YHBaseFoundationTest](https://github.com/ZYHshao/YHBaseFoundationTest) 。总体看来，这个框架并不是干货，只是我开发中的一些积累，如果可以帮到你，择优而用，如果需要和我交流，QQ316045346，对视欢迎。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS开发之蓝牙通讯","slug":"166iOS开发之蓝牙通讯","date":"2015-12-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.329Z","comments":true,"path":"2015/12/20/166iOS开发之蓝牙通讯/","link":"","permalink":"http://huishao.cc/2015/12/20/166iOS开发之蓝牙通讯/","excerpt":"","text":"iOS开发之蓝牙通讯一、引言蓝牙是设备近距离通信的一种方便手段，在iPhone引入蓝牙4.0后，设备之间的通讯变得更加简单。相关的蓝牙操作由专门的CoreBluetooth.framework进行统一管理。通过蓝牙进行通讯交互分为两方，一方为中心设备central，一方为外设peripheral，外设通过广播的方式向外发送信息，中心设备检索到外设发的广播信息，可以进行配对连接，进而进行数据交互。 二、中心设备CBCentralManagerCBCentralManager是管理中心设备的管理类，其中重要方法如下： 123456//设置中心设备代理@property(assign, nonatomic, nullable) id&lt;CBCentralManagerDelegate&gt; delegate;//中心设备当前状态@property(readonly) CBCentralManagerState state;//中心设备是否正在扫描@property(readonly) BOOL isScanning NS_AVAILABLE(NA, 9_0); 其中state是一个枚举，有关蓝牙是否可用的状态如下： 1234567891011121314typedef NS_ENUM(NSInteger, CBCentralManagerState) &#123; //状态未知 CBCentralManagerStateUnknown = 0, //连接断开 即将重置 CBCentralManagerStateResetting, //该平台不支持蓝牙 CBCentralManagerStateUnsupported, //未授权蓝牙使用 CBCentralManagerStateUnauthorized, //蓝牙关闭 CBCentralManagerStatePoweredOff, //蓝牙正常开启 CBCentralManagerStatePoweredOn,&#125;; 下面这些方法用于初始化管理中心： 1234567891011121314//初始化方法//设置的代理需要遵守CBCentralManagerDelegate协议//queue可以设置蓝牙扫描的线程 传入nil则为在主线程中进行- (instancetype)initWithDelegate:(nullable id&lt;CBCentralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue;//此方法同上 在options字典中用于进行一些管理中心的初始化属性设置//字典中支持的键值如下/*NSString * const CBCentralManagerOptionShowPowerAlertKey 对应一个NSNumber类型的bool值，用于设置是否在关闭蓝牙时弹出用户提示NSString * const CBCentralManagerOptionRestoreIdentifierKey 对应一个NSString对象，设置管理中心的标识符ID*/- (instancetype)initWithDelegate:(nullable id&lt;CBCentralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 1234//根据获取所有已知设备- (NSArray&lt;CBPeripheral *&gt; *)retrievePeripheralsWithIdentifiers:(NSArray&lt;NSUUID *&gt; *)identifiers;//根据服务id获取所有连接的设备- (NSArray&lt;CBPeripheral *&gt; *)retrieveConnectedPeripheralsWithServices:(NSArray&lt;CBUUID *&gt; *)serviceUUIDs; 在初始化管理中心完成后，会回调代理中的如下方法，我们必须实现如下方法： 12//这个方法中可以获取到管理中心的状态- (void)centralManagerDidUpdateState:(CBCentralManager *)central; 如果上面方法中管理中心状态为蓝牙可用，可以通过下面方法开启扫描外设： 12345678//serviceUUIDs用于扫描一个特点ID的外设 options用于设置一些扫描属性 键值如下/*//是否允许重复扫描 对应NSNumber的bool值，默认为NO，会自动去重NSString *const CBCentralManagerScanOptionAllowDuplicatesKey;//要扫描的设备UUID 数组 对应NSArrayNSString *const CBCentralManagerScanOptionSolicitedServiceUUIDsKey;*/- (void)scanForPeripheralsWithServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 12//停止扫描外设- (void)stopScan; 扫描的结果会在如下代理方法中回掉： 1234//peripheral 扫描到的外设//advertisementData是外设发送的广播数据//RSSI 是信号强度- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI; 扫描到外设后，通过下面方法可以连接一个外设： 123456789101112/*options中可以设置一些连接设备的初始属性键值如下//对应NSNumber的bool值，设置当外设连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnConnectionKey;//对应NSNumber的bool值，设置当外设断开连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnDisconnectionKey;//对应NSNumber的bool值，设置当外设暂停连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnNotificationKey;*/- (void)connectPeripheral:(CBPeripheral *)peripheral options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;//取消一个外设的连接- (void)cancelPeripheralConnection:(CBPeripheral *)peripheral; 调用过连接外设的方法后，会回掉如下代理方法： 123456//连接外设成功- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral;//连接外设失败- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error;//断开外设连接- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error; 当管理中心恢复时会调用如下代理： 12345678910//dict中会传入如下键值对/*//恢复连接的外设数组NSString *const CBCentralManagerRestoredStatePeripheralsKey;//恢复连接的服务UUID数组NSString *const CBCentralManagerRestoredStateScanServicesKey;//恢复连接的外设扫描属性字典数组NSString *const CBCentralManagerRestoredStateScanOptionsKey;*/- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict; 三、外设CBPeripheralManager从上面我们知道，中心设备是用来扫描周围的外设，两台设备的通讯中，必须有一个充当中心设备，一个充当外设，外设是由CBPeripheralManager进行管理，主要方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//设置外设管理中心代理@property(assign, nonatomic, nullable) id&lt;CBPeripheralManagerDelegate&gt; delegate;//外设状态 枚举如中心设备@property(readonly) CBPeripheralManagerState state;//是否正在发送广播@property(readonly) BOOL isAdvertising;//用户的授权状态+ (CBPeripheralManagerAuthorizationStatus)authorizationStatus;//初始化并设置代理 参数的具体含义与中心设备管理中心- (instancetype)initWithDelegate:(nullable id&lt;CBPeripheralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t);- (instancetype)initWithDelegate:(nullable id&lt;CBPeripheralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;//开始发送广播//advertisementData中可以发送的数据有约定 如下/*对应设置NSString类型的广播名NSString *const CBAdvertisementDataLocalNameKey;外设制造商的NSData数据NSString *const CBAdvertisementDataManufacturerDataKey;外设制造商的CBUUID数据NSString *const CBAdvertisementDataServiceDataKey;服务的UUID与其对应的服务数据字典数组NSString *const CBAdvertisementDataServiceUUIDsKey;附加服务的UUID数组NSString *const CBAdvertisementDataOverflowServiceUUIDsKey;外设的发送功率 NSNumber类型NSString *const CBAdvertisementDataTxPowerLevelKey;外设是否可以连接NSString *const CBAdvertisementDataIsConnectable;服务的UUID数组NSString *const CBAdvertisementDataSolicitedServiceUUIDsKey;*/- (void)startAdvertising:(nullable NSDictionary&lt;NSString *, id&gt; *)advertisementData;//停止发送广播- (void)stopAdvertising;//设置一个连接的具体central设备的延时 枚举如下/*typedef NS_ENUM(NSInteger, CBPeripheralManagerConnectionLatency) &#123; CBPeripheralManagerConnectionLatencyLow = 0, CBPeripheralManagerConnectionLatencyMedium, CBPeripheralManagerConnectionLatencyHigh&#125; NS_ENUM_AVAILABLE(NA, 6_0);*/- (void)setDesiredConnectionLatency:(CBPeripheralManagerConnectionLatency)latency forCentral:(CBCentral *)central;//添加一个服务- (void)addService:(CBMutableService *)service;//移除一个服务- (void)removeService:(CBMutableService *)service;//移除所有服务- (void)removeAllServices;//响应中心设备的读写请求- (void)respondToRequest:(CBATTRequest *)request withResult:(CBATTError)result;//更新一个连接中心设备的订阅特征值- (BOOL)updateValue:(NSData *)value forCharacteristic:(CBMutableCharacteristic *)characteristic onSubscribedCentrals:(nullable NSArray&lt;CBCentral *&gt; *)centrals; 外设代理的相关方法如下： 123456789101112131415161718//这个方法是必须实现的 状态可用后可以发送广播- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral;//连接回复时调用的方法 和centralManager类似- (void)peripheralManager:(CBPeripheralManager *)peripheral willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict;//开始发送广播时调用的方法- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(nullable NSError *)error;//添加服务调用的回调- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(nullable NSError *)error;//当一个central设备订阅一个特征值时调用的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic;//取消订阅一个特征值时调用的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic;//收到读请求时触发的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request;//收到写请求时触发的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests;//外设准备更新特征值时调用的方法- (void)peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)peripheral; 四、中心设备与外设对象CBCentral与CBPeripheral上面介绍了中心设备管理类与外设管理类，这些类用于将设备连接建立起来，器具的数据交换的服务和一些信息则是在对应的设备对象中。 1、中心设备 CBCentral属性与方法1234//设备UUID@property(readonly, nonatomic) NSUUID *identifier;//中心设备最大接收的数据长度@property(readonly, nonatomic) NSUInteger maximumUpdateValueLength; 2、外设CAPeripheral属性与方法外设对象要比中心对象复杂的多，当centralManager连接到外设后，需要通过外设对象的代理方法进行数据交互，其中主要方法属性如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//设置代理@property(assign, nonatomic, nullable) id&lt;CBPeripheralDelegate&gt; delegate;//外设name@property(retain, readonly, nullable) NSString *name;//信号强度@property(retain, readonly, nullable) NSNumber *RSSI NS_DEPRECATED(NA, NA, 5_0, 8_0);//外设状态/*typedef NS_ENUM(NSInteger, CBPeripheralState) &#123; CBPeripheralStateDisconnected = 0,//未连接 CBPeripheralStateConnecting,//正在链接 CBPeripheralStateConnected,//已经连接 CBPeripheralStateDisconnecting NS_AVAILABLE(NA, 9_0),//正在断开连接&#125; NS_AVAILABLE(NA, 7_0);*/@property(readonly) CBPeripheralState state;//所有的服务数组@property(retain, readonly, nullable) NSArray&lt;CBService *&gt; *services;//获取当前信号强度- (void)readRSSI;//根据服务UUID寻找服务对象- (void)discoverServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs;//在服务对象UUID数组中寻找特定服务- (void)discoverIncludedServices:(nullable NSArray&lt;CBUUID *&gt; *)includedServiceUUIDs forService:(CBService *)service;//在一个服务中寻找特征值- (void)discoverCharacteristics:(nullable NSArray&lt;CBUUID *&gt; *)characteristicUUIDs forService:(CBService *)service;//从一个特征中读取数据- (void)readValueForCharacteristic:(CBCharacteristic *)characteristic;//写数据的最大长度//type枚举如下/*typedef NS_ENUM(NSInteger, CBCharacteristicWriteType) &#123; CBCharacteristicWriteWithResponse = 0,//写数据并且接收成功与否回执 CBCharacteristicWriteWithoutResponse,//写数据不接收回执&#125;;*/- (NSUInteger)maximumWriteValueLengthForType:(CBCharacteristicWriteType)type NS_AVAILABLE(NA, 9_0);//向某个特征中写数据- (void)writeValue:(NSData *)data forCharacteristic:(CBCharacteristic *)characteristic type:(CBCharacteristicWriteType)type;//为制定的特征值设置监听通知- (void)setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic;//寻找特征值的描述- (void)discoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic;//读取特征的描述值- (void)readValueForDescriptor:(CBDescriptor *)descriptor;//写特征的描述值- (void)writeValue:(NSData *)data forDescriptor:(CBDescriptor *)descriptor; 外设的代理方法如下： 1234567891011121314151617181920212223242526//外设名称更改时回调的方法- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral NS_AVAILABLE(NA, 6_0);//外设服务变化时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray&lt;CBService *&gt; *)invalidatedServices NS_AVAILABLE(NA, 7_0);//信号强度改变时调用的方法- (void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(nullable NSError *)error NS_DEPRECATED(NA, NA, 5_0, 8_0);//读取信号强度回调的方法- (void)peripheral:(CBPeripheral *)peripheral didReadRSSI:(NSNumber *)RSSI error:(nullable NSError *)error NS_AVAILABLE(NA, 8_0);//发现服务时调用的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error;//在服务中发现子服务回调的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(nullable NSError *)error;//发现服务的特征值后回调的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error;//特征值更新时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error;//向特征值写数据时回调的方法 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //特征值的通知设置改变时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //发现特征值的描述信息触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //特征的描述值更新时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error; //写描述信息时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error; 五、服务对象CBService服务对象是用来管理外设提供的一些数据服务的，其中属性如下： 12345678//对应的外设@property(assign, readonly, nonatomic) CBPeripheral *peripheral;//是否是初等服务@property(readonly, nonatomic) BOOL isPrimary;//包含的自服务@property(retain, readonly, nullable) NSArray&lt;CBService *&gt; *includedServices;//服务中的特征值@property(retain, readonly, nullable) NSArray&lt;CBCharacteristic *&gt; *characteristics; 六、服务的特征值CBCharacteristic通过绑定服务中的特征值来进行数据的读写操作，其中属性如下： 1234567891011121314151617181920212223242526//对应的服务对象@property(assign, readonly, nonatomic) CBService *service;//特征值的属性 枚举如下/*typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123; CBCharacteristicPropertyBroadcast,//允许广播特征 CBCharacteristicPropertyRead,//可读属性 CBCharacteristicPropertyWriteWithoutResponse,//可写并且接收回执 CBCharacteristicPropertyWrite,//可写属性 CBCharacteristicPropertyNotify,//可通知属性 CBCharacteristicPropertyIndicate,//可展现的特征值 CBCharacteristicPropertyAuthenticatedSignedWrites,//允许签名的特征值写入 CBCharacteristicPropertyExtendedProperties, CBCharacteristicPropertyNotifyEncryptionRequired, CBCharacteristicPropertyIndicateEncryptionRequired&#125;;*/@property(readonly, nonatomic) CBCharacteristicProperties properties;//特征值的数据@property(retain, readonly, nullable) NSData *value;//特征值的描述@property(retain, readonly, nullable) NSArray&lt;CBDescriptor *&gt; *descriptors;//是否是当前广播的特征@property(readonly) BOOL isBroadcasted;//是否是正在通知的特征@property(readonly) BOOL isNotifying; 七、读写请求对象CBATTRequest服务对象是外设向中心设备提供的相关数据服务，获取到相应服务后，中心设备可以进行读写请求，读写对象属性如下： 123456//对应的中心设备@property(readonly, nonatomic) CBCentral *central;//对应的特征值@property(readonly, nonatomic) CBCharacteristic *characteristic;//读写数据值@property(readwrite, copy, nullable) NSData *value; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS获取和监测设备基本信息——UIDevice的使用","slug":"165iOS获取和监测设备基本信息——UIDevice的使用","date":"2015-12-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.329Z","comments":true,"path":"2015/12/18/165iOS获取和监测设备基本信息——UIDevice的使用/","link":"","permalink":"http://huishao.cc/2015/12/18/165iOS获取和监测设备基本信息——UIDevice的使用/","excerpt":"","text":"iOS获取和监测设备基本信息——UIDevice的使用12345678910111213141516171819202122//获取当前设备单例+ (UIDevice *)currentDevice;//获取当前设备名称 @property(nonatomic,readonly,strong) NSString *name; // e.g. &quot;My iPhone&quot;//获取当前设备模式@property(nonatomic,readonly,strong) NSString *model; // e.g. @&quot;iPhone&quot;, @&quot;iPod touch&quot;//获取本地化的当前设备模式@property(nonatomic,readonly,strong) NSString *localizedModel; // localized version of model//获取系统名称@property(nonatomic,readonly,strong) NSString *systemName; // e.g. @&quot;iOS&quot;//获取系统版本@property(nonatomic,readonly,strong) NSString *systemVersion; // e.g. @&quot;4.0&quot;//获取设备方向@property(nonatomic,readonly) UIDeviceOrientation orientation; //获取设备UUID对象@property(nullable, nonatomic,readonly,strong) NSUUID *identifierForVendor;//是否开启监测电池状态 开启后 才可以正常获取电池状态@property(nonatomic,getter=isBatteryMonitoringEnabled) BOOL batteryMonitoringEnabled NS_AVAILABLE_IOS(3_0); // default is NO//获取电池状态@property(nonatomic,readonly) UIDeviceBatteryState batteryState NS_AVAILABLE_IOS(3_0); //获取电量@property(nonatomic,readonly) float batteryLevel NS_AVAILABLE_IOS(3_0); 设备方向的枚举如下： 123456789typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123; UIDeviceOrientationUnknown, UIDeviceOrientationPortrait, // home键在下 UIDeviceOrientationPortraitUpsideDown, // home键在上 UIDeviceOrientationLandscapeLeft, // home键在右 UIDeviceOrientationLandscapeRight, // home键在左 UIDeviceOrientationFaceUp, // 屏幕朝上 UIDeviceOrientationFaceDown // 屏幕朝下&#125;; 电池状态的枚举如下： 123456typedef NS_ENUM(NSInteger, UIDeviceBatteryState) &#123; UIDeviceBatteryStateUnknown, UIDeviceBatteryStateUnplugged, // 放电状态 UIDeviceBatteryStateCharging, // 充电未充满状态 UIDeviceBatteryStateFull, // 充电已充满&#125;; 下面的方法关于监测屏幕状态： 123456//获取是否开启屏幕状态更改通知@property(nonatomic,readonly,getter=isGeneratingDeviceOrientationNotifications) BOOL generatesDeviceOrientationNotifications;//开始监测通知- (void)beginGeneratingDeviceOrientationNotifications; //结束监测通知- (void)endGeneratingDeviceOrientationNotifications; 下面这两个放大与距离传感器应用相关，可参考：http://my.oschina.net/u/2340880/blog/544341. 123@property(nonatomic,getter=isProximityMonitoringEnabled) BOOL proximityMonitoringEnabled NS_AVAILABLE_IOS(3_0); //开启距离传感器//是否触发了距离传感器@property(nonatomic,readonly) BOOL proximityState 相关通知： 12345678//设备方向改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceOrientationDidChangeNotification;//电池状态改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceBatteryStateDidChangeNotification NS_AVAILABLE_IOS(3_0);//电量改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceBatteryLevelDidChangeNotification NS_AVAILABLE_IOS(3_0);//距离传感器状态改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceProximityStateDidChangeNotification NS_AVAILABLE_IOS(3_0); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——距离传感器的应用","slug":"164iOS传感器开发——距离传感器的应用","date":"2015-12-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.329Z","comments":true,"path":"2015/12/14/164iOS传感器开发——距离传感器的应用/","link":"","permalink":"http://huishao.cc/2015/12/14/164iOS传感器开发——距离传感器的应用/","excerpt":"","text":"iOS传感器开发——距离传感器的应用iPhone手机中内置了距离传感器，位置在手机的听筒附近，当我们在打电话的时候靠近听筒，手机的屏幕会自动熄灭，这就靠距离传感器来控制。 在我们开发app时，如果需要，也可以调用距离传感器的一些接口方法。距离传感器的接口十分简单，主要通过通知中心来对距离的改变进行通知。 首先，我们需要开启距离传感器应用： 1[UIDevice currentDevice].proximityMonitoringEnabled=YES; 监听距离改变的通知： 1[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(notice) name:UIDeviceProximityStateDidChangeNotification object:nil]; 在回调方法中，我们可以通过下面这个属性来监听距离状态： 1234567-(void)notice&#123; if ([UIDevice currentDevice].proximityState) &#123; NSLog(@&quot;近距离&quot;); &#125;else&#123; NSLog(@&quot;远距离&quot;); &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用","slug":"163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用","date":"2015-12-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.328Z","comments":true,"path":"2015/12/13/163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用/","link":"","permalink":"http://huishao.cc/2015/12/13/163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用/","excerpt":"","text":"iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用一、引言通过加速度传感器，螺旋仪传感器和磁力传感，我们可以获取到手机在当前三维空间中的形态，加速度传感器也被称作重力感应。在一些赛车游戏中可以广泛得到应用。在iOS5之前，iPhone支持的传感器有限，关于加速度传感器的管理用UIAccelerometer这个类负责，iOS5之后，有关设备空间信息的管理交由了CoreMotion这个框架，CoreMotion将多种传感器统一进行管理计算。 二、使用UIAccelerometer获取设备空间位置虽然在iOS5之后这个类被弃用了，但是和其他大多被弃用的方法类似，在新的iOS版本中，是兼容旧方法的，我们依然可以使用这个类来获取简单的设备空间信息。 我们主要使用到的类和代理方法如下： 1234567891011//设备信息对象类@interface UIAcceleration : NSObject//加速度传感器的时间戳@property(nonatomic,readonly) NSTimeInterval timestamp;//x方向值@property(nonatomic,readonly) UIAccelerationValue x;//y方向值@property(nonatomic,readonly) UIAccelerationValue y;//z方向值@property(nonatomic,readonly) UIAccelerationValue z;@end 上面的UIAccelerationValue就是double类型。 加速度传感器获取的属性是设备在三维空间的角度属性，借用下面这张图： 如果将设备这样立在桌面上，设备的三维坐标器如图，我们将设备已Z轴移动的时候，向右x为正，向左为负，其他两轴类似。 123456789//加速度管理类@interface UIAccelerometer : NSObject //获取单例对象+ (UIAccelerometer *)sharedAccelerometer;//刷新频率@property(nonatomic) NSTimeInterval updateInterval;//代理@property(nullable,nonatomic,weak) id&lt;UIAccelerometerDelegate&gt; delegate;@end UIAccelerometer是管理类，通过单例方法获取到实例对象。 123456@protocol UIAccelerometerDelegate&lt;NSObject&gt;@optional- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration NS_DEPRECATED_IOS(2_0, 5_0) __TVOS_PROHIBITED;@end 这个代理方法是刷新信息的回调，会以我们设置的帧率刷新。 举例代码如下： 123456789101112131415161718@interface ViewController ()&lt;UIAccelerometerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [UIAccelerometer sharedAccelerometer].delegate=self; [UIAccelerometer sharedAccelerometer].updateInterval=1/60.0;&#125;-(void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration&#123; NSLog(@&quot;\\n%f\\n%f\\n%f&quot;,acceleration.x,acceleration.y,acceleration.z); // NSLog(@&quot;%f&quot;,acceleration.timestamp);&#125;@end 三、CoreMotion框架的使用CoreMotion框架十分强大，它不仅将加速度传感器和螺旋仪传感器进行了统一配置和管理，还为我们封装了许多算法，我们可以直接获取到设备的运动状态信息。 1、CoreMotion负责处理的数据CoreMotion负责处理四种数据，一种是加速度数据，一种是螺旋仪数据，一种是磁感应数据，还有一种是前三种数据通过复杂运算得到的设备的运动数据。几个主要的类如下： CMAccelerommterData:设备的加速度数据 1234567891011121314typedef struct &#123; double x; double y; double z;&#125; CMAcceleration;@interface CMAccelerometerData : CMLogItem&#123;@private id _internal;&#125;//加速度的数据对象@property(readonly, nonatomic) CMAcceleration acceleration;@end CMGyroData:设备的螺旋仪数据 1234567891011121314typedef struct &#123; double x; double y; double z; &#125; CMRotationRate;@interface CMGyroData : CMLogItem&#123;@private id _internal;&#125;//螺旋仪数据对象@property(readonly, nonatomic) CMRotationRate rotationRate;@end CMMagnetometerData：磁感应信息 12345678910111213141516typedef struct &#123; double x; double y; double z;&#125; CMMagneticField;@interface CMMagnetometerData : CMLogItem&#123;@private id _internal;&#125;//磁力对象@property(readonly, nonatomic) CMMagneticField magneticField;@end CMDeviceMotion:设备的运动状态数据 123456789101112131415@interface CMDeviceMotion : CMLogItem&#123;@private id _internal;&#125;//设备的状态对象@property(readonly, nonatomic) CMAttitude *attitude;//设备的角速度@property(readonly, nonatomic) CMRotationRate rotationRate;//设备的重力加速度@property(readonly, nonatomic) CMAcceleration gravity;//用户嫁给设备的加速度 设备的总加速度为重力加速度叫上用户给的加速度@property(readonly, nonatomic) CMAcceleration userAcceleration;//设备的磁场矢量对象@property(readonly, nonatomic) CMCalibratedMagneticField magneticField NS_AVAILABLE(NA,5_0); 相比之前两个类，这个就比较复杂了，attitude对象中又封装了许多设备的状态属性： 12345678910111213141516@interface CMAttitude : NSObject &lt;NSCopying, NSSecureCoding&gt;&#123;@private id _internal;&#125;//设备的欧拉角roll@property(readonly, nonatomic) double roll;//设备的欧拉角pitch@property(readonly, nonatomic) double pitch;//设备的欧拉角yaw@property(readonly, nonatomic) double yaw;//设备状态的旋转矩阵@property(readonly, nonatomic) CMRotationMatrix rotationMatrix;//设备状态的四元数@property(readonly, nonatomic) CMQuaternion quaternion;@end 2、CoreMotion的使用CoreMotion有两种使用方式，一种是我们主动向manager索取数据，一种是通过回调让manager将数据传给回调给我们，这两种方式分别称作pull方式和push方式。 pull方式： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建管理对象 manager= [[CMMotionManager alloc]init]; //开启加速度更新 [manager startAccelerometerUpdates]; //开启螺旋仪更新 [manager startGyroUpdates]; //开启状态更新 [manager startMagnetometerUpdates]; //创建定时器 NSTimer * time = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(updata) userInfo:nil repeats:YES]; time.fireDate = [NSDate distantPast];&#125;-(void)updata&#123;//获取数据 NSLog(@&quot;%f,%f,%f\\n%f,%f,%f&quot;,manager.accelerometerData.acceleration.x,manager.accelerometerData.acceleration.y,manager.accelerometerData.acceleration.z,manager.gyroData.rotationRate.x,manager.gyroData.rotationRate.y,manager.gyroData.rotationRate.z); &#125; push方式： 123456 //创建管理对象 manager= [[CMMotionManager alloc]init]; //在当前线程中回调 [manager startAccelerometerUpdatesToQueue:[NSOperationQueue currentQueue] withHandler:^(CMAccelerometerData * _Nullable accelerometerData, NSError * _Nullable error) &#123; NSLog(@&quot;%f,%f,%f\\n%f,%f,%f&quot;,manager.accelerometerData.acceleration.x,manager.accelerometerData.acceleration.y,manager.accelerometerData.acceleration.z,manager.gyroData.rotationRate.x,manager.gyroData.rotationRate.y,manager.gyroData.rotationRate.z); &#125;]; 3、CoreMotion的更多属性和方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@interface CMMotionManager : NSObject&#123;@private id _internal;&#125;//设置加速度传感器更新帧率@property(assign, nonatomic) NSTimeInterval accelerometerUpdateInterval __TVOS_PROHIBITED;//加速度传感器是否可用@property(readonly, nonatomic, getter=isAccelerometerAvailable) BOOL accelerometerAvailable __TVOS_PROHIBITED;//加速度传感器是否激活@property(readonly, nonatomic, getter=isAccelerometerActive) BOOL accelerometerActive __TVOS_PROHIBITED;//加速度传感器数据对象@property(readonly, nullable) CMAccelerometerData *accelerometerData __TVOS_PROHIBITED;//pull方式开始更新加速度数据- (void)startAccelerometerUpdates __TVOS_PROHIBITED;//push方式更新加速度数据- (void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler __TVOS_PROHIBITED;//停止更新加速度数据- (void)stopAccelerometerUpdates __TVOS_PROHIBITED;//螺旋仪传感器刷新帧率@property(assign, nonatomic) NSTimeInterval gyroUpdateInterval __TVOS_PROHIBITED;//螺旋仪是否可用@property(readonly, nonatomic, getter=isGyroAvailable) BOOL gyroAvailable __TVOS_PROHIBITED;//螺旋仪是否激活@property(readonly, nonatomic, getter=isGyroActive) BOOL gyroActive __TVOS_PROHIBITED;//螺旋仪数据@property(readonly, nullable) CMGyroData *gyroData __TVOS_PROHIBITED;//pull方式开始更新螺旋仪- (void)startGyroUpdates __TVOS_PROHIBITED;//push方式开始更新螺旋仪- (void)startGyroUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMGyroHandler)handler __TVOS_PROHIBITED;//停止更新螺旋仪- (void)stopGyroUpdates __TVOS_PROHIBITED;//磁力传感更新帧率@property(assign, nonatomic) NSTimeInterval magnetometerUpdateInterval NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力传感器是否可用@property(readonly, nonatomic, getter=isMagnetometerAvailable) BOOL magnetometerAvailable NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力传感器是否激活@property(readonly, nonatomic, getter=isMagnetometerActive) BOOL magnetometerActive NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力状态数据@property(readonly, nullable) CMMagnetometerData *magnetometerData NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//pull方式更新设备磁力状态- (void)startMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//push方式更新设备磁力状态- (void)startMagnetometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMMagnetometerHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//停止更新设备状态- (void)stopMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备状态更新帧率@property(assign, nonatomic) NSTimeInterval deviceMotionUpdateInterval __TVOS_PROHIBITED;//参考器枚举+ (CMAttitudeReferenceFrame)availableAttitudeReferenceFrames NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;@property(readonly, nonatomic) CMAttitudeReferenceFrame attitudeReferenceFrame NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备运动信息是否可用@property(readonly, nonatomic, getter=isDeviceMotionAvailable) BOOL deviceMotionAvailable __TVOS_PROHIBITED;//设备运动信息是否激活@property(readonly, nonatomic, getter=isDeviceMotionActive) BOOL deviceMotionActive __TVOS_PROHIBITED;//设备运动信息对象@property(readonly, nullable) CMDeviceMotion *deviceMotion __TVOS_PROHIBITED;//pull方式开始刷新运动信息- (void)startDeviceMotionUpdates __TVOS_PROHIBITED;//push方式开始刷新运动信息- (void)startDeviceMotionUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler __TVOS_PROHIBITED;//使用某个参考系- (void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//push方式开始刷新设备运动信息- (void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame toQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//停止刷新设备运动信息- (void)stopDeviceMotionUpdates __TVOS_PROHIBITED; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——为APP添加手机密码、指纹进行安全验证","slug":"162iOS传感器开发——为APP添加手机密码、指纹进行安全验证","date":"2015-12-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.328Z","comments":true,"path":"2015/12/10/162iOS传感器开发——为APP添加手机密码、指纹进行安全验证/","link":"","permalink":"http://huishao.cc/2015/12/10/162iOS传感器开发——为APP添加手机密码、指纹进行安全验证/","excerpt":"","text":"iOS传感器开发——为APP添加手机密码、指纹进行安全验证一、引言iPhone5s之后，iPhone硬件上已支持进行指纹识别的功能，相应的，一些新的api也可以应用于APP中，进行用户安全的验证。目前，开发者可以使用的安全验证方式有两种，一种是通过手机密码进行验证，一种是通过识别指纹进行验证。 二、为APP添加安全验证要使用安全验证的相关api，我们需要引入如下头文件： 1#import &lt;LocalAuthentication/LocalAuthentication.h&gt; 添加手机密码验证： 123456789101112131415 //创建安全验证对象 LAContext * con = [[LAContext alloc]init]; NSError * error; //判断是否支持密码验证 /** *LAPolicyDeviceOwnerAuthentication 手机密码的验证方式 *LAPolicyDeviceOwnerAuthenticationWithBiometrics 指纹的验证方式 */ BOOL can = [con canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:&amp;error]; if (can) &#123; [con evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:@&quot;验证信息&quot; reply:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@&quot;%d,%@&quot;,success,error); &#125;]; &#125; canEvaluatePolicy是用来判断是否支持手机密码验证的，如果没有设置手机密码，会返回NO，如果启用了，会出现如下界面： 密码验证的提示信息，我们可以自定义设置。 进行指纹验证： 12345678910LAContext * con = [[LAContext alloc]init]; NSError * error; BOOL can = [con canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]; NSLog(@&quot;%d&quot;,can); if (can) &#123; [con evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@&quot;验证指纹&quot; reply:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@&quot;%d,%@&quot;,success,error); &#125;]; &#125; 回调中的success用来判断是否验证成功： 通过这些验证方式，可以使用户的数据更加安全，在做敏感操作时，可以确保是手机的持有者。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之五——高级动画技巧","slug":"160iOS开发CoreAnimation解读之五——高级动画技巧","date":"2015-12-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.328Z","comments":true,"path":"2015/12/06/160iOS开发CoreAnimation解读之五——高级动画技巧/","link":"","permalink":"http://huishao.cc/2015/12/06/160iOS开发CoreAnimation解读之五——高级动画技巧/","excerpt":"","text":"iOS开发CoreAnimation解读之五——高级动画技巧一、事务类CoreAnimation中还有一个非常重要的类：CATransaction事物类，这个可以同时设置多个layer层的动画效果。可以通过隐式和显式两种方式来进行动画操作。 二、CATransaction属性对layer层的属性操作，都会形成隐式动画，要使用隐式动画，需要关闭layer层的animation动画属性，使用下面的方法： 123//关闭animation动画效果，开启隐式动画+ (BOOL)disableActions;+ (void)setDisableActions:(BOOL)flag; CATransaction用类方式通过设置key-value来进行动画的属性设置： 12+ (nullable id)valueForKey:(NSString *)key;+ (void)setValue:(nullable id)anObject forKey:(NSString *)key; 支持的key值如下： 12345678//设置动画持续时间 NSString * const kCATransactionAnimationDuration; //设置停用animation类动画 NSString * const kCATransactionDisableActions; //设置动画时序效果 NSString * const kCATransactionAnimationTimingFunction; //设置动画完成后的回调 NSString * const kCATransactionCompletionBlock; 除了隐式的展示动画外，也可以显式的通过调用CATransaction的相关方法进行显示的提交动画： 123456789//动画开始+ (void)begin;//提交动画+ (void)commit;//立即进行动画渲染 一般不需调用+ (void)flush;//下面这两个方法用于动画事物的加锁与解锁 在多线程动画中，保证修改属性的安全+ (void)lock;+ (void)unlock; 示例如下： 1234 [CATransaction begin]; [CATransaction setValue:@1 forKey:kCATransactionAnimationDuration]; layer.backgroundColor = [UIColor blueColor].CGColor; [CATransaction commit]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之六——CATransform3D变换的应用","slug":"161iOS开发CoreAnimation解读之六——CATransform3D变换的应用","date":"2015-12-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.328Z","comments":true,"path":"2015/12/06/161iOS开发CoreAnimation解读之六——CATransform3D变换的应用/","link":"","permalink":"http://huishao.cc/2015/12/06/161iOS开发CoreAnimation解读之六——CATransform3D变换的应用/","excerpt":"","text":"iOS开发CoreAnimation解读之五——CATransform3D变换的应用一、引言CATransform3D定义了一个变化矩阵，通过对矩阵参数的设置，我们可以改变layer的一些属性，这个属性的改变，可以产生动画的效果。首先，CATransform3D定义了一个4*4的矩阵，如下： 1234567struct CATransform3D&#123; CGFloat m11, m12, m13, m14; CGFloat m21, m22, m23, m24; CGFloat m31, m32, m33, m34; CGFloat m41, m42, m43, m44;&#125;; 从m11到m44定义的含义如下： m11：x轴方向进行缩放 m12：和m21一起决定z轴的旋转 m13:和m31一起决定y轴的旋转 m14: m21:和m12一起决定z轴的旋转 m22:y轴方向进行缩放 m23:和m32一起决定x轴的旋转 m24: m31:和m13一起决定y轴的旋转 m32:和m23一起决定x轴的旋转 m33:z轴方向进行缩放 m34:透视效果m34= -1/D，D越小，透视效果越明显，必须在有旋转效果的前提下，才会看到透视效果 m41:x轴方向进行平移 m42:y轴方向进行平移 m43:z轴方向进行平移 m44:初始为1 二、CATransform3D中的属性和方法12345678//初始化一个transform3D对象，不做任何变换const CATransform3D CATransform3DIdentity;//判断一个transform3D对象是否是初始化的对象bool CATransform3DIsIdentity (CATransform3D t);//比较两个transform3D对象是否相同bool CATransform3DEqualToTransform (CATransform3D a, CATransform3D b);//将两个 transform3D对象变换属性进行叠加，返回一个新的transform3D对象CATransform3D CATransform3DConcat (CATransform3D a, CATransform3D b); 1、平移变换1234//返回一个平移变换的transform3D对象 tx，ty，tz对应x，y，z轴的平移CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz);//在某个transform3D变换的基础上进行平移变换，t是上一个transform3D，其他参数同上CATransform3D CATransform3DTranslate (CATransform3D t, CGFloat tx, CGFloat ty, CGFloat tz); 例如： 123456789 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeTranslation(10, 200, 0); newImageView.layer.transform =trans; 效果如下： 2、缩放变换1234//x，y，z分别对应x轴，y轴，z轴的缩放比例CATransform3D CATransform3DMakeScale (CGFloat sx, CGFloat sy, CGFloat sz);//在一个transform3D变换的基础上进行缩放变换，其他参数同上CATransform3D CATransform3DScale (CATransform3D t, CGFloat sx, CGFloat sy, CGFloat sz); 例如： 123456789UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeScale(2, 1, 1); newImageView.layer.transform =trans; 效果如下： 3、旋转变换123456//angle参数是旋转的角度，为弧度制 0-2π//x，y，z决定了旋转围绕的中轴，取值为-1——1之间，例如（1，0，0）,则是绕x轴旋转（0.5，0.5，0），则是绕x轴与y轴中//间45度为轴旋转,依次进行计算CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);//在一个transform3D的基础上进行旋转变换，其他参数如上CATransform3D CATransform3DRotate (CATransform3D t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z); 例如： 123456789UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeRotation(M_PI/2, 0, 0, 1); newImageView.layer.transform =trans; 效果如下： 另外，当我们有垂直于z轴的旋转分量时，设置m34的值可以增加透视效果，也可以理解为景深效果，例如： 123456789101112 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; imageView.layer.transform = CATransform3DMakeRotation(M_PI/4, 0, 1, 0); [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DIdentity; trans.m34 = -1/100.0; trans = CATransform3DRotate(trans, M_PI/4, 0, 1, 0); newImageView.layer.transform =trans; 两个imageView都进行了y轴的旋转变换，第二个有透视效果，第一个没有，运行如下： 4、旋转翻转变换12//将一个旋转的效果进行翻转 CATransform3D CATransform3DInvert (CATransform3D t); 例如： 123456789101112 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; imageView.layer.transform = CATransform3DMakeRotation(M_PI/4, 0, 0, 1); [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeRotation(M_PI/4, 0, 0, 1); trans = CATransform3DInvert(trans); newImageView.layer.transform =trans; 效果如下： 5、CATransform3D与CGAffineTransform的转换CGAffineTransform是UIKit框架中一个用于变换的矩阵，其作用与CATransform类似，只是其可以直接作用于View，而不用作用于layer，这两个矩阵也可以进行转换，方法如下： 123456//将一个CGAffinrTransform转化为CATransform3DCATransform3D CATransform3DMakeAffineTransform (CGAffineTransform m);//判断一个CATransform3D是否可以转换为CAAffineTransformbool CATransform3DIsAffine (CATransform3D t);//将CATransform3D转换为CGAffineTransformCGAffineTransform CATransform3DGetAffineTransform (CATransform3D t); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之四——Layer层动画内容","slug":"159iOS开发CoreAnimation解读之四——Layer层动画内容","date":"2015-12-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.328Z","comments":true,"path":"2015/12/05/159iOS开发CoreAnimation解读之四——Layer层动画内容/","link":"","permalink":"http://huishao.cc/2015/12/05/159iOS开发CoreAnimation解读之四——Layer层动画内容/","excerpt":"","text":"iOS开发CoreAnimation解读之四——Layer层动画内容一、引言通过前几篇博客的介绍，我们可以了解到layer层可以设置许多与控件UI相关的属性，并且对于iOS开发，UIView层的属性是会映射到CALayer的，因此，可以通过UIKit和CoreAnimation两个框架来设置控件的UI相关属性，当属性发生变化时，我们可以使其展示一个动画效果。 二、CAAnimation动画体系的介绍CAAnimation是CoreAnimation框架中执行动画对象的基类，下面有一张图，是我手画的，不太美观，但是可以将与CAAnimation相关的几个动画类的关系表达清楚： 从上图中可以看到，从CAAnimation中继承出三个子类，分别是用于创建属性动画的CAPropertyAnimation，创建转场动画的CATransition和创建组合动画的CAAnimationGroup。 我们就先从根类开始探讨。 1.CAAnimation属性和方法CAAnimation作为动画对象的基类，其中封装了动画的基础属性，如下： 12345678//通过类方法创建一个CAAnimation对象+ (instancetype)animation;//动画执行的时序模式@property(nullable, strong) CAMediaTimingFunction *timingFunction;//代理@property(nullable, strong) id delegate;//是否动画完成时将动画对象移除掉@property(getter=isRemovedOnCompletion) BOOL removedOnCompletion; timingFunction定义了动画执行的时序效果，CAMediaTimingFunction的创建方式如下： 1234567891011121314/*name参数决定的执行的效果，可选参数如下//线性执行 NSString * const kCAMediaTimingFunctionLinear; //淡入 在动画开始时 淡入效果 NSString * const kCAMediaTimingFunctionEaseIn; //淡出 在动画结束时 淡出效果 NSString * const kCAMediaTimingFunctionEaseOut; //淡入淡出 NSString * const kCAMediaTimingFunctionEaseInEaseOut; //默认效果 NSString * const kCAMediaTimingFunctionDefault;*/+ (instancetype)functionWithName:(NSString *)name; CAAnimation的代理方法入如下几个： 1234//动画开始时执行的回调- (void)animationDidStart:(CAAnimation *)anim;//动画结束后执行的回调- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; 2.CAPropertyAnimation属性与方法CAPropertyAnimation是继承于CAAnimation专门用来创建与属性相关的动画的类： 12345678910111213//创建对象 参数中的path就是我们要执行动画的属性//例如，如果传入@&quot;backgroundColor&quot; 当layer的背景颜色改变时，就会执行我们设置的动画+ (instancetype)animationWithKeyPath:(nullable NSString *)path;//这个属性确定动画执行的状态是否叠加在控件的原状态上//默认设置为NO，如果我们执行两次位置移动的动画，会从同一位置执行两次//如果设置为YES，则会在第一次执行的基础上执行第二次动画@property(getter=isAdditive) BOOL additive;//这个属性对重复执行的动画有效果//默认为NO，重复执行的动画每次都是从起始状态开始//如果设置为yes，则为此执行都会在上一次执行的基础上执行@property(getter=isCumulative) BOOL cumulative;//这个属性和transfron属性的动画执行相关@property(nullable, strong) CAValueFunction *valueFunction; 上面这些属性中，只有一个需要我们注意，valueFunction是专门为了transform动画而设置的，因为我们没有办法直接改变transform3D中的属性，通过这个参数，可以帮助我们直接操作transfrom3D属性变化产生动画效果，举例如下，一个绕Z轴旋转的动画： 123456789101112 //绕z轴旋转的动画 CABasicAnimation * ani = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;]; //从0度开始 ani.fromValue = @0; //旋转到180度 ani.toValue = [NSNumber numberWithFloat:M_PI]; //时间2S ani.duration = 2; //设置为z轴旋转 ani.valueFunction = [CAValueFunction functionWithName:kCAValueFunctionRotateZ]; //执行动画 [layer addAnimation:ani forKey:@&quot;&quot;]; 实际上，使用点的方式也是可以访问到相应属性的，如果不设置valueFunction，使用如下方法也是可以进行绕Z轴旋转的： 12345678910//绕z轴旋转的动画 CABasicAnimation * ani = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; //从0度开始 ani.fromValue = @0; //旋转到180度 ani.toValue = [NSNumber numberWithFloat:M_PI]; //时间2S ani.duration = 2; //执行动画 [layer addAnimation:ani forKey:@&quot;&quot;]; 3.CABasicAnimation属性CABasicAnimaton是CAPropertyAnimation分出来的一个子类，创建基础的属性变化动画，例如我们上面的示例代码，其中属性如下： 123@property(nullable, strong) id fromValue;@property(nullable, strong) id toValue;@property(nullable, strong) id byValue; 上面三个属性都是来确定动画的起始与结束位置，有如下的含义： fromValue和toValue不为空：动画的值由fromValue变化到toValue fromValue和byValue不为空：动画的值由fromValue变化到fromValue+byValue byValue和toValue不为空：动画的值由toValue-byValue变化到toValue 只有fromValue不为空：动画的值由fromValue变化到layer的当前状态值 只有toValue不为空：动画的值由layer当前的值变化到toValue 只有byValue不为空：动画的值由layer当前的值变化到layer当前的值+byValue 4.CAKeyframeAnimation关键帧动画CAKeyframeAnimation也是继承与CAPropertyAnimation的一个子类，其与CABasicAnimation的不同之处在于虽然其都是改变layer层属性的动画，但是CABasicAnimation只能设置初始与结束状态，这之间我们没办法控制，而CAKeyframeAnimation可以让我们设置一些关键帧再整个动画的过程中。属性方法如下： 1234567891011121314151617//关键帧的值数组 例如我们想让控件沿某个路径移动，这里面存放每个移动的点@property(nullable, copy) NSArray *values;//直接设置路径，作用域values类似@property(nullable) CGPathRef path;//设置每一帧执行的时间长短 这个的取值为0-1，代表占用时间的比例@property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes;//每一帧执行过程中的时序效果 上面有提过@property(nullable, copy) NSArray&lt;CAMediaTimingFunction *&gt; *timingFunctions;/*设置帧的中间值如何计算 NSString * const kCAAnimationLinear; NSString * const kCAAnimationDiscrete; NSString * const kCAAnimationPaced; NSString * const kCAAnimationCubic; NSString * const kCAAnimationCubicPaced;*/@property(copy) NSString *calculationMode; 示例如下： 1234 CAKeyframeAnimation * ani = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; ani.values = @[[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(120, 100)],[NSValue valueWithCGPoint:CGPointMake(120, 200)],[NSValue valueWithCGPoint:CGPointMake(200, 200)]]; ani.duration = 3; [layer addAnimation:ani forKey:@&quot;&quot;]; 5.CASpringAnimation阻尼动画通过CASpringAnimation，可以帮助开发者很轻松的创建出有弹簧效果的动画，主要属性如下： 12345678910//这个属性设置弹簧重物的质量 会影响惯性 必须大于0 默认为1@property CGFloat mass;//设置弹簧的刚度系数，必须大于0 默认为100 这个越大 则回弹越快@property CGFloat stiffness;//阻尼系数 默认为10 必须大于0 这个值越大 回弹的幅度越小@property CGFloat damping;//初始速度@property CGFloat initialVelocity;//获取动画停下来需要的时间@property(readonly) CFTimeInterval settlingDuration; 6.CATransition转场动画CATransition和CAPropertyAnimation的不同之处在于当layer层出现时，会产生动画效果，而并不是属性改变时，属性如下： 123456789101112131415161718192021222324/*设置动画类型//淡入 NSString * const kCATransitionFade; //移入 NSString * const kCATransitionMoveIn; //压入 NSString * const kCATransitionPush; //溶解 NSString * const kCATransitionReveal;*/@property(copy) NSString *type;/*设置动画的方向//从右侧进 NSString * const kCATransitionFromRight; //从左侧进 NSString * const kCATransitionFromLeft; //从上侧进 NSString * const kCATransitionFromTop; //从下侧进 NSString * const kCATransitionFromBottom;*/@property(nullable, copy) NSString *subtype; 其实，关于type定义的动画效果，出来官方定义的，我们还可以使用一些私有的参数，如下： 12345pageCurl 翻页rippleEffect 滴水效果suckEffect 收缩效果，如一块布被抽走cube 立方体效果oglFlip 上下翻转效果 例如： 1234 CATransition * ani = [CATransition animation]; ani.type = @&quot;pageCurl&quot;; ani.subtype = kCATransitionFromRight; [layer addAnimation:ani forKey:@&quot;&quot;]; 7.CAAnimationGroup动画组CAAnimationGroup本身并没有定义动画，他可以将我们上面提到的相关动画进行组合： 1@property(nullable, copy) NSArray&lt;CAAnimation *&gt; *animations; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS运用runtime全局修改UILabel的默认字体","slug":"158iOS运用runtime全局修改UILabel的默认字体","date":"2015-12-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.327Z","comments":true,"path":"2015/12/02/158iOS运用runtime全局修改UILabel的默认字体/","link":"","permalink":"http://huishao.cc/2015/12/02/158iOS运用runtime全局修改UILabel的默认字体/","excerpt":"","text":"iOS运用runtime全局修改UILabel的默认字体一、需求背景介绍在项目比较成熟的基础上，遇到了这样一个需求，应用中需要引入新的字体，需要更换所有Label的默认字体，但是同时，对于一些特殊设置了字体的label又不需要更换。乍看起来，这个问题确实十分棘手，首先项目比较大，一个一个设置所有使用到的label的font工作量是巨大的，并且在许多动态展示的界面中，可能会漏掉一些label，产生bug。其次，项目中的label来源并不唯一，有用代码创建的，有xib和storyBoard中的，这也将浪费很大的精力。这种情况下，我们可能会有下面两种处理方式。 二、处理方式1、使用框架创建我们自己的BaseLabel类，在其中进行默认字体的设置，并且并不影响在使用过程中特殊设置字体的label，这种方式可以满足我们的需求，但是并不适于我们的场景，项目已经成熟，重建一个label基类，来让所有的UILabel都换成它的工作量不会比重新设置所有label字体的工作量小太多。但这也是有优势的，至少如果下次再换字体，我们就不用麻烦了。 2、使用runtime替换UILabel初始化方法这是最简单方便的方法，我们可以使用runtime机制替换掉UILabel的初始化方法，在其中对label的字体进行默认设置。因为Label可以从initWithFrame、init和nib文件三个来源初始化，所以我们需要将这三个初始化的方法都替换掉。 首先，我们创建一个UILabel的类别： 12345#import &lt;UIKit/UIKit.h&gt;@interface UILabel (YHBaseChangeDefaultFont)@end 在其中加入如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#import &quot;UILabel+YHBaseChangeDefaultFont.h&quot;#import &lt;objc/runtime.h&gt;@implementation UILabel (YHBaseChangeDefaultFont)/** *每个NSObject的子类都会调用下面这个方法 在这里将init方法进行替换，使用我们的新字体 *如果在程序中又特殊设置了字体 则特殊设置的字体不会受影响 但是不要在Label的init方法中设置字体 *从init和initWithFrame和nib文件的加载方法 都支持更换默认字体 */+(void)load&#123; //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); //替换三个方法 SEL originalSelector = @selector(init); SEL originalSelector2 = @selector(initWithFrame:); SEL originalSelector3 = @selector(awakeFromNib); SEL swizzledSelector = @selector(YHBaseInit); SEL swizzledSelector2 = @selector(YHBaseInitWithFrame:); SEL swizzledSelector3 = @selector(YHBaseAwakeFromNib); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method originalMethod2 = class_getInstanceMethod(class, originalSelector2); Method originalMethod3 = class_getInstanceMethod(class, originalSelector3); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); Method swizzledMethod2 = class_getInstanceMethod(class, swizzledSelector2); Method swizzledMethod3 = class_getInstanceMethod(class, swizzledSelector3); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); BOOL didAddMethod2 = class_addMethod(class, originalSelector2, method_getImplementation(swizzledMethod2), method_getTypeEncoding(swizzledMethod2)); BOOL didAddMethod3 = class_addMethod(class, originalSelector3, method_getImplementation(swizzledMethod3), method_getTypeEncoding(swizzledMethod3)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; if (didAddMethod2) &#123; class_replaceMethod(class, swizzledSelector2, method_getImplementation(originalMethod2), method_getTypeEncoding(originalMethod2)); &#125;else &#123; method_exchangeImplementations(originalMethod2, swizzledMethod2); &#125; if (didAddMethod3) &#123; class_replaceMethod(class, swizzledSelector3, method_getImplementation(originalMethod3), method_getTypeEncoding(originalMethod3)); &#125;else &#123; method_exchangeImplementations(originalMethod3, swizzledMethod3); &#125; &#125;); &#125;/** *在这些方法中将你的字体名字换进去 */- (instancetype)YHBaseInit&#123; id __self = [self YHBaseInit]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; return __self;&#125;-(instancetype)YHBaseInitWithFrame:(CGRect)rect&#123; id __self = [self YHBaseInitWithFrame:rect]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; return __self;&#125;-(void)YHBaseAwakeFromNib&#123; [self YHBaseAwakeFromNib]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; &#125;@end 在上面的方法中写入我们想要UILabel默认显示的字体，我们分别从init，initWithFrame和nib文件创建一个UILabel添加到视图上，不做任何其他的操作： 1234567UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 280, 30)]; label.text = @&quot;你是从initWithFrame来的label&quot;; UILabel * label2 = [[UILabel alloc]init]; label2.frame= CGRectMake(20, 200, 280, 30); label2.text = @&quot;你是从init来的label&quot;; [self.view addSubview:label]; [self.view addSubview:label2]; 运行效果如下，可以看出，字体全部换掉了： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之三——几种常用Layer的使用解析","slug":"157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析","date":"2015-11-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.327Z","comments":true,"path":"2015/12/01/157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析/","link":"","permalink":"http://huishao.cc/2015/12/01/157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析/","excerpt":"","text":"iOS开发CoreAnimation解读之三——几种常用Layer的使用解析一、CAEmitterLayerCAEmitterLayer是CoreAnimation框架中的粒子发射层，在以前的一片博客中有详细的介绍和范例，这里不再重复，地址如下： 粒子效果的应用和火焰范例：http://my.oschina.net/u/2340880/blog/485095 二、CAGradientLayerCAGradientLayer是用于色彩梯度展示的layer图层，通过CAGradientLayer，我们可以很轻松的创建出有过渡效果的色彩图。其中属性如下： 1234567891011121314151617181920/*颜色数组，设置我们需要过的的颜色，必须是CGColor对象*/@property(nullable, copy) NSArray *colors;/*颜色开始进行过渡的位置这个数组中的元素是NSNumber类型，单调递增的，并且在0——1之间例如，如果我们设置两个颜色进行过渡，这个数组中写入0.5，则第一个颜色会在达到layer一半的时候开始向第二个颜色过渡*/@property(nullable, copy) NSArray&lt;NSNumber *&gt; *locations;/*下面两个参数用于设置渲染颜色的起点和终点 取值范围均为0——1默认起点为（0.5 ，0） 终点为（0.5 ，1）,颜色的过渡范围就是沿y轴从上向下*/@property CGPoint startPoint;@property CGPoint endPoint;/*渲染风格 iOS中只支持一种默认的kCAGradientLayerAxial，我们无需手动设置*/@property(copy) NSString *type; 用如下代码创建一个度过视图的效果： 12345678 CAGradientLayer * layer = [CAGradientLayer layer]; layer.colors = @[(id)[UIColor redColor].CGColor,(id)[UIColor blueColor].CGColor,(id)[UIColor greenColor].CGColor]; layer.locations = @[@0.1,@0.7,@1]; layer.bounds = CGRectMake(0, 0, 100, 100); layer.position = CGPointMake(100, 100); layer.startPoint = CGPointMake(0, 0); layer.endPoint = CGPointMake(1, 1); [self.view.layer addSublayer:layer]; 效果如下： 三、CAReplicatorLayerCAReplocatorLayer是拷贝视图容器，我们可以通过它，将其中的子layer进行拷贝，并进行一些差异处理，其中常用属性方法如下： 12345678910111213141516//拷贝的次数@property NSInteger instanceCount;//是否开启景深效果@property BOOL preservesDepth;//当CAReplicatorLayer的子Layer层进行动画的时候，拷贝的副本执行动画的延时@property CFTimeInterval instanceDelay;//拷贝副本的3D变换@property CATransform3D instanceTransform;//拷贝副本的颜色变换@property(nullable) CGColorRef instanceColor;//每个拷贝副本的颜色偏移参数@property float instanceRedOffset;@property float instanceGreenOffset;@property float instanceBlueOffset;//每个拷贝副本的透明度偏移参数@property float instanceAlphaOffset; 例如，通过拷贝一个色块，使其产生平移排列： 1234567891011121314 CAReplicatorLayer *reLayer = [CAReplicatorLayer layer]; reLayer.position = CGPointMake(0, 0); CALayer * layer= [CALayer layer]; [reLayer addSublayer:layer]; [self.view.layer addSublayer:reLayer]; layer.bounds = CGRectMake(0, 0, 20, 20); layer.position = CGPointMake(30, 100); layer.backgroundColor = [UIColor redColor].CGColor; //每个副本向右平移25px reLayer.instanceTransform=CATransform3DMakeTranslation(25, 0, 0); //如果进行动画，副本延时一秒执行 reLayer.instanceDelay = 1; //拷贝十个副本 reLayer.instanceCount = 10; 效果如下： 四、CAShapeLayerCAShapeLayer是图形layer层，我们可以自定义这个层的形状。先来看其中我们可以使用的属性和方法： 1@property(nullable) CGPathRef path; path属性为CAShapeLayer设置一个边界路径，例如我们可以创建一个三角形的路径通过如下代码： 12345678 CAShapeLayer * layer = [CAShapeLayer layer]; layer.position=CGPointMake(0,0); CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, 0, 100, 100); CGPathAddLineToPoint(path, 0, 300, 100); CGPathAddLineToPoint(path, 0, 200, 200); CGPathAddLineToPoint(path, 0, 100, 100); layer.path=path; 仅仅有路径，不能将我们想要的形状画出来，下面一些属性可以对图形的一些基础属性进行设置： 12345678910111213141516171819202122232425262728293031323334353637383940//设置图形的填充颜色@property(nullable) CGColorRef fillColor;/*设置图形的填充规则 选项如下：非零填充 NSString *const kCAFillRuleNonZero; 奇偶填充 NSString *const kCAFillRuleEvenOdd;*/@property(copy) NSString *fillRule;//设置线条颜色@property(nullable) CGColorRef strokeColor;//设置线条的起点与终点 0-1之间@property CGFloat strokeStart;@property CGFloat strokeEnd;//设置线条宽度@property CGFloat lineWidth;//设置两条线段相交时锐角斜面长度@property CGFloat miterLimit;/*设置线条首尾的外观可选参数如下无形状 NSString *const kCALineCapButt; 圆形 NSString *const kCALineCapRound; 方形 NSString *const kCALineCapSquare;*/@property(copy) NSString *lineCap;/*设置线段的链接方式棱角 NSString *const kCALineJoinMiter; 平滑 NSString *const kCALineJoinRound; 折线 NSString *const kCALineJoinBevel;*/@property(copy) NSString *lineJoin; 修改一下上面的代码，如下： 1234567891011121314151617CAShapeLayer * layer = [CAShapeLayer layer]; layer.position=CGPointMake(0,0); CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, 0, 100, 100); CGPathAddLineToPoint(path, 0, 300, 100); CGPathAddLineToPoint(path, 0, 200, 200); CGPathAddLineToPoint(path, 0, 100, 100); layer.path=path; layer.fillColor= [UIColor redColor].CGColor; layer.fillRule = kCAFillRuleEvenOdd; layer.strokeColor = [UIColor blueColor].CGColor; layer.strokeStart =0; layer.strokeEnd =0.5; layer.lineWidth = 5; layer.miterLimit = 1; layer.lineJoin = kCALineJoinMiter; [self.view.layer addSublayer:layer]; 效果如下： 除此之外，我们还可以设置边界的线条为虚线，通过下面两个属性： 1234567 //设置线段的宽度为5px 间距为10px /* 这个数组中还可以继续添加，会循环进行设置 例如 5 2 1 3 则第一条线段5px，间距2px，第二条线段1px 间距3px再开始第一条线段 */ layer.lineDashPattern = @[@05,@10]; //设置从哪个位置开始 layer.lineDashPhase =5; 如下： 五、CATextLayerCATextLayer可以进行文本的绘制，属性方法如下： 123456789101112131415161718192021222324252627282930//渲染的文字字符串@property(nullable, copy) id string;//设置字体@property(nullable) CFTypeRef font;//设置字号@property CGFloat fontSize;//设置文字颜色@property(nullable) CGColorRef foregroundColor;//是否换行@property(getter=isWrapped) BOOL wrapped;/*设置截断模式 NSString * const kCATruncationNone; 截断前部分 NSString * const kCATruncationStart; 截断后部分 NSString * const kCATruncationEnd; 截断中间 NSString * const kCATruncationMiddle;*/@property(copy) NSString *truncationMode;/*设置文字对齐模式 NSString * const kCAAlignmentNatural; NSString * const kCAAlignmentLeft; NSString * const kCAAlignmentRight; NSString * const kCAAlignmentCenter; NSString * const kCAAlignmentJustified;*/@property(copy) NSString *alignmentMode; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之二——对CALayer的分析","slug":"156iOS开发CoreAnimation解读之二——对CALayer的分析","date":"2015-11-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.327Z","comments":true,"path":"2015/11/26/156iOS开发CoreAnimation解读之二——对CALayer的分析/","link":"","permalink":"http://huishao.cc/2015/11/26/156iOS开发CoreAnimation解读之二——对CALayer的分析/","excerpt":"","text":"iOS开发CoreAnimation解读之二——对CALayer的分析一、UIView中的CALayer属性1.Layer专门负责view的视图渲染每一个UIView的对象中都有一个layer这样的属性，并且layer会负责view中有关图形绘制的相关操作，例如我们设置view的背景颜色和设置layer的背景颜色都是有效的，并且，设置view的背景色依然是通过layer来展示的，我们可以写如下的测试代码： 1234567 UIView * view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; view.backgroundColor = [UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; view2.layer.backgroundColor = view.layer.backgroundColor; [self.view addSubview:view]; [self.view addSubview:view2]; 可以看出，我们设置view的backgroundColor属性其实起作用的也是layer的backgroundColor。 2.自定义view默认layer属性的类UIView是很多视图类的父类，根据功能不同，会分出UIImageView，UIScrollerView，UITableView等，CALayer也相似，其也可以根据功能分出许多子类，还可以根据我们的需求自定义一个Layer类。UIView其中的layer默认是CALyer类，我们也可以通过重写View中的如下方法来使其创建我们需要的layer类： 12+(Class)layerClass&#123;&#125; 例如我们自定义一个View类，在自定义一个Layer类，是的自定义的View默认创建的layer是自定义的layer： 在MyView中重写上述方法： 123+(Class)layerClass&#123; return [MyLayer class];&#125; 在MyLayer中进行一些自定义： 12345678- (instancetype)init&#123; self = [super init]; if (self) &#123; self.backgroundColor = [UIColor redColor].CGColor; &#125; return self;&#125; 之后我们使用这个MyView的对象时，layer层的背景色就是红色的了。 二、几种系统的Layer类前边说过，和UIView相似，CALayer也很据功能衍生出许多子类，系统系统给我们可以使用的有如下几种： 1.CAEmitterLayerCoreAnimation框架中的CAEmitterLayer是一个粒子发射器系统，负责粒子的创建和发射源属性。通过它，我们可以轻松创建出炫酷的粒子效果。 2.CAGradientLayerCAGradientLayer可以创建出色彩渐变的图层效果，如下： 3.CAEAGLLayerCAEAGLLayer可以通过OpenGL ES来进行界面的绘制。 4.CAReplicatorLayerCAReplicatorLayer是一个layer容器，会对其中的subLayer进行复制和属性偏移，通过它，可以创建出类似倒影的效果，也可以进行变换复制，如下： 5.CAScrollLayerCAScrollLayer可以支持其上管理的多个子层进行滑动，但是只能通过代码进行管理，不能进行用户点按触发。 6.CAShapeLayerCAShapeLayer可以让我们在layer层是直接绘制出自定义的形状。 7.CATextLayerCATextLayer可以通过字符串进行文字的绘制。 8.CATiledLayerCATiledLayer类似瓦片视图，可以将绘制分区域进行，常用于一张大的图片的分不分绘制。 9.CATransformLayerCATransformLayer用于构建一些3D效果的图层。 三、设置与调整Layer层的内容设置层的内容有下面三种方式： 1.可以通过设置CGImage为layer的内容。 2.可以通过代理方法来动态修改或者绘制层的内容。 3.通过自定义CALayer对象来创建层的内容。 当你设置了Layer的内容后，例如设置了一张图片，内容的尺寸不一定会刚好和layer的尺寸合适，我们可以对其位置的调整，使其达到我们想要的效果，contentsGravity属性决定了内容对齐与填充方式，它可以分为两个方面： 1.不改变内容的原始大小 这种模式中不会改变内容的原始大小，如果层的尺寸小于内容的尺寸，则内容会被切割，如果层的尺寸大于内容的尺寸，多出的部分将会显示层的背景颜色。下面的这些设置方式为这种模式： 123456789101112131415161718CA_EXTERN NSString * const kCAGravityCenter __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTop __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottom __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTopLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTopRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottomLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottomRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0); 每个参数对应的对其模式如下图： 2.改变内容的尺寸大小 这种模式设置的实际上是一种填充方式，参数如下： 123456CA_EXTERN NSString * const kCAGravityResize __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityResizeAspect __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityResizeAspectFill __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0); 四、CALayer的接口应用总结1、创建与初始化layer相关123456//通过类方法创建并初始化一个layer+ (instancetype)layer;//初始化方法- (instancetype)init;//通过一个layer创建一个副本- (instancetype)initWithLayer:(id)layer; 2、渲染层layer与模型层layer在CALayer中，有如下两个属性，他们都返回一个CALayer的对象： 1234//渲染层layer- (nullable id)presentationLayer;//模型层layer- (id)modelLayer; 对于presentationLayer，这个属性不一定总会返回一个实体对象，只有当进行动画或者其他渲染的操作时，这个属性会返回一个在当前屏幕上的layer，不且每一次执行，这个对象都会不同，它是原layer的一个副本presentationLayer的modelLayer就是其实体layer层。 对于modelLayer，它会返回当前的存储信息的Layer，也是当前的layer对象，始终唯一。 3.一些属性与方法1+ (nullable id)defaultValueForKey:(NSString *)key; 上面这个属性用于设置layer中默认属性的值，我们可以在子类中重写这个方法来改变默认创建的layer的一些属性，例如如下代码，我们创建出来的layer就默认有红色的背景颜色： 123456+(id)defaultValueForKey:(NSString *)key&#123; if ([key isEqualToString:@&quot;backgroundColor&quot;]) &#123; return (id)[UIColor redColor].CGColor; &#125; return [super defaultValueForKey:key];&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//这个方法也只使用在子类中重写，用于设置在某些属性改变时是否进行layer重绘+ (BOOL)needsDisplayForKey:(NSString *)key;//子类重写这个方法设置属性是否可以被归档- (BOOL)shouldArchiveValueForKey:(NSString *)key;/*********************************************///设置layer尺寸@property CGRect bounds;//设置layer位置@property CGPoint position;//设置其在父layer中的层次，默认为0，这个值越大，层次越靠上@property CGFloat zPosition;//锚点@property CGPoint anchorPoint;//在Z轴上的锚点位置 3D变换时会有很大影响@property CGFloat anchorPointZ;//进行3D变换@property CATransform3D transform;//获取和设置CGAffineTransform变换- (CGAffineTransform)affineTransform;- (void)setAffineTransform:(CGAffineTransform)m;//设置layer的frame@property CGRect frame;//设置是否隐藏@property(getter=isHidden) BOOL hidden;//每个layer层有两面，这个属性确定是否两面都显示@property(getter=isDoubleSided) BOOL doubleSided;//是否进行y轴的方向翻转@property(getter=isGeometryFlipped) BOOL geometryFlipped;//获取当前layer内容y轴方向是否被翻转了- (BOOL)contentsAreFlipped;//父layer视图@property(nullable, readonly) CALayer *superlayer;//从其父layer层上移除- (void)removeFromSuperlayer;//所有子layer数组@property(nullable, copy) NSArray&lt;CALayer *&gt; *sublayers;//添加一个字layer- (void)addSublayer:(CALayer *)layer;//插入一个子layer- (void)insertSublayer:(CALayer *)layer atIndex:(unsigned)idx;//将一个子layer插入到最下面- (void)insertSublayer:(CALayer *)layer below:(nullable CALayer *)sibling;//将一个子layer插入到最上面- (void)insertSublayer:(CALayer *)layer above:(nullable CALayer *)sibling;//替换一个子layer- (void)replaceSublayer:(CALayer *)layer with:(CALayer *)layer2;//对其子layer进行3D变换@property CATransform3D sublayerTransform;//遮罩层layer@property(nullable, strong) CALayer *mask;//舍否进行bounds的切割，在设置圆角属性时会设置为YES@property BOOL masksToBounds;//下面这些方法用于坐标转换- (CGPoint)convertPoint:(CGPoint)p fromLayer:(nullable CALayer *)l;- (CGPoint)convertPoint:(CGPoint)p toLayer:(nullable CALayer *)l;- (CGRect)convertRect:(CGRect)r fromLayer:(nullable CALayer *)l;- (CGRect)convertRect:(CGRect)r toLayer:(nullable CALayer *)l;//返回包含某一点的最上层的子layer- (nullable CALayer *)hitTest:(CGPoint)p;//返回layer的bounds内是否包含某一点- (BOOL)containsPoint:(CGPoint)p;//设置layer的内容，一般会设置为CGImage的对象@property(nullable, strong) id contents;//获取内容的rect尺寸@property CGRect contentsRect;//设置内容的填充和对其方式，具体上面有说@property(copy) NSString *contentsGravity;//设置内容的缩放@property CGFloat contentsScale; 下面这个属性和内容拉伸相关： 1@property CGRect contentsCenter; 这个属性确定一个矩形区域，当内容进行拉伸或者缩放的时候，这一部分的区域是会被形变的，例如默认设置为(0,0,1,1)，则整个内容区域都会参与形变。如果我们设置为(0.25,0.25,0.5,0.5),那么只有中间0.5*0.5比例宽高的区域会被拉伸，四周都不会。 下面这两个属性用来设置缩放或拉伸的模式： 12345678910111213//设置缩小的模式@property(copy) NSString *minificationFilter;//设置放大的模式@property(copy) NSString *magnificationFilter;//缩放因子@property float minificationFilterBias;//模式参数如下//临近插值NSString * const kCAFilterNearest;//线性拉伸NSString * const kCAFilterLinear;//瓦片复制拉伸NSString * const kCAFilterTrilinear; 1234567891011121314151617//设置内容是否完全不透明@property(getter=isOpaque) BOOL opaque;//重新加载绘制内容- (void)display;//设置内容为需要重新绘制- (void)setNeedsDisplay;//设置某一区域内容需要重新绘制- (void)setNeedsDisplayInRect:(CGRect)r;//获取是否需要重新绘制- (BOOL)needsDisplay;//如果需要，进行内容重绘- (void)displayIfNeeded;//这个属性设置为YES，当内容改变时会自动调用- (void)setNeedsDisplay函数@property BOOL needsDisplayOnBoundsChange;//绘制与读取内容- (void)drawInContext:(CGContextRef)ctx;- (void)renderInContext:(CGContextRef)ctx; 1234567891011121314151617181920//设置背景颜色@property(nullable) CGColorRef backgroundColor;//设置圆角半径@property CGFloat cornerRadius;//设置边框宽度@property CGFloat borderWidth;//设置边框颜色@property(nullable) CGColorRef borderColor;//设置透明度@property float opacity;//设置阴影颜色@property(nullable) CGColorRef shadowColor;//设置阴影透明度@property float shadowOpacity;//设置阴影偏移量@property CGSize shadowOffset;//设置阴影圆角半径@property CGFloat shadowRadius;//设置阴影路径@property(nullable) CGPathRef shadowPath; 12345678910//添加一个动画对象 key值起到id的作用，通过key值，可以取到这个动画对象- (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key;//移除所有动画对象- (void)removeAllAnimations;//移除某个动画对象- (void)removeAnimationForKey:(NSString *)key;//获取所有动画对象的key值- (nullable NSArray&lt;NSString *&gt; *)animationKeys;//通过key值获取动画对象- (nullable CAAnimation *)animationForKey:(NSString *)key; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程","slug":"155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程","date":"2015-11-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.327Z","comments":true,"path":"2015/11/25/155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程/","link":"","permalink":"http://huishao.cc/2015/11/25/155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程/","excerpt":"","text":"iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程一、引言众所周知，绚丽动画效果是iOS系统的一大特点，通过UIView层封装的动画，基本已经可以满足我们应用开发的所有需求，但若需要更加自由的控制动画的展示，我们就需要使用CoreAnimation框架中的一些类与方法。这里先附上前几篇与动画相关的博客地址，这一系列，我们抽出其中的CoreAnimation框架来详细解读。 UIViewAnimation动画的使用：http://my.oschina.net/u/2340880/blog/484457 UIView动画执行的另一种方式：http://my.oschina.net/u/2340880/blog/484538 UIView转场动画：http://my.oschina.net/u/2340880/blog/484669 CoreAnimation隐式动画的应用：http://my.oschina.net/u/2340880/blog/484793 粒子效果的使用：http://my.oschina.net/u/2340880/blog/485095 二、初识CoreAnimationCoreAnimation框架是基于OpenGL与CoreGraphics图像处理框架的一个跨平台的动画框架。简单来说，它使帮助我们将图像读取成位图，通过硬件的处理，实现动画效果。文档中的一张图片十分形象的描述了CoreAnimation与UIKit框架的关系： 在CoreAnimation中，大部分的动画效果都是通过Layer层来实现的，通过CALayer，我们可以组织复杂的层级结构。 在CoreAnimation中，大多数的动画效果是添加在图层属性的变化上，例如，改变图层的位置，大小，颜色，圆角半径等。Layer层并不决定视图的展现，它只是存储了视图的几何属性状态。 三、锚点对几何属性的影响关于Layer层，我们需要了解一个有关锚点的概念，锚点决定了图层的绘制位置以及动画展示时其参照的点，锚点的取值范围为0-1，锚点有两个地方在应用中会有很大影响： 1.layer层的position参照点始终和锚点重合 通过position决定了layer所在的位置，在Layer中，虽然也有frame这样的属性，但我们很少使用，一般我们会使用bounds和position确定Layer层的大小和位置。 2.锚点决定进行动作的参照点 例如一个旋转动作，锚点决定了层旋转的中心点，对于放大缩小的动作，锚点决定了放大或者缩小参照的中心点。 可以来看下边一组图： 上面两个矩形，frame和bounds都是一样的，第一个矩形的锚点位置为(0.5,0.5)，第二个为(0,0), 因此，两个矩形的position点是不同的，第一个是(100,100),第二个是(40,60)。再看当产生动作时锚点的影响： 现在就很好理解了，锚点的不同直接影响了动作产生的参照点。 通过CALayer的如下属性，我们可以设置锚点，注意x，y的取值范围都是0~1，代表所占宽度和高度的比例： 1@property CGPoint anchorPoint; 四、Layer与View之间的关系Layer是专门用于辅助我们绘制图像的层，它使支持三维坐标系的绘制的，通过每个坐标点与转换矩阵的运算，来决定最后绘制的状态，并且，Layer可以更高帧率的绘制动画效果。然而Layer与View依然有很大不同，首先，我们不可能只通过Layer来开发应用程序，Layer并没有接收事件和处理用户交互的能力，这些依然需要View来完成，每一个View中，都有一个Layer的属性来辅助进行图形的绘制。并且Layer是可以层级嵌套的，开发中，我们可以根据需求灵活选择。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS9新特性——堆叠视图UIStackView","slug":"154iOS9新特性——堆叠视图UIStackView","date":"2015-11-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.326Z","comments":true,"path":"2015/11/17/154iOS9新特性——堆叠视图UIStackView/","link":"","permalink":"http://huishao.cc/2015/11/17/154iOS9新特性——堆叠视图UIStackView/","excerpt":"","text":"iOS9新特性——堆叠视图UIStackView一、引言随着autolayout的推广开来，更多的app开始使用自动布局的方式来构建自己的UI系统，autolayout配合storyBoard和一些第三方的框架，对于创建约束来说，已经十分方便，但是对于一些动态的线性布局的视图，我们需要手动添加的约束不仅非常多，而且如果我们需要插入或者移除其中的一些UI元素的时候，我们又要做大量的修改约束的工作，UIStackView正好可以解决这样的问题。 二、在storyBoard上初识StackViewUIStackView是一个管理一组堆叠视图的控制器类视图，所谓堆叠视图时一种平铺式的线性布局方式，不可重叠，布局方向也不可交错，如果你做过watchOS的开发，你会发现，其实StackView与watchOS中的group十分能相似。 例如，我们如果需要一个如下效果的布局，在屏幕的中间摆放几个大小一致的色块，无论屏幕朝向如何，其位置都不会变化，并且可以向其中添加和移除色块的数量： 首先，我们在ViewController中拉入一个stackView： 将一些属性设置如下： Axis是设置布局的方向，有水平和垂直两种方式，一个StackView只能选择一种布局模式。 Alignment是选择其管理视图的对齐模式，我们这里选择充满。 Distribution是设置其管理视图的排列方式，我们选择等宽充满。 Spacing是设置视图之间的间距，设置为10. 之后有一点需要注意，stackView用于布局其内部管理的视图，对于它本身，我们还需要添加一些约束，将它约束在屏幕的中间。 我们向其中拖入任意数量的view，设置不同的颜色，就实现了我们想要的效果，并且可以随意动态删除和添加其中的view数量，不需要改变约束。 三、从代码学习UIStackView通过代码创建一个UIStackView也非常简单，首先，我们先通过代码实现上面的效果： 123456789101112131415161718 NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i =0 ; i&lt;5; i++) &#123; UIView * view = [[UIView alloc]init]; view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [array addObject:view]; &#125; UIStackView * stackView = [[UIStackView alloc]initWithArrangedSubviews:array]; [self.view addSubview:stackView]; [stackView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(self.view.mas_centerX); make.centerY.equalTo(self.view.mas_centerY); make.leading.equalTo(self.view.mas_leading).offset(20); make.trailing.equalTo(self.view.mas_trailing).offset(-20); make.size.height.equalTo(@100); &#125;]; stackView.axis = UILayoutConstraintAxisHorizontal; stackView.distribution = UIStackViewDistributionFillEqually; stackView.alignment = UIStackViewAlignmentFill; 效果图如下： 我们的布局没有问题，并且可以动态的改变其中view的个数，使用如下方法添加一个view： 123 UIView * newView = [[UIView alloc]init]; newView.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [stackView addArrangedSubview:newView]; 与之相对，我们可以使用下面的方法移除一个view： 12 UIView * view = [stackView arrangedSubviews].lastObject; [stackView removeArrangedSubview:view]; 特别注意：addArrangedSubview和addSubview有很大的区别，使用前者是将试图添加进StackView的布局管理，后者只是简单的加在试图的层级上，并不接受StackView的布局管理。 技巧：因为StackView继承于UIView，因此在布局改变的时候，我们可以使用UIView层的动画，如下： 12345 //在添加view的时候会有动画效果，移除的时候没有 [stackView addArrangedSubview:newView]; [UIView animateWithDuration:1 animations:^&#123; [stackView layoutIfNeeded]; &#125;]; 四、再来深入理解下UIStackView通过上面的介绍，我们已经基本了解了StackView的使用和特点，下面我们再来仔细介绍一下与其相关的属性和方法的使用，使我们能够更加得心应手。 有关被管理视图的添加与移除： 12345678910//初始化方法，通过数组传入被管理的视图- (instancetype)initWithArrangedSubviews:(NSArray&lt;__kindof UIView *&gt; *)views; //获取被管理的所有视图@property(nonatomic,readonly,copy) NSArray&lt;__kindof UIView *&gt; *arrangedSubviews;//添加一个视图进行管理- (void)addArrangedSubview:(UIView *)view;//移除一个被管理的视图- (void)removeArrangedSubview:(UIView *)view;//在指定位置插入一个被管理的视图- (void)insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex; 与StackView布局设置相关： 1.布局模式： 1@property(nonatomic) UILayoutConstraintAxis axis; 上面这个属性用于设置布局的模型，枚举如下： 1234567//stackView只有两种布局模式 水平和竖直typedef NS_ENUM(NSInteger, UILayoutConstraintAxis) &#123; //水平布局 UILayoutConstraintAxisHorizontal = 0, //竖直布局 UILayoutConstraintAxisVertical = 1&#125;; 2.对齐模式： 1@property(nonatomic) UIStackViewAlignment alignment; 这个属性用于设置控件的对其模式，枚举如下： 123456789101112131415161718typedef NS_ENUM(NSInteger, UIStackViewAlignment) &#123; //水平布局时为高度充满，竖直布局时为宽度充满 UIStackViewAlignmentFill, //前边对其 UIStackViewAlignmentLeading, //顶部对其 UIStackViewAlignmentTop = UIStackViewAlignmentLeading, //第一个控件文字的基线对其 水平布局有效 UIStackViewAlignmentFirstBaseline, //中心对其 UIStackViewAlignmentCenter, //后边对其 UIStackViewAlignmentTrailing, //底部对其 UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing, //基线对其，水平布局有效 UIStackViewAlignmentLastBaseline, &#125; NS_ENUM_AVAILABLE_IOS(9_0); 在上面的例子中，我们设置了对其方式为充满，这样的话，我们就不需要再做过多控件尺寸的约束，如果我们被管理的控件高度或者宽度不一，我们可以设置中心对其，这样的话，我们还需要为每个控件添加一个宽度或者高度的约束，如下： 12345678910111213141516171819202122 NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i =0 ; i&lt;5; i++) &#123; UIView * view = [[UIView alloc]init]; view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; float height = arc4random()%90+10; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo([NSNumber numberWithFloat:height]); &#125;]; [array addObject:view]; &#125; stackView = [[UIStackView alloc]initWithArrangedSubviews:array]; [self.view addSubview:stackView]; [stackView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(self.view.mas_centerX); make.centerY.equalTo(self.view.mas_centerY); make.leading.equalTo(self.view.mas_leading).offset(20); make.trailing.equalTo(self.view.mas_trailing).offset(-20); make.size.height.equalTo(@100); &#125;]; stackView.axis = UILayoutConstraintAxisHorizontal; stackView.distribution = UIStackViewDistributionFillEqually; stackView.alignment = UIStackViewAlignmentCenter; 效果如下： 这样，参差不齐的控件布局我们也可以轻松完成。 3.排列方式 1@property(nonatomic) UIStackViewDistribution distribution; 排列方式的枚举如下： 123456789101112typedef NS_ENUM(NSInteger, UIStackViewDistribution) &#123; //充满，当只有一个控件时可以使用 UIStackViewDistributionFill = 0, //平分充满，每个控件占据相同尺寸排列充满 UIStackViewDistributionFillEqually, //会优先按照约束的尺寸进行排列，如果没有充满，会拉伸最后一个排列的控件充满 UIStackViewDistributionFillProportionally, //等间距排列 UIStackViewDistributionEqualSpacing, //中心距离相等 UIStackViewDistributionEqualCentering,&#125; NS_ENUM_AVAILABLE_IOS(9_0); 注意，除了我们选择fill属性时不需约束控件视图的尺寸，其他都需要进行约束，例如如果我们选择等间距，我把改成如下代码： 123456 [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo([NSNumber numberWithFloat:height]); make.width.equalTo(@50); &#125;]; stackView.distribution = UIStackViewDistributionEqualSpacing; 效果如下： 4.其他 123456//设置最小间距@property(nonatomic) CGFloat spacing;//设置布局时是否参照基线@property(nonatomic,getter=isBaselineRelativeArrangement) BOOL baselineRelativeArrangement;//设置布局时是否以控件的LayoutMargins为标准，默认为NO，是以控件的bounds为标准@property(nonatomic,getter=isLayoutMarginsRelativeArrangement) BOOL layoutMarginsRelativeArrangement; 五、UIStackView的嵌套一个StackView不允许我们进行水平和竖直的交叉布局，但是我们可以通过嵌套的方式来实现复杂的布局效果，比如我们实现一个类似电影表标签，可以使用水平布局的StackView中嵌套一个竖直布局的StackView： 十分轻松就可以实现如下的效果： 看到了吧，通过StackView，我们没有添加过多的约束，使我们布局起来更加轻松了。如果你常常使用storyBoard进行开发，还有一个小技巧可以方便的将两个控件整合到一个StackView中，按住command，选中两个控件，之后点击右下角的如下图标，系统会自动帮我们生成一个StackView，将选中的两个控件整合进去，很酷吧！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发中标签控制器的使用——UITabBarController","slug":"153iOS开发中标签控制器的使用——UITabBarController","date":"2015-11-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.326Z","comments":true,"path":"2015/11/13/153iOS开发中标签控制器的使用——UITabBarController/","link":"","permalink":"http://huishao.cc/2015/11/13/153iOS开发中标签控制器的使用——UITabBarController/","excerpt":"","text":"iOS开发中标签控制器的使用——UITabBarController一、引言与导航控制器相类似，标签控制器也是用于管理视图控制器的一个UI控件，在其内部封装了一个标签栏，与导航不同的是，导航的管理方式是纵向的，采用push与pop切换控制器，标签的管理是横向的，通过标签的切换来改变控制器，一般我们习惯将tabBar作为应用程序的根视图控制器，在其中添加导航，导航中在对ViewController进行管理。 二、创建一个标签控制器通过如下的步骤，我们可以很简便的创建一个TabBarController： 12345678910111213UITabBarController * tabBar= [[UITabBarController alloc]init]; NSMutableArray * controllerArray = [[NSMutableArray alloc]init]; for (int i=0; i&lt;4; i++) &#123; UIViewController * con = [[UIViewController alloc]init]; [con loadViewIfNeeded]; con.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; con.tabBarItem.image = [UIImage imageNamed:@&quot;btn_publish_face_a.png&quot;]; con.tabBarItem.title=[NSString stringWithFormat:@&quot;%d&quot;,i+1]; con.title = [NSString stringWithFormat:@&quot;%d&quot;,i+1]; [controllerArray addObject:con]; &#125; tabBar.viewControllers = controllerArray; [self presentViewController:tabBar animated:YES completion:nil]; 通过点击下面的标签按钮，可以很方便的切换控制器。如果我们的控制器数超过4个，系统会被我们创建一个more的导航，并且可以通过系统自带的编辑来调整控制器的顺序，如下： 三、UITabBarController的属性和方法123456789101112131415//管理的viewController数组@property(nullable, nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;- (void)setViewControllers:(NSArray&lt;__kindof UIViewController *&gt; * __nullable)viewControllers animated:(BOOL)animated;//选中的ViewControlle@property(nullable, nonatomic, assign) __kindof UIViewController *selectedViewController;//通过编号设置选中ViewController@property(nonatomic) NSUInteger selectedIndex;//当viewController大于4个时，获取&quot;更多&quot;标签的导航控制器@property(nonatomic, readonly) UINavigationController *moreNavigationController; //这个属性设置的是可以进行自定义排列顺序的视图控制器，如上面第二张图中的，默认是全部@property(nullable, nonatomic, copy) NSArray&lt;__kindof UIViewController *&gt; *customizableViewControllers;//标签控制器中分装的标签栏@property(nonatomic,readonly) UITabBar *tabBar NS_AVAILABLE_IOS(3_0);//代理@property(nullable, nonatomic,weak) id&lt;UITabBarControllerDelegate&gt; delegate; 四、关于标签栏TabBar通过自定义标签栏的一些属性，使我们可以更加灵活的使用tabBar。 1、UITabBar属性和方法设置标签： 1234@property(nullable,nonatomic,copy) NSArray&lt;UITabBarItem *&gt; *items; //设置选中的标签 @property(nullable,nonatomic,assign) UITabBarItem *selectedItem; - (void)setItems:(nullable NSArray&lt;UITabBarItem *&gt; *)items animated:(BOOL)animated; 设置自定义标签顺序： 123456//调用这个方法会弹出一个类似上面第二张截图的控制器，我们可以交换标签的布局顺序- (void)beginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //完成标签布局- (BOOL)endCustomizingAnimated:(BOOL)animated; //是否正在自定义标签布局- (BOOL)isCustomizing; 设置tabBar颜色相关： 1234//设置渲染颜色，会影响选中字体和图案的渲染@property(null_resettable, nonatomic,strong) UIColor *tintColor;//设置导航栏的颜色@property(nullable, nonatomic,strong) UIColor *barTintColor; 设置背景图案： 123456//设置导航栏背景图案@property(nullable, nonatomic,strong) UIImage *backgroundImage;//设置选中一个标签时，标签背后的选中提示图案 这个会出现在设置的item图案的后面@property(nullable, nonatomic,strong) UIImage *selectionIndicatorImage;//设置阴影的背景图案@property(nullable, nonatomic,strong) UIImage *shadowImage TabBar中标签的宏观属性： 123456789101112//设置标签item的位置模式@property(nonatomic) UITabBarItemPositioning itemPositioning;//枚举如下typedef NS_ENUM(NSInteger, UITabBarItemPositioning) &#123; UITabBarItemPositioningAutomatic,//自动 UITabBarItemPositioningFill,//充满 UITabBarItemPositioningCentered,//中心&#125; NS_ENUM_AVAILABLE_IOS(7_0);//设置item宽度@property(nonatomic) CGFloat itemWidth;//设置item间距@property(nonatomic) CGFloat itemSpacing; 与导航栏类似，也可以设置tabBar的风格和透明效果： 1234//风格 分黑白两种@property(nonatomic) UIBarStyle barStyle;//是否透明效果@property(nonatomic,getter=isTranslucent) BOOL translucent; 2、UITabBarDelegate123456789//选中标签时调用- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item;//将要开始编辑标签时- (void)tabBar:(UITabBar *)tabBar willBeginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //已经开始编辑标签时 - (void)tabBar:(UITabBar *)tabBar didBeginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //将要进入编辑状态时- (void)tabBar:(UITabBar *)tabBar willEndCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items changed:(BOOL)changed; //已经进入编辑状态时- (void)tabBar:(UITabBar *)tabBar didEndCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items changed:(BOOL)changed; 五、再看UITabBarItem和NavigationItem类似，标签栏上的item也可以自定义，一些方法如下。 初始化方法： 12345//通过标题和图案进行创建- (instancetype)initWithTitle:(nullable NSString *)title image:(nullable UIImage *)image tag:(NSInteger)tag;- (instancetype)initWithTitle:(nullable NSString *)title image:(nullable UIImage *)image selectedImage:(nullable UIImage *)selectedImage;//创建系统类型的- (instancetype)initWithTabBarSystemItem:(UITabBarSystemItem)systemItem tag:(NSInteger)tag; UITabBarSystemItem的枚举如下： 1234567891011121314typedef NS_ENUM(NSInteger, UITabBarSystemItem) &#123; UITabBarSystemItemMore,//更多图标 UITabBarSystemItemFavorites,//最爱图标 UITabBarSystemItemFeatured,//特征图标 UITabBarSystemItemTopRated,//高级图标 UITabBarSystemItemRecents,//最近图标 UITabBarSystemItemContacts,//联系人图标 UITabBarSystemItemHistory,//历史图标 UITabBarSystemItemBookmarks,//图书图标 UITabBarSystemItemSearch,//查找图标 UITabBarSystemItemDownloads,//下载图标 UITabBarSystemItemMostRecent,//记录图标 UITabBarSystemItemMostViewed,//全部查看图标&#125;; UITabBarItem常用属性： 12//设置选中图案@property(nullable, nonatomic,strong) UIImage *selectedImage; 下面这个属性可以设置item的头标文字： 1 con.tabBarItem.badgeValue = @&quot;1&quot;; 12//设置标题的位置偏移@property (nonatomic, readwrite, assign) UIOffset titlePositionAdjustment; 由于UITabBarItem是继承于UIBarItem，还有下面这个属性可以设置使用： 12345678910111213//标题@property(nullable, nonatomic,copy) NSString *title; //图案 @property(nullable, nonatomic,strong) UIImage *image; //横屏时的图案 @property(nullable, nonatomic,strong) UIImage *landscapeImagePhone;//图案位置偏移@property(nonatomic) UIEdgeInsets imageInsets; //横屏时的图案位置偏移@property(nonatomic) UIEdgeInsets landscapeImagePhoneInsets ;//设置和获取标题的字体属性- (void)setTitleTextAttributes:(nullable NSDictionary&lt;NSString *,id&gt; *)attributes forState:(UIControlState)state;- (nullable NSDictionary&lt;NSString *,id&gt; *)titleTextAttributesForState:(UIControlState)state; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS自定义的emoji表情键盘","slug":"152iOS自定义的emoji表情键盘","date":"2015-11-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.326Z","comments":true,"path":"2015/11/11/152iOS自定义的emoji表情键盘/","link":"","permalink":"http://huishao.cc/2015/11/11/152iOS自定义的emoji表情键盘/","excerpt":"","text":"iOS自定义的表情键盘一、关于emoji表情随着iOS系统版本的升级，对原生emoji表情的支持也越来越丰富。emoji表情是unicode码中为表情符号设计的一组编码，当然，还有独立于unicode的另一套编码SBUnicode，在OS系统中，这两种编码都有很好的支持。UI系统会自动帮我们将编码转义成表情符号，例如用SBUnicode如下代码： 1234 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; label.font = [UIFont systemFontOfSize:25]; label.text = @&quot;\\uE056&quot;; [self.view addSubview:label]; 就会在屏幕上出现一个笑脸： 二、开发表情键盘的思路首先为了实现跨平台，无论iOS端，andorid端还是web端，都要有一个相同的标准，这个标准就可以是国际Unicode编码，我们的思路是将表情文字进行unicode编码后再进行传输，因此，有两中方式，一种是通过自定义一套表情切图，将其与unicode码一一对应，在转码的时候，我们一一遍历，转换成unicode后进行传输，这样的好处是我们可以保证所有平台所能使用的表情统一。在iOS端，可以有另一种方式，通过上面我们知道，通过SBUnicode码我们可以在客户端显示表情符号，并且这个码的排列是十分有规律的，通过这个特点，我们可以通过遍历SBUnicode码的范围进行表情的创建，省去的图片素材的麻烦。 iOS中可用的表情unicode范围是：0xE001~0xE05A,0xE101~0xE15A, 0xE201~0xE253,0xE401~0xE44C,0xE501~0xE537。 我们可以通过遍历的方法，将其都加入数据源数组中： 1234567891011int emojiRangeArray[10] = &#123;0xE001,0xE05A,0xE101,0xE15A,0xE201,0xE253,0xE401,0xE44C,0xE501,0xE537&#125;; for (int j = 0 ; j&lt;10 ; j+=2 ) &#123; int startIndex = emojiRangeArray[j]; int endIndex = emojiRangeArray[j+1]; for (int i = startIndex ; i&lt;= endIndex ; i++ ) &#123; //添加到数据源数组 [dataArray addObject:[NSString stringWithFormat:@&quot;%C&quot;, (unichar)i]]; &#125; &#125; 键盘的摆放，可以通过collectionView来做，十分方便： 1234567891011121314151617181920212223242526 //为了摆放分页控制器，创建一个背景view bgView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 200)]; //分页控制器 pageControlBottom = [[UIPageControl alloc]initWithFrame:CGRectMake(0, 170, [UIScreen mainScreen].bounds.size.width, 20)]; [bgView addSubview:pageControlBottom]; //collectionView布局 UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; //水平布局 layout.scrollDirection=UICollectionViewScrollDirectionHorizontal; //设置每个表情按钮的大小为30*30 layout.itemSize=CGSizeMake(30, 30); //计算每个分区的左右边距 float xOffset = (kscreenWidth-7*30-10*6)/2; //设置分区的内容偏移 layout.sectionInset=UIEdgeInsetsMake(10, xOffset, 10, xOffset); scrollView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 160) collectionViewLayout:layout]; //打开分页效果 scrollView.pagingEnabled = YES; //设置行列间距 layout.minimumLineSpacing=10; layout.minimumInteritemSpacing=5; scrollView.delegate=self; scrollView.dataSource=self; scrollView.backgroundColor = bgView.backgroundColor; [bgView addSubview:scrollView]; 在collectionView的回调方法中，处理如下： 1234567891011121314151617181920212223242526272829303132333435363738//每页28个表情-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; if (((dataArray.count/28)+(dataArray.count%28==0?0:1))!=section+1) &#123; return 28; &#125;else&#123; return dataArray.count-28*((dataArray.count/28)+(dataArray.count%28==0?0:1)-1); &#125; &#125;//返回页数-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return (dataArray.count/28)+(dataArray.count%28==0?0:1);&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;biaoqing&quot; forIndexPath:indexPath]; for (int i=cell.contentView.subviews.count; i&gt;0; i--) &#123; [cell.contentView.subviews[i-1] removeFromSuperview]; &#125; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; label.font = [UIFont systemFontOfSize:25]; label.text =dataArray[indexPath.row+indexPath.section*28] ; [cell.contentView addSubview:label]; return cell;&#125;-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSString * str = dataArray[indexPath.section*28+indexPath.row]; //这里手动将表情符号添加到textField上 &#125;//翻页后对分页控制器进行更新-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat contenOffset = scrollView.contentOffset.x; int page = contenOffset/scrollView.frame.size.width+((int)contenOffset%(int)scrollView.frame.size.width==0?0:1); pageControlBottom.currentPage = page;&#125; 三、切换系统键盘和自定义的表情键盘UITextField和UITextView都会有下面这个属性和方法： 12@property (nullable, readwrite, strong) UIView *inputView; - (void)reloadInputViews; inputView我们可以设置textView和textField成为第一响应时的弹出附件，如果我们不设置或者设置为nil，则会弹出系统键盘，reloadInputView方法可以使我们刷新这个附件视图，通过这两个，我们可以非常轻松的实现键盘的切换，比如我们在一个出发方法中如下处理： 1234567891011121314151617-(void)imageViewTap&#123; if (![_publishContent isFirstResponder]) &#123; return; &#125; if (isEmoji==NO) &#123; isEmoji=YES; //呼出表情 _textView.inputView=bgView; [_textView reloadInputViews]; &#125;else&#123; isEmoji=NO; _textView.inputView=nil; [_textView reloadInputViews]; &#125; &#125; 效果如下： 追注：测试上面的SBUnicode码在模拟器上可以正常显示，真机并不能识别，可以通过将表情符全部添加到一个plist文件中，通过文件读取来创建键盘的方式进行真机上的开发。plist文件地址如下： http://pan.baidu.com/s/1o6AdkBw 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列四——导航控制器UINavigationController","slug":"151iOS开发UINavigation系列四——导航控制器UINavigationController","date":"2015-11-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.326Z","comments":true,"path":"2015/11/10/151iOS开发UINavigation系列四——导航控制器UINavigationController/","link":"","permalink":"http://huishao.cc/2015/11/10/151iOS开发UINavigation系列四——导航控制器UINavigationController/","excerpt":"","text":"iOS开发UINavigation系列四——导航控制器UINavigationController一、引言在前面的博客中，我么你介绍了UINavigationBar，UINavigationItem和UIToolBar，UINavigationController是将这些控件和UIViewController紧密的结合了起来，使用导航，我们的应用程序层次会更加分明，对controller的管理也更加方便。前几篇博客地址如下： UINavigationBar：http://my.oschina.net/u/2340880/blog/527706 UINavigationItem：http://my.oschina.net/u/2340880/blog/527781 UIToolBar：http://my.oschina.net/u/2340880/blog/528168 二、导航控制器的创建和controller的管理导航控制器是一个堆栈结构，只是其中管理的对象是controller，通过push与pop进行controller的切换，我们有两种方式可以创建导航控制器： 1234//通过一个自定义的导航栏和工具栏创建导航控制器- (instancetype)initWithNavigationBarClass:(nullable Class)navigationBarClass toolbarClass:(nullable Class)toolbarClass;//使用系统默认的导航栏和工具栏，通过一个根视图创建导航控制器- (instancetype)initWithRootViewController:(UIViewController *)rootViewController; 通过以下方法对视图控制器进行管理操作： 12345678910//设置管理的视图控制器- (void)setViewControllers:(NSArray&lt;UIViewController *&gt; *)viewControllers animated:(BOOL)animated;//压入新的视图控制器- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;//弹出一个视图控制器 返回的是pop的controller- (nullable UIViewController *)popViewControllerAnimated:(BOOL)animated;//弹出到某个视图控制器 返回所有pop的controller- (nullable NSArray&lt;__kindof UIViewController *&gt; *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated; //直接pop到根视图控制器，返回所有被pop的controller- (nullable NSArray&lt;__kindof UIViewController *&gt; *)popToRootViewControllerAnimated:(BOOL)animated; 三、导航控制器中的常用方法和属性1234//返回栈顶的controller@property(nullable, nonatomic,readonly,strong) UIViewController *topViewController; //返回显示的controller@property(nullable, nonatomic,readonly,strong) UIViewController *visibleViewController; 上面两个方法的区别在于，topViewController是返回被push出的最后一个controller，但是如果之后又有present进行莫泰跳转，visibleViewController会返回当前显示的controller。例如A-push-B-present-C，则topViewController会返回B，visibleViewController会返回C。 123456789101112131415//返回堆栈中所有的controller@property(nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;//设置隐藏导航栏@property(nonatomic,getter=isNavigationBarHidden) BOOL navigationBarHidden;- (void)setNavigationBarHidden:(BOOL)hidden animated:(BOOL)animated;//导航栏对象，只读属性@property(nonatomic,readonly) UINavigationBar *navigationBar;//隐藏状态栏@property(nonatomic,getter=isToolbarHidden) BOOL toolbarHidden NS_AVAILABLE_IOS(3_0);- (void)setToolbarHidden:(BOOL)hidden animated:(BOOL)animated;//状态栏对象@property(null_resettable,nonatomic,readonly) UIToolbar *toolbar;//导航中的返回手势对象//iOS7之后，在导航中右划会进行pop操作，设置这个的enable可以控制设置手势是否失效@property(nullable, nonatomic, readonly) UIGestureRecognizer *interactivePopGestureRecognizer; 四、iOS8后导航的新特性1234567891011121314//这个方法是为了iOS方法的命名统一，在导航中，其作用和push一样- (void)showViewController:(UIViewController *)vc sender:(nullable id)sender;//弹出键盘的时候隐藏导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsWhenKeyboardAppears;//屏幕滑动的时候隐藏导航栏，常用于tableView,上滑隐藏导航栏，下滑显示，带动画效果@property (nonatomic, readwrite, assign) BOOL hidesBarsOnSwipe;//滑动隐藏导航栏的手势@property (nonatomic, readonly, strong) UIPanGestureRecognizer *barHideOnSwipeGestureRecognizer;//横屏的时候隐藏导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsWhenVerticallyCompact;//敲击屏幕可以隐藏与显示导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsOnTap;//敲击屏幕的手势@property (nonatomic, readonly, assign) UITapGestureRecognizer *barHideOnTapGestureRecognizer; iOS8中增加的这些方法，不得不说着实在用户体验生进了一大步，从中也可以看出apple对于用户体验度的用心。 五、UINavigationDelegate导航控制器还提供了一些代理回调方法，如下： 1234567891011//视图将要展示时调用的方法- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated;//视图已经展示时调用的方法- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated;//设置方法设置导航控制器支持的设备方向- (UIInterfaceOrientationMask)navigationControllerSupportedInterfaceOrientations:(UINavigationController *)navigationController NS_AVAILABLE_IOS(7_0);//这个方法设置导航控制器的首选设备方向- (UIInterfaceOrientation)navigationControllerPreferredInterfaceOrientationForPresentation:(UINavigationController *)navigationController NS_AVAILABLE_IOS(7_0);//下面两个方法可以对导航的转场动画进行设置- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController;- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC ; 六、与UIViewController相关当一个controller被添加到导航中后，系统会为它分配一些属性，如下： 123456//当前controller对应的导航项@property(nonatomic,readonly,strong) UINavigationItem *navigationItem;//push的时候隐藏底部栏，如push后隐藏tabbar@property(nonatomic) BOOL hidesBottomBarWhenPushed;//管理它的导航控制器@property(nullable, nonatomic,readonly,strong) UINavigationController *navigationController; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列三——工具栏UIToolBar","slug":"150iOS开发UINavigation系列三——工具栏UIToolBar","date":"2015-11-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.326Z","comments":true,"path":"2015/11/09/150iOS开发UINavigation系列三——工具栏UIToolBar/","link":"","permalink":"http://huishao.cc/2015/11/09/150iOS开发UINavigation系列三——工具栏UIToolBar/","excerpt":"","text":"iOS开发UINavigation系列三——工具栏UIToolBariOS中除了UINavinationBar之外，还有工具栏UIToolBar可以供我们使用，工具栏和导航栏十分类似，只是功能更加简单，工具栏中也有UIBarButtonItem按钮，在前两篇博客中，对导航栏和导航项都进行的讨论，地址如下： UINavigationBar：http://my.oschina.net/u/2340880/blog/527706 UINavigationItem:http://my.oschina.net/u/2340880/blog/527781 导航栏一般会出现在视图的头部，与之相对，工具栏一般会出现在视图的的底部，上面可以填充一些按钮，提供给用户一些操作。创建一个工具栏如下： 123 self.view.backgroundColor = [UIColor grayColor]; UIToolbar * tool = [[UIToolbar alloc]initWithFrame:CGRectMake(0, self.view.frame.size.height-40, 320, 40)]; [self.view addSubview:tool]; 下面是UIToolBar中的一些方法，其中大部分在UINavigationBar中都有涉及，这里只做简单的介绍： 1234567891011121314151617//工具栏的风格，和导航栏类似，有黑白两种@property(nonatomic) UIBarStyle barStyle; //设置工具栏上按钮数组@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *items; //设置工具栏是否透明@property(nonatomic,assign,getter=isTranslucent) BOOL translucent; //设置工具栏按钮- (void)setItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated; //设置item风格颜色@property(null_resettable, nonatomic,strong) UIColor *tintColor;//设置工具栏背景色@property(nullable, nonatomic,strong) UIColor *barTintColor;//设置工具栏背景和阴影图案- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;- (nullable UIImage *)backgroundImageForToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;- (void)setShadowImage:(nullable UIImage *)shadowImage forToolbarPosition:(UIBarPosition)topOrBottom;- (nullable UIImage *)shadowImageForToolbarPosition:(UIBarPosition)topOrBottom; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列二——UINavigationItem","slug":"149iOS开发UINavigation系列二——UINavigationItem","date":"2015-11-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.325Z","comments":true,"path":"2015/11/08/149iOS开发UINavigation系列二——UINavigationItem/","link":"","permalink":"http://huishao.cc/2015/11/08/149iOS开发UINavigation系列二——UINavigationItem/","excerpt":"","text":"iOS开发UINavigation系列二——UINavigationItem一、引言UINavigationItem是导航栏上用于管理导航项的类，在上一篇博客中，我们知道导航栏是通过push与pop的堆栈操作来对item进行管理的，同样，每一个Item自身也有许多属性可供我们进行自定制。这篇博客，主要讨论UINavigationItem的使用方法。 UINavigationBar：http://my.oschina.net/u/2340880/blog/527706。 二、来说说UINavigationItemItem，从英文上来理解，它可以解释为一个项目，因此，item不是一个简单的label标题，也不是一个简单的button按钮，它是导航栏中管理的一个项目的抽象。说起来有些难于理解，通过代码，我们就能很好的理解Item的意义。 首先，我们创建一个item，用UINavigationBar导航栏push出来： 123 UINavigationItem * item = [[UINavigationItem alloc]initWithTitle:@&quot;title&quot;]; UINavigationBar * bar = [[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 64)]; [bar pushNavigationItem:item animated:YES]; 我们可以看到，在导航栏上的中间，有title这样一个item： 除了创建一个标题item，我们也可以创建一个View类型的item： 123 UIView * view = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; view.backgroundColor = [UIColor brownColor]; item.titleView = view; 效果如下： 通过下面的属性，可以给这个Item添加一个说明文字，这段文字会显示在item的上方： 1item.prompt= @&quot;我是navigationItem的说明文字&quot;; 上面我们看到的这些，实际上只是一个item的一部分，item还有许多其他的附件，如果我们使导航栏再push出一个item，这时导航栏的左边会出现一个返回按钮，这个返回按钮实际上是数据第一个item的，我们做如下的设置： 12345 UINavigationItem * item = [[UINavigationItem alloc]initWithTitle:@&quot;title&quot;]; UINavigationItem * item2 = [[UINavigationItem alloc]initWithTitle:@&quot;title2&quot;]; item.backBarButtonItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;title1&quot; style:nil target:nil action:nil]; [bar pushNavigationItem:item animated:YES]; [bar pushNavigationItem:item2 animated:YES]; 可以看出，虽然当前push出来的item是item2，但是左边的返回按钮是属于item的。这里有一点需要注意，虽然backBarButtonItem的标题我们可以自定义，但是方法和其他属性我们都不能定制，是系统实现好的。 当然，我们也可以设置在push出来新的item的时候，隐藏前面的返回按钮，使用如下属性： 12@property(nonatomic,assign) BOOL hidesBackButton;- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated; 默认为NO，设置为YES将会隐藏返回按钮。 三、关于UIBarButtonItem一个UINavigationItem中，还可以包含许多BarButtonItem，BarButtonItem是一系列的按钮，会出现在导航栏的左侧或者右侧。例如： 12 UIBarButtonItem * button = [[UIBarButtonItem alloc]initWithTitle:@&quot;按钮&quot; style:UIBarButtonItemStyleDone target:self action:@selector(click)]; item.leftBarButtonItem = button; 这个barButtonItem是一个按钮，可以触发一个方法，这有时候对我们来说十分有用。但是有一个你一定发现了，如果继续push出来Item，原来的返回按钮不见了，是否隐藏返回按钮，由下面这个属性控制： 1item.leftItemsSupplementBackButton=YES; 我们也可以通过下面的方法设置右边的按钮，或者直接设置一组按钮： 123456789@property(nullable, nonatomic,strong) UIBarButtonItem *leftBarButtonItem;@property(nullable, nonatomic,strong) UIBarButtonItem *rightBarButtonItem;- (void)setLeftBarButtonItem:(nullable UIBarButtonItem *)item animated:(BOOL)animated;- (void)setRightBarButtonItem:(nullable UIBarButtonItem *)item animated:(BOOL)animated;@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *leftBarButtonItems;@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *rightBarButtonItems;- (void)setLeftBarButtonItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated;- (void)setRightBarButtonItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated; 四、再看UIBarButtonItem上面我们了解到了，一个NavigationItem基本上是有三大部分组成的，当前显示的部分，返回按钮部分，和ButtonItem部分，同样对于创建和设置UIBarButoonItem，也有很多方法供我们使用。 首先是创建与初始化的方法： 1- (instancetype)initWithTitle:(nullable NSString *)title style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action; 这个方法通过一个标题创建ButtonItem，其中style参数可以设置一个风格，枚举如下： 1234typedef NS_ENUM(NSInteger, UIBarButtonItemStyle) &#123; UIBarButtonItemStylePlain, UIBarButtonItemStyleDone,&#125;; 这两种风格差别并不大，如下是效果，Done风格的字体加粗一些： 我们因为可以通过一个图片来创建BarButtonItem： 12- (instancetype)initWithImage:(nullable UIImage *)image style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action;- (instancetype)initWithImage:(nullable UIImage *)image landscapeImagePhone:(nullable UIImage *)landscapeImagePhone style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action; 上面这两个方法中，第一个方法与使用文字创建的方法类似，第二个方法多了一个landscapeImagePhone的参数，这个参数可以设置设备横屏时的图片。 我们也可以使用自定义的View来创建BarButtonItem： 1- (instancetype)initWithCustomView:(UIView *)customView; 除了上面一些自定义的创建方法外，对于BarButtonItem这个对象，系统也封装好了许多原生的可以供我们使用，创建的时候使用如下方法： 1UIBarButtonItem * button = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemCamera target:self action:nil]; 上面的SystemItem是系统为我们做好的许多buttonItem的类型，枚举如下： 1234567891011121314151617181920212223242526typedef NS_ENUM(NSInteger, UIBarButtonSystemItem) &#123; UIBarButtonSystemItemDone,//显示完成 UIBarButtonSystemItemCancel,//显示取消 UIBarButtonSystemItemEdit, //显示编辑 UIBarButtonSystemItemSave, //显示保存 UIBarButtonSystemItemAdd,//显示加号 UIBarButtonSystemItemFlexibleSpace,//什么都不显示，占位一个空间位置 UIBarButtonSystemItemFixedSpace,//和上一个类似 UIBarButtonSystemItemCompose,//显示写入按钮 UIBarButtonSystemItemReply,//显示循环按钮 UIBarButtonSystemItemAction,//显示活动按钮 UIBarButtonSystemItemOrganize,//显示组合按钮 UIBarButtonSystemItemBookmarks,//显示图书按钮 UIBarButtonSystemItemSearch,//显示查找按钮 UIBarButtonSystemItemRefresh,//显示刷新按钮 UIBarButtonSystemItemStop,//显示停止按钮 UIBarButtonSystemItemCamera,//显示相机按钮 UIBarButtonSystemItemTrash,//显示移除按钮 UIBarButtonSystemItemPlay,//显示播放按钮 UIBarButtonSystemItemPause,//显示暂停按钮 UIBarButtonSystemItemRewind,//显示退后按钮 UIBarButtonSystemItemFastForward,//显示前进按钮 UIBarButtonSystemItemUndo,//显示消除按钮 UIBarButtonSystemItemRedo ,//显示重做按钮 UIBarButtonSystemItemPageCurl ,//在tool上有效&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列一——导航栏UINavigtionBar","slug":"148iOS开发UINavigation系列一——导航栏UINavigtionBar","date":"2015-11-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.325Z","comments":true,"path":"2015/11/08/148iOS开发UINavigation系列一——导航栏UINavigtionBar/","link":"","permalink":"http://huishao.cc/2015/11/08/148iOS开发UINavigation系列一——导航栏UINavigtionBar/","excerpt":"","text":"iOS开发UINavigation系列一——导航栏UINavigtionBar一、导航栏的使用在iOS开发中，我们通常会使用导航控制器，导航控制器中封装了一个UINavigationBar，实际上，我们也可以在不使用导航控制器的前提下，单独使用导航栏，在UINavigationBar中，也有许多我们可以定制的属性，用起来十分方便。 二、UINavigationBar的创建和风格类型导航栏继承于UIView，所以我们可以像创建普通视图那样创建导航栏，比如我们创建一个高度为80的导航栏，将其放在ViewController的头部，代码如下： 12UINavigationBar *bar = [[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 80)];[self.view addSubview:bar]; 效果如下： 我们也可以设置导航栏的风格属性，从iOS6之后，UINavigationBar默认为半透明的样式，从上面也可以看出，白色的导航栏下面透出些许背景的红色。导航栏的风格属性可以通过下面的属性来设置： 1@property(nonatomic,assign) UIBarStyle barStyle; UIBarStyle是一个枚举，其中大部分的样式都已弃用，有效果的只有如下两个： 1234typedef NS_ENUM(NSInteger, UIBarStyle) &#123; UIBarStyleDefault = 0,//默认 UIBarStyleBlack = 1,//黑色&#125; 默认的风格就是我们上面看到的白色的风格，黑色的风格效果瑞如下： 三、导航栏常用属性和方法从上面我们可以看到，iOS6后导航栏默认都是半透明的，我们可以通过下面的bool值来设置这个属性，设置为NO，则导航栏不透明，默认为YES： 1@property(nonatomic,assign,getter=isTranslucent) BOOL translucent; 下面一些方法用于设置NavigationBar及上面item的颜色相关属性： 1@property(null_resettable, nonatomic,strong) UIColor *tintColor; tintColor这个属性会影响到导航栏上左侧pop按钮的图案颜色和字体颜色，系统默认是如下颜色： 1@property(nullable, nonatomic,strong) UIColor *barTintColor; BarTintColor用于设置导航栏的背景色，这个属性被设置后，半透明的效果将失效： 12- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;- (nullable UIImage *)backgroundImageForBarMetrics:(UIBarMetrics)barMetrics; 上面两个方法用于设置和获取导航栏的背景图案，这里需要注意，默认背景图案是不做缩放处理的，所以我们使用的图片尺寸要和导航栏尺寸匹配，这里面还有一个UIBarMetrics参数，这个参数设置设备的状态，如下： 1234typedef NS_ENUM(NSInteger, UIBarMetrics) &#123; UIBarMetricsDefault,//正常竖屏状态 UIBarMetricsCompact,//横屏状态&#125;; 1234//设置导航栏的阴影图片@property(nullable, nonatomic,strong) UIImage *shadowImage;//设置导航栏的标题字体属性@property(nullable,nonatomic,copy) NSDictionary&lt;NSString *,id&gt; *titleTextAttributes; 标题字体属性会影响到导航栏的中间标题，如下： 1 bar.titleTextAttributes = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;; 我们也可以通过下面的属性设置导航栏标题的竖直位置偏移： 12- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics;- (CGFloat)titleVerticalPositionAdjustmentForBarMetrics:(UIBarMetrics)barMetrics; 还有一个细节，导航栏左侧pop按钮的图案默认是一个箭头，我们可以使用下面的方法修改： 12@property(nullable,nonatomic,strong) UIImage *backIndicatorImage;@property(nullable,nonatomic,strong) UIImage *backIndicatorTransitionMaskImage; 四、导航栏中item的push与pop操作UINavigationBar上面不只是简单的显示标题，它也将标题进行了堆栈的管理，每一个标题抽象为的对象在iOS系统中是UINavigationItem对象，我们可以通过push与pop操作管理item组。 123456789101112//向栈中添加一个item，上一个item会被推向导航栏的左侧，变为pop按钮，会有一个动画效果- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;//pop一个item- (nullable UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; //当前push到最上层的item@property(nullable, nonatomic,readonly,strong) UINavigationItem *topItem;//仅次于最上层的item，一般式被推向导航栏左侧的item@property(nullable, nonatomic,readonly,strong) UINavigationItem *backItem;//获取堆栈中所有item的数组@property(nullable,nonatomic,copy) NSArray&lt;UINavigationItem *&gt; *items;//设置一组item- (void)setItems:(nullable NSArray&lt;UINavigationItem *&gt; *)items animated:(BOOL)animated; 五、UINavigationBarDelegate在UINavigationBar中，还有如下一个属性： 1@property(nullable,nonatomic,weak) id&lt;UINavigationBarDelegate&gt; delegate; 通过代理，我们可以监控导航栏的一些push与pop操作： 12345678//item将要push的时候调用，返回NO，则不能push- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item; //item已经push后调用- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item; //item将要pop时调用，返回NO，不能pop - (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item; //item已经pop后调用 - (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用","slug":"147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用","date":"2015-11-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.325Z","comments":true,"path":"2015/11/06/147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用/","link":"","permalink":"http://huishao.cc/2015/11/06/147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用/","excerpt":"","text":"iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用一、引言在iOS系统中，手势是进行用户交互的重要方式，通过UIGestureRecognizer类，我们可以轻松的创建出各种手势应用于app中。关于UIGestureRecognizer类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的一些讨论，在前面的博客中有提到： iOS事件响应控制：http://my.oschina.net/u/2340880/blog/396161。 二、手势的抽象类——UIGestureRecognizerUIGestureRecognizer将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用UIGestureRecognizer的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，UIGestureRecognizer中抽象出了哪些方法。 1、统一的初始化方法UIGestureRecognizer类为其子类准备好了一个统一的初始化方法，无论什么样的手势动作，其执行的结果都是一样的：触发一个方法，可以使用下面的方法进行统一的初始化： 1- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action; 当然，如果我们使用alloc-init的方式，也是可以的，下面的方法可以为手势添加触发的selector： 1- (void)addTarget:(id)target action:(SEL)action; 与之相对应的，我们也可以将一个selector从其手势对象上移除： 1- (void)removeTarget:(nullable id)target action:(nullable SEL)action; 上面两个方法是十分有意思的，因为addTarget方式的存在，iOS系统允许一个手势对象可以添加多个selector触发方法，并且触发的时候，所有添加的selector都会被执行，我们以点击手势示例如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)]; [ges addTarget:self action:@selector(haha)]; [self.view addGestureRecognizer:ges];&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;); &#125;-(void)haha&#123; NSLog(@&quot;haha&quot;);&#125; 运行后点击屏幕，打印如下，说明两个方法都触发了： 2、手势状态UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态: 1@property(nonatomic,readonly) UIGestureRecognizerState state; 枚举值如下： 123456789typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; UIGestureRecognizerStatePossible, // 默认的状态，这个时候的手势并没有具体的情形状态 UIGestureRecognizerStateBegan, // 手势开始被识别的状态 UIGestureRecognizerStateChanged, // 手势识别发生改变的状态 UIGestureRecognizerStateEnded, // 手势识别结束，将会执行触发的方法 UIGestureRecognizerStateCancelled, // 手势识别取消 UIGestureRecognizerStateFailed, // 识别失败，方法将不会被调用 UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded &#125;; 3、常用属性和方法123456789101112//设置代理，具体的协议后面会说@property(nullable,nonatomic,weak) id &lt;UIGestureRecognizerDelegate&gt; delegate; //设置手势是否有效@property(nonatomic, getter=isEnabled) BOOL enabled;//获取手势所在的view@property(nullable, nonatomic,readonly) UIView *view; //获取触发触摸的点- (CGPoint)locationInView:(nullable UIView*)view; //设置触摸点数- (NSUInteger)numberOfTouches; //获取某一个触摸点的触摸位置- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view; 下面的几个BOOL值的属性，对于手势触发的控制也十分重要： （1）1@property(nonatomic) BOOL cancelsTouchesInView; 上面的属性默认为YES，当这个属性设置为YES时，如果识别到了手势，系统将会发送touchesCancelled:withEvent:消息在其时间传递链上，终止触摸事件的传递，设置为NO，则不会终止事件的传递，举个例子来说，可能会更加清楚一些如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; UIPanGestureRecognizer * ges = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];; [self.view addGestureRecognizer:ges]; ges.cancelsTouchesInView=NO;&#125;-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;123&quot;);&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;);&#125; 上面我们使用了拖拽手势和touchesMoved两个触发方式，当我们把cancelTouchesInView设置为NO时，在屏幕上滑动，会发现两种方式都在触发，打印如下： 如果我们将cancelTouchesInView改为YES，当手势触发时，将取消触摸消息的触发： （2）1@property(nonatomic) BOOL delaysTouchesBegan; 通过上面的例子，我们知道，在一个手势触发之前，是会一并发消息给事件传递链的，delaysTouchesBgan属性用于控制这个消息的传递时机，默认这个属性为NO，此时在触摸开始的时候，就会发消息给事件传递链，如果我们设置为YES，在触摸没有被识别失败前，都不会给事件传递链发送消息。 （3）1@property(nonatomic) BOOL delaysTouchesEnded; 这个属性设置手势识别结束后，是立刻发送touchesEnded消息到事件传递链或者等待一个很短的时间后，如果没有接收到新的手势识别任务，再发送。 4、手势间的互斥处理有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如： 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];; //view.backgroundColor = [UIColor redColor]; //ges.delegate=self; [self.view addGestureRecognizer:ges]; UITapGestureRecognizer * ges2 = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click1:)];// ges2.delegate=self; [self.view addGestureRecognizer:ges2];&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;); &#125;-(void)click1:(UIGestureRecognizer *)ges1&#123; NSLog(@&quot;第二个手势的触发方法&quot;); &#125; 我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法： 1- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer; 这个方法中第一个参数是需要时效的手势，第二个是生效的手势。 三、UIGestureRecognizerDelegate前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下： 1234567891011//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;//下面这个两个方法也是用来控制手势的互斥执行的//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);//这个方法返回YES，第一个和第二个互斥时，第二个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0); 四、点击手势——UITapGestureRecognizer点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置： 1234//设置点击次数，默认为单击@property (nonatomic) NSUInteger numberOfTapsRequired; //设置同时点击的手指数@property (nonatomic) NSUInteger numberOfTouchesRequired; 五、捏合手势——UIPinchGestureRecognizer捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下： 1234//设置缩放比例@property (nonatomic) CGFloat scale; //设置捏合速度@property (nonatomic,readonly) CGFloat velocity; 六、拖拽手势——UIPanGestureRecognzer当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。 12345678910//设置触发拖拽的最少触摸点，默认为1@property (nonatomic) NSUInteger minimumNumberOfTouches; //设置触发拖拽的最多触摸点@property (nonatomic) NSUInteger maximumNumberOfTouches; //获取当前位置- (CGPoint)translationInView:(nullable UIView *)view; //设置当前位置- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;//设置拖拽速度- (CGPoint)velocityInView:(nullable UIView *)view; 七、滑动手势——UISwipeGestureRecognizer滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢。 1234567891011//设置触发滑动手势的触摸点数@property(nonatomic) NSUInteger numberOfTouchesRequired; //设置滑动方向@property(nonatomic) UISwipeGestureRecognizerDirection direction; //枚举如下typedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) &#123; UISwipeGestureRecognizerDirectionRight = 1 &lt;&lt; 0, UISwipeGestureRecognizerDirectionLeft = 1 &lt;&lt; 1, UISwipeGestureRecognizerDirectionUp = 1 &lt;&lt; 2, UISwipeGestureRecognizerDirectionDown = 1 &lt;&lt; 3&#125;; 八、旋转手势——UIRotationGestureRecognizer进行旋转动作时触发手势方法。 1234//设置旋转角度@property (nonatomic) CGFloat rotation;//设置旋转速度 @property (nonatomic,readonly) CGFloat velocity; 九、长按手势——UILongPressGestureRecognizer进行长按的时候触发的手势方法。 12345678//设置触发前的点击次数@property (nonatomic) NSUInteger numberOfTapsRequired; //设置触发的触摸点数@property (nonatomic) NSUInteger numberOfTouchesRequired; //设置最短的长按时间@property (nonatomic) CFTimeInterval minimumPressDuration; //设置在按触时时允许移动的最大距离 默认为10像素@property (nonatomic) CGFloat allowableMovement; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中UITableViewController自带的刷新控件","slug":"146iOS中UITableViewController自带的刷新控件","date":"2015-11-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.325Z","comments":true,"path":"2015/11/05/146iOS中UITableViewController自带的刷新控件/","link":"","permalink":"http://huishao.cc/2015/11/05/146iOS中UITableViewController自带的刷新控件/","excerpt":"","text":"iOS中UITableViewController自带的刷新控件一、引言在iOS开发中，使用tableView的界面，大多会用到一个下拉刷新的的控件，第三方库中，我们一般会选择比较好用的MJRefresh，其实，在iOS6之后，系统为我们提供了一个原生的刷新控件，使用起来非常方便，只是制定性不强，如果我们没有复杂的需求，使用UIRefreshControl也是不错的一个选择。 二、UITableViewController相对于UIViewController，UITableViewController只是在内部为我们封装好了一个UITableView，并且遵守好了相关的协议，我们只需要在其中实现方法即可。UITableViewController更多的方面之处是在于下面的这个属性： 1@property (nonatomic) BOOL clearsSelectionOnViewWillAppear; 这是一个bool值，设置为yes后每当当前controller调用ViewWillAppare的时候，都会将cell的选中状态取消，这十分有用，我们在通过点击cell跳转界面后，pop回来不需要在手动修改cell的选中状态了。 除此之后，TableViewController中还封装了这样一个属性： 1@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl; 这个UIRefreshControl类是iOS6之后引入的一个简单的刷新控件，我们如果设置了它，在tableView下拉的时候，系统会提供给我们一个下拉刷新的效果。 三、UIRefreshControl这个类也十分简单，通过简单的设置可以展现一个小巧的刷新效果，但是制定性不强，其中主要属性如下： 1234567891011//获取刷新状态@property (nonatomic, readonly, getter=isRefreshing) BOOL refreshing;//设置控件颜色@property (null_resettable, nonatomic, strong) UIColor *tintColor;//设置控件文字@property (nullable, nonatomic, strong) NSAttributedString *attributedTitle UI_APPEARANCE_SELECTOR;// 手动开始刷新- (void)beginRefreshing NS_AVAILABLE_IOS(6_0);// 结束刷新- (void)endRefreshing NS_AVAILABLE_IOS(6_0); 需要注意的是，UIRefreshControl是继承于UIControl的，下拉唤醒刷新状态后，会触发UIControleEventValueChange事件，我们可以在其中进行刷新的数据逻辑操作。 例如： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; self.refreshControl = [[UIRefreshControl alloc]init]; self.refreshControl.tintColor = [UIColor greenColor]; self.refreshControl.attributedTitle = [[NSAttributedString alloc]initWithString:@&quot;下拉刷新了~~&quot;]; self.clearsSelectionOnViewWillAppear = YES; self.navigationItem.rightBarButtonItem = self.editButtonItem; [self.refreshControl addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged];&#125;-(void)change:(UIRefreshControl*)con&#123; self.refreshControl.attributedTitle = [[NSAttributedString alloc]initWithString:@&quot;开始刷新了~~&quot;];&#125; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之四——使用第三方库Masonry进行autolayout布局","slug":"145iOS界面布局之四——使用第三方库Masonry进行autolayout布局","date":"2015-11-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.324Z","comments":true,"path":"2015/11/02/145iOS界面布局之四——使用第三方库Masonry进行autolayout布局/","link":"","permalink":"http://huishao.cc/2015/11/02/145iOS界面布局之四——使用第三方库Masonry进行autolayout布局/","excerpt":"","text":"iOS界面布局之四——使用第三方库Masonry进行autolayout布局一、引言在前面博客，我们讨论了使用iOS原生的框架代码来进行autolayout布局。在使用中，我们会发现，无论是代码量还是结构的清晰度，都十分不能让我们满意，在storyBoard中只需要几条线就可以搞定的事情，用代码缺要写冗余的一大堆。并且有些时候，故事版并不能解决所有问题，某些控件必须我们手写，这样的话，我们就不得不进行代码的autolayout布局，幸运的是，Masonry可以帮助我们轻松愉快的完成这一任务。 使用代码进行autolayout布局：http://my.oschina.net/u/2340880/blog 。 二、使用Masonry这里说的大部分内容均来自Masonry和官方gitHub，将其内容进行了翻译和解释，源地址如下：[https://github.com/SnapKit/Masonry](https://github.com/SnapKit/Masonry)。 1、布局的控件属性对照无论是用storyBoard还是代码，在设置控件之间layout关系的时候，我们都需要设置控件的位置属性。在下面的方法中，这个位置属性就是NSLayoutAttribute对象，他决定的控件对象的参照位置： 12345+(instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 在Masonry中，有一系列的属性与之成对应关系，对照如下： 2、3个方法让你玩转Masonry约束操作Masonry在UIView的类别中，有3个全局的操作约束的方法，通过他们我们可以自由的进行autolayout的设置。 添加约束： 1- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block; 这个方法用于我们在最开始时为控件设置的约束，在block中进行约束条件的设置，例如我们创建一个label，将其尺寸设置为50*50，放在屏幕中间，使用如下代码： 注意：在添加约束前，必须将视图添加到其父视图上。 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UILabel * label = [[UILabel alloc]init]; [self.view addSubview:label]; [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self.view); make.height.equalTo(@50); make.width.equalTo(@50); &#125;]; label.backgroundColor = [UIColor redColor];&#125; 效果如下： 更新约束： 当我们需要配合布局改变或者动画效果的时候，我们可能需要将已经添加的约束进行更新操作，使用如下的方法： 1234[label mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.width.equalTo(@100); &#125;]; 更新约束的作用在于更新已经添加的某些约束，并不会移除掉原有的约束，如果我们需要添加新的约束，可以使用下面的重设约束的方法。 重设约束： 123456[label mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view.mas_left).offset(10); make.top.equalTo(self.view.mas_top).offset(100); make.height.equalTo(@100); make.width.equalTo(@100); &#125;]; 3、约束值相关在添加具体约束的时候，我们不仅可以将约束值设置为绝对的相等关系，也可以设置一些值域的关系，在Masonry中，有如下三种： 123456//绝对相等- (MASConstraint * (^)(id attr))equalTo;//大于等于- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;//小于等于- (MASConstraint * (^)(id attr))lessThanOrEqualTo; 对于约束的优先级，使用如下几个量： 12345678//手动设置一个优先级参数- (MASConstraint * (^)(MASLayoutPriority priority))priority;//优先级低- (MASConstraint * (^)())priorityLow;//优先级中等- (MASConstraint * (^)())priorityMedium;//优先级高- (MASConstraint * (^)())priorityHigh; 写法如下： 123456[label mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view.mas_left).offset(10); make.top.equalTo(self.view.mas_top).offset(100); make.height.equalTo(@100).priority(1000); make.width.equalTo(@100).priorityHigh(); &#125;]; 三、Masonry设置约束的几个示例1、设置视图与其父视图的边距约束12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. label = [[UILabel alloc]init]; [self.view addSubview:label]; [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.view).insets(UIEdgeInsetsMake(20, 20, 20, 20)); &#125;]; label.backgroundColor = [UIColor redColor];&#125; 设置上下左右与其父视图边距为20px，效果如下： 2、约束控件的尺寸为固定值12345[label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@200); make.width.equalTo(@200); make.center.equalTo(self.view); &#125;]; 位置约束设置在了屏幕的中间，效果如下： 3、约束控件之间的尺寸123456789101112 [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.width.equalTo(label2); make.right.equalTo(label2.mas_left).offset(-100); make.leading.equalTo(self.view.mas_leading).offset(20); make.centerY.equalTo(self.view); &#125;]; [label2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.centerY.equalTo(label); make.trailing.equalTo(self.view.mas_trailing).offset(-20); &#125;]; 设置了两个label宽度一致，相距100px,分别距离左右边距20px，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS对UIViewController生命周期和属性方法的解析","slug":"144iOS对UIViewController生命周期和属性方法的解析","date":"2015-10-31T16:00:00.000Z","updated":"2023-04-14T11:50:08.324Z","comments":true,"path":"2015/11/01/144iOS对UIViewController生命周期和属性方法的解析/","link":"","permalink":"http://huishao.cc/2015/11/01/144iOS对UIViewController生命周期和属性方法的解析/","excerpt":"","text":"iOS对UIViewController生命周期和属性方法的解析一、引言作为MVC设计模式中的C，Controller一直扮演着项目开发中最重要的角色，它是视图和数据的桥梁，通过它的管理，将数据有条有理的展示在我们的View层上。iOS中的UIViewController是UIKit框架中最基本的一个类。从第一个UI视图到复杂完整项目，都离不开UIViewController作为基础。基于UIViewController的封装和扩展，也能够出色的完成各种复杂界面逻辑。这篇博客，旨在讨论UIViewController的生命周期和属性方法，在最基础的东西上，往往会得到意想不到的惊喜。 二、UIViewController的生命周期要了解UIViewController，先要弄清楚其生命周期。在面向对象的语言中，是对象，就一定要有生命周期，UIViewController也不例外，生命周期管理Controller的作用范围和时间，也管理其内对象的作用范围和时间。首先，UIViewController中与其生命周期有关的几个函数如下： 1234567891011121314151617181920212223242526//类的初始化方法+ (void)initialize;//对象初始化方法- (instancetype)init;//从归档初始化- (instancetype)initWithCoder:(NSCoder *)coder;//加载视图-(void)loadView;//将要加载视图- (void)viewDidLoad;//将要布局子视图-(void)viewWillLayoutSubviews;//已经布局子视图-(void)viewDidLayoutSubviews;//内存警告- (void)didReceiveMemoryWarning;//已经展示-(void)viewDidAppear:(BOOL)animated;//将要展示-(void)viewWillAppear:(BOOL)animated;//将要消失-(void)viewWillDisappear:(BOOL)animated;//已经消失-(void)viewDidDisappear:(BOOL)animated;//被释放-(void)dealloc; 上面这么多的函数，乍一看什么复杂，其实关系什么明朗，除了initialize,init和initWithCoder不是存在所有对象的声明周期中，其他函数都会在UIViewController的声明周期中有序的被调用。那么具体的调用顺序是怎样的呢，最好的办法是实践一下，通过编号打印，结果如下： 这是一个ViewController完整的声明周期，其实里面还有好多地方需要我们注意一下： 1：initialize函数并不会每次创建对象都调用，只有在这个类第一次创建对象时才会调用，做一些类的准备工作，再次创建这个类的对象，initalize方法将不会被调用，对于这个类的子类，如果实现了initialize方法，在这个子类第一次创建对象时会调用自己的initalize方法，之后不会调用，如果没有实现，那么它的父类将替它再次调用一下自己的initialize方法，以后创建也都不会再调用。因此，如果我们有一些和这个相关的全局变量，可以在这里进行初始化。 2：init方法和initCoder方法相似，只是被调用的环境不一样，如果用代码进行初始化，会调用init，从nib文件或者归档进行初始化，会调用initCoder。 3：loadView方法是开始加载视图的起始方法，除非手动调用，否则在ViewController的生命周期中没特殊情况只会被调用一次。 4：viewDidLoad方法是我们最常用的方法的，类中成员对象和变量的初始化我们都会放在这个方法中，在类创建后，无论视图的展现或消失，这个方法也是只会在将要布局时调用一次。 5：viewWillAppear：视图将要展现时会调用。 6：viewWillLayoutSubviews：在viewWillAppear后调用，将要对子视图进行布局。 7：viewDidLayoutSubviews：已经布局完成子视图。 8：viewDidAppare：视图完成显示时调用。 9：viewWillDisappear：视图将要消失时调用。 10：viewDidDisappear：视图已经消失时调用。 11：dealloc：controller被释放时调用。 注意：经过测试，从nib文件加载的controller，只要不释放，在每次viewWillAppare时都会调用layoutSubviews方法，有时甚至会在viewDidAppare后在调用一次layoutSubviews，而重点是从代码加载的则只会在开始调用一次，之后都不会，所以注意，在layoutSubviews中写相关的布局代码十分危险。 三、从storyBoard加载UIViewController实例的传值陷阱我们知道，当我们从StoryBoard中加载ViewController时，我们在Controller中拖拽的视图是可以被初始化的，这里面有一点需要我们注意，如果我们需要向controller中视图进行传值设置，通过以下方法得到的Controller中，视图还没有被初始化创建出来： 1 ViewController2 * viewController2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:@&quot;ViewController2&quot;]; 我们可以在ViewController2的storyBoard中拉一个label，然后关联到头文件中，如下打印，会发现我们得到controller时，里面的视图对象并没有进行创建: 123ViewController2 * viewController2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:@&quot;ViewController2&quot;]; NSLog(@&quot;%@&quot;,viewController2.label); [self presentViewController:viewController2 animated:YES completion:nil]; 打印如下： 可以想象，如果我们这时候需要对label进行一些属性设置，必然失败。有人提出可以在创建后，手动调以下loadView方法，我们试一下，结果如下： 可以看到，手动调用loadView后，label是被创建了出来，但是暴漏了一个更严重的问题，系统不在调用ViewDidLoad方法，这是十分有风险的，因为我们大部分的初始化代码都会放在这个方法里，所以手动调用loadView是一种错误的方法，apple文档声明对于loadView方法，我们从来都不要手动直接调用，那么我们如何实现创建后对成员对象进行传值设置呢，iOS9中增加了这样一个方法： 1- (void)loadViewIfNeeded NS_AVAILABLE_IOS(9_0); 这个方法十分有用，调用这个方法，会将视图创建出来，并且不会忽略viewDidLoad的调用。 在iOS9中，UIViewController还增加了下面一个布尔值的属性，可以同来判断controller的view是否已经加载完成： 1@property(nullable, nonatomic, readonly, strong) UIView *viewIfLoaded NS_AVAILABLE_IOS(9_0); 四、UIViewController与StroyBoard的相关相互方法对于ViewConroller，我们一般有两种方式创建，一种是用纯代码的方式，一种是与StoryBoard关联，在UIViewController中，有许多方法方便我们与StoryBoard进行交互联系。 1、ViewController直接在StoryBoard中进行跳转的传值在StoryBoard中进行界面跳转是十分方便的，我们在StoryBoard中拉入两个ViewController，在一个上面添加一个按钮，点住按钮按住control，将鼠标拉到第二个controller上，会出现如下的跳转选项： 我们选择一个后，就会在两个controller之间建立一个跳转连接。当我们运行点击按钮后，会自动从第一个controller跳转到第二个controller。在UIViewController中有如下方法可以对是否跳转进行控制： 1- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(6_0); 这个方法如果返回NO，自动跳转将不能进行，会被拒绝，需要注意的是，这个方法只会在自动的跳转时被调用，我们手动使用代码跳转StoryBoard中的连接关系时是不会被调用的，我们后面讨论。 在执行过上述方法后，如果返回YES，系统还会在执行如下一个方法，作为跳转前的准备，我们可以在这个方法中进行一些传值操作，这个方法无论使我们手动进行跳转还是storyboard中自动跳转，都会被执行： 1- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(nullable id)sender NS_AVAILABLE_IOS(5_0); sugur对象中封装了相关的ViewController，可以使用segue.destinationViewController获取。 segue在StoryBoard中除了用来自动正向跳转外，我们还可以进行反向的跳转，类似pop和dismiss方法，这种segue被称为unwind sugue。例如，我们有一个controller1和一个controllert2，要使用unwind segue从2返回1，我们需要在2中实现如下格式的方法： 123- (IBAction)unwindSegueToViewController:(UIStoryboardSegue *)segue &#123; NSLog(@&quot;unwindSegueToViewController&quot;);&#125; 这个方法中的返回值必须为IBAction，参数必须是UIStoryboardSegue，方法名我们可以自己定义，之后在StoryBoard中的ViewController1中的Exit选项中，我们会发现多了一个这样的方法： 我们可以把它连接到viewController2中的一个按钮上： 这样，当我们点击viewController2中的按钮时，就会返回到我们第一个ViewController1中了。 当然，在使用unwind segue方法时，也是会有一些回调帮助我们进行跳转前的设置和传值，UIViewController如下方法会在跳转前调用，返回NO，则不能进行跳转： 1234-(BOOL)canPerformUnwindSegueAction:(SEL)action fromViewController:(UIViewController *)fromViewController withSender:(id)sender&#123; NSLog(@&quot;canPerformUnwindSegueAction&quot;); return YES;&#125; 之后会执行我们自定义的unwindSegue方法，这个方法中我们可以什么都不写，模式是会进行跳转的。 2、使用代码跳转Storyboard中的controller我们除了在Storyboard中拉拉扯扯可以进行控制器的跳转外，我们也可以使用代码来跳转Storyboard中segue连接关系。 在Storyboard中两个控制器间建立一个segue联系，我们可以取一个名字： 在触发跳转的方法中，使用如下方法进行跳转，这里面的参数id就是我们取得segue的id： 1- (void)performSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(5_0); 下面三个属性我们可以获取controller的nib文件名，其storyBoard和其Bundle: 123@property(nullable, nonatomic, readonly, copy) NSString *nibName; @property(nullable, nonatomic, readonly, strong) NSBundle *nibBundle; @property(nullable, nonatomic, readonly, strong) UIStoryboard *storyboard NS_AVAILABLE_IOS(5_0); 五、UIViewController之间的一些从属关系这部分的内容和方法可能我们接触用到的并不多，但是在某些情况下，使用这些方法可以大大的方便某些逻辑。 1、parentViewControllerUIViewController里面封装了一个数组，可以存放其子ViewController，系统中使用的例子就是导航和tabBar这类的控制器，我们使用如下方法可以直接访问这些父的controller： 1@property(nullable,nonatomic,weak,readonly) UIViewController *parentViewController; 2、模态跳转中Controller的从属在我们进行控制器的跳转时，只要控制器没有被释放，我们都可以顺藤摸瓜的找到它，使用如下两个方法： 1234//其所present的contller，比如，A和B两个controller，A跳转到B，那么A的presentedViewController就是B@property(nullable, nonatomic,readonly) UIViewController *presentedViewController NS_AVAILABLE_IOS(5_0);//和上面的方法刚好相反，比如，A和B两个controller，A跳转到B，那么B的presentingViewController就是A@property(nullable, nonatomic,readonly) UIViewController *presentingViewController NS_AVAILABLE_IOS(5_0); 了解了上面方法我们可以知道，对于反向传值这样的问题，我们根本不需要代理，block，通知等这样的复杂手段，只需要获取跳转到它的Controller，直接设置即可。举个例子，我们需要在第二个界面消失后，改变第一个界面的颜色，在第二个controller中只需要下面的代码即可实现 ： 12 self.presentingViewController.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [self dismissViewControllerAnimated:YES completion:nil]; 六、UIViewController的模态跳转及动画特效单纯的UIViewController中，我们使用最多的是如下的两个方法，一个向前跳转，一个向后返回: 12- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0);- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0); 从方法中，我们可以看到，有animated这个参数，来选择是否有动画特效，默认的动画特效是像抽屉一样从手机屏幕的下方向上弹起，当然，这个效果我们可以进行设置，UIViewController有如下一个属性来设置动画特效： 1@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle NS_AVAILABLE_IOS(3_0); 注意，这个要设置的是将要跳转到的controller，枚举如下： 123456typedef NS_ENUM(NSInteger, UIModalTransitionStyle) &#123; UIModalTransitionStyleCoverVertical = 0,//默认的，从下向上覆盖 UIModalTransitionStyleFlipHorizontal ,//水平翻转 UIModalTransitionStyleCrossDissolve,//溶解 UIModalTransitionStylePartialCurl ,从下向上翻页&#125;; 除了跳转的效果，还有一个属性可以设置弹出的controler的填充效果，但是这个属性只在pad上有效，在iphone上无效，都是填充到整个屏幕： 12345678910111213@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle NS_AVAILABLE_IOS(3_2);//枚举如下typedef NS_ENUM(NSInteger, UIModalPresentationStyle) &#123; UIModalPresentationFullScreen = 0,//填充整个屏幕 UIModalPresentationPageSheet,//留下状态栏 UIModalPresentationFormSheet,//四周留下变暗的空白 UIModalPresentationCurrentContext ,//和跳转到它的控制器保持一致 UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),//自定义 UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0), UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0), UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED, UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1, &#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之三——纯代码的autoLayout及布局动画","slug":"143iOS界面布局之三——纯代码的autoLayout及布局动画","date":"2015-10-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.324Z","comments":true,"path":"2015/10/30/143iOS界面布局之三——纯代码的autoLayout及布局动画/","link":"","permalink":"http://huishao.cc/2015/10/30/143iOS界面布局之三——纯代码的autoLayout及布局动画/","excerpt":"","text":"iOS界面布局之三——纯代码的autoLayout及布局动画一、引言关于界面布局，apple的策略已经趋于成熟，autolayout的优势在开发中也已经展现的淋漓尽致。除了使用storyBoard进行布局约束的拖拽，有时我们也需要在代码中进行autolayout的布局设置，Masonry库可以方便的创建约束属性，实际上，我们也没有必要再使用系统原生的代码来创建和设置约束，这篇博客只作为使用的方法备忘。前几篇布局介绍的链接如下： 使用autoresizing进行界面布局：http://my.oschina.net/u/2340880/blog/423357 初识autolayout布局模型：http://my.oschina.net/u/2340880/blog/423500 二、了解一个类用代码来做视图间的相关约束，那么就一定要将“约束”也进行对象化，在iOS6之后，引入了autolayout这个概念，相应的也增加了NSLayoutConstraint这个对象，这个对象就是专门用来进行约束布局的设置对象。通过这个对象，我们可以设置类似视图对象之间的间距，约束的宽高，比例等属性。创建NSLayoutConstraint对象的方法有两种，下面我们分别介绍： 1、使用Objective-C风格的方法创建约束对象所谓Objective-C风格的方法，就是通过原生枚举和一些属性设置来创建NSLayoutConstraint对象。使用NSLayoutConstraint类的如下方法： 1+(instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 先来介绍下方法中的参数都是什么意义，我们应该怎么用他们： view1：要添加约束的视图对象。 attr1：要约束的对象属性，这个就是一些枚举，如下： 123456789101112131415161718192021222324252627typedef NS_ENUM(NSInteger, NSLayoutAttribute) &#123; NSLayoutAttributeLeft = 1,//左 NSLayoutAttributeRight,//右 NSLayoutAttributeTop,//上 NSLayoutAttributeBottom,//下 NSLayoutAttributeLeading,//起始边，类似左，只在某些从右向左排列的语言中和NSLayoutAttributeLeft有大区别 NSLayoutAttributeTrailing,//结束边 NSLayoutAttributeWidth,//宽度 NSLayoutAttributeHeight,//高度 NSLayoutAttributeCenterX,//x中心 NSLayoutAttributeCenterY,//y中心 NSLayoutAttributeBaseline,//基线 NSLayoutAttributeLastBaseline = NSLayoutAttributeBaseline, NSLayoutAttributeFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0), //下面的属性是设置的边距 意义和上面类似 对应左，右等边距 NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeBottomMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeLeadingMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeTrailingMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeCenterXWithinMargins NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeCenterYWithinMargins NS_ENUM_AVAILABLE_IOS(8_0), //无，后面会说应用场景 NSLayoutAttributeNotAnAttribute = 0&#125;; relation：约束的选项，对应&lt;=,==,&gt;=这些，枚举如下： 12345typedef NS_ENUM(NSInteger, NSLayoutRelation) &#123; NSLayoutRelationLessThanOrEqual = -1,//&lt;= NSLayoutRelationEqual = 0,//== NSLayoutRelationGreaterThanOrEqual = 1,//&gt;=&#125;; view2:与之对应添加约束的视图对象，例如，如过我要设置view1的上边距离父视图的上边一定间距，这个view2就是view1的父视图，如果我要设置view1与另一个视图一定距离，这个view2就是另一个视图。 attr2：view2的要约束的属性，和attr1含义一样。 multiplie:约束的比例，比如view1的宽是view2的宽的两倍，这个multiplie就是2. C：这是具体的约束值 对于这些属性，文档上有这样的解释：view1.attr1 = view2.attr2 * multiplier + constant 例如，我们创建一个label，将它的宽高固定为100*100，位置放在屏幕的中央，我们可以使用如下的约束代码： 12345678910111213141516UILabel * label = [[UILabel alloc]init]; label.numberOfLines = 0; //使用代码布局 需要将这个属性设置为NO label.translatesAutoresizingMaskIntoConstraints = NO; label.backgroundColor = [UIColor redColor]; //创建x居中的约束 NSLayoutConstraint * constraintx = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1 constant:0]; //创建y居中的约束 NSLayoutConstraint * constrainty = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterY multiplier:1 constant:0]; //创建宽度约束 NSLayoutConstraint * constraintw = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:100]; //创建高度约束 NSLayoutConstraint * constrainth = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:100]; //添加约束之前，必须将视图加在父视图上 [self.view addSubview:label]; [self.view addConstraints:@[constraintx,constrainty,constrainth,constraintw]]; 效果如下： 可以发现，一个如此简单的约束方式，我们用这样的代码要写这么一大坨，麻烦而且不直观。于是，apple又提供给我们下面一种方式。 2.使用ASCLL字符创造艺术般的格式化字符串约束看到这个小标题是不是眼前一亮，这个标题不是我凭空想象出来的，apple的文档上就是这么写的。十分可爱，对吧。相对于NSLayoutConstraint中的创建方法如下： 1+ (NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(nullable NSDictionary&lt;NSString *,id&gt; *)metrics views:(NSDictionary&lt;NSString *, id&gt; *)views; 那么我们先来看，什么是格式化的字符串约束。 说到格式化的字符串约束，要先提一个东西VFL：visual format language——格式化约束语言，这又是什么鬼？确实，这个东西写出来第一眼看上去真的不知道是什么鬼，就比如要设置一个label，距离上边100，左边20，宽高都为100，代码如下： 12345678910 label.numberOfLines = 0; label.translatesAutoresizingMaskIntoConstraints = NO; label.backgroundColor = [UIColor redColor]; //label.text=@&quot;12332322132131233213213&quot;; [self.view addSubview:label]; NSArray * constraintArray = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-20-[label(100@1000)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(label)]; NSArray * constraintArray2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-100-[label(100)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(label)]; [self.view addConstraints:constraintArray]; [self.view addConstraints:constraintArray2]; 效果如下： 代码少了很多，对吧，但是中间那部分字符串什么玩意？下面我们来解释一下。 VFL语言我个人而言，他很类似于古代的象形文字(不知道是否apple的工程师从其中得到灵感)，对布局的约束设置是直观的用符号表达出来的，例如： 1H:|-20-[label(100@1000)] 前面的H代表是水平的布局还是垂直的布局，H代表水平，V表示垂直，|表示父视图的边沿，-20-表示距离20px，[]内是要布局摆放的视图对象名，()中是约束的尺寸，H下则为宽度，V下则为高度,@后面的数字代表优先级。 创建方法中的options参数，用来设置对齐模式，不需要可以写0： 1234567891011121314151617181920212223typedef NS_OPTIONS(NSUInteger, NSLayoutFormatOptions) &#123; NSLayoutFormatAlignAllLeft = (1 &lt;&lt; NSLayoutAttributeLeft), NSLayoutFormatAlignAllRight = (1 &lt;&lt; NSLayoutAttributeRight), NSLayoutFormatAlignAllTop = (1 &lt;&lt; NSLayoutAttributeTop), NSLayoutFormatAlignAllBottom = (1 &lt;&lt; NSLayoutAttributeBottom), NSLayoutFormatAlignAllLeading = (1 &lt;&lt; NSLayoutAttributeLeading), NSLayoutFormatAlignAllTrailing = (1 &lt;&lt; NSLayoutAttributeTrailing), NSLayoutFormatAlignAllCenterX = (1 &lt;&lt; NSLayoutAttributeCenterX), NSLayoutFormatAlignAllCenterY = (1 &lt;&lt; NSLayoutAttributeCenterY), NSLayoutFormatAlignAllBaseline = (1 &lt;&lt; NSLayoutAttributeBaseline), NSLayoutFormatAlignAllLastBaseline = NSLayoutFormatAlignAllBaseline, NSLayoutFormatAlignAllFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0) = (1 &lt;&lt; NSLayoutAttributeFirstBaseline), NSLayoutFormatAlignmentMask = 0xFFFF, /* choose only one of these three */ NSLayoutFormatDirectionLeadingToTrailing = 0 &lt;&lt; 16, // default NSLayoutFormatDirectionLeftToRight = 1 &lt;&lt; 16, NSLayoutFormatDirectionRightToLeft = 2 &lt;&lt; 16, NSLayoutFormatDirectionMask = 0x3 &lt;&lt; 16, &#125;; metrics参数是属性替换字典，例如我们上边用到的距离左边界20，如果这个20是一个变量width,我们可以将20的地方换成width，然后配置这个字典：@{@”width”:@20}，这样，在布局时，系统会把width换成20。 views是对象的映射字典，原理也是将字符串中的对象名label映射成真实的对象，NSDictionaryOfVariableBindings会帮我们生成这样的字典，我们只需要想对象传进去即可，如果要手动创建这字典，格式如下：@{@”label”：label}. 三、使用aotulayout设计一个聊天界面的输入框仔细观察QQ或者其他聊天工具的app上的输入框，会发现他非常智能，宽度会随着我们输入文字的行数进行自适应，并且这个宽度不是无限增大的，当我们文字多到一定行数，宽度会保持不变，文本框可以进行内容滑动，如果不用autolayout，这个功能会比较棘手一些，但是使用它，会发现这是如此的容易： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@interface ViewController ()&lt;UITextViewDelegate&gt;&#123; UITextView * textView ; NSArray * array1; NSArray * array2;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. textView = [[UITextView alloc]init]; textView.layer.borderColor = [[UIColor grayColor]CGColor]; textView.layer.borderWidth = 1; textView.translatesAutoresizingMaskIntoConstraints = NO; textView.delegate=self; [self.view addSubview:textView]; array1 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-100-[textView]-100-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; array2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-150-[textView(30)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; [self.view addConstraints:array1]; [self.view addConstraints:array2]; &#125;-(BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text&#123; //当文本高度大于textView的高度并且小于100时，更新约束 if (textView.contentSize.height&gt;textView.frame.size.height&amp;&amp;textView.contentSize.height&lt;100) &#123; float hight =textView.contentSize.height; //将以前的移除掉 [self.view removeConstraints:array1]; [self.view removeConstraints:array2]; array1 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-100-[textView]-100-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; array2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-150-[textView(hight)]&quot; options:0 metrics:@&#123;@&quot;hight&quot;:[NSNumber numberWithFloat:hight]&#125; views:NSDictionaryOfVariableBindings(textView)]; [self.view addConstraints:array1]; [self.view addConstraints:array2]; &#125; //更新约束 [self.view updateConstraintsIfNeeded]; return YES;&#125; 现在，当我们进行输入的时候，textView的高度可以自适应文字行数了。 四、通过动画改善更新约束时的效果这一点非常coll，上面我们已经实现了textView随文本的行数高度进行自适应，但是变化的效果十分生硬，还要apple的动画框架支持autolayout，把刚才调用更新约束的地方进行如下修改： 123[UIView animateWithDuration:1 animations:^&#123; [self.view layoutIfNeeded]; &#125;]; 试试看，变换的效果已经非常平滑了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列七——三维中的球型布局","slug":"142iOS流布局UICollectionView系列七——三维中的球型布局","date":"2015-10-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.324Z","comments":true,"path":"2015/10/29/142iOS流布局UICollectionView系列七——三维中的球型布局/","link":"","permalink":"http://huishao.cc/2015/10/29/142iOS流布局UICollectionView系列七——三维中的球型布局/","excerpt":"","text":"iOS流布局UICollectionView系列七——三维中的球型布局一、引言通过6篇的博客，从平面上最简单的规则摆放的布局，到不规则的瀑布流布局，再到平面中的圆环布局，我们突破了线性布局的局限，在后面，我们将布局扩展到了空间，在Z轴上进行了平移，我们实现了一个类似UIPickerView的布局模型，其实我们还可以再进一步，类比于平面布局，picKerView只是线性排列布局在空间上的旋转与平移，这次，我们更加充分了利用一下空间的尺寸，来设计一个圆球的布局模型。以下是前几篇博客地址： 1.初识与简单实用UICollectionView：http://my.oschina.net/u/2340880/blog/522613 2.UICollectionView的代理方法：http://my.oschina.net/u/2340880/blog/522682 3.实用FlowLayout进行更灵活布局：http://my.oschina.net/u/2340880/blog/522748 4.自定义FlowLayout进行瀑布流布局：http://my.oschina.net/u/2340880/blog/522806 5.平面圆环布局的实现：http://my.oschina.net/u/2340880/blog/523064 6.将布局从平面应用到空间：http://my.oschina.net/u/2340880/blog/523341 二、将布局扩展为空间球型在viewController中先实现一些准备代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; //这里设置的偏移量是为了无缝进行循环的滚动，具体在上一篇博客中有解释 collect.contentOffset = CGPointMake(320, 400); [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;//我们返回30的标签-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 30;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; label.text = [NSString stringWithFormat:@&quot;%ld&quot;,(long)indexPath.row]; [cell.contentView addSubview:label]; return cell;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;//这里对滑动的contentOffset进行监控，实现循环滚动-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y&lt;200) &#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y+10*400); &#125;else if(scrollView.contentOffset.y&gt;11*400)&#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y-10*400); &#125; if (scrollView.contentOffset.x&lt;160) &#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x+10*320,scrollView.contentOffset.y); &#125;else if(scrollView.contentOffset.x&gt;11*320)&#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x-10*320,scrollView.contentOffset.y); &#125;&#125; 这里面的代码比较上一篇博客中的并没有什么大的改动，只是做了横坐标的兼容。 在我们的layout类中，将代码修改成如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-(void)prepareLayout&#123; [super prepareLayout]; &#125;//返回的滚动范围增加了对x轴的兼容-(CGSize)collectionViewContentSize&#123; return CGSizeMake( self.collectionView.frame.size.width*([self.collectionView numberOfItemsInSection:0]+2), self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2));&#125;-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES;&#125;-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //获取item的个数 int itemCounts = (int)[self.collectionView numberOfItemsInSection:0]; atti.center = CGPointMake(self.collectionView.frame.size.width/2+self.collectionView.contentOffset.x, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y); atti.size = CGSizeMake(30, 30); CATransform3D trans3D = CATransform3DIdentity; trans3D.m34 = -1/900.0; CGFloat radius = 15/tanf(M_PI*2/itemCounts/2); //根据偏移量 改变角度 //添加了一个x的偏移量 float offsety = self.collectionView.contentOffset.y; float offsetx = self.collectionView.contentOffset.x; //分别计算偏移的角度 float angleOffsety = offsety/self.collectionView.frame.size.height; float angleOffsetx = offsetx/self.collectionView.frame.size.width; CGFloat angle1 = (float)(indexPath.row+angleOffsety-1)/itemCounts*M_PI*2; //x，y的默认方向相反 CGFloat angle2 = (float)(indexPath.row-angleOffsetx-1)/itemCounts*M_PI*2; //这里我们进行四个方向的排列 if (indexPath.row%4==1) &#123; trans3D = CATransform3DRotate(trans3D, angle1, 1.0,0, 0); &#125;else if(indexPath.row%4==2)&#123; trans3D = CATransform3DRotate(trans3D, angle2, 0, 1, 0); &#125;else if(indexPath.row%4==3)&#123; trans3D = CATransform3DRotate(trans3D, angle1, 0.5,0.5, 0); &#125;else&#123; trans3D = CATransform3DRotate(trans3D, angle1, 0.5,-0.5,0); &#125; trans3D = CATransform3DTranslate(trans3D, 0, 0, radius); atti.transform3D = trans3D; return atti;&#125;-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray * attributes = [[NSMutableArray alloc]init]; //遍历设置每个item的布局属性 for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123; [attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]]; &#125; return attributes;&#125; 布局效果如下： 滑动屏幕，这个圆球是可以进行滚动的。 TIP：这里我们只平均分配了四个方向上的布局，如果item更加小也更加多，我们可以分配到更多的方向上，使球体更加充实。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列五——圆环布局的实现","slug":"140iOS流布局UICollectionView系列五——圆环布局的实现","date":"2015-10-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.323Z","comments":true,"path":"2015/10/28/140iOS流布局UICollectionView系列五——圆环布局的实现/","link":"","permalink":"http://huishao.cc/2015/10/28/140iOS流布局UICollectionView系列五——圆环布局的实现/","excerpt":"","text":"iOS流布局UICollectionView系列五——圆环布局的实现一、引言前边的几篇博客，我们了解了UICollectionView的基本用法以及一些扩展，在不定高的瀑布流布局中，我们发现，可以通过设置具体的布局属性类UICollectionViewLayoutAttributes来设置设置每个item的具体位置，我们可以再扩展一下，如果位置我们可以自由控制，那个布局我们也可以更加灵活，就比如创建一个如下的circleLayout： 这种布局方式在apple的官方文档中也有介绍，是UICollectionView的一个应用示例。 二、设计一个圆环布局接着我们以前的想法，依然时候随机颜色的色块来表达我们的item，先自定义一个layout类，这个类继承于UICollectionViewLayout，UICollectionLayout是一个布局抽象基类，我们要使用自定义的布局方式，必须将其子类化，可能你还记得，我们在进行瀑布流布局的时候使用过UICollectionViewFlowLayout类，这个类就是继承于UICollectionViewLayout类，系统为我们实现好的一个布局方案。 1234@interface MyLayout : UICollectionViewLayout//这个int值存储有多少个item@property(nonatomic,assign)int itemCount;@end 我们需要重写这个类的三个方法，来进行圆环布局的设置，首先是prepareLayout，为布局做一些准备工作，使用collectionViewContentSize来设置内容的区域大小，最后使用layoutAttributesForElementsInRect方法来返回我们的布局信息字典，这个前面瀑布流布局的思路是一样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@implementation MyLayout&#123; NSMutableArray * _attributeAttay;&#125;-(void)prepareLayout&#123; [super prepareLayout]; //获取item的个数 _itemCount = (int)[self.collectionView numberOfItemsInSection:0]; _attributeAttay = [[NSMutableArray alloc]init]; //先设定大圆的半径 取长和宽最短的 CGFloat radius = MIN(self.collectionView.frame.size.width, self.collectionView.frame.size.height)/2; //计算圆心位置 CGPoint center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2); //设置每个item的大小为50*50 则半径为25 for (int i=0; i&lt;_itemCount; i++) &#123; UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]; //设置item大小 attris.size = CGSizeMake(50, 50); //计算每个item的圆心位置 /* . . . . . r . . ......... */ //计算每个item中心的坐标 //算出的x y值还要减去item自身的半径大小 float x = center.x+cosf(2*M_PI/_itemCount*i)*(radius-25); float y = center.y+sinf(2*M_PI/_itemCount*i)*(radius-25); attris.center = CGPointMake(x, y); [_attributeAttay addObject:attris]; &#125; &#125;//设置内容区域的大小-(CGSize)collectionViewContentSize&#123; return self.collectionView.frame.size;&#125;//返回设置数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return _attributeAttay;&#125; 在viewController中代码如下： 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.layer.masksToBounds = YES; cell.layer.cornerRadius = 25; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 如上非常简单的一些逻辑控制，我们就实现哦圆环布局，随着item的多少，布局会自动调整，如果不是UICollectionView的功劳，实现这样的功能，我们可能要写上一阵子了^_^。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列六——将布局从平面应用到空间","slug":"141iOS流布局UICollectionView系列六——将布局从平面应用到空间","date":"2015-10-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.324Z","comments":true,"path":"2015/10/28/141iOS流布局UICollectionView系列六——将布局从平面应用到空间/","link":"","permalink":"http://huishao.cc/2015/10/28/141iOS流布局UICollectionView系列六——将布局从平面应用到空间/","excerpt":"","text":"iOS流布局UICollectionView系列六——将布局从平面应用到空间一、引言前面，我们将布局由线性的瀑布流布局扩展到了圆环布局，这使我们使用UICollectionView的布局思路大大迈进了一步，这次，我们玩的更加炫一些，想办法将布局应用的空间，你是否还记得，在管理布局的item的具体属性的类UICollectionViewLayoutAttributrs类中，有transform3D这个属性，通过这个属性的设置，我们真的可以在空间的坐标系中进行布局设计。iOS系统的控件中，也并非没有这样的先例，UIPickerView就是很好的一个实例，这篇博客，我们就通过使用UICollectionView实现一个类似系统的UIPickerView的布局视图，来体会UICollectionView在3D控件布局的魅力。系统的pickerView效果如下： 二、先来实现一个炫酷的滚轮空间布局万丈的高楼也是由一砖一瓦堆砌而成，在我们完全模拟系统pickerView前，我们应该先将视图的布局摆放这一问题解决。我们依然来创建一个类，继承于UICollectionViewLayout： 123@interface MyLayout : UICollectionViewLayout@end 对于.m文件的内容，前几篇博客中我们都是在prepareLayout中进行布局的静态设置，那是因为我们前几篇博客中的布局都是静态的，布局并不会随着我们的手势操作而发生太大的变化，因此我们全部在prepareLayout中一次配置完了。而我们这次要讨论的布局则不同，pickerView会随着我们手指的拖动而进行滚动，因此UICollectionView中的每一个item的布局是在不断变化的，所以这次，我们采用动态配置的方式，在layoutAttributesForItemAtIndexPath方法中进行每个item的布局属性设置。 至于layoutAttributesForItemAtIndexPath方法，它也是UICollectionViewLayout类中的方法，用于我们自定义时进行重写，至于为什么动态布局要在这里面配置item的布局属性，后面我们会了解到。 在编写我们的布局类之前，先做好准备工作，在viewController中，实现如下代码： 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 250, 80)]; label.text = [NSString stringWithFormat:@&quot;我是第%ld行&quot;,(long)indexPath.row]; [cell.contentView addSubview:label]; return cell;&#125; 上面我创建了10个Item，并且在每个Item上添加了一个标签，标写是第几行。 在我们自定义的布局类中重写layoutAttributesForElementsInRect，在其中返回我们的布局数组： 12345678-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray * attributes = [[NSMutableArray alloc]init]; //遍历设置每个item的布局属性 for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123; [attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]]; &#125; return attributes;&#125; 之后，在我们布局类中重写layoutAttributesForItemAtIndexPath方法： 12345678910111213-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; //创建一个item布局属性类 UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //获取item的个数 int itemCounts = (int)[self.collectionView numberOfItemsInSection:0]; //设置每个item的大小为260*100 atti.size = CGSizeMake(260, 100); /* 后边介绍的代码添加在这里 */ return atti;&#125; 上面的代码中，我们什么都没有做，下面我们一步步来实现3D的滚轮效果。 首先，我们先将所有的item的位置都设置为collectionView的中心： 1atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2); 这时，如果我们运行程序的话，所有item都将一层层贴在屏幕的中央，如下： 很丑对吧，之后我们来设置每个item的3D效果,在上面的布局方法中添加如下代码: 12345678910111213141516 //创建一个transform3D类 //CATransform3D是一个类似矩阵的结构体 //CATransform3DIdentity创建空得矩阵 CATransform3D trans3D = CATransform3DIdentity; //这个值设置的是透视度，影响视觉离投影平面的距离 trans3D.m34 = -1/900.0; //下面这些属性 后面会具体介绍 //这个是3D滚轮的半径 CGFloat radius = 50/tanf(M_PI*2/itemCounts/2); //计算每个item应该旋转的角度 CGFloat angle = (float)(indexPath.row)/itemCounts*M_PI*2; //这个方法返回一个新的CATransform3D对象，在原来的基础上进行旋转效果的追加 //第一个参数为旋转的弧度，后三个分别对应x，y，z轴，我们需要以x轴进行旋转 trans3D = CATransform3DRotate(trans3D, angle, 1.0, 0, 0); //进行设置 atti.transform3D = trans3D; 对于上面的radius属性，运用了一些简单的几何和三角函数的知识。如果我们将系统的pickerView沿着y轴旋转90°，你会发现侧面的它是一个规则的正多边形，这里的radius就是这个多边形中心到其边的垂直距离，也是内切圆的半径，所有的item拼成了一个正多边形，示例如下： 通过简单的数学知识，h/2弦对应的角的弧度为2*pi/(边数)/2，在根据三角函数相关知识可知，这个角的正切值为h/2/radius，这就是我们radius的由来。 对于angle属性，它是每一个item的x轴旋转度数，如果我们将所有item的中心都放在一点，通过旋转让它们散开如下图所示： 每个item旋转的弧度就是其索引/(2*pi)。 通过上面的设置，我们再运行代码，效果如下： 仔细观察我们可以发现，item以x中轴线进行了旋转平均布局，侧面的效果就是我们上面的简笔画那样，下面要进行我们的第三步了，将这个item，全部沿着其Z轴向前拉，就可以成为我们滚轮的效果，示例图如下： 我们继续在刚才的代码后面添加这行代码： 12 //这个方法也返回一个transform3D对象，追加平移效果，后面三个参数，对应平移的x，y，z轴，我们沿z轴平移 trans3D = CATransform3DTranslate(trans3D, 0, 0, radius); 再次运行，效果如下： 布局的效果我们已经完成了，离成功很近了对吧，只是现在的布局是静态的，我们不能滑动这个滚轮，我们还需要用动态滑动做一些处理。 三、让滚轮滑动起来 通过上面的努力，我们已经静态布局出了一个类似pickerView的滚轮，现在我们再来添加滑动滚动的效果 首先，我们需要给collectionView一个滑动的范围，我们以一屏collectionView的滑动距离来当做滚轮滚动一下的参照，我们在布局类中的如下方法中返回滑动区域： 123-(CGSize)collectionViewContentSize&#123; return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*[self.collectionView numberOfItemsInSection:0]);&#125; 这时我们的collectionView已经可以进行滑动，但是并不是我们想要的效果，滚轮并没有滚动，而是随着滑动出了屏幕，因此，我们需要在滑动的时候不停的动态布局，将滚轮始终固定在collectionView的中心，先需要在布局类中实现如下方法： 12345//返回yes，则一有变化就会刷新布局-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES; &#125; 将上面的布局的中心点设置加上一个动态的偏移量： 1 atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y); 现在在运行，会发现滚轮会随着滑动始终固定在中间，但是还是不如人意，滚轮并没有转动起来，我们还需要动态的设置每个item的旋转角度，这样连续看起来，滚轮就转了起来，在上面设置布局的方法中，我们在添加一些处理： 12345 //获取当前的偏移量 float offset = self.collectionView.contentOffset.y; //在角度设置上，添加一个偏移角度 float angleOffset = offset/self.collectionView.frame.size.height; CGFloat angle = (float)(indexPath.row+angleOffset)/itemCounts*M_PI*2; 再看看效果，没错，就是这么简单，滚轮已经转了起来。 四、让其循环滚动的逻辑我们再进一步，如果滚动可以循环，这个控件将更加炫酷，添加这样的逻辑也很简单，通过监测scrollView的偏移量，我们可以对齐进行处理，因为collectionView继承于scrollView，我们可以直接在ViewController中实现其代理方法，如下： 123456789-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //小于半屏 则放到最后一屏多半屏 if (scrollView.contentOffset.y&lt;200) &#123; scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y+10*400); //大于最后一屏多一屏 放回第一屏 &#125;else if(scrollView.contentOffset.y&gt;11*400)&#123; scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y-10*400); &#125;&#125; 因为咱们的环状布局，上面的逻辑刚好可以无缝对接，但是会有新的问题，一开始运行，滚轮就是出现在最后一个item的位置，而不是第一个，并且有些相关的地方，我们也需要一些适配： 在viewController中： 12//一开始将collectionView的偏移量设置为1屏的偏移量collect.contentOffset = CGPointMake(0, 400); 在layout类中： 1234//将滚动范围设置为(item总数+2)*每屏高度 -(CGSize)collectionViewContentSize&#123; return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2));&#125; 12//将计算的具体item角度向前递推一个CGFloat angle = (float)(indexPath.row+angleOffset-1)/itemCounts*M_PI*2; OK，我们终于大功告成了，可以发现，实现这样一个布局效果炫酷的控件，代码其实并没有多少，相比，数学逻辑要比编写代码本身困难，这十分类似数学中的几何问题，如果你弄清了逻辑，解决是分分钟的事，我们可以通过这样的一个思路，设计更多3D或者平面特效的布局方案，抽奖的转动圆盘，书本的翻页，甚至立体的标签云，UICollectionView都可以实现，这篇博客中的代码在下面的连接中，疏漏之处，欢迎指正！ http://pan.baidu.com/s/1jGCmbKM 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列一——初识与简单使用UICollectionView image解决方法","slug":"136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView","date":"2015-10-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.322Z","comments":true,"path":"2015/10/27/136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView/","link":"","permalink":"http://huishao.cc/2015/10/27/136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView/","excerpt":"","text":"iOS流布局UICollectionView系列一——初识与简单使用UICollectionView一、简介UICollectionView是iOS6之后引入的一个新的UI控件，它和UITableView有着诸多的相似之处，其中许多代理方法都十分类似。简单来说，UICollectionView是比UITbleView更加强大的一个UI控件，有如下几个方面： 1、支持水平和垂直两种方向的布局 2、通过layout配置方式进行布局 3、类似于TableView中的cell特性外，CollectionView中的Item大小和位置可以自由定义 4、通过layout布局回调的代理方法，可以动态的定制每个item的大小和collection的大体布局属性 5、更加强大一点，完全自定义一套layout布局方案，可以实现意想不到的效果 这篇博客，我们主要讨论CollectionView使用原生layout的方法和相关属性，其他特点和更强的制定化，会在后面的博客中介绍 二、先来实现一个最简单的九宫格类布局在了解UICollectionView的更多属性前，我们先来使用其进行一个最简单的流布局试试看，在controller的viewDidLoad中添加如下代码： 123456789101112131415 //创建一个layout布局类 UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; //设置布局方向为垂直流布局 layout.scrollDirection = UICollectionViewScrollDirectionVertical; //设置每个item的大小为100*100 layout.itemSize = CGSizeMake(100, 100); //创建collectionView 通过一个布局策略layout来创建 UICollectionView * collect = [[UICollectionView alloc]initWithFrame:self.view.frame collectionViewLayout:layout]; //代理设置 collect.delegate=self; collect.dataSource=self; //注册item类型 这里使用系统的类型 [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect]; 这里有一点需要注意，collectionView在完成代理回调前，必须注册一个cell，类似如下: 1[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; 这和tableView有些类似，又有些不同，因为tableView除了注册cell的方法外，还可以通过临时创建来做： 12345//tableView在从复用池中取cell的时候，有如下两种方法//使用这种方式如果复用池中无，是可以返回nil的，我们在临时创建即可- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;//6.0后使用如下的方法直接从注册的cell类获取创建，如果没有注册 会崩溃- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); 我们可以分析：因为UICollectionView是iOS6.0之前的新类，因此这里统一了从复用池中获取cell的方法，没有再提供可以返回nil的方式，并且在UICollectionView的回调代理中，只能使用从复用池中获取cell的方式进行cell的返回，其他方式会崩溃，例如： 1234567891011121314//这是正确的方法-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125;//这样做会崩溃-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;// UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];// cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UICollectionViewCell * cell = [[UICollectionViewCell alloc]init]; return cell;&#125; 上面错误的方式会崩溃，信息如下，让我们使用从复用池中取cell的方式： 上面的设置完成后，我们来实现如下几个代理方法： 这里与TableView的回调方式十分类似 1234567891011121314//返回分区个数-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;//返回每个分区的item个数-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;//返回每个item-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 效果如下： 同样，如果内容的大小超出一屏，和tableView类似是可以进行视图滑动的。 还有一点细节，我们在上面设置布局方式的时候设置了垂直布局： 123layout.scrollDirection = UICollectionViewScrollDirectionVertical;//这个是水平布局//layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; 这样系统会在一行充满后进行第二行的排列，如果设置为水平布局，则会在一列充满后，进行第二列的布局，这种方式也被称为流式布局 三、UICollectionView中的常用方法和属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//通过一个布局策略初识化CollectionView- (instancetype)initWithFrame:(CGRect)frame collectionViewLayout:(UICollectionViewLayout *)layout;//获取和设置collection的layout@property (nonatomic, strong) UICollectionViewLayout *collectionViewLayout;//数据源和代理@property (nonatomic, weak, nullable) id &lt;UICollectionViewDelegate&gt; delegate;@property (nonatomic, weak, nullable) id &lt;UICollectionViewDataSource&gt; dataSource;//从一个class或者xib文件进行cell(item)的注册- (void)registerClass:(nullable Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;//下面两个方法与上面相似，这里注册的是头视图或者尾视图的类//其中第二个参数是设置 头视图或者尾视图 系统为我们定义好了这两个字符串//UIKIT_EXTERN NSString *const UICollectionElementKindSectionHeader NS_AVAILABLE_IOS(6_0);//UIKIT_EXTERN NSString *const UICollectionElementKindSectionFooter NS_AVAILABLE_IOS(6_0);- (void)registerClass:(nullable Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier;//这两个方法是从复用池中取出cell或者头尾视图- (__kindof UICollectionViewCell *)dequeueReusableCellWithReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;- (__kindof UICollectionReusableView *)dequeueReusableSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;//设置是否允许选中 默认yes@property (nonatomic) BOOL allowsSelection;//设置是否允许多选 默认no@property (nonatomic) BOOL allowsMultipleSelection;//获取所有选中的item的位置信息- (nullable NSArray&lt;NSIndexPath *&gt; *)indexPathsForSelectedItems; //设置选中某一item，并使视图滑动到相应位置，scrollPosition是滑动位置的相关参数，如下：/*typedef NS_OPTIONS(NSUInteger, UICollectionViewScrollPosition) &#123; //无 UICollectionViewScrollPositionNone = 0, //垂直布局时使用的 对应上中下 UICollectionViewScrollPositionTop = 1 &lt;&lt; 0, UICollectionViewScrollPositionCenteredVertically = 1 &lt;&lt; 1, UICollectionViewScrollPositionBottom = 1 &lt;&lt; 2, //水平布局时使用的 对应左中右 UICollectionViewScrollPositionLeft = 1 &lt;&lt; 3, UICollectionViewScrollPositionCenteredHorizontally = 1 &lt;&lt; 4, UICollectionViewScrollPositionRight = 1 &lt;&lt; 5&#125;;*/- (void)selectItemAtIndexPath:(nullable NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UICollectionViewScrollPosition)scrollPosition;//将某一item取消选中- (void)deselectItemAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;//重新加载数据- (void)reloadData;//下面这两个方法，可以重新设置collection的布局，后面的方法多了一个布局完成后的回调，iOS7后可以用//使用这两个方法可以产生非常炫酷的动画效果- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated;- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);//下面这些方法更加强大，我们可以对布局更改后的动画进行设置//这个方法传入一个布局策略layout，系统会开始进行布局渲染，返回一个UICollectionViewTransitionLayout对象//这个UICollectionViewTransitionLayout对象管理动画的相关属性，我们可以进行设置- (UICollectionViewTransitionLayout *)startInteractiveTransitionToCollectionViewLayout:(UICollectionViewLayout *)layout completion:(nullable UICollectionViewLayoutInteractiveTransitionCompletion)completion NS_AVAILABLE_IOS(7_0);//准备好动画设置后，我们需要调用下面的方法进行布局动画的展示，之后会调用上面方法的block回调- (void)finishInteractiveTransition NS_AVAILABLE_IOS(7_0);//调用这个方法取消上面的布局动画设置，之后也会进行上面方法的block回调- (void)cancelInteractiveTransition NS_AVAILABLE_IOS(7_0);//获取分区数- (NSInteger)numberOfSections;//获取某一分区的item数- (NSInteger)numberOfItemsInSection:(NSInteger)section;//下面两个方法获取item或者头尾视图的layout属性，这个UICollectionViewLayoutAttributes对象//存放着布局的相关数据，可以用来做完全自定义布局，后面博客会介绍- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;//获取某一点所在的indexpath位置- (nullable NSIndexPath *)indexPathForItemAtPoint:(CGPoint)point;//获取某个cell所在的indexPath- (nullable NSIndexPath *)indexPathForCell:(UICollectionViewCell *)cell;//根据indexPath获取cell- (nullable UICollectionViewCell *)cellForItemAtIndexPath:(NSIndexPath *)indexPath;//获取所有可见cell的数组- (NSArray&lt;__kindof UICollectionViewCell *&gt; *)visibleCells;//获取所有可见cell的位置数组- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleItems;//下面三个方法是iOS9中新添加的方法，用于获取头尾视图- (UICollectionReusableView *)supplementaryViewForElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0);- (NSArray&lt;UICollectionReusableView *&gt; *)visibleSupplementaryViewsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleSupplementaryElementsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);//使视图滑动到某一位置，可以带动画效果- (void)scrollToItemAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UICollectionViewScrollPosition)scrollPosition animated:(BOOL)animated;//下面这些方法用于动态添加，删除，移动某些分区获取items- (void)insertSections:(NSIndexSet *)sections;- (void)deleteSections:(NSIndexSet *)sections;- (void)reloadSections:(NSIndexSet *)sections;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;- (void)insertItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)deleteItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)reloadItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)moveItemAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列二——UICollectionView的代理方法","slug":"137iOS流布局UICollectionView系列二——UICollectionView的代理方法","date":"2015-10-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.322Z","comments":true,"path":"2015/10/27/137iOS流布局UICollectionView系列二——UICollectionView的代理方法/","link":"","permalink":"http://huishao.cc/2015/10/27/137iOS流布局UICollectionView系列二——UICollectionView的代理方法/","excerpt":"","text":"iOS流布局UICollectionView系列二——UICollectionView的代理方法一、引言在上一篇博客中，介绍了最基本的UICollectionView的使用和其中我们常用的属性和方法，也介绍了瀑布流布局的过程与思路，这篇博客是上一篇的补充，来讨论关于UICollectionView的代理方法的使用。博客地址： UICollectionView的简介和简单使用：http://my.oschina.net/u/2340880/blog/522613 二、UICollectionViewDataSource协议这个协议主要用于collectionView相关数据的处理，包含方法如下： 首先，有两个方法是我们必须实现的： 设置每个分区的Item个数 - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section; 设置返回每个item的属性 - (UICollectionViewCell )collectionView:(UICollectionView )collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; 下面的方法是可选实现的： 虽然这个方法是可选的，一般我们都会去实现，设置分区数 - (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView; 对头视图或者尾视图进行设置 - (UICollectionReusableView )collectionView:(UICollectionView )collectionView viewForSupplementaryElementOfKind:(NSString )kind atIndexPath:(NSIndexPath )indexPath; 设置某个item是否可以被移动，返回NO则不能移动 - (BOOL)collectionView:(UICollectionView )collectionView canMoveItemAtIndexPath:(NSIndexPath )indexPath NS_AVAILABLE_IOS(9_0); 移动item的时候，会调用这个方法 - (void)collectionView:(UICollectionView )collectionView moveItemAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath； 三、UICollectionViewDelegate协议这个协议用来设置和处理collectionView的功能和一些逻辑，所有方法都是可选实现： 是否允许某个Item的高亮，返回NO，则不能进入高亮状态 - (BOOL)collectionView:(UICollectionView )collectionView shouldHighlightItemAtIndexPath:(NSIndexPath )indexPath; 当item高亮时触发的方法 - (void)collectionView:(UICollectionView )collectionView didHighlightItemAtIndexPath:(NSIndexPath )indexPath; 结束高亮状态时触发的方法 - (void)collectionView:(UICollectionView )collectionView didUnhighlightItemAtIndexPath:(NSIndexPath )indexPath; 是否可以选中某个Item，返回NO，则不能选中 - (BOOL)collectionView:(UICollectionView )collectionView shouldSelectItemAtIndexPath:(NSIndexPath )indexPath; 是否可以取消选中某个Item - (BOOL)collectionView:(UICollectionView )collectionView shouldDeselectItemAtIndexPath:(NSIndexPath )indexPath; 已经选中某个item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didSelectItemAtIndexPath:(NSIndexPath )indexPath; 取消选中某个Item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didDeselectItemAtIndexPath:(NSIndexPath )indexPath; 将要加载某个Item时调用的方法 - (void)collectionView:(UICollectionView )collectionView willDisplayCell:(UICollectionViewCell )cell forItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0); 将要加载头尾视图时调用的方法 - (void)collectionView:(UICollectionView )collectionView willDisplaySupplementaryView:(UICollectionReusableView )view forElementKind:(NSString )elementKind atIndexPath:(NSIndexPath )indexPath NS_AVAILABLE_IOS(8_0); 已经展示某个Item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didEndDisplayingCell:(UICollectionViewCell )cell forItemAtIndexPath:(NSIndexPath *)indexPath; 已经展示某个头尾视图时触发的方法 - (void)collectionView:(UICollectionView )collectionView didEndDisplayingSupplementaryView:(UICollectionReusableView )view forElementOfKind:(NSString )elementKind atIndexPath:(NSIndexPath )indexPath; 这个方法设置是否展示长按菜单 - (BOOL)collectionView:(UICollectionView )collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath )indexPath; 长按菜单中可以触发一下类复制粘贴的方法，效果如下： 这个方法用于设置要展示的菜单选项 - (BOOL)collectionView:(UICollectionView )collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath )indexPath withSender:(nullable id)sender; 这个方法用于实现点击菜单按钮后的触发方法,通过测试，只有copy，cut和paste三个方法可以使用 - (void)collectionView:(UICollectionView )collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath )indexPath withSender:(nullable id)sender; 通过下面的方式可以将点击按钮的方法名打印出来： 123-(void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender&#123; NSLog(@&quot;%@&quot;,NSStringFromSelector(action));&#125; collectionView进行重新布局时调用的方法 - (nonnull UICollectionViewTransitionLayout )collectionView:(UICollectionView )collectionView transitionLayoutForOldLayout:(UICollectionViewLayout )fromLayout newLayout:(UICollectionViewLayout )toLayout; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局","slug":"138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局","date":"2015-10-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.322Z","comments":true,"path":"2015/10/27/138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局/","link":"","permalink":"http://huishao.cc/2015/10/27/138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局/","excerpt":"","text":"iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局一、引言前面的博客介绍了UICollectionView的相关方法和其协议中的方法，但对布局的管理类UICollectionViewFlowLayout没有着重探讨，这篇博客介绍关于布局的相关设置和属性方法。 UICollectionView的简单使用：http://my.oschina.net/u/2340880/blog/522613 UICollectionView相关协议方法：http://my.oschina.net/u/2340880/blog/522613 通过layout的设置，我们可以编写更加灵活的布局效果。 二、将九宫格式的布局进行升级在第一篇博客中，通过UICollectionView，我们很轻松的完成了一个九宫格的布局，但是如此中规中矩的布局方式，有时候并不能满足我们的需求，有时我们需要每一个Item展示不同的大小，代码如下： 123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init]; layout.scrollDirection = UICollectionViewScrollDirectionVertical; UICollectionView *collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; ; [self.view addSubview:collect]; &#125;//设置每个item的大小，双数的为50*50 单数的为100*100-(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; if (indexPath.row%2==0) &#123; return CGSizeMake(50, 50); &#125;else&#123; return CGSizeMake(100, 100); &#125;&#125;//代理相应方法-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 100;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 效果如下： 现在的布局效果是不是炫酷了许多。 三、UICollectionViewFlowLayout相关属性方法UICollectionViewFlowLayout是系统提供给我们一个封装好的流布局设置类，其中有一些布局属性我们可以进行设置： 设置行与行之间的间距最小距离 @property (nonatomic) CGFloat minimumLineSpacing; 设置列与列之间的间距最小距离 @property (nonatomic) CGFloat minimumInteritemSpacing; 设置每个item的大小 @property (nonatomic) CGSize itemSize; 设置每个Item的估计大小，一般不需要设置 @property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); 设置布局方向 @property (nonatomic) UICollectionViewScrollDirection scrollDirection; 这个UICollectionViewScrollDirection的枚举如下： 1234typedef NS_ENUM(NSInteger, UICollectionViewScrollDirection) &#123; UICollectionViewScrollDirectionVertical,//水平布局 UICollectionViewScrollDirectionHorizontal//垂直布局&#125;; 设置头视图尺寸大小 @property (nonatomic) CGSize headerReferenceSize; 设置尾视图尺寸大小 @property (nonatomic) CGSize footerReferenceSize; 设置分区的EdgeInset @property (nonatomic) UIEdgeInsets sectionInset; 这个属性可以设置分区的偏移量，例如我们在刚才的例子中添加如下设置： 1 layout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20); 效果如下，会看到分区的边界闪出了20像素 下面这两个方法设置分区的头视图和尾视图是否始终固定在屏幕上边和下边 @property (nonatomic) BOOL sectionHeadersPinToVisibleBounds NS_AVAILABLE_IOS(9_0); @property (nonatomic) BOOL sectionFootersPinToVisibleBounds NS_AVAILABLE_IOS(9_0); 四、动态的配置layout的相关属性UICollectionViewDelegateFlowLayout上面的方法在创建FlowLayout时静态的进行设置，如果我们需要动态的设置这些属性，就像我们例子中的，每个item的大小会有差异，我们可以通过代理来实现。 UICollectionViewDelegateFlowLayout是UICollectionViewDelegate的子协议，其中常用方法如下，我们只需要实现我们需要的即可： 动态设置每个Item的尺寸大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath; 动态设置每个分区的EdgeInsets - (UIEdgeInsets)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout insetForSectionAtIndex:(NSInteger)section; 动态设置每行的间距大小 - (CGFloat)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section; 动态设置每列的间距大小 - (CGFloat)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section; 动态设置某个分区头视图大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section; 动态设置某个分区尾视图大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局","slug":"139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局","date":"2015-10-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.323Z","comments":true,"path":"2015/10/27/139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局/","link":"","permalink":"http://huishao.cc/2015/10/27/139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局/","excerpt":"","text":"iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局一、引言前几篇博客从UICollectionView的基础应用到设置UICollectionViewFlowLayout更加灵活的进行布局，但都限制在系统为我们准备好的布局框架中，还是有一些局限性，例如，如果我要进行瀑布流似的不定高布局，前面的方法就很难满足我们的需求了，如下： 这种布局无疑在app的应用中更加广泛，商品的展示，书架书目的展示，都会倾向于采用这样的布局方式，当然，通过自定义FlowLayout，我们也很容易实现。 二、进行自定义瀑布流布局首先，我们新建一个文件继承于UICollectionViewFlowLayout： 1@interface MyLayout : UICollectionViewFlowLayout 为了演示的方面，这里我不错更多的封装，添加一个属性，直接让外界将item个数传递进来，我们把重心方法重写布局的方法上： 123@interface MyLayout : UICollectionViewFlowLayout@property(nonatomic,assign)int itemCount;@end 前面说过，UICollectionViewFlowLayout是一个专门用来管理collectionView布局的类，因此，collectionView在进行UI布局前，会通过这个类的对象获取相关的布局信息，FlowLayout类将这些布局信息全部存放在了一个数组中，数组中是UICollectionViewLayoutAttributes类，这个类是对item布局的具体设置，以后咱们在讨论这个类。总之，FlowLayout类将每个item的位置等布局信息放在一个数组中，在collectionView布局时，会调用FlowLayout类layoutAttributesForElementsInRect：方法来获取这个布局配置数组。因此，我们需要重写这个方法，返回我们自定义的配置数组，另外，FlowLayout类在进行布局之前，会调用prepareLayout方法，所以我们可以重写这个方法，在里面对我们的自定义配置数据进行一些设置。 简单来说，自定义一个FlowLayout布局类就是两个步骤： 1、设计好我们的布局配置数据 prepareLayout方法中 2、返回我们的配置数组 layoutAttributesForElementsInRect方法中 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@implementation MyLayout&#123; //这个数组就是我们自定义的布局配置数组 NSMutableArray * _attributeAttay;&#125;//数组的相关设置在这个方法中//布局前的准备会调用这个方法-(void)prepareLayout&#123; _attributeAttay = [[NSMutableArray alloc]init]; [super prepareLayout]; //演示方便 我们设置为静态的2列 //计算每一个item的宽度 float WIDTH = ([UIScreen mainScreen].bounds.size.width-self.sectionInset.left-self.sectionInset.right-self.minimumInteritemSpacing)/2; //定义数组保存每一列的高度 //这个数组的主要作用是保存每一列的总高度，这样在布局时，我们可以始终将下一个Item放在最短的列下面 CGFloat colHight[2]=&#123;self.sectionInset.top,self.sectionInset.bottom&#125;; //itemCount是外界传进来的item的个数 遍历来设置每一个item的布局 for (int i=0; i&lt;_itemCount; i++) &#123; //设置每个item的位置等相关属性 NSIndexPath *index = [NSIndexPath indexPathForItem:i inSection:0]; //创建一个布局属性类，通过indexPath来创建 UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:index]; //随机一个高度 在40——190之间 CGFloat hight = arc4random()%150+40; //哪一列高度小 则放到那一列下面 //标记最短的列 int width=0; if (colHight[0]&lt;colHight[1]) &#123; //将新的item高度加入到短的一列 colHight[0] = colHight[0]+hight+self.minimumLineSpacing; width=0; &#125;else&#123; colHight[1] = colHight[1]+hight+self.minimumLineSpacing; width=1; &#125; //设置item的位置 attris.frame = CGRectMake(self.sectionInset.left+(self.minimumInteritemSpacing+WIDTH)*width, colHight[width]-hight-self.minimumLineSpacing, WIDTH, hight); [_attributeAttay addObject:attris]; &#125; //设置itemSize来确保滑动范围的正确 这里是通过将所有的item高度平均化，计算出来的(以最高的列位标准) if (colHight[0]&gt;colHight[1]) &#123; self.itemSize = CGSizeMake(WIDTH, (colHight[0]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing); &#125;else&#123; self.itemSize = CGSizeMake(WIDTH, (colHight[1]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing); &#125; &#125;//这个方法中返回我们的布局数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return _attributeAttay;&#125;@end 自定义完成FlowLayout后，我们在ViewController中进行使用： 123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; layout.scrollDirection = UICollectionViewScrollDirectionVertical; layout.itemCount=100; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect]; &#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 100;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 运行效果就是我们引言中的截图。 三、UICollectionViewLayoutAttributes类中我们可以配置的属性通过上面的例子，我们可以了解，collectionView的item布局其实是LayoutAttributes类具体配置的，这个类可以配置的布局属性不止是frame这么简单，其中还有许多属性： 12345678910111213141516171819202122232425262728//配置item的布局位置@property (nonatomic) CGRect frame;//配置item的中心@property (nonatomic) CGPoint center;//配置item的尺寸@property (nonatomic) CGSize size;//配置item的3D效果@property (nonatomic) CATransform3D transform3D;//配置item的bounds@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);//配置item的旋转@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0);//配置item的alpha@property (nonatomic) CGFloat alpha;//配置item的z坐标@property (nonatomic) NSInteger zIndex; // default is 0//配置item的隐藏@property (nonatomic, getter=isHidden) BOOL hidden; //item的indexpath@property (nonatomic, strong) NSIndexPath *indexPath;//获取item的类型@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;@property (nonatomic, readonly, nullable) NSString *representedElementKind; //一些创建方法+ (instancetype)layoutAttributesForCellWithIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath *)indexPath; 通过上面的属性，可以布局出各式各样的炫酷效果，正如一句话：没有做不到，只有想不到。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Xcode真机测试could not find developer disk image解决方法","slug":"135Xcode真机测试could not find developer disk image解决方法","date":"2015-10-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.322Z","comments":true,"path":"2015/10/25/135Xcode真机测试could not find developer disk image解决方法/","link":"","permalink":"http://huishao.cc/2015/10/25/135Xcode真机测试could not find developer disk image解决方法/","excerpt":"","text":"Xcode真机测试could not find developer disk image解决方法在使用Xcode进行真机调试的时候，有时根据真机的系统不同，会出现could not find developer disk image 错误，这是由于真机系统过高或者过低，Xcode中没有匹配的配置包文件，我们可以通过这个路径进入配置包的存放目录： /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 里面有类似这样的一些文件夹，如果这些文件夹中没有包含我们真机的系统，则不能进行真机测试。但是我们可以通过将相应的配置包添加入这个文件夹来解决问题： 说了解决的方法，不提供文件，会让大家觉得坑爹，下面给大家一个链接，里面有从iOS4.2到9.1所有版本的配置包，大家各取所需，不用感谢我： http://pan.baidu.com/s/1qYIQWjE。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"watchOS中进行异步图片加载和缓存的策略","slug":"134watchOS中进行异步图片加载和缓存的策略","date":"2015-10-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.322Z","comments":true,"path":"2015/10/24/134watchOS中进行异步图片加载和缓存的策略/","link":"","permalink":"http://huishao.cc/2015/10/24/134watchOS中进行异步图片加载和缓存的策略/","excerpt":"","text":"watchOS中进行异步图片加载和缓存的策略一、引言iWatch是智能手表的一次革命。iWatch的应用也将会越来越多，基于watch的一些特点，watchOS的开发者需要更加精益的把握watch的UI和性能。运用watchOS自带的缓存体系进行数据的缓存，是增强用户体验度的一种方式，这篇博客，介绍在watchOS中进行异步加载图片和缓存的方法，愿与志同道合的朋友，一起交流。 关于watchOS中的缓存框架，在这里：http://my.oschina.net/u/2340880/blog/519023 。 二、存储的命名规则在进行设计之前，我们应该先了解，watchOS的缓存容量为最大20M，因为有限，我们更应该认真的利用每一份空间，因此，缓存我们不仅可以存，在即将装满的时候，我们还要有办法从缓存中删去一些东西，让出空间，那么应该删除哪些东西了，我们应该都可以想到，当然是旧的了，把最早的缓存删掉，所以，在存的时候，我们要设计一种规则，可以保存存入的时间，并且不影响我寻找这个缓存文件。我的方法是通过格式化的命名： 1234567891011121314//这是一个规范缓存命名的方法func checkString(str:NSString)-&gt;NSString&#123; let result:NSMutableString=NSMutableString() //先将所有的非字母和数字剔除掉 for var i=0 ; i&lt;str.length ; i++ &#123; if (str.characterAtIndex(i)&gt;=48&amp;&amp;str.characterAtIndex(i)&lt;=57)||(str.characterAtIndex(i)&gt;=65&amp;&amp;str.characterAtIndex(i)&lt;=90)||(str.characterAtIndex(i)&gt;=97&amp;&amp;str.characterAtIndex(i)&lt;=122)&#123; result.appendFormat(&quot;%c&quot;,str.characterAtIndex(i)) &#125; &#125; //拼接上当前时间戳 let date:Double = NSDate().timeIntervalSince1970 result.appendFormat(&quot;?%.0f&quot;,date) return result&#125; 通过？符号将名称和时间戳进行了拼接。 二、进行异步加载图片和缓存这一步是如下的设计思路：通过图片url从缓存的路径中进行寻找，如果有，直接取出图片，如果没有，开启一个线程进行异步加载，完成后刷新主线程UI并将图片文件规范命名后进行缓存： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//进行存取缓存的操作//取出watchOS的缓存目录let imagedic:NSDictionary = WKInterfaceDevice().cachedImages as NSDictionary //取图片存储的名称 let imageUrl:NSMutableString=NSMutableString() //这里的url是外界传进来的图片地址url，进行去掉特殊字符 for var i=0 ; i&lt;url?.length ; i++ &#123; if (url?.characterAtIndex(i)&gt;=48&amp;&amp;url?.characterAtIndex(i)&lt;=57)||(url?.characterAtIndex(i)&gt;=65&amp;&amp;url?.characterAtIndex(i)&lt;=90)||(url?.characterAtIndex(i)&gt;=97&amp;&amp;url?.characterAtIndex(i)&lt;=122)&#123; imageUrl.appendFormat(&quot;%c&quot;,(url?.characterAtIndex(i))!) &#125; &#125; //查找缓存中是否有图片 //遍历watchOS的缓存目录 for var i=0 ; i&lt;imagedic.allKeys.count ; i++ &#123; //通过规定好的？进行分割 let str:NSArray = imagedic.allKeys[i].componentsSeparatedByString(&quot;?&quot;) if str[0].isEqualToString(imageUrl as String) &#123; //找到图片 view是要设置的interfaceImage view.setImageNamed(imagedic.allKeys[i] as? String) return; &#125; &#125; //设置缺省图片 这里是外界传进来的缺省图片，如果需要下载，先设置缺省图片 if defaultImage != nil &#123; view.setImageNamed(defaultImage as? String) &#125; //进行下载和存储 let dispath = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) //在新的线程中下载 dispatch_async(dispath, &#123; () -&gt; Void in let imgURL:NSURL = NSURL(string: url as! String)! let imageData:NSData? = NSData(contentsOfURL: imgURL) if imageData != nil &#123; //主线程中刷新 dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in view.setImageData(imageData!) &#125;) //写缓存 如果缓存满了 就删掉时间戳最早的一张缓存 //这个方法会返回bool值，判断是否存入成功 while !WKInterfaceDevice().addCachedImageWithData(imageData!, name: checkString(url!) as String) &#123; //如果存入失败，删去时间戳最早的缓存 var temp:NSString? //保存最早的缓存名称 var result:NSString? for var i=0 ; i&lt;imagedic.allKeys.count ; i++ &#123; let str:NSArray = imagedic.allKeys[i].componentsSeparatedByString(&quot;?&quot;) if temp == nil &#123; temp = str[1] as? NSString result = imagedic.allKeys[i] as! String break &#125; if str[1].doubleValue &lt; temp?.doubleValue &#123; //找到更早的缓存 temp = str[1] as? NSString result = imagedic.allKeys[i] as! String &#125; &#125; //删掉缓存 WKInterfaceDevice().removeCachedImageWithName(result as! String) &#125; &#125; &#125;) 上面的代码和注释，已经介绍了所有的思路，有错误之处或者更好的方式，还望多多指点。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门七——watchOS中通知的应用","slug":"131AppleWatch开发入门七——watchOS中通知的应用","date":"2015-10-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.321Z","comments":true,"path":"2015/10/19/131AppleWatch开发入门七——watchOS中通知的应用/","link":"","permalink":"http://huishao.cc/2015/10/19/131AppleWatch开发入门七——watchOS中通知的应用/","excerpt":"","text":"AppleWatch开发入门七——watchOS中通知的应用一、引言在iOS系统中，支持的通知有两种类型：本地通知和远程通知。本地通知多用于计时类通知，远程的又称推送，多用于一些提示动态的提示信息。这里有相关通知的一些知识总结： 本地推送：http://my.oschina.net/u/2340880/blog/405491。 远程推送：http://my.oschina.net/u/2340880/blog/413584。 在watch中，通知是和iphone同步的，在iphone上的App收到通知的同时，会默认也推送到watch上，基于watch的穿戴性，对用户来说，它上面的通知信息将比iphone更加及时。 二、WatchOS通知概览首先，watch上的通知分为两部分：short-look和long-lock。简而言之，short-look，可以理解为一个简单的通知预览，它会将通知发起的APP和主要标题等信息展示给你，让你一目了然，当用户抬起手腕，查看这个通知一定时间，这个短通知就会转换为long-look通知。short-look的通知界面我们不能够自定义，系统为我们设计好了模样，如下： 长通知的界面我们是可以进行一定程度上的自定义的，并且可以添加按钮等逻辑操作。 long-look也分为两种界面，静态界面和动态界面。这个也好理解，静态界面是我们在写程序时就定义好的界面，在通知发送到watch上时，界面会自动匹配通知内容进行显示。动态的界面则是当收到通知时，会先执行我们相应的配置代码，之后在进行通知界面的展示。一个long-look界面大致如下： 在long-lock中，界面定义为三个部分，头部标题栏，自定义视图栏和按钮交互区。头部的标题栏我们不能自定义，它是一个半透明的上面有App图标和名字的横栏。其下面是我们可以自定义的区域，我们可以在storyBoard中拉入文本和图片。最下面是一些交互按钮，其名称等配置信息在推送的文件中定义。 三、如何在模拟器上模拟远程推送在watchOS模拟器上，Xcode为我们准备好了一种可以模拟测试推送的方式。如果我们创建项目时，选择了NotifacationScene,则Xcode会默认为我们创建一个apns文件： 这个文件就是模拟推送的相关配置文件，如果没有，我们也可以手动来创建： 文件中的内容格式如下： 12345678910111213141516171819&#123; &quot;aps&quot;: &#123; &quot;alert&quot;: &#123; &quot;body&quot;: &quot;通知&quot;, &quot;title&quot;: &quot;通知来了&quot; &#125;, &quot;category&quot;: &quot;myCategory&quot; &#125;, &quot;WatchKit Simulator Actions&quot;: [ &#123; &quot;title&quot;: &quot;First Button&quot;, &quot;identifier&quot;: &quot;firstButtonAction&quot; &#125; ], &quot;customKey&quot;: &quot;Use this file to define a testing payload for your notifications. The aps dictionary specifies the category, alert text and title. The WatchKit Simulator Actions array can provide info for one or more action buttons in addition to the standard Dismiss button. Any other top level keys are custom payload. If you have multiple such JSON files in your project, you&apos;ll be able to select them when choosing to debug the notification interface of your Watch App.&quot;&#125; 这是一些json格式的数据，其中alert是对推送内容的设置，body会显示在long-look的标题栏，title会显示在short-look的标题栏，Actions数组中是对按钮就行配置，每一个按钮可以设置一个标题和id，标题用于在推送界面显示，id用于处理点击按钮后触发的逻辑。 创建好这个，我们可以来试着测试一下推送的界面，选择推送工程，运行即可： 四、long-look的静态界面和动态界面上面提到过，long-look分为静态界面和动态界面两种，当我们在storyBoard中拉入一个Notification Interface Controller的时候，可以选择同时创建动态界面，勾选 Has Dynamic Interface： 这时，在storyBoard中是如下模样： 我们在创建一个文件，继承于WKUserNotificationInterfaceController，并将storyBoard中动态的的推送controller的class设置为我们创建的类： 注意，这里设置的是动态的Interface，也就是上面右边的controller。之后运行，你会发现效果并没有什么改变，那是因为系统默认会从静态界面加载推送界面，我们需要在NotifacationController代码中做一些操作： 1234567891011121314151617//在NotificationController中重写下面两个方法//这个用于本地推送override func didReceiveLocalNotification(localNotification: UILocalNotification, withCompletion completionHandler: ((WKUserNotificationInterfaceType) -&gt; Void)) &#123; //在这里做一些动态界面的加载操作，比如可以根据推送的数据 设置图片 文字等 //下面这个方法决定是加载静态的界面还是动态的界面 //Custom是加载动态界面 //default是加载静态界面 completionHandler(.Custom) &#125; //设个用于远程推送 和上面方法类似override func didReceiveRemoteNotification(remoteNotification: [NSObject : AnyObject], withCompletion completionHandler: ((WKUserNotificationInterfaceType) -&gt; Void)) &#123; completionHandler(.Custom) &#125; 五、触发推送点击事件首先，我们多配置几个点击按钮，在apns文件中如下配置： 1234567891011121314151617&quot;WatchKit Simulator Actions&quot;: [ &#123; &quot;title&quot;: &quot;第一&quot;, &quot;identifier&quot;: &quot;one&quot; &#125;, &#123; &quot;title&quot;: &quot;第二&quot;, &quot;identifier&quot;: &quot;two&quot; &#125;, &#123; &quot;title&quot;: &quot;第三&quot;, &quot;identifier&quot;: &quot;three&quot; &#125; ], 在我们watch App的InterfaceController中实现如下的方法： 12345678910//重写下面两个方法来响应点击事件//远程推送的方法override func handleActionWithIdentifier(identifier: String?, forRemoteNotification remoteNotification: [NSObject : AnyObject]) &#123; //通过我们配置的按钮id来区分点击的按钮 处理响应的逻辑 print(identifier) &#125;//本地推送的方法override func handleActionWithIdentifier(identifier: String?, forLocalNotification localNotification: UILocalNotification) &#123; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门八——Watch中图片缓存的处理","slug":"132AppleWatch开发入门八——Watch中图片缓存的处理","date":"2015-10-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.321Z","comments":true,"path":"2015/10/19/132AppleWatch开发入门八——Watch中图片缓存的处理/","link":"","permalink":"http://huishao.cc/2015/10/19/132AppleWatch开发入门八——Watch中图片缓存的处理/","excerpt":"","text":"AppleWatch开发入门八——Watch中图片缓存的处理由于iWatch在存储和性能上都和iPhone有着很大的差距，这就要求开发者对程序有更高的性能优化，下载与传输图像，在Watch操作中是一个非时的过程，因此，watchOS中为我们提供了一个缓存图片的框架，并且接口和使用都非常简单。 WatchOS中缓存图片的方法封装在WKInterfaceDevice这个类中，其中添加图片进入缓存的方法如下： 12345//添加一个UIImage对象进入缓存目录，设置name，当我们设置图片时，可以直接通过name进行设置public func addCachedImage(image: UIImage, name: String) -&gt; Bool//添加一个Data图片进入缓存目录，设置name，当我们设置图片时，可以直接通过name进行设置public func addCachedImageWithData(imageData: NSData, name: String) -&gt; Bool//上面两个方法的返回值用于判断缓存是否成功，因为watch缓存目录的大小有限，可能会失败 同样，我们也可以将已经缓存的图片数据删除掉： 1234 //根据name删除一个图片数据 public func removeCachedImageWithName(name: String) //删除缓存目录中所有的图片数据 public func removeAllCachedImages() 我们也可以通过下面的方法获取所有缓存图片的name值： 12//下面这个函数返回一个字典，string为缓存图片的name值，NSNumber为相应的图片大小，单位为bpublic var cachedImages: [String : NSNumber] &#123; get &#125; 注意：系统缓存目录的大小为20M，如果缓存失败，可以尝试删掉旧的缓存。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门九——Watch帧动画的实现","slug":"133AppleWatch开发入门九——Watch帧动画的实现","date":"2015-10-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.322Z","comments":true,"path":"2015/10/19/133AppleWatch开发入门九——Watch帧动画的实现/","link":"","permalink":"http://huishao.cc/2015/10/19/133AppleWatch开发入门九——Watch帧动画的实现/","excerpt":"","text":"AppleWatch开发入门九——Watch帧动画的实现动画一直是iOS系统的一大亮点，CoreAnimation和粒子效果的支持，开发者可以很容易的做出效果炫酷的动画特效。在watchOS中，由于性能和屏幕尺寸的限制，对于动画，并没有强大的框架支持，但是这并不是说开发者就没办法在watch上添加动画的特效了。在watchOS中唯一可以让开发者用于动画操作的就是帧动画。 和iOS类似，watchOS中的真动画也是通过UIImage对象的合集来展示的。只是设置和用法略有不同。 首先，watchOS中帧动画的操作被单独封装成了一个协议，当然，WKInterfaceImage类是遵守了这个协议的： 12345678public protocol WKImageAnimatable : NSObjectProtocol &#123; //从默认帧开始播放动画 public func startAnimating() //播放一个指定范围的帧动画 NSRange是帧的范围，durtion是播放一遍的时间，repeatCount是重复播放次数，0为无限循环 public func startAnimatingWithImagesInRange(imageRange: NSRange, duration: NSTimeInterval, repeatCount: Int) //停止播放动画 public func stopAnimating()&#125; 创建帧动画的步骤与一些注意： 1、关联一个视图中的WKInterfaceImage对象 2、所有帧动画的图片帧必须有统一的格式：比如image1.png，image2.png等等 3、给WKInterfaceImage对象设置帧前缀： 1imageInterface.setImageNamed(&quot;image&quot;) 注意：这里使用的方法和设置图片的方法一样，但是参数有别，图片的设置需要完整的图片名，动画帧前缀的设置只要设置帧图片的前缀。 4、开始动画： 1 imageInterface.startAnimatingWithImagesInRange(NSRange(location: 1, length: 3), duration: 3, repeatCount: 0) 注意：素材帧必须放入watchKit App这个Target中，才可以使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"iOS8统一的系统提示控件——UIAlertController","slug":"130iOS8统一的系统提示控件——UIAlertController","date":"2015-10-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.321Z","comments":true,"path":"2015/10/17/130iOS8统一的系统提示控件——UIAlertController/","link":"","permalink":"http://huishao.cc/2015/10/17/130iOS8统一的系统提示控件——UIAlertController/","excerpt":"","text":"iOS8统一的系统提示控件——UIAlertController一、引言相信在iOS开发中，大家对UIAlertView和UIActionSheet一定不陌生，这两个控件在UI设计中发挥了很大的作用。然而如果你用过，你会发现这两个控件的设计思路有些繁琐，通过创建设置代理来进行界面的交互，将代码逻辑分割了，并且很容易形成冗余代码。在iOS8之后，系统吸引了UIAlertController这个类，整理了UIAlertView和UIActionSheet这两个控件，在iOS中，如果你扔使用UIAlertView和UIActionSheet，系统只是会提示你使用新的方法，iOS9中，这两个类被完全弃用，但这并不说明旧的代码将不能使用，旧的代码依然可以工作很好，但是会存在隐患，UIAlertController，不仅系统推荐，使用更加方便，结构也更加合理，作为开发者，使用新的警示控件，我们何乐而不为呢。这里有旧的代码的使用方法： UIAlertView使用：http://my.oschina.net/u/2340880/blog/408873。 UIActionSheet使用：http://my.oschina.net/u/2340880/blog/409907。 二、UIAlertController的使用从这个类的名字我们就可以看出，对于警示控件，设计的思路不再是View而是Controller。通过present和push进行呼出，而不是以前的show方法。另一个机制改变的地方是，其中按钮的触发方法不再通过代理处理，而是将按钮封装成了类:UIAlertAction。详细方法及使用如下： 12345 UIAlertController * con = [UIAlertController alertControllerWithTitle:@&quot;新的&quot; message:@&quot;看看样子&quot; preferredStyle:UIAlertControllerStyleAlert]; [con addAction:[UIAlertAction actionWithTitle:@&quot;仔细看&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; //按钮触发的方法 &#125;]]; [self presentViewController:con animated:YES completion:nil]; 上面的代码，会在屏幕上呼出警告框，如下： 初始化方法中的preferref参数是一个枚举，决定是提示框或者抽屉列表： 1234typedef NS_ENUM(NSInteger, UIAlertControllerStyle) &#123; UIAlertControllerStyleActionSheet = 0,//抽屉 UIAlertControllerStyleAlert//警告框&#125; 上面的addAction方法添加了一个封装了方法的按钮，UIAlertAction类的构造十分简单，如下： 12345678//初始化方法+ (instancetype)actionWithTitle:(nullable NSString *)title style:(UIAlertActionStyle)style handler:(void (^ __nullable)(UIAlertAction *action))handler;//获取标题@property (nullable, nonatomic, readonly) NSString *title;//获取风格@property (nonatomic, readonly) UIAlertActionStyle style;//设置是否有效@property (nonatomic, getter=isEnabled) BOOL enabled; AlertAction的风格是如下的枚举： 12345typedef NS_ENUM(NSInteger, UIAlertActionStyle) &#123; UIAlertActionStyleDefault = 0,//默认的风格 UIAlertActionStyleCancel,//取消按钮的风格 UIAlertActionStyleDestructive//警告的风格&#125; 风格效果如下： 三、UIAlertController其他属性和方法@property (nonatomic, readonly) NSArray *actions; 获取所有AlertAction @property (nonatomic, strong, nullable) UIAlertAction *preferredAction NS_AVAILABLE_IOS(9_0); iOS9后新增加的属性，可以使某个按钮更加突出，只能设置已经在actions数组中的AkertAction，会使设置的按钮更加显眼，如下： - (void)addTextFieldWithConfigurationHandler:(void (^ __nullable)(UITextField *textField))configurationHandler; 添加一个textField，以前的相关控件，虽然也可以添加textField，但是定制化能力非常差，这个新的方法中有一个configurationHandler代码块，可以将textField的相关设置代码放入这个代码块中，并且这个方法添加的textField个数不再限制于2个： 123456789 [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第1个&quot;; &#125;]; [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第2个&quot;; &#125;]; [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第3个&quot;; &#125;]; @property (nullable, nonatomic, readonly) NSArray *textFields; 获取所有textField的数组 @property (nullable, nonatomic, copy) NSString *title; 设置警示控件的标题 @property (nullable, nonatomic, copy) NSString *message; 设置警示控件的信息 @property (nonatomic, readonly) UIAlertControllerStyle preferredStyle; 获取警示控件的风格 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"AppleWatch开发入门六——Glance(预览)扩展的应用","slug":"129AppleWatch开发入门六——Glance(预览)扩展的应用","date":"2015-10-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.321Z","comments":true,"path":"2015/10/16/129AppleWatch开发入门六——Glance(预览)扩展的应用/","link":"","permalink":"http://huishao.cc/2015/10/16/129AppleWatch开发入门六——Glance(预览)扩展的应用/","excerpt":"","text":"AppleWatch开发入门六——Glance(预览)扩展的应用一、简介Glance是watchOS中类似iOS的today插件一样的预览扩展。提供了Glance功能的WatchApp可以在手表主页上唤起Glance，展示app相关信息，然而这个扩展只能作为展示作用，并不能进行太多的交互，界面的布局也有很大的限制，因此，Glance的应用主要在于展示备忘信息等。特点如下： 1、扩展的样式布局我们并不能完全个性化，只能通过系统模板来布局。 2、扩展中不能添加交互功能，只能展示信息，点击界面间唤起WatchApp。 3、一个app只能享有一个Glance界面，并且是单屏的不可滑动。 二、创建一个Glance在我们创建WatchApp的时候，可以勾选创建Glance： 同样，如果这里没有勾选，我们也可以在storyBoard中拉入一个Glance界面： 可以发现，这里面的布局样式，我们不能做修改，只能使用系统提供的一些模板： 我们创建一个模板，可以将其中元素与文件关联，进行代码的动态设置。 在Xcode7中，在Scream中选择Glance项目，进行运行： 模拟器效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门四——Table视图的应用","slug":"127AppleWatch开发入门四——Table视图的应用","date":"2015-10-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.320Z","comments":true,"path":"2015/10/15/127AppleWatch开发入门四——Table视图的应用/","link":"","permalink":"http://huishao.cc/2015/10/15/127AppleWatch开发入门四——Table视图的应用/","excerpt":"","text":"AppleWatch开发入门四——Table视图的应用一、Watch上的TableWatchOS中的TableView和iOS中的TableView还是有很大的区别，在开发之前，首先我们应该明白WatchOS中的Table有哪些局限性和特点。下面几点是我总结WatchOS中Table的特殊之处： 1、Table只有行的概念，没有分区的概念，没有头尾视图的概念。 2、可以通过创建多个Table，来实现分区的效果。 3、因为Watch上是通过Gruop进行布局适应的，所以没有行高等设置。 4、Table没有代理，所有行的数据都是采用静态配置的方式，后面会介绍。 5、点击Table中的行触发的方法，是通过重写Interface中的方法来实现的。 二、创建一个Table在storyBoard中拖入你的Table，如下： 在Table上拉两个label： 每一个Table中包含一个TableRowController，实际上我们Table上的控件都是通过这个TableRowController进行管理的，因此如果我们需要在代码中控制TableRow上的内容，我们需要创建一个文件作为Table的TableRowController： 将storyBoard中TableRowController的类修改为我们创建的类并指定一个identifier： 然后，我们将两个label关联到TableRowController中： 123456import WatchKitclass TableRowController: NSObject &#123; @IBOutlet var numberLabel: WKInterfaceLabel! @IBOutlet var titleLabel: WKInterfaceLabel!&#125; 将Table关联到interfaceController中： 12345class InterfaceControllerMain: WKInterfaceController &#123; @IBOutlet var Table: WKInterfaceTable!&#125; 下面，我们开始在interface中对Table做相关配置，首先我们可以先观察一下WKInterfaceTable中有哪些方法和属性： 1234567891011121314151617181920public class WKInterfaceTable : WKInterfaceObject &#123; //设置行的类型，数组中对应存放行的类型，数组元素的个数，就是行数 /* 通过这个方法，我们可以创建每一行样式都不同的table，行的类型 实际上就是我们刚才用到的TableRowController，我们可以进行自定义 */ public func setRowTypes(rowTypes: [String]) //设置行数和类型 用于创建单一行类型的table public func setNumberOfRows(numberOfRows: Int, withRowType rowType: String) // repeating row name //这个get方法获取行数，用于我们遍历table中的行，进行内容设置 public var numberOfRows: Int &#123; get &#125; //这个方法会返回某一行，我们可以获取到后进行内容设置 public func rowControllerAtIndex(index: Int) -&gt; AnyObject? //插入一行 public func insertRowsAtIndexes(rows: NSIndexSet, withRowType rowType: String) //删除一行 public func removeRowsAtIndexes(rows: NSIndexSet) //滑动到某一行 public func scrollToRowAtIndex(index: Int)&#125; 了解了上面的方法，可以看出，WatchOS的Table配置非常简单易用，例如我们如下配置： 1234567891011121314151617@IBOutlet var Table: WKInterfaceTable! override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) let dic:Dictionary&lt;String,String&gt; = [&quot;中国建设银行&quot;:&quot;￥1000&quot;,&quot;中国农业银行&quot;:&quot;￥5000&quot;,&quot;中国银行&quot;:&quot;20000&quot;,&quot;招商银行&quot;:&quot;￥401&quot;,&quot;中国邮政储蓄&quot;:&quot;1100&quot;] //设置行数与类型 Table.setNumberOfRows(dic.count, withRowType: &quot;TableRowController&quot;) //遍历进行设置 let titleArray:Array&lt;String&gt; = Array(dic.keys) for var i=0 ; i &lt; dic.count ; i++ &#123; let row:TableRowController = Table.rowControllerAtIndex(i) as! TableRowController row.titleLabel.setText(titleArray[i]) row.numberLabel.setText(dic[titleArray[i]]) row.numberLabel.setTextColor(UIColor.grayColor()) &#125; // Configure interface objects here. &#125; 这样一个展示银行卡余额的界面我们就创建完成了，效果如下： 三、关于Table的点击事件上面我们提到，Table没有所谓代理方法，点击row的时候，我们也是通过两种方式进行逻辑跳转的，一种是在storyBoard中，我们通过拉线跳转，这时如需传值，我们需在interface中实现如下方法： 1 public func contextForSegueWithIdentifier(segueIdentifier: String, inTable table: WKInterfaceTable, rowIndex: Int) -&gt; AnyObject? 另一种方式，我们可以重写实现InterfaceController中的如下方法，来处理Table的点击事件： 1public func table(table: WKInterfaceTable, didSelectRowAtIndex rowIndex: Int) 无论哪种方式，我们都可以通过参数table和rowIndex来确认点击的具体是那个table和哪一行，进行传值和处理我们的逻辑。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门五——菜单控件的使用","slug":"128AppleWatch开发入门五——菜单控件的使用","date":"2015-10-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.321Z","comments":true,"path":"2015/10/15/128AppleWatch开发入门五——菜单控件的使用/","link":"","permalink":"http://huishao.cc/2015/10/15/128AppleWatch开发入门五——菜单控件的使用/","excerpt":"","text":"AppleWatch开发入门五——菜单控件的使用一、简介菜单也是WatchOS中一个重要的交互方式，限于Watch的屏幕尺寸，若将所有用户交互控件都紧密的排列进展示的UI中，那样难免会使用户操作困难，也会影响界面布局的简洁美观。因此，WatchOS的菜单机制是一层覆盖在屏幕上的交互界面，有如下的特点： 1、菜单是内置于InterfaceController中的，不需显式处理，只需对齐菜单项进行添加设置。 2、菜单最多可以容乃四个选项按钮。 3、通过重按可以呼出和隐藏菜单。 二、创建菜单的两种方式1、通过storyBoard创建在storyBoard中，我们可以将一个菜单控件拖入到interfaceController中： 在Menu中可以添加一些item，每个item都可以设置图片和文字： 图片的设置分为，自定义和系统两种，我们可以使用自己的图片作为菜单的图片，也可以使用系统为我们提供的一些图片，系统的图片参数是一个枚举，值如下： 12345678910111213141516171819public enum WKMenuItemIcon : Int &#123; case Accept // checkmark case Add // &apos;+&apos; case Block // circle w/ slash case Decline // &apos;x&apos; case Info // &apos;i&apos; case Maybe // &apos;?&apos; case More // &apos;...&apos; case Mute // speaker w/ slash case Pause // pause button case Play // play button case Repeat // looping arrows case Resume // circular arrow case Share // share icon case Shuffle // swapped arrows case Speaker // speaker icon case Trash // trash icon&#125; 这些枚举中提供了一些我们常用的功能图标。 菜单按钮的触发方法，我们可以通过拖拽Action的方式来添加，在Xcode7的模拟器中，我们使用command+shift+2可以切换到重按模式，模拟器效果如下： 2、通过代码来添加菜单选项前面提到过，菜单是内含于InterfaceController中的一个控件，在Interface中我们可以调用一些方法来添加菜单按钮，相关方法如下： 1234567 //添加一个菜单按钮，图片自定义 public func addMenuItemWithImage(image: UIImage, title: String, action: Selector) public func addMenuItemWithImageNamed(imageName: String, title: String, action: Selector) //添加一个系统图片的按钮 public func addMenuItemWithItemIcon(itemIcon: WKMenuItemIcon, title: String, action: Selector) //清除所有按钮 public func clearAllMenuItems() 示例代码如下： 1234567891011121314151617override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) self.addMenuItemWithItemIcon(WKMenuItemIcon.Share, title: &quot;分享&quot;, action:Selector(&quot;share&quot;)) self.addMenuItemWithItemIcon(WKMenuItemIcon.Decline, title: &quot;取消&quot;, action: Selector(&quot;cancle&quot;)) self.addMenuItemWithItemIcon(WKMenuItemIcon.Add, title: &quot;添加&quot;, action:Selector(&quot;add&quot;)) &#125; func share()&#123; print(&quot;分享&quot;) &#125; func add()&#123; print(&quot;add&quot;) &#125; func cancle()&#123; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门二——界面布局","slug":"125AppleWatch开发入门二——界面布局","date":"2015-10-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.320Z","comments":true,"path":"2015/10/14/125AppleWatch开发入门二——界面布局/","link":"","permalink":"http://huishao.cc/2015/10/14/125AppleWatch开发入门二——界面布局/","excerpt":"","text":"AppleWatch开发入门二——界面布局一、简介在iphone开发中，最基本的布局方式是通过frame，将控件的位置和大小固定在屏幕上，后来，由于手机屏幕的尺寸有了略微变化，有了autoresizing的布局框架，我们可以设置子视图随父视图的改变做一些相应的变化，再后来，iphone的尺寸与分辨率也越来越多，适配各个屏幕也成为了iOS开发者遇到的新的问题，幸运的是，autolayout机制的出现，大大减小了开发者在适配方面的成本。以上提到的两种布局方式，在以前博客中有讨论： 使用autoresizing进行动态布局：http://my.oschina.net/u/2340880/blog/423357 使用autolayout进行动态布局：http://my.oschina.net/u/2340880/blog/423500 在watch的布局方式中，我们需要抛弃iphone里的思路，重新接受一套新的布局框架。 首先，watch的屏幕不大，目前只有38mm和42mm两个尺寸，我们不可能在这个有限的空间里做非常复杂的界面效果，因此，在界面开发中，应该遵循便于使用和一目了然的原则。watch上的布局方式采用的是一种平面堆放的方式，不再有frame，也不再有约束，控件的布局方式只是一个挨着一个的平面堆放，也不可重叠。但在watch中，提供了group这样一种布局方式，可以让我们在布局中体现自由与个性的方面。 二、最基础的堆放布局我们在不使用group的时候，watch的布局采用的是最基础的堆放方式，从上到下依次排开，例如，我们添加四个label，效果如下： 通过改变label的添加顺序，可以改变其上下位置： 这种方式的布局高度并没有限制，我们可以一直往下排列，在watch上，会出现滑动的效果： 三、使用Group进行复杂的界面布局通过上面的布局方式，我们只能进行纵向的排列布局，这并不能达到我们的需求，WatchKit中提供那一套布局的模型：Group。 可以这样理解，group就是将屏幕分成了几各分区，我们可以设置各个分区的排列方式，例如水平或者垂直，通过这样的思路，完成复杂的watch界面布局，例如下面的效果： 这样效果的一个界面，就是将在屏幕中添加了三个Group，最上面的Gorup设置为水平排列模式，在其中添加了两个按钮和一个分割线，中间一个Group是垂直排列模式，放入了一个选择器和一个按钮，最下面一个Group也是水平排列模式，放入了一个按钮和一个时间栏。 扩展：所谓GroupGroup在界面布局上，不仅可以起到分区屏幕的作用，其还可以设置一些属性来使布局更加漂亮。在storyBoard右侧的设置菜单中，我们可以对这些属性进行操作： Layout：设置布局模式，分为水平布局和垂直布局两种 insert：可以设置内容区域偏移量，通过这个属性，我们可以使其中填充的控件四周留白 Spacing：其中填充的控件的间距 BackGround：设置Group的背景图案 Mode：设置背景图案的填充方式 Animate：出现时带动画 color：设置Group的背景颜色 Radius：设置Group的圆角度 四、布局中控件的位置和尺寸设置在iphone中，我们使用frame或者约束来控制控件的位置和尺寸，在watch中则简单很多，尺寸和位置都是固定的模式，我们只需要做一些设置即可。 1、控件尺寸的控制对于控件的尺寸，有三种模式，控件的width和Height都是通过这三个模式设置的： Relative to Container：自身的尺寸是按照容器的尺寸比例设置的。例如设置为0.5的话，当前控件的尺寸就是容纳其Group的一半。 Size To Fit Content:自身的尺寸与自身内容相关，例如，label中字数的多少决定了label的尺寸。 Fixed：手动设置一个固定的值。 2、控件位置的控制因为watch的界面十分简洁，对于控件的位置设置，是通过水平和垂直两个维度来设置的，通过设置每个维度的属性来控制其在容纳它的Group中的位置： Horizontal：left（左），center（中心），right（右） Vertical：top（上），center（中心），bottom（下） 一点注意:关于图片素材，你可以发现，在Extension和App文件夹中各有一个Assets.xcasssets组，只有将素材放入APP文件夹下的这个组watch才能使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门三——代码交互与控制器生命周期","slug":"126AppleWatch开发入门三——代码交互与控制器生命周期","date":"2015-10-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.320Z","comments":true,"path":"2015/10/14/126AppleWatch开发入门三——代码交互与控制器生命周期/","link":"","permalink":"http://huishao.cc/2015/10/14/126AppleWatch开发入门三——代码交互与控制器生命周期/","excerpt":"","text":"AppleWatch开发入门三——代码交互与控制器生命周期一、引言在前两篇博客中，讨论了关于watch开发中框架与界面布局相关，然而主要的逻辑，终究还是要通过代码来实现的，在我们创建了项目之后，就会生成InterfaceController这个文件，它就是我们storyBoard中的入口视图控制器。 二、代码交互与控制器声明周期storyBoard中的控件我们可以通过拖拽的方式关联到文件中，Action和Outlet两种关联方式基本可以达到我们修改控件和处理业务逻辑的需求。 WKInterfaceController类似于iOS中的ViewController，是watch中主要用于展示界面的controller，我们的控件也都是基于这个容器中显示。在模板中，系统为我们提供了三个函数，这三个函数体现了watch一个界面的声明周期，如下： 123456789101112131415 //这个函数在初始化界面时会触发，通过context可以实现界面的传值 override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) &#125; //这个函数在界面即将展现时触发 类似于iOS中的ViewWillApear override func willActivate() &#123; // This method is called when watch view controller is about to be visible to user super.willActivate() &#125; //这个函数在界面消失后触发，类似于iOS中的ViewDidDisAppear override func didDeactivate() &#123; // This method is called when watch view controller is no longer visible super.didDeactivate() &#125; 三、watch中的界面跳转与传值与iOS类似，watchOS的界面跳转也有两种方式：model和push。同样，我们也可以通过storyBoard或者代码来进行跳转。 1、通过代码跳转与传值我们创建两个InterfaceController，界面如下： 通过代码跳转，我们需要给第二个controller设置一个id标识符： 在按钮触发的方法中，如下跳转： 12345 @IBAction func `switch`(value: Bool) &#123; //这里的context是传值的上下文 //在awakeWithContext方法中会将这个值取到 pushControllerWithName(&quot;InterfaceControllerTwo&quot;, context: &quot;我是传的值&quot;) &#125; 2、在storyBoard中设置跳转关系我们也可以直接在storyBoard中设置界面的跳转，按住control，拖拽按钮到要跳转的controller，会出现push和model菜单，选择后，当我们触发按钮方法时，就会跳转： 通过这种方式进行的跳转，在执行跳转之前，会执行如下这个函数： 123override func contextForSegueWithIdentifier(segueIdentifier: String) -&gt; AnyObject? &#123; return &quot;我是值&quot; &#125; 这个设置的返回值就是context上下文传递的值。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门一——Watch的开发思路与应用框架","slug":"124AppleWatch开发入门一——Watch的开发思路与应用框架","date":"2015-10-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.320Z","comments":true,"path":"2015/10/13/124AppleWatch开发入门一——Watch的开发思路与应用框架/","link":"","permalink":"http://huishao.cc/2015/10/13/124AppleWatch开发入门一——Watch的开发思路与应用框架/","excerpt":"","text":"AppleWatch开发入门一——Watch的开发思路与应用框架一、引言Apple Watch无疑是apple在智能手表领域的一次革命，如何在Watch上开发出实用且具有美感的应用，是iOS开发者们开始思考的一个问题，由于watch的随身性和快捷性，在某些方面，它有比iphone更加大的优势，要抓住watch的这些特点，开发出淋漓尽致的应用，就需要改变一些在iphone开发的思路，正如一句话：只有忘掉经验，才会有意想不到的突破。 这一系列博客，首先是总结我在公司watch项目开发中的一些经验，其次，还会加入一些我的理解和想法，如有错误，欢迎指正，如果对你有帮助，也欢迎撒花，😄。 二、开发前我们需要准备什么如果你没有开发过iphone，直接来做watch，我建议你不要这么做，不是不可以，而是目前所有的第三方应用都必须基于iphone的扩展，原生的watch应用，苹果目前还没有开放给开发者，因此实际上，我们在watch上可以做的事情十分有限，或许后续apple会开放更多接口，但是目前，我们必须放弃iphone开发的思路，从新开始。 1、watch应用的架构如上所说，完全脱离iphone的原生watch应用，我们目前还不能开发，所有第三方的watch应用必须基于一个iphone的host app。我们可以通过创建一个watch应用来观察一下，首先，在Xcode6.3后虽然支持watch的开发，但watch模拟器并不十分好用，Xcode7进行了优化，通过模拟器，基本可以完成我们的开发。用Xcode新建一个项目，之后我们在Xcode菜单中创建一个target： 选择apple Watch中的项目： 在如下的设置中，我们先将include Notification和Include Glance都勾选上，他们也是watch应用的一种表现方式，后面我们再说： 之后可以看到，我们的项目中会多了这样的几个文件夹： 我们只需要关注下结尾为Extension和App的这两个，从目录结构我们也可以看到，App文件夹中有Storyboard这个文件，Extension文件夹中主要是一些代码文件，这也正是我们需要了解的watch app的机制，实际运行与我们手表上的是App文件夹中的界面，而逻辑的代码实际上是运行在我们的手机中的，作为iphone App的扩展而存在，通过手机与手表的交互，来达到watch上的一些操作。 由此，我们可以理解，目前的第三方watch应用，watch类似于一个UI容器，通过与iphone的交互来达到一些逻辑和效果。 2、三种watch应用方式的用途在我们创建watch的扩展时，我们勾选了两个Scene，从字面我们也可以理解的差不多，这里加上我的理解，不是官方的解释： watch app：watch应用的主体，可以通过watch上的图标进入，可以与iphone进行交互与数据共享。 Notification：watch通知，会和iphone通知同步，包括本地的和远程的，这里和iphone不同在于有长通知和短通知的分别，在实际开发中，我们可以通过在后台添加参数来区分。在storyboard中的界面如下： Glance：预览界面，没有复杂的交互能力，也不能滑动，只能在单屏展示一些数据，点击后会进入主体watchApp中： 3、在模拟器上运行一个watch app选中我们的watch App工程，在Xcode7中运行如下： 如果你是以前版本的Xcode，可能需要在模拟器的Hardware中将其调出。 运行后，我们可以在watch模拟器上使用command+H来回到watch的主界面。 三、几点watch app的开发思路1、优秀的watch app无疑必须是简单，朴素，快捷而时效的。 2、watch上不能自定义手势，我们可以使用的只有滑动，点击和长按 3、必须改变iphone布局的思想，完全接受新的watch布局特点，进行创新 4、iphone的特点是界面的绚丽，watch则是简约 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"iOS在应用中添加自定义字体","slug":"123iOS在应用中添加自定义字体","date":"2015-10-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.320Z","comments":true,"path":"2015/10/10/123iOS在应用中添加自定义字体/","link":"","permalink":"http://huishao.cc/2015/10/10/123iOS在应用中添加自定义字体/","excerpt":"","text":"iOS在应用中添加自定义字体一、在应用中添加自定义字体的步骤1、网上提供的字体库有很多，下载完成后，将其导入工程中，一般为ttf格式。 2、注意Build Phases中的Copy Bundle Resources中是否导入了文件： 3、在项目的info.plist文件中添加字体键值如下： 这个数组中可以添加多个元素，多个字体库。 4、这时实际上我们已经将字体添加进了工程中，但是在在使用这个字体时，字体的名字有时和文件名是不一样的，我们需要知道真实的字体名称，通常情况下，我们会讲所有字体名称打印出来： 12345 for (NSString * name in [UIFont familyNames]) &#123; for (NSString * fo in [UIFont fontNamesForFamilyName:name]) &#123; NSLog(@&quot;%@&quot;,fo); &#125; &#125; 5、找到我们需要的字体，如下使用即可： 1 UIFont * font = [UIFont fontWithName:@&quot;yuweij&quot; size:14]; 二、如何快速的找到新添加的字体名字如果你将所有字体都打印了出来，在其中找到新的字体名称是身份困难的，尤其是当这个字体的名称和文件名相差甚远的时候，这是一件非常痛苦的事情。 为了在以后使用自定义字体的时候不必一次一次的经历这样的痛苦，在Xcode6.3的环境下，我将所有的系统字体获取后写入了plist文件，将这个plist文件导入项目中，通过如下方法，可以只打印出新增加的字体： 12345678910111213141516171819 NSString *paths=[[NSBundle mainBundle]pathForResource:@&quot;font&quot; ofType:@&quot;plist&quot;]; //得到完整的文件名 NSDictionary * rootDic = [NSDictionary dictionaryWithContentsOfFile:paths]; //遍历当前所有字体 for (NSString * name in [UIFont familyNames]) &#123; NSArray * fontArray = [rootDic objectForKey:name]; BOOL tip = NO; for (NSString * fo in [UIFont fontNamesForFamilyName:name]) &#123; for (NSString * tmp in fontArray) &#123; if ([tmp isEqualToString:fo]) &#123; tip=YES; break; &#125; &#125; if (!tip) &#123; NSLog(@&quot;%@&quot;,fo); &#125; &#125; &#125; 如果你也需要，字体集plist文件的地址：https://github.com/ZYHshao/YHBaseFoundationTest/tree/master/YHBase/BaseSouce。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective—C语言的新魅力——Nullability、泛型集合与类型延拓","slug":"122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓","date":"2015-10-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.320Z","comments":true,"path":"2015/10/09/122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓/","link":"","permalink":"http://huishao.cc/2015/10/09/122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓/","excerpt":"","text":"Objective—C语言的新魅力一、引言在Xcode7中，iOS9的SDK已经全面兼容了Objective-C的一些新特性和新功能。这些功能都只作用于编译期，对程序的运行并没有影响，因此，它可以很好的向下进行兼容，无缝的衔接低版本的iOS系统，那么这些特性有什么样的用处呢，作为开发者，我保证你一定会爱上他们，如果你可以将这些新特性都应用于你的开发，你的开发效率和代码质量，相比之前，会有一个很大的提升。 二、Nullability检测的支持在swift语言中，通过!和?可以将对象声明成Optional，用于在开发中标记这个对象是否可以为空。在OC中，以前是没有这样的功能的，因此我们在开发中会经常遇到因为某个函数应该返回实例而返回了空导致的崩溃。Nullability的主要用武之地，就是在这里，它可以起到提示开发者做是否为空得判断的提示。 打开Xcode7，系统的框架中已经支持了Nullability，如下： 12@property (nullable, nonatomic, readonly) ObjectType firstObject;@property (nullable, nonatomic, readonly) ObjectType lastObject; 这是NSArray中的两个属性，其中nullable关键字说明了这里可能返回空的值。 如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的，越是多人合作的项目，作用也越大。 例如： 123-(void)setValue:(NSNumber * _Nonnull )number&#123; &#125; 我们在调用函数时，如果传入了空值，编译器会给我们警告： 注意： 这一特性在Xcode6.3中就已经支持，但在Xcode7中又做了一些写法上的小改动，例如，在Xcode6.3中这样写： 123-(void)setValue:( nonnull NSNumber * )number&#123; &#125; 而在Xcode7中提倡我们使用第一种写法。 与之相关的几个关键字如下： 修饰参数 nonnull：不可为空 nullable: 可以为空 null_unspecified:不确定是否可以为空(极少情况) 在属性的声明中，还会有如下一个修饰符： null_resettable:set方法可以为nil，get方法不可返回nil 一点提示： 你可以发现，iOS9的SDK中已经完全兼容使用了这些特性，并且nonnull的使用会比nullable广泛的多，因此，系统提供了这样一对宏： #define NS_ASSUME_NONNULL_BEGIN _Pragma(“clang assume_nonnull begin”) #define NS_ASSUME_NONNULL_END _Pragma(“clang assume_nonnull end”) 我们在这对宏之间定义的变量都会加上nonnull的修饰符，只有我们特殊声明nullable的才需要手动写。 三、泛型集合的支持这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。还记得，在Xcode7之前，依然是为了方便多人开发，我经常会在框架中写这样的一个空得宏： 在开发时如下使用，做到提示伙伴我这个数组中是什么东西的作用： 12345@interface ViewController ()&#123; NSArray __TYPE__FIT_TO__CLASS(NSString) * array;&#125;@end 当然，所有这些都是我自己的自导自演，编译器并不会鸟我，我在这个数组中加其他的东西，它也不会介意，所有这些只是我和我的伙伴们约定的一种一厢情愿。所以，当我看到Xcode7中的集合类型时，我着实兴奋了一下。 1、有类型约定的集合在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下： 1 NSMutableArray&lt;NSString *&gt; *array = [[NSMutableArray alloc]init]; 声明了这样一个数组后，就好比我告诉了编译器，这个数组中的数据类型都是NSString*类型的，现在非常好，如果我这个数组中元素的方法，会出现如下的提示： 激动吧，使用点语法可以访问到数组中泛型的方法了，还有更加诱人的： 在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来。 同样，如果我们向这个数组中追加类型不匹配的元素，如下： 12 NSMutableArray&lt;NSString *&gt; *array = [[NSMutableArray alloc]init]; [array addObject:@1]; 编译器会给我们一个这样的警告： 2、关于一个类型通配符观察Xcode7中iOS系统的类，我们可以发现这么一个好玩的东西：ObjectType。它既不是一个类型，也不是关键字，然而却大量存在，如下是系统的NSMutableArray的头文件： 12345678910@interface NSMutableArray&lt;ObjectType&gt; : NSArray&lt;ObjectType&gt;- (void)addObject:(ObjectType)anObject;- (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;- (void)removeLastObject;- (void)removeObjectAtIndex:(NSUInteger)index;- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;- (instancetype)init NS_DESIGNATED_INITIALIZER;- (instancetype)initWithCapacity:(NSUInteger)numItems NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;@end 这个ObjectType其实只是一个类型标识符，它具体怎么写并不重要，只是系统中都约定使用了ObjectType，你也可以在自己的类中按自己的喜好来命名，这个东西有怎样的用处，我用文字描述不清楚，我们可以通过自己来定义一个集合类来理解： 创建一个类，继承于NSObject，我取名叫MyArray： 123456//这个类型通配符只能在interfave里使用，作用域为@interface到@end之间//这里我使用Type来做这个通配符@interface MyArray&lt;Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;-(void)addObject:(nonnull Type)obj;@end 实现如下： 123456789101112131415161718- (instancetype)init&#123; self = [super init]; if (self) &#123; _array = [[NSMutableArray alloc]init]; &#125; return self;&#125;-(void)addObject:(id)obj&#123; [_array addObject:obj];&#125;-(NSString *)description&#123; NSMutableString * str = [[NSMutableString alloc]init]; for (int i=0; i&lt;_array.count; i++) &#123; [str appendString:[NSString stringWithFormat:@&quot;%@\\n&quot;,_array[i]]]; &#125; return str;&#125; 我们在使用这个自定义的集合类型时，就会有和系统一样的效果了： 3、关于多参数的泛型集合多参数的泛型集合，有一个非常好的例子，就是NSDictionary，在Xcode7中我们可以这样写字典： 可以看到，字典键值的类型编译器为我们提示了出来，结合上面类型通配符的使用，对于多参的集合，将参数类型用“,”隔开即可。 4、协变性与逆变性因为有了泛型集合的概念，相比之前，我们的类型实际上更加复杂了，比如还拿我们自定义的集合类型来举例： 12 MyArray&lt;NSString *&gt; * array; MyArray&lt;NSMutableString *&gt;*muArray; array和muArray在编译器看来已经是不同的类型，如果我们强行转换，会报如下的警告： 因此，就有了逆变和协变这个概念： __covariant :子类型指针可以向父类型指针转换 __contravariant:父类型指针可以向子类型转换 上面的情况，我们将自定义的类做如下修改，就不会出现警告： 1234@interface MyArray&lt;__covariant Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;-(void)addObject:(nonnull Type)obj;@end 四、类型延拓符的应用在开发中，开发者经常会遇到这样的情况，例如通过tag获取某些UI控件时，viewWithTag方法通常会返回给我们一个UIView类型的指针，这就需要开发者手动的强转一下，十分麻烦。新增加的__kindof修饰符可以帮助我们解除这个烦恼。我们还从自定义的那个数组类开刀，对其添加一个属性： 12345@interface MyArray&lt;__covariant Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;@property(nonnull,strong,nonatomic)NSMutableArray&lt;UIView *&gt; * viewArray;-(void)addObject:(nonnull Type)obj;@end 创建一个自定义的数组对象，并向其中添加一个UIButton，我们会看到有如下一个警告： 这也是我们开发中常遇到的问题，对吧，以前需要强转。但是以后就不需要了，我们在声明这个数组时加上一个__kindof修饰符： 1@property(nonnull,strong,nonatomic)NSMutableArray&lt;__kindof UIView *&gt; * viewArray; 警告就消失了，很cool吧。 这个修饰符就是告诉编译器，这里可以返回UIView的子类指针。 五、结语虽然这些优点在swift中早有体现，但就我个人而言，我对OC的感情会更深一些，也更加愿意接受OC的改变和成长，大家都说swift的趋势势在必行，我只想说，swift很优秀，OC亦然。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS数据持久化之一——plist文件","slug":"120iOS数据持久化之一——plist文件","date":"2015-10-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.319Z","comments":true,"path":"2015/10/08/120iOS数据持久化之一——plist文件/","link":"","permalink":"http://huishao.cc/2015/10/08/120iOS数据持久化之一——plist文件/","excerpt":"","text":"iOS数据持久化之一——plist文件iOS开发中，我们时常会将一些简单的数据进行持久化的存储，方便我们保存程序的一些配置和用户的一些数据，plist文件就是我们保存这些数据的最佳选择。 一、何为plistplist是一种文件格式，其内容规则是xml文件，后缀为.plist，因此，我们更习惯于成它问plist文件，在iOS开发中，这种文件常用来保存一些简单的配置数据，例如项目中的info.plist。 通过plist文件编辑器，我们可以很方便的查看和编辑层次清晰的plist文件。 二、通过操作plist文件进行数据持久化的几种方式1、操作系统为我们准备的用户配置文件——NSUserDefaults对于NSUserDefaults，具体用法和一些小技巧在以前的一篇博客中有详细的描述，一般的用户配置信息，我们都会选择通过这种方式来进行持久化，地址如下：[http://my.oschina.net/u/2340880/blog/411344](http://my.oschina.net/u/2340880/blog/411344)。 2、在项目包中手动创建一个plist文件，通过代码对其进行操作这种方式创建的plist文件非常自由且直观，我们可以创建多个根据功能进行分类存储，并且可以通过Xcode的可视化工具进行可视化的修改。 首先，我们新创建一个文件，在Resource中选择 Property List文件： 之后，我们通过Xcode，在其中添加一些数据： 通过代码，我们来获取这些数据： 1234 //获取myInfo文件地址 NSString * path = [[NSBundle mainBundle]pathForResource:@&quot;myInfo&quot; ofType:@&quot;plist&quot;]; NSMutableDictionary * dic =[NSMutableDictionary dictionaryWithContentsOfFile:path]; NSLog(@&quot;%@&quot;,dic); 打印结果如下： 这种方式添加的plist文件，我们只能在xcode中配置好，然后再程序中读取使用，但是不能在程序中修改这些数据，可以应用于一些固定的数据的存储，例如地图shu xing列表等。 3、在沙盒目录中创建和使用plist文件我们还可以通过代码在沙盒中创建我们自己的plist文件，进行数据的存储。同时可以支持add，delete，replace，find等操作。 123456789101112 //获取沙盒目录 NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString *plistPath1 = [paths objectAtIndex:0]; //得到完整的文件名 NSString *filename=[plistPath1 stringByAppendingPathComponent:@&quot;my.plist&quot;]; NSDictionary * dic = @&#123;@&quot;my&quot;:@&quot;haha&quot;&#125;; [dic writeToFile:filename atomically:YES]; //取数据 NSDictionary * getDic = [NSDictionary dictionaryWithContentsOfFile:filename]; NSLog(@&quot;%@&quot;,getDic); 打印如下： 这种方式无疑会更加安全，存取也更加自由。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS数据持久化之二——归档与设计可存储化的数据模型基类","slug":"121iOS数据持久化之二——归档与设计可存储化的数据模型基类","date":"2015-10-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.319Z","comments":true,"path":"2015/10/08/121iOS数据持久化之二——归档与设计可存储化的数据模型基类/","link":"","permalink":"http://huishao.cc/2015/10/08/121iOS数据持久化之二——归档与设计可存储化的数据模型基类/","excerpt":"","text":"iOS数据持久化之二——归档与设计可存储化的数据模型基类一、引言在上一篇博客中，我们介绍了用plist文件进行数据持久化的方法。虽然简单易用，但随着开发的深入，你会发现，这种方式还是有很大的局限性。试想，如果我们可以将用户的登录返回信息模型，游戏中角色的属性信息模型进行直接的持久化存取，那是不是非常爽的事，幸运的是，我们可以通过归档，来设计一个这样的数据模型。 二、先来精通归档吧归档也是iOS提供给开发者的一种数据存储的方式，事实上，几乎所有的数据类型都可以通过归档来进行存取。其存储与读取的过程，主要封装在两个类中：NSKeyedArchiver和NSKeyedUnarchiver。 1、归档的原理归档是将一种或者多种数据类型进行序列化，解归档的过程就是将序列化的数据进行反序列化的解码，这里需要注意一点，归档的核心并非是数据的持久化处理，而是数据的序列化处理，持久化的处理依然是通过文件存取来实现的。因此，被归档的数据类型都必须遵守一个相同的协议，才能在这个协议的约束下进行正确的归档与解归档，这个协议就是NSCoding协议，我们可以先来看一下NSCoding中的内容： 123456@protocol NSCoding- (void)encodeWithCoder:(NSCoder *)aCoder;- (id)initWithCoder:(NSCoder *)aDecoder;@end 这个协议非常简单，一个init的归档方法，一个encode的解归档方法，NSCoder就是归档对象。原则上说，无论是什么数据类型的对象，系统的或者是我们自定义的，都可以通过实现这个协议中的方法来支持归档操作。 2、几种归档与解归档的应用（1）通过类方法来对rootKey进行归档这种方式，我个人理解，很类似于NSUserDefaults中的standardUserDefaults，只是后者是系统为我们创建的一个默认plist文件，而rootKey是系统为我们创建的一个默认的归档键值。说起来比较复杂，举个例子就十分清晰了： 12345678910111213 NSString *homeDictionary = NSHomeDirectory();//获取根目录 NSString *homePath = [homeDictionary stringByAppendingPathComponent:@&quot;atany.archiver&quot;];//添加储存的文件名 //方式一：通过data数据归档，在将数据写入文件 NSData *data= [NSKeyedArchiver archivedDataWithRootObject:@&quot;123&quot;]; [data writeToFile:homePath atomically:YES]; //方式二：直接写入文件 [NSKeyedArchiver archiveRootObject:@&quot;456&quot; toFile:homePath]; //方式一和方式二的效果完全一样 只是解归档的时候不同 //方式一的解归档:先获取data数据，在进行data数据的解归档 NSLog(@&quot;%@&quot;,[NSKeyedUnarchiver unarchiveObjectWithData:data]); //方式二的解归档：直接解文件中的归档 NSLog(@&quot;%@&quot;,[NSKeyedUnarchiver unarchiveObjectWithFile:homePath]); 上面的示例是对字符串类型进行的归档，是对单一的数据对象进行的归档，当然，这里的对象是支持数组、字典等集合的，但集合其中的对象，也必须全部支持归档操作。 （2）通过构造新的archiver对象，对多个对象进行归档除了上面的类方法，我们还可以自己构造一个归档对象，来对多种不同的对象进行归档： 123456789101112131415161718192021 NSString *homeDictionary = NSHomeDirectory();//获取根目录 NSString *homePath = [homeDictionary stringByAppendingPathComponent:@&quot;atany.archiver&quot;];//添加储存的文件名 //这里创建一个可变的data对象作为归档的容器 NSMutableData * data = [[NSMutableData alloc]init]; //创建一个归档对象，归档后写入data数据 NSKeyedArchiver * archiver = [[NSKeyedArchiver alloc]initForWritingWithMutableData:data]; //对下面的字符串和int值进行归档序列化 [archiver encodeObject:@&quot;jaki&quot; forKey:@&quot;name&quot;]; [archiver encodeInt:24 forKey:@&quot;age&quot;]; //写入data [archiver finishEncoding]; //写入文件 [data writeToFile:homePath atomically:YES]; //创建解归档的反序列化对象 NSKeyedUnarchiver * unarchiver = [[NSKeyedUnarchiver alloc]initForReadingWithData:data]; //进行反序列化 NSString * name = [unarchiver decodeObjectForKey:@&quot;name&quot;]; int age = [unarchiver decodeIntForKey:@&quot;age&quot;]; //打印信息 NSLog(@&quot;\\nname:%@\\nage:%d&quot;,name,age); 结果如下： （3）进行自定义对象的归档上面介绍中有提到，原则上，任何遵守了NSCoding协议的类都可以进行归档操作，那么对于我们自定义的对象，我们该如何来做呢？ 首先，我们新建一个类： 仿照上面的例子，我们写一个这样的类： 1234@interface MyObject : NSObject@property(nonatomic,strong)NSString * name;@property(nonatomic,assign)int age;@end 对其进行归档： 12345678 //进行归档 MyObject * obj = [[MyObject alloc]init]; obj.name = @&quot;jaki&quot;; obj.age = 24; NSData * data = [NSKeyedArchiver archivedDataWithRootObject:obj]; //进行解档 MyObject * obj2 = [NSKeyedUnarchiver unarchiveObjectWithData:data]; NSLog(@&quot;\\nname:%@\\nage:%d&quot;,obj2.name,obj2.age); 直接运行，程序会崩溃掉，打印如下： 可以看出，正是我们前边说过的，必须遵守归档协议的对象，才可以被归档，我们在MyObject类中实现如下两个方法： 12345678910111213141516//解档方法- (instancetype)initWithCoder:(NSCoder *)coder&#123; if (self=[super init]) &#123; _name = [coder decodeObjectForKey:@&quot;name&quot;]; _age = [coder decodeIntForKey:@&quot;age&quot;]; &#125; return self;&#125;//归档方法- (void)encodeWithCoder:(NSCoder *)coder&#123; [coder encodeObject:_name forKey:@&quot;name&quot;]; [coder encodeInt:_age forKey:@&quot;age&quot;];&#125; 添加了上面两个方法，我们自定义的对象就可以自由归档存取，并可以写入本地，非常cool吧。 三、设计可以归档存取的数据模型基类1、动机与初衷通过上面对归档的介绍，我们可以发现归档一个十分有潜力的应用：可以自由存取自定义的数据对象。这个特性的优势是毫无疑问的，除了可以使我们的数据用起来更加方便，无需多次解析数据外，安全性也更好。但是也带来了一个缺陷，每个类都需要实现NSCoding中的两个方法是十分繁琐的，并且类越复杂，这个步骤越繁琐，如果在之后的修改和优化中类做了改变，相应的方法也要做改变，这将增加很大的工作量并且埋下潜在bug的风险。 所以我们会想，能否设计一个这样的model基类，来使需要存储的model都继承于它，使我们的model不需要实现NSCoding方法的同时可以支持归档呢，通过runtime和OC语言特性的一些小技巧，我们是可以做到的。 2、基类模型的设计我们新建一个BaseModel类，核心方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//归档与解归档的方法- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super init]; if (self) &#123; //获取所有属性 NSArray * porpertyArray = [self getAllPropertys]; for (NSString * name in porpertyArray) &#123; //去掉属性名前面的_ NSString * key = [name substringFromIndex:1]; //约定好的键值对 c+key [self setValue:[coder decodeObjectForKey:[NSString stringWithFormat:@&quot;c%@&quot;,key]] forKey:key]; &#125; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder&#123; //获取所有属性 NSArray * porpertyArray = [self getAllPropertys]; for (NSString * name in porpertyArray) &#123; //去掉属性名前面的_ NSString * key = [name substringFromIndex:1]; //约定好的键值对 c+key [coder encodeObject:[self valueForKey:key] forKey:[NSString stringWithFormat:@&quot;c%@&quot;,key]]; &#125;&#125;//获取model所有属性-(NSArray *)getAllPropertys&#123; NSMutableArray * array = [[NSMutableArray alloc]init]; unsigned int * count = malloc(sizeof(unsigned int)); //调用runtime的方法 //Ivar：方法返回的对象内容对象，这里将返回一个Ivar类型的指针 //class_copyIvarList方法可以捕获到类的所有变量，将变量的数量存在一个unsigned int的指针中 Ivar * mem = class_copyIvarList([self class], count); //进行遍历 for (int i=0; i&lt; *count ; i++) &#123; //通过移动指针进行遍历 Ivar var = * (mem+i); //获取变量的名称 const char * name = ivar_getName(var); NSString * str = [NSString stringWithCString:name encoding:NSUTF8StringEncoding]; [array addObject:str]; &#125; //释放内存 free(count); //注意处理野指针 count=nil; return array;&#125; 通过这样的一个runtime机制，我们可以很方便的是新建的model继承于这个基类，无需其他处理直接支持归档，修改与优化都不受影响。 四、为志同道合的朋友分享这个model集成在了我的一个开源的开发框架中，当然，那里面也综合和许多许多这样方便开发者使用的功能，如果你感兴趣，可以在[https://github.com/ZYHshao/YHBaseFoundationTest](https://github.com/ZYHshao/YHBaseFoundationTest)上面看到。如果你发现了一些bug或者可以添加或者优化的地方，请务必告知我，十分你感谢。QQ：316045346 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS9系列专题6——iOS9其他适配注意点","slug":"119iOS9系列专题6——iOS9其他适配注意点","date":"2015-10-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.319Z","comments":true,"path":"2015/10/07/119iOS9系列专题6——iOS9其他适配注意点/","link":"","permalink":"http://huishao.cc/2015/10/07/119iOS9系列专题6——iOS9其他适配注意点/","excerpt":"","text":"iOS9适配注意点一、后台定位类app适配点在iOS8中，APP的定位服务apple就做了一些修改，需要用户申请相应的权限，并在info.plist文件中添加对应的键值。具体的做法在这篇博客中有详细的讲解：[http://my.oschina.net/u/2340880/blog/414760](http://my.oschina.net/u/2340880/blog/414760)。 在iOS9系统中，定位服务的做法基本没有改变，对于前台的定位没有影响，但app中如果需要后台定位，那么还需要多做一些操作，例如： 123456789 manager = [[CLLocationManager alloc]init]; //申请后台定位权限 [manager requestAlwaysAuthorization]; manager.delegate=self; //======================================= //下面这个是iOS9中新增的方法 开启后台定位 manager.allowsBackgroundLocationUpdates = YES; //====================================== [manager startUpdatingLocation]; 通过上面简单的配置直接运行的话，程序会崩溃掉，还需要在plist文件中做一些配置，两种方式： 方式一：直接在plist文件中配置如下： 方式二：在项目中设置 打开background Models选项，勾选其中的Location updates。 二、安装不受信任的开发者应用我们知道，在Xcode7后，开发者可以不用花99dollars去购买开发者账号而可以在自己的iphone上进行测试。在安装这些应用时，iOS9系统不再向以前那样，再安装时提示一个信任的按钮，而是做如下的提示： 在设置中，选择描述文件： 之后选择开发者对应的appleId，选择信任即可： 三、BitCode的配置BitCode是app的一种中间形式，在iOS9系列专题的前几篇，有对其的简单介绍，举个例子，我们可以在提交app时提交app的bitcode形式，如此一来，apple会对我们的app进行二次优化，在用户下载时根据所需再进行编译打包。在Xocde7中，新建的项目是默认开启BitCode的，如果我们用Xcode7编译提交应用，这里有需要注意适配的地方。 如果要支持BitCode，需要保证所有的SDK都支持BitCode，如果要更新旧的SDK，只需要在Xcode7上开启BitCode重新制作一遍即可。 如果不能使所有SDK都支持BitCode，可以在项目中关闭BitCode，在building Setting中搜索BitCode，将enable设置为NO，如下： 四、URL Scheme白名单在iOS9中，apple引入了白名单这个概念，其好处是对app应用内安全进行了加强。在iOS9的适配中，如果我们用到canOpenURL这样的方法，则需要配置白名单。 首先，我们创建一个测试工程，什么都不用做，只需要添加一个URL Scheme： 在另一个工程中，我们写如下代码： 123 BOOL can= [[UIApplication sharedApplication]canOpenURL:[NSURL URLWithString:@&quot;TEST://&quot;]]; NSLog(@&quot;%d&quot;,can); [[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;TEST://&quot;]]; 在没有配置白名单之前，打印如下： 可以看到，bool值返回的是NO。虽然这样也可以跳转相应的APP，但是canOpenURL这个方法相当于失效了，我们不能用它来判断用户到底装没装这个app。 适配时，我们在plist文件中添加如下键值： 这时再次运行程序，canOpenURL的判断就会准确了。 注意：白名单添加上限为50个。 五、label默认字体不同产生的BUGiOS9的另一变化是label的默认字体产生了变化，我们打印iOS9中label的字体如下： iOS8中的label默认字体如下： 这两种字体的最大差异是字间距不同，例如如下一段代码： 12345 UILabel * label = [[UILabel alloc]init]; label.frame=CGRectMake(100, 100, 100, 30); [self.view addSubview:label]; label.backgroundColor= [UIColor redColor]; label.text=@&quot;1111111111111&quot;; 这段代码在iOS9上是刚好可以正常显示的，在iOS8上则不行，如下： iOS9： iOS8： 适配注意点： 1、可以通过动态计算来获取label的宽度，进行设置label的宽度 2、一个更简单的方法是通过设置一个确定的字体，来进行适配 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题四——APP传输安全","slug":"116iOS9系列专题四——APP传输安全","date":"2015-09-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.318Z","comments":true,"path":"2015/09/28/116iOS9系列专题四——APP传输安全/","link":"","permalink":"http://huishao.cc/2015/09/28/116iOS9系列专题四——APP传输安全/","excerpt":"","text":"APP Transport Security——加密传输方式随着ios9的推出和Xcode的升级，apple将默认开发者使用https的传输方式，相比http的传输协议，这无疑会增加一些安全性，对于开发者而言，一下子将http协议全部升级为https协议，不是一件容易的事，我们可以通过Xcode的一些配置，使其支持http的传输协议。 如果在Xcode7上运行http协议的应用，会出现如下信息： 这个信息也很清晰，需要我们在info.plist文件中配置一些参数来支持http。 首先，在项目的Info.plist中加入NSAppTransportSecurity这个键，类型为Dictionary,在字典中添加一对键值，键为Boolen类型的NSAllowsArbitraryLoads，值为YES，如下： 这时再运行项目，就可以正常取到数据了。 几点注意： 1.总有朋友说plist文件中配置了依然没有效果，一开始我很奇怪，后来发现了原因，info.plist文件有两个，一个是正式项目中的，一个是测试项目中的，一定要配置在正式项目中。 2.可能Xcode的还有些缺陷，这些键值不能通过自动补全提示出来，需要我们无误的手打。 后续：Xcode7.1中已经支持自动补全的功能。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"Xcode多版本的dmg文件下载方式","slug":"117Xcode多版本的dmg文件下载方式","date":"2015-09-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.319Z","comments":true,"path":"2015/09/28/117Xcode多版本的dmg文件下载方式/","link":"","permalink":"http://huishao.cc/2015/09/28/117Xcode多版本的dmg文件下载方式/","excerpt":"","text":"Xcode多版本的dmg文件下载方式在iOS开发中，有时我们想保有当前版本的Xcode的同时，体验新版本或者兼容旧版本，在apple官网上，是提供给我们下载地址的： 1.访问https://developer.apple.com。 2.选择Resources： 3.选择Xcode，点击download： 4.在网页下方点击additional tools，需要用appid登录： 之后会出现apple的工具列表，选择我们需要的下载即可： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"iOS9系列专题五——全新的联系人与联系人UI框架","slug":"118iOS9系列专题五——全新的联系人与联系人UI框架","date":"2015-09-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.319Z","comments":true,"path":"2015/09/28/118iOS9系列专题五——全新的联系人与联系人UI框架/","link":"","permalink":"http://huishao.cc/2015/09/28/118iOS9系列专题五——全新的联系人与联系人UI框架/","excerpt":"","text":"iOS9全新的联系人相关框架——Contacts Framework一、引言在以前iOS开发中，涉及联系人相关的编程，代码都非常繁琐，并且框架的设计也不是Objective-C风格的，这使开发者用起来非常的难受。在iOS9中，apple终于解决了这个问题，全新的Contacts Framework将完全替代AddressBookFramework，AddressBookFramework也将成为历史被弃用。至于AddressBookFramework的相关api如何繁琐，在以前的博客中有记录，地址如下： 联系人信息相关编程：http://my.oschina.net/u/2340880/blog/407347。 联系人UI界面相关编程：http://my.oschina.net/u/2340880/blog/407973。 这一新的框架是iOS9新特性中十分受欢迎的一个。apple的Objective—C体系也更加完善与强大。 二、让我们来添加一个联系人新的框架的整体思路是通过配置与请求来管理联系人，这样做有一个非常大的好处，逻辑简单，代码层次清晰。如下，通过添加一个联系人来向大家做演示： 1、联系人对象：CNContact这个对象是用来配置联系人信息的，有可变的CNMutaleContact和CNContact，区别用来读取和创建联系人。CNContact对象中有许多属性，对应联系人的一些信息。 首先，创建CNMutableContact对象： 1 CNMutableContact * contact = [[CNMutableContact alloc]init]; 设置联系人头像： 1contact.imageData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;Icon-114.png&quot;]); 设置联系人姓名： 1234 //设置名字 contact.givenName = @&quot;jaki&quot;; //设置姓氏 contact.familyName = @&quot;zhang&quot;; 设置联系人邮箱： 123 CNLabeledValue *homeEmail = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:@&quot;316045346@qq.com&quot;]; CNLabeledValue *workEmail =[CNLabeledValue labeledValueWithLabel:CNLabelWork value:@&quot;316045346@qq.com&quot;]; contact.emailAddresses = @[homeEmail,workEmail]; 这里需要注意，emailAddresses属性是一个数组，数组中是才CNLabeledValue对象，CNLabeledValue对象主要用于创建一些联系人属性的键值对应，通过这些对应，系统会帮我们进行数据的格式化，例如CNLabelHome，就会将号码格式成家庭邮箱的格式，相应的其他键如下： 123456789101112131415//家庭CONTACTS_EXTERN NSString * const CNLabelHome NS_AVAILABLE(10_11, 9_0);//工作CONTACTS_EXTERN NSString * const CNLabelWork NS_AVAILABLE(10_11, 9_0);//其他CONTACTS_EXTERN NSString * const CNLabelOther NS_AVAILABLE(10_11, 9_0);// 邮箱地址CONTACTS_EXTERN NSString * const CNLabelEmailiCloud NS_AVAILABLE(10_11, 9_0);// url地址CONTACTS_EXTERN NSString * const CNLabelURLAddressHomePage NS_AVAILABLE(10_11, 9_0);// 日期CONTACTS_EXTERN NSString * const CNLabelDateAnniversary NS_AVAILABLE(10_11, 9_0); 设置联系人电话： 1contact.phoneNumbers = @[[CNLabeledValue labeledValueWithLabel:CNLabelPhoneNumberiPhone value:[CNPhoneNumber phoneNumberWithStringValue:@&quot;12344312321&quot;]]]; 联系人电话的配置方式和邮箱类似，键值如下： 1234567CONTACTS_EXTERN NSString * const CNLabelPhoneNumberiPhone NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberMobile NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberMain NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberHomeFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberWorkFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberOtherFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberPager NS_AVAILABLE(10_11, 9_0); 这里的CNPhoneNumber对象也是iOS9中的一个新的类，专门用来创建电话号码，之中方法如下： 12345678910@interface CNPhoneNumber : NSObject &lt;NSCopying, NSSecureCoding&gt;//通过类方法创建+ (instancetype)phoneNumberWithStringValue:(NSString *)stringValue;//通过初始化方法创建- (instancetype)initWithStringValue:(NSString *)string;@property (readonly, copy, NS_NONATOMIC_IOSONLY) NSString *stringValue;@end 设置联系人地址： 123456 CNMutablePostalAddress * homeAdress = [[CNMutablePostalAddress alloc]init]; homeAdress.street = @&quot;贝克街&quot;; homeAdress.city = @&quot;伦敦&quot;; homeAdress.state = @&quot;英国&quot;; homeAdress.postalCode = @&quot;221B&quot;; contact.postalAddresses = @[[CNLabeledValue labeledValueWithLabel:CNLabelHome value:homeAdress]]; 设置生日： 12345NSDateComponents * birthday = [[NSDateComponents alloc]init]; birthday.day=7; birthday.month=5; birthday.year=1992; contact.birthday=birthday; 2、创建添加联系人请求：CNSaveRequestCNSaveRequest是用于存储联系人的请求类，通过这个类，我们可以创建批量添加、修改或者删除联系人的请求，例如添加上面我们创建的联系人对象： 1234 //初始化方法 CNSaveRequest * saveRequest = [[CNSaveRequest alloc]init]; //添加联系人 [saveRequest addContact:contact toContainerWithIdentifier:nil]; 这个类中还有许多方便我们操作的方法： 123456789101112131415161718192021222324@interface CNSaveRequest : NSObject//添加一个联系人- (void)addContact:(CNMutableContact *)contact toContainerWithIdentifier:(nullable NSString *)identifier;//更新一个联系人- (void)updateContact:(CNMutableContact *)contact;//删除一个联系人- (void)deleteContact:(CNMutableContact *)contact;//添加一组联系人- (void)addGroup:(CNMutableGroup *)group toContainerWithIdentifier:(nullable NSString *)identifier;//更新一组联系人- (void)updateGroup:(CNMutableGroup *)group;//删除一组联系人- (void)deleteGroup:(CNMutableGroup *)group;//向组中添加子组- (void)addSubgroup:(CNGroup *)subgroup toGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA);//在组中删除子组- (void)removeSubgroup:(CNGroup *)subgroup fromGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA);//向组中添加成员- (void)addMember:(CNContact *)contact toGroup:(CNGroup *)group;//向组中移除成员- (void)removeMember:(CNContact *)contact fromGroup:(CNGroup *)group;@end 3、进行联系人的写入操作:CNContactStoreCNContactStore是一个用于存取联系人的上下文桥梁，现在，把我们创建的添加联系人的请求写入： 12 CNContactStore * store = [[CNContactStore alloc]init]; [store executeSaveRequest:saveRequest error:nil]; 在模拟器上运行程序，打开联系人，效果如下： 联系人界面： 联系人详情： 三、获取格式化的联系人信息iOS9中，ContactFramework也为开发者提供了非常方便的格式化信息的方法，还拿我们上面创建的联系人对象举例： 1、获取格式化的联系人姓名12 NSString * foematter =[CNContactFormatter stringFromContact:contact style:CNContactFormatterStyleFullName]; NSLog(@&quot;%@&quot;,foematter); 这个运行后会打印出jaki zhang，其中style风格枚举如下： 1234567typedef NS_ENUM(NSInteger, CNContactFormatterStyle)&#123; //获取全名 CNContactFormatterStyleFullName, //获取拼音全名 CNContactFormatterStylePhoneticFullName,&#125; NS_ENUM_AVAILABLE(10_11, 9_0); 2、获取格式化的联系人地址12 NSString * foematter =[CNPostalAddressFormatter stringFromPostalAddress:homeAdress style:CNPostalAddressFormatterStyleMailingAddress]; NSLog(@&quot;%@&quot;,foematter); 打印如下： 四、提取联系人在开发中，提取联系人的使用率要远远高于创建联系人，ContactFramework提取联系人的方式，类似于数据库的检索方式，通过配置条件，提取出我们需要的数据，例如： 12345 CNContactStore * stroe = [[CNContactStore alloc]init]; //检索条件，检索所有名字中有zhang的联系人 NSPredicate * predicate = [CNContact predicateForContactsMatchingName:@&quot;zhang&quot;]; //提取数据 NSArray * contacts = [stroe unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey] error:nil]; keysToFetch是设置提取联系人的哪些数据，如上则只提取出检索联系人的名字。 同样，也可以通过请求的方式来对联系人进行遍历： 12345 CNContactStore * stroe = [[CNContactStore alloc]init]; CNContactFetchRequest * request = [[CNContactFetchRequest alloc]initWithKeysToFetch:@[CNContactPhoneticFamilyNameKey]]; [stroe enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSLog(@&quot;%@&quot;,contact); &#125;]; 五、ContactFramework UI相关iOS9中，系统也为我们封装好了一套联系人的UI界面，用起来也十分方便，主要新增的controller有两个： CNContactPickerViewController：展示联系人列表的controller CNContactViewController：展示联系人详细信息的controller 示例如下： 弹出联系人列表： 12 CNContactPickerViewController * con = [[CNContactPickerViewController alloc]init]; [self presentViewController:con animated:YES completion:nil]; 效果如下： 联系人逻辑的相关处理主要在CNContactPickerDelegate中完成： 1234567//视图取消时 调用的方法- (void)contactPickerDidCancel:(CNContactPickerViewController *)picker;//选中与取消选中时调用的方法- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContact:(CNContact *)contact;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContactProperty:(CNContactProperty *)contactProperty;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContacts:(NSArray&lt;CNContact*&gt; *)contacts;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContactProperties:(NSArray&lt;CNContactProperty*&gt; *)contactProperties; CNContactViewController则是用来显示具体联系人的详细信息的，比如： 12 CNContactViewController * con = [CNContactViewController viewControllerForContact:contact]; [self presentViewController:con animated:YES completion:nil]; 相关代理回调函数如下： 123//将要展示联系人信息与已经展示联系人信息的回调- (BOOL)contactViewController:(CNContactViewController *)viewController shouldPerformDefaultActionForContactProperty:(CNContactProperty *)property;- (void)contactViewController:(CNContactViewController *)viewController didCompleteWithContact:(nullable CNContact *)contact; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题三——应用瘦身","slug":"115iOS9系列专题三——应用瘦身","date":"2015-09-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.318Z","comments":true,"path":"2015/09/27/115iOS9系列专题三——应用瘦身/","link":"","permalink":"http://huishao.cc/2015/09/27/115iOS9系列专题三——应用瘦身/","excerpt":"","text":"更小，更快——iOS9的App Thinningapple在iOS9中引入了一套新的app瘦身方案，通过一些优化策略，将尽可能的减小app安装包的体积。这部分的大多工作是由app store来完成，开发者并不需要付出太多额外的开销。这篇博客将这部分内容做了简单的介绍，详细信息在[App Thinning](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)。 App的瘦身策略主要包括三部分： 一、slicing这部分的主要原理是不同的设备下载安装不同的app包，各个app包副本中包含相应尺寸的素材。在xcode中，使用asset catalog管理素材文件，在我们提交应用市场后，会自动帮我们生成各个尺寸包得app副本。 二、BitCode字节码文件是app程序的一种中间形式，苹果会对包含字节码的app进行二次的优化，来进行相应的瘦身。 三、On-Demand Resources这是一种多级应用的设计思路，例如一个游戏，开发者可以将其分为一个大小各异的资源包，用户只需下载一个小的引导程序，在程序内加载相应资源包。这样，可以大大加快应用的安装速度。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题二——全新的搜索功能api","slug":"114iOS9系列专题二——全新的搜索功能api","date":"2015-09-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.318Z","comments":true,"path":"2015/09/27/114iOS9系列专题二——全新的搜索功能api/","link":"","permalink":"http://huishao.cc/2015/09/27/114iOS9系列专题二——全新的搜索功能api/","excerpt":"","text":"更加智能的搜索方案——iOS9搜索功能新api一、引言iOS9中为我们提供了许多新的api，搜索功能的加强无疑是其中比较显眼的一个。首先，我们先设想一下：如果在你的app中定义一种标识符，在siri和搜索中，可以用过这个标识符搜索到你的app，是不是很棒？不，这还差得远，你可以定义任意的数据，使其在搜索和siri中可以快速检索到，这样的搜索功能是不是非常酷？不，还有更cool的，你甚至可以在你的网站中添加一些标志，使apple的爬虫可以检索到，那样，即使用户没有安装你的app，也可以在搜索中获取到相应的信息，这太强大了，对吧。 二、3种全新的搜索模式‍1、NSUserActivity‍我们可以在项目中使用相应的函数来添加一些用户的活跃元素，使我们可以在搜索中通过搜索这样的活跃元素展现我们的app。例如： 12345678910 //创建一个对象，这里的type用于区分搜索的类型 NSUserActivity *userActivity = [[NSUserActivity alloc] initWithActivityType: @&quot;myapp&quot;]; //显示的标题 userActivity.title = @&quot;我的app&quot;; // 搜索的关键字 userActivity.keywords = [NSSet setWithArray: @[@&quot;sea&quot;,@&quot;rch&quot;]]; // 支持Search userActivity.eligibleForSearch = YES; //提交设置 [userActivity becomeCurrent]; 在下面的函数中，我们可以处理用户点击搜索后的回调： 123456789101112- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:&#123; NSString *activityType = userActivity.activityType; if ([activityType isEqual: @&quot;myapp&quot;])&#123; // Handle restoration for values provided in userInfo // do something return YES; &#125; return NO; //处理回调&#125; TIP：这种方式添加的关键字搜索，必须创建全局变量，否则无法进行搜索: 2、CoreSpotlightCoreSpotlight是一种更加自由的搜索方式，可以通过添加类似item的模型，将app中的数据展示在搜索栏中，CoreSpotlight框架类似提供了一些增、删、改、查的操作，可是使我们自由的进行搜索属性的设置。 （1）认识3个类在iOS9中，新增加了3个类，通过对这三个类的操作与配合，我们可以轻易的在app中添加CoreSpotlight搜索的功能。 CSSearchableItemAttributeSet：设置类，这个类用于设置搜索标签里的icon，内容，图片等。主要用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//这个类的核心方法只有一个init方法，通过一个类型字符串进行创建，字符串用于在回调中区分@interface CSSearchableItemAttributeSet : NSObject &lt;NSCopying,NSSecureCoding&gt;- (instancetype)initWithItemContentType:(nonnull NSString *)itemContentType;@end//更多的属性设置在其扩展类中，例如：@interface CSSearchableItemAttributeSet (CSGeneral)//展示的名称@property(nullable, copy) NSString *displayName;//名称数组@property(nullable, copy) NSArray&lt;NSString*&gt; *alternateNames;//完整的路径@property(nullable, copy) NSString *path;//链接url@property(nullable, strong) NSURL *contentURL;//图片链接的url@property(nullable, strong) NSURL *thumbnailURL;//设置图片数据@property(nullable, copy) NSData *thumbnailData;//设置一个标识符@property(nullable, copy) NSString *relatedUniqueIdentifier;@property(nullable, strong) NSDate *metadataModificationDate;//内容类型@property(nullable, copy) NSString *contentType;@property(nullable, copy) NSArray&lt;NSString*&gt; *contentTypeTree;//搜索的关键字数组@property(nullable, copy) NSArray&lt;NSString*&gt; *keywords;//标题信息@property(nullable, copy) NSString *title;@end CSSearchableItem：搜索标签类，通过这个类，来创建响应的搜索标签。主要内容如下： 12345678910111213141516//这个类主要用于创建搜索的标签@interface CSSearchableItem : NSObject &lt;NSSecureCoding, NSCopying&gt;//init方法- (instancetype)initWithUniqueIdentifier:(nullable NSString *)uniqueIdentifier //Can be null, one will be generated domainIdentifier:(nullable NSString *)domainIdentifier attributeSet:(CSSearchableItemAttributeSet *)attributeSet;//相应 的属性@property (copy) NSString *uniqueIdentifier;@property (copy, nullable) NSString *domainIdentifier;@property (copy, null_resettable) NSDate * expirationDate;@property (strong) CSSearchableItemAttributeSet *attributeSet;@end CSSearchableIndex：这个类，我个人理解，类似一个manager的作用，通过它对标签进行增、删、改、查等操作： 123456789101112131415161718192021222324@interface CSSearchableIndex : NSObject@property (weak,nullable) id&lt;CSSearchableIndexDelegate&gt; indexDelegate;//判断设备是否支持+ (BOOL)isIndexingAvailable;//取系统的searchIndex管理者+ (instancetype)defaultSearchableIndex;//一般情况下，我们不需要重新创建对象- (instancetype)initWithName:(NSString *)name;- (instancetype)initWithName:(NSString *)name protectionClass:(nullable NSString *)protectionClass;//设置索引标签- (void)indexSearchableItems:(NSArray&lt;CSSearchableItem *&gt; *)items completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//删除指定id索引标签- (void)deleteSearchableItemsWithIdentifiers:(NSArray&lt;NSString *&gt; *)identifiers completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;- (void)deleteSearchableItemsWithDomainIdentifiers:(NSArray&lt;NSString *&gt; *)domainIdentifiers completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//删除所有索引标签- (void)deleteAllSearchableItemsWithCompletionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;@end （2）一个小例子下面，我们通过一个小例子来应用下CoreSpotlight的搜索功能。 首先，需要在项目中导入如下库： 实现如下代码： 12345678910 //进行标签设置 CSSearchableItemAttributeSet * itemSet = [[CSSearchableItemAttributeSet alloc]initWithItemContentType:@&quot;myApp&quot;]; itemSet.title = @&quot;我的APP&quot;; itemSet.keywords = @[@&quot;haha&quot;,@&quot;123&quot;]; itemSet.contentDescription = @&quot;这是搜索到得内容&quot;; itemSet.thumbnailData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;Icon-114.png&quot;]); CSSearchableItem * item = [[CSSearchableItem alloc]initWithUniqueIdentifier:@&quot;1&quot; domainIdentifier:@&quot;1&quot; attributeSet:itemSet]; [[CSSearchableIndex defaultSearchableIndex]indexSearchableItems:@[item] completionHandler:nil]; 我们在搜索中输入haha或者123效果如下： CoreSpotlight的搜索回调和NSUserActivaty一样，只是区分id的方式有所不同： 1234567891011- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:&#123; NSString *activityType = userActivity.activityType; //先取CSSearchableItemActionType if ([activityType isEqual: CSSearchableItemActionType]) &#123; NSString *uniqueIdentifier = [userActivity.userInfo objectForKey:CSSearchableItemActivityIdentifier]; // do something return YES; &#125; return NO;&#125; 3、Web Markup这个功能与我们app开发关系不大，但是对我app的推广却至关重要，这项技术可以让我们的app关联一个网站，apple通过爬虫来获取我们规定的一些标签值，无论用户是否安装了app，在搜索时，都可以展示出相关信息，因为这项功能主要关联前端技术，需要了解的可以参看：[App Search Programming Guide](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8)。 三、结语在我参考的许多相关文章中，都一致建议，iOS9的搜索功能固然强大，然而滥用会造成垃圾信息的泛滥，这样的结果一定会适得其反，作为开发者，我们需要将最合适，最简洁的信息推送到用户的面前。另外，文章有疏漏和错误之处，欢迎指正。 欢迎转载 请注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题一——3D Touch","slug":"113iOS9系列专题一——3D Touch","date":"2015-09-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.318Z","comments":true,"path":"2015/09/26/113iOS9系列专题一——3D Touch/","link":"","permalink":"http://huishao.cc/2015/09/26/113iOS9系列专题一——3D Touch/","excerpt":"","text":"新的触摸体验——iOS9的3D Touch一、引言在iphone6s问世之后，很多果粉都争先要体验3D Touch给用户带来的额外维度上的交互，这个设计之所以叫做3D Touch，其原理上是增加了一个压力的感触，通过区分轻按和重按来进行不同的用户交互。 二、在模拟器上学习和测试3D Touch3D Touch是一个很新颖的设计，可是苹果文档有言： With Xcode 7.0 you must develop on a device that supports 3D Touch. Simulator in Xcode 7.0 does not support 3D Touch. 看到这句话心是不是凉了一半，是的，xcode7是支持3D Touch开发的，可是模拟器并不支持这个手势，我们只能在真机上进行学习与测试，但是在IT的世界，从来都不缺拯救世界的人物，github上有人为我们提供了这样的一个插件，可以让我们在模拟器上进行3D Touch的效果测试： git地址：https://github.com/DeskConnect/SBShortcutMenuSimulator。 附.SBShortcutMenuSimulator的安装和使用其实安装和使用并不需要怎么介绍，git主页里介绍的很清楚，这里在记录一遍，其中只有一点需要注意，如果你像我一样，电脑中装有Xcode6和Xcode7两个版本，那个Xcode的编译路径，需要做一下修改。 安装： 在终端中一次运行如下指令： 123git clone https://github.com/DeskConnect/SBShortcutMenuSimulator.gitcd SBShortcutMenuSimulatormake 如果电脑中有多个Xcode版本，先做如下操作，如果只有Xcode7，则可以跳过 1sudo xcode-select -switch /Applications/Xcode2.app/Contents/Developer/ 注意：上面命令中，Xcode2.app是你电脑中Xcode的名字，这里如要特别注意，如果名字中有空格，需要修改一下，把空格去掉，否则会影响命令的执行。 之后在SBShortcutMenuSimulator的目录中执行如下操作： 12xcrun simctl spawn booted launchctl debug system/com.apple.SpringBoard --environment DYLD_INSERT_LIBRARIES=$PWD/SBShortcutMenuSimulator.dylibxcrun simctl spawn booted launchctl stop com.apple.SpringBoard 如果没有报错，我们可以通过向指定端口发送消息的方法来在模拟器上模拟3D Touch的效果： 1echo &apos;com.apple.mobilecal&apos; | nc 127.0.0.1 8000 其中，com.apple.mobilecal是应用的Bundle ID ，如果要测试我们的应用，将其改为我们应用的BundleID即可，上面的示例应用是系统日历，可以看到模拟器的效果如下： 三、3D Touch的主要应用文档给出的应用介绍主要有两块： 1.A user can now press your Home screen icon to immediately access functionality provided by your app. 2.Within your app, a user can now press views to see previews of additional content and gain accelerated access to features. 第一部分的应用是我们可以通过3D手势，在主屏幕上的应用Icon处，直接进入应用的响应功能模块。这个功能就例如我们上面的日历示例，会在Icon旁边出现一个菜单，点击菜单我们可以进入相应的功能单元。 我个人理解，这个功能，push消息功能加上iOS8推出的扩展today功能，这三个机制使iOS应用变得无比灵活方便，用户可以不需付出寻找的时间成本来快速使用自己需要的功能。 第二部分是对app的一个优化，用户可以通过3D Touch手势在view上来预览一些预加载信息，这样的设计可以使app更加简洁大方，交互性也更强。 四、3D Touch的三大模块在我们的app中使用3D Touch功能，主要分为以下三个模块： 1、Home Screen Quick Actions通过主屏幕的应用Icon，我们可以用3D Touch呼出一个菜单，进行快速定位应用功能模块相关功能的开发。如上面的日历。 2、peek and pop这个功能是一套全新的用户交互机制，在使用3D Touch时，ViewController中会有如下三个交互阶段： （1）提示用户这里有3D Touch的交互，会使交互控件周围模糊 （2）继续深按，会出现预览视图 （3）通过视图上的交互控件进行进一步交互 这个模块的设计可以在网址连接上进行网页的预览交互。 3.Force PropertiesiOS9为我们提供了一个新的交互参数:力度。我们可以检测某一交互的力度值，来做相应的交互处理。例如，我们可以通过力度来控制快进的快慢，音量增加的快慢等。 五、Home Screen Quick Action使用与相关api详解iOS9为我们提供了两种屏幕标签，分别是静态标签和动态标签。 1、静态标签静态标签是我们在项目的配置plist文件中配置的标签，在用户安装程序后就可以使用，并且排序会在动态标签的前面。 我们先来看静态标签的配置： 首先，在info.plist文件中添加如下键值（我在测试的时候，系统并没有提示，只能手打上去）： 先添加了一个UIApplicationShortcutItems的数组，这个数组中添加的元素就是对应的静态标签，在每个标签中我们需要添加一些设置的键值： 必填项（下面两个键值是必须设置的）： UIApplicationShortcutItemType 这个键值设置一个快捷通道类型的字符串 UIApplicationShortcutItemTitle 这个键值设置标签的标题 选填项（下面这些键值不是必须设置的）： UIApplicationShortcutItemSubtitle 设置标签的副标题 UIApplicationShortcutItemIconType 设置标签Icon类型 UIApplicationShortcutItemIconFile 设置标签的Icon文件 UIApplicationShortcutItemUserInfo 设置信息字典(用于传值) 我们如上截图设置后，运行程序，用我们前面的方法进行测试，效果如下： 2、动态标签动态标签是我们在程序中，通过代码添加的，与之相关的类，主要有三个： UIApplicationShortcutItem 创建3DTouch标签的类 UIMutableApplicationShortcutItem 创建可变的3DTouch标签的类 UIApplicationShortcutIcon 创建标签中图片Icon的类 因为这些类是iOS9中新增加的类，所以其api的复杂程度并不大，下面我们来对其中方法与属性进行简要讲解： 12345678910@interface UIApplicationShortcutItem : NSObject &lt;NSCopying, NSMutableCopying&gt;//下面是两个初始化方法 通过设置type，title等属性来创建一个标签，这里的icon是UIApplicationShortcutIcon对象，我们后面再说- (instancetype)initWithType:(NSString *)type localizedTitle:(NSString *)localizedTitle localizedSubtitle:(nullable NSString *)localizedSubtitle icon:(nullable UIApplicationShortcutIcon *)icon userInfo:(nullable NSDictionary *)userInfo NS_DESIGNATED_INITIALIZER;- (instancetype)initWithType:(NSString *)type localizedTitle:(NSString *)localizedTitle;//下面这是一些只读的属性，获取相应的属性值@property (nonatomic, copy, readonly) NSString *type;@property (nonatomic, copy, readonly) NSString *localizedTitle;@property (nullable, nonatomic, copy, readonly) NSString *localizedSubtitle;@property (nullable, nonatomic, copy, readonly) UIApplicationShortcutIcon *icon;@property (nullable, nonatomic, copy, readonly) NSDictionary&lt;NSString *, id &lt;NSSecureCoding&gt;&gt; *userInfo; 123456789//这个类继承于 UIApplicationShortcutItem，创建的标签可变@interface UIMutableApplicationShortcutItem : UIApplicationShortcutItem@property (nonatomic, copy) NSString *type;@property (nonatomic, copy) NSString *localizedTitle;@property (nullable, nonatomic, copy) NSString *localizedSubtitle;@property (nullable, nonatomic, copy) UIApplicationShortcutIcon *icon;@property (nullable, nonatomic, copy) NSDictionary&lt;NSString *, id &lt;NSSecureCoding&gt;&gt; *userInfo;@end 1234567//这个类创建标签中的icon@interface UIApplicationShortcutIcon : NSObject &lt;NSCopying&gt;//创建系统风格的icon+ (instancetype)iconWithType:(UIApplicationShortcutIconType)type;//创建自定义的图片icon+ (instancetype)iconWithTemplateImageName:(NSString *)templateImageName;@end 创建好标签后，将其添加如application的hortcutItems数组中即可，示例如下： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建 UIApplicationShortcutItem * item = [[UIApplicationShortcutItem alloc]initWithType:@&quot;two&quot; localizedTitle:@&quot;第二个标签&quot; localizedSubtitle:@&quot;看我哦&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypePlay] userInfo:nil]; 添加 [UIApplication sharedApplication].shortcutItems = @[item];&#125; 效果如下： 这里，将系统风格icon的枚举列举如下： 123456789typedef NS_ENUM(NSInteger, UIApplicationShortcutIconType) &#123; UIApplicationShortcutIconTypeCompose,//编辑的图标 UIApplicationShortcutIconTypePlay,//播放图标 UIApplicationShortcutIconTypePause,//暂停图标 UIApplicationShortcutIconTypeAdd,//添加图标 UIApplicationShortcutIconTypeLocation,//定位图标 UIApplicationShortcutIconTypeSearch,//搜索图标 UIApplicationShortcutIconTypeShare//分享图标&#125; NS_ENUM_AVAILABLE_IOS(9_0); 3、响应标签的行为类似推送，当我们点击标签进入应用程序时，也可以进行一些操作，我们可以看到，在applocation中增加了这样一个方法： - (void)application:(UIApplication )application performActionForShortcutItem:(UIApplicationShortcutItem )shortcutItem completionHandler:(void(^)(BOOL succeeded))completionHandler NS_AVAILABLE_IOS(9_0); 当我们通过标签进入app时，就会在appdelegate中调用这样一个回调，我们可以获取shortcutItem的信息进行相关逻辑操作。 这里有一点需要注意：我们在app的入口函数： - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions; 也需要进行一下判断，在launchOptions中有UIApplicationLaunchOptionsShortcutItemKey这样一个键，通过它，我们可以区别是否是从标签进入的app，如果是则处理结束逻辑后，返回NO，防止处理逻辑被反复回调。 几点注意： 1、快捷标签最多可以创建四个，包括静态的和动态的。 2、每个标签的题目和icon最多两行，多出的会用…省略 六、结语关于3DTouch在UIView中的预览功能和UITouch中新增加的力度属性的应用，因为不好演示，这里就不再总结，大家可以通过头文件中相应的类和属性来了解他们，最后，如有疏漏和错误之处，欢迎指正。 欢迎转载 请注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS中UISearchBar(搜索框)使用总结","slug":"112iOS中UISearchBar(搜索框)使用总结","date":"2015-09-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.318Z","comments":true,"path":"2015/09/22/112iOS中UISearchBar(搜索框)使用总结/","link":"","permalink":"http://huishao.cc/2015/09/22/112iOS中UISearchBar(搜索框)使用总结/","excerpt":"","text":"iOS中UISearchBar(搜索框)使用总结初始化：UISearchBar继承于UIView，我们可以像创建View那样创建searchBar 12 UISearchBar * bar = [[UISearchBar alloc]initWithFrame:CGRectMake(20, 100, 250, 40)]; [self.view addSubview:bar]; @property(nonatomic) UIBarStyle barStyle; 这个属性可以设置searchBar的搜索框的风格，枚举如下： 1234567typedef NS_ENUM(NSInteger, UIBarStyle) &#123; UIBarStyleDefault = 0,//默认风格 白色搜索框，多出的背景为灰色 UIBarStyleBlack = 1,//黑色风格，黑色的搜索框 //下面两个枚举已经被禁用，作用和黑色风格一样 UIBarStyleBlackOpaque = 1, // Deprecated. Use UIBarStyleBlack UIBarStyleBlackTranslucent = 2, // Deprecated. Use UIBarStyleBlack and set the translucent property to YES&#125;; @property(nonatomic,copy) NSString *text; 设置搜索框中的文字 @property(nonatomic,copy) NSString *prompt; 这个属性的官方解释是在搜索框顶部显示一行文字，其实就是背景文字，上图说明： 12 bar.prompt = @&quot;搜索框&quot;; bar.text=@&quot;321111111111111111111111111&quot; 效果如下： @property(nonatomic,copy) NSString *placeholder; 和其他文本输入控件的placeholder相同，在输入文字时就会消失 @property(nonatomic) BOOL showsBookmarkButton; 是否在搜索框右侧显示一个图书的按钮，默认为NO，YES的效果如下： @property(nonatomic) BOOL showsCancelButton; 是否显示取消按钮，默认为NO，YES的效果如下： @property(nonatomic) BOOL showsSearchResultsButton; 是否显示搜索结果按钮，默认为NO，YES效果如下： @property(nonatomic, getter=isSearchResultsButtonSelected) BOOL searchResultsButtonSelected ; 设置搜索结果按钮的选中状态 - (void)setShowsCancelButton:(BOOL)showsCancelButton animated:(BOOL)animated; 设置显示取消按钮 @property(nonatomic,retain) UIColor *tintColor; 设置这个颜色值会影响搜索框中的光标的颜色 @property(nonatomic,retain) UIColor *barTintColor; 设置这个颜色会影响搜索框的背景颜色 @property (nonatomic) UISearchBarStyle searchBarStyle; 设置搜索框整体的风格，枚举如下： 12345typedef NS_ENUM(NSUInteger, UISearchBarStyle) &#123; UISearchBarStyleDefault, // currently UISearchBarStyleProminent UISearchBarStyleProminent, // 显示背景 UISearchBarStyleMinimal // 不显示背景&#125; NS_ENUM_AVAILABLE_IOS(7_0); @property(nonatomic,assign,getter=isTranslucent) BOOL translucent; 设置是否半透明 @property(nonatomic) BOOL showsScopeBar ; 是否显示搜索栏的附件选择按钮试图，要想显示这个试图，首先要将这个属性设置为YES，之后给按钮数组中添加按钮，使用下面这个属性： @property(nonatomic,copy) NSArray *scopeButtonTitles ； 设置选择按钮试图的按钮标题 @property(nonatomic) NSInteger selectedScopeButtonIndex; 设置一个默认的选中按钮 123 bar = [[UISearchBar alloc]initWithFrame:CGRectMake(20, 100, 250, 200)]; bar.showsScopeBar=YES; bar.scopeButtonTitles = @[@&quot;12&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;]; @property (nonatomic, readwrite, retain) UIView *inputAccessoryView; 键盘的附属试图 @property(nonatomic,retain) UIImage *backgroundImage; 设置搜索框的背景图案 @property(nonatomic,retain) UIImage *scopeBarBackgroundImage; 设置附属选择按钮视图的背景图案 - (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics ; - (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics 这一对方法可以设置和获取某个状态枚举下的搜索框的背景图案 - (void)setSearchFieldBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; - (UIImage *)searchFieldBackgroundImageForState:(UIControlState)state; 这一对方法用于设置和获取搜索框中TextField的背景图案 - (void)setImage:(UIImage *)iconImage forSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state ; - (UIImage *)imageForSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state ; 这一对方法用于获取和设置搜索栏icon图片的图案 - (void)setScopeBarButtonBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; - (UIImage *)scopeBarButtonBackgroundImageForState:(UIControlState)state; 这一对方法用于设置和获取搜索框的附加选择按钮视图的背景图案 - (void)setScopeBarButtonDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; - (UIImage *)scopeBarButtonDividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; 这一对方法用于获取和设置附加选择按钮视图中切换按钮的图案 - (void)setScopeBarButtonTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state; - (NSDictionary *)scopeBarButtonTitleTextAttributesForState:(UIControlState)state; 这一对方法用于设置和获取切换按钮标题文字的字体属性字典 @property(nonatomic) UIOffset searchFieldBackgroundPositionAdjustment; 搜索文字在搜索框中的位置偏移 @property(nonatomic) UIOffset searchTextPositionAdjustment; textfield在搜索框中的位置偏移 - (void)setPositionAdjustment:(UIOffset)adjustment forSearchBarIcon:(UISearchBarIcon)icon; - (UIOffset)positionAdjustmentForSearchBarIcon:(UISearchBarIcon)icon; 设置搜索栏中图片的位置偏移，图片的枚举如下： 123456typedef NS_ENUM(NSInteger, UISearchBarIcon) &#123; UISearchBarIconSearch, //搜索图标 UISearchBarIconClear, // 清除图标 UISearchBarIconBookmark, // 书本图标 UISearchBarIconResultsList, // 结果列表图标&#125;; 下面是搜索框控件的一些代理方法： - (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar; 将要开始编辑时的回调，返回为NO，则不能编辑 - (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar; 已经开始编辑时的回调 - (BOOL)searchBarShouldEndEditing:(UISearchBar *)searchBar; 将要结束编辑时的回调 - (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar; 已经结束编辑的回调 - (void)searchBar:(UISearchBar )searchBar textDidChange:(NSString )searchText; 编辑文字改变的回调 - (BOOL)searchBar:(UISearchBar )searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString )text ; 编辑文字改变前的回调，返回NO则不能加入新的编辑文字 - (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar; 搜索按钮点击的回调 - (void)searchBarBookmarkButtonClicked:(UISearchBar *)searchBar; 书本按钮点击的回调 - (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar; 取消按钮点击的回调 - (void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar; 搜索结果按钮点击的回调 - (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope; 搜索栏的附加试图中切换按钮触发的回调 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"mac端的优秀抓包工具——Charles使用","slug":"111mac端的优秀抓包工具——Charles使用","date":"2015-09-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.318Z","comments":true,"path":"2015/09/20/111mac端的优秀抓包工具——Charles使用/","link":"","permalink":"http://huishao.cc/2015/09/20/111mac端的优秀抓包工具——Charles使用/","excerpt":"","text":"mac端的优秀抓包工具——Charles使用一、简介Charles是mac端的一款截取与分析网络请求的工具，在网络开发中使用其作分析，可以大大提高我们的开发效率。Charles是收费软件，一般可以试用三十天，但是可以通过相应的破解来获取服务（这里只做演示使用，希望大家购买正版软件）。Charles软件和破解包下载地址：[http://pan.baidu.com/s/1ySsUy](http://pan.baidu.com/s/1ySsUy)。 二、安装与使用下载好压缩包后，解压打开，将软件包拖入应用程序文件夹中，这时候一个原版的软件就可以让我们使用，只是有一个试用期，右键单击我们的Charles应用，显示包内容： 将如下文件夹中的jar包替换为我们破解文件夹中的jar包： 三、使用Charles在mac上进行抓包分析在软件安装完成后，我们已经可以在mac上截取一般的网络请求了，打开软件，将Proxy设置中的Mac OS X Proxy勾选，设置为网络代理，这时候如果发生网络请求，就可以被Charles截获到 如果我们需要截取SSL协议的网络请求，这时候我们还需要安装一个证书：http://yun.baidu.com/s/1o6J2Crg。注意将证书权限设置为始终信任。 抓获信息的界面如下： 软件的功能十分强大，Structure是将请求按域名排序，Sequence是将请求时间排序，下面的Request和Response分别为请求的数据包和返回的数据包，如果是json数据，还会自动帮我们解析格式。 注意：如果iOS模拟器上抓不到请求包，重启模拟器即可。 四、在移动设备上进行抓包导入证书的过程和在mac上一样，在移动设备上访问[http://yun.baidu.com/s/1o6J2Crg](http://yun.baidu.com/s/1o6J2Crg)。进行证书下载，安装： 在移动设备上截获网络请求，我们的移动设备必须和电脑在同一网段，在我们电脑的网络设置中查看IP地址，然后在移动设备上点击我们连接的电脑上的网络，在代理一栏中，选择手动，将我们刚才查看的ip地址填写在这里，并且设置一个端口号。 在Charles中的Proxy setting中如下勾选并配置端口号 我们在设备上再访问网络，请求包就可以被我们抓取到。 五、Charles的更多应用1、过滤网络请求有时候我们只想抓取某个主机的网络请求，我们可以设置过滤网络，在Proxy菜单中的Recording Setting中，我们选择include标签，可以在里面添加一个白名单，这样Charles就只截取在这个主机下的请求： 2、模拟限速网络很多时候，我们需要测试在网络不佳时应用请求的相关数据，我们可以模拟设置限速网络，在Proxy菜单中的Throttle Settings中将，Enable Throttling勾选，并可以在下面进行网路设置，only for selected host可以设置一个指定的主机访问进行限制网络。 3、修改网络信息，多次请求在测试接口时，有时候我们需要反复进行不同参数的接口请求，Charles也支持我们进行请求参数的修改和多次请求，在请求上点击右键，现则edit： 其中的参数，请求类型等我们都可以修改，之后点击execute进行重新请求 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}],"tags":[],"keywords":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}]},{"title":"工厂设计模式的探讨——iOS类簇的应用分析","slug":"110工厂设计模式的探讨——iOS类簇的应用分析","date":"2015-09-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.317Z","comments":true,"path":"2015/09/18/110工厂设计模式的探讨——iOS类簇的应用分析/","link":"","permalink":"http://huishao.cc/2015/09/18/110工厂设计模式的探讨——iOS类簇的应用分析/","excerpt":"","text":"工厂设计模式的探讨——iOS类簇的应用分析一、何为设计模式什么是设计模式，先来看段度娘的话： 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 其实我们不需要这么专业，在我的理解，设计模式就是一种规范化的编程习惯，养成了这样的思想与习惯，对我们的代码，总是有好处了。 二、工厂设计模式首先，工厂设计模式是创建对象的一种设计模式，一个严格意义上的工厂设计模式应该是一个纯虚的构造方法。由子类进行具体对象的创建，我们可以这样理解：现在有一个珲少牌制造工厂，这个工厂可以制造多种交通工具，我大胆一些，假设它可以制造飞机，轮船。小汽车，公交车，出租出和自行车，那么，这些不同的车种虽然功能和大类别统一，但是他们的个体差异也是天地之别，就比如我飞机一小时可以飞5000公里，自行车拼死了劲也不一定能骑20公里。所以，如果珲少这个大工厂要生产他们，也不可能把他们放在一起生产。一个比较明智的决定是，开立分厂，比如珲少飞机工厂专门生产飞机，珲少自行车工厂专门生产自行车。 好了，如果将我们这种人类世界的思维运用于程序世界，那么我们可以通过工厂的这种思维方式来将一些大类抽象为工厂，通过定义接口或者说是定义虚函数来规范这个大工厂的生产规模和流程，由其子类来具体实现这些方法，也就是由一个个小的分厂来明确的生产我们需要的东西。这就是工厂设计模式的基本思路。 三、工厂的设计模式有什么用许多开发者或许并不在意设计模式这个东西，我们可能会想，我实现我的功能就可以了，你管我怎么设计呢。在这篇博客的开头就说到，在我理解中，设计模式就是一种编程习惯和规范，更是一种众多开发者摸索出来的经验，这就像农业上的套种间种和你随便种，哪一种效率高，收成好，不言而喻。那么在软件设计中，工厂模式的应用在哪呢？ 我们先来体验一下在iOS开发中，一些使用工厂设计模式的系统类为我们带来的便捷之处： 1、认识一个名词 类簇在iOS的Foundation框架中，类簇是一种常用的设计模式，他将一些相近的，私有的，具体的子类组合在一个实体的抽象类下面，我称这个抽象类为实体的，是因为和我们交互的接口承载者，就是这个抽象大类。我们平时常用的三大类，NSString,NSArray,NSDictionary都是类簇，我们通过他们创建的对象都是其子类对象的实例化，并不是他本身的实例化，我们还通过上面的例子来理解，我买了一辆珲少小汽车，这两汽车的生产实际是在珲少汽车工厂生产的，但是我个人会依然认为，这是珲少工厂出产的汽车。我们可以通过打印类名来验证： 12NSString * str = [[NSString alloc]initWithCString:&quot;2&quot; encoding:0]; NSLog(@&quot;%@&quot;,[str class]); 结果如下： 可以看到，真实的对象是NSString的子类__NSCFString进行实例化的。 2.这样设计的优势在哪如果你通过NSString的事例还是无法体会到类簇，也就是工厂设计模式的优势，那么下面这个例子你一定经常遇到:NSNumber。我们在创建数字对象的时候，通常会这样考虑，如果是int值，我需要一个IntNumber的类，float值，我需要一个FloatNumber类，如果foundation框架真这么设计的话，那么你现在就痛苦了，你不仅要记住好多这样相似的类，调用方法时也要相应的对象调其内的方法，这使开发者的开发变得更加繁琐，并且对于开发者来说，我并不需要知道具体我创建了什么类，我只是想让他完成既定的方法。说的更通俗一点，还是上面的制造工厂，使用者并不在乎具体这个交通工具是哪个地方生产出来的，只要它价钱和速度都是使用者预期的结果就好了。 3.工厂设计模式的应用通过上面的分析，我们大致可以总结出工厂这种设计模式的应用场景： （1）当一个类并不知道要创建的具体对象是什么，交由子类处理 （2）当一些类有相似的行为和结构，只是具体实现不同时，可以抽象出工厂 （3）使用者并不在乎具体类型，只在乎接口约定的行为，并且这种行为有个体差异 四、在iOS中模拟一个工厂同样是上面的例子，我们来用代码模拟一下： 首先，我们创建一个抽象的工程类，在其中创建一些私有的子类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &lt;Foundation/Foundation.h&gt;//交通工具的枚举typedef enum &#123;car,boat,airport,bycicle,bus,taxi&#125;ToolsName;//代理@protocol TransPortationDelegate &lt;NSObject&gt;-(void)toHome:(Class)class;@end//抽象工厂类@interface TramsPortationFactory : NSObject+(TramsPortationFactory*)buyTool:(ToolsName)tool;//共有的方法接口-(int)shouldPayMoney;-(void)run;@property(nonatomic,strong)id&lt;TransPortationDelegate&gt;delegate;@end//具体实现的子类@interface CarFactory : TramsPortationFactory@end@interface BoatFactory : TramsPortationFactory@end@interface AirportFactory : TramsPortationFactory@end@interface BycicleFactory : TramsPortationFactory@end@interface TaxiFactory : TramsPortationFactory@end@interface BusFactory : TramsPortationFactory@end 实现文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#import &quot;TramsPortationFactory.h&quot;@implementation TramsPortationFactory//实现的创建方法+(TramsPortationFactory*)buyTool:(ToolsName)tool&#123; switch (tool) &#123; case car: return [[CarFactory alloc]init]; break; case airport: return [[AirportFactory alloc]init]; break; case bycicle: return [[BycicleFactory alloc]init]; break; case boat: return [[BoatFactory alloc]init]; break; case taxi: return [[TaxiFactory alloc]init]; break; case bus: return [[BusFactory alloc]init]; break; default: break; &#125;&#125;-(int)shouldPayMoney&#123; return 0;&#125;-(void)run&#123; [self.delegate toHome:[self class]];&#125;@end//各自类实现具体的行为@implementation CarFactory-(int)shouldPayMoney&#123; return 50;&#125;-(void)run&#123; [super run]; NSLog(@&quot;car to home&quot;);&#125;@end@implementation AirportFactory-(int)shouldPayMoney&#123; return 1000;&#125;-(void)run&#123; [super run]; NSLog(@&quot;fly to home&quot;);&#125;@end@implementation BoatFactory-(int)shouldPayMoney&#123; return 300;&#125;-(void)run&#123; [super run]; NSLog(@&quot;boat to home&quot;);&#125;@end@implementation BusFactory-(int)shouldPayMoney&#123; return 10;&#125;-(void)run&#123; [super run]; NSLog(@&quot;bus to home&quot;);&#125;@end@implementation BycicleFactory-(int)shouldPayMoney&#123; return 0;&#125;-(void)run&#123; [super run]; NSLog(@&quot;run to home&quot;);&#125;@end@implementation TaxiFactory-(int)shouldPayMoney&#123; return 100;&#125;-(void)run&#123; [super run]; NSLog(@&quot;go to home&quot;);&#125;@end 这样，我们的一个生产工厂就完成了，在外面，我们只需要知道一个类，我们的抽象父类，就可以实现个子类的行为，示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; TramsPortationFactory * tool = [TramsPortationFactory buyTool:car]; tool.delegate=self; [tool run]; NSLog(@&quot;花了:%d钱&quot;,[tool shouldPayMoney]); TramsPortationFactory * tool2 = [TramsPortationFactory buyTool:airport]; tool2.delegate=self; [tool2 run]; NSLog(@&quot;花了:%d钱&quot;,[tool2 shouldPayMoney]); &#125;-(void)toHome:(Class)class&#123; NSLog(@&quot;%@&quot;,NSStringFromClass(class));&#125; 可以看到，对于开发者，我们并不知晓CarFactory类的存在，我们只需要通过TramsPortationFactory类，就能够操作各种交通工具，达到我们的需求。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}],"tags":[],"keywords":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}]},{"title":"iOS生成标准的注释工具——VVDocumenter","slug":"109iOS生成标准的注释工具——VVDocumenter","date":"2015-09-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.317Z","comments":true,"path":"2015/09/16/109iOS生成标准的注释工具——VVDocumenter/","link":"","permalink":"http://huishao.cc/2015/09/16/109iOS生成标准的注释工具——VVDocumenter/","excerpt":"","text":"iOS生成标准的注释工具——VVDocumenter在程序开发中，我们免不了要写许多注释，方便帮别人也方便我们自己以后检查我们的代码。然而，写注释是一件十分浪费我们时间与精力的事，要写符合文档格式的注释，更是会消耗我们很多的功夫，幸运的是，VVDocumenter可以帮我们很大的忙。 gitHub地址：[https://github.com/onevcat/VVDocumenter-Xcode](https://github.com/onevcat/VVDocumenter-Xcode)。 安装与使用方法：下载github源码，使用xcode打开工程，运行一下，如果成功，插件就安装好了，这时，我们必须将xcode重新启动一下，才可以使用。 重启xcode，在任意一个地方输入///，即会自动出现如下的注释模板，参数部分已经由占位符写好 123456/** * &lt;#Description#&gt; * * @param data &lt;#data description#&gt; */- (void)updateWithData:(id)data; 是不是写注释变成了一件非常有趣的事，你还可以对其进行一些设置，在xcode-&gt;window菜单栏中，有VVDocumenter这个标签，里面可以对生成注释的模板进行一些设置，比如生成注释的快捷键，注释的对齐模式，注释显示创建者和时间等。例如如下设置就会生成这样的注释： 12345678/** * @author Elephant, 15-09-16 13:09:28 * * @brief &lt;#Description#&gt; * * @param data &lt;#data description#&gt; */ - (void)updateWithData:(id)data; 最后，推荐这款小插件给你，祝你写代码愉快O(∩_∩)O。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"我的女神——简洁实用的iOS代码调试框架","slug":"108我的女神——简洁实用的iOS代码调试框架","date":"2015-09-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.317Z","comments":true,"path":"2015/09/10/108我的女神——简洁实用的iOS代码调试框架/","link":"","permalink":"http://huishao.cc/2015/09/10/108我的女神——简洁实用的iOS代码调试框架/","excerpt":"","text":"我的女神——简洁实用的iOS代码调试框架一、引言这篇博客的起源是接手了公司的一个已经完成的项目，来做代码优化，项目工程很大，并且引入了很多公司内部的SDK，要搞清楚公司内部的这套框架，的确不是件容易的事，并且由于这个项目是多人开发的，在调试阶段会打印出巨量的调试信息，使得浏览有用信息变的十分困难，更加恐怖的是，很多信息是SDK中的调试打印，将这些都进行注销是非常费劲甚至不可能的事，于是便有了这样一些需求：首先，我需要清楚了解各个controller之间的跳转关系，需要快速的弄清每个stroyBoard中各个controller的来龙去脉，其次，我想在不改变其他人的调试代码的情况下，屏蔽冗余的log信息，让我的调试数据更加清晰明了。于是我想到了如下的解决方案，同样，如果你有更好的方案或者你知道的优秀的解决办法，请告知我，十分感谢。 二、追踪程序的跳转路径这是一个很容易解决的问题，我们都知道，一个controller，如果要展现出来，一定会走生命周期中的viewWillAppear这个方法，我们只需要在这个方法中做些手脚就可以了，实现有两种思路，一种是采用工厂的设计模式，建立工厂类Controller，在其viewWillAppear中加入我们的调试代码，但这对于我的项目并不实用，首先我不确定所有controller都会继承于一个父类，其次，在我没有找到源头时，这些类已经在公司的framework中了，我根本没办法操作源码。而第二种方案就是runtime，对的，运行时的OC，没有不可能。关于runtime的详细说明，在[http://my.oschina.net/u/2340880/blog/489072](http://my.oschina.net/u/2340880/blog/489072)中有介绍。思路是我们可以写一个方法，替换掉系统的viewWillAppear，在其中加入我们的调试代码，这个方法就是Method Swizzing，代码设计如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//新建一个conreoller的类别#import &quot;UIViewController+YHBaseTest.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIViewController (YHBaseTest)+ (void)load &#123; //只执行一次的线程 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); //创建两个选择器 分别指向 系统的和我们要替换的函数 SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(YHBaseViewWillAppear:); //获取方法实例 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); //现将方法加入 BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); //进行方法替换 if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)YHBaseViewWillAppear:(BOOL)animated &#123;//这里是是我加的一个控制调试锁 后面会介绍 [self YHBaseViewWillAppear:animated]; YHBaseProcessLog(@&quot;YHBaseTest:ViewWillAppear: %@&quot;, self); &#125; 三、屏蔽冗余的log信息1、系统的NSLog是个什么玩意要战胜我们的敌人，首先应该了解我们的敌人，我们想要屏蔽NSLog的打印，先需要清楚NSLog到底是个什么玩意。 首先，NSLog的定义如下： 12FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2);FOUNDATION_EXPORT void NSLogv(NSString *format, va_list args) NS_FORMAT_FUNCTION(1,0); 这里面有两个函数，一个是使用多参的格式化字符串进行NSLog的打印，一个是通过参数指针进行打印。从这里我们可以看出，系统的NSLog是一个C风格的函数，所以，我们有思路了，我们可以通过定义一个NSLog宏来替换掉项目中所有的NSLog，如下： 12//...是省略参数的宏的写法，后面的__VA_ARGS__是系统定义好的一个宏，来声明不定参数#define NSLog(...) YHBaseTestLog(__VA_ARGS__) 2、实现我们自己的NSLog通过上面的方法，在没有动源码的情况下，我们已经可以替换掉程序中所有的打印，可能你会疑问，程序中怎么会允许我们有两个NSLog呢，其实这没什么神奇的，要知道宏是一种预编译的指令，所有这些操作是在代码编译之前完成的，实际上程序中已经将NSLog简单替换成了我们的函数调用，程序中只有一个NSLog，这就是宏的强大之处，狸猫换太子，不错吧。 下面我们来实现我们的这个函数，如下： 123456789101112//不要忘了在.h文件中声明void YHBaseTestLog(NSString *str,...)&#123;//参数列 va_list list; va_start(list, str); //这个地方是一个锁，后面会介绍 if (![YHBaseTestLock sharedTheSingletion]-&gt;_customLock) &#123; //进行打印 NSLogv(str, list); &#125; va_end(list);&#125; 这个函数中其实并没有做什么，加了一个锁的判断，仅此而已，核心的控制，就交给我们的锁吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//.h文件@interface YHBaseTestLock : NSObject&lt;YHSingletonProcotol&gt;&#123; @public BOOL _customLock; BOOL _precessLock;&#125;+(void)customLock;+(void)customUnLock;+(void)processLogLock;+(void)processLogUnLock;//.m//单例方法+(instancetype)sharedTheSingletion&#123; static YHBaseTestLock * sharedModel = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; sharedModel = [[YHBaseTestLock alloc] init]; &#125;); return sharedModel;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; //初始化 默认用户的打印都开起 _customLock=NO; //默认 我们加的controller的打印屏蔽 _precessLock=YES; &#125; return self;&#125;//响应的设置+(void)customLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_customLock=YES;&#125;+(void)customUnLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_customLock=NO;&#125;+(void)processLogLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_precessLock=YES;&#125;+(void)processLogUnLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_precessLock=NO;&#125; 四、看看我们的杰作吧做完上面的工作后，我们在appdelegate中如如下的简单配置： 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //将用户打印加锁 [YHBaseTestLock customLock]; //将流程打印解锁 [YHBaseTestLock processLogUnLock]; return YES;&#125; 我们做如下测试： 1234567891011121314@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSLog(@&quot;111111111111111111111111111111111111111111111111111111111111111&quot;); [YHBaseTestLock customUnLock]; NSLog(@&quot;这个是有用的信息:%@==%d&quot;,@&quot;看我哦&quot;,__LINE__); [YHBaseTestLock customLock]; NSLog(@&quot;32123213123214412312312&quot;);&#125; 我在viewController中的有用信息前后，打印了一些干扰信息，并且可以看到，这个NSLog的格式和系统的完全兼容，在打印有用信息前后解锁和加锁，结果如下： 可以看到，我们将没用的打印都屏蔽了，并且打印了程序的跳转流程。最重要的是，我们对源码一个字符都没有修改，同时不会影响与冲突其他人的开发。 这篇博客开头，我称之为我的女神，真心实感，这个方法帮了我很大的忙，在我了解项目的结构框架前，每次调试打印都在控制区滚出一片片的信息着实让我头晕脑胀，现在一清凉，精神也清爽不少，^_^。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS开发一款小巧简洁的日历控件","slug":"107iOS开发一款小巧简洁的日历控件","date":"2015-09-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.317Z","comments":true,"path":"2015/09/07/107iOS开发一款小巧简洁的日历控件/","link":"","permalink":"http://huishao.cc/2015/09/07/107iOS开发一款小巧简洁的日历控件/","excerpt":"","text":"iOS开发一款小巧简洁的日历控件一、引言日 历是iOS开发中有时会用到的一个UI控件，网上开源的代码也很多，我浏览过一些，大致有两种模式，一种是日历的逻辑由开发者自己实现，通过计算闰年与平 年来确定月份天数，另外一种模式是通过NSDate这个时间类，来获取日历的信息。我个人认为后一种更加安全，代码性能也会更加优质，下面就是我用这种模 式实现的一个日历控件。 二、设计思路1、先来看下效果吧 2、我们需要实现的功能（1）每行7天，对应星期，列数为将当前月显示完全 （2）今日标红 （3）点击的日期背景填充 （4）提供特殊标记，用于标记计划日，节日等 （5）左右无限翻页，直到世界起源和末日 3、设计步骤（1）设计一个日历模型 1234567#import &quot;YHBaseModel.h&quot;@interface YHBaseDateModel : YHBaseModel@property(nonatomic,strong)NSString * year;@property(nonatomic,strong)NSString * month;@property(nonatomic,strong)NSString * day;@end （2）向系统的NSDate类中添加一些扩展方法，便于我们使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//头文件部分@interface NSDate (YHBaseCalendar)/** *获取当前月的天数 */- (NSUInteger)YHBaseNumberOfDaysInCurrentMonth;/** *获取本月第一天 */- (NSDate *)YHBaseFirstDayOfCurrentMonth;//下面这些方法用于获取各种整形的数据/** *确定某天是周几 */-(int)YHBaseWeekly;/** *年月日 时分秒 */-(int)getYear;-(int)getMonth;-(int)getDay;-(int)getHour;-(int)getMinute;-(int)getSecond;@end//实现部分@implementation NSDate (YHBaseCalendar)-(NSUInteger)YHBaseNumberOfDaysInCurrentMonth&#123; return [[NSCalendar currentCalendar] rangeOfUnit:NSDayCalendarUnit inUnit:NSMonthCalendarUnit forDate:self].length; &#125;- (NSDate *)YHBaseFirstDayOfCurrentMonth&#123; NSDate *startDate = nil; BOOL ok = [[NSCalendar currentCalendar] rangeOfUnit:NSMonthCalendarUnit startDate:&amp;startDate interval:NULL forDate:self]; NSAssert1(ok, @&quot;Failed to calculate the first day of the month based on %@&quot;, self); return startDate;&#125;-(int)YHBaseWeekly&#123; return (int)[[NSCalendar currentCalendar] ordinalityOfUnit:NSDayCalendarUnit inUnit:NSWeekCalendarUnit forDate:self];&#125;-(int)getYear&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.year;&#125;-(int)getMonth&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.month;&#125;-(int)getDay&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.day;&#125;-(int)getHour&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.hour;&#125;-(int)getMinute&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.minute;&#125;-(int)getSecond&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.second;&#125;@end （3）设计我们的UI控件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//头文件部分@interface YHBaseCalendarView : YHBaseView@property(nonatomic,strong)NSDate * currentDate;//标记数组 用于标记特殊日期 这个数组中存放的必须是YHBaseDateModel 对象@property(nonatomic,strong)NSArray * markArray;@property(nonatomic,weak)id&lt;YHBaseCalendarViewDelegate&gt; delegate;@end//实现部分@interface YHBaseCalendarView()&lt;UIScrollViewDelegate&gt;&#123; //星期 UIView * _headView; //日历的展示 UIView * _bodyViewL; UIView * _bodyViewM; UIView * _bodyViewR; //滑动功能的支持 UIScrollView * _scrollView; NSDate * _today; YHBaseDateModel * _selectModel;&#125;@end@implementation YHBaseCalendarView-(void)reloadView&#123; _currentDate = [NSDate date]; _today = [NSDate date]; _selectModel = [[YHBaseDateModel alloc]init]; _selectModel.year = [NSString stringWithFormat:@&quot;%d&quot;,[_today getYear]]; _selectModel.month =[NSString stringWithFormat:@&quot;%d&quot;,[_today getMonth]]; _selectModel.day = [NSString stringWithFormat:@&quot;%d&quot;,[_today getDay]]; _scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 30, self.frame.size.width, self.frame.size.height)]; _scrollView.contentSize = CGSizeMake(3*self.frame.size.width, 0); _scrollView.contentOffset = CGPointMake(self.frame.size.width, 0); _scrollView.pagingEnabled=YES; _scrollView.delegate=self; [self addSubview:_scrollView]; _bodyViewL = [[UIView alloc]initWithFrame:CGRectMake(0, 0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewL]; _bodyViewM = [[UIView alloc]initWithFrame:CGRectMake(_scrollView.frame.size.width,0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewM]; _bodyViewR = [[UIView alloc]initWithFrame:CGRectMake(_scrollView.frame.size.width*2, 0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewR]; //展示星期 _headView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, self.frame.size.width, 30)]; _headView.backgroundColor = [UIColor redColor]; NSArray * weekArray = @[@&quot;SUN&quot;,@&quot;MON&quot;,@&quot;TUES&quot;,@&quot;WED&quot;,@&quot;THUR&quot;,@&quot;FRI&quot;,@&quot;SAT&quot;]; for (int i=0; i&lt;7; i++) &#123; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(self.frame.size.width/7*i, 0, self.frame.size.width/7, 30)]; if (i!=0&amp;&amp;i!=6) &#123; label.backgroundColor = [UIColor redColor]; &#125;else&#123; label.backgroundColor = [UIColor purpleColor]; &#125; label.text=weekArray[i]; label.textAlignment = NSTextAlignmentCenter; label.layer.borderWidth=1; label.layer.borderColor = [[UIColor grayColor]CGColor]; label.font = [UIFont boldSystemFontOfSize:16]; label.layer.borderColor=[[UIColor grayColor] CGColor]; label.textColor = [UIColor whiteColor]; label.layer.borderWidth = 1; [_headView addSubview:label]; &#125; [self addSubview:_headView]; [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR];&#125;//核心的构造方法-(void)creatViewWithData:(id)data onView:(UIView *)bodyView&#123; NSDate * currentDate = (NSDate *)data; //获取当前月有多少天 int monthNum = (int)[currentDate YHBaseNumberOfDaysInCurrentMonth]; //获取第一天的日期 NSDate * firstDate = [currentDate YHBaseFirstDayOfCurrentMonth]; //确定这一天是周几 int weekday = [firstDate YHBaseWeekly]; //确定创建多少行 int weekRow=0; int tmp=monthNum; if (weekday!=7) &#123; weekRow++; tmp=monthNum-(7-weekday); &#125; weekRow += tmp/7; weekRow += (tmp%7)?1:0; //开始创建按钮 /** *这里的逻辑是有问题的，应该设计成cell的复用机制，而不应该重复耗性能的创建 有时间在优化 */#warning 可以优化哦 NSArray * array = [bodyView subviews]; for (UIView * v in array) &#123; [v removeFromSuperview]; &#125; int nextDate = 1; //行 for (int i=0; i&lt;weekRow; i++) &#123; //列 for (int j=0; j&lt;7; j++) &#123; //先进行上个月余天的创建 UIButton * btn; if (weekday!=7&amp;&amp;(i*7+j)&lt;weekday) &#123; //获取上个月有多少天 NSDate * preDate = [YHBaseDateTools getPreviousframDate:currentDate]; int preDays = (int)[preDate YHBaseNumberOfDaysInCurrentMonth]; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,preDays-weekday+j+1] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125;else if((i*7+j+1-(weekday==7?0:weekday))&lt;=monthNum)&#123; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,(i*7+j+1-(weekday==7?0:weekday))] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125;else&#123; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,nextDate++] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125; //将今天的日期标出 if ([currentDate getYear]==[_today getYear]&amp;&amp;[currentDate getMonth]==[_today getMonth]&amp;&amp;[btn.titleLabel.text intValue]==[_today getDay]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; &#125; //是否进行自定义标记 /** *if中的颜色比较 是为了让上月与下月的余日不产生bug */ if (_markArray!=nil) &#123; for (int i=0; i&lt;_markArray.count; i++) &#123; YHBaseDateModel * model = _markArray[i]; if ([currentDate getYear]==[model.year intValue]&amp;&amp;[currentDate getMonth]==[model.month intValue]&amp;&amp;[btn.titleLabel.text intValue]==[model.day intValue]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; btn.layer.borderColor = [[UIColor grayColor]CGColor]; btn.layer.borderWidth=1; &#125; &#125; &#125; //是否进行选中标记 if ([_selectModel.year intValue]==[currentDate getYear]&amp;&amp;[_selectModel.month intValue]==[currentDate getMonth]&amp;&amp;[_selectModel.day intValue]==[btn.titleLabel.text intValue]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; btn.backgroundColor = [UIColor cyanColor]; &#125; if (!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; //添加点击事件 [btn addTarget:self action:@selector(clickBtn:) forControlEvents:UIControlEventTouchUpInside]; &#125; &#125; &#125; &#125;//这个方法中进行重构-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.x==0) &#123;//向前翻页了 _currentDate = [YHBaseDateTools getPreviousframDate:_currentDate]; _scrollView.contentOffset=CGPointMake(scrollView.frame.size.width, 0); [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; &#125;else if (scrollView.contentOffset.x==scrollView.frame.size.width)&#123; &#125;else if (scrollView.contentOffset.x==scrollView.frame.size.width*2)&#123; _currentDate = [YHBaseDateTools getNextMonthframDate:_currentDate]; _scrollView.contentOffset=CGPointMake(scrollView.frame.size.width, 0); [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; &#125; scrollView.userInteractionEnabled=YES; if ([self.delegate respondsToSelector:@selector(YHBaseCalendarViewScrollEndToDate:)]) &#123; YHBaseDateModel * model = [[YHBaseDateModel alloc]init]; model.year = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getYear]]; model.month = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getMonth]]; model.day = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getDay]]; [self.delegate YHBaseCalendarViewScrollEndToDate:model]; &#125;&#125;-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; scrollView.userInteractionEnabled=NO;&#125;//点击事件-(void)clickBtn:(UIButton *)btn&#123; _selectModel.year = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getYear]]; _selectModel.month = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getMonth]]; _selectModel.day = btn.titleLabel.text; [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; if ([self.delegate respondsToSelector:@selector(YHBaseCalendarViewSelectAtDateModel:)]) &#123; [self.delegate YHBaseCalendarViewSelectAtDateModel:_selectModel]; &#125; &#125;@end （4）为用户交互设计的协议 1234@protocol YHBaseCalendarViewDelegate&lt;NSObject&gt;-(void)YHBaseCalendarViewSelectAtDateModel:(YHBaseDateModel *)dateModel;-(void)YHBaseCalendarViewScrollEndToDate:(YHBaseDateModel *)dateModel;@end 三、插个小广告控件的源码在[https://github.com/ZYHshao/YHBaseFoundationTest.git](https://github.com/ZYHshao/YHBaseFoundationTest.git)中，这是我封装的一套基于Cocoa与Foundation的更易用的开发框架，其中也对AFN，CRLabel，SDImage,MJRefresh进行了集成，有易用的下载框架，缓存框架，错误处理框架，皮肤管理框架等，也有支持加载HTML并且异步缓存图片的view，边下边播并做缓存的AVAudioPlayer，以及各种自定义性能很强的view控件，如用block创建的按钮，提示框以及对json和模型做相关映射的处理类，如果这些东西有帮到你，我很开心，如果你发现一些问题或者优化建议，请一定告知我，我将十分感激，QQ316045346 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C使用位运算设计可复选的枚举","slug":"106Objective-C使用位运算设计可复选的枚举","date":"2015-09-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.316Z","comments":true,"path":"2015/09/03/106Objective-C使用位运算设计可复选的枚举/","link":"","permalink":"http://huishao.cc/2015/09/03/106Objective-C使用位运算设计可复选的枚举/","excerpt":"","text":"使用位运算设计可复选的枚举一、枚举使用的一个小例子在软件开发中，枚举是我们会经常会用到的一种编程方式，通过枚举，可以使我们的代码更具可读性与统一性。通常情况下，我们会通过typedef来定义一种枚举的类型来使用。例如： 12345typedef enum &#123; para1, para2, para3&#125;myEnum; 我们可以在函数的参数中来使用它： 123456789101112131415161718192021-(void)testEunm:(myEnum)para&#123; switch (para) &#123; case para1: &#123; NSLog(@&quot;para%d&quot;,1); &#125; break; case para2: &#123; NSLog(@&quot;para%d&quot;,2); &#125; break; case para3: &#123; NSLog(@&quot;para%d&quot;,3); &#125; break; default: break; &#125;&#125; 我们在调用调用这样的一个函数的时候，通过传入一个枚举类型，可以分流执行我们想要的操作。 二、枚举到底是个什么东西枚举并不是一种奇怪的类型，起实质是整型的另一个名字，如果没有附加的操作，枚举中的第一个参数默认就是整型0，之后依次递加，当然，我们也可以认为的控制这个数值，例如： 12345typedef enum &#123; para1=7, para2, para3=1000&#125;myEnum; 可以这么理解，我在传参的时候，传7和para1是完全一样的效果，但是后者明显更具可读性。 三、可复选的枚举属性如果熟悉iOS的开发，你会发现系统很多的枚举类型都是可以复选的，例如视图的拉伸模式，json的解析属性等等，这不仅使代码可读性优化，也更加简便了一些选项设置的代码。当我们理解了枚举就是整型之后，会发现其实很容易做到这一点： 首先，我们给定义的枚举参数设置一个有规律的值： 12345typedef enum &#123; para1=1&lt;&lt;1, para2=1&lt;&lt;2, para3=1&lt;&lt;3&#125;myEnum; &lt;&lt;符号是位运算中的左移运算符，将1进行1位，2位，3位的左移后，我们得到的二进制数如下： 123000100100100 现在我们有了一个大致思路了，用当前位的0和1来标识当前属性是否设置，如果有几个属性的复选，只需要将我们的相应枚举进行或的位运算，在取的时候检测相应位是否为1即可，这正是与运算可以做到的： 1234567891011-(void)testEunm:(myEnum)para&#123; if (para&amp;1&lt;&lt;1) &#123; NSLog(@&quot;para1&quot;); &#125; if (para&amp;1&lt;&lt;2) &#123; NSLog(@&quot;para2&quot;); &#125; if (para&amp;1&lt;&lt;3) &#123; NSLog(@&quot;para3&quot;); &#125;&#125; 我们通过如下方式调用： 1[self testEunm:para2|para3]; 打印结果如下： 这种位运算的枚举在官方sdk中被广泛使用，能够有效的简化代码和提高代码的可读性。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计","slug":"105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计","date":"2015-08-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.316Z","comments":true,"path":"2015/08/30/105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计/","link":"","permalink":"http://huishao.cc/2015/08/30/105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计/","excerpt":"","text":"扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计在iOS开发中，图文混排一直都是UI编程的一个核心点，也有许多优秀的第三方引擎，其中很有名的一套图文混排的框架叫做DTCoreText。但是在前些日的做的一个项目中，我并没有采用这套框架，原因有二，一是这套框架体积非常大，而项目的需求其实并不太高；二是要在这套框架中修改一些东西，难度也非常大，我最终采用的是一个叫做RCLabel的第三方控件，经过一些简单的优化和完善，达到了项目的要求。 先来介绍一下我项目中的图文混排的需求：首先我从服务器中取到的数据是字符串，但是其中穿插图片的位置是一个HTML的图片标签，标签里的资源路径就是图片的请求地址。需要达到的要求是这些数据显示出来后，图片的位置要空出来，然后通过异步的网络请求获取图片的数据，再将图片插入文字中。 要自己实现一套这样的引擎确实会比较麻烦，幸运的是RCLabel可以完美的帮我们解析带有HTML标签的数据，进行图文混排，我们先来看一下这个东西怎么用，下面是我封装的一个展示html数据的view： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@interface YHBaseHtmlView()&lt;YHRTLabelImageDelegate&gt;&#123; //RCLabel对象 RCLabel * _rcLabel; //保存属性 用于异步加载完成后刷新 RTLabelComponentsStructure * _origenComponent; //含html标签的数据字符串 NSString * _srt;&#125;@end@implementation YHBaseHtmlView/*// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code&#125;*/- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super initWithCoder:coder]; if (self) &#123; //将rclabel初始化 _rcLabel = [[RCLabel alloc]init]; [self addSubview:_rcLabel]; &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _rcLabel = [[RCLabel alloc]initWithFrame:frame]; [self addSubview:_rcLabel]; &#125; return self;&#125;-(void)reSetHtmlStr:(NSString *)htmlStr&#123; _srt = htmlStr; //这个代理是我额外添加的 后面解释 _rcLabel.imageDelegate=self; //设置frame _rcLabel.frame=CGRectMake(0, 0, self.frame.size.width, 0); //设置属性 _origenComponent = [RCLabel extractTextStyle:htmlStr IsLocation:NO withRCLabel:_rcLabel]; _rcLabel.componentsAndPlainText = _origenComponent; //获取排版后的size CGSize size = [_rcLabel optimumSize]; //重新设置frame _rcLabel.frame=CGRectMake(0, 0, _rcLabel.frame.size.width, size.height); self.frame=CGRectMake(self.frame.origin.x, self.frame.origin.y, _rcLabel.frame.size.width, size.height);&#125;//这是我额外添加的代理方法的实现-(void)YHRTLabelImageSuccess:(RCLabel *)label&#123; _origenComponent = [RCLabel extractTextStyle:_srt IsLocation:NO withRCLabel:_rcLabel]; _rcLabel.componentsAndPlainText = _origenComponent; CGSize size = [_rcLabel optimumSize]; _rcLabel.frame=CGRectMake(0, 0, _rcLabel.frame.size.width, size.height); self.frame=_rcLabel.frame; if ([self.delegate respondsToSelector:@selector(YHBaseHtmlView:SizeChanged:)]) &#123; [self.delegate YHBaseHtmlView:self SizeChanged:self.frame.size]; &#125;&#125; RCLabel的用法很简单，总结来说只有三步： 1.初始化并设置frame 2.通过带html标签的数据进行属性的初始化 3.将属性进行set设置并重设视图frame RCLabel是很强大，并且代码很简练，但是其中处理图片的部分必须是本地的图片，即图片html标签中的路径必须是本地图片的名字，其内部是通过[UIImage ImageNamed:]这个方法进行图片的渲染的，所以要达到我们的需要，我们需要对其进行一些简单的扩展： 1、在属性设置方法中添加一个参数，来区分本地图片与网络图片： 12//我在这个方法中添加了location这个bool值，实际上rclabel这个参数也是我添加的，是为了后面代理使用的+ (RTLabelComponentsStructure*)extractTextStyle:(NSString*)dataimage IsLocation:(BOOL)location withRCLabel:(RCLabel *)rcLabel; 2、在实现方法中添加如下代码，因为原文件有1900多行，在其中弄清楚逻辑关系也确实费了我不小的力气，我这里只将我添加的代码贴过来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#warning 这里进行了兼容性处理 if (location) &#123; //本地图片的渲染 if (tempURL) &#123; UIImage *tempImg = [UIImage imageNamed:tempURL]; component.img = tempImg; &#125; &#125;else&#123;//这里做远程图片数据的处理 //这里我进行了缓存的操作，这个缓存中心是我封装的框架中的另一套东西，这里可以不用在意 //先读缓存 NSData * ceche = [[YHBaseCecheCenter sharedTheSingletion] readCecheFile:tempURL fromPath:YHBaseCecheImage]; if (ceche) &#123; UIImage * tempImg = [UIImage imageWithData:ceche]; component.img=tempImg; &#125;else&#123; //在分线程中进行图片数据的获取 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; if (tempURL) &#123; NSData * data = [YHBaseData getDataWithUrl:tempURL]; if (data) &#123; //获取完成后村缓存 //做缓存 [[YHBaseCecheCenter sharedTheSingletion]writeCecheFile:data withFileID:tempURL toPath:YHBaseCecheImage]; //赋值 回调代理 UIImage * tempImg = [UIImage imageWithData:data]; component.img=tempImg; //这里代理是我添加的，当图片下载完成后 通知视图重新排版 if ([[rcLabel imageDelegate]respondsToSelector:@selector(YHRTLabelImageSuccess:)]) &#123; //在主线程中执行回调 //这个地方要在主线程中执行，否则刷新会有延时 dispatch_async(dispatch_get_main_queue(), ^&#123; [[rcLabel imageDelegate] YHRTLabelImageSuccess:rcLabel]; &#125;); &#125; &#125; &#125;; &#125;); &#125; &#125; 通过如上简单的扩展，基本达到了项目中的需求，这里把我的一些想法和思路分享给大家，有更好的解决方案，或者同是开发爱好者，欢迎指点与交流，我的QQ是316045346。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS程序框架设计之皮肤切换功能","slug":"104iOS程序框架设计之皮肤切换功能","date":"2015-08-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.316Z","comments":true,"path":"2015/08/21/104iOS程序框架设计之皮肤切换功能/","link":"","permalink":"http://huishao.cc/2015/08/21/104iOS程序框架设计之皮肤切换功能/","excerpt":"","text":"iOS程序框架设计之皮肤切换功能一、引言移动应用的开发中，有时我们会需要例如更换皮肤此类的功能，andorid采用xml配置UI的方式，这个问题或许还容易解决些，iOS的主要UI逻辑则是在代码中控制的，如果没有一个强大的框架方案，这个问题将变得非常棘手。网上也有很多诸如此类功能的优秀案例与框架，在这篇博客中，我与大家分享下我的解决方案，其中如果有不恰或者糟糕之处，希望与高人一起交流。 二、设计思路与框架首先我的设计思路是采用通知的方式，原理可以如下理解为以下几步： 1、在系统的通知中心注册一个通知 2、所有需要更改皮肤功能的controller作为这个通知的监听者 3、设计一个皮肤的model类 4、将controller中有关皮肤设置的属性从model中取 5、在切换皮肤前更改皮肤model 6、发送更改皮肤的通知 上面的6个步骤是这整个框架的基本逻辑，框架无非是将这些逻辑进行优化与封装。下面这张图很烂，但是思路很清晰： 首先最上面是我设计的一个切换主题的manager，我这里的设计有个缺陷，我将manager和主题配置相关的model混合在了一起，写的时候简单了些，可这给框架的逻辑上带来了混乱，所以我在图中使用曲线和虚椭圆将其分离，manager来控制切换model的属性，我们在controller中取model的属性进行配置，这个manager的逻辑位置是交互时间与通知中心的桥梁。manager中的核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//单例方法+(instancetype)sharedTheSingletion&#123; static YHTopicColorManager * sharedModel = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; sharedModel = [[YHTopicColorManager alloc] init]; &#125;); return sharedModel;&#125;//这个方法应该分离在model中，从本地读取当前的主题模式，更改后我们只需要更改本地数据 然后重新调用这个方法即可-(void)getTopicModel&#123; //从本地读取 int tp = [YHSASystemSettingManager sharedTheSingletion].topic; if (tp==0) &#123; //默认为白天主题 tp=dayTime; [YHSASystemSettingManager sharedTheSingletion].topic = tp; &#125; switch (tp) &#123; //这里是我定义的一些枚举，拿白天和夜间模式示范 case dayTime://白天模式 &#123; //这里面定义一些白天模式下 控件的颜色属性 也可以定义其他 _navColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _bgColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _btnColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _textColor=[UIColor colorWithRed:0 green:0 blue:0 alpha:1]; _btnTextColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _navTextColor= [UIColor whiteColor]; &#125; break; case nightTime://夜间模式 &#123; //这里面定义夜间模式下的相关控件的颜色属性 _navColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _bgColor=[UIColor colorWithRed:0 green:0 blue:0 alpha:1]; _btnColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _textColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _btnTextColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _navTextColor= [UIColor whiteColor]; &#125; break; default: break; &#125;&#125;//发送更改主题的消息+(void)postTopicChangeMessage&#123; [[NSNotificationCenter defaultCenter]postNotificationName:YHTopicChangeTopicNotication object:nil];&#125; 在manager调用通知中心发送通知后，我们要让所有需要改变主题的视图控制器都接收到通知，最简便的做法是，我们设计一个父类，让父类监听通知，所有需要有主题更改功能的控制器继承于它即可，这个father controller的核心代码如下： 1234567891011121314151617//移除监听-(void)dealloc&#123; [[NSNotificationCenter defaultCenter]removeObserver:self];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //添加监听主题更换的通知 [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(useYHTopicToCreatViewWithModel) name:YHTopicChangeTopicNotication object:nil]; //协议中的方法，加载主题 一会再说 [self useYHTopicToCreatViewWithModel];&#125;//子类实现如下方法-(void)useYHTopicToCreatViewWithModel&#123; &#125; 到目前，我们已经可以顺利接收到主题切换的通知，可是要所有子类都步伐一致的执行相同一个操作，我们可以通过一个协议来约定，这就是图中的主框架的protocol，这个协议中规定一个特定的方法，我们在父类中调用，子类中实现，当收到通知时，所有子类都将重新加载这个方法，如果我们将皮肤设置部分在这个方法中实现，那么正是我们想要的效果，所有皮肤设置都被重新加载了。协议如下： 12345678910111213/** *这里定义主题的风格 */typedef enum &#123; dayTime=1,//白天 nightTime//夜间&#125;YHTopicModel;@protocol YHTopicProcotol &lt;NSObject&gt;//所有可以更换主题的界面必须遵守这个协议调用并实现如下方法//将视图中控件的颜色摄住部分全部放在这个方法中@required-(void)useYHTopicToCreatViewWithModel;@end 这时，就剩下我们这套逻辑的最后一步了，我们只需要将控件的颜色设置写在子类的协议方法中，并且，这些设置的数据来源于model这个模型，整个体系就完成了，子类实现方法如下： 1234567891011121314151617-(void)useYHTopicToCreatViewWithModel&#123;//获取到模型 YHTopicColorManager * model = [YHTopicColorManager sharedTheSingletion]; //加载模型数据 [model getTopicModel]; //进行设置 self.view.backgroundColor = model.bgColor; _schoolLabel.textColor = model.textColor; _phoneLabel.textColor = model.textColor; _secertLabel.textColor = model.textColor; _reWriteSecretLabel.textColor = model.textColor; _questionLabel.textColor = model.textColor; _answerLabel.textColor = model.textColor; _registBtn.backgroundColor = model.btnColor; [_registBtn setTitleColor:model.btnTextColor forState:UIControlStateNormal]; &#125; 我简单写了一些界面，不论任何地方切换皮肤，所有界面效果都会改变： 切换夜间模式前： 开启夜间模式后： 三、补充自己的思路实现更换主题的一种方法，真诚的想与志同道合的朋友交流开发经验，如果你想批评，点拨，交流或者是借鉴我的代码，Q316045346随时欢迎。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"Xcode创建可复用的代码块","slug":"102Xcode创建可复用的代码块","date":"2015-08-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.315Z","comments":true,"path":"2015/08/13/102Xcode创建可复用的代码块/","link":"","permalink":"http://huishao.cc/2015/08/13/102Xcode创建可复用的代码块/","excerpt":"","text":"Xcode创建可复用的代码块在各种程序开发中，编写代码的效率是非常重要的一个问题，各种优秀的编译器也都有相应的插件用于提高程序员的编码速度。在xcode中，可以通过定义代码块的方式将常用的一部分代码进行快捷呼出，首先xcode中为我们定义好了许多代码块，例如： 在使用这些代码模板时，我们只需要将其拖入我们的代码中，或者直接键入快捷键即可，十分的方便，当然，我们也可以将我们自己常用的代码块包装成模板，便于我们复用。 例如，我写如下的代码段： 1@property(nonatomic,copy)NSString * str; 将其选中，长按左键，直到鼠标变成箭头模样，然后将其拖入右下方的代码块模板区，会弹出如下设置菜单： title用来设置我们的代码块名称。 platform用来设置代码块可以使用的平台。 Language用来设置支持的编程语言。 completion用来设置快捷键入的快捷键，比如我们设置为pro 如果我们需要将其中的某些参数进行，替换，比如上面的NSString和str,我们想在编码时自定义他们，我们这样写： &lt;#NSString#&gt;*&lt;#str#&gt; 这时，界面就变成了如下这样： 我们点击Done后，在代码中输入pro会自动提示出这段代码段，变成方便了许多。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"iOS中RunLoop机制浅探","slug":"103iOS中RunLoop机制浅探","date":"2015-08-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.315Z","comments":true,"path":"2015/08/13/103iOS中RunLoop机制浅探/","link":"","permalink":"http://huishao.cc/2015/08/13/103iOS中RunLoop机制浅探/","excerpt":"","text":"iOS中RunLoop机制浅探一、浅识RunLoopRunLoop这个家伙在iOS开发中，我们一直在用，却从未注意过他，甚至都不从见过他的面孔，那个这个神秘的家伙究竟是做什么的？首先，我们先来观察一下我们的程序运行机制。 无论是面向对象的语言或是面向过程的语言，代码的执行终究是面向过程的。线程也一样，一个线程从开始代码执行，到结束代码销毁。就像HELLO WORLD程序，打印出字符串后程序就结束了，那么，我们的app是如何实现如下这样的机制的呢：app从运行开始一直处于待命状态，接收到类似点击事件等用户交互后执行相应操作，完成后继续等待交互响应，直到我们将程序杀死。通过这个过程的分析，我们可能会猜到，我们执行的主线程一定是在一个死循环中，没有任务的时候进行休眠，接收到任务后被激活执行任务。现在我们可以理解了，这样一个管理线程执行任务的机制就是RunLoop机制，线程在执行中的休眠与激活就是由RunLoop对象进行管理的。 二、RunLoop与线程的关系上面我们说到，RunLoop是用来管理线程的，那么他们直接有着怎样的关系，又是怎样进行交互的呢。事实上，每一个线程中都有一个Runloop对象，可以通过具体方法获得。这里有一点需要我们注意，官方文档上描述，虽然每一个线程中都可以获取RunLoop对象，但是并不是每一个线程中都有这个实例对象，我们可以这样理解：如果我们不获取runloop，这个runloop就不存在，我们获取时，如果不存在，就会去创建。在主线程中，这个MainRunLoop是默认创建并运行激活的。 三、认识NSRunLoopNSRunLoop是Cocoa框架中的类，与之对应，在Core Fundation中是CFRunLoopRef类。这两者的区别是前者不是线程安全的，而后者是线程安全的。我们这里只来讨论NSRunLoop的属性和方法： + (NSRunLoop *)currentRunLoop; 获取当前线程的RunLoop：有则获取，无则创建 + (NSRunLoop *)mainRunLoop ; 获取主线程的RunLoop @property (readonly, copy) NSString *currentMode; 获取当前runloop的执行模式，两种模式如下： NSString * const NSDefaultRunLoopMode; 默认模式，接收大部分输入源的响应 NSString * const NSRunLoopCommonModes; 多种模式的集合 - (CFRunLoopRef)getCFRunLoop; 获取RunLoop的CFRunLoopRef对象 - (void)addTimer:(NSTimer )timer forMode:(NSString )mode; 将定时器添加到runloop中 - (void)addPort:(NSPort )aPort forMode:(NSString )mode; 添加输入源端口到runloop中，NSPort对象可以理解为详细的载体，会传递消息与其代理。 - (void)removePort:(NSPort )aPort forMode:(NSString )mode; 将某个输入源端口移除 - (NSDate )limitDateForMode:(NSString )mode; 获取下个响应时间 解释：例如定时器的执行，其并不是按时间的间隔进行调用方法，而是在定时器注册到runloop中后，runloop会设置一个一个的时间点进行调用，比如10，20，30。如果错过了某个时间点，定时器并不会延时调用，而是直接等待下一个时间点调用，所以定时器并不是精准的。 - (void)acceptInputForMode:(NSString )mode beforeDate:(NSDate )limitDate; 在某个时间期限前接收响应 - (void)run;开始运行 - (void)runUntilDate:(NSDate *)limitDate; 到某个时间点运行 - (BOOL)runMode:(NSString )mode beforeDate:(NSDate )limitDate; 在某个期限前运行 四、RunLoop的应用正如前面所说，我们一直在使用他，却很少见到他。并且，我们在大多数情况下，都不需要显式的创建或者启动RunLoop，有两种情况，我们却必须手动设置它： 1、在分线程中使用定时器定时器的实现便是基于runloop的，平时我们使用定时器你或许并没有对runloop做什么操作，那是因为主线程的runloop默认是开启运行的，如果我们在分线程中也需要重复执行某一动作，如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(time) userInfo:nil repeats:YES]; &#125;); &#125;-(void)time&#123; NSLog(@&quot;run&quot;);&#125; 你会发现，程序运行后并没有打印任何信息，方法并没有被调用，我们必须在线程中手动的执行如下代码： 1 [[NSRunLoop currentRunLoop] run]; 定时器才能正常工作。 2、当你在线程中使用如下方法时某些延时函数和选择器在分线程中的使用，我们也必须手动开启runloop，这些方法如下： @interface NSObject (NSDelayedPerforming) - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes; - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay; + (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(id)anArgument; + (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget; - (void)performSelector:(SEL)aSelector target:(id)target argument:(id)arg order:(NSUInteger)order modes:(NSArray *)modes; - (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target; 五、补充RunLoop更强大的地方在于对消息的监听，因为CFRunLoopRef的线程安全优势，我们通常会更多使用后者。 细心的你可能会发现，输入源被注册进Runloop中时会有方法进行remove，但是定时器却没有，但是定时器中的invalidate方法可以将其从runloop中移除，正如官方文档的说明：invalidate是重要也是唯一的可以将定时器从runloop的注销的方法，所以如果我们创建了定时器，就一定要在不使用时调用invalidate方法。我不知道apple为何将定时器的方法分离开来，可能的原因是让开发者更少的显式调用runloop的方法，你若是知道原因，恳请留言指导。 关于定时器的问题，在另一篇博客中有介绍：[http://my.oschina.net/u/2340880/blog/398598](http://my.oschina.net/u/2340880/blog/398598)。 学习使用 欢迎转载 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中制作可复用的框架Framework","slug":"101iOS中制作可复用的框架Framework","date":"2015-08-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.315Z","comments":true,"path":"2015/08/12/101iOS中制作可复用的框架Framework/","link":"","permalink":"http://huishao.cc/2015/08/12/101iOS中制作可复用的框架Framework/","excerpt":"","text":"iOS中制作可复用的框架Framework在iOS开发中，我们时常会使用一些我们封装好的管理类，框架类，方法类等，我们在实现这些文件时，可能还会依赖一些第三方库或者系统库。如果每次我们复用这些代码时，都要将关联的这些东西进行导入，甚至还要进行arc和mrc的编译设置，会浪费我们很大的精力。除此之外，如果项目需要多人合作，你可能也并不希望你的源代码暴漏在所有人的面前，这个时候，我们就可以使用静态库或者动态库的方式来对我们的代码进行包装，便于复用。静态库的制作方法在一篇旧的博客中有描述：[http://my.oschina.net/u/2340880/blog/398887](http://my.oschina.net/u/2340880/blog/398887)。相比静态库文件，动态库的效率会更高且封装性更好，这里主要讨论动态库的制作。 xcode6后支持在xcode中制作动态库，并且过程也十分简单。 新建一个项目，选择framework： 之后我们在里面编写我们的代码，比如我们创建一个MyObject类： 123456789@interface MyObject : NSObject-(void)myLog;@end@implementation MyObject-(void)myLog&#123; NSLog(@&quot;framework&quot;);&#125;@end 和静态库类似，如果我们不做任何处理，打包出来的库文件只能在模拟器或者只能在真机上使用，为了方便我们调试，我们可以添加一个脚本命令，是的生成一个同时支持模拟器和真机的framework： 新建target： 选择Aggregate： 之后，我们在target的Build Phases中点击加号： 添加一个Run Script： 在里面添加如下的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556set -eset +u# Avoid recursively calling this script.if [[ $SF_MASTER_SCRIPT_RUNNING ]]thenexit 0fiset -uexport SF_MASTER_SCRIPT_RUNNING=1SF_TARGET_NAME=$&#123;PROJECT_NAME&#125;SF_EXECUTABLE_PATH=&quot;$&#123;SF_TARGET_NAME&#125;.framework/$&#123;SF_TARGET_NAME&#125;&quot;SF_WRAPPER_NAME=&quot;$&#123;SF_TARGET_NAME&#125;.framework&quot;if [[ &quot;$SDK_NAME&quot; =~ ([A-Za-z]+) ]]thenSF_SDK_PLATFORM=$&#123;BASH_REMATCH[1]&#125;elseecho &quot;Could not find platform name from SDK_NAME: $SDK_NAME&quot;exit 1fiif [[ &quot;$SDK_NAME&quot; =~ ([0-9]+.*$) ]]thenSF_SDK_VERSION=$&#123;BASH_REMATCH[1]&#125;elseecho &quot;Could not find sdk version from SDK_NAME: $SDK_NAME&quot;exit 1fiif [[ &quot;$SF_SDK_PLATFORM&quot; = &quot;iphoneos&quot; ]]thenSF_OTHER_PLATFORM=iphonesimulatorelseSF_OTHER_PLATFORM=iphoneosfiif [[ &quot;$BUILT_PRODUCTS_DIR&quot; =~ (.*)$SF_SDK_PLATFORM$ ]]thenSF_OTHER_BUILT_PRODUCTS_DIR=&quot;$&#123;BASH_REMATCH[1]&#125;$&#123;SF_OTHER_PLATFORM&#125;&quot;elseecho &quot;Could not find platform name from build products directory: $BUILT_PRODUCTS_DIR&quot;exit 1firm -rf buildProductsmkdir buildProducts# Build the other platform.xcrun xcodebuild -project &quot;$&#123;PROJECT_FILE_PATH&#125;&quot; -target &quot;$&#123;TARGET_NAME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION&#125;&quot; -sdk $&#123;SF_OTHER_PLATFORM&#125;$&#123;SF_SDK_VERSION&#125; BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION# Smash the two static libraries into one fat binary and store it in the .frameworkxcrun lipo -create &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework/$PRODUCT_NAME&quot; &quot;$&#123;SF_OTHER_BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework/$PRODUCT_NAME&quot; -output &quot;$&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME&quot;cp -rf $&#123;BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework $&#123;PROJECT_DIR&#125;/buildProductsmv $&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME $&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME.framework 接着，我们需要将给外界的接口文件暴露出来，将其移动到public下即可： 之后我们运行程序，需要注意的一点事，如果要支持64位，需要在编译选项中设置，如下： 到此时，我们的framework库文件就制作完成，在xcode的window-&gt;projects中选中我们的这个项目，点击进入文件夹的小箭头： 在build-&gt;product中便可以找到我们的framework文件，我们将其赋值出来即可以使用。 我们测试一下，新建一个工程，将刚才制作的静态库导入，如下加入头文件，调用方法，可以使用。 123#import &lt;MyFramework/MyObject.h&gt; MyObject * obj = [[MyObject alloc]init]; [obj myLog]; 两个技巧： 一、如果你运行程序出现类似Reason: image not found!的崩溃信息，可能的原因是动态库文件中的某些文件你的项目中已经包含了，在Build Phases中将required改成optional即可。 二、一个优秀且完整的框架可能会包含相当多的文件，包括框架自己的和其他第三方的，为了使用的方便，我们可以将头文件都导入一个的头文件中，这里有一个地方我们需要注意，我们直接在framework工程中添加的头文件是不会编译的，我的解决方案是通过建一个OC的类，在这个类中导入这个总的头文件，将这个类隐藏成私有的，就可以解决问题了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"iOS多线程开发之深入GCD","slug":"100iOS多线程开发之深入GCD","date":"2015-08-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.315Z","comments":true,"path":"2015/08/11/100iOS多线程开发之深入GCD/","link":"","permalink":"http://huishao.cc/2015/08/11/100iOS多线程开发之深入GCD/","excerpt":"","text":"iOS多线程开发之深入GCD一、前言在以前的一些系列博客中，对iOS中线程的管理做了总结，其中涵盖了GCD的相关基础知识：[http://my.oschina.net/u/2340880/blog/417746](http://my.oschina.net/u/2340880/blog/417746)。那里面将GCD的线程管理能力，列队组能力，通过信号和消息控制程序流程的能力都有介绍，这里，我们继续深入GCD的功能，通过GCD来处理一些逻辑更加复杂的代码功能。 二、延时追加任务当我们在程序中处理延时任务的时候，我们一般会通过两种方式，一种是通过定时器进行延时执行，另外一种是通过如下的函数： - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay; 然而，如果我们需要在多线程中进行延时操作，上面两种方式会显得十分麻烦，并且徒增代码的复杂度。GCD为我们提供了一种方式： void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); 这个方法有三个参数，第一个参数延时的时间，第二个参数为将任务加入的队列，第三个block为要执行的任务。示例如下： 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;1233&quot;); &#125;); 这里通过dispatch_time来创建时间对象，将打印信息的方法在3S后加入主线程队列。需要注意的是，这里只是将任务延时加入队列，并不是执行，如果是加入同步队列中，则会进入等待状态。 三、数据存取的线程安全问题在进行多线程编程时，或许总会遇到一类问题，数据的竞争与线程的安全。这些问题如果我们通过程序手动来控制难度将会非常大。GCD同样为我们简单的解决了这样的问题。 首先，如果只是在读取数据，而不对数据做任何修改时，我们并不需要处理安全问题，可以让多个任务同时进行读取，可是如果要对数据进行写的操作，那么在同一时间，我们就必须只能有一个任务在写，GCD中有一个方法帮我们完美的解决了这个问题，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839//创建一个队列dispatch_queue_t queue = dispatch_queue_create(&quot;oneQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //几个任务同时读操作 dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read1:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read2:%d&quot;,i); &#125; &#125;); //此处进行写操作 /* 下面这个函数在加入队列时不会执行，会等待已经开始的异步执行全部完成后再执行，并且在执行时，会阻塞其他任务 执行完成后，其他任务重新进入异步执行 */ dispatch_barrier_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;write:%d&quot;,i); &#125; &#125;); //继续进行异步读操作 dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read3:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read4:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read5:%d&quot;,i); &#125; &#125;); 打印信息如下： 可以看出，读操作是异步进行的，写操作是等待后阻塞任务队列独立进行，结束后队列恢复异步执行读操作，这正是我们需要的效果。 四、GCD模式的单例通常情况下，我们的单例会是如下的样子： 1234567+(instancetype)shared&#123; static Auto * obj; if (obj==nil) &#123; obj = [[Auto alloc]init]; &#125; return obj;&#125; 这种通过读取静态变量的方式在大多数情况下是没问题的，可是并不能保证程序百分百的安全，因为在多线程的操作中，会有可能初始化多个对象，在GCD中，我们可以使用如下方式： 12345678910+(instancetype)shared&#123; static Auto * obj; //dispatch_once_t对象可以只保证执行一次 static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; obj = [[Auto alloc]init]; &#125;); return obj; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS视频功能模块的开发","slug":"99iOS视频功能模块的开发","date":"2015-08-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.411Z","comments":true,"path":"2015/08/10/99iOS视频功能模块的开发/","link":"","permalink":"http://huishao.cc/2015/08/10/99iOS视频功能模块的开发/","excerpt":"","text":"iOS视频功能模块的开发一、使用MPMoviePlayerController进行视频播放MPMoviePlayerController是iOS中进行视频播放开发的一个控制类，里面涵盖了视频播放中大部分的需求功能，在使用这个框架时，需要导入头文件&lt;MediaPlayer/MediaPlayer.h&gt;。 1、初始化方法MPMoviePlayerController可以播放网络视频，也可以播放本地视频，通过不同的URL来进行初始化，例如本地视频的初始化如下： 123456//视频文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;mp4&quot;]; //视频URL NSURL *url = [NSURL fileURLWithPath:path]; //视频播放对象 MPMoviePlayerController * movie = [[MPMoviePlayerController alloc] initWithContentURL:url]; 初始化和完成相关配置后，我们需要将MPMoviePlayerController对象的View添加在我们需要的UI视图上，这个控制器只提供的控制的相关功能，外部的UI并没有为我们提供好。 2、相关属性与方法@property (nonatomic, copy) NSURL *contentURL; 视频文件的url地址 @property (nonatomic, readonly) UIView *view; 播放器view，在使用之前，必须设置frame大小，然后将其添加在我们的UI视图上 @property (nonatomic, readonly) UIView *backgroundView; 播放器背景颜色 @property (nonatomic, readonly) MPMoviePlaybackState playbackState; 播放器的当前播放状态，枚举定义如下： 12345678typedef NS_ENUM(NSInteger, MPMoviePlaybackState) &#123; MPMoviePlaybackStateStopped,//停止播放 MPMoviePlaybackStatePlaying,//正在播放 MPMoviePlaybackStatePaused,//暂停播放 MPMoviePlaybackStateInterrupted,//中断播放 MPMoviePlaybackStateSeekingForward,//快进 MPMoviePlaybackStateSeekingBackward//快退&#125;; @property (nonatomic, readonly) MPMovieLoadState loadState; 播放器的网络缓存状态，枚举定义如下： 123456typedef NS_OPTIONS(NSUInteger, MPMovieLoadState) &#123; MPMovieLoadStateUnknown = 0,//状态未知 MPMovieLoadStatePlayable = 1 &lt;&lt; 0,//缓存数据足够开始播放，但是视频并没有缓存完全 MPMovieLoadStatePlaythroughOK = 1 &lt;&lt; 1, //已经缓存完成，如果设置了自动播放，这时会自动播放 MPMovieLoadStateStalled = 1 &lt;&lt; 2, //数据缓存已经停止，播放将暂停&#125;; @property (nonatomic) MPMovieControlStyle controlStyle; 播放器风格，枚举如下: 1234567typedef NS_ENUM(NSInteger, MPMovieControlStyle) &#123; MPMovieControlStyleNone, // 无控制器 MPMovieControlStyleEmbedded, // 嵌入视频风格 MPMovieControlStyleFullscreen, // 全屏播放风格 MPMovieControlStyleDefault = MPMovieControlStyleEmbedded&#125;; @property (nonatomic) MPMovieRepeatMode repeatMode; 播放器的循环模式，枚举如下： 1234typedef NS_ENUM(NSInteger, MPMovieRepeatMode) &#123; MPMovieRepeatModeNone,//播放结束后不循环 MPMovieRepeatModeOne//循环&#125;; @property (nonatomic) BOOL shouldAutoplay; 是否开启自动播放 @property (nonatomic, getter=isFullscreen) BOOL fullscreen; 设置是否充满屏幕 - (void)setFullscreen:(BOOL)fullscreen animated:(BOOL)animated; 设置是否充满屏幕，带动画效果 @property (nonatomic) MPMovieScalingMode scalingMode; 设置播放器的填充方式，枚举定义如下： 123456typedef NS_ENUM(NSInteger, MPMovieScalingMode) &#123; MPMovieScalingModeNone, // 无缩放 MPMovieScalingModeAspectFit, // 适应大小模式 MPMovieScalingModeAspectFill, // 充满可视范围，可能会被裁剪 MPMovieScalingModeFill // 缩放到充满视图&#125;; @property (nonatomic, readonly) BOOL readyForDisplay NS_AVAILABLE_IOS(6_0); 返回YES说明数据栈已经缓存好数据，返回NO则没有缓存好 @property (nonatomic, readonly) MPMovieMediaTypeMask movieMediaTypes; 数据文件的格式，枚举如下： 12345typedef NS_OPTIONS(NSUInteger, MPMovieMediaTypeMask) &#123; MPMovieMediaTypeMaskNone = 0,//格式未知 MPMovieMediaTypeMaskVideo = 1 &lt;&lt; 0,//音频格式 MPMovieMediaTypeMaskAudio = 1 &lt;&lt; 1//视频格式&#125;; @property (nonatomic) MPMovieSourceType movieSourceType; 视频的数据类型，枚举如下： 12345typedef NS_ENUM(NSInteger, MPMovieSourceType) &#123; MPMovieSourceTypeUnknown,//类型未知 MPMovieSourceTypeFile, // 文件类型 MPMovieSourceTypeStreaming // 数据流&#125;; @property (nonatomic, readonly) NSTimeInterval duration; 视频文件的时长 @property (nonatomic, readonly) NSTimeInterval playableDuration; 缓存完成能够播放的时长 @property (nonatomic, readonly) CGSize naturalSize; 视频的原始大小 @property (nonatomic) NSTimeInterval initialPlaybackTime; 播放器开始播放的时间 @property (nonatomic) NSTimeInterval endPlaybackTime; 播放器结束播放的时间 @property (nonatomic) BOOL allowsAirPlay; 是否允许云端播放 - (void)requestThumbnailImagesAtTimes:(NSArray *)playbackTimes timeOption:(MPMovieTimeOption)optio; 获取视频某一些时间点的缩略图，参数枚举如下，生成缩略图的数据回调在后面的通知中详说： 1234typedef NS_ENUM(NSInteger, MPMovieTimeOption) &#123; MPMovieTimeOptionNearestKeyFrame,//使用最近的关键帧生成缩略图 MPMovieTimeOptionExact//使用精确的当前帧生成缩略图&#125;; 与播放控制相关的方法如下： 1234567891011121314151617181920//调用这个方法进行播放视频的准备工作- (void)prepareToPlay;//获取播放器的准备工作是否就绪@property(nonatomic, readonly) BOOL isPreparedToPlay;//调用此方法进行视频的播放- (void)play;//调用此方法进行视频播放的暂停操作- (void)pause;//调用此方法停止视频播放- (void)stop;//当前视频已播放的时间@property(nonatomic) NSTimeInterval currentPlaybackTime;//当前视频的播放速度@property(nonatomic) float currentPlaybackRate;//调用此方法进行快进操作- (void)beginSeekingForward;//调用此方法进行快退操作- (void)beginSeekingBackward;//调用此方法结束快进或者快退操作- (void)endSeeking; 3、系统相关通知MPMoviePlayerController的系统回调并没有采用代理的设计模式，而是采用的系统发通知，我们注册观察者，接收我们需要的通知。举例几种常用通知如下： NSString * const MPMoviePlayerScalingModeDidChangeNotification; 播放器缩放产生改变时发送的通知 NSString * const MPMoviePlayerPlaybackDidFinishNotification; 播放结束时发送的通知 NSString * const MPMoviePlayerPlaybackStateDidChangeNotification; 播放状态改变时发送的通知 NSString * const MPMoviePlayerLoadStateDidChangeNotification; 缓冲状态改变时发送的通知 NSString * const MPMoviePlayerNowPlayingMovieDidChangeNotification; 当前播放的视频改变时发送的通知 NSString * const MPMoviePlayerWillEnterFullscreenNotification; 将要进入全屏模式时发送的通知 NSString * const MPMoviePlayerDidEnterFullscreenNotification; 已经进入全屏时发送的通知 NSString * const MPMoviePlayerWillExitFullscreenNotification; 将要退出全屏时发送的通知 NSString * const MPMoviePlayerDidExitFullscreenNotification; 已经退出全屏时发送的通知 NSString * const MPMoviePlayerThumbnailImageRequestDidFinishNotification; 获取缩略图完成时发送的通知 二、MPMoviePlayerViewController视频视图控制器如果你很熟悉MVC，你可能会觉得MPMoviePlayerController的设计模式非常蹩脚，强行要求你将控制器的视图分离出来加在另外的UI上，徒增的代码逻辑的混乱，那么你想的没错，MPMoviePlayerViewController可能就是为了解决这个问题。 MPMoviePlayerViewController将视图封装在了一起，其中有一个成员对象是MPMoviePlayerController类型，类似C++中的has-a逻辑，我们只需要对MPMoviePlayerViewController进行的简单的初始化后，对其中MPMoviePlayerController进行其他配置，之后通过模态跳转切换控制器即可。 方法如下： - (instancetype)initWithContentURL:(NSURL *)contentURL; 初始化方法，和上面类似 @property (nonatomic, readonly) MPMoviePlayerController *moviePlayer; 播放器对象 - (void)presentMoviePlayerViewControllerAnimated:(MPMoviePlayerViewController *)moviePlayerViewController; - (void)dismissMoviePlayerViewControllerAnimated; viewController的模态跳转方法，也可以通过导航push与pop 代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface ViewController2 ()@property(nonatomic,strong)MPMoviePlayerController * movie;@property(nonatomic,strong)MPMoviePlayerViewController * viewController;@end@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self playMovie:@&quot;111&quot;];&#125;-(void)playMovie:(NSString *)fileName&#123; //视频文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;mp4&quot;]; //视频URL NSURL *url = [NSURL fileURLWithPath:path]; //视频播放对象 _viewController = [[MPMoviePlayerViewController alloc]initWithContentURL:url]; _movie=_viewController.moviePlayer; // 注册一个播放结束的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(myMovieFinishedCallback:) name:MPMoviePlayerPlaybackDidFinishNotification object:_movie]; _movie.fullscreen=YES;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_movie play]; [self presentViewController:_viewController animated:YES completion:nil];&#125;-(void)myMovieFinishedCallback:(NSNotification*)notify&#123; //视频播放对象 MPMoviePlayerController* theMovie = [notify object]; //销毁播放通知 [[NSNotificationCenter defaultCenter] removeObserver:self name:MPMoviePlayerPlaybackDidFinishNotification object:theMovie]; [theMovie.view removeFromSuperview]; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C中runtime机制的应用","slug":"98Objective-C中runtime机制的应用","date":"2015-08-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.411Z","comments":true,"path":"2015/08/07/98Objective-C中runtime机制的应用/","link":"","permalink":"http://huishao.cc/2015/08/07/98Objective-C中runtime机制的应用/","excerpt":"","text":"Objective-C中runtime机制的应用一、初识runtimeObjective-C是一种动态语言，所谓动态语言，是在程序执行时动态的确定变量类型，执行变量类型对应的方法的。因此，在Object-C中常用字符串映射类的技巧来动态创建类对象。因为OC的动态语言特性，我们可以通过一些手段，在程序运行时动态的更改对象的变量甚至方法，这就是我们所说的runtime机制。 二、你还有什么办法操作这样的变量么？首先，我们先来看一个例子，这里有我创建的一个MyObject类： 1234567891011121314151617181920212223242526272829303132//.h===========================@interface MyObject : NSObject&#123; @private int privateOne; NSString * privateTow;;&#125;@end//=============================//.m===========================@interface MyObject()&#123; @private NSString * privateThree;&#125;@end@implementation MyObject- (instancetype)init&#123; self = [super init]; if (self) &#123; privateOne=1; privateTow=@&quot;Tow&quot;; privateThree=@&quot;Three&quot;; &#125; return self;&#125;-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;one=%d\\ntow=%@\\nthree=%@\\n&quot;,privateOne,privateTow,privateThree];&#125;@end//============================= 这个类是相当的安全，首先，在头文件中没有提供任何的方法接口，我们没有办法使用点语法做任何操作，privateOne和PrivateTow两个变量虽然声明在了头文件中，却是私有类型的，通过指针的方式我们虽然可以看到他们，却不能做任何读取修改的操作，xcode中的提示如下： 他会告诉我们，这是一个私有的变量，我们不能使用。对于privateThree，我们更是束手无策，不仅不能使用，我们甚至都看不到它的存在。那么对于这种情况，你有什么办法操作这些变量么？对，是时候展现真正的技术了：runtime! 三、通过runtime获取对象的变量列表要操作对象的变量，我们首先应该要捕获这些变量，让他们无处遁形。无论声明在头文件或是实现文件，无论类型是公开的还是私有的，只要声明了这个变量，系统就会为其分配空间，我们就可以通过runtime机制捕获到它，代码如下： 123456789101112131415161718192021222324252627282930313233343536#import &quot;ViewController.h&quot;#import &quot;MyObject.h&quot;//包含runtime头文件#import &lt;objc/runtime.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //我们先声明一个unsigned int型的指针，并为其分配内存 unsigned int * count = malloc(sizeof(unsigned int)); //调用runtime的方法 //Ivar：方法返回的对象内容对象，这里将返回一个Ivar类型的指针 //class_copyIvarList方法可以捕获到类的所有变量，将变量的数量存在一个unsigned int的指针中 Ivar * mem = class_copyIvarList([MyObject class], count); //进行遍历 for (int i=0; i&lt; *count ; i++) &#123; //通过移动指针进行遍历 Ivar var = * (mem+i); //获取变量的名称 const char * name = ivar_getName(var); //获取变量的类型 const char * type = ivar_getTypeEncoding(var); NSLog(@&quot;%s:%s\\n&quot;,name,type); &#125; //释放内存 free(count); //注意处理野指针 count=nil;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 打印结果如下，其中i表示int型： 是不是小吃惊了一下，无论变量在哪里，只要它在，就让它无处遁形。 四、让我找到你，就让我改变你！仅仅能够获得变量的类型和名字或许并没有什么卵用，没错，我们获取变量的目的不是为了观赏，而是为了操作它，这对runtime来说，也是小事一碟。代码如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; //获取变量 unsigned int count; Ivar * mem = class_copyIvarList([MyObject class],&amp;count); //创建对象 MyObject * obj = [[MyObject alloc]init]; NSLog(@&quot;before runtime operate:%@&quot;,obj); //进行变量的设置 object_setIvar(obj, mem[0],10); object_setIvar(obj, mem[1], @&quot;isTow&quot;); object_setIvar(obj, mem[2], @&quot;isThree&quot;); NSLog(@&quot;after runtime operate:%@&quot;,obj); &#125; Tip:在修改int型变量的时候，你或许会遇到一个问题，ARC下，编译器不允许你将int类型的值赋值给id，在buildset中将Objective-C Automatic Reference Counting修改为No即可。 打印效果如下： 可以看到，那些看似非常安全的变量被我们修改了。 五、让我看看你的方法吧变量通过runtime机制我们可以取到和改变值，那么我们再大胆一点，试试那些私有的方法，首先我们在MyObject类中添加一些方法，我们只实现，并不声明他们： 1234567891011121314151617181920212223242526@interface MyObject()&#123; @private NSString * privateThree;&#125;@end@implementation MyObject- (instancetype)init&#123; self = [super init]; if (self) &#123; privateOne=1; privateTow=@&quot;Tow&quot;; privateThree=@&quot;Three&quot;; &#125; return self;&#125;-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;one=%d\\ntow=%@\\nthree=%@\\n&quot;,privateOne,privateTow,privateThree];&#125;-(NSString *)method1&#123; return @&quot;method1&quot;;&#125;-(NSString *)method2&#123; return @&quot;method2&quot;;&#125; 这样的方法我们在外面是无法调用他们的，和操作变量的思路一样，我们先要捕获这些方法： 12345678 //获取所有成员方法 Method * mem = class_copyMethodList([MyObject class], &amp;count); //遍历 for(int i=0;i&lt;count;i++)&#123; SEL name = method_getName(mem[i]); NSString * method = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@\\n&quot;,method); &#125; 打印如下： 得到了这些方法名，我们大胆的调用即可： 12 MyObject * obj = [[MyObject alloc]init]; NSLog(@&quot;%@&quot;,[obj method1]); Tip:这里编译器不会给我们方法提示，放心大胆的调用即可。 六、动态的为类添加方法这个runtime机制最强大的部分要到了，试想，如果我们可以动态的向类中添加方法，那将是一件多么令人激动的事情，注意，这里是动态的添加，和类别的最大不同在于这种方式是运行时才决定是否添加方法的。 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; //添加一个新的方法，第三个参数是返回值的类型v是void,i是int，：是SEL，对象是@等 class_addMethod([MyObject class], @selector(method3), (IMP)logHAHA, &quot;v&quot;); unsigned int count = 0; Method * mem = class_copyMethodList([MyObject class], &amp;count); for(int i=0;i&lt;count;i++)&#123; SEL name = method_getName(mem[i]); NSString * method = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@\\n&quot;,method); &#125; MyObject * obj = [[MyObject alloc]init]; //运行这个方法 [obj performSelector:@selector(method3)]; &#125;//方法的实现void logHAHA()&#123; NSLog(@&quot;HAHA&quot;);&#125; 运行结果如下： 从前五行可以看出，方法已经加进去了，从最后一行可以看出，执行没有问题。 七、做点小手脚程序员总是得寸进尺的，现在，我们要做点事情，用我们的函数替换掉类中的函数： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; MyObject * obj = [[MyObject alloc]init]; //替换之前的方法 NSLog(@&quot;%@&quot;, [obj method1]); //替换 class_replaceMethod([MyObject class], @selector(method1), (IMP)logHAHA, &quot;v&quot;); [obj method1]; &#125;void logHAHA()&#123; NSLog(@&quot;HAHA&quot;);&#125; 打印如下： 这次够cool吧，通过这个方法，我们可以把系统的函数都搞乱套。当然，runtime还有许多很cool的方法： id object_copy(id obj, size_t size) 拷贝一个对象 id object_dispose(id obj) 释放一个对象 const char *object_getClassName(id obj) 获取对象的类名 ive void method_exchangeImplementations(Method m1, Method m2)交换两个方法的实现 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Cocos2d-x-v3中3D网格特效动画的应用","slug":"97Cocos2d-x-v3中3D网格特效动画的应用","date":"2015-08-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.411Z","comments":true,"path":"2015/08/06/97Cocos2d-x-v3中3D网格特效动画的应用/","link":"","permalink":"http://huishao.cc/2015/08/06/97Cocos2d-x-v3中3D网格特效动画的应用/","excerpt":"","text":"Cocos2d-x-v3中3D网格特效动画的应用一、网格特效的使用原理基础的动作是对节点整体进行移动，变形等操作，网格特效的原理是将节点分割成多个尺寸相同的网格，根据改变每个网格块的属性使整体节点产生3D的效果。 二、网格特效的基本用法在cocos2d-x中，v3的版本新引入了一个类NodeGrid，专门用来包装网格的特效，示例如下： 12345678910111213141516 //获取屏幕尺寸 Size visibleSize = Director::getInstance()-&gt;getVisibleSize(); Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin(); //加载精灵 auto sprite = Sprite::create(&quot;HelloWorld.png&quot;); sprite-&gt;setPosition(Vec2(visibleSize.width/2+origin.x, visibleSize.height/2+origin.y)); //创建网格特效包装类 NodeGrid * nodeg = NodeGrid::create(); nodeg-&gt;setPosition(Vec2::ZERO); //添加播放特效的精灵 nodeg-&gt;addChild(sprite); this-&gt;addChild(nodeg); //参数的含义 分别是 执行时间，切分的网格大小，波浪次数，波浪大小 Waves3D * ani3d = Waves3D::create(2, Size(15, 15), 6, 4); //执行特效 nodeg-&gt;runAction(ani3d); 三、系统提供的网格特效static Waves3D* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude); 创建波浪3D效果，参数含义为：执行时间，网格尺寸，波浪次数，波浪大小 static FlipX3D* create(float duration); 以x为轴进行翻转 static FlipY3D* create(float duration); 以y为轴进行翻转 static Lens3D* create(float duration, const Size&amp; gridSize, const Vec2&amp; position, float radius); 创建镜头的3D效果，参数为：执行时间，网格大小，镜头中心，镜头半径 static Ripple3D* create(float duration, const Size&amp; gridSize, const Vec2&amp; position, float radius, unsigned int waves, float amplitude); 创建波纹特效，参数为：执行时间，网格大小，波纹中心，波纹半径，波纹计数，振幅 static Shaky3D* create(float initWithDuration, const Size&amp; gridSize, int range, bool shakeZ); 创建震动特效，参数为：执行时间，网格大小，震动范围，是否波动z轴 static Liquid* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude); 创建液体特效，参数为：执行时间，网格尺寸，流动次数，幅度 static Waves* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical); 创建平面波纹特效，参数为：执行时间，网格尺寸，波纹次数，波纹振幅，开关横向波纹，开关纵向波纹 static Twirl* create(float duration, const Size&amp; gridSize, Vec2 position, unsigned int twirls, float amplitude);创建扭曲旋转的特效，参数为：执行时间，网格尺寸，扭曲旋转中心，旋转次数，旋转幅度 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Xcode中修改变量名、类名及字符串的替换操作","slug":"94Xcode中修改变量名、类名及字符串的替换操作","date":"2015-08-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.410Z","comments":true,"path":"2015/08/05/94Xcode中修改变量名、类名及字符串的替换操作/","link":"","permalink":"http://huishao.cc/2015/08/05/94Xcode中修改变量名、类名及字符串的替换操作/","excerpt":"","text":"Xcode中修改变量名、类名及字符串的替换操作在做iOS开发代码优化的工作时，优化代码结构之前，我们应该先整理好工程的外貌，将文件和类的命名进行规范，在Xcode中为我们提供了方便而强大的名称修改功能。 第一步：修改类名 将鼠标点击放在类的名称上，选择Xcode工具栏中的edit-&gt;refactor-&gt;rename： 之后，将类名更改为我们需要的模式点击preview，记得将下面的关联文件勾选： Xcode会为我们检测出需要更改的地方，浏览无误后点击save。 第二步 修改相关字符串： 通过第一步，我们的类的文件名，类名都已经更改，但并不全面，因为某些注释，字符串动态创建类对象以及类函数创建类对象时的类名并没有更改，我们需要做这一步，将更改前的类名在Xcode左侧的搜索栏中搜索： ![](http://static.oschina.net/uploads/space/2015/0805/093235_ZPfC_2340880.png) 将Find改选为Replace： 这里面有四个选项，意义如下： Containing:检索出包涵检索条件的对象 Matching:检索出等于检索条件的对象 Start With：检索出以检索条件开头的对象 Ending with:检索出以检索条件结尾的对象 我们选择Matching，进行检索，将检索出来的地方进行Replace替换，通过这一步，我们可以替换代码中的注释，字符串，类方法以及xib和StoryBoard文件中关联的id，cell复用符等。 第三步：修改文件中变量名 在文件中，我们也可以通过command+F换出搜索框，将Find改选为Replace检索进行我们想要的变量替换。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"Cocos2d-x-v3动作体系","slug":"95Cocos2d-x-v3动作体系","date":"2015-08-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.411Z","comments":true,"path":"2015/08/05/95Cocos2d-x-v3动作体系/","link":"","permalink":"http://huishao.cc/2015/08/05/95Cocos2d-x-v3动作体系/","excerpt":"","text":"Cocos2d-x-v3动作体系cocos2d-x-v3版本v2的版本有的很大的改动，最直观的是在一些函数的改动和类名的改动上，首先以CC开头的类，都不再使用CC。在我个人的理解上，原来的cocos2d-x是完全从iphone的框架cocos2d移植过来的，代码的风格和编程的思想都及类似于Object-C，除了语法是C++的外，其他就像是OC版的翻译，新的版本更好的体现了跨平台的特性，也更多的运用了C++的一些编码思想和语言特点，更易于各平台的开发者使用。这篇博客的主要内容，是总结cocos2d中行为动作的处理方法和相关函数。 一、瞬时动作 这类行为只能称为动作，不能称作动画，其执行是瞬时的，没有可是化的过程。 cocos2d中常用的瞬时动作有如下几种： FlipX：关于x轴做镜像变换。 FlipY：关于y轴做镜像变换。 Hide：隐藏。 Show：显示。 ToggleVisibility：切换隐藏和显示。 Place：将对象放置在某个位置。 二、延时动作延时动作就是动画，将动作的过程展现出来，cocos2d引擎中的几种延时动作如下： 1\\. MoveTo:将对象移动到某一位置，是绝对位置，移动后不会记录对象的原始位置，动作不能进行反转。例如： 12auto action = MoveTo::create(2, Vec2(100, 100));//2S时间移动到(100,100) label-&gt;runAction(action);//执行动作 2.MoveBy:将对象相对现在的位置移动某个距离，这个移动是相对对象当前位置的，可以反转。 3.JumpTo:和MoveTo类似，对象跳动到某一位置，例如： 1label-&gt;runAction(JumpTo::create(2, Vec2(100, 100), 30, 3));//对象在2S内跳三次，每次高度为30像素，跳到(100,100)点 4.JumpBy:和MoveBy类似。 5.BezierTo:以贝塞尔曲线的方式移动到某一位置，例如： 123456ccBezierConfig config; config.controlPoint_1=Vec2(300, 300); config.controlPoint_2=Vec2(200,200); config.endPosition=Vec2(100, 100);//设置两个中间点和一个终点 label-&gt;runAction(BezierTo::create(2, config));//2S时间通过贝塞尔曲线方式移动 6.BezierBy:以贝塞尔曲线的方式进行相对移动。 7.ScaleTo:相对原始大小缩放到某一尺度。 8.ScaleBy:相对目前大小进行缩放。 9.RotateTo:相对原始状态旋转到某一角度。 10.RotateBy：相对目前转台旋转某个角度。 11.Blink:闪烁动画。 12.TintTo：颜色转化到某一色值 13.TintBy:相对目前色值，颜色相对转变某一色值。 14.FadeTo:变暗到某一透明度 15.FadeIn:淡入动作 16.FadeOut：淡出动作 三、动作的组合方式 cocos2d中不仅为我们提供的各种动作方式，也为我们提供了相关的类用于管理这些动作： 1.动作序列Sequence：这个类可以创建一个动作序列，按序列中动作的顺序依次执行动作，如下： 12 Sequence * sq= Sequence::create(TintTo::create(2, Color3B(123, 123, 123)),RotateTo::create(2, 30), NULL); label-&gt;runAction(sq);//创建动作序列，使对象执行先变颜色，在旋转的动画 2.同步动作组Spawn：这个类和Sequence类似，只是他里面的动画会同时一起执行。 3.有限次的循环动作Repeat：这个类可以使某一动作循环执行数次，例如： 12Repeat * re = Repeat::create(RotateBy::create(2, 30), 5);//旋转5次30度 label-&gt;runAction(re); 4.无限次循环动作RepeatForever： 12RepeatForever * ref = RepeatForever::create(RotateBy::create(2, 30)); label-&gt;runAction(ref); 5.帧动画 cocos2d中同样提供了对帧动画的支持： 12345678910111213141516 //创建设置精灵 Sprite * spr = Sprite::create( &quot;CloseNormal.png&quot;); spr-&gt;setPosition(Vec2(100, 100)); //创建两帧精灵图片 SpriteFrame * frame1 = SpriteFrame::create(&quot;CloseNormal.png&quot;, Rect(0, 0, 50, 50)); SpriteFrame * frame2 = SpriteFrame::create(&quot;CloseSelected.png&quot;, Rect(0, 0, 50, 50)); Vector&lt;SpriteFrame *&gt; arr; arr.pushBack(frame1); arr.pushBack(frame2); //创建动画体 第一个参数是帧容器，第二个是每一帧的播放时间，第三个是循环次数 Animation * ani = Animation::createWithSpriteFrames(arr, 1, 1); //创建动作 Animate *ant = Animate::create(ani); RepeatForever * ref = RepeatForever::create(ant); spr-&gt;runAction(ref); this-&gt;addChild(spr); 6.反转动画 可以通过reverse方法获取动作的反转动作，例如： 12345auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/arial.ttf&quot;, 24); MoveBy * move = MoveBy::create(3, Vec2(100, 100)); Sequence * sq = Sequence::create(move,move-&gt;reverse(), NULL); label-&gt;runAction(sq); //label 会先相对移动(100,100)，再反移动回来 7.动作的速度控制 通过一些速度相关的类，cocos2d可以很轻松的创建出各种线性与非线性的动作。例如： 12345auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/arial.ttf&quot;, 24); MoveTo * move = MoveTo::create(3, Vec2(-200, -200)); EaseIn* an = EaseIn::create(move, 5); label-&gt;runAction(an);//label的运动会先慢后快，速度差为5倍 EaseIn:由慢变快，线性 EaseOut：由快变慢，线性 EaseInOut：由慢变快再由快变慢 EaseSineIn:由慢变快，正弦规律 EaseSineOut:由快变慢，正弦规律 EaseSineInOut：由慢变快再由快变慢，正弦规律 EaseExponentialIn:由慢变快,指数规律 EaseExponentialOut:由快变慢,指数规律 EaseExponentialInOut:由慢变快再由快变慢,指数规律 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Cocos2d-x-v3场景切换","slug":"96Cocos2d-x-v3场景切换","date":"2015-08-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.411Z","comments":true,"path":"2015/08/05/96Cocos2d-x-v3场景切换/","link":"","permalink":"http://huishao.cc/2015/08/05/96Cocos2d-x-v3场景切换/","excerpt":"","text":"Cocos2d-x-v3场景切换cocos2d中场景的切换采用的是包装的思想，通过创建一个专场效果类，将需要专场的场景进行包装。代码示例如下： 12 auto * scene = OtherScene::createScene();//创建一个场景 Director::getInstance()-&gt;replaceScene(TransitionFlipX::create(1, scene));//进行包装切换，第一个参数为切换时间，第二个为切换的场景 引擎为我们封装的特效有很多，函数方法如下： static TransitionRotoZoom create(float t, Scene scene); 旧的场景旋转缩小到中心点后再将新的场景旋转放大完成切换 static TransitionJumpZoom create(float t, Scene scene); 旧场景弹跳缩小移出，新场景弹跳方法完成切换 static TransitionMoveInL create(float t, Scene scene); 新的场景从左边切入(覆盖) static TransitionMoveInR create(float t, Scene scene); 新的场景从右边切入(覆盖) static TransitionMoveInT create(float t, Scene scene); 新的场景从上边切入(覆盖) static TransitionMoveInB create(float t, Scene scene); 新的场景从下边切入(覆盖) static TransitionSlideInL create(float t, Scene scene); 新的场景从左边推入 static TransitionSlideInR create(float t, Scene scene); 新的场景从右边推入 static TransitionSlideInT create(float t, Scene scene); 新的场景从上边推入 static TransitionSlideInB create(float t, Scene scene); 新的场景从下边推入 static TransitionShrinkGrow create(float t, Scene scene); 新的场景从后向前进行替换 static TransitionFlipX create(float t, Scene s, Orientation o); 场景以X为轴进行翻转切换，第三个参数为翻转的方向 static TransitionFlipY create(float t, Scene s, Orientation o); 场景以Y为轴进行翻转切换，第三个参数为翻转的方向 static TransitionFlipAngular create(float t, Scene s, Orientation o); 场景以对角线为轴进行翻转切换，第三个参数为翻转的方向 static TransitionZoomFlipX create(float t, Scene s, Orientation o); 场景以X轴进行翻转，带缩放效果 static TransitionZoomFlipY create(float t, Scene s, Orientation o); 场景以Y轴进行翻转，带缩放效果 static TransitionZoomFlipAngular create(float t, Scene s, Orientation o); 场景以对角线为轴进行翻转，带缩放效果 static TransitionFade create(float duration, Scene scene, const Color3B&amp; color); 场景以颜色过渡进行切换 static TransitionCrossFade create(float t, Scene scene); 场景淡出过渡切换 static TransitionTurnOffTiles create(float t, Scene scene); 场景瓦片溶解切换 static TransitionSplitCols create(float t, Scene scene); 场景纵向切割切换 static TransitionSplitRows create(float t, Scene scene); 场景横向切割切换 static TransitionFadeTR create(float t, Scene scene); 场景向右上角过滤切换 static TransitionFadeBL create(float t, Scene scene); 场景向左下角过滤切换 static TransitionFadeUp create(float t, Scene scene); 场景向上过滤切换 static TransitionFadeDown create(float t, Scene scene); 场景向下过滤切换 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Cocos2d-x-v3坐标体系","slug":"93Cocos2d-x-v3坐标体系","date":"2015-08-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.410Z","comments":true,"path":"2015/08/03/93Cocos2d-x-v3坐标体系/","link":"","permalink":"http://huishao.cc/2015/08/03/93Cocos2d-x-v3坐标体系/","excerpt":"","text":"Cocos2d-x坐标体系cocos2d引擎是一款非常优秀的扩平台的游戏开发引擎，在apple游戏榜上，有很多排名靠前的游戏都是由他创造出来的，他也有一套十分方便的坐标体系。 一、UI坐标体系UI坐标体系相对于移动开发人员来说再熟悉不过了，在iOS系统中，它就是frame体系，即坐标(0,0)点位于屏幕的左上角，向右x增大，向下y增大。 二、OpenGL坐标体系OpenGL坐标系是cocos2d中使用的坐标系，它更接近于数学上的坐标系，即(0,0)点位于屏幕的左下角，往左x增大，往上y增大。这套坐标系统也更符合物理世界的逻辑，便于游戏的开发。当然，这并不是说cocos2d中所有的坐标都是采用这个体系标准的，在手指点击事件层，接收到点击坐标点的坐标就是采用UI坐标系表示的。 三、世界坐标系简单的理解，世界坐标系就是绝对坐标系，在cocos2d中，精灵的坐标是相对于其父视图而言的，是相对的坐标，世界坐标则是统一绝对的坐标，在项目中是固定的。 四、相对坐标系最常用的坐标体系，任何类设置的坐标都是相对于其父视图原点的坐标。 五、坐标系的转换由于UI坐标系与OpenGL坐标系的差异，在开发中，我们有时需要其两个标准的相互转化，cocos2d中也未我们提供了相应的方法： Vec2 Director::convertToGL(const Vec2&amp; uiPoint); 这个方法将UI坐标系转换为OpenGL坐标系。 Vec2 Director::convertToUI(const Vec2&amp; glPoint); 这个方法将OpenGL坐标系转换为UI坐标系。 Vec2 Node::convertToWorldSpace(const Vec2&amp; nodePoint) const; 这个方法将物体的相对坐标 Vec2 Node::convertToNodeSpace(const Vec2&amp; worldPoint) const; 这个方法将世界坐标转化为某一节点的相对坐标。 还有两个转化的方法与上面类似，只有一点不同，这两个方法参照的原点不是系统默认的，而是我们设置的节点的锚点： Vec2 Node::convertToNodeSpaceAR(const Vec2&amp; worldPoint) const; Vec2 Node::convertToWorldSpaceAR(const Vec2&amp; nodePoint) const; 六、锚点锚点的概念可以理解为参照点，其设置范围为0-1，系统默认的节点锚点为(0,0)。在UI坐标系中，(0,0)点就是节点的左上角，在OpenGL坐标系中，(0,0)点就是节点的左下角。例如，如果我将锚点设置为(0.5,0.5),则在UI和OpenGL坐标系中，(0,0)点都是节点的中心点。又如，我将锚点设置为(1,1)，则在UI坐标系中，原点为右下角，在OpenGL坐标系中，原点为右上角，锚点的用处就是更改参考点，在另一种情形下，锚点对程序也会产生很大的影响，就是当我们设置一个节点旋转或者缩放时，节点会以锚点位置为中心进行旋转或缩放。 cocos2d中通过下面方法分别来设置和获取锚点： void Sprite::setAnchorPoint(const Vec2&amp; anchor); 设置锚点 const Vec2&amp; Node::getAnchorPoint() const; 获取锚点 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"iOS8新特性扩展(Extension)应用之四——自定义键盘控件","slug":"92iOS8新特性扩展(Extension)应用之四——自定义键盘控件","date":"2015-07-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.410Z","comments":true,"path":"2015/07/31/92iOS8新特性扩展(Extension)应用之四——自定义键盘控件/","link":"","permalink":"http://huishao.cc/2015/07/31/92iOS8新特性扩展(Extension)应用之四——自定义键盘控件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之四——自定义键盘控件iOS8系统的开放第三方键盘，使得用户在输入法的选择上更加自主灵活，也更加贴近不同语言的输入风格。这篇博客，将介绍如何开发一个第三方的键盘控件。 一、了解UIInputViewController类UIInputViewController是系统扩展支持键盘扩展的一个类，通过这个类，我们可以自定义一款我们自己的键盘提供给系统使用。 首先，我们先来看一下这个类中的一些属性和方法： @property (nonatomic, retain) UIInputView *inputView; 键盘的输入视图，我们可以自定义这个视图。 @property (nonatomic, readonly) NSObject *textDocumentProxy; 实现了UITextDocumentProxy协议的一个对象，后面会介绍这个协议。 @property (nonatomic, copy) NSString *primaryLanguage; 系统为我们准备了一些本地化的语言字符串 - (void)dismissKeyboard; 收键盘的方法 - (void)advanceToNextInputMode; 切换到下一输入法的方法 UITextDocumentProxy协议内容如下： 123456789@protocol UITextDocumentProxy &lt;UIKeyInput&gt;//输入的上一个字符@property (nonatomic, readonly) NSString *documentContextBeforeInput;//即将输入的一个字符@property (nonatomic, readonly) NSString *documentContextAfterInput;//将输入的字符移动到某一位置- (void)adjustTextPositionByCharacterOffset:(NSInteger)offset;@end 而UITextDocumentProxy这个协议继承与UIKeyInput协议，UIKeyInput协议中提供的两个方法用于输入字符和删除字符： - (void)insertText:(NSString *)text;- (void)deleteBackward; 二、创建一款最简单的数字输入键盘创建一个项目，作为宿主APP，接着我们File-&gt;new-&gt;target-&gt;customKeyBoard: 系统要求我们对键盘的布局要使用autolayout，并且只可以采用代码布局的方式，我们这里为了简单演示，将坐标写死： 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)viewDidLoad &#123; [super viewDidLoad]; // 设置数字键盘的UI //数字按钮布局 for (int i=0; i&lt;10; i++) &#123; UIButton * btn = [UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20+45*(i%3), 20+45*(i/3), 40, 40); btn.backgroundColor=[UIColor greenColor]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,i] forState:UIControlStateNormal]; btn.tag=101+i; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; &#125; //创建切换键盘按钮 UIButton * change = [UIButton buttonWithType:UIButtonTypeSystem]; change.frame=CGRectMake(200,20, 80, 40) ; NSLog(@&quot;%f,%f&quot;,self.view.frame.size.height,self.view.frame.size.width); [change setBackgroundColor:[UIColor blueColor]]; [change setTitle:@&quot;切换键盘&quot; forState:UIControlStateNormal]; [change addTarget:self action:@selector(change) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:change]; //创建删除按钮 UIButton * delete = [UIButton buttonWithType:UIButtonTypeSystem]; delete.frame=CGRectMake(200, 120, 80, 40); [delete setTitle:@&quot;delete&quot; forState:UIControlStateNormal]; [delete setBackgroundColor:[UIColor redColor]]; [delete addTarget:self action:@selector(delete) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:delete];&#125;//删除方法-(void)delete&#123; if (self.textDocumentProxy.documentContextBeforeInput) &#123; [self.textDocumentProxy deleteBackward]; &#125;&#125;//切换键盘方法-(void)change&#123; [self advanceToNextInputMode];&#125;//点击数字按钮 将相应数字输入-(void)click:(UIButton *)btn&#123; [self.textDocumentProxy insertText:[NSString stringWithFormat:@&quot;%ld&quot;,btn.tag-101]];&#125; 运行后，在使用之前，我们需要先加入这个键盘：在模拟器系统设置中general-&gt;keyboard-&gt;keyboards-&gt;addNowKeyboard 选中我们自定义的键盘，之后运行浏览器，切换到我们的键盘，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之一——Today扩展","slug":"89iOS8新特性扩展(Extension)应用之一——Today扩展","date":"2015-07-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.409Z","comments":true,"path":"2015/07/30/89iOS8新特性扩展(Extension)应用之一——Today扩展/","link":"","permalink":"http://huishao.cc/2015/07/30/89iOS8新特性扩展(Extension)应用之一——Today扩展/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之一——Today扩展一、理解扩展1、简介基于iOS系统的安全性考虑，其应用的数据存储是通过沙盒模式进行的，要实现应用之间的数据共享十分困难，功能共享就更加棘手。在iOS8系统中，apple为我们提供了一个革命性的功能：扩展。我们可以通过扩展来使app间数据甚至功能进行共享。 2、几种扩展模式（1）今日视图扩展:today这个扩展也被叫做 widget。该扩展可以将今日发生的简短消息放到消息中心的「今日」视图里。这个功能类似于安卓系统中的小控件，只是安卓的可以直接放在桌面上，更加自由。示例如下： （2）分享功能扩展该扩展允许应用向在线服务上传照片、链接或者其他文件。在以前版本中，我们若要实现分享功能，必须进行复杂的操作。 （3）个性操作通过这个功能，可以实现两个APP中共享一些内容，例如编辑文字中的图片，翻译网页中的文字。 （4）照片操作这个类型的扩展可以允许我们在ipone相机中拍摄的照片使用其他图片编辑软件进行编辑。 （5）文件分享该扩展可以让软件将文件保存在各种云存储服务商。 （6）自定义键盘允许用户使用第三方的键盘输入法。 二、ToDay扩展的创建扩展是一个独立的构成，和其有关的两个概念是宿主APP和主机APP，宿主APP是扩展存放的地方，与扩展可以实现资源共享，主机APP是扩展运行的程序，例如ToDay扩展有抽屉中的Today应用进行运行。要创建一个ToDay扩展，首先我们需要创建一个宿主APP： 新建一个工程： 选择xcode工具栏中的File-&gt;new-&gt;target 在Application Extension中有上面提到的6中扩展，我们选择Today。 这是我们的项目中会多了一个扩展的文件夹： 这个文件夹中有一个ViewController，我们可以在里面进行布局，还有一个plist文件，可是配置扩展的一些属性。 我们创建一个按钮： 123 UIButton * btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 30)]; [btn setTitle:@&quot;231&quot; forState:UIControlStateNormal]; [self.view addSubview:btn]; 之后我们运行这个扩展： xcode会让我们选择运行扩展的主机程序，因为这是一个today类型的扩展，我们选择Today： 运行后，在系统的通知抽屉中，就会出现我们的这个扩展： 同样，我们可以创建tableView，imageView以及其他复杂的视图效果，我们也可以编写很多逻辑功能，跳转APP等。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之三——照片编辑插件","slug":"91iOS8新特性扩展(Extension)应用之三——照片编辑插件","date":"2015-07-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.410Z","comments":true,"path":"2015/07/30/91iOS8新特性扩展(Extension)应用之三——照片编辑插件/","link":"","permalink":"http://huishao.cc/2015/07/30/91iOS8新特性扩展(Extension)应用之三——照片编辑插件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之三——照片编辑插件 通过前几篇博客的介绍，我们了解到扩展给app提供的更加强大的交互能力，这种强大的交互能力另一方面体现在照片编辑插件的应用。 和通常一样，我们先创建一个工程，然后新建一个Target，选择photo editing： 从模板中，我们可以看到系统为我们创建了一个controller，这个controller就是用于处理照片的controller，其中方法如下： 123456789101112131415161718192021222324252627282930- (BOOL)canHandleAdjustmentData:(PHAdjustmentData *)adjustmentData &#123; // Inspect the adjustmentData to determine whether your extension can work with past edits. // (Typically, you use its formatIdentifier and formatVersion properties to do this.) return NO;&#125;//这个函数用于从系统相册获取到选中的照片，contentEditingInput对象中存有响应的数据类型和image对象- (void)startContentEditingWithInput:(PHContentEditingInput *)contentEditingInput placeholderImage:(UIImage *)placeholderImage &#123; //我们可以在这里将取到的数据进行展示等等 self.input = contentEditingInput;&#125;//结束编辑照片时的方法- (void)finishContentEditingWithCompletionHandler:(void (^)(PHContentEditingOutput *))completionHandler &#123; // Update UI to reflect that editing has finished and output is being rendered. // Render and provide output on a background queue. dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // Create editing output from the editing input. PHContentEditingOutput *output = [[PHContentEditingOutput alloc] initWithContentEditingInput:self.input]; //我们可以在这里将新的图片数据写入到输出流中 // output.adjustmentData = &lt;#new adjustment data#&gt;; // NSData *renderedJPEGData = &lt;#output JPEG#&gt;; // [renderedJPEGData writeToURL:output.renderedContentURL atomically:YES]; // Call completion handler to commit edit to Photos. completionHandler(output); // Clean up temporary files, etc. &#125;);&#125; 在当前扩展执行结束编辑之前，我们可以自由渲染我们得到的图片，例如添加相框，文字等等，输出时将渲染后的图片进行输出即可。 这里还有一个地方需要我们注意，此类扩展有一个功能，如果我们中途退出编辑，系统会为我们保存我们扩展的处理状态，为了区分多个类似功能的扩展，在输出数据的对象中有一个PHAdjustmentData类型的对象，这个对象专门用于负责版本的记录，这个对象中有如下两个属性用于区分版本： @property (readonly, copy) NSString *formatIdentifier; @property (readonly, copy) NSString *formatVersion; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之二——分享插件","slug":"90iOS8新特性扩展(Extension)应用之二——分享插件","date":"2015-07-29T16:00:00.000Z","updated":"2023-04-14T11:50:08.410Z","comments":true,"path":"2015/07/30/90iOS8新特性扩展(Extension)应用之二——分享插件/","link":"","permalink":"http://huishao.cc/2015/07/30/90iOS8新特性扩展(Extension)应用之二——分享插件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之二——分享插件 在上一篇博客中，介绍了iOS8新特性扩展功能之一的Today功能：[http://my.oschina.net/u/2340880/blog/485533](http://my.oschina.net/u/2340880/blog/485533)，这里我们再介绍一下分享的扩展功能。 在iOS8之前，除了一些主流的社交平台，例如苹果支持内容分享外，其他开发者的应用若要加入分享的功能，将会十分的复杂。在iOS8的新特性中，apple为我们准备了这样的扩展功能。 首先创建工程，在我们的工程中新建一个Target： 之后，模板中会为我们创建一个controller类，这个controller用于控制我们的分享插件，里面内容： 1234567891011121314151617181920@implementation ShareViewController//这个函数用于判断分享内容的可用性，我们在其中获取分享的内容进行检查- (BOOL)isContentValid &#123; // Do validation of contentText and/or NSExtensionContext attachments here return YES;&#125;//点击post按钮后出发的方法，我们可以在这里将分享的内容进行上传等操作- (void)didSelectPost &#123; // This is called after the user selects Post. Do the upload of contentText and/or NSExtensionContext attachments. // Inform the host that we&apos;re done, so it un-blocks its UI. Note: Alternatively you could call super&apos;s -didSelectPost, which will similarly complete the extension context. [self.extensionContext completeRequestReturningItems:@[] completionHandler:nil];&#125;//这里用于设置分享插件的附件按钮- (NSArray *)configurationItems &#123; // To add configuration options via table cells at the bottom of the sheet, return an array of SLComposeSheetConfigurationItem here. return @[];&#125;@end 除此之外，还有一些常用的属性： - (void)presentationAnimationDidFinish; 弹出视图动画结束后执行的方法 @property (readonly, NS_NONATOMIC_IOSONLY) NSString *contentText; 分享的内容文字 @property (copy, NS_NONATOMIC_IOSONLY) NSString *placeholder; 默认显示的提示文字 - (void)didSelectCancel; 取消按钮执行的方法 我们在代码中如下添加后运行： 1234567891011@implementation ShareViewController-(NSString *)placeholder&#123; return @&quot;提示文字&quot;;&#125;- (NSArray *)configurationItems &#123; // To add configuration options via table cells at the bottom of the sheet, return an array of SLComposeSheetConfigurationItem here. SLComposeSheetConfigurationItem * item =[[SLComposeSheetConfigurationItem alloc]init]; item.title=@&quot;地点&quot;; item.value=@&quot;城门&quot;; return @[item];&#125; 我们用系统的相册做测试，点击相片的分享按钮： 点击MORE，添加我们的扩展插件。 这时分享栏中多了一个我们的插件，点击效果如下： 还有一点我们需要了解，在这个扩展的plist文件中，有这样一个键：NSExtensionAttributes，里面有一个NSExtensionActivationRule的字典，其中可以设置一些键值，对分享插件的属性进行控制。 这些键的写法在官方文档中的介绍如下： 这些键的意义，文档中介绍的很清楚，我们可以根据需要进行设置。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之五——炫酷的粒子效果","slug":"88iOS动画开发之五——炫酷的粒子效果","date":"2015-07-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.409Z","comments":true,"path":"2015/07/29/88iOS动画开发之五——炫酷的粒子效果/","link":"","permalink":"http://huishao.cc/2015/07/29/88iOS动画开发之五——炫酷的粒子效果/","excerpt":"","text":"iOS动画开发之五——炫酷的粒子效果在上几篇博客中，我们对UIView层的动画以及iOS的核心动画做了介绍，基本已经可以满足iOS应用项目中所有的动画需求，如果你觉得那些都还不够炫酷，亦或是你灵光一现，想用UIKit框架写出一款炫酷的休闲游戏，那个有一个东西可以帮到你：iOS的粒子效果引擎。 一、粒子发射器iOS中的粒子效果有两部分组成，一部分为发射器，设置例子发射的宏观属性，另一部分是粒子单元，用于设置相应的粒子属性。粒子发射器是基于Layer层，没错，又是Layer，他的全名叫做： CAEmitterLayer。其中常用的属性如下： @property(copy) NSArray *emitterCells; 粒子单元数组，例如你在绘制火焰的效果时，你可以创建两个单元，一个单元负责烟雾，一个单元负责火苗。 @property float birthRate; 粒子的创建速率，默认为1/s。 @property float lifetime; 粒子的存活时间。默认为1S。 @property CGPoint emitterPosition; 发射器在xy平面的中心位置 @property CGFloat emitterZPosition; 发射器在Z平面的位置 @property CGSize emitterSize; 发射器的尺寸大小 @property CGFloat emitterDepth; 发射器的深度，在某些模式下会产生立体效果 @property(copy) NSString *emitterShape; 发射器的形状，这个参数的几个系统字符串如下： 123456789101112CA_EXTERN NSString * const kCAEmitterLayerPoint __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0); //点的形状，粒子从一个点发出CA_EXTERN NSString * const kCAEmitterLayerLine __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//线的形状，粒子从一条线发出CA_EXTERN NSString * const kCAEmitterLayerRectangle __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//矩形形状，粒子从一个矩形中发出CA_EXTERN NSString * const kCAEmitterLayerCuboid __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//立方体形状，会影响Z平面的效果CA_EXTERN NSString * const kCAEmitterLayerCircle __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//圆形，粒子会在圆形范围发射CA_EXTERN NSString * const kCAEmitterLayerSphere __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//球型 @property(copy) NSString *emitterMode; 发射器的发射模式，参数如下： 12345678CA_EXTERN NSString * const kCAEmitterLayerPoints __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器中发出CA_EXTERN NSString * const kCAEmitterLayerOutline __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器边缘发出CA_EXTERN NSString * const kCAEmitterLayerSurface __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器表面发出CA_EXTERN NSString * const kCAEmitterLayerVolume __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器中点发出 @property(copy) NSString *renderMode; 发射器渲染模式，参数如下： 12345678910CA_EXTERN NSString * const kCAEmitterLayerUnordered __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，粒子是无序出现的，多个发射源将混合CA_EXTERN NSString * const kCAEmitterLayerOldestFirst __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，声明久的粒子会被渲染在最上层CA_EXTERN NSString * const kCAEmitterLayerOldestLast __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，年轻的粒子会被渲染在最上层CA_EXTERN NSString * const kCAEmitterLayerBackToFront __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，粒子的渲染按照Z轴的前后顺序进行CA_EXTERN NSString * const kCAEmitterLayerAdditive __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式会进行粒子混合 @property BOOL preservesDepth; 是否开启三维空间效果 @property float velocity; 粒子的运动速度 @property float scale; 粒子的缩放大小 @property float spin; 粒子的旋转位置 @property unsigned int seed; 初始化随机的粒子种子 二、粒子单元设置好了粒子发射器，我们还需要初始化一些粒子单元，设置具体粒子的属性，我们使用到的类是CAEmitterCell这个类。 + (instancetype)emitterCell; 类方法创建发射单元 @property(copy) NSString *name; 设置发射单元的名称 @property(getter=isEnabled) BOOL enabled; 是否允许发射器渲染 @property float birthRate; 粒子的创建速率 @property float lifetime; 粒子的生存时间 @property float lifetimeRange; 粒子的生存时间容差 @property CGFloat emissionLatitude; 粒子在Z轴方向的发射角度 @property CGFloat emissionLongitude; 粒子在xy平面的发射角度 @property CGFloat emissionRange; 粒子发射角度的容差 @property CGFloat velocity; 粒子的速度 @property CGFloat velocityRange; 粒子速度的容差 @property CGFloat xAcceleration; @property CGFloat yAcceleration; @property CGFloat zAcceleration; x，y，z三个方向的加速度 @property CGFloat scale; @property CGFloat scaleRange; @property CGFloat scaleSpeed; 缩放大小，缩放容差和缩放速度 @property CGFloat spin; @property CGFloat spinRange; 旋转度与旋转容差 @property CGColorRef color; 粒子的颜色 @property float redRange; @property float greenRange; @property float blueRange; @property float alphaRange; 粒子在rgb三个色相上的容差和透明度的容差 @property float redSpeed; @property float greenSpeed; @property float blueSpeed; @property float alphaSpeed; 粒子在RGB三个色相上的变化速度和透明度的变化速度 @property(strong) id contents; 渲染粒子，可以设置为一个CGImage的对象 @property CGRect contentsRect; 渲染的范围 三、让我们来“火”一把通过上面的介绍，我们来应用这些创造一团火，代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@interface ViewController ()&#123; CAEmitterLayer * _fireEmitter;//发射器对象&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.view.backgroundColor=[UIColor blackColor]; //设置发射器 _fireEmitter=[[CAEmitterLayer alloc]init]; _fireEmitter.emitterPosition=CGPointMake(self.view.frame.size.width/2,self.view.frame.size.height-20); _fireEmitter.emitterSize=CGSizeMake(self.view.frame.size.width-100, 20); _fireEmitter.renderMode = kCAEmitterLayerAdditive; //发射单元 //火焰 CAEmitterCell * fire = [CAEmitterCell emitterCell]; fire.birthRate=800; fire.lifetime=2.0; fire.lifetimeRange=1.5; fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor]; fire.contents=(id)[[UIImage imageNamed:@&quot;Particles_fire.png&quot;]CGImage]; [fire setName:@&quot;fire&quot;]; fire.velocity=160; fire.velocityRange=80; fire.emissionLongitude=M_PI+M_PI_2; fire.emissionRange=M_PI_2; fire.scaleSpeed=0.3; fire.spin=0.2; //烟雾 CAEmitterCell * smoke = [CAEmitterCell emitterCell]; smoke.birthRate=400; smoke.lifetime=3.0; smoke.lifetimeRange=1.5; smoke.color=[[UIColor colorWithRed:1 green:1 blue:1 alpha:0.05]CGColor]; smoke.contents=(id)[[UIImage imageNamed:@&quot;Particles_fire.png&quot;]CGImage]; [fire setName:@&quot;smoke&quot;]; smoke.velocity=250; smoke.velocityRange=100; smoke.emissionLongitude=M_PI+M_PI_2; smoke.emissionRange=M_PI_2; _fireEmitter.emitterCells=[NSArray arrayWithObjects:smoke,fire,nil]; [self.view.layer addSublayer:_fireEmitter]; &#125; 效果如下： 看到效果了么？这次够炫酷了吧，改改其它属性，尽情的玩吧！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之二——UIView动画执行的另一种方式","slug":"85iOS动画开发之二——UIView动画执行的另一种方式","date":"2015-07-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.409Z","comments":true,"path":"2015/07/28/85iOS动画开发之二——UIView动画执行的另一种方式/","link":"","permalink":"http://huishao.cc/2015/07/28/85iOS动画开发之二——UIView动画执行的另一种方式/","excerpt":"","text":"iOS动画开发之二——UIView动画执行的另一种方式 上一篇博客中介绍了UIView的一些常用动画，通过block块，我们可以很方便简洁的创建出动画效果：[http://my.oschina.net/u/2340880/blog/484457](http://my.oschina.net/u/2340880/blog/484457)，这篇博客再介绍一种更加传统的执行UIView的动画的方法。 这种方式相比如block的方式，显得要麻烦一些，apple官方也推荐我们使用带block的创建动画的方式，我们可以将编程重心更多的放在动画逻辑的实现上。使用begin和commit方式主要分为三个步骤： 一、设置动画开始 1[UIView beginAnimations:@&quot;test&quot; context:nil]; 这个函数中的两个参数，第一个用于设置一个动画的标识id，通常第二个参数写为nil。 二、动画执行的参数设置 + (void)setAnimationDelegate:(id)delegate; 设置这个动画的代理，用于执行动画开始或者结束后的动作 + (void)setAnimationWillStartSelector:(SEL)selector; 设置动画开始时执行的回调 + (void)setAnimationDidStopSelector:(SEL)selector; 设置动画结束后执行的回调 + (void)setAnimationDuration:(NSTimeInterval)duration; 设置动画执行的时间 + (void)setAnimationDelay:(NSTimeInterval)delay; 设置延时执行的延时 + (void)setAnimationStartDate:(NSDate *)startDate; 给动画设置一个启示时间 + (void)setAnimationCurve:(UIViewAnimationCurve)curve; 设置动画播放的线性效果，UIViewAnimationCurve的枚举如下： 123456typedef NS_ENUM(NSInteger, UIViewAnimationCurve) &#123; UIViewAnimationCurveEaseInOut, // 淡入淡出 UIViewAnimationCurveEaseIn, // 淡入 UIViewAnimationCurveEaseOut, // 淡出 UIViewAnimationCurveLinear //线性&#125; + (void)setAnimationRepeatCount:(float)repeatCount; 设置动画循环播放次数 + (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses; 设置动画逆向执行 三、提交动画 + (void)commitAnimations; 例如： 1234567UIView * view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; [UIView beginAnimations:@&quot;test&quot; context:nil]; [UIView setAnimationDuration:3]; view.backgroundColor=[UIColor orangeColor]; [UIView commitAnimations];//执行commit后，动画即开始执行 一点建议：这种创建UIView动画的方式和上一篇博客中的block方式效果相同，然而效率并不高，写的代码也会繁琐冗长，在开发中，如果没有特殊的兼容要求，使用block的方式会更高效方便。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之三——UIView的转场切换","slug":"86iOS动画开发之三——UIView的转场切换","date":"2015-07-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.409Z","comments":true,"path":"2015/07/28/86iOS动画开发之三——UIView的转场切换/","link":"","permalink":"http://huishao.cc/2015/07/28/86iOS动画开发之三——UIView的转场切换/","excerpt":"","text":"iOS动画开发之三——UIView的转场切换前两篇博客中，我们分别介绍了UIView动画的两种使用方式，分别为，带block的方式：[**http://my.oschina.net/u/2340880/blog/484457**](http://my.oschina.net/u/2340880/blog/484457) ,传统的属性配置的方式：[http://my.oschina.net/u/2340880/blog/484538](http://my.oschina.net/u/2340880/blog/484538)。通过UIView动画的类方法，我们可以十分方便的使View某些属性改变的同时拥有动画效果。这篇博客主要讨论View切换的动画操作。 两个方法： + (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 通过这个方法，我们可以重绘View视图，任何其子视图的改变或者其自身的改变都会触发转场动画的效果， 系统提供的转场效果在第一篇博客中已经介绍过。 这个方法常用于类似小说软件的翻页效果。 + (void)transitionFromView:(UIView )fromView toView:(UIView )toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion; 这个方法会作用于fromView的父视图，用于切换两个view，通过执行这个方法，会将formView从其父视图上移除，将toView重新粘在其父视图上，展现一个动画效果。 通过使用上述两个方法，你会发现某些效果会非常突兀，比如想要改变视图的颜色，它会在转场动画播放完成后，颜色突然的变化，要改善这一效果，我们需要设置options参数包含：UIViewAnimationOptionAllowAnimatedContent这个枚举。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之四——核心动画编程(CoreAnimation)","slug":"87iOS动画开发之四——核心动画编程(CoreAnimation)","date":"2015-07-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.409Z","comments":true,"path":"2015/07/28/87iOS动画开发之四——核心动画编程(CoreAnimation)/","link":"","permalink":"http://huishao.cc/2015/07/28/87iOS动画开发之四——核心动画编程(CoreAnimation)/","excerpt":"","text":"iOS动画开发之四——核心动画编程(CoreAnimation)一、引言前几篇博客详细介绍了有关UIView层的动画使用与相关的效果，然而这些动画是UIKit为我们封装好的核心动画层的方法，通过这些方法，我们可以用的更加简便，当然功能也十分强大，基本能达到我们项目的大多需求。但是如果你想更加自由的通过动画操作视图的属性，你就需要跳过UIKit的封装，使用CoreAnimation核心动画层的方法来实现动画。 二、开始前的准备1、认识一个的朋友在开始介绍核心动画的内容前，我们需要先搞明白一个东西：Layer。你可能很少听说他，可是他却无处不在，在iOS的UI开发中，任何一个View包括继承于UIView的子类上面都会有一个Layer，可以理解为Layer为单独的一层，专门负责视图的显示，而view除此之外更多负责触摸时间等逻辑处理。因此，iOS也将所有动画的操作都交给你Layer来负责。 2、Layer层可以做到的事Layer如此神秘，那他究竟可以做到哪些事？他确实可以做很多view做不了的事情. (1)设置view的圆角属性12345 view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; view.layer.masksToBounds=YES;//设置layer层的切割属性 view.layer.cornerRadius=10;//设置layer层的圆角半径 效果如下： (2)设置view的边框123456view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; CALayer *layer=view.layer; layer.borderWidth=10;//设置边框的宽度 layer.borderColor=[[UIColor magentaColor]CGColor];//设置边框的颜色 注意：因为CoreAnimation层是UI层的底层，所以这里的颜色为CGColor对象。 效果如下： (3)设置视图阴影12345678 view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; CALayer *layer=view.layer; layer.shadowOffset=CGSizeMake(30, 30);//设置阴影方向 layer.shadowColor=[[UIColor blackColor] CGColor];//设置阴影颜色 layer.shadowOpacity=0.5;//设置阴影透明度 layer.shadowRadius=10;//设置阴影圆角 效果如下： 这样的立体效果是否已经很酷了？NO，在加上动画才对。 三、CoreAnimation的使用1、基础属性相关的动画CABasicAnimationCABasicAnimation是核心动画中对属性操作需要用到了一个动画类，示例如下： 1234567 CALayer *layer=view.layer; CABasicAnimation * ani= [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];//创建对象，参数关键字为layer的属性 ani.duration=3;//设置执行时间 ani.repeatCount=1;//设置执行次数 ani.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];//设置线性效果 [layer addAnimation:ani forKey:@&quot;test&quot;];//添加动画 layer.opacity=0;//透明度改变时执行动画动作 通过上面的示例，我们可以发现，layer的属性都可以来进行动画动作，这样，我们对动画的操作就自由的很多。 2、关键帧动画CAKeyframeAnimation关键帧动画除了动画改变layer的属性外，可以设置几个关键帧点，通过这些点，可以实现路径更加负责的动画，例如： 12345CALayer *layer=view.layer; CAKeyframeAnimation * ani = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];//创建一个关键帧动画对象 ani.duration=3; ani.values=@[@1,@0,@1];//传入三个关键帧，动画会将试图先慢慢隐藏，再慢慢展现 [layer addAnimation:ani forKey:@&quot;test&quot;]; 类比如上代码，我们还可以通过关键帧让试图按照我们预定的路线移动，同时我们还可以设置两个数组，分别为keyTimes和timingFunctions。这两个数组中的值可以设置动画每一段的运动线性特征和每一段的运动时间比例。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之一——UIViewAnimation动画的使用","slug":"84iOS动画开发之一——UIViewAnimation动画的使用","date":"2015-07-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.408Z","comments":true,"path":"2015/07/27/84iOS动画开发之一——UIViewAnimation动画的使用/","link":"","permalink":"http://huishao.cc/2015/07/27/84iOS动画开发之一——UIViewAnimation动画的使用/","excerpt":"","text":"iOS动画开发之一——UIViewAnimation动画的使用一、简介一款APP的成功与否，除了完善的功能外，用户体验也占有极大的比重，动画的合理运用，可以很好的增强用户体验。iOS开发中，常用的动画处理有UIView动画编程和核心动画编程，其中UIView动画使用简便，开发中应用十分广泛。这篇博客，主要讨论UIView的动画使用。 二、UIView动画的几个方法+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations; 这个是参数最少的一个方法，我们可以通过设置一个时间和block块来完成动画，时间参数是动画执行的时长，block块中为要执行的动画动作，具体可以执行那些动作，我们会在后面说。例如在1S内将view渐变透明： 123[UIView animateWithDuration:1 animations:^&#123; _myView.alpha=0; &#125;]; + (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数会带两个block块，用法和第一个函数相似，设置一个执行时间和一个执行动作，第二个block块中可以添加一个动画执行结束后的动作，作为补充，例如下面代码的效果，在1S内将view渐变为透明，动画结束后，view在瞬间变回不透明： 1234567[UIView animateWithDuration:1 animations:^&#123; _myView.alpha=0; &#125; completion:^(BOOL finished) &#123; if (finished) &#123; _myView.alpha=1; &#125; &#125;]; + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数除了上面的属性外，可以设置延时执行，同时可以设置一个动画效果参数，这个参数是个枚举，它可以影响动画的执行效果，后面会再总结。 + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数是iOS7之后的一个新函数，通过这个函数，我们可以方便的制作出效果炫酷的动画，这个函数的核心是两个阻尼参数，参数dampingRatio可以理解为弹簧效果的强弱，设置1则没有回弹效果，设置0则会剧烈的阻尼回弹。velocity参数用于设置弹簧的初始速度。 三、UIView动画可以操作的视图属性通过上面的介绍，我们了解了几个使用动画的函数，那么那些属性可以产生动画效果呢？ 官方文档告诉我们这些属性是可以通过上述方法进行动画的： 四、动画执行选项设置 在UIView执行动画的相关函数中，有UIViewAnimationOptions这个参数可以对动画的执行效果进行设置，这个枚举非常多，可分为三部分，如下： 123456789101112131415161718192021222324252627enum &#123; //这部分是基础属性的设置 UIViewAnimationOptionLayoutSubviews = 1 &lt;&lt; 0,//设置子视图随父视图展示动画 UIViewAnimationOptionAllowUserInteraction = 1 &lt;&lt; 1,//允许在动画执行时用户与其进行交互 UIViewAnimationOptionBeginFromCurrentState = 1 &lt;&lt; 2,//允许在动画执行时执行新的动画 UIViewAnimationOptionRepeat = 1 &lt;&lt; 3,//设置动画循环执行 UIViewAnimationOptionAutoreverse = 1 &lt;&lt; 4,//设置动画反向执行，必须和重复执行一起使用 UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt; 5,//强制动画使用内层动画的时间值 UIViewAnimationOptionOverrideInheritedCurve = 1 &lt;&lt; 6,//强制动画使用内层动画曲线值 UIViewAnimationOptionAllowAnimatedContent = 1 &lt;&lt; 7,//设置动画视图实时刷新 UIViewAnimationOptionShowHideTransitionViews = 1 &lt;&lt; 8,//设置视图切换时隐藏，而不是移除 UIViewAnimationOptionOverrideInheritedOptions = 1 &lt;&lt; 9,// //这部分属性设置动画播放的线性效果 UIViewAnimationOptionCurveEaseInOut = 0 &lt;&lt; 16,//淡入淡出 首末减速 UIViewAnimationOptionCurveEaseIn = 1 &lt;&lt; 16,//淡入 初始减速 UIViewAnimationOptionCurveEaseOut = 2 &lt;&lt; 16,//淡出 末尾减速 UIViewAnimationOptionCurveLinear = 3 &lt;&lt; 16,//线性 匀速执行 //这部分设置UIView切换效果 UIViewAnimationOptionTransitionNone = 0 &lt;&lt; 20, UIViewAnimationOptionTransitionFlipFromLeft = 1 &lt;&lt; 20,//从左边切入 UIViewAnimationOptionTransitionFlipFromRight = 2 &lt;&lt; 20,//从右边切入 UIViewAnimationOptionTransitionCurlUp = 3 &lt;&lt; 20,//从上面立体进入 UIViewAnimationOptionTransitionCurlDown = 4 &lt;&lt; 20,//从下面立体进入 UIViewAnimationOptionTransitionCrossDissolve = 5 &lt;&lt; 20,//溶解效果 UIViewAnimationOptionTransitionFlipFromTop = 6 &lt;&lt; 20,//从上面切入 UIViewAnimationOptionTransitionFlipFromBottom = 7 &lt;&lt; 20,//从下面切入&#125;; 提示：1，属性可以使用|进行多项合并。 2，这类的动画可以进行嵌套，其中有一点需要注意，内层动画的执行时间和曲线模式会默认继承外层动的，若要强制使用新的参数，使用如下的两个参数： 12UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt; 5,//强制动画使用内层动画的时间值 UIViewAnimationOptionOverrideInheritedCurve = 1 &lt;&lt; 6,//强制动画使用内层动画曲线值 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发技巧之查看模拟器沙盒文件","slug":"83iOS开发技巧之查看模拟器沙盒文件","date":"2015-07-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.408Z","comments":true,"path":"2015/07/19/83iOS开发技巧之查看模拟器沙盒文件/","link":"","permalink":"http://huishao.cc/2015/07/19/83iOS开发技巧之查看模拟器沙盒文件/","excerpt":"","text":"iOS开发技巧之查看模拟器沙盒文件iOS开发中，在对数据库进行操作时，有时我们需要直观的查看数据库的内容，那么我们如何找到沙盒中的这个文件呢，步骤很简单： 1.点击Finder选项栏上的前往菜单： 2.选择前往文件夹选项： 前往的文件路径为：/Users/username/Library/Application Support/iPhone Simulator/ 其中username为当前mac电脑的用户名。 3.界面类似如下模样，选择一个版本的模拟器，应用的沙盒文件就在Applications中。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美十——用户交互元素","slug":"82标签之美十——用户交互元素","date":"2015-07-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.408Z","comments":true,"path":"2015/07/02/82标签之美十——用户交互元素/","link":"","permalink":"http://huishao.cc/2015/07/02/82标签之美十——用户交互元素/","excerpt":"","text":"标签之美——用户交互元素任何一个网页都会提供用户交互的功能，包括账号密码的提交，留言板等用户信息的的获取。 一、用户交互表单的属性表单使用来创建。 1、跳转链接属性表单的跳转是在提交数据后跳转到指定的URL，使用action属性，如下： 12&lt;form action=&quot;http://&quot;&gt;&lt;/form&gt; 2、传递数据的方式表单跳转传递数据时可以设置一个传递方式，使用method可以设置方式为get或者post,delate,put： 12&lt;form action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;/form&gt; 3、表单名称表单可是设置一个名称，通过name属性来设置： 12&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;/form&gt; 二、输入表单输入表单使用创建，必须在表单元素中 123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input/&gt;&lt;/form&gt; 效果如下： 1、输入文本框输入表单有type属性可以用来设置类型： 123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;文本框&lt;input type=&quot;text&quot; name=&quot;文本框&quot;/&gt;&lt;!--name:表单名称--&gt;&lt;/form&gt; 效果如下： 2、密码输入框123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;密码框&lt;input type=&quot;password&quot; name=&quot;密码框&quot;/&gt;&lt;!--name:表单名称--&gt;&lt;/form&gt; 效果如下： 3、输入单选框设置type=radio可以创建单选框，单选框需要设置几个属性，同一系列的单选框必须有相同的name值，不相同的value值，可以通过添加checked键值来设置默认选中，示例如下： 12345&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;性别&quot; value=&quot;男&quot; checked/&gt;男&lt;br/&gt;&lt;input type=&quot;radio&quot; name=&quot;性别&quot; value=&quot;女&quot;/&gt;女&lt;/form&gt; 效果如下： 4、输入复选框和单选框相似，可以使用type=checkbox创建复选框: 1234567&lt;body&gt;&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;/form&gt; 效果如下： 5、提交按钮使用type=submit来创建提交按钮，value值为按钮显示的文字： 1234567&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 效果如下： 6、重置按钮123456&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;br/&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt; 效果如下： 点击重置按钮后，输入的内容会被重置。 7、图像按钮图像按钮和普通按钮的用法相似，设置type=image可以创建图像按钮，只是这个按钮多了一个src的属性用来设置图片的路径地址。 三、下拉列表通过和标签来设置下拉菜单和其中的选项，示例如下： 1234567&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;select name=&quot;下拉框&quot;&gt;&lt;option value=&quot;爱好&quot; selected&gt;HTML&lt;/option&gt;&lt;option value=&quot;爱好&quot;&gt;iOS&lt;/option&gt;&lt;option value=&quot;爱好&quot;&gt;android&lt;/option&gt;&lt;/select&gt;&lt;/form&gt; 效果如下： 四、文本输入框使用来设置文本输入框，属性rows和clos可以分别设置输入框的行数和列数，示例如下： 1234&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;textarea name=&quot;文本输入框&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt;&lt;/form&gt; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"Swift学习第二练——Swift项目时光电影","slug":"80Swift学习第二练——Swift项目时光电影","date":"2015-06-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.407Z","comments":true,"path":"2015/06/28/80Swift学习第二练——Swift项目时光电影/","link":"","permalink":"http://huishao.cc/2015/06/28/80Swift学习第二练——Swift项目时光电影/","excerpt":"","text":"Swift学习第二练——Swift项目时光电影很早以前的一个OC的练习项目，用swift重新写了一遍，因为xcode版本的更新对swift的兼容度也在不断改变，此版本适用于xcode6.1。 这个项目中，用swift将iOS官方SDK中的HTTP进行了封装，使用了swift编写的异步加载网络图片的方法。练习了用swift操作界面布局，跳转界面等的方法。 下面是封装的下载类的核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private var httpConnection:NSURLConnection?class ZYHHttpRequset: NSObject,NSURLConnectionDataDelegate&#123; var requestUrl:String? var downloadData:NSMutableData=NSMutableData() var isDownloadSuccess:Bool? var delegate:ZYHHttpRequestDelegate? class func requestFormUrl(url:NSString)-&gt;ZYHHttpRequset&#123; var oldRequest:ZYHHttpRequset?=ZYHHttpRequestManager.sharedHttpRequestManager().requestForKey(url) if (oldRequest != nil)&#123; println(&quot;该任务存在&quot;) return oldRequest! &#125; //新建下载任务 var request:ZYHHttpRequset=ZYHHttpRequset() request.requestUrl=url request.startRequestUrl(url) ZYHHttpRequestManager.sharedHttpRequestManager().addTask(request, key: url) return request &#125; func stop()&#123; if httpConnection != nil &#123; httpConnection?.cancel() httpConnection = nil &#125; &#125; //开始下载请求 private func startRequestUrl(url:NSString)&#123; if httpConnection != nil &#123; httpConnection!.cancel() httpConnection==nil &#125; //创建连接对象 var request=NSURLRequest(URL: NSURL(string: url)!) httpConnection=NSURLConnection(request: request, delegate: self) &#125; //重写协议中的方法 func connection(connection: NSURLConnection, didReceiveResponse response: NSURLResponse) &#123; downloadData.length=0 &#125; func connection(connection: NSURLConnection, didReceiveData data: NSData) &#123; downloadData.appendData(data) &#125; func connectionDidFinishLoading(connection: NSURLConnection) &#123; isDownloadSuccess = true delegate!.ZYHHttpRequestSuccsee(self) ZYHHttpRequestManager.sharedHttpRequestManager().removeTaskFromUrl(self.requestUrl!) &#125; func connection(connection: NSURLConnection, didFailWithError error: NSError) &#123; println(&quot;加载失败&quot;) println(error) self.isDownloadSuccess=false ZYHHttpRequestManager.sharedHttpRequestManager().removeTaskFromUrl(self.requestUrl!) &#125; &#125;protocol ZYHHttpRequestDelegate&#123; func ZYHHttpRequestSuccsee(request:ZYHHttpRequset)&#125; 项目部分截图： github源码地址：https://github.com/ZYHshao/SwiftMovie 其中错误之处，欢迎指教，希望在交流中，不断进步！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"标签之美九——列表","slug":"81标签之美九——列表","date":"2015-06-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.408Z","comments":true,"path":"2015/06/28/81标签之美九——列表/","link":"","permalink":"http://huishao.cc/2015/06/28/81标签之美九——列表/","excerpt":"","text":"标签之美——列表列表是网页排序中时常会用到的一个元素。 一、无序列表1、无序列表的标签无序列表使用来定义标签的开始和结束。使用来设置标签项，示例如下： 12345&lt;body&gt;&lt;ul&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 效果如下： 2、无序列表标签的样式标签的type属性可以设置其样式： 实心圆样式：disc这个样式就是默认的样式，效果如上图 空心圆样式：circle示例如下： 12345&lt;body&gt;&lt;ul type=&quot;circle&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 效果如下： 方块样式：square效果如下： 二、有序列表1、有序列表的标签有序列表的开始和结束使用来定义，同样使用来定义列表项，示例如下： 12345&lt;body&gt;&lt;ol type=&quot;square&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt; 效果如下： 2、有序列表的样式数字标号的样式：type=1这个样式为默认的样式，效果如上。 大写字母的标签：type=A效果如下： 小写字母样式：type=a 大写罗马数字样式：type=I 小写罗马数字样式：type=i 三、列表的嵌套列表可以进行嵌套，形式如下： 123456789&lt;body&gt;&lt;ol type=&quot;i&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;subTitle1&lt;/li&gt;&lt;li&gt;subTitle2&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS开发swift版异步加载网络图片(带缓存和缺省图片)","slug":"79iOS开发swift版异步加载网络图片(带缓存和缺省图片)","date":"2015-06-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.407Z","comments":true,"path":"2015/06/25/79iOS开发swift版异步加载网络图片(带缓存和缺省图片)/","link":"","permalink":"http://huishao.cc/2015/06/25/79iOS开发swift版异步加载网络图片(带缓存和缺省图片)/","excerpt":"","text":"iOS开发之swift版异步加载网络图片与SDWebImage异步加载网络图片的功能相似，只是代码比较简单，功能没有SD的完善与强大，支持缺省添加图片，支持本地缓存。 异步加载图片的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 func setZYHWebImage(url:NSString?, defaultImage:NSString?, isCache:Bool)&#123; var ZYHImage:UIImage? if url == nil &#123; return &#125; //设置默认图片 if defaultImage != nil &#123; self.image=UIImage(named: defaultImage!) &#125; //是否进行缓存处理 if isCache &#123; //缓存管理类 var data:NSData?=ZYHWebImageChcheCenter.readCacheFromUrl(url!) if data != nil &#123; ZYHImage=UIImage(data: data!) self.image=ZYHImage &#125;else&#123; //获取异步线程 var dispath=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) dispatch_async(dispath, &#123; () -&gt; Void in var URL:NSURL = NSURL(string: url!)! var data:NSData?=NSData(contentsOfURL: URL) if data != nil &#123; ZYHImage=UIImage(data: data!) //写缓存 ZYHWebImageChcheCenter.writeCacheToUrl(url!, data: data!) //主线程中刷新UI dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in //刷新主UI self.image=ZYHImage &#125;) &#125; &#125;) &#125; &#125;else&#123; var dispath=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) dispatch_async(dispath, &#123; () -&gt; Void in var URL:NSURL = NSURL(string: url!)! var data:NSData?=NSData(contentsOfURL: URL) if data != nil &#123; ZYHImage=UIImage(data: data!) //写缓存 dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in //刷新主UI self.image=ZYHImage &#125;) &#125; &#125;) &#125; &#125; &#125; 缓存的处理这里采用的是写文件的方式，通过文件名来对缓存进行管理，这个框架还不完善，后面会加入缓存清除等功能。缓存的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class func readCacheFromUrl(url:NSString)-&gt;NSData?&#123; var data:NSData? var path:NSString=ZYHWebImageChcheCenter.getFullCachePathFromUrl(url) if NSFileManager.defaultManager().fileExistsAtPath(path) &#123; data=NSData.dataWithContentsOfMappedFile(path) as? NSData &#125; return data &#125; class func writeCacheToUrl(url:NSString, data:NSData)&#123; var path:NSString=ZYHWebImageChcheCenter.getFullCachePathFromUrl(url) println(data.writeToFile(path, atomically: true)) &#125; //设置缓存路径 class func getFullCachePathFromUrl(url:NSString)-&gt;NSString&#123; var chchePath=NSHomeDirectory().stringByAppendingString(&quot;/Library/Caches/MyCache&quot;) var fileManager:NSFileManager=NSFileManager.defaultManager() fileManager.fileExistsAtPath(chchePath) if !(fileManager.fileExistsAtPath(chchePath)) &#123; fileManager.createDirectoryAtPath(chchePath, withIntermediateDirectories: true, attributes: nil, error: nil) &#125; //进行字符串处理 var newURL:NSString newURL=ZYHWebImageChcheCenter.stringToZYHString(url) chchePath=chchePath.stringByAppendingFormat(&quot;/%@&quot;, newURL) return chchePath &#125; class func stringToZYHString(str:NSString)-&gt;NSString&#123; var newStr:NSMutableString=NSMutableString() for var i:NSInteger=0; i &lt; str.length; i++ &#123; var c:unichar=str.characterAtIndex(i) if (c&gt;=48&amp;&amp;c&lt;=57)||(c&gt;=65&amp;&amp;c&lt;=90)||(c&gt;=97&amp;&amp;c&lt;=122)&#123; newStr.appendFormat(&quot;%c&quot;, c) &#125; &#125; return newStr.copy() as NSString &#125; 框架的github地址，欢迎指正与扩展：https://github.com/ZYHshao/swift-ZYHWebImage 因xcode的版本不同，swift语言语法随环境时常会变化，此版本在6.1中可用，更高版本中需要修改少部分即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS中UIWebView的使用详解","slug":"78iOS中UIWebView的使用详解","date":"2015-06-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.407Z","comments":true,"path":"2015/06/23/78iOS中UIWebView的使用详解/","link":"","permalink":"http://huishao.cc/2015/06/23/78iOS中UIWebView的使用详解/","excerpt":"","text":"iOS中UIWebView的使用详解一、初始化与三种加载方式UIWebView继承与UIView，因此，其初始化方法和一般的view一样，通过alloc和init进行初始化，其加载数据的方式有三种： 第一种： - (void)loadRequest:(NSURLRequest *)request; 这是加载网页最常用的一种方式，通过一个网页URL来进行加载，这个URL可以是远程的也可以是本地的，例如我加载百度的主页： 123 UIWebView * view = [[UIWebView alloc]initWithFrame:self.view.frame]; [view loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]]; [self.view addSubview:view]; 会得到如下的效果： 第二种： - (void)loadHTMLString:(NSString )string baseURL:(NSURL )baseURL; 这个方法需要将httml文件读取为字符串，其中baseURL是我们自己设置的一个路径，用于寻找html文件中引用的图片等素材。 第三种： - (void)loadData:(NSData )data MIMEType:(NSString )MIMEType textEncodingName:(NSString )textEncodingName baseURL:(NSURL )baseURL; 这个方式使用的比较少，但也更加自由，其中data是文件数据，MIMEType是文件类型，textEncodingName是编码类型，baseURL是素材资源路径。 二、一些常用的属性和变量@property (nonatomic, assign) id &lt;UIWebViewDelegate> delegate; 设置webView的代理 @property (nonatomic, readonly, retain) UIScrollView *scrollView; 内置的scrollView @property (nonatomic, readonly, retain) NSURLRequest *request; URL请求 - (void)reload; 重新加载数据 - (void)stopLoading; 停止加载数据 - (void)goBack; 返回上一级 - (void)goForward; 跳转下一级 @property (nonatomic, readonly, getter=canGoBack) BOOL canGoBack; 获取能否返回上一级 @property (nonatomic, readonly, getter=canGoForward) BOOL canGoForward; 获取能否跳转下一级 @property (nonatomic, readonly, getter=isLoading) BOOL loading; 获取是否正在加载数据 - (NSString )stringByEvaluatingJavaScriptFromString:(NSString )script; 通过javaScript操作web数据 @property (nonatomic) BOOL scalesPageToFit; 设置是否缩放到适合屏幕大小 @property (nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0); 设置某些数据变为链接形式，这个枚举可以设置如电话号，地址，邮箱等转化为链接 @property (nonatomic) BOOL allowsInlineMediaPlayback NS_AVAILABLE_IOS(4_0); 设置是否使用内联播放器播放视频 @property (nonatomic) BOOL mediaPlaybackRequiresUserAction NS_AVAILABLE_IOS(4_0); 设置视频是否自动播放 @property (nonatomic) BOOL mediaPlaybackAllowsAirPlay NS_AVAILABLE_IOS(5_0); 设置音频播放是否支持ari play功能 @property (nonatomic) BOOL suppressesIncrementalRendering NS_AVAILABLE_IOS(6_0); 设置是否将数据加载如内存后渲染界面 @property (nonatomic) BOOL keyboardDisplayRequiresUserAction NS_AVAILABLE_IOS(6_0); 设置用户交互模式 三、iOS7中的一些新特性下面这些属性是iOS7之后才有的，通过他们可以设置更加有趣的web体验 @property (nonatomic) UIWebPaginationMode paginationMode NS_AVAILABLE_IOS(7_0); 这个属性用来设置一种模式，当网页的大小超出view时，将网页以翻页的效果展示，枚举如下： 1234567typedef NS_ENUM(NSInteger, UIWebPaginationMode) &#123; UIWebPaginationModeUnpaginated,//不使用翻页效果 UIWebPaginationModeLeftToRight,//将网页超出部分分页，从左向右进行翻页 UIWebPaginationModeTopToBottom,//将网页超出部分分页，从上向下进行翻页 UIWebPaginationModeBottomToTop,//将网页超出部分分页，从下向上进行翻页 UIWebPaginationModeRightToLeft//将网页超出部分分页，从右向左进行翻页&#125;; @property (nonatomic) CGFloat pageLength NS_AVAILABLE_IOS(7_0); 设置每一页的长度 @property (nonatomic) CGFloat gapBetweenPages NS_AVAILABLE_IOS(7_0); 设置每一页的间距 @property (nonatomic, readonly) NSUInteger pageCount NS_AVAILABLE_IOS(7_0); 获取分页数 四、webView协议中的方法- (BOOL)webView:(UIWebView )webView shouldStartLoadWithRequest:(NSURLRequest )request navigationType:(UIWebViewNavigationType)navigationType; 准备加载内容时调用的方法，通过返回值来进行是否加载的设置 - (void)webViewDidStartLoad:(UIWebView *)webView; 开始加载时调用的方法 - (void)webViewDidFinishLoad:(UIWebView *)webView; 结束加载时调用的方法 - (void)webView:(UIWebView )webView didFailLoadWithError:(NSError )error; 加载失败时调用的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Swift学习第一练——用Swift实现的FlappyBird小游戏","slug":"77Swift学习第一练——用Swift实现的FlappyBird小游戏","date":"2015-06-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.407Z","comments":true,"path":"2015/06/11/77Swift学习第一练——用Swift实现的FlappyBird小游戏/","link":"","permalink":"http://huishao.cc/2015/06/11/77Swift学习第一练——用Swift实现的FlappyBird小游戏/","excerpt":"","text":"用Swift实现的FlappyBird小游戏 伴随着apple公司对swift的推广态度深入，swift火的很快，并且swift精简便捷的语法和强大的功能，对于使用Object—C开发iOS的开发者来说，也有必要了解学习一下swift。这篇博客跳过swift干涩的语法，直接从一个小游戏项目开始使用swift，将其中收获总结如下： FlappyBird是前段时间很火的一款小游戏，通过手指点击屏幕平衡小鸟通过障碍。我是将以前OC版的项目拿来改成了swift，所以整体的思路还是OC的开发思路。 首先，我需要定义两个宏，一个用来模拟重力加速度G，一个用来便捷获取设备屏幕尺寸。因为这个游戏非常简单，开发起来也只需要几个小时，所以我们只需要在一个文件中写代码：viewController.swift。 swift中没有一般语言中的宏定义，但是可以通过定义常量的形式实现宏的效果： 123//用常量的形式代理OC中的宏定义let G:Float=9.8let SCREEN_SIZE = UIScreen.mainScreen().bounds 我们需要定义一些成员变量，如下： 12345678910class ViewController: UIViewController &#123; var timer:NSTimer?//背景移动的定时器 var i:Int=0//背景移动的速度 var timer2:NSTimer?//柱子和地面移动的定时器 var timer3:NSTimer?//小鸟移动的定时器 var bird:UIImageView? var t:Float=0.0//小鸟下落的速度 var isDowm:Bool=false//标记小鸟是否在下落 var isGameOver:Bool=false//标记是否游戏结束&#125; 对于？和！号的理解，网上概念很多，简单理解声明变量时如果不初始化系统是不会给变量赋nil的，会报错，？的作用就是告诉系统这里如果没有初始化就是nil。同理，在用这类变量的时候，也需要加上？解包，如果加！就是强制解包，可以理解为让系统认为这个变量一定不是nil。 对于UI的创建等部分函数和OC一样，只是调用的方式略有不同，后面会附上源码。 在控制小鸟下落的部分代码如下，其中有一点需要注意，在swift中没有隐式转换这个概念，比如你要使用int a + float b 你必须手动将int转为float:(Float)(a)+b 12345678910111213141516171819func birdMove()&#123; if !isDowm&#123; if bird?.frame.origin.y &lt; SCREEN_SIZE.height-100&#123; var rant:CGRect=bird!.frame rant.origin.y += (CGFloat)(G*(t*t/2)) bird?.frame=rant t+=0.025 &#125; &#125;else&#123; if t&lt;0.24&#123; var rant = bird?.frame rant?.origin.y -= 4.9-(CGFloat)(G*t*t/2) bird?.frame=rant! t+=0.025 &#125;else&#123; isDowm=false &#125; &#125; &#125; 游戏效果图如下： 我相信，实践是学习的必经途径，希望与志同道合的朋友，一起进步。 项目github地址：https://github.com/ZYHshao/swiftFlappyBird 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS选择器视图控件(UIPickerView)使用方法总结","slug":"76iOS选择器视图控件(UIPickerView)使用方法总结","date":"2015-06-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.406Z","comments":true,"path":"2015/06/10/76iOS选择器视图控件(UIPickerView)使用方法总结/","link":"","permalink":"http://huishao.cc/2015/06/10/76iOS选择器视图控件(UIPickerView)使用方法总结/","excerpt":"","text":"iOS中UIPickerView使用总结UIPickerView是iOS中的原生选择器控件，使用方便，用法简单，效果漂亮。 @property(nonatomic,assign) id&lt;UIPickerViewDataSource> dataSource; @property(nonatomic,assign) id&lt;UIPickerViewDelegate> delegate; 设置数据源和代理 @property(nonatomic) BOOL showsSelectionIndicator; 是否显示选择框，在iOS7之后这个属性没有任何效果 @property(nonatomic,readonly) NSInteger numberOfComponents; 获取分区数 - (NSInteger)numberOfRowsInComponent:(NSInteger)component; 获取某一分区的行数 - (CGSize)rowSizeForComponent:(NSInteger)component; 获取某一分区行的尺寸 - (UIView *)viewForRow:(NSInteger)row forComponent:(NSInteger)component; 获取某一分区某一行的视图 - (void)reloadAllComponents; 重载所有分区 - (void)reloadComponent:(NSInteger)component; 重载某一分区 - (void)selectRow:(NSInteger)row inComponent:(NSInteger)component animated:(BOOL)animated; 设置选中某一分区某一行 - (NSInteger)selectedRowInComponent:(NSInteger)component; 返回某一分区选中的行 数据源代理中的方法： - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView; 设置分区数 - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component; 根据分区设置行数 代理中的方法： - (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component; 设置分区宽度 - (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component; 设置分区行高 - (NSString )pickerView:(UIPickerView )pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component; 设置某一行显示的标题 - (NSAttributedString )pickerView:(UIPickerView )pickerView attributedTitleForRow:(NSInteger)row forComponent:(NSInteger)component; 通过属性字符串设置某一行显示的标题 - (UIView )pickerView:(UIPickerView )pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view; 设置某一行显示的view视图 - (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component; 选中某一行时执行的回调 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UI之日期控件的使用（UIDatePicker）","slug":"75iOS开发UI之日期控件的使用（UIDatePicker）","date":"2015-06-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.406Z","comments":true,"path":"2015/06/09/75iOS开发UI之日期控件的使用（UIDatePicker）/","link":"","permalink":"http://huishao.cc/2015/06/09/75iOS开发UI之日期控件的使用（UIDatePicker）/","excerpt":"","text":"iOS日期控件UIDatePicker用法总结@property (nonatomic) UIDatePickerMode datePickerMode; 设置控件模式，枚举如下： 123456typedef NS_ENUM(NSInteger, UIDatePickerMode) &#123; UIDatePickerModeTime, //时间模式，显示时分和上下午 UIDatePickerModeDate, //日期模式显示年月日 UIDatePickerModeDateAndTime, //时间和日期模式，显示月日星期，时分上下午 UIDatePickerModeCountDownTimer, //计时模式，显示时和分&#125;; @property (nonatomic, retain) NSLocale *locale; 设置本地化环境 @property (nonatomic, copy) NSCalendar *calendar; 设置日历 @property (nonatomic, retain) NSTimeZone *timeZone; 设置时区 @property (nonatomic, retain) NSDate *date; 设置当前时间 @property (nonatomic, retain) NSDate *minimumDate; 设置最小时间点 @property (nonatomic, retain) NSDate *maximumDate; 设置最大时间点 @property (nonatomic) NSTimeInterval countDownDuration; 只适用于计时模式，设置时间 @property (nonatomic) NSInteger minuteInterval;设置每一格的时间差 - (void)setDate:(NSDate *)date animated:(BOOL)animated; 设置到一个时间，有动画效果 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中UITextView方法解读","slug":"73iOS中UITextView方法解读","date":"2015-06-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.406Z","comments":true,"path":"2015/06/04/73iOS中UITextView方法解读/","link":"","permalink":"http://huishao.cc/2015/06/04/73iOS中UITextView方法解读/","excerpt":"","text":"iOS中UITextView方法解读常用属性解读： @property(nonatomic,assign) id&lt;UITextViewDelegate> delegate; 设置代理属性 @property(nonatomic,copy) NSString *text; textView上的文本 @property(nonatomic,retain) UIFont *font; 设置文本字体 @property(nonatomic,retain) UIColor *textColor; 设置文本颜色 @property(nonatomic) NSTextAlignment textAlignment; 设置文本对齐模式 @property(nonatomic) NSRange selectedRange; 设置选中的文本范围(只有当textView是第一响应时才有效) @property(nonatomic,getter=isEditable) BOOL editable; 设置是否可以编辑 @property(nonatomic,getter=isSelectable) BOOL selectable; 设置是否可以选中 @property(nonatomic) UIDataDetectorTypes dataDetectorTypes; 这个属性可以将本文中的电话，邮件等变为链接，长按会调用响应响应的程序(textView必须为不可编辑状态)，属性的枚举如下： 12345678typedef NS_OPTIONS(NSUInteger, UIDataDetectorTypes) &#123; UIDataDetectorTypePhoneNumber = 1 &lt;&lt; 0, // 电话变为链接 UIDataDetectorTypeLink = 1 &lt;&lt; 1, // 网址变为链接 UIDataDetectorTypeAddress = 1 &lt;&lt; 2, // 地址变为链接 UIDataDetectorTypeCalendarEvent = 1 &lt;&lt; 3, // 日历变为链接 UIDataDetectorTypeNone = 0, // 无连接 UIDataDetectorTypeAll = NSUIntegerMax // 所有类型链接&#125;; @property(nonatomic) BOOL allowsEditingTextAttributes; 设置是否允许编辑属性字符串文本 @property(nonatomic,copy) NSAttributedString *attributedText; 设置属性字符串文本 @property(nonatomic,copy) NSDictionary *typingAttributes; 设置属性字符串文本属性字典 - (void)scrollRangeToVisible:(NSRange)range; 滚动textView使其显示在本一段文本 @property (readwrite, retain) UIView *inputView; 设置成为第一响应时弹出的视图，键盘视图 @property (readwrite, retain) UIView *inputAccessoryView; 设置成为第一响应时弹出的副视图，副键盘视图 @property(nonatomic) BOOL clearsOnInsertion; 设置是否显示删除按钮 UITextViewDelegate中的方法 - (BOOL)textViewShouldBeginEditing:(UITextView *)textView; 是否开始编辑 - (BOOL)textViewShouldEndEditing:(UITextView *)textView; 是否结束编辑 - (void)textViewDidBeginEditing:(UITextView *)textView; 开始编辑时触发的方法 - (void)textViewDidEndEditing:(UITextView *)textView; 结束编辑时触发的方法 - (BOOL)textView:(UITextView )textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString )text; 是否允许字符改变 - (void)textViewDidChange:(UITextView *)textView; 字符内容改变触发的方法 - (void)textViewDidChangeSelection:(UITextView *)textView; 选中内容改变触发的方法 - (BOOL)textView:(UITextView )textView shouldInteractWithURL:(NSURL )URL inRange:(NSRange)characterRange; 当文本中的URL进行链接时触发的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UIScrollView使用详解","slug":"74iOS开发UIScrollView使用详解","date":"2015-06-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.406Z","comments":true,"path":"2015/06/04/74iOS开发UIScrollView使用详解/","link":"","permalink":"http://huishao.cc/2015/06/04/74iOS开发UIScrollView使用详解/","excerpt":"","text":"iOS开发UIScrollView使用详解一、ScrollView常用方法和属性@property(nonatomic)CGPoint contentOffset; 设置滚动的偏移量 @property(nonatomic)CGSize contentSize; 设置滑动区域 @property(nonatomic,assign) id delegate; 设置UIScrollView的代理 @property(nonatomic,getter=isDirectionalLockEnabled) BOOL directionalLockEnabled; 设置是否锁定，这个属性很有意思，默认为NO，当设置为YES时，你的滚动视图只能同一时间在一个方向上滚动，但是当你从对角线拖动时，是时刻在水平和竖直方向同时滚动的。 @property(nonatomic) BOOL bounces; 设置是否开启回弹效果 @property(nonatomic) BOOL alwaysBounceVertical; 是否开启垂直方向的回弹效果 @property(nonatomic) BOOL alwaysBounceHorizontal; 是否开启水平方向的回弹效果 @property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled; 是否开启翻页效果 @property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled; 设置是否可以滑动 @property(nonatomic) BOOL showsHorizontalScrollIndicator; 设置是否显示水平滑动条 @property(nonatomic) BOOL showsVerticalScrollIndicator; 设置是否显示竖直滑动条 @property(nonatomic) UIEdgeInsets scrollIndicatorInsets; 设置滑动条的位置 @property(nonatomic) UIScrollViewIndicatorStyle indicatorStyle; 设置滑动条风格，枚举如下： 12345typedef NS_ENUM(NSInteger, UIScrollViewIndicatorStyle) &#123; UIScrollViewIndicatorStyleDefault, //默认 UIScrollViewIndicatorStyleBlack, //黑色风格 UIScrollViewIndicatorStyleWhite //白色风格&#125;; @property(nonatomic) CGFloat decelerationRate; 设置滑动速度 - (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated; 设置滚动视图内容的偏移量，可以带动画效果 - (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated; 设置滚动视图滚动到某个可见区域，可以带动画效果 - (void)flashScrollIndicators; 显示一个短暂的滚动指示器 @property(nonatomic,readonly,getter=isTracking) BOOL tracking; 获取用户是否触及视图内容 @property(nonatomic,readonly,getter=isDragging) BOOL dragging; 获取用户是否开始拖动视图 @property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating; 获取视图是否开始减速（用户停止拖动但视图仍在滚动） @property(nonatomic) BOOL delaysContentTouches; 设置视图是否延迟处理触摸事件（会将消息传递给子视图） @property(nonatomic) BOOL canCancelContentTouches; 设置是否给子视图传递取消动作的消息（默认设置为YES，当scrollView触发事件的时候，其子视图不能触发，如果设置为NO，则子视图会继续触发事件） - (BOOL)touchesShouldBegin:(NSSet )touches withEvent:(UIEvent )event inContentView:(UIView *)view; - (BOOL)touchesShouldCancelInContentView:(UIView *)view; 重写这两个方法可以控制起子视图的事件响应 @property(nonatomic) CGFloat minimumZoomScale; 设置内容最小缩放比例 @property(nonatomic) CGFloat maximumZoomScale; 设置内容最大缩放比例 @property(nonatomic) CGFloat zoomScale; 设置缩放比例 - (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated; 设置缩放比例，可以带动画效果 - (void)zoomToRect:(CGRect)rect animated:(BOOL)animated; 设置缩放显示到某个区域，可以带动画效果 @property(nonatomic) BOOL bouncesZoom; 设置是否可以缩放回弹 @property(nonatomic,readonly,getter=isZooming) BOOL zooming; 获取是否正在缩放模式 @property(nonatomic,readonly,getter=isZoomBouncing) BOOL zoomBouncing; 获取是否当前的缩放比例超出设置的峰值 @property(nonatomic) BOOL scrollsToTop; 设置是否点击状态栏滚动到scrollView的最上端 @property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode; 设置键盘消失的模式，枚举如下： 12345typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) &#123; UIScrollViewKeyboardDismissModeNone, UIScrollViewKeyboardDismissModeOnDrag, //手指滑动视图键盘就会消失 UIScrollViewKeyboardDismissModeInteractive, //手指滑动视图后可以与键盘交互，上下滑动键盘会跟随手指上下移动&#125;; 二、ScrollViewDelegata中常用方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView; 视图已经开始滑动时触发的方法 - (void)scrollViewDidZoom:(UIScrollView *)scrollView; 视图已经开始缩放时触发的方法 - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView; 视图开始拖动时触发的方法 - (void)scrollViewWillEndDragging:(UIScrollView )scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint )targetContentOffset; - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; 视图拖动结束时触发的方法 - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; 视图开始减速时触发的方法 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; 视图减速结束时触发的方法 - (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; 视图动画结束时触发的方法，使用set方法设置偏移量后回触发 - (UIView )viewForZoomingInScrollView:(UIScrollView )scrollView; 返回进行缩放的视图 - (void)scrollViewWillBeginZooming:(UIScrollView )scrollView withView:(UIView )view; 视图内容将要开始缩放时触发的方法 - (void)scrollViewDidEndZooming:(UIScrollView )scrollView withView:(UIView )view atScale:(CGFloat)scale; 视图内容结束缩放时触发的方法 - (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; 返回yes，开启快捷滚动回顶端，将要滚动时调用 - (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; 视图快捷滚动回顶端开始动作时调用 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中UIImageView用法总结","slug":"72iOS中UIImageView用法总结","date":"2015-06-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.405Z","comments":true,"path":"2015/06/03/72iOS中UIImageView用法总结/","link":"","permalink":"http://huishao.cc/2015/06/03/72iOS中UIImageView用法总结/","excerpt":"","text":"iOS中UIImageView用法总结- (instancetype)initWithImage:(UIImage *)image; 通过一个图片UIImage对象进行初始化 - (instancetype)initWithImage:(UIImage )image highlightedImage:(UIImage )highlightedImage; 通过一个正常状态下的图片和高亮状态下的图片初始化对象 @property(nonatomic,retain) UIImage *image; 设置正常状态下的图片 @property(nonatomic,retain) UIImage *highlightedImage; 设置高亮状态下的图片 @property(nonatomic,getter=isUserInteractionEnabled) BOOL userInteractionEnabled; 设置是否开启用户交互 @property(nonatomic,getter=isHighlighted) BOOL highlighted; 设置是否为高亮状态 @property(nonatomic,copy) NSArray *animationImages; 设置正常状态下的动画图片数组 @property(nonatomic,copy) NSArray *highlightedAnimationImages; 设置高亮状态下的动画图片数组 @property(nonatomic) NSTimeInterval animationDuration; 设置动画播放时长 默认频率为30帧每秒 @property(nonatomic) NSInteger animationRepeatCount; 设置动画循环播放次数 默认为无限循环 - (void)startAnimating; 开始播放帧动画 - (void)stopAnimating; 停止播放帧动画 - (BOOL)isAnimating; 是否正在播放动画 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS系统关于URL Schemes的漏洞探究","slug":"70iOS系统关于URL Schemes的漏洞探究","date":"2015-06-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.405Z","comments":true,"path":"2015/06/02/70iOS系统关于URL Schemes的漏洞探究/","link":"","permalink":"http://huishao.cc/2015/06/02/70iOS系统关于URL Schemes的漏洞探究/","excerpt":"","text":"iOS系统关于URL Schemes的漏洞探究一、何为URL Schemes我想这个东西的设计的目的是为了方便App之间的相互调用与通讯，你可以在自己的App中使用OpenURL方法来唤起其他的App。比如微信的URL Schemes是wiexin，我们新建一个工程，实现如下代码后运行程序： 1[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;weixin://]]; 这时你会发现，你的应用启动后很快就调起了微信的客户端。 二、由URL Schemes引发的漏洞的根源1、一个小问题引起的漏洞根源如上所说，通过URL Schemes可以在应用间相互唤起，而产生漏洞的根源在于这个URL并非是应用唯一的。apple并没有任何限制或者审核这个URL的任何措施，也就是说，如果两个App有着相同的URL Schemes，那么系统唤起的App可能并不是你想唤起的。 2、URL Schemes的优先级如何确定由于相同的URL Scheme可能同时被多个App使用，再如果这些App都安装在了同一个设备上，那么系统究竟会唤起哪一个呢？这个我也不能十分的确定，只有一点可以肯定：如果有和系统应用的URL Scheme相同，那么系统一定会唤起系统自己的应用，在这里系统的应用有着最高的优先级（苹果这里做的好像很不厚道，将自己的应用保护了起来，而把广大其他开发者的应用放在漏洞前置之不理）。如果没有和系统耦合的，那么系统会唤起哪一个App就看运气了。不过，这也不是无章可循，经过测试，优先级和App的Bundle identifier有关，更准确说和Bundle identifier的字母排序有关，如果精心设计这个id，我们就可以做到截获其他应用的URL。 3、这个漏洞会引发什么问题么？仅仅通过上面的叙述，你可能还看不出这个漏洞会引发什么样的后果。可是如果你仔细观察，你会发现，各种iPhone上的第三方调用，例如QQ音乐快捷登录，腾讯的各种游戏，甚至包括调用支付宝钱包的支付功能，都是通过这样的原理实现的。如果这些回调的数据被截获，那么就等于说登录信息，用户信息甚至支付订单信息都会暴漏在他人眼下，对于截获者来说，他可以用你的信息进行登录，可以替你完成支付，也可以盗取你登陆后的用户信息。 三、利用URL Scheme漏洞进行远程登录下面，就用一个实例来演示一下我如何通过一个伪装App登录天天炫斗账号。 天天炫斗是腾讯的一款十分火爆的格斗游戏，像其他腾讯游戏一样，支持QQ和微信登录，这里我拿微信登录为例。 首先，我们需要做一个伪装的App来截取用户的登录信息，新建一个项目，在plist文件中添加一个和天天炫斗微信登录相同的URL Scheme： 这里的wx63124814f356e266就是微信登录天天炫斗的URL Scheme，这里将Bundle id设置为A，使它有比天天炫斗更高的优先级。 在AppDelegate中添加如下代码： 1234-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; NSLog(@&quot;%@&quot;,url); return YES;&#125; 这个函数是在App被通过URL唤起时首先调用的函数，这里传入的URL就是用户的登录验证信息，我们可以在这里将这个信息发送回来。 将伪装好的程序跑一遍后，运行天天炫斗，然后使用微信登录，会发现在微信验证成功后跳转后并没有跳转回天天炫斗应用，而是跳转到了我们伪装的这个Demo。这时xcode调试区会打印出如下的信息： 之后，来开始做我们的侵入程序，这个其实更加简单，新建一个工程，只需要添加一行代码： 1[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;wx63124814f356e266://oauth?code=0118aa2f2b99d8a9e0e76a7176b2bd4E&amp;state=weixin&quot;]]; 这里的URL就是我们截获的带参的URL，在另一个装有天天炫斗的手机上跑这个程序（在同一个手机上测试的话要将刚才的伪装App删去，不然它也会将我们的侵入程序一起骗了）。会发现登录天天炫斗成功，角色信息完全一致。 同样的做法，还可以远程登录QQ音乐，天天飞车等等各种通过微信，QQ，微博快捷登录的应用。 四、要战胜你的敌人，必须要了解你的敌人不了解apple为什么一直不对URL Scheme做限制，或许需要或许不需要。但是这一点建议总是好的：在你的App使用快捷登录的时候，最好同时将设备号或者某个本地保存的标志绑定，防止恶意的第三方借此获取用户的信息。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"获取iOS应用的URL Schemes","slug":"71获取iOS应用的URL Schemes","date":"2015-06-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.405Z","comments":true,"path":"2015/06/02/71获取iOS应用的URL Schemes/","link":"","permalink":"http://huishao.cc/2015/06/02/71获取iOS应用的URL Schemes/","excerpt":"","text":"获取任意App的系统配置文件这是一个小技巧，无需设备越狱，可以获取到任意App系统配置文件。 1、在mac上的AppStore商店搜索相应App。 2、下载获取此App。 3、打开iTunes，查看应用程序，选中相应的应用程序点击右键，选择在Finder中显示，然后解压ipa文件，得到一个文件夹。 4、进入文件夹，找到扩展名为app的文件，右键选择显示包内容。info.plist文件就在里面。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS界面布局之一——使用autoresizing进行动态布局","slug":"68iOS界面布局之一——使用autoresizing进行动态布局","date":"2015-05-31T16:00:00.000Z","updated":"2023-04-14T11:50:08.405Z","comments":true,"path":"2015/06/01/68iOS界面布局之一——使用autoresizing进行动态布局/","link":"","permalink":"http://huishao.cc/2015/06/01/68iOS界面布局之一——使用autoresizing进行动态布局/","excerpt":"","text":"iOS界面布局之一——使用autoresizing进行动态布局autoresizing是iOS中传统的界面自动布局方式，通过它，当父视图frame变换时，子视图会自动的做出相应的调整。 一、通过代码进行布局任何一个view都有autoresizingMask这个属性，通过这个属性可以设置当前view与其父视图的相对关系。我们先来看UIViewAutoresizing这个枚举： 123456789typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123; UIViewAutoresizingNone = 0,//默认 UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,//与父视图右边间距固定，左边可变 UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,//视图宽度可变 UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,//与父视图左边间距固定，右边可变 UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3,//与父视图下边间距固定，上边可变 UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4,//视图高度可变 UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5//与父视图上边间距固定，下边可变&#125;; 下面我们通过效果来看这些属性的作用： 先创建两个view，为了区分，设置不同的背景色： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(20, 40, 200, 200)]; view1.backgroundColor=[UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(10, 10, 100, 100)]; view2.backgroundColor=[UIColor greenColor]; [view1 addSubview:view2]; [self.view addSubview:view1];&#125; 设置view2的自动布局属性如下： 1 view2.autoresizingMask=UIViewAutoresizingFlexibleBottomMargin; 这时的效果如下： 改变view1的frame如下： 1UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(20, 40, 300, 300)]; 效果如下： 这时view2的下边距离相对父视图是可变的。 设置如下： 1 view2.autoresizingMask=UIViewAutoresizingFlexibleHeight; 效果如下： 可以看出，这时子视图的高度是随父视图变化而自动改变的。 如下设置： 1view2.autoresizingMask=UIViewAutoresizingFlexibleLeftMargin; 效果如下： 这时子视图的左边是随父视图变化而可变的。 同理，UIViewAutoresizingFlexibleRightMargin将使子视图右边与父视图的距离可变。 UIViewAutoresizingFlexibleTopMargin将使子视图上边与父视图距离可变。UIViewAutoresizingFlexibleWidth将使子视图的宽度可变。 注意：这些自动布局的属性是可以叠加的，比如保持视图与父视图边距不变，如下设置： 1view2.autoresizingMask=UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight; 效果如下： 二、nib文件中可视化设置自动布局在storyboard中我们可以更加轻松的进行autoresizing自动布局。在view设置栏中有autoresizing这个设置，点中相应的箭头，就是刚才我们探讨的设置选项。并且我们把鼠标放在这个上面的时候，右侧会自动为我们预览效果。 如果你觉得autoresizing很强大，那么你就太容易满足了，autoresizing可以满足大部分简单的自动布局需求，可是它有一个致命的缺陷，它只能设置子视图相对于父视图的变化，却不能精确这个变化的度是多少，因此对于复杂的精准的布局需求，它就力不从心了。但是有一个好消息告诉你，iOS6之后的autolayout自动布局方案，正是解决复杂布局的好帮手，我们在下一遍博客中再进行详细讨论。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之二——初识autolayout布局模型","slug":"69iOS界面布局之二——初识autolayout布局模型","date":"2015-05-31T16:00:00.000Z","updated":"2023-04-14T11:50:08.405Z","comments":true,"path":"2015/06/01/69iOS界面布局之二——初识autolayout布局模型/","link":"","permalink":"http://huishao.cc/2015/06/01/69iOS界面布局之二——初识autolayout布局模型/","excerpt":"","text":"iOS界面布局之二——初识autolayout布局模型一、引言 在上一篇博客中介绍了传统的布局方式：autoresizing。随着iphone型号的越来越多，屏幕的标准也更加多样化，通过autoresizing已经不能满足开发的需求，而进行两套布局或者动态代码控制又大大增加了开发者的工作量，autolayout的出现拯救个这一切，它让动态布局变的十分简单便捷。 autoresizing介绍：[http://my.oschina.net/u/2340880/blog/423357](http://my.oschina.net/u/2340880/blog/423357)。 二、autolayout的设计思想正如storyboard的设计目的是为了让开发者将更多的精力投入到逻辑实现而不是界面布局一样。autolayout的设计思想是让开发者将布局上更多的精力放在控件关系上而不是坐标。我们只需要关心控件之间的摆放关系，而并不需要关心这是如何实现的。因此你使用autolayout进行布局时，就是在添加一个一个的约束。控件与控件之间的约束，控件与父视图之间的约束。 1、了解几种约束点击xcode的storyboard文件，在xcode的导航栏上点击Edito，然后选择Pin，可以看到如图，其中是可以添加的约束类型。 Width：对视图宽度的约束 Height：对视图高度的约束 Horizontal Spacing：对视图间水平距离的约束 Vertical Spacing：对视图间垂直距离的约束 Leading Space to Superview：与父视图左边界的约束 Trailing Space to Superview：与父视图右边界的约束 Top Space to Superview：与父视图上边界的约束 Bottom Space to Superview：与父视图下边界的约束 Widehs Equally：视图等宽约束 Heights Equally：视图等高约束 2、网上的一个很简单的约束例子了解了上面的几种约束，现在我们来实现一个效果，借用网上关于autolayout自动布局的一个小例子。我们在storyboard中拖入三个label，使它们如下效果： 然后我们将屏幕横过来，会发现这时的效果并不是我们想得到的结果： 在进行添加约束之前，我们先来理清这三个视图之间的关系，将上面两个视图编号为1.2，下面那个视图编号为3. （1）1和2的宽和高相等 （2）1距离父视图左边20px （3）2距离父视图右边20px （4）3距离父视图左边20px，右边20px （5）1和2水平间距20px （6）1与3垂直间距20px （7）1和2距离父视图上边距50px （8）3距离父视图下边距20px （9）3与1和2的高度一样 通过上面的约束，所有视图的位置都将被相对的固定，下面我们只需要按照顺序一一添加即可。 （1）选中1和2视图（按住cmd键可以多选），然后点击Editor-&gt;Pin之后选择Widehs Equally，重复上面的过程，选择Heights Equally。我们会看到如下的效果： 几点注意： *线是橙色代表警告，我们没有添加足够的约束来确定位置或者约束有矛盾。 *如果线的中间显示的不是等号，而是数字，则是因为视图1和2的尺寸设置的不等，约束有矛盾。 （2）选中1.重复上面步骤，选择Leading Space to Superview。这时1的左边又会增加一条线： 点击这条线，在右边的设置去将约束值设置为20： （3）重复上面步骤，选中视图2，添加Trailing Space to Superview约束。 （4）选中视图3，重复上面步骤。 （5）选中1和2，添加Horizontal Spacing，设置为20. （6）选中1和3，添加Vertical Spacing，设置为20. （7）为1和2分别添加Top Space to Superview约束。 （8）为3添加Bottom Space to Superview约束。 （9）选中1和3，添加Heights Equally约束。 上面的过程虽然繁琐，但是逻辑性十分清晰，这时你会发现所有的线都变成了蓝色，约束已经添加完整，我们再次运行后横屏，效果如下： 这就是我们想要的结果了。 3、自动布局的几种对其方式在xcode导航的Editor菜单中，还有一个子菜单，Align，这里面的选项可以为控件添加对其约束： Left Edges：控件左对齐 Right Edges：控件右对齐 Top Edges：控件上对齐 Bottom Edges：控件下对齐 Horizontal Centers：控件水平中心对齐 Vertical Centers：控件垂直水平对齐 Horizontal Center in Container：控件与其父视图水平中心对齐 Vertical Center in Container：控件与其父视图垂直中心对齐 三、几点小感悟到此为止，基本上已经可以使用autolayout自动布局解决复杂的布局需求了，但是切记，正式因为aotulayout的强大使它会隐藏更多的坑，下面是我的几点感悟，再次分享： 1、autolayout的精髓在于足够多的约束，autolayout之所以比autoresizing强大，就在于其布局的精确性，而精确性正是由约束来提供的。 2、切莫画蛇添足，矛盾的约束会使xcode晕掉，所以在添加约束前，我建议将试图间的布局关系先整理出来。 3、应该转变你的思路，如果你已经习惯了使用CGRect、Point等传统的坐标布局模式，那么你应该稍微转变一下，autolayout倡导的是一个相对的概念，你需要将更多的关注放在视图间的关系，比如A和B距离10，A和C右对齐等。具体的坐标会有autolayout帮你算。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发音频播放基础——AVAudioPlayer的应用","slug":"66iOS开发音频播放基础——AVAudioPlayer的应用","date":"2015-05-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.404Z","comments":true,"path":"2015/05/26/66iOS开发音频播放基础——AVAudioPlayer的应用/","link":"","permalink":"http://huishao.cc/2015/05/26/66iOS开发音频播放基础——AVAudioPlayer的应用/","excerpt":"","text":"iOS音频开发——AVAudioPlayer应用AVAudioPlayer是系统提供给我们的一个音频播放类，在AVFoundation框架下，通过它，我们可以实现一个功能强大的音乐播放器。首先，在项目中我们需要导入AVFoundation这个框架。 一、AVAudioPlayer方法与属性详解初始化方法有两种，通过音频的路径或者音频data数据初始化player对象 12- (instancetype)initWithContentsOfURL:(NSURL *)url error:(NSError **)outError;- (instancetype)initWithData:(NSData *)data error:(NSError **)outError; 注意：支持的音频格式有:AAC,ALAC,HE-AAC,iLBC,IMA4,MP3. 准备播放音频，返回值标志是否解析成功，是否可以播放。 1- (BOOL)prepareToPlay; 开始播放音频 1- (BOOL)play; 在一段时间间隔后播放 1- (BOOL)playAtTime:(NSTimeInterval)time; 暂停播放，并且准备好继续播放 1- (void)pause; 停止播放，不再准备好继续播放 1- (void)stop; 获取是否正在播放 1@property(readonly, getter=isPlaying) BOOL playing; 获取当前音频声道数 1@property(readonly) NSUInteger numberOfChannels; 获取当前音频时长 1@property(readonly) NSTimeInterval duration; 获取创建时的音频路径 1@property(readonly) NSURL *url; 获取创建时的音频数据 1@property(readonly) NSData *data; 设置声道偏移量，0为中心，-1为只有左声道，1为只有右声道 1@property float pan; 设置音频音量，取值为0-1之间 1@property float volume; 设置是否可以改变播放速度 1@property BOOL enableRate; 注意:设置这个属性前必须先调用prepareToPlay这个方法。 设置播放速度，1为正常，0.5为一半速度，2.0为2倍速度 1@property float rate; 设置当前播放的时间点 1@property NSTimeInterval currentTime; 设置音频播放循环次数 1@property NSInteger numberOfLoops; 获取音频设置字典 1@property(readonly) NSDictionary *settings; 是否开启仪表计数功能 1@property(getter=isMeteringEnabled) BOOL meteringEnabled; 更新仪表计数的值 1- (void)updateMeters; 获取指定声道音频峰值 1- (float)peakPowerForChannel:(NSUInteger)channelNumber; 获取指定声道音频平均值 1- (float)averagePowerForChannel:(NSUInteger)channelNumber; 二、AVAudioPlayerDelegate方法详解音频播放结束后调用的函数 1- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag; 播放遇到错误时调用的函数 1- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError *)error; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS后台音频播放及锁屏界面显示音频信息用","slug":"67iOS后台音频播放及锁屏界面显示音频信息","date":"2015-05-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.405Z","comments":true,"path":"2015/05/26/67iOS后台音频播放及锁屏界面显示音频信息/","link":"","permalink":"http://huishao.cc/2015/05/26/67iOS后台音频播放及锁屏界面显示音频信息/","excerpt":"","text":"iOS后台播放音乐及用户交互处理后台播放是任何一个音频软件都支持的功能，在上一篇博客中，详细介绍了使用AVAudioPlayer播放音频的方法，这篇博客将对后台的处理做介绍，关于播放与设置音频的博客地址：http://my.oschina.net/u/2340880/blog/420129。 一、设置后台播放iOS设置后台音频播放的步骤非常简单，首先需要在系统设置的plist文件中添加一个键Required background modes，值为App plays audio or streams audio/video using AirPlay，如下： 然后进行如下代码设置： 123 AVAudioSession *session = [AVAudioSession sharedInstance]; [session setActive:YES error:nil]; [session setCategory:AVAudioSessionCategoryPlayback error:nil]; 此时播放音频时我们点击HOME回到主页面，会发现音频不会停，已经实现后台播放的功能。 二、设置后台用户交互在appDelegate中，我们需要先注册响应后台控制： 1[[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; 然后在appDelegate中我们实现如下函数处理后台传递给我们的信息： 12345-(void)remoteControlReceivedWithEvent:(UIEvent *)event&#123; if (event.type==UIEventTypeRemoteControl) &#123; NSLog(@&quot;%ld&quot;,event.subtype); &#125;&#125; event中的subtype是操作类型，我们打开系统桌面抽屉，可以看到如下的控制键： subtype中的枚举便是点击这些控制键后传递给我们的消息，我们可以根据这些消息在app内做逻辑处理。枚举如下，其中只有100之后的在音频控制中对我们有效： 12345678910111213141516171819202122232425262728typedef NS_ENUM(NSInteger, UIEventSubtype) &#123; // available in iPhone OS 3.0 UIEventSubtypeNone = 0, // for UIEventTypeMotion, available in iPhone OS 3.0 UIEventSubtypeMotionShake = 1, //这之后的是我们需要关注的枚举信息 // for UIEventTypeRemoteControl, available in iOS 4.0 //点击播放按钮或者耳机线控中间那个按钮 UIEventSubtypeRemoteControlPlay = 100, //点击暂停按钮 UIEventSubtypeRemoteControlPause = 101, //点击停止按钮 UIEventSubtypeRemoteControlStop = 102, //点击播放与暂停开关按钮(iphone抽屉中使用这个) UIEventSubtypeRemoteControlTogglePlayPause = 103, //点击下一曲按钮或者耳机中间按钮两下 UIEventSubtypeRemoteControlNextTrack = 104, //点击上一曲按钮或者耳机中间按钮三下 UIEventSubtypeRemoteControlPreviousTrack = 105, //快退开始 点击耳机中间按钮三下不放开 UIEventSubtypeRemoteControlBeginSeekingBackward = 106, //快退结束 耳机快退控制松开后 UIEventSubtypeRemoteControlEndSeekingBackward = 107, //开始快进 耳机中间按钮两下不放开 UIEventSubtypeRemoteControlBeginSeekingForward = 108, //快进结束 耳机快进操作松开后 UIEventSubtypeRemoteControlEndSeekingForward = 109,&#125;; 三、设置后台信息显示及锁屏界面设置设置锁屏界面显示信息的原理是通过设置一个系统的字典，当音频开始播放时，系统会自动从这个字典中读取要显示的信息，如果需要动态显示，我们只需要不断更新这个字典即可。首先需要添加&lt;MediaPlayer/MediaPlayer.h&gt;这个头文件。 代码示例如下： 1234567891011121314151617 NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; //设置歌曲题目 [dict setObject:@&quot;题目&quot; forKey:MPMediaItemPropertyTitle]; //设置歌手名 [dict setObject:@&quot;歌手&quot; forKey:MPMediaItemPropertyArtist]; //设置专辑名 [dict setObject:@&quot;专辑&quot; forKey:MPMediaItemPropertyAlbumTitle]; //设置显示的图片 UIImage *newImage = [UIImage imageNamed:@&quot;43.png&quot;]; [dict setObject:[[MPMediaItemArtwork alloc] initWithImage:newImage] forKey:MPMediaItemPropertyArtwork]; //设置歌曲时长 [dict setObject:[NSNumber numberWithDouble:300] forKey:MPMediaItemPropertyPlaybackDuration]; //设置已经播放时长 [dict setObject:[NSNumber numberWithDouble:150] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; //更新字典 [[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:dict]; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美八——网页框架","slug":"65标签之美八——网页框架","date":"2015-05-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.404Z","comments":true,"path":"2015/05/25/65标签之美八——网页框架/","link":"","permalink":"http://huishao.cc/2015/05/25/65标签之美八——网页框架/","excerpt":"","text":"标签之美——网页框架的应用一、框架集框架集用来设置框架的属性，修饰框架的总体效果。 1、框架宽度cols属性用来设置框架的宽度，示例如下： 12345678&lt;body&gt;&lt;frameset cols=&quot;30%,30%,30%,10%&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 其中属性设置的值可以是百分比，可以是固定值，*符号表示除了已经分配后的剩余空间。上面代码中每个html文件设置不同的背景颜色，效果如下： 2、框架高度使用rows属性可是设置框架的高度。其用法和cols属性类似，示例如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 注意：宽度和高度这两个属性，不能同时使用，只能二选一。 3、边框宽度可以通过border属性设置框架边框的宽度，如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot; border=&quot;10&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 4、边框颜色和其他属性类似，通过bordercolor可以设置边框的颜色。 5、设置是否显示边框通过设置frameborder可以显示和隐藏边框，其值可取0或者1。隐藏效果如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot; frameborder=&quot;0&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 二、框架框架和框架集是可以嵌套的。可以在一个框架中继续嵌套框架集。 1、设置框架大小不可调节使用的框架，默认当鼠标点击拉动时是可以调节大小的，可以设置nosize=”nosize”来设置不可调节。 2、设置框架的滚动条scrolling属性可以设置框架是否显示滚动条,可以设置yes或者no。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS多线程编程之三——GCD的应用","slug":"64iOS多线程编程之三——GCD的应用","date":"2015-05-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.404Z","comments":true,"path":"2015/05/21/64iOS多线程编程之三——GCD的应用/","link":"","permalink":"http://huishao.cc/2015/05/21/64iOS多线程编程之三——GCD的应用/","excerpt":"","text":"iOS多线程编程之三——GCD的应用一、引言在软件开发中使用多线程可以大大的提升用户体验度，增加工作效率。iOS系统中提供了多种分线程编程的方法，在前两篇博客都有提及： NSThread类进行多线程编程：http://my.oschina.net/u/2340880/blog/416524。 NSOperation进行多线程操作编程：http://my.oschina.net/u/2340880/blog/416782。 上两个进行多线程编程的机制都是封装于Object-C的类与方法。这篇博客将讨论的Grand Central Dispatch(GCD)机制，则是基于C语言的，相比上面两种机制，GCD更加高效，并且线程有系统管理，会自动运用多核运算。因为这些优势，GCD是apple推荐我们使用的多线程解决方案。 二、GCD的调度机制GCD机制中一个很重要的概念是调度队列，我们对线程的操作实际上是由调度队列完成的。我们只需要将要执行的任务添加到合适的调度队列中即可。 1、调度队列的类型调度队列有三种类型： （1）主队列 其中的任务在主线程中执行，因为其会阻塞主线程，所以这是一个串行的队列。可以通过dispatch_get_main_queue()方法得到。 （2）全局并行队列 队列中任务的执行方式是严格按照先进先出的模式进行了。如果是串行的队列，则当一个任务结束后，才会开启另一个任务，如果是并行队列，则任务的开启顺序是和添加顺序一致的。系统为iOS应用自动创建了四个全局共享的并发队列。使用如下函数获得： dispatch_get_global_queue(long identifier, unsigned long flags); 其中第一个参数是这个队列的id，系统的四个全局队列默认的优先级不同，这个参数可填的定义如下： 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2//优先级最高的全局队列#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0//优先级中等的全局队列#define DISPATCH_QUEUE_PRIORITY_LOW (-2)//优先级低的全局队列#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN//后台的全局队列 优先级最低 这个函数的第二个参数，按照官方文档的说法是有待未来使用，现在我们都填0即可。 （3）自定义队列 上面的两种队列都是系统为我们创建好的，我们只需要获取到他们，将任务添加即可。当然，我们可可以创建我们自己的队列，包括串行的和并行的。使用如下方法创建： 1dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL); 其中，第一个参数是这个队列的名字，第二个参数决定创建的是串行的还是并行的队列。填写DISPATCH_QUEUE_SERIAL或者NULL创建串行队列，填写DISPATCH_QUEUE_CONCURRENT创建并行队列。 2、添加任务到队列中使用dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)函数或者dispatch_async(dispatch_queue_t queue, dispatch_block_t block)函数来同步或者异步的执行任务，示例如下： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; NSLog(@&quot;%@:1&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;%@:2&quot;,[NSThread currentThread]); &#125;);&#125; 打印结果如下： 可以看出第一个任务在主线程中执行，第二个在分线程中执行。 三、队列调度机制的更多技巧通过上面的演示，我们已经可以运用队列进行多线程的执行任务，但是GCD的强大之处远远不止如此。 1、使用队列组如果有这样三个任务，A与B是没有关系的，他们可以并行执行，C必须在A,B结束之后才能执行，当然，实现这样的逻辑并不困难，使用KVO就可以实现，但是使用队列组处理这样的逻辑，代码会更加清晰简单。 可以使用dispatch_group_create()创建一个队列组，使用如下函数将队列添加到队列组中： 123void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 队列组中的队列是异步执行的，示例如下： 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个队列组 dispatch_group_t group=dispatch_group_create(); 创建一个异步队列 dispatch_queue_t queue=dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); //阻塞线程直到队列任务完成 dispatch_group_wait(group,DISPATCH_TIME_FOREVER); for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;over:%d&quot;,i); &#125;&#125; 打印出来的信息如下： 可以看出，队列中的任务是异步执行的，并且等待队列组中队列任务全部执行后才执行后面的任务。这样的做法在实际应用中我们很少使用，通常我们会把后续的任务在放在异步中执行，做法如下： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个队列组 dispatch_group_t group=dispatch_group_create(); //创建一个队列 dispatch_queue_t queue=dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //添加队列任务到队列组 dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); //队列组任务执行完后执行的任务 dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;over:%d&quot;,i); &#125; &#125;); for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;Finish:%d&quot;,i); &#125; &#125; 打印信息如下： 可以看出GCD的强大了吧，复杂的任务逻辑关系因为GCD变得十分清晰简单。 2、循环机制一开始我们就提到，GCD相比NSOperation的优势在于多核心的应用，更深得挖掘出了硬件的性能。GCD在多核方面的一个明显的特点就是循环机制。 123 dispatch_apply(10, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t i) &#123; NSLog(@&quot;%@:%zu&quot;,[NSThread currentThread],i); &#125;); 打印结果如下： 可以看出，程序的运行效率又会高许多。 3、消息传递机制dispatch_source_t类型的对象可以用来传递和接受某个消息，然后执行block方法，示例如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个数据对象，DISPATCH_SOURCE_TYPE_DATA_ADD的含义表示数据变化时相加 dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue()); //创建接收数据变化的句柄 dispatch_source_set_event_handler(source, ^&#123; NSLog(@&quot;%lu&quot;,dispatch_source_get_data(source)); &#125;); //启动 dispatch_resume(source); //设置数据 dispatch_source_merge_data(source, 1); //这步执行完之后会执行打印方法&#125; 4、发送和等待信号GCD中还有一个重要的概念是信号量。它的用法法消息的传递有所类似，通过代码来解释： 1234567 //创建一个信号，其中的参数为信号的初始值 dispatch_semaphore_t singer = dispatch_semaphore_create(0); //发送信号，使信号量+1 dispatch_semaphore_signal(singer); //等待信号，当信号量大于0时执行后面的方法，否则等待，第二个参数为等待的超时时长，下面设置的为一直等待 dispatch_semaphore_wait(singer, DISPATCH_TIME_FOREVER); NSLog(@&quot;123&quot;); 通过发送信号，可以试信号量+1，每次执行过等待信号后，信号量会-1；如此，我们可以很方便的控制不同队列中方法的执行流程。 5、挂起和开启任务队列GCD还提供了暂停与开始任务的方法，使用 void dispatch_suspend(dispatch_object_t object); 可以将队列或者队列组进行暂时的挂起，使用 void dispatch_resume(dispatch_object_t object); 将队列或者队列组重新开启。 需要注意的是，暂停队列时，队列中正在执行的任务并不会被中断，会挂起未开启的任务。 四、关于内存管理GCD虽然是基于C语言封装的框架，使用了面向对象的思想。因此，它的内存管理是需要我们注意的，不论是ARC或者MRC，我们都应该手动去处理这些对象。还好，GCD的内存管理思路和Object—C是兼容的，我们使用dispatch_retain()和dispatch_release()来将引用对象的计数进行加减。这一点十分重要，切记切记。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美七——为网页添加音乐","slug":"63标签之美七——为网页添加音乐","date":"2015-05-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.404Z","comments":true,"path":"2015/05/20/63标签之美七——为网页添加音乐/","link":"","permalink":"http://huishao.cc/2015/05/20/63标签之美七——为网页添加音乐/","excerpt":"","text":"标签之美——为网页添加音乐一、添加音乐为网页添加音乐可以使用这个标签。其用法和插入图片类似。 标签的几个属性设置如下： src：音频路径 autostart：可是设置为ture或者false，代表是否自动播放。 loop：设置是否循环播放 hidden：是否隐藏播放界面 二、插入背景音乐使用标签插入背景音乐，其中插入路径的写法和插入图片类似。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS多线程编程之一——NSThread线程管理","slug":"61iOS多线程编程之一——NSThread线程管理","date":"2015-05-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.403Z","comments":true,"path":"2015/05/19/61iOS多线程编程之一——NSThread线程管理/","link":"","permalink":"http://huishao.cc/2015/05/19/61iOS多线程编程之一——NSThread线程管理/","excerpt":"","text":"iOS多线程编程之一——NSThread线程管理NSTread是iOS中进行多线程开发的一个类，其结构逻辑清晰，使用十分方便，但其封装度和性能不高，线程周期，加锁等需要手动处理。 一、NSThread类方法总结获取当前线程 1+ (NSThread *)currentThread; 这个方法通过开启一个新的线程执行选择器方法 1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 线程用法示例如下： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [NSThread detachNewThreadSelector:@selector(log) toTarget:self withObject:nil]; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125;-(void)log&#123; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 运行后的打印信息： 可以清晰的看出来，新启的线程和主线程是异步的。 程序是否是多线程执行 1+ (BOOL)isMultiThreaded; 线程字典，我们可以为特殊的线程设置键值对 1@property (readonly, retain) NSMutableDictionary *threadDictionary; 线程在某个时间执行 1+ (void)sleepUntilDate:(NSDate *)date; 线程在等待一个时间间隔后执行 1+ (void)sleepForTimeInterval:(NSTimeInterval)ti; 结束线程 1+ (void)exit; 设置线程的优先级，取值的范围为0-1，1的优先级最高 12+ (double)threadPriority;+ (BOOL)setThreadPriority:(double)p; 这个属性是iOS8之后的新特性，将优先级更人性化的封装了起来 1@property NSQualityOfService qualityOfService; NSQualityOfService的枚举如下： 123456789101112typedef NS_ENUM(NSInteger, NSQualityOfService) &#123; //刷新UI级别的线程 NSQualityOfServiceUserInteractive = 0x21, //用户请求的无需精确的任务的线程，例如点击加载邮件 NSQualityOfServiceUserInitiated = 0x19, //周期性的任务线程，例如定时刷新 NSQualityOfServiceUtility = 0x11, //后台任务的线程 NSQualityOfServiceBackground = 0x09, //优先级未知的线程，优先级介于UserInteractive和Utility之间 NSQualityOfServiceDefault = -1&#125;; 判断是否是主线程 1+ (BOOL)isMainThread; 获取主线程 1+ (NSThread *)mainThread; 二、属性与成员方法总结初始化方法，选择器可以带一个参数 1- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 线程是否正在执行 1@property (readonly, getter=isExecuting) BOOL executing; 线程是否已经执行结束 1@property (readonly, getter=isFinished) BOOL finished; 线程是否已经取消执行 1@property (readonly, getter=isCancelled) BOOL cancelled; 三、隐式的通过NSThread进行多线程编程NSObject的一个类别中提供了支持多线程的方法，如下： 这个函数指定在主线程执行一个选择器，arg是参数，wait是是否立即执行，如果YES，则会阻塞当前主线程的任务，NO则会等待当前任务结束后执行。 1- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait; 这个函数指定在某个线程执行选择器 1- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; 指定在后台线程中执行选择器 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS多线程编程之二——NSOperation与NSOperationQueue","slug":"62iOS多线程编程之二——NSOperation与NSOperationQueue","date":"2015-05-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.404Z","comments":true,"path":"2015/05/19/62iOS多线程编程之二——NSOperation与NSOperationQueue/","link":"","permalink":"http://huishao.cc/2015/05/19/62iOS多线程编程之二——NSOperation与NSOperationQueue/","excerpt":"","text":"iOS多线程编程之二——NSOperation与NSOperationQueue一、NSOperation解析NSOperation是基于Objective-C封装的一套管理与执行线程操作的类。这个类是一个抽象类，通常情况下，我们会使用NSInvocationOperation和NSBlockOperation这两个子类进行多线程的开发，当然我们也可以写继承于NSOperation的类，封装我们自己的操作类。 1、NSOperation抽象类中提供的逻辑方法操作开始执行 1- (void)start; 在子类中可以重写这个方法，实现执行的方法 1- (void)main; 取消执行 1- (void)cancel; 获取当操作状态的几个属性 12345@property (readonly, getter=isCancelled) BOOL cancelled;//当前操作是否取消执行@property (readonly, getter=isExecuting) BOOL executing;//当前操作是否正在执行@property (readonly, getter=isFinished) BOOL finished;//当前操作是否执行结束@property (readonly, getter=isAsynchronous) BOOL asynchronous;//当前操作是否在异步线程中@property (readonly, getter=isReady) BOOL ready;//当前操作是否已经准备好 阻塞当前线程直到操作完成 1- (void)waitUntilFinished; 设置在操作队列中的优先级 1@property NSOperationQueuePriority queuePriority; 其中NSOperationQueuePriority的枚举如下： 1234567typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L,//优先级很低 NSOperationQueuePriorityLow = -4L,//优先级低 NSOperationQueuePriorityNormal = 0,//优先级普通 NSOperationQueuePriorityHigh = 4,//优先级高 NSOperationQueuePriorityVeryHigh = 8//优先级非常高&#125;; 设置操作完成后的回调block 1@property (copy) void (^completionBlock)(void); 设置操作的优先级 1@property double threadPriority; 设置操作的名称 1@property (copy) NSString *name; 2、带block的操作类实例——NSBlockOperationNSBlockOperation是NSOperation的一个子类，其可以异步的执行多个block，当所有的block都完成时，这个操作才算完成。 初始化方法： 1+ (instancetype)blockOperationWithBlock:(void (^)(void))block; 在操作中添加block 1- (void)addExecutionBlock:(void (^)(void))block; 添加进去的block的数组 1@property (readonly, copy) NSArray *executionBlocks; 示例如下： 1234567891011NSBlockOperation * opera = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;]; [opera addExecutionBlock:^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;]; [opera start]; 打印情况如下，可以看出，两个block块的执行是异步的： 3、使用NSInvocationOperation调用方法根据选择器创建一个对象 1- (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(id)arg; 通过Invocation创建一个对象 1- (instancetype)initWithInvocation:(NSInvocation *)inv; 这个类执行的操作是与调用它的线程同步的，示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSInvocationOperation * operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(log) object:nil]; [operation start]; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;-(void)log&#123; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 通过打印结果可以看出其执行的同步性。 二、操作之间的依赖关系依赖关系和优先级的作用很像，却也不同。如果一个操作A依赖于另一个操作B，那么只有当B操作完成后，A操作才会执行。操作添加依赖的 添加一个依赖： 1- (void)addDependency:(NSOperation *)op; 删除一个依赖 1- (void)removeDependency:(NSOperation *)op; 原则上说，一个操作对象的依赖可以添加多个，并且当所有依赖都执行完成后才会执行这个操作。 三、NSOperationQueue操作队列NSOperationQueue是操作队列类，通过上面的介绍，我们已经可以理解操作，并且操作默认的执行方式是串行的，尽管NSBlockOperation中的block块间是并行执行的，但其和外部操作依然是串行的。如果将操作放入操作队列中，则默认为并行执行的。 示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSOperationQueue * queue = [[NSOperationQueue alloc]init]; NSInvocationOperation * op1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(log) object:nil]; [queue addOperation:op1]; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125;-(void)log&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 打印信息如下： 可以看出来，队列的操作是在一个新的线程中执行的，并且操作队列之中的操作也都是异步执行的。 在操作队列中添加一个操作任务： 1- (void)addOperation:(NSOperation *)op; 在队列中插入一组操作任务，后面的参数设置是否队列中得任务都执行完成后再执行这一组操作： 1- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 在队列中添加一个block操作 1- (void)addOperationWithBlock:(void (^)(void))block; 获取操作队列中的所有操作的数组 1@property (readonly, copy) NSArray *operations; 获取操作队列中操作的个数 1@property (readonly) NSUInteger operationCount; 设置队列最大并行操作数量 1@property NSInteger maxConcurrentOperationCount; 设置是否暂停队列任务执行 1@property (getter=isSuspended) BOOL suspended; 设置队列名字 1@property (copy) NSString *name; 设置队列的优先级别（iOS8后支持） 1@property NSQualityOfService qualityOfService; 取消队列中所有操作任务 1- (void)cancelAllOperations; 阻塞当前线程，直到队列中所有任务完成 1- (void)waitUntilAllOperationsAreFinished; 获取当前执行的队列 1+ (NSOperationQueue *)currentQueue; 获取主线程中的操作队列 1+ (NSOperationQueue *)mainQueue; 四、队列中操作的执行顺序法则1、决定于依赖关系，只有当这个操作的依赖全部执行完成后，它才会被执行。 2、影响于优先级，优先级高的会先执行。 如有疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发进阶——使用导航和附近兴趣点检索","slug":"60iOS原生地图开发进阶——使用导航和附近兴趣点检索","date":"2015-05-17T16:00:00.000Z","updated":"2023-04-14T11:50:08.403Z","comments":true,"path":"2015/05/18/60iOS原生地图开发进阶——使用导航和附近兴趣点检索/","link":"","permalink":"http://huishao.cc/2015/05/18/60iOS原生地图开发进阶——使用导航和附近兴趣点检索/","excerpt":"","text":"iOS原生地图开发进阶——使用导航和附近兴趣点检索iOS中的mapKit框架对国际化的支持非常出色。在前些篇博客中，对这个地图框架的基础用法和标注与覆盖物的添加进行了详细的介绍，这篇博客将介绍两个更加实用的功能的开发：线路导航与兴趣点搜索。前几篇博客的链接如下： 地图基础用法详解：http://my.oschina.net/u/2340880/blog/415360。 添加大头针与自定义标注：http://my.oschina.net/u/2340880/blog/415441。 添加地图覆盖物：http://my.oschina.net/u/2340880/blog/415611。 一、线路导航1、从几个类的关系说起(1)MKPlacemark 一个地点信息类，如下： 1234567@interface MKPlacemark : CLPlacemark &lt;MKAnnotation&gt;//初始化方法，通过给定一个经纬度和地点信息字典- (instancetype)initWithCoordinate:(CLLocationCoordinate2D)coordinate addressDictionary:(NSDictionary *)addressDictionary;//国家编码@property (nonatomic, readonly) NSString *countryCode;@end (2)MKMapItem 地点节点类，包含此节点的许多地点信息，如下： 1234567891011121314151617@interface MKMapItem : NSObject//当前节点的地点信息对象@property (nonatomic, readonly) MKPlacemark *placemark;//是否是当前位置@property (nonatomic, readonly) BOOL isCurrentLocation;//节点名称@property (nonatomic, copy) NSString *name;//电话号码@property (nonatomic, copy) NSString *phoneNumber;//网址@property (nonatomic, strong) NSURL *url;//将当前位置创建为节点+ (MKMapItem *)mapItemForCurrentLocation;//由一个位置信息创建节点- (instancetype)initWithPlacemark:(MKPlacemark *)placemark;@end (3)MKDirectionsRequest 导航请求类 123456789@interface MKDirectionsRequest : NSObject//起点节点- (MKMapItem *)source NS_AVAILABLE(10_9, 6_0);- (void)setSource:(MKMapItem *)source NS_AVAILABLE(10_9, 7_0);//目的地节点- (MKMapItem *)destination NS_AVAILABLE(10_9, 6_0);- (void)setDestination:(MKMapItem *)destination NS_AVAILABLE(10_9, 7_0);@end 这个类还有一些扩展的设置属性： @property (nonatomic) MKDirectionsTransportType transportType; 设置路线检索类型，枚举如下： 12345typedef NS_OPTIONS(NSUInteger, MKDirectionsTransportType) &#123; MKDirectionsTransportTypeAutomobile = 1 &lt;&lt; 0,//适合驾车时导航 MKDirectionsTransportTypeWalking = 1 &lt;&lt; 1,//适合步行时导航 MKDirectionsTransportTypeAny = 0x0FFFFFFF//任何情况&#125;; @property (nonatomic) BOOL requestsAlternateRoutes; 设置是否搜索多条线路 @property (nonatomic, copy) NSDate *departureDate; 设置出发日期 @property (nonatomic, copy) NSDate *arrivalDate; 设置到达日期 （4）MKDirections 从apple服务器获取数据的连接类 123456789101112@interface MKDirections : NSObject//初始化方法- (instancetype)initWithRequest:(MKDirectionsRequest *)request NS_DESIGNATED_INITIALIZER;//开始计算线路信息- (void)calculateDirectionsWithCompletionHandler:(MKDirectionsHandler)completionHandler;//开始计算时间信息- (void)calculateETAWithCompletionHandler:(MKETAHandler)completionHandler;//取消- (void)cancel;//是否正在计算@property (nonatomic, readonly, getter=isCalculating) BOOL calculating;@end (5)MKDirectionsResponse 线路信息结果类 12345@interface MKDirectionsResponse : NSObject@property (nonatomic, readonly) MKMapItem *source;//起点@property (nonatomic, readonly) MKMapItem *destination;//终点@property (nonatomic, readonly) NSArray *routes; //线路规划数组@end (6)MKETResponse 时间信息结果类 123456@interface MKETAResponse : NSObject@property (nonatomic, readonly) MKMapItem *source;//起点@property (nonatomic, readonly) MKMapItem *destination;//终点@property (nonatomic, readonly) NSTimeInterval expectedTravelTime;//耗时@end (7)MKRoute 线路信息类，导航的线路结果是这个类型的对象 12345678910111213@interface MKRoute : NSObject@property (nonatomic, readonly) NSString *name; //线路名称@property (nonatomic, readonly) NSArray *advisoryNotices; //注意事项@property (nonatomic, readonly) CLLocationDistance distance; //距离@property (nonatomic, readonly) NSTimeInterval expectedTravelTime;//耗时@property (nonatomic, readonly) MKDirectionsTransportType transportType; //检索的类型@property (nonatomic, readonly) MKPolyline *polyline; // 线路覆盖物@property (nonatomic, readonly) NSArray *steps; // 线路详情数组@end （8）MKRouteStep 线路详情信息类，线路中每一步的信息都是这个类的对象 123456789101112@interface MKRouteStep : NSObject@property (nonatomic, readonly) NSString *instructions; // 节点信息@property (nonatomic, readonly) NSString *notice; // 注意事项@property (nonatomic, readonly) MKPolyline *polyline; //线路覆盖物@property (nonatomic, readonly) CLLocationDistance distance; // 距离@property (nonatomic, readonly) MKDirectionsTransportType transportType; // 导航类型@end 看到上面如此多的类，你可能会觉得一头雾水，那么不用着急，类虽然繁杂，但他们之间的逻辑非常清晰，下面就通过一个例子来进行线路导航。 2、进行线路导航12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667- (void)viewDidLoad &#123; [super viewDidLoad]; //地图初始化设置 mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(5, 5)); mapView.mapType=MKMapTypeStandard; mapView.delegate=self; [self.view addSubview:mapView]; //导航设置 CLLocationCoordinate2D fromcoor=CLLocationCoordinate2DMake(39.26, 116.3); CLLocationCoordinate2D tocoor = CLLocationCoordinate2DMake(33.33, 113.33); //创建出发点和目的点信息 MKPlacemark *fromPlace = [[MKPlacemark alloc] initWithCoordinate:fromcoor addressDictionary:nil]; MKPlacemark *toPlace = [[MKPlacemark alloc]initWithCoordinate:tocoor addressDictionary:nil]; //创建出发节点和目的地节点 MKMapItem * fromItem = [[MKMapItem alloc]initWithPlacemark:fromPlace]; MKMapItem * toItem = [[MKMapItem alloc]initWithPlacemark:toPlace]; //初始化导航搜索请求 MKDirectionsRequest *request = [[MKDirectionsRequest alloc]init]; request.source=fromItem; request.destination=toItem; request.requestsAlternateRoutes=YES; //初始化请求检索 MKDirections *directions = [[MKDirections alloc]initWithRequest:request]; //开始检索，结果会返回在block中 [directions calculateDirectionsWithCompletionHandler:^(MKDirectionsResponse *response, NSError *error) &#123; if (error) &#123; NSLog(@&quot;error:%@&quot;,error); &#125;else&#123; //提取导航线路结果中的一条线路 MKRoute *route =response.routes[0]; //将线路中的每一步详情提取出来 NSArray * stepArray = [NSArray arrayWithArray:route.steps]; //进行遍历 for (int i=0; i&lt;stepArray.count; i++) &#123; //线路的详情节点 MKRouteStep * step = stepArray[i]; //在此节点处添加一个大头针 MKPointAnnotation * point = [[MKPointAnnotation alloc]init]; point.coordinate=step.polyline.coordinate; point.title=step.instructions; point.subtitle=step.notice; [mapView addAnnotation:point]; //将此段线路添加到地图上 [mapView addOverlay:step.polyline]; &#125; &#125; &#125;]; &#125;//地图覆盖物的代理方法-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKPolylineRenderer *renderer = [[MKPolylineRenderer alloc] initWithPolyline:overlay]; renderer.strokeColor = [UIColor redColor]; renderer.lineWidth = 4.0; return renderer;&#125;//标注的代理方法-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; MKPinAnnotationView * view= [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;anno&quot;]; view.canShowCallout=YES; return view;&#125; 效果如下： 二、附近兴趣点检索兴趣点检索的逻辑和导航线路检索的逻辑相似，直接通过代码来演示： 1234567891011121314151617181920212223 //创建一个位置信息对象，第一个参数为经纬度，第二个为纬度检索范围，单位为米，第三个为经度检索范围，单位为米 MKCoordinateRegion region = MKCoordinateRegionMakeWithDistance(tocoor, 5000, 5000); //初始化一个检索请求对象 MKLocalSearchRequest * req = [[MKLocalSearchRequest alloc]init]; //设置检索参数 req.region=region; //兴趣点关键字 req.naturalLanguageQuery=@&quot;hotal&quot;; //初始化检索 MKLocalSearch * ser = [[MKLocalSearch alloc]initWithRequest:req]; //开始检索，结果返回在block中 [ser startWithCompletionHandler:^(MKLocalSearchResponse *response, NSError *error) &#123; //兴趣点节点数组 NSArray * array = [NSArray arrayWithArray:response.mapItems]; for (int i=0; i&lt;array.count; i++) &#123; MKMapItem * item=array[i]; MKPointAnnotation * point = [[MKPointAnnotation alloc]init]; point.title=item.name; point.subtitle=item.phoneNumber; point.coordinate=item.placemark.coordinate; [mapView addAnnotation:point]; &#125; &#125;]; 效果如下： 如果疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南再续——地图覆盖物的应用","slug":"59iOS原生地图开发指南再续——地图覆盖物的应用","date":"2015-05-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.403Z","comments":true,"path":"2015/05/16/59iOS原生地图开发指南再续——地图覆盖物的应用/","link":"","permalink":"http://huishao.cc/2015/05/16/59iOS原生地图开发指南再续——地图覆盖物的应用/","excerpt":"","text":"iOS原生地图开发指南再续——地图覆盖物的应用一、引言在前两篇博客中，将iOS系统的地图框架MapKit中地图的设置与应用以及关于添加大头针和自定义大头针的相关操作做了详细的介绍。链接如下：http://my.oschina.net/u/2340880/blog/415360、http://my.oschina.net/u/2340880/blog/415441。这篇博客中将进一步讨论关于地图添加覆盖物的使用方法。 二、添加地图覆盖物的逻辑原理地图覆盖物其实就是在地图上画一些东西，例如路径，范围等等。添加地图覆盖物的逻辑原理其实和添加大头针很相似。首先所有可以成为覆盖物的对象必须遵守MKOverlay这个协议，通过 - (void)addOverlay:(id )overlay; 将覆盖物添加在地图上，然后地图会调用代理方法 -(MKOverlayRenderer )mapView:(MKMapView )mapView rendererForOverlay:(id)overlay; 对覆盖物进行绘制，我们可以在这个方法中设置覆盖物，例如线宽，颜色等，注意，必须实现这个方法，覆盖物才会显示。 1、添加折线覆盖物12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //初始化地图对象 MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; //设置地图 _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); //设置代理 _mapView.delegate=self; //下面是C的语法，创建一个结构体数组 CLLocationCoordinate2D *coor; coor = malloc(sizeof(CLLocationCoordinate2D)*5); for (int i=0; i&lt;5; i++) &#123; CLLocationCoordinate2D po = CLLocationCoordinate2DMake(33.23+i*0.01, 113.112); coor[i]=po; &#125; //创建一个折线对象 MKPolyline * line = [MKPolyline polylineWithCoordinates:coor count:5]; [_mapView addOverlay:line]; [self.view addSubview:_mapView];&#125;//覆盖物绘制的代理-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; //折线覆盖物提供类 MKPolylineRenderer * render = [[MKPolylineRenderer alloc]initWithPolyline:overlay]; //设置线宽 render.lineWidth=3; //设置颜色 render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 2、添加圆形覆盖物1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); _mapView.delegate=self; //创建圆形覆盖物对象 MKCircle * cirle = [MKCircle circleWithCenterCoordinate:CLLocationCoordinate2DMake(33.23, 113.122) radius:500]; [_mapView addOverlay:cirle]; [self.view addSubview:_mapView];&#125;-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKCircleRenderer * render=[[MKCircleRenderer alloc]initWithCircle:overlay]; render.lineWidth=3; //填充颜色 render.fillColor=[UIColor greenColor]; //线条颜色 render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 3、添加多边形覆盖物1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); _mapView.delegate=self; CLLocationCoordinate2D *coor; coor = malloc(sizeof(CLLocationCoordinate2D)*6); for (int i=0; i&lt;5; i++) &#123; CLLocationCoordinate2D po = CLLocationCoordinate2DMake(33.23+i*0.01, 113.112+((i/2==0)?0.01:-0.01)); coor[i]=po; &#125; coor[5]=CLLocationCoordinate2DMake(33.23, 113.112); MKPolygon * gon = [MKPolygon polygonWithCoordinates:coor count:6]; [_mapView addOverlay:gon]; [self.view addSubview:_mapView];&#125;-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKPolygonRenderer * render = [[MKPolygonRenderer alloc]initWithPolygon:overlay]; render.lineWidth=3; render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南续——大头针与自定义标注","slug":"58iOS原生地图开发指南续——大头针与自定义标注","date":"2015-05-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.403Z","comments":true,"path":"2015/05/15/58iOS原生地图开发指南续——大头针与自定义标注/","link":"","permalink":"http://huishao.cc/2015/05/15/58iOS原生地图开发指南续——大头针与自定义标注/","excerpt":"","text":"iOS原生地图开发指南续——大头针与自定义标注在上一篇博客中http://my.oschina.net/u/2340880/blog/415360系统总结了iOS原生地图框架MapKit中主体地图的设置与应用。这篇是上一篇的一个后续，总结了系统的大头针视图以及自定义标注视图的方法。 一、先来认识一个协议MKAnnotation官方文档告诉我们，所有标注的类必须遵守这个协议。所以可以了解，标注这个概念在逻辑属性和视图上是分开的。先来看下这个协议声明了哪些方法： 123456789@protocol MKAnnotation &lt;NSObject&gt;@property (nonatomic, readonly) CLLocationCoordinate2D coordinate;//地理坐标位置@optional@property (nonatomic, readonly, copy) NSString *title;//标题@property (nonatomic, readonly, copy) NSString *subtitle;//副标题//拖动时调用- (void)setCoordinate:(CLLocationCoordinate2D)newCoordinate;@end 二、创建一个系统标注大头针123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化地图 mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; //设置代理 mapView.delegate=self; //设置位置 mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(1.8, 1)); mapView.mapType=MKMapTypeStandard; //初始化一个大头针类 MKPointAnnotation * ann = [[MKPointAnnotation alloc]init]; //设置大头针坐标 ann.coordinate=CLLocationCoordinate2DMake(39.26, 116.3); ann.title=@&quot;我&quot;; ann.subtitle=@&quot;看这里&quot;; [mapView addAnnotation:ann]; [self.view addSubview:mapView];&#125; 效果如下： 重绘大头针视图，大头针渲染时会调用地图代理的方法，我们可以重写这个方法进行大头针的重绘，来更改其颜色： 123456-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; //创建一个系统大头针对象 MKPinAnnotationView * view = [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;pin&quot;]; view.pinColor=MKPinAnnotationColorGreen;//设置颜色为绿色 return view;&#125; 效果如下： MKAnnotationView是标注的视图类，一会我们通过它来自定义我们自己的标注，先来看MKPinAnnotationView这个类，这个类继承于MKAnnotationView，是一个大头针视图类。这个类根简单，只有一下两个属性： @property (nonatomic) MKPinAnnotationColor pinColor; 设置大头针的颜色，枚举如下： 12345typedef NS_ENUM(NSUInteger, MKPinAnnotationColor) &#123; MKPinAnnotationColorRed = 0,//红色 MKPinAnnotationColorGreen,//绿色 MKPinAnnotationColorPurple//紫色&#125;; @property (nonatomic) BOOL animatesDrop; 设置添加时是否显示降落动画 三、自定义标注视图123456789101112131415161718-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; MKAnnotationView * view = [[MKAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;annotation&quot;]; //设置标注的图片 view.image=[UIImage imageNamed:@&quot;保温车0.png&quot;]; //点击显示图详情视图 必须MKPointAnnotation对象设置了标题和副标题 view.canShowCallout=YES; //创建了两个view UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 50, 50)]; view1.backgroundColor=[UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 50)]; view2.backgroundColor=[UIColor blueColor]; //设置左右辅助视图 view.leftCalloutAccessoryView=view1; view.rightCalloutAccessoryView=view2; //设置拖拽 可以通过点击不放进行拖拽 view.draggable=YES; return view;&#125; 效果如下： 四、标注视图类MKAnnotationView的其他常用属性解读@property (nonatomic) CGPoint centerOffset; 视图中心的偏移量 @property (nonatomic) CGPoint calloutOffset; 点击后弹出视图的偏移量 @property (nonatomic, getter=isEnabled) BOOL enabled; 设置是否有效 @property (nonatomic, getter=isHighlighted) BOOL highlighted; 是否高亮状态 @property (nonatomic) CGPoint leftCalloutOffset; 设置左辅助视图的偏移量 @property (nonatomic) CGPoint rightCalloutOffset; 设置右辅助视图的偏移量 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南","slug":"57iOS原生地图开发指南","date":"2015-05-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.403Z","comments":true,"path":"2015/05/15/57iOS原生地图开发指南/","link":"","permalink":"http://huishao.cc/2015/05/15/57iOS原生地图开发指南/","excerpt":"","text":"iOS原生地图开发详解 在上一篇博客中:http://my.oschina.net/u/2340880/blog/414760。对iOS中的定位服务进行了详细的介绍与参数说明，在开发中，地位服务往往与地图框架结合使用，这篇博客主要对iOS官方的地图框架MapKit.framework进行介绍。 一、初始化地图视图与相关属性方法介绍1、初始化地图视图地图视图的展示依赖于MKMapView这个类，这个类继承于UIView，因此和其他View的使用方法类似。在我们需要展现地图的地方： 12345- (void)viewDidLoad &#123; [super viewDidLoad]; MKMapView * mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; [self.view addSubview:mapView];&#125; 运行发现，一张世界地图就在我们的设备上了，apple内置的地图数据是由高德提供的。 2、系统提供的三种地图样式可以通过MKMapView的mapType这个属性设置地图的模式： @property (nonatomic) MKMapType mapType; 枚举如下： 12345typedef NS_ENUM(NSUInteger, MKMapType) &#123; MKMapTypeStandard = 0,//标准式的行政地图(会显示城市，街道等) MKMapTypeSatellite,//标准的卫星地图 MKMapTypeHybrid//混合地图(在卫星图上显示街道等名称)&#125;; 3、设置地图的中心和比例尺在百度地图等第三方地图服务的SDK中，都会提供一个类似zoomLevel比例尺的属性。通过官方的API设置这个属性有些麻烦，但是也更加灵活。首先，设置地图的中心位置和比例尺是通过region这个属性实现的。region结构体如下： 1234typedef struct &#123; CLLocationCoordinate2D center;//地图中心的经纬度 MKCoordinateSpan span;//地图显示的经纬度范围&#125; MKCoordinateRegion; 这个结构体中包含了两个结构体，其中CLLocationCoordinate2D很好理解，就是简单的经纬度，解释如下： 1234typedef struct &#123; CLLocationDegrees latitude;//纬度，北纬为正，南纬为负 CLLocationDegrees longitude;//经度，东经为正，西经为负&#125; CLLocationCoordinate2D; MKCoordinateSpan这个结构体比较复杂，如下： 1234typedef struct &#123; CLLocationDegrees latitudeDelta;//纬度范围 CLLocationDegrees longitudeDelta;//经度范围&#125; MKCoordinateSpan; 这个结构体定义的应该是一个范围，因为北纬南纬加起来180°，所以纬度范围的取值应为0-180。同理，经度范围的取值范围为0-360。 通过上面的介绍，我们举个例子，将北京市设为地图的中心区域，并且比例设置为显示北京大小。通过百度，首先知道北京市界的地理坐标为：北纬39”26’至41”03’，东经115”25’至 117”30’。北京市区坐标为：北纬39.9”，东经116. 3”。代码如下： 1mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(1.8, 2.05)); 运行后可以看到，北京市基本上是在地图中心的，效果如下： 注意：MKCoordinateSpan的显示范围是取决于大的一边的，比如如果我们这样写： 1MKCoordinateSpanMake(1.8, 360); 最后依然会显示整个世界地图。 - (void)setRegion:(MKCoordinateRegion)region animated:(BOOL)animated; 这个方法可以在设置后给地图加上动画效果 @property (nonatomic) CLLocationCoordinate2D centerCoordinate; 设置地图的中心点位置 - (void)setCenterCoordinate:(CLLocationCoordinate2D)coordinate animated:(BOOL)animated; 设置地图的中心点位置，并附带动画效果 4、坐标转换方法- (CGPoint)convertCoordinate:(CLLocationCoordinate2D)coordinate toPointToView:(UIView *)view; 将经纬度转换为视图上的坐标 - (CLLocationCoordinate2D)convertPoint:(CGPoint)point toCoordinateFromView:(UIView *)view; 将视图上的坐标转换为经纬度 - (CGRect)convertRegion:(MKCoordinateRegion)region toRectToView:(UIView *)view; 将地理显示的区域转换为视图上的坐标区域 - (MKCoordinateRegion)convertRect:(CGRect)rect toRegionFromView:(UIView *)view;将视图上的坐标区域转换为地理区域 5、MKMapView常用方法和属性@property (nonatomic, getter=isZoomEnabled) BOOL zoomEnabled; 设置是否允许捏合手势进行地图缩放 @property (nonatomic, getter=isScrollEnabled) BOOL scrollEnabled; 设置是否允许滑动 @property (nonatomic, getter=isRotateEnabled) BOOL rotateEnabled; 设置是否允许旋转地图 @property (nonatomic, getter=isPitchEnabled) BOOL pitchEnabled; 设置是否支持3D效果 @property (nonatomic) BOOL showsPointsOfInterest; 设置是否显示兴趣点，例如学校，医院等 @property (nonatomic) BOOL showsBuildings; 设置是否显示建筑物轮廓，只在标准的地图中有效 @property (nonatomic) BOOL showsUserLocation; 是否显示用户位置 @property (nonatomic) MKUserTrackingMode userTrackingMode; - (void)setUserTrackingMode:(MKUserTrackingMode)mode animated:(BOOL)animated; 设置更新用户位置的模式,当显示用户位置设置为YES，这个方法也设置了后，地图框架为我们直接集成了定位，地图上就会显示我们的位置，模式的枚举如下： 12345typedef NS_ENUM(NSInteger, MKUserTrackingMode) &#123; MKUserTrackingModeNone = 0, // 不跟踪用户位置 MKUserTrackingModeFollow, // 跟踪用户位置 MKUserTrackingModeFollowWithHeading, // 当方向改变时跟踪用户位置&#125; @property (nonatomic, readonly) MKUserLocation *userLocation; 获取用户位置的标注 @property (nonatomic, readonly, getter=isUserLocationVisible) BOOL userLocationVisible; 获取用户位置是否可见 - (void)addAnnotation:(id )annotation; 在地图上添加一个标注 - (void)addAnnotations:(NSArray *)annotations;在地图上添加一组标注- (void)removeAnnotation:(id )annotation; 移除一个标注 - (void)removeAnnotations:(NSArray *)annotations; 移除一组标注 @property (nonatomic, readonly) NSArray *annotations; 获取所有标注数组 - (MKAnnotationView *)viewForAnnotation:(id )annotation; 获取标注的视图 - (MKAnnotationView )dequeueReusableAnnotationViewWithIdentifier:(NSString )identifier; 获取复用的标注 - (void)selectAnnotation:(id )annotation animated:(BOOL)animated; 选中一个标注 - (void)deselectAnnotation:(id )annotation animated:(BOOL)animated; 取消选中一个标注 @property (nonatomic, copy) NSArray *selectedAnnotations; 选中标注的数组 - (void)addOverlay:(id )overlay level:(MKOverlayLevel)level; 添加一个地图覆盖物，level是设置一个层级，枚举如下： 1234typedef NS_ENUM(NSInteger, MKOverlayLevel) &#123; MKOverlayLevelAboveRoads = 0, // 覆盖物位于道路之上 MKOverlayLevelAboveLabels//覆盖物位于标签之上&#125; - (void)addOverlays:(NSArray *)overlays level:(MKOverlayLevel)level; 添加一组地图覆盖物 - (void)removeOverlay:(id )overlay; 移除一个地图覆盖物 - (void)removeOverlays:(NSArray *)overlays; 移除一组地图覆盖物 - (void)insertOverlay:(id )overlay atIndex:(NSUInteger)index level:(MKOverlayLevel)level; 在索引处插入一个地图覆盖物 - (void)insertOverlay:(id )overlay aboveOverlay:(id )sibling; 将一个地图覆盖物插在到某个覆盖物之上 - (void)insertOverlay:(id )overlay belowOverlay:(id )sibling; 将一个地图覆盖物插入到某个覆盖物之下 - (void)exchangeOverlay:(id )overlay1 withOverlay:(id )overlay2; 替换一个地图覆盖物 @property (nonatomic, readonly) NSArray *overlays; 地图覆盖物数组 - (NSArray *)overlaysInLevel:(MKOverlayLevel)level; 层级属性下的东土覆盖物数组 二、MKMapViewDelegate相关方法解读- (void)mapView:(MKMapView *)mapView regionWillChangeAnimated:(BOOL)animated; 地图显示位置将要改变时调用的方法 - (void)mapView:(MKMapView *)mapView regionDidChangeAnimated:(BOOL)animated; 地图显示位置已经改变时调用的方法 - (void)mapViewWillStartLoadingMap:(MKMapView *)mapView; 地图将要加载时调用的方法 - (void)mapViewDidFinishLoadingMap:(MKMapView *)mapView; 地图加载完成时执行的方法 - (void)mapViewDidFailLoadingMap:(MKMapView )mapView withError:(NSError )error; 地图加载失败时执行的方法 - (MKAnnotationView )mapView:(MKMapView )mapView viewForAnnotation:(id )annotation; 渲染标注视图时调用的方法，可以通过这个方法自定义标注视图 - (void)mapView:(MKMapView )mapView didAddAnnotationViews:(NSArray )views; 标注添加完成后调用的方法 - (void)mapView:(MKMapView )mapView didSelectAnnotationView:(MKAnnotationView )view; 选中标注时调用的方法 - (void)mapView:(MKMapView )mapView didDeselectAnnotationView:(MKAnnotationView )view; 取消选中标注时调用的方法 - (void)mapViewWillStartLocatingUser:(MKMapView *)mapView; 将要开始定位用户位置时调用的方法 - (void)mapViewDidStopLocatingUser:(MKMapView *)mapView; 停止定位用户位置时调用的方法 - (void)mapView:(MKMapView )mapView didUpdateUserLocation:(MKUserLocation )userLocation; 更新用户位置时调用的方法 - (void)mapView:(MKMapView )mapView didFailToLocateUserWithError:(NSError )error; 更新用户位置失败时调用的方法 - (void)mapView:(MKMapView )mapView annotationView:(MKAnnotationView )view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState; 标注拖动状态改变调用的方法，MKAnnotationViewDragState的枚举如下： 1234567typedef NS_ENUM(NSUInteger, MKAnnotationViewDragState) &#123; MKAnnotationViewDragStateNone = 0, // 初始状态 MKAnnotationViewDragStateStarting, // 开始拖动时 MKAnnotationViewDragStateDragging, // 正在拖动 MKAnnotationViewDragStateCanceling, // 取消拖动 MKAnnotationViewDragStateEnding // 结束拖动&#125;; - (void)mapView:(MKMapView *)mapView didChangeUserTrackingMode:(MKUserTrackingMode)mode animated:(BOOL)animated; 定位用户位置模式改变时调用的方法 - (MKOverlayView )mapView:(MKMapView )mapView viewForOverlay:(id )overlay; 渲染覆盖物视图时调用的方法，可以自定义覆盖物视图 - (void)mapView:(MKMapView )mapView didAddOverlayViews:(NSArray )overlayViews; 添加完成覆盖物数组执行的方法 备注：在iOS9中，地图类型的枚举又添加了两种： 1234567typedef NS_ENUM(NSUInteger, MKMapType) &#123; MKMapTypeStandard = 0,//标准 MKMapTypeSatellite,//卫星 MKMapTypeHybrid,//混合 MKMapTypeSatelliteFlyover NS_ENUM_AVAILABLE(10_11, 9_0),//立体卫星 MKMapTypeHybridFlyover NS_ENUM_AVAILABLE(10_11, 9_0),//立体混合&#125; NS_ENUM_AVAILABLE(10_9, 3_0) __WATCHOS_PROHIBITED; 注：因篇幅限制，关于系统大头针和自定义标注的应用、地图覆盖物的应用将在下一篇博客中讨论。 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美六——滚动字幕的应用","slug":"56标签之美六——滚动字幕的应用","date":"2015-05-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.402Z","comments":true,"path":"2015/05/14/56标签之美六——滚动字幕的应用/","link":"","permalink":"http://huishao.cc/2015/05/14/56标签之美六——滚动字幕的应用/","excerpt":"","text":"标签之美——滚动字幕的应用在网页中，我们经常可以看到一些滚动出现的字幕，按钮等内容。滚动字幕的应用会使网页的内容更加生动紧凑。 1、滚动标签 将滚动显示的文字放在这个标签内，就可以实现滚动字幕。这个标签有一个behavior属性，可以设置滚动方式： scroll：循环滚动，默认的滚动方式 slide：只滚动一次 alternate：左右来回滚动 2、设置字幕背景颜色 123&lt;body&gt;&lt;marquee behavior=&quot;alternate&quot; bgcolor=&quot;#F4070B&quot;&gt;这里是滚动字幕&lt;/marquee&gt;&lt;/body&gt; 3、设置字幕滚动方向：direction属性，可以设置的值有：left，right，up，down。分别表示从右向左滚动，从左向右滚动，从下向上滚动，从上向下滚动。 4、设置字幕的滚动速度 通过设置scrollamount属性来更改字幕的滚动速度，数值越大，速度越快。 5、设置字幕滚动时间间隔 scrolldelay可以来设置字幕的停顿时间间隔，单位是毫秒。效果和速度属性相似。 6、设置滚动次数 loop属性可以设置滚动次数，-1则为循环滚动。 7、设置鼠标滑过时停止滚动，移开时继续滚动： 123&lt;body&gt;&lt;marquee direction=&quot;down&quot; onMouseOver=&quot;this.stop()&quot; onMouseOut=&quot;this.start()&quot;&gt;这里是滚动字幕&lt;/marquee&gt;&lt;/body&gt; 滚动字幕也支持图片的滚动，将文字换位图片即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS定位服务的应用","slug":"55IOS定位服务的应用","date":"2015-05-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.402Z","comments":true,"path":"2015/05/14/55IOS定位服务的应用/","link":"","permalink":"http://huishao.cc/2015/05/14/55IOS定位服务的应用/","excerpt":"","text":"iOS定位服务的应用一、授权的申请与设置在IOS8之后，IOS的定位服务做了优化，若要使用定位服务，必须先获取用户的授权。 首先需要在info.plist文件中添加一个键：NSLocationAlwaysUsageDescription或者NSLocationWhenInUseUsageDescription。其中NSLocationAlwaysUsageDescription是要始终使用定位服务，NSLocationWhenInUseUsageDescription是只在前台使用定位服务。 IOS8中CLLocationManager新增的两个新方法： - (void)requestAlwaysAuthorization; - (void)requestWhenInUseAuthorization; 这两个方法对应上面的两个键值，用于在代码中申请定位服务权限。 二、定位服务相关方法IOS的定位服务在CoreLocation.framework框架内，首先引入这个框架： 开启定位服务的代码非常简单，示例如下： 12345678910111213141516171819#import &quot;ViewController.h&quot;#import &lt;CoreLocation/CoreLocation.h&gt;@interface ViewController ()&lt;CLLocationManagerDelegate&gt;//定位服务的代理@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; CLLocationManager* manager = [[CLLocationManager alloc]init];//初始化一个定位管理对象 [manager requestWhenInUseAuthorization];//申请定位服务权限 manager.delegate=self;//设置代理 [manager startUpdatingLocation];//开启定位服务&#125;//定位位置改变后调用的函数-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations&#123; NSLog(@&quot;%@&quot;,locations);&#125;@end CLLocationManager相关方法解读： + (BOOL)locationServicesEnabled; 判断设备是否支持定位服务 + (BOOL)headingAvailable; 判断设备是否支持航向信息功能(海拔，速度，方向等传感器的支持) + (BOOL)significantLocationChangeMonitoringAvailable; 判断设备是否支持更新位置信息 + (BOOL)isMonitoringAvailableForClass:(Class)regionClass; 判断设备是否支持区域检测，regionClass是地图框架中的类。 + (BOOL)isRangingAvailabl; 判断设备是否支持蓝牙测距 + (CLAuthorizationStatus)authorizationStatus; 获得定位服务的授权状态，CLAuthorizationStatus的枚举如下： 1234567typedef NS_ENUM(int, CLAuthorizationStatus) &#123; kCLAuthorizationStatusNotDetermined = 0,//用户还没有做选择 kCLAuthorizationStatusRestricted,//应用拒接使用定位服务 kCLAuthorizationStatusDenied,//用户拒绝授权 kCLAuthorizationStatusAuthorizedAlways,//8.0后可用，始终授权位置服务 kCLAuthorizationStatusAuthorizedWhenInUse,//8.0后可用，只在前台授权位置服务&#125;; @property(assign, nonatomic) CLActivityType activityType; 这个属性用来设置位置更新的模式，枚举如下： 123456typedef NS_ENUM(NSInteger, CLActivityType) &#123; CLActivityTypeOther = 1,//未知模式，默认为此 CLActivityTypeAutomotiveNavigation, //车辆导航模式 CLActivityTypeFitness, //行人模式 CLActivityTypeOtherNavigation //其他交通工具模式&#125;; 模式的应用可以起到节省电量的作用，例如车辆导航模式，当汽车停止时，位置更新服务会暂停。 @property(assign, nonatomic) CLLocationDistance distanceFilter; 设置位置更新的敏感范围，单位为米。 @property(assign, nonatomic) CLLocationAccuracy desiredAccuracy; 设置定位服务的精确度，系统定义好的几个参数如下： kCLLocationAccuracyBestForNavigation;//导航最高精确kCLLocationAccuracyBest;//高精确kCLLocationAccuracyNearestTenMeters;//10米kCLLocationAccuracyHundredMeters;//百米kCLLocationAccuracyKilometer;//千米kCLLocationAccuracyThreeKilometers;//三公里 @property(assign, nonatomic) BOOL pausesLocationUpdatesAutomatically; 设置位置更新是否自动暂停 @property(readonly, nonatomic, copy) CLLocation *location; 最后一次更新的位置信息，只读属性 @property(assign, nonatomic) CLLocationDegrees headingFilter; 相关航向更新的敏感范围 @property(assign, nonatomic) CLDeviceOrientation headingOrientation; 定位航向时的参照方向默认为正北，枚举如下： 123456789typedef NS_ENUM(int, CLDeviceOrientation) &#123; CLDeviceOrientationUnknown = 0,//方向未知 CLDeviceOrientationPortrait,//纵向模式 CLDeviceOrientationPortraitUpsideDown,//纵向倒置模式 CLDeviceOrientationLandscapeLeft,//左向横向模式 CLDeviceOrientationLandscapeRight,//右向横向模式 CLDeviceOrientationFaceUp,//水平屏幕向上模式 CLDeviceOrientationFaceDown//水平屏幕下模式&#125;; @property(readonly, nonatomic, copy) CLHeading *heading; 最后一个定位得到的航向信息 - (void)startUpdatingLocation; 开启定位服务 - (void)stopUpdatingLocation; 停止定位服务 - (void)startUpdatingHeading; 开启航向地理信息服务 - (void)stopUpdatingHeading; 停止航向地理信息服务 三、定位服务代理的相关方法- (void)locationManager:(CLLocationManager )manager didUpdateLocations:(NSArray )locations； 位置更新后调用的方法，数组中是所有定位到的位置信息，最后一个是最新的。 - (void)locationManager:(CLLocationManager )manager didUpdateHeading:(CLHeading )newHeading； 航向信息更新后调用的方法 - (void)locationManager:(CLLocationManager )manager didFailWithError:(NSError )error; 定位异常时调用的方法 四、定位服务获取到的位置对象上面也提到，定位后返回的数组中存放的都是CLLocation对象，这里面有很详细的位置信息，属性如下： @property(readonly, nonatomic) CLLocationCoordinate2D coordinate; 经纬度属性，CLLocationCoordinate2D是一个结构体，如下： 1234typedef struct &#123; CLLocationDegrees latitude;//纬度 CLLocationDegrees longitude;//经度&#125; CLLocationCoordinate2D; @property(readonly, nonatomic) CLLocationDistance altitude; 海拔高度，浮点型 @property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy; 水平方向的容错半径 @property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy; 竖直方向的容错半径 @property(readonly, nonatomic) CLLocationDirection course; 设备前进的方向，取值范围为0-359.9，相对正北方向 @property(readonly, nonatomic) CLLocationSpeed speed; 速度，单位为m/s @property(readonly, nonatomic, copy) NSDate *timestamp; 定位时的时间戳 五、航标定位得到的航标信息对象CLHeading对象的属性信息： @property(readonly, nonatomic) CLLocationDirection magneticHeading; 设备朝向航标方向，0为北磁极。 @property(readonly, nonatomic) CLLocationDirection trueHeading; 设备朝向真实方向，0被地理上的北极 @property(readonly, nonatomic) CLLocationDirection headingAccuracy; 方向偏差 @property(readonly, nonatomic) CLHeadingComponentValue x; x轴的方向值 @property(readonly, nonatomic) CLHeadingComponentValue y; y轴方向值 @property(readonly, nonatomic) CLHeadingComponentValue z; z轴方向值 @property(readonly, nonatomic, copy) NSDate *timestamp; 方向定位时间戳 如有疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美五——网页表格的设计","slug":"54标签之美五——网页表格的设计","date":"2015-05-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.402Z","comments":true,"path":"2015/05/13/54标签之美五——网页表格的设计/","link":"","permalink":"http://huishao.cc/2015/05/13/54标签之美五——网页表格的设计/","excerpt":"","text":"标签之美——网页表格的使用通过表格，可以使网页排版更加清晰，形式更加简洁漂亮。 一、表格布局中三个重要的标签1、：表格的开始和结束标签，行列的布局都在标签内。 2、行标签的开始和结束 3、列标签的开始和结束 行标签在列标签的外层，不能单独使用，其中必须至少有一列。示例如下： 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;!--为了便于观察，设置一个边框--&gt;&lt;tr&gt;&lt;td&gt;表格的内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 效果如下： 二、单元格设置的相关标签1、单元格表头 这个标签用来设置表格的表头，作用和列标签相似，只是字体是加黑的。 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 2、表格宽度属性和高度属性width,height 这两个属性可以设置在标签里，也可以设置在和中，作用域会不同。 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th width=&quot;200&quot;&gt;1&lt;/th&gt;&lt;th width=&quot;100&quot;&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 3、设置表格背景图片background 这个属性和尺寸属性用法一样，写在相应的标签里，就是相应的背景图案，设置的是图片的路径。 4、设置表格行列间距cellspacing 1234567&lt;body&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;20&quot;&gt;&lt;tr&gt;&lt;th width=&quot;200&quot;&gt;1&lt;/th&gt;&lt;th width=&quot;100&quot;&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 5、设置单元格内容偏移量 cellpadding 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 三、表格的边框属性和对齐模式灵活的应用边框，可以使表格看起来更加整洁有序。 1、边框宽度属性border 2、边框的颜色属性bordercolor 3、不显示外边框frame=”void” 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;void&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 4、设置frame=”hsides”则只显示上下外边框 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 5、设置frame=”vsides”则只显示左右外边框 6、单独显示边框的frame值分别为： 上：above 下：below 左：lhs 右：rhs 7、设置表格对齐模式： 水平对齐模式：align 表格的align属性可以设置对齐模式，center,left,right分别对应居中，左对齐，右对齐。 垂直对齐模式：valign 和水平对齐模式相似，这个属性的值为：middle，top，bottom对应了中间对齐，上对齐和下对齐。 四、表格行和列的操作1、行的合并：rowspan 12345678910&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;第一行&lt;/td&gt;&lt;td&gt;第一行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第二行&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 2、列的合并colspan 12345678910&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;第一列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 3、表格的标题标签 1234567891011&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot; &gt;&lt;caption&gt;标题&lt;/caption&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;第一列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"分分钟搞定IOS远程消息推送","slug":"53分分钟搞定IOS远程消息推送","date":"2015-05-11T16:00:00.000Z","updated":"2023-04-14T11:50:08.402Z","comments":true,"path":"2015/05/12/53分分钟搞定IOS远程消息推送/","link":"","permalink":"http://huishao.cc/2015/05/12/53分分钟搞定IOS远程消息推送/","excerpt":"","text":"分分钟搞定IOS远程消息推送一、引言IOS中消息的推送有两种方式，分别是本地推送和远程推送，本地推送在http://my.oschina.net/u/2340880/blog/405491这篇博客中有详细的介绍，这里主要讨论远程推送的流程与配置过程。 二、远程推送机制的原理1、从一张很火的图说起搜索IOS远程推送，你总能看到一张如下的流程示意图，因为这张图确实很火，所以我也将它引用在此： 这张图示意的很清晰，大致意思是这样：你的应用服务端将消息发送到apple的APNS服务器，APNS服务器将消息推送到指定的Iphone，最后由Iphone负责将消息推送至你的APP。在此先不说这个过程是如何实现的，仅仅看这个流程，你可能会觉得，在你们服务端和客户端之间增加了一个apple的APNS，不是增加开发者的负担么？其实结果恰恰相反，因为apple对推送的统一管理，使我们开发者的工作变得异常简单。 2、服务端如何连接到客户端的如果你是做android开发的，你一定非常了解长链接与心跳包。事实上，大部分的android应用的推送也确实是通过长链接来实现的。因为android系统的开放性，APP是很容易做到自启动和后台长链接的，而心跳验证，就是始终保证长链接属于接通状态，然后由服务端直接推送消息。如果IOS开发者也采用这种思路，就十分困难了，在IOS中想要保持一个APP服务始终不被系统杀死，我只能说太难了。通过上面的流程图，对比android的推送思路，我们很容易明白，IOS中其实也始终有一个长链接，那就是系统本身，这个长链接始终与APNS服务器相连，然后统一管理所有应用程序的推送。 3、这是IOS推送机制的优势？下面的这些，只是我个人的一些看法。系统并无优劣，优劣在于个人喜好。 1、因为推送的服务端是appleID的验证用户，推送可靠性会高。 2、所有推送消息由APNS统一管理，效率高。 3、在客户端只需系统维护一个长链接，节省了用户流量消耗和手机的性能消耗，并且提高了安全性，使得有恶意推送和流氓软件的几率降低。 三、分分钟让你的APP收到远程推送1、工欲善其事、必先利其器——创建推送证书(1)请求CSR文件 在MAC应用程序中找到钥匙串访问，打开它。 点击选项栏中的钥匙串访问中的证书助理： 选择从证书颁发机构申请证书: 填写电子邮件和名称，选择储存到磁盘，然后继续。 这时，我们存储的地方有了这样一个文件：CertificateSigningRequest.certSigningRequest。 (2)导出密钥文件 打开钥匙串，会发现多了一对密钥，名字就是上面你填写的常用名称。 我们选择专用密钥进行导出，然后设置一个我们自己的密码： 这时候我们又有了一个后缀名为.p12的文件。 (3)创建AppId 到https://developer.apple.com的member Center： 用你付过费的开发者appleID登陆后，选择Certificates: 如果你的项目已经创建了APP id，则可以不用重新创建，但是你创建的APP id必须要支持远程推送。如果还没有创建，点击加号，创建一个： 之后的界面中APP ID有两种类型：Explicit和Wildcard，分别是特殊的和通配的，我们需要推送功能，这个ID不能是通配的，所以我们选择第一个。 这里需要填的的Bundle ID必须和我们App中的一致： 在APP ID的服务设置中，将Push Notification勾选上，点击continue。 之后点击submit，最后点击Done。这时我们的APP IDs列表中会出现我们刚才创建的APP ID。 (4)创建证书 点击我们刚才创建的APP ID，你会看到Push Notification一行为未设定的。我们点击Edit。 在Push Notifications设置里是如下界面，development是开发证书，Production是产品证书，我们现在需要测试，所以用Development证书，上线时要使用Production证书。点击Create Certificate。 接着点击continue，如下界面会让我们选择一个CSR文件，我们第一步创建的文件在这里派上用场了，选择那个文件，点击Generate。 将创建好的证书下载到电脑中： 至此，我们已经有了三个文件了，分别是CSR文件，.p12文件，.cer文件。要将这三个文件放在同一个目录下。.cer文件分为测试和产品两个，需要哪个自行选择。写了这么多，我们的准备工作可算是做完了，不要灰心，其实你的推送工作基本上也就做完了。只是申请过程麻烦了一些，但工程的代码，我们几乎不用怎么配置。 2、兵马未动、粮草先行——服务端进行信息推送的设置(1)处理证书 打开终端cd到我们上面得到的三个文件所在的目录。 在终端执行如下命令： 1$ openssl x509 -in aps_development.cer -inform der -out PushCert.pem aps_development.cer是刚才生成的.cer文件的文件名。会在当前文件夹中生成一个pem文件，这是我们服务端对应的证书。 再执行如下命令： 1$ openssl pkcs12 -nocerts -out PushKey.pem -in key.p12 key.p12是上面生成的.p12文件的文件名。这时终端会让输入密码，这里的密码就是上面我们设置的密钥的密码。输入密码后回车，如果密码正确，会让我们输入新密码(一定切记)，输入两次后，终端会提示成功创建PushKey.pem文件。 最后一步，将我们生成的两个pem文件和成为一个： 1$ cat PushCert.pem PushKey.pem &gt; ck.pem (2)测试证书是否可用 在终端执行下面的命令： 1$ telnet gateway.sandbox.push.apple.com 2195 等一小会，如果终端显示下面的情形，则证书正常。 然后执行如下命令： 1openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert PushChatCert.pem -key PushKey.pem 输入密码后回车显示如下的结果则连接成功： 3、天涯海角、一步之遥——应用程序中的配置在我们项目的AppDelegate中添加如下代码： 12345678910111213141516171819202122- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;double version = [[UIDevice currentDevice].systemVersion doubleValue];//判定系统版本。if(version&gt;=8.0f)&#123; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:(UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound|UIRemoteNotificationTypeAlert) categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; &#125;else&#123; UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes]; &#125;&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; // 处理推送消息 NSLog(@&quot;userinfo:%@&quot;,userInfo); NSLog(@&quot;收到推送消息:%@&quot;,[[userInfo objectForKey:@&quot;aps&quot;] objectForKey:@&quot;alert&quot;]);&#125;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *) error &#123; NSLog(@&quot;Registfail%@&quot;,error);&#125;-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; NSLog(@&quot;%@&quot;,deviceToken);//这里的Token就是我们设备要告诉服务端的Token码&#125; 下面是网上搜的PHP服务端的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php//这里填写设备的Token码$deviceToken = &apos;74314cc9e8f747e2fa96c2c1585c830cdf994de6b453ce9fa1c09ba396b2f9e9&apos;;//这里是密钥密码$passphrase = &apos;abcabc&apos;;//推送的消息$message = &apos;这是一条推送消息&apos;;////////////////////////////////////////////////////////////////////////////////$ctx = stream_context_create();stream_context_set_option($ctx, &apos;ssl&apos;, &apos;local_cert&apos;, &apos;ck.pem&apos;);//ck文件stream_context_set_option($ctx, &apos;ssl&apos;, &apos;passphrase&apos;, $passphrase);// Open a connection to the APNS server$fp = stream_socket_client( &apos;ssl://gateway.sandbox.push.apple.com:2195&apos;, $err, $errstr, 60, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);if (!$fp) exit(&quot;Failed to connect: $err $errstr&quot; . PHP_EOL);echo &apos;Connected to APNS&apos; . PHP_EOL;// Create the payload body$body[&apos;aps&apos;] = array( &apos;alert&apos; =&gt; $message, &apos;sound&apos; =&gt; &apos;default&apos; );// Encode the payload as JSON$payload = json_encode($body);// Build the binary notification$msg = chr(0) . pack(&apos;n&apos;, 32) . pack(&apos;H*&apos;, $deviceToken) . pack(&apos;n&apos;, strlen($payload)) . $payload;// Send it to the server$result = fwrite($fp, $msg, strlen($msg));if (!$result) echo &apos;Message not delivered&apos; . PHP_EOL;else echo &apos;Message successfully delivered&apos; . PHP_EOL;// Close the connection to the serverfclose($fp); ?&gt; 把上面的PHP文件和我们的ck文件放在同一目录下。在终端的当前目录下，执行如下命令： 1$php push.php 如果我们的设备王略正常，就可收到推送的消息了： 四、几点注意1、如果终端发送信息时提示密钥不可访问之类的错误，请检查是否cd到了当前目录，如果还存在问题，将密钥部分从新生成一次。 2、注意PHP代码中的字符为英文字符。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美四——为网页添加绚丽多彩的图像","slug":"52标签之美四——为网页添加绚丽多彩的图像","date":"2015-05-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.402Z","comments":true,"path":"2015/05/11/52标签之美四——为网页添加绚丽多彩的图像/","link":"","permalink":"http://huishao.cc/2015/05/11/52标签之美四——为网页添加绚丽多彩的图像/","excerpt":"","text":"标签之美——图像的使用一、设置网页背景图片12&lt;body background=&quot;1.jpg&quot;&gt;&lt;/body&gt; 这里图片路径的写法和本地超链接的写法是一样的，可以参考上一篇博客中关于本地路径的地方：http://my.oschina.net/u/2340880/blog/412934。 注意：如果图片大小不能充满网页，图片将会被复制平铺。 二、图片标签的应用是图片插入标签。其中图片路径的写法和超链接路径的写法一样。示例如下： 123&lt;body&gt;&lt;img src=&quot;2.png&quot;/&gt;&lt;/body&gt; 效果如下： 标签的alt属性可以为图片添加缺省文字，当图片不存在或者无法显示时，会有提示效果。示例如下： 123&lt;body&gt;&lt;img src=&quot;3.png&quot; alt=&quot;图片不存在&quot;/&gt;&lt;/body&gt; 设置图片的尺寸属性：width，height 123&lt;body&gt;&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;&lt;!--设置宽高为200像素--&gt;&lt;/body&gt; 三、图片的对齐模式align是图片标签的对齐属性，对齐模式有5种属性值，下面一一对其进行介绍： 1、bottom:底部对其1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;bottom&quot;/&gt;的图片 效果如下： 2、left:左部对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;left&quot;/&gt;的图片 3、right:右部对其1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;right&quot;/&gt;的图片 效果如下： 4、middle:居中对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;middle&quot;/&gt;的图片 效果如下： 5、top:上部对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;top&quot;/&gt;的图片 效果如下： 四、设置图片边框和边距通过border属性可以给图片添加边框。属性的值为边框的宽度。 1&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;top&quot; border=&quot;4&quot;/&gt; 效果如下，图片被加上了黑色的边框： 也可以给图片设置一个间距，间距的效果和透明的边框是一样的。 1这里是图片&lt;img src=&quot;1.png&quot; align=&quot;middle&quot; hspace=&quot;20&quot;&gt;内容 其中，hspace是设置水平边框的宽度，还有一个属性vspace是设置垂直边框的宽度，上面代码效果如下： 五、插入视频的相关操作插入视频的原理和图像是一样的，只是路径使用的时dynsrc，可以使用loop属性来设置循环次数，start属性来设置播放方式，这里，只将start属性说明一下，有两种方式，fileopen是网页加载就开始播放，mouseover是鼠标移动到视频位置后开始播放。 1&lt;img dynsrc=&quot;2.wmv&quot; start=&quot;fileopen&quot; loop=&quot;1&quot;&gt; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美三——超链接的嵌入","slug":"51标签之美三——超链接的嵌入","date":"2015-05-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.401Z","comments":true,"path":"2015/05/10/51标签之美三——超链接的嵌入/","link":"","permalink":"http://huishao.cc/2015/05/10/51标签之美三——超链接的嵌入/","excerpt":"","text":"标签之美——超链接标签一、创建超链接通常的超链接有两种方式，一种是链接到另一个文件，另一种是链接到当前文件的某个位置。这两种方式都是通过标签来创建，其中href属性用来指定链接的目标地址。 1、链接到当前页面指定位置被链接的地方需要使用标签的name属性标记，示例如下： 1234&lt;a href=&quot;#last&quot;&gt;链接到本页最后&lt;/a&gt;&lt;!--创建一个超链接--&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=&quot;last&quot;&gt;最后&lt;/a&gt;&lt;!--链接的标记名--&gt;&lt;/body&gt; 2、链接到本地相对路径文件相对路径是以当前\b文件所在的路径为参考的。示例如下： 12345678&lt;body&gt;&lt;!--同级链接：所链接到得文件与当前文件在同一目录下，直接链接文件名即可--&gt;&lt;a href=&quot;nwe.html&quot;&gt;同级链接&lt;/a&gt;&lt;!--下级链接：所链接的文件在当前文件所在目录的子目录下--&gt;&lt;a href=&quot;thml/new.html&quot;&gt;下级链接&lt;/a&gt;&lt;!--上级链接：所链接文件在当前文件所在的上级目录--&gt;&lt;a href=&quot;../new.html&quot;&gt;上级链接&lt;/a&gt;&lt;/body&gt; 3、链接到网址URL这种方式通常会用在友情链接中。例如如下链接到百度： 123&lt;body&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/body&gt; 二、链接的打开方式标签中的target属性可以设置标签的打开方式，一共有四种方式，分别是_blank,_parent,_self,_top。 1、_blank打开方式会让浏览器在新的窗口中打开标签。 2、_parent打开方式在父窗口中打开，当前页面会被覆盖。 3、_self打开方式在当前窗口打开，当前窗口会被覆盖。 4、_top打开方式在最上层窗体中打开。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美二——文本标签","slug":"50标签之美二——文本标签","date":"2015-05-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.401Z","comments":true,"path":"2015/05/08/50标签之美二——文本标签/","link":"","permalink":"http://huishao.cc/2015/05/08/50标签之美二——文本标签/","excerpt":"","text":"标签之美–HTML文本标签属性详解1、使用标题标签 是标题的开始和结束标签，html提供6级标题划分，示例如下： 123&lt;body&gt;&lt;!--设置背景为蓝色--&gt;&lt;h1&gt;这是一级标题&lt;/h1&gt;&lt;h2&gt;这是二级标题&lt;/h&gt;&lt;h6&gt;这是六级标题&lt;/h6&gt;&lt;/body&gt; 2、使用字体标签 用于定义字体，其中详细属性如下： 定义字体大小：size 例如设置其中文字字号为4。 设置字体：face 其中可以填写多个字体名称，浏览器会按顺序寻找。 3、使用文本布局标签 缩进标签，可以让内容布局更加清晰，效果如下： 1234&lt;body&gt;这是没有使用索引的内容&lt;br&gt;&lt;blockquote&gt;这里使用了标签的内容&lt;/blockquote&gt;&lt;/body&gt; 手动格式化布局标签这个标签可以不通过代码进行空格和换行的控制，而是直接将文本中的布局显示。效果如下： 1234&lt;body&gt;&lt;pre&gt;手动的空格 与换行这里是第二行&lt;/pre&gt;&lt;/body&gt; 内联标签，这个标签的作用是将对象内联与某些内容，比如将鼠标悬停时展现的内容，示例如下： 123&lt;body&gt;&lt;span title=&quot;看这里&quot;&gt;标题&lt;/span&gt;&lt;/body&gt; 4、使用字体属性标签 为字体加粗： 使用斜体： 添加下划线： 添加标注： 与下划线形式相同 添加删除标记： 与 添加上标： 添加下表： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS有关内存管理的二三事","slug":"49iOS有关内存管理的二三事","date":"2015-05-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.401Z","comments":true,"path":"2015/05/07/49iOS有关内存管理的二三事/","link":"","permalink":"http://huishao.cc/2015/05/07/49iOS有关内存管理的二三事/","excerpt":"","text":"iOS有关内存管理的二三事一、前引随着移动设备的内存越来越大，程序员也已经度过了为了那一两M的内存在系统的抽丝剥茧的年代，对于JAVA的开发者，对内存更是伸手即取，并且从不关心什么时候还回去。但是，程序的掌控度对程序员来说是至关重要的，任何语言的内存管理机制的初衷也是在有限的空间里完成最精致的逻辑。 二、Xcode工程设置ARCARC是xcode5中引入的自动引用计数，其原理与MRC是一样，只是系统帮助我们添加了retain和release。现在在xcode中新建的项目默认都是ARC的环境，我们可以通过设置其为MRC。 在BuildSettings中搜索ARC： 将下面的参数设置为NO，默认是YES。 这时项目工程的环境就变成了MRC。 三、项目中实现MRC和ARC混编现实中的许多旧的项目，还有一些比较老的第三方库，可能都是采用MRC环境编写的，我们在对其进行扩展或者做新项目的兼容的时候，可以在xcode中对其进行混编。 选择：target-&gt;build phases-&gt;compile sources 如果工程是ARC，要混编MRC的文件，我们选中compiler flags，后面设置为-fno-objc-arc 如果工程是MRC，要混编ARC文件，我们在后面设置-fobjc-arc 四、IOS内存管理机制基本原理无论你是只注重于代码逻辑，将内存交给ARC的新时代程序员，还是依然对apple的信任不足，依然事必躬亲的MRC古板程序员，我想你都应该了解IOS中内存管理的机制，尽管ARC机制很成熟也很可靠，可是依然会有很多应用存在循环应用，内存泄露等问题，要知道，ARC不是万能的，它仅仅只是帮你省去写一些繁琐的代码。 首先，在Object-C中创建对象返回的并不是对象本身，而是一个指针。比如我们使用alloc申请空间，会经常这样做： UIImage * image = [[UIImage alloc]init]; 这里，调用的alloc时，系统将给我们创建的类分配一块内存空间，并返回一个指向这个空间的指针。调用init时对对象进行初始化。如果此时，我们将image这个指针置为nil：image=nil;那样将造成内存泄露，系统分配给image的空间永远无法回收。所以，在我们不需要image这个对象时，我们会使用dealloc方法将其交还给系统：[image dealloc];然而这里，有将产生一个严重的问题，如果我们此时打印image的指针，会发现它现在成了一个危险东西，因为它指向的东西不存在了，而它却依然指向那个地方，这便是很多程序员的噩梦：野指针。为此，我们应该养成一个好习惯，不用的指针置为nil，所有对空指针进行的操作都被认为是安全的。 通过上面的理解，我们发现了一个非常麻烦的地方，我申请了一块内存空间，如果我将指针置空了而没有释放对象，则会内存泄露，如果我提前释放了对象，又很可能会有野指针的出现。并且如果有很多类都引用了这个对象，我甚至的不知道我应该什么时候释放它。因此，Object-C为我们引入了引用计数这种管理内存的方法，任何引用这个对象的地方，都应该让这个对象的引用计数加1。同样，任何不再需要这个对象的地方，也应该使它的引用计数减1，如此一来，对象内存便被统一的管理了起来。 五、内存管理的黄金法则引用计数内存管理的机制是对象的计数，每个对象至少会有一个引用者，如果没有了引用者，对象会被释放。 黄金法则： 1、当你使用alloc,new,copy,mutableCopy创建对象时，你才需要管理他们。 2、你可以使用retain给一个对象增加引用计数。 3、当你不再需要一个对象时，你必须调用release减少其引用计数。 4、你不能释放不属于你的对象的所有权。 上面就是黄金法则的所有内容，我译的可能不到位，总结为一点，也是至关重要的一点就是：谁创建了对象，谁释放掉对象。谁增加了引用计数，谁就在不用时减少计数。alloc，new，copy，mutableCopy，retain这些方法会使引用计数增加，release会使引用计数减少，当计数为0时，系统会调用dealloc释放内存。 六、自动释放池为了方便内存管理，避免我们频繁的调用release方法，Object-C中还为我们引用了一种机制：自动释放池。自动释放池的原理其实只是延时释放，它并没有帮我们做太多的工作。自动释放池的使用方式有两种： 1、MRC时： 123 NSAutoreleasePool * pool = [[NSAutoreleasePool alloc]init];//创建一个自动释放池，系统默认会为我们创建一个，我们也可以创建自己的。 UIImage * image = [[[UIImage alloc]init] autorelease];//在池内创建一些对象，会和最近的自动释放池匹配 [pool release];//这时自动释放池会向池子中的每一个对象发送release消息 2、ARC时： 123 @autoreleasepool &#123; UIImage * image = [[[UIImage alloc]init] autorelease]; &#125; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发遇到的屏幕上下闪出黑边的解决方法","slug":"48iOS开发遇到的屏幕上下闪出黑边的解决方法","date":"2015-05-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.401Z","comments":true,"path":"2015/05/07/48iOS开发遇到的屏幕上下闪出黑边的解决方法/","link":"","permalink":"http://huishao.cc/2015/05/07/48iOS开发遇到的屏幕上下闪出黑边的解决方法/","excerpt":"","text":"iOS开发遇到的屏幕上下闪出黑边的解决方法在IOS开发时，使用的时IOS的模拟器，程序中任何有关坐标的地方也是根据屏幕获取的，而在IOS7的系统上运行，却发现屏幕小了一截，上下各闪出一块黑色区域。后经过查找原因，解决方法如下: 项目的App Icon and Launch Images设置中，本来是这样的： 点击Use Asset Catalog，之后点击Migrate，设置界面如下图模样： 这时在IOS7上就能充满屏幕了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS通过NSUserDefaults实现简单的应用间数据传递","slug":"46iOS通过NSUserDefaults实现简单的应用间数据传递","date":"2015-05-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.401Z","comments":true,"path":"2015/05/06/46iOS通过NSUserDefaults实现简单的应用间数据传递/","link":"","permalink":"http://huishao.cc/2015/05/06/46iOS通过NSUserDefaults实现简单的应用间数据传递/","excerpt":"","text":"iOS中NSUserDefaults详解NSUserDefaults是用于保存应用程序设置，应用信息等轻量级数据的的一个类，其本质是将数据写为plist文件的形式保存在本地。在IOS中，系统为每一个应用程序都默认创建了一个NSUserDefaults对象。 一、常用方法总结+ (NSUserDefaults *)standardUserDefaults; 获取系统默认创建的应用程序设置表 + (void)resetStandardUserDefaults; 这个方法用于将默认的UserDefaults释放掉，并在下次使用时创建一个新的对象，需要注意的是，调用这个方法后，对原UserDefaults单例进行的KVO监听将失效。 - (instancetype)initWithSuiteName:(NSString *)suitename; 这个方法创建一个新的域：根据名字可以创建一些不同的域，分别存储几套设置信息。 - (id)objectForKey:(NSString *)defaultName; - (void)setObject:(id)value forKey:(NSString *)defaultName; - (void)removeObjectForKey:(NSString *)defaultName; 上面三个方法是对对象存储进行的操作，分别是存储，获取和删除。 - (NSString )stringForKey:(NSString )defaultName; 获取字符串数据 - (NSArray )arrayForKey:(NSString )defaultName; 获取数组数据 - (NSDictionary )dictionaryForKey:(NSString )defaultName; 获取字典数据 - (NSData )dataForKey:(NSString )defaultName; 获取data数据 - (NSArray )stringArrayForKey:(NSString )defaultName; 获取字符串数组数据 - (NSInteger)integerForKey:(NSString *)defaultName; 获取整型数据 - (float)floatForKey:(NSString *)defaultName; 获取浮点型数据 - (double)doubleForKey:(NSString *)defaultName; 获取双精度浮点型数据 - (BOOL)boolForKey:(NSString *)defaultName; 获取布尔诗句 - (NSURL )URLForKey:(NSString )defaultName; 获取网址数据 下面是一些对应的set方法 - (void)setInteger:(NSInteger)value forKey:(NSString *)defaultName; - (void)setFloat:(float)value forKey:(NSString *)defaultName; - (void)setDouble:(double)value forKey:(NSString *)defaultName; - (void)setBool:(BOOL)value forKey:(NSString *)defaultName; - (void)setURL:(NSURL )url forKey:(NSString )defaultName; - (void)registerDefaults:(NSDictionary *)registrationDictionary; 这个方法可以通过字典对数据表进行赋值 - (void)addSuiteNamed:(NSString *)suiteName; 添加一个域 - (void)removeSuiteNamed:(NSString *)suiteName; 移除一个域 - (NSDictionary *)dictionaryRepresentation; 返回系统设置的信息，也是NSGlobalDomain域中的信息。 @property (readonly, copy) NSArray *volatileDomainNames; 返回一个数组，其中是所有不稳定域的名字 - (NSDictionary )volatileDomainForName:(NSString )domainName; 根据名字获取不稳定域中的数据 - (void)setVolatileDomain:(NSDictionary )domain forName:(NSString )domainName; 根据名字设置不稳定域 - (void)removeVolatileDomainForName:(NSString *)domainName; 根据名字移除不稳定域 - (NSDictionary )persistentDomainForName:(NSString )domainName; 根据名字获取稳定域的数据 - (void)setPersistentDomain:(NSDictionary )domain forName:(NSString )domainName; 根据名字设置稳定域 - (void)removePersistentDomainForName:(NSString *)domainName; 根据名字移除稳定域 - (BOOL)synchronize; 对象的同步方法，将内存中的数据写入磁盘。 - (BOOL)objectIsForcedForKey:(NSString *)key; 判断某个键值的数据是否存在 - (BOOL)objectIsForcedForKey:(NSString )key inDomain:(NSString )domain; 判断某个域中某个键值的数据是否存在 注：目前的iOS版本已经不能通过下面的方法在应用间进行传值！！！ 二、三个特殊的域及实现简单的应用间信息传递我们应该了解到，在IOS中，因为沙盒模式的存在，应用间是不允许互相访问数据与传值通信的。这样做的好处显而易见： 1、保证了数据的安全性 2、数据的管理更加简洁 3、当我们删除数据时，只需要将沙盒删除。 在某些需求下，我们可能会需要应用程序间的传值与通信，当然除了通过网络外，对于非常小的数据量，比如验证另一应用从程序是否登录，是否安装并且开启过一次，我们也可以通过NSUserDefaults的一个全局的数据表来实现。 NSUserDefaults的三个特殊的系统域如下： NSString * const NSGlobalDomain; 这个是一个系统级别的全局的域，存储这系统配置信息，我们可以通过它实现应用程序间传值 NSString * const NSArgumentDomain; 这个是在本应用程序内可访问的域，存储着应用程序的信息 NSString * const NSRegistrationDomain; 这个是存放临时数据的域 代码示例如下： 首先在第一个工程中，我们写如下代码运运行一下： 123456789 //获取全局的域 NSDictionary * dic = [[NSUserDefaults standardUserDefaults]persistentDomainForName:NSGlobalDomain]; NSMutableDictionary * temDic = [NSMutableDictionary dictionaryWithDictionary:dic]; [temDic setObject:@&quot;传递的值&quot; forKey:@&quot;应用1&quot;]; //重设 [[NSUserDefaults standardUserDefaults]setPersistentDomain:temDic forName:NSGlobalDomain]; //同步 [NSUserDefaults resetStandardUserDefaults]; NSLog(@&quot;%@&quot;,dic); 打印的结果是许多系统信息。 在第二个工程中，我们这样做： 12 NSDictionary * dic = [[NSUserDefaults standardUserDefaults]persistentDomainForName:NSGlobalDomain]; NSLog(@&quot;%@\\n--------------\\n%@=%@&quot;,dic,@&quot;应用1&quot;,[dic objectForKey:@&quot;应用1&quot;]); 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657582015-05-06 15:48:49.897 321[4100:186745] &#123; AppleITunesStoreItemKinds = ( newsstand, podcast, &quot;itunes-u&quot;, artist, booklet, document, eBook, software, &quot;software-update&quot;, &quot;podcast-episode&quot; ); AppleLanguages = ( en, fr, de, &quot;zh-Hans&quot;, &quot;zh-Hant&quot;, ja, nl, it, es, &quot;es-MX&quot;, ko, pt, &quot;pt-PT&quot;, da, fi, nb, sv, ru, pl, tr, uk, ar, hr, cs, el, he, ro, sk, th, id, ms, &quot;en-GB&quot;, &quot;en-AU&quot;, ca, hu, vi, hi ); AppleLocale = &quot;en_US&quot;; MSVLoggingMasterSwitchEnabledKey = 0; &quot;\\U5e94\\U75281&quot; = &quot;\\U4f20\\U9012\\U7684\\U503c&quot;;&#125;--------------应用1=传递的值 这样，我们就简单实现了应用程序间的传值，但是建议最好不要轻易操作系统的这个域。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美一——HTML基础元素","slug":"47标签之美一——HTML基础元素","date":"2015-05-05T16:00:00.000Z","updated":"2023-04-14T11:50:08.401Z","comments":true,"path":"2015/05/06/47标签之美一——HTML基础元素/","link":"","permalink":"http://huishao.cc/2015/05/06/47标签之美一——HTML基础元素/","excerpt":"","text":"标签之美–HTML基础标签使用总结HTML是一种标记语言，因此，标签便是HTML的核心，一些基础标签的用法总结如下： 1、 任何HTML文件都会有这样一个标签，标记网页的开始和结束。 2、 头部标签中可以包含许多网页的头信息。 3、 这个标签包含在头部标签内，其内容就是网页显示的标题，比如： 12345&lt;html&gt;&lt;head&gt;&lt;title&gt;我的HTML网页&lt;/title&gt;&lt;/head&gt;&lt;/html&gt; 结果如下： 4、 这是一个设置标签，也叫元信息标签，用于记录和设置网页的一些属性。 其中：name属性可以用来设置关键字，简要内容，网页生成工具及网页的制作者和网页链接查询权限，分别对应的字段为：Keywords、Description、Generator、Author、Robots。 每一个name的属性，后面都要用contect进行解释。对于Robots属性，contect权限的说明如下： all:文件和链接都可以被检索 none:都不可以被检索 index:文件被检索 follow:页面上的链接被检索 noindex：文件不被检索，链接可以被查询 标签的另一个属性值为http-equiv，它将告诉浏览器一些重要的信息，例如编码信息： 1&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--告诉浏览器编码格式--&gt; 定时跳转网页： 1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5;url=http://www.baidu.com&quot;&gt;&lt;!--5S后将跳转到百度网页--&gt; 5、 顾名思义，网页的主体内容写在这个标签里。 下面这些标签都是在标签下的： 6、 段落标签，示例如下： 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;我的HTML网页&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是第一段&lt;/p&gt;&lt;p&gt;这是第二段&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 7、 换行标签，如下： 123&lt;body&gt;这是第一行&lt;br&gt;这是第二行&lt;/body&gt; 8、 水平分割线，示例如下： 123456789&lt;body&gt;这是第一行&lt;hr&gt;这是第二行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第三行&lt;hr width=&quot;200&quot;&gt;&lt;!--设置分割线的长度--&gt;这是第四行&lt;hr width=&quot;100&quot; align=&quot;left&quot;&gt;&lt;!--设置居左--&gt;&lt;/body&gt; 在设置分割线的颜色之前，我们先把HTML中颜色对应的代码总结如下： 123456789&lt;body&gt;这是第一行&lt;hr color=&quot;#0C2DEC&quot;&gt;这是第二行&lt;hr size=&quot;12&quot; color=&quot;#FF0000&quot;&gt;&lt;!--设置颜色--&gt;这是第三行&lt;hr width=&quot;200&quot; color=&quot;#730C0D&quot;&gt;这是第四行&lt;hr width=&quot;100&quot; align=&quot;left&quot; color=&quot;#158C4F&quot;&gt;&lt;/body&gt; 取消分割线阴影： 123456&lt;body&gt;这是第一行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第二行&lt;hr size=&quot;16&quot; noshade&gt;&lt;!--取消分割线阴影--&gt;&lt;/body&gt; 9、 注释标签，任何编程语言都会有注释语句，这个就无需多说了。形式如下： 10、设置网页背景色 标签中有一个属性，可以用来设置网页的背景颜色：bgcolor 123456&lt;body bgcolor=&quot;#002BF8&quot;&gt;&lt;!--设置背景为蓝色--&gt;这是第一行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第二行&lt;hr size=&quot;16&quot; noshade&gt;&lt;!--取消分割线阴影--&gt;&lt;/body&gt; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS中KVC与KVO的应用解析","slug":"45iOS中KVC与KVO的应用解析","date":"2015-05-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.400Z","comments":true,"path":"2015/05/05/45iOS中KVC与KVO的应用解析/","link":"","permalink":"http://huishao.cc/2015/05/05/45iOS中KVC与KVO的应用解析/","excerpt":"","text":"iOS中KVC与KVO的应用解析一、NSKeyValueCoding（KVC）1、从一个小例子引入KVC键值编码是Object-C为我们提供的一种对成员变量赋值的方法。在探讨其方法之前，我们先来看一个小例子： 首先，创建一个数据模型model类： 12345678//.h文件#import &lt;Foundation/Foundation.h&gt;@interface Model : NSObject&#123; @public//将成员变量设置为公有的 以便其他文件有访问权限 NSString * str;&#125;@end 我们在其他文件中有两种方法str进行赋值和取值： 12345 Model * model = [[Model alloc]init]; model-&gt;str=@&quot;312&quot;;//普通方法赋值 [model setValue:@&quot;321&quot; forKey:@&quot;str&quot;];//kvc赋值 NSLog(@&quot;%@&quot;,model-&gt;str);//普通方法取值 NSLog(@&quot;%@&quot;,[model valueForKey:@&quot;str&quot;]);//kvc取值 同样的，对于用@property声明的变量，使用kvc的效果和使用点语法，setter，getter方法的效果是一样的。 2、KVC有关函数方法详解通过上面的例子，我们已经可以简单了解KVC是干什么的了，下面是一些常用方法。 + (BOOL)accessInstanceVariablesDirectly; 这个方法类似一个开关，默认返回为YES，表示支持KVC方式赋值，也可以在子类中将其重写，如果返回为NO，则再进行KVC会抛出异常。 - (id)valueForKey:(NSString *)key; 通过键取值 - (void)setValue:(id)value forKey:(NSString *)key; 通过字符串键给成员变量赋值 - (BOOL)validateValue:(inout id )ioValue forKey:(NSString )inKey error:(out NSError **)outError; 系统默认实现的方法，验证一个键值是否有效 - (NSMutableArray )mutableArrayValueForKey:(NSString )key; 将取到的值放入一个可变数组中 - (NSMutableOrderedSet )mutableOrderedSetValueForKey:(NSString )key NS_AVAILABLE(10_7, 5_0); 将取到的值放入可变的有序集合中 - (NSMutableSet )mutableSetValueForKey:(NSString )key; 将取到的值放入可变的集合中 - (id)valueForKeyPath:(NSString )keyPath;- (void)setValue:(id)value forKeyPath:(NSString )keyPath; 上面这两个方法分别是通过路径赋值与取值，数据结构类似地图，比如在model类中有一个成员变量model2，在Model2类中有一个字符串，我们可以通过如下的方式赋值取值 123456789101112131415161718192021//Model.h#import &quot;Model2.h&quot;@interface Model : NSObject&#123; @public NSString * str; Model2 * model2;&#125;//Model2.h@interface Model2 : NSObject&#123;@public NSString * str2;&#125;@end//其他文件 Model * model = [[Model alloc]init]; Model2 * model2 = [[Model2 alloc]init]; model-&gt;model2=model2; [model setValue:@&quot;123&quot; forKeyPath:@&quot;model2.str2&quot;]; NSLog(@&quot;%@&quot;,[model valueForKeyPath:@&quot;model2.str2&quot;]); - (NSMutableArray )mutableArrayValueForKeyPath:(NSString )keyPath;- (NSMutableOrderedSet )mutableOrderedSetValueForKeyPath:(NSString )keyPath NS_AVAILABLE(10_7, 5_0);- (NSMutableSet )mutableSetValueForKeyPath:(NSString )keyPath; 上面三个方法与前面类似，只是是从路径取值的。 - (id)valueForUndefinedKey:(NSString *)key; 这个方法可以获取没有提前定义的成员变量的值，比如运行时创建的，下面这个方法是给未定义的成员变量赋值 - (void)setValue:(id)value forUndefinedKey:(NSString *)key; 注意：这两个方法默认的实现会抛出异常，子类必须重写才能使用。 - (void)setNilValueForKey:(NSString *)key; 将成员变量置为nil - (NSDictionary )dictionaryWithValuesForKeys:(NSArray )keys; 根据键值获取键值对字典 - (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues; 通过字典对成员变量同意赋值，经常使用 二、NSKeyValueObservingCustomization（KVO）KVO是一种消息监听机制，可以在某个量发生变化的时候将消息传送给监听者，因此广泛用于传值，界面低耦合等逻辑中。KVO机制的核心是以下三个方法： - (void)addObserver:(NSObject )observer forKeyPath:(NSString )keyPath options:(NSKeyValueObservingOptions)options context:(void *)context; 使用这个方法注册一个监听者，参数解释如下： observer：监听者对象 keyPath：监听的参数 options：监听选项 context：参数传递 监听的选项枚举如下： 12345678typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123; NSKeyValueObservingOptionNew = 0x01,//回调的字典中存放新值 NSKeyValueObservingOptionOld = 0x02,//回调的字典中存放旧值 NSKeyValueObservingOptionInitial ,//值改变前进行回调 NSKeyValueObservingOptionPrior//改变前后都进行回调&#125;;//回调字典后面会解释 - (void)removeObserver:(NSObject )observer forKeyPath:(NSString )keyPath context:(void )context ;- (void)removeObserver:(NSObject )observer forKeyPath:(NSString *)keyPath; 这两个方法都是用来移除监听者 - (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary )change context:(void *)context; 这个方法是监听对象数据改变时回调的方法，change是一个字典，字典中根据监听的选项不同，存放不同的值（新或者旧）。context是传递的参数。 代码示例： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. model = [[Model alloc]init]; //添加监听者 [model addObserver:self forKeyPath:@&quot;str&quot; options:NSKeyValueObservingOptionNew context:@&quot;321&quot;]; [model setValue:@&quot;qw&quot; forKey:@&quot;str&quot;];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if ([keyPath isEqualToString:@&quot;str&quot;]) &#123; NSLog(@&quot;%@&quot;,context); &#125;&#125; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C中编写省略参数的多参函数","slug":"43Objective-C中编写省略参数的多参函数","date":"2015-05-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.396Z","comments":true,"path":"2015/05/04/43Objective-C中编写省略参数的多参函数/","link":"","permalink":"http://huishao.cc/2015/05/04/43Objective-C中编写省略参数的多参函数/","excerpt":"","text":"Objective-C中编写省略参数的多参数函数引语：在Object-C中，我们会遇到很多像NSLog这样的函数，其中参数的个数不确定，由程序员自由控制，在初始化数组，字典等方面应用广泛，那么，这类的函数是如何实现的呢？我们怎么编写我们自己的省略参数的函数呢？当然，这不是唯一的多参函数的处理方法，你也可以通过一个字典或者数组传递参数。但C为我们提供的这样的一种机制，无疑是最方便的。 一、了解几个概念va_list C语言中定义的一个指针，用于指向当前的参数。 va_start(ap,param) 这个宏是初始化参数列表，其中第一个参数是va_list对象，第二个参数是参数列表的第一个参数。 va_arg(ap, type) 一个用于取出参数的宏，这个宏的第一个参数是va_list对象，第二个参数是要取出的参数类型。 va_end(ap) 这个宏用于关闭取参列表 二、多参函数的取参原理在编写我们自己的多参函数之前，明白函数的取参原理是十分重要的，首先，函数的参数是被放入我们内存的栈段的，而且放入的顺序是从后往前放入，比如如果一个函数参数如下： void func(int a,int b,int c,int d) 那么传递参数的时候参数d先入栈，接着是c、b、a。如此这样，在取参的时候，根据堆栈的取值原则，则取值顺序为a、b、c、d。所以在原理上，只要我们知道第一个参数的地址和每个参数的类型，我们就可以将参数都取出来。而上面介绍的几个宏，就是帮助我们做这些的。 三、声明与实现省略参数的多参函数“…”这个符号就是我们用来实现省略参数函数的符号。例如我们模拟实现一个log函数如下： 12345678910-(void)myLog:(NSString *)str,...&#123;//省略参数的写法 va_list list;//创建一个列表指针对象 va_start(list, str);//进行列表的初始化，str为省略前的第一个参数，及...之前的那个参数 NSString * temStr = str; while (temStr!=nil) &#123;//如果不是nil，则继续取值 NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*);//返回取到的值，并且让指针指向下一个参数的地址 &#125; va_end(list);//关闭列表指针&#125; 注意，调用时，我们必须在参数的最后加上nil这个判断结束的条件： 1[self myLog:@&quot;312&quot;,@&quot;321&quot;, nil];//必须有nil 四、一点补充细心的你可能发现了，这里的nil是我们在调用函数时手动加上的，可是系统的许多函数在我们调用时，系统直接帮我们加上了参数结尾的那个nil，例如 NSArray * array = [NSArray arrayWithObjects:(id), nil] 这是如何做到的呢？我们只需要在函数的声明里加上一个宏，就可以实现这个功能，修改如下： 12345678910-(void)myLog:(NSString *)str,...NS_REQUIRES_NIL_TERMINATION&#123;//这里加上一个宏 va_list list; va_start(list, str); NSString * temStr = str; while (temStr!=nil) &#123; NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*); &#125; va_end(list);&#125; 顾名思义，这个宏的作用就是在结束位置加上我们需要的nil。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UITableViewCell使用详解","slug":"44iOS UITableViewCell使用详解","date":"2015-05-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.399Z","comments":true,"path":"2015/05/04/44iOS UITableViewCell使用详解/","link":"","permalink":"http://huishao.cc/2015/05/04/44iOS UITableViewCell使用详解/","excerpt":"","text":"iOS中UITableViewCell使用详解- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier; Cell的初始化方法，可以设置一个风格和标识符，风格的枚举如下： 123456typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123; UITableViewCellStyleDefault, // 默认风格，自带标题和一个图片视图，图片在左 UITableViewCellStyleValue1, // 只有标题和副标题 副标题在右边 UITableViewCellStyleValue2, // 只有标题和副标题，副标题在左边标题的下边 UITableViewCellStyleSubtitle // 自带图片视图和主副标题，主副标题都在左边，副标题在下&#125;; @property (nonatomic, readonly, retain) UIImageView *imageView; 图片视图，风格允许时才会创建 @property (nonatomic, readonly, retain) UILabel *textLabel; 标题标签 @property (nonatomic, readonly, retain) UILabel *detailTextLabel; 副标题标签 @property (nonatomic, readonly, retain) UIView *contentView; 容纳视图，任何cell的子视图都应该添加在这个上面 @property (nonatomic, retain) UIView *backgroundView; 背景视图 @property (nonatomic, retain) UIView *selectedBackgroundView; 选中状态下的背景视图 @property (nonatomic, retain) UIView *multipleSelectionBackgroundView; 多选选中时的背景视图 @property (nonatomic, readonly, copy) NSString *reuseIdentifier; cell的标识符 - (void)prepareForReuse; 当被重用的cell将要显示时，会调用这个方法，这个方法最大的用武之地是当你自定义的cell上面有图片时，如果产生了重用，图片可能会错乱（当图片来自异步下载时及其明显），这时我们可以重写这个方法把内容抹掉。 @property (nonatomic) UITableViewCellSelectionStyle selectionStyle; cell被选中时的风格，枚举如下： 123456typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123; UITableViewCellSelectionStyleNone,//无 UITableViewCellSelectionStyleBlue,//蓝色 UITableViewCellSelectionStyleGray,//灰色 UITableViewCellSelectionStyleDefault//默认 为蓝色&#125;; @property (nonatomic, getter=isSelected) BOOL selected; 设置cell是否选中状态 @property (nonatomic, getter=isHighlighted) BOOL highlighted; 设置cell是否高亮状态 - (void)setSelected:(BOOL)selected animated:(BOOL)animated; - (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated; 与上面的两个属性对应 @property (nonatomic, readonly) UITableViewCellEditingStyle editingStyle; 获取cell的编辑状态，枚举如下 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone,//无编辑 UITableViewCellEditingStyleDelete,//删除编辑 UITableViewCellEditingStyleInsert//插入编辑&#125;; @property (nonatomic) BOOL showsReorderControl; 设置是否显示cell自带的自动排序控件 注意：要让cell实现拖动排序的功能，除了上面设置为YES，还需实现代理中的如下方法： -(BOOL)tableView:(UITableView )tableView canMoveRowAtIndexPath:(NSIndexPath )indexPath{ return YES; } -(void)tableView:(UITableView )tableView moveRowAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{ } @property (nonatomic) BOOL shouldIndentWhileEditing; 设置编辑状态下是否显示缩进 @property (nonatomic) UITableViewCellAccessoryType accessoryType; 设置附件视图的风格(cell最右侧显示的视图) 枚举如下： 1234567typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123; UITableViewCellAccessoryNone, // 没有视图 UITableViewCellAccessoryDisclosureIndicator, // cell右侧显示一个灰色箭头 UITableViewCellAccessoryDetailDisclosureButton, // 显示详情符号和灰色箭头 UITableViewCellAccessoryCheckmark, // cell右侧显示蓝色对号 UITableViewCellAccessoryDetailButton // cell右侧显示一个详情符号&#125;; @property (nonatomic, retain) UIView *accessoryView; 附件视图 @property (nonatomic) UITableViewCellAccessoryType editingAccessoryType; cell编辑时的附件视图风格 @property (nonatomic, retain) UIView *editingAccessoryView; cell编辑时的附件视图 @property (nonatomic) NSInteger indentationLevel; 设置内容区域的缩进级别 @property (nonatomic) CGFloat indentationWidth; 设置每个级别的缩进宽度 @property (nonatomic) UIEdgeInsets separatorInset; 设置分割线的偏移量 @property (nonatomic, getter=isEditing) BOOL editing; - (void)setEditing:(BOOL)editing animated:(BOOL)animated; 设置是否编辑状态 @property(nonatomic, readonly) BOOL showingDeleteConfirmation; 返回是否目前正在显示删除按钮 - (void)willTransitionToState:(UITableViewCellStateMask)state; cell状态将要转换时调用的函数，可以在子类中重写 - (void)didTransitionToState:(UITableViewCellStateMask)state; cell状态已经转换时调用的函数，可以在子类中重写，状态枚举如下： 12345typedef NS_OPTIONS(NSUInteger, UITableViewCellStateMask) &#123; UITableViewCellStateDefaultMask = 0,//默认状态 UITableViewCellStateShowingEditControlMask = 1 &lt;&lt; 0,//编辑状态 UITableViewCellStateShowingDeleteConfirmationMask = 1 &lt;&lt; 1//确认删除状态&#125;; 注意：下面这些方法已经全部在IOS3.0后被废弃了，虽然还有效果，但是会被警告 @property (nonatomic, copy) NSString *text; 设置标题 @property (nonatomic, retain) UIFont *font; 设置字体 @property (nonatomic) NSTextAlignment textAlignment; 设置对其模式 @property (nonatomic) NSLineBreakMode lineBreakMode; 设置断行模式 @property (nonatomic, retain) UIColor *textColor; 设置字体颜色 @property (nonatomic, retain) UIColor *selectedTextColor; 设置选中状态下的字体颜色 @property (nonatomic, retain) UIImage *image; 设置图片 @property (nonatomic, retain) UIImage *selectedImage; 设置选中状态时的图片 @property (nonatomic) BOOL hidesAccessoryWhenEditing; 设置编辑的时候是否隐藏附件视图 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中UIActionSheet使用详解","slug":"42IOS中UIActionSheet使用详解","date":"2015-05-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.393Z","comments":true,"path":"2015/05/03/42IOS中UIActionSheet使用详解/","link":"","permalink":"http://huishao.cc/2015/05/03/42IOS中UIActionSheet使用详解/","excerpt":"","text":"IOS中UIActionSheet使用方法详解一、初始化方法- (instancetype)initWithTitle:(NSString )title delegate:(id)delegate cancelButtonTitle:(NSString )cancelButtonTitle destructiveButtonTitle:(NSString )destructiveButtonTitle otherButtonTitles:(NSString )otherButtonTitles, …; 参数说明： title：视图标题 delegate：设置代理 cancelButtonTitle：取消按钮的标题 destructiveButtonTitle：特殊标记的按钮的标题 otherButtonTitles：其他按钮的标题 二、常用方法和属性介绍@property(nonatomic,copy) NSString *title; 设置标题 @property(nonatomic) UIActionSheetStyle actionSheetStyle; 设置风格，枚举如下： 123456typedef NS_ENUM(NSInteger, UIActionSheetStyle) &#123; UIActionSheetStyleAutomatic = -1, UIActionSheetStyleDefault = UIBarStyleDefault, UIActionSheetStyleBlackTranslucent = UIBarStyleBlackTranslucent, UIActionSheetStyleBlackOpaque = UIBarStyleBlackOpaque,&#125;; - (NSInteger)addButtonWithTitle:(NSString *)title; 添加一个按钮，会返回按钮的索引 - (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex; 获取按钮标题 @property(nonatomic,readonly) NSInteger numberOfButtons; 获取按钮数量 @property(nonatomic) NSInteger cancelButtonIndex; 设置取消按钮的索引值 @property(nonatomic) NSInteger destructiveButtonIndex; 设置特殊标记 @property(nonatomic,readonly,getter=isVisible) BOOL visible; 视图当前是否可见 下面是几种弹出方式，会根据风格不同展现不同的方式 - (void)showFromToolbar:(UIToolbar *)view; - (void)showFromTabBar:(UITabBar *)view; - (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated ; - (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated ; - (void)showInView:(UIView *)view; - (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; 使用代码将视图收回 三、UIActionSheet代理方法- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex; 点击按钮时触发的方法 - (void)willPresentActionSheet:(UIActionSheet *)actionSheet; 视图将要弹出时触发的方法 - (void)didPresentActionSheet:(UIActionSheet *)actionSheet; 视图已经弹出式触发的方法 - (void)actionSheet:(UIActionSheet *)actionSheet willDismissWithButtonIndex:(NSInteger)buttonIndex; 点击按钮后，视图将要收回时触发的方法 - (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex; 点击按钮后，视图已经收回时触发的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIAlertView（警告框）方法总结","slug":"41IOS UIAlertView（警告框）方法总结","date":"2015-04-30T16:00:00.000Z","updated":"2023-04-14T11:50:08.391Z","comments":true,"path":"2015/05/01/41IOS UIAlertView（警告框）方法总结/","link":"","permalink":"http://huishao.cc/2015/05/01/41IOS UIAlertView（警告框）方法总结/","excerpt":"","text":"IOS中UIAlertView(警告框)常用方法总结一、初始化方法- (instancetype)initWithTitle:(NSString )title message:(NSString )message delegate:(id //)delegate cancelButtonTitle:(NSString )cancelButtonTitle otherButtonTitles:(NSString )otherButtonTitles, …;这个方法通过设置一个标题，内容，代理和一些按钮的标题创建警告框，代码示例如下： 12 UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;我的警告框&quot; message:@&quot;这是一个警告框&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil]; [alert show]; 效果如下： 注意：如果按钮数超过两个，将会创建成如下样子： 如果按钮数量超出屏幕显示范围，则会创建类似tableView的效果。 二、属性与方法解析标题属性 @property(nonatomic,copy) NSString *title; 内容属性 @property(nonatomic,copy) NSString *message; 添加一个按钮，返回的是此按钮的索引值 - (NSInteger)addButtonWithTitle:(NSString *)title; 返回根据按钮索引按钮标题 - (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex; 获取按钮数量 @property(nonatomic,readonly) NSInteger numberOfButtons; 设置将某一个按钮设置为取消按钮 @property(nonatomic) NSInteger cancelButtonIndex; 返回其他类型按钮第一个的索引值 @property(nonatomic,readonly) NSInteger firstOtherButtonIndex; 警告框是否可见 @property(nonatomic,readonly,getter=isVisible) BOOL visible; 显现警告框 - (void)show; 代码模拟点击按钮消失触发方法 - (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; 设置警告框风格 @property(nonatomic,assign) UIAlertViewStyle alertViewStyle; 风格的枚举如下 123456typedef NS_ENUM(NSInteger, UIAlertViewStyle) &#123; UIAlertViewStyleDefault = 0,//默认风格 UIAlertViewStyleSecureTextInput,//密码输入框风格 UIAlertViewStylePlainTextInput,//普通输入框风格 UIAlertViewStyleLoginAndPasswordInput//账号密码框风格&#125;; 这个方法设置文本输入框的索引 - (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex; 三、UIAlertViewDelegate中的方法点击按钮时触发的方法 - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex; 将要展现警告框时触发的方法 - (void)willPresentAlertView:(UIAlertView *)alertView; 已经展现警告框时触发的方法 - (void)didPresentAlertView:(UIAlertView *)alertView; 警告框将要消失时触发的方法 - (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex; 警告框已经消失时触发的方法 - (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex; 设置是否允许第一个按钮不是取消按钮 - (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS调用系统通讯录","slug":"39iOS调用系统通讯录","date":"2015-04-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.385Z","comments":true,"path":"2015/04/29/39iOS调用系统通讯录/","link":"","permalink":"http://huishao.cc/2015/04/29/39iOS调用系统通讯录/","excerpt":"","text":"iOS调用系统通讯录上一篇博客详细介绍了在IOS开发中，我们如何获取通讯录联系人的信息，即对其进行增删改查的操作：http://my.oschina.net/u/2340880/blog/407347。而在一些开发项目中，如果没有特殊需求，并且我们只是需要一些通讯录信息，并不做修改操作，我们完全可以采取另一种更加方便的方式，直接调用系统的通讯录。 首先，导入这个头文件： 1#import &lt;AddressBookUI/AddressBookUI.h&gt; 注意：需要在项目中链接如下两个库： 只需简单的几句代码，就可以弹出系统的通讯录界面： 123 ABPeoplePickerNavigationController * con = [[ABPeoplePickerNavigationController alloc]init]; con.peoplePickerDelegate=self; [self presentViewController:con animated:YES completion:nil]; 点击联系人后执行的方法，我们只需要实现下面的代理方法即可 123-(void)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person&#123; //person参数就是选择的联系人的引用 具体含义和数据获取，在上一篇博客中有详细介绍&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中调用系统拨打电话与发送短信","slug":"40IOS中调用系统拨打电话与发送短信","date":"2015-04-28T16:00:00.000Z","updated":"2023-04-14T11:50:08.388Z","comments":true,"path":"2015/04/29/40IOS中调用系统拨打电话与发送短信/","link":"","permalink":"http://huishao.cc/2015/04/29/40IOS中调用系统拨打电话与发送短信/","excerpt":"","text":"IOS中调用系统拨打电话发送短信一、调用打电话界面[[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@”tel://%@”,_phoneNumber]]]; 二、发送短消息界面调用系统的发送短信的界面，需要引入以下头文件： #import &lt;MessageUI/MessageUI.h&gt; 系统短信界面的调用很简单，只需下面几句代码： 12345 MFMessageComposeViewController * con = [[MFMessageComposeViewController alloc]init]; if ([MFMessageComposeViewController canSendText]) &#123; con.recipients=@[_phoneNumber];//电话数组 con.messageComposeDelegate=self; [self presentViewController:con animated:YES completion:nil]; 下面将MessageUI的一些常用方法总结如下： + (BOOL)canSendText 判断是否支持发送文字 + (BOOL)canSendSubject; 判断是否支持发送主题信息 + (BOOL)canSendAttachments; 判断是否支持发送附件 + (BOOL)isSupportedAttachmentUTI:(NSString *)uti; 判断是否支持统一标示附件 - (void)disableUserAttachments; 禁止发送附件 @property(nonatomic,copy) NSArray *recipients; 联系人数组，会显示在发送人列表里 @property(nonatomic,copy) NSString *body; 信息主体内容 @property(nonatomic,copy) NSString *subject; 信息标题 @property(nonatomic,copy, readonly) NSArray *attachments; 信息附件数组 只读的 里面是字典 - (BOOL)addAttachmentURL:(NSURL )attachmentURL withAlternateFilename:(NSString )alternateFilename; 根据URL路径和添加附件，返回YES表示添加成功 - (BOOL)addAttachmentData:(NSData )attachmentData typeIdentifier:(NSString )uti filename:(NSString *)filename; 根据Data数据添加附件 - (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result; MFMessageComposeViewControllerDelegate的代理方法，result会传回来一个结果，枚举如下： 12345678enum MessageComposeResult &#123; //取消发送 MessageComposeResultCancelled, //发送成功 MessageComposeResultSent, //发送失败 MessageComposeResultFailed&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS代码运行的磨刀石-预编译指令","slug":"37iOS代码运行的磨刀石-预编译指令","date":"2015-04-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.379Z","comments":true,"path":"2015/04/28/37iOS代码运行的磨刀石-预编译指令/","link":"","permalink":"http://huishao.cc/2015/04/28/37iOS代码运行的磨刀石-预编译指令/","excerpt":"","text":"iOS中代码运行的磨刀石–预编译指令所谓预编译，就是程序代码在编译之前，开发工具为我们预先做的一些工作。不要小瞧这些指令，没有它们，我们的代码可能寸步难行。 一、文件包含相关预处理命令#include #include “header” C语言中使用的包含文件的指令””和&lt;&gt;的区别为，””是从当前目录开始寻找文件，&lt;&gt;是从系统库中寻找文件。这两个指令不能使头文件循环引入，也不能重复包含同一个头文件。 #import “header” #import 这两个指令和上面两个作用一样，只是更加智能，智能处理重复包含头文件的问题。 #include_next “header” #include_next 这两个指令是C中的指令，OC也支持，只是很少使用，它的作用是在找到名字匹配的头文件后跳过，寻找下一个相同名字的导入。 二、宏定义宏定义是开发中会经常用到的一个指令了，我们还会将许多简单的函数定义为宏，省去系统压栈的时间，提高代码效率。因为这篇博客的主题是预处理命令，所以宏的用法和高级用法就不再多写了，下次再讨论。 #define 参数1 参数2 定义一个简单的替换宏，不带参数，在预编译阶段，会把所有参数1的地方直接替换为参数2。 #define ADD(x) (x+x) 定义一个带参数的宏，类似带参函数的功能，但也是编译前做简单替换。 三、条件编译条件编译用于判断一个表达式是否成立，成立则进入条件编译。 方式一： #if 表达式 #else #endif 方式二： #if 表达式 #elif 表达式 #endif 方式三: #ifndef 如果没有定义一个宏进行编译 #ifdef 如果定义一个宏进行编译 四、错误，警告的预处理#error 错误 当程序检查到这里时会停止编译，这个命令的作用是在错误的地方禁止编译。 #warning 警告 这个命令并不会影响程序的编译和运行，但是会认为的在这里显示一条警告信息，提醒我们自己。 五、更改文件名和行号在OC中，有一个系统的定义的宏: __LINE__ 这个宏表示当前行的行号，可以打印。 #line number 改变当前行的行号，会影响下面所有的行 #line number “filename” 改变当前行号和编译后的文件名 六、编译器控制指令#pragma 参数 这个预编译指令是最复杂的，用于控制编译器的行为，一般我们开发应用APP是很少用到的，常用的有两种方式： #pragma mark - 信息 为代码加上标注 #pragma message(“信息”) 编译时提示信息 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS获取通讯录联系人信息","slug":"38iOS获取通讯录联系人信息","date":"2015-04-27T16:00:00.000Z","updated":"2023-04-14T11:50:08.382Z","comments":true,"path":"2015/04/28/38iOS获取通讯录联系人信息/","link":"","permalink":"http://huishao.cc/2015/04/28/38iOS获取通讯录联系人信息/","excerpt":"","text":"iOS获取系统通讯录联系人信息一、权限注册随着apple对用户隐私的越来越重视，IOS系统的权限设置也更加严格，在获取系统通讯录之前，我们必须获得用户的授权。权限申请代码示例如下： 12345678910111213141516171819202122232425262728293031 //这个变量用于记录授权是否成功，即用户是否允许我们访问通讯录 int __block tip=0; //声明一个通讯簿的引用 ABAddressBookRef addBook =nil; //因为在IOS6.0之后和之前的权限申请方式有所差别，这里做个判断 if ([[UIDevice currentDevice].systemVersion floatValue]&gt;=6.0) &#123; //创建通讯簿的引用 addBook=ABAddressBookCreateWithOptions(NULL, NULL); //创建一个出事信号量为0的信号 dispatch_semaphore_t sema=dispatch_semaphore_create(0); //申请访问权限 ABAddressBookRequestAccessWithCompletion(addBook, ^(bool greanted, CFErrorRef error) &#123; //greanted为YES是表示用户允许，否则为不允许 if (!greanted) &#123; tip=1; &#125; //发送一次信号 dispatch_semaphore_signal(sema); &#125;); //等待信号触发 dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); &#125;else&#123; //IOS6之前 addBook =ABAddressBookCreate(); &#125; if (tip) &#123; //做一个友好的提示 UIAlertView * alart = [[UIAlertView alloc]initWithTitle:@&quot;温馨提示&quot; message:@&quot;请您设置允许APP访问您的通讯录\\nSettings&gt;General&gt;Privacy&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil]; [alart show]; return; &#125; 几点注意：1、dispatch_semaphore_t三个相关的操作为 dispatch_semaphore_create 创建一个信号 dispatch_semaphore_signal 发送一个信号 dispatch_semaphore_wait 等待信号触发 dispatch_semaphore_create()创建一个信号，后面可以跟一个参数，表示信号量，当信号量正值时，dispatch_semaphore_wait后面的代码会被执行，否则程序将会一直等待在dispatch_semaphore_wait。 dispatch_semaphore_signal的作用是发送一个信号，会使信号量加1，相对的，dispatch_semaphore_wait执行后会使信号量减1. 2、因为是否被授权是在ABAddressBookRequestAccessWithCompletion的block回调中获取的，所以我们需要在外面做一个线程等待。 二、获取通讯录联系人详细信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 //获取所有联系人的数组 CFArrayRef allLinkPeople = ABAddressBookCopyArrayOfAllPeople(addBook); //获取联系人总数 CFIndex number = ABAddressBookGetPersonCount(addBook); //进行遍历 for (NSInteger i=0; i&lt;number; i++) &#123; //获取联系人对象的引用 ABRecordRef people = CFArrayGetValueAtIndex(allLinkPeople, i); //获取当前联系人名字 NSString*firstName=(__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); //获取当前联系人姓氏 NSString*lastName=(__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); //获取当前联系人中间名 NSString*middleName=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonMiddleNameProperty)); //获取当前联系人的名字前缀 NSString*prefix=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonPrefixProperty)); //获取当前联系人的名字后缀 NSString*suffix=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonSuffixProperty)); //获取当前联系人的昵称 NSString*nickName=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonNicknameProperty)); //获取当前联系人的名字拼音 NSString*firstNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonFirstNamePhoneticProperty)); //获取当前联系人的姓氏拼音 NSString*lastNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonLastNamePhoneticProperty)); //获取当前联系人的中间名拼音 NSString*middleNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonMiddleNamePhoneticProperty)); //获取当前联系人的公司 NSString*organization=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonOrganizationProperty)); //获取当前联系人的职位 NSString*job=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonJobTitleProperty)); //获取当前联系人的部门 NSString*department=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonDepartmentProperty)); //获取当前联系人的生日 NSString*birthday=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonBirthdayProperty)); NSMutableArray * emailArr = [[NSMutableArray alloc]init]; //获取当前联系人的邮箱 注意是数组 ABMultiValueRef emails= ABRecordCopyValue(people, kABPersonEmailProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(emails); j++) &#123; [emailArr addObject:(__bridge NSString *)(ABMultiValueCopyValueAtIndex(emails, j))]; &#125; //获取当前联系人的备注 NSString*notes=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonNoteProperty)); //获取当前联系人的电话 数组 NSMutableArray * phoneArr = [[NSMutableArray alloc]init]; ABMultiValueRef phones= ABRecordCopyValue(people, kABPersonPhoneProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(phones); j++) &#123; [phonerr addObject:(__bridge NSString *)(ABMultiValueCopyValueAtIndex(phones, j))]; &#125; //获取创建当前联系人的时间 注意是NSDate NSDate*creatTime=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonCreationDateProperty)); //获取最近修改当前联系人的时间 NSDate*alterTime=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonModificationDateProperty)); //获取地址 ABMultiValueRef address = ABRecordCopyValue(people, kABPersonAddressProperty); for (int j=0; j&lt;ABMultiValueGetCount(address); j++) &#123; //地址类型 NSString * type = (__bridge NSString *)(ABMultiValueCopyLabelAtIndex(address, j)); NSDictionary * temDic = (__bridge NSDictionary *)(ABMultiValueCopyValueAtIndex(address, j)); //地址字符串，可以按需求格式化 NSString * adress = [NSString stringWithFormat:@&quot;国家:%@\\n省:%@\\n市:%@\\n街道:%@\\n邮编:%@&quot;,[temDic valueForKey:(NSString*)kABPersonAddressCountryKey],[temDic valueForKey:(NSString*)kABPersonAddressStateKey],[temDic valueForKey:(NSString*)kABPersonAddressCityKey],[temDic valueForKey:(NSString*)kABPersonAddressStreetKey],[temDic valueForKey:(NSString*)kABPersonAddressZIPKey]]; &#125; //获取当前联系人头像图片 NSData*userImage=(__bridge NSData*)(ABPersonCopyImageData(people)); //获取当前联系人纪念日 NSMutableArray * dateArr = [[NSMutableArray alloc]init]; ABMultiValueRef dates= ABRecordCopyValue(people, kABPersonDateProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(dates); j++) &#123; //获取纪念日日期 NSDate * data =(__bridge NSDate*)(ABMultiValueCopyValueAtIndex(dates, j)); //获取纪念日名称 NSString * str =(__bridge NSString*)(ABMultiValueCopyLabelAtIndex(dates, j)); NSDictionary * temDic = [NSDictionary dictionaryWithObject:data forKey:str]; [dateArr addObject:temDic]; &#125; 一点扩展：相同的方法，可以获取关联人信息，社交信息，邮箱信息，各种类型的电话信息，字段如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //相关人，组织字段const ABPropertyID kABPersonKindProperty; const CFNumberRef kABPersonKindPerson;const CFNumberRef kABPersonKindOrganization;// 电话相关字段AB_EXTERN const ABPropertyID kABPersonPhoneProperty;AB_EXTERN const CFStringRef kABPersonPhoneMobileLabel;AB_EXTERN const CFStringRef kABPersonPhoneIPhoneLabel AB_EXTERN const CFStringRef kABPersonPhoneMainLabel;AB_EXTERN const CFStringRef kABPersonPhoneHomeFAXLabel;AB_EXTERN const CFStringRef kABPersonPhoneWorkFAXLabel;AB_EXTERN const CFStringRef kABPersonPhoneOtherFAXLabelAB_EXTERN const CFStringRef kABPersonPhonePagerLabel;// 即时聊天信息相关字段AB_EXTERN const ABPropertyID kABPersonInstantMessageProperty; AB_EXTERN const CFStringRef kABPersonInstantMessageServiceKey; AB_EXTERN const CFStringRef kABPersonInstantMessageServiceYahoo;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceJabber;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceMSN;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceICQ;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceAIM;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceQQ AB_EXTERN const CFStringRef kABPersonInstantMessageServiceGoogleTalk;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceSkype;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceFacebook;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceGaduGadu;AB_EXTERN const CFStringRef kABPersonInstantMessageUsernameKey; // 个人网页相关字段AB_EXTERN const ABPropertyID kABPersonURLProperty;AB_EXTERN const CFStringRef kABPersonHomePageLabel; //相关人姓名字段AB_EXTERN const ABPropertyID kABPersonRelatedNamesProperty; AB_EXTERN const CFStringRef kABPersonFatherLabel; // FatherAB_EXTERN const CFStringRef kABPersonMotherLabel; // MotherAB_EXTERN const CFStringRef kABPersonParentLabel; // ParentAB_EXTERN const CFStringRef kABPersonBrotherLabel; // BrotherAB_EXTERN const CFStringRef kABPersonSisterLabel; // SisterAB_EXTERN const CFStringRef kABPersonChildLabel; // ChildAB_EXTERN const CFStringRef kABPersonFriendLabel; // FriendAB_EXTERN const CFStringRef kABPersonSpouseLabel; // SpouseAB_EXTERN const CFStringRef kABPersonPartnerLabel; // PartnerAB_EXTERN const CFStringRef kABPersonAssistantLabel; // AssistantAB_EXTERN const CFStringRef kABPersonManagerLabel; // Manager 三、通讯录“写”的相关操作看到上面读取信息的代码，你可能觉得一阵目炫，其实只是字段比较长，逻辑还是很简单的，同样，写的操作与之类似，创建，修改，删除，是我们对通讯录“写”的常用操作。 1、创建一个联系人123456789101112131415161718192021222324252627 //创建一个联系人引用 ABRecordRef person = ABPersonCreate(); NSString *firstName = @&quot;哈&quot;; NSString *lastName = @&quot;哈&quot;; // 电话号码数组 NSArray *phones = [NSArray arrayWithObjects:@&quot;123&quot;,@&quot;456&quot;,nil]; // 电话号码对应的名称 NSArray *labels = [NSArray arrayWithObjects:@&quot;iphone&quot;,@&quot;home&quot;,nil]; //这里的字段和上面的字段完全相同 // 设置名字属性 ABRecordSetValue(person, kABPersonFirstNameProperty,(__bridge CFStringRef)firstName, NULL); // 设置姓氏属性 ABRecordSetValue(person, kABPersonLastNameProperty, (__bridge CFStringRef)lastName, NULL); // 设置生日属性 ABRecordSetValue(person, kABPersonBirthdayProperty,(__bridge CFDateRef)birthday, NULL); // 字典引用 ABMultiValueRef dic =ABMultiValueCreateMutable(kABMultiStringPropertyType); // 添加电话号码与其对应的名称内容 for (int i = 0; i &lt; [phones count]; i ++) &#123; ABMultiValueIdentifier obj = ABMultiValueAddValueAndLabel(dic,(__bridge CFStringRef)[phones objectAtIndex:i], (__bridge CFStringRef)[labels objectAtIndex:i], &amp;obj); &#125; // 设置phone属性 ABRecordSetValue(person, kABPersonPhoneProperty, dic, NULL); // 将新建的联系人添加到通讯录中 ABAddressBookAddRecord(addBook, person, NULL); // 保存通讯录数据 ABAddressBookSave(addBook, NULL); 2、修改联系人修改联系人的操作就是将获取和添加和在一起，先获取到相应的联系人引用，重设其属性字段即可。 3.删除联系人12345678910111213 //获取所有联系人 NSArray *array = (__bridge NSArray*)ABAddressBookCopyArrayOfAllPeople(addBook); // 遍历所有的联系人 for (id obj in array) &#123; ABRecordRef people = (__bridge ABRecordRef)obj; NSString *firstName = (__bridge NSString*)ABRecordCopyValue(people, kABPersonFirstNameProperty); NSString *lastName = (__bridge NSString*)ABRecordCopyValue(people, kABPersonLastNameProperty); if ([firstName isEqualToString:@&quot;哈&quot;] &amp;&amp;[lastName isEqualToString:@&quot;哈&quot;]) &#123; ABAddressBookRemoveRecord(addBook, people,NULL); &#125; &#125; // 保存修改的通讯录对象 ABAddressBookSave(addBook, NULL); 四、重中之重-关于内存管理上面的代码为了演示方便，创建的全部引用都没有释放，势必是造成内存泄露，在我们用ABAddressBookCreate()创建一个引用对象时，切记无论ARC还MRC，要用CFRelease()进行释放引用，例如上面的例子，我们需要加上这句代码 CFRelease(addBook); 如果你耐心的看到了这里，我想你一定明白了我为什么不在前边的代码里说明这个问题，因为在ARC项目普及的现在，这的确是重中之重。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中JSON数据的解析","slug":"35iOS中JSON数据的解析","date":"2015-04-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.375Z","comments":true,"path":"2015/04/27/35iOS中JSON数据的解析/","link":"","permalink":"http://huishao.cc/2015/04/27/35iOS中JSON数据的解析/","excerpt":"","text":"iOS中JSON数据解析官方为我们提供的解析JSON数据的类是NSJSONSerialization，首先我们先来看下这个类的几个方法： + (BOOL)isValidJSONObject:(id)obj; 判断一个数据对象是否可以转化为JSON数据 + (NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error; 将JSON数据写为NSData数据，其中opt参数的枚举如下，这个参数可以设置，也可以不设置，如果设置，则会输出视觉美观的JSON数据，否则输出紧凑的JSON数据。 123typedef NS_OPTIONS(NSUInteger, NSJSONWritingOptions) &#123; NSJSONWritingPrettyPrinted = (1UL &lt;&lt; 0)&#125; + (id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error; 这个方法是解析中数据的核心方法，data是JSON数据对象，可以设置一个opt参数，具体用法如下： 12345678typedef NS_OPTIONS(NSUInteger, NSJSONReadingOptions) &#123; //将解析的数组和字典设置为可变对象 NSJSONReadingMutableContainers = (1UL &lt;&lt; 0), //将解析数据的子节点创建为可变字符串对象 NSJSONReadingMutableLeaves = (1UL &lt;&lt; 1), //允许解析对象的最上层不是字典或者数组 NSJSONReadingAllowFragments = (1UL &lt;&lt; 2)&#125; + (NSInteger)writeJSONObject:(id)obj toStream:(NSOutputStream *)stream options:(NSJSONWritingOptions)opt error:(NSError **)error; 将JSON数据写入到输出流，返回的是写入流的字节数 + (id)JSONObjectWithStream:(NSInputStream *)stream options:(NSJSONReadingOptions)opt error:(NSError **)error; 从输入流读取JSON数据 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS(CGGeometry)几何类方法总结","slug":"36iOS(CGGeometry)几何类方法总结","date":"2015-04-26T16:00:00.000Z","updated":"2023-04-14T11:50:08.377Z","comments":true,"path":"2015/04/27/36iOS(CGGeometry)几何类方法总结/","link":"","permalink":"http://huishao.cc/2015/04/27/36iOS(CGGeometry)几何类方法总结/","excerpt":"","text":"iOS开发几何类方法总结CGGeometry.h文件是用C语言实现的一个封装了许多常用几何方法的文件。 一、几个常用结构体struct CGPoint { CGFloat x; CGFloat y; }; 定义一个点，设置x坐标和y坐标 struct CGSize { CGFloat width; CGFloat height; }; 定义一个尺寸，设置宽度和高度 struct CGVector { CGFloat dx; CGFloat dy; }; 定义一个二维矢量 struct CGRect { CGPoint origin; CGSize size; }; 定义一个矩形 二、几个系统定义的量const CGPoint CGPointZero 零点，与CGPointMake(0, 0)等效 const CGSize CGSizeZero 零尺寸，与CGSizeMake(0, 0)等效 const CGRect CGRectZero 零矩形，与CGRectMake(0, 0, 0, 0)等效 const CGRect CGRectNull 空矩形，这个和零矩形并不相同，当我们返回两个不相交矩形的交集时，会返回空矩形。 const CGRect CGRectInfinite 无限的矩形 三、一些常用方法CGPoint CGPointMake(CGFloat x, CGFloat y); 创建一个点 CGSize CGSizeMake(CGFloat width, CGFloat height); 创建一个尺寸 CGVectorMake(CGFloat dx, CGFloat dy); 创建一个矢量 CGRect CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height); 创建一个矩形 CGFloat CGRectGetMinX(CGRect rect); 获得矩形最左边的x值 CGFloat CGRectGetMidX(CGRect rect); 获取矩形中点的x值 CGFloat CGRectGetMaxX(CGRect rect); 获取矩形最右端的x值 CGFloat CGRectGetMinY(CGRect rect); 获取矩形最上端的y值 CGFloat CGRectGetMidY(CGRect rect); 获取矩形中心点的y值 CGFloat CGRectGetMaxY(CGRect rect); 获取矩形最下端的y值 CGFloat CGRectGetWidth(CGRect rect); 获取矩形宽度 CGFloat CGRectGetHeight(CGRect rect); 获取矩形高度 bool CGPointEqualToPoint(CGPoint point1, CGPoint point2); 判断两个点是否相等 bool CGSizeEqualToSize(CGSize size1, CGSize size2); 判断两个尺寸是否相等 bool CGRectEqualToRect(CGRect rect1, CGRect rect2); 判断两个矩形是否相等 CGRect CGRectStandardize(CGRect rect); 根据一个矩形创建一个标准的矩形 bool CGRectIsEmpty(CGRect rect); 判断是否为零矩形 CGRectIsNull(CGRect rect); 判断是否为空矩形 bool CGRectIsInfinite(CGRect rect); 判断是否为无限矩形 CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy); 创建一个内嵌的矩形，中心和rect参数的中心一样，dx，dy对应内嵌的宽度和高度 比如：CGRect rect= CGRectInset(CGRectMake(0, 0, 100, 100), 10, 10); 会创建出的rect为（10，10，80，80），dx，dy也可以为负值，则是创建出来的矩形会大于原矩形范围。 CGRect CGRectIntegral(CGRect rect) 根据一个矩形，返回四个参数都是整数的矩形 CGRect CGRectUnion(CGRect r1, CGRect r2); 返回两个矩形的并集 CGRect CGRectIntersection(CGRect r1, CGRect r2); 返回两个矩形的交集，如果没有交集，返回空矩形 CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy); 返回一个矩形，偏移量相对于rect void CGRectDivide(CGRect rect, CGRect slice, CGRect remainder, CGFloat amount, CGRectEdge edge); 这个函数用来分割矩形，参数rect是源矩形，slice和remainder是分割后的两部分矩形，amount是分割线，edge是分割选项。 注意：1、edge是一个宏，定义了分割的方式如下： 12345678910typedef CF_ENUM(uint32_t, CGRectEdge) &#123; //从x的最小处进行垂直分割 CGRectMinXEdge, //从y的最小处进行水平分割 CGRectMinYEdge, //从x最大处进行垂直分割 CGRectMaxXEdge, //从y最大处进行水平分割 CGRectMaxYEdge&#125;; 2、slice和remainder是地址。 3、举例如下，将会分割出两个矩形分别为(40,0,60,100)(0,0,40,100); 1234CGRect rect = CGRectMake(0, 0, 100, 100); CGRect slice ; CGRect remainder; CGRectDivide(rect, &amp;slice, &amp;remainder, 60, CGRectMaxXEdge); bool CGRectContainsPoint(CGRect rect, CGPoint point); 判断点是否在矩形内 bool CGRectContainsRect(CGRect rect1, CGRect rect2); 判断矩形1是否包含矩形2 bool CGRectIntersectsRect(CGRect rect1, CGRect rect2); 判断矩形1和矩形2是否相交 CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point); 返回一个表示点的字典 bool CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point); 将字典转换为点 CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size); 返回一个表示尺寸的字典 bool CGSizeMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGSize *size) ; 将字典转换为尺寸 CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect); 返回一个表示矩形的字典 bool CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect); 将字典转化为矩形 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中使用像素位图(CGImageRef)对图片进行处理","slug":"34iOS中使用像素位图(CGImageRef)对图片进行处理","date":"2015-04-25T16:00:00.000Z","updated":"2023-04-14T11:50:08.372Z","comments":true,"path":"2015/04/26/34iOS中使用像素位图(CGImageRef)对图片进行处理/","link":"","permalink":"http://huishao.cc/2015/04/26/34iOS中使用像素位图(CGImageRef)对图片进行处理/","excerpt":"","text":"iOS中对图片进行重绘处理的方法总结一、CGImageRef是什么CGImageRef是定义在QuartzCore框架中的一个结构体指针，用C语言编写。在CGImage.h文件中，我们可以看到下面的定义： 1typedef struct CGImage *CGImageRef; CGImageRef 和 struct CGImage * 是完全等价的。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。 QuartzCore这个框架是可移植的。 二、CGImageRef相关的一些方法解析CFTypeID CGImageGetTypeID(void) 这个方法返回的是一个编号，每个Core Foundation框架中得结构都会有一个这样的编号，CFTypeID定义如下： 1234567891011#if __LLP64__typedef unsigned long long CFTypeID;typedef unsigned long long CFOptionFlags;typedef unsigned long long CFHashCode;typedef signed long long CFIndex;#elsetypedef unsigned long CFTypeID;typedef unsigned long CFOptionFlags;typedef unsigned long CFHashCode;typedef signed long CFIndex;#endif 这个方法没有特殊的意义，只是一个标识符。 CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent); 通过这个方法，我们可以创建出一个CGImageRef类型的对象，下面分别对参数进行解释： sizt_t是定义的一个可移植性的单位，在64位机器中为8字节，32位位4字节。 width：图片宽度像素 height：图片高度像素 bitsPerComponent：每个颜色的比特数，例如在rgba-32模式下为8 bitsPerPixel：每个像素的总比特数 bytesPerRow：每一行占用的字节数，注意这里的单位是字节 space：颜色空间模式，例如const CFStringRef kCGColorSpaceGenericRGB 这个函数可以返回一个颜色空间对象。 bitmapInfo：位图像素布局，枚举如下： 1234567891011typedef CF_OPTIONS(uint32_t, CGBitmapInfo) &#123; kCGBitmapAlphaInfoMask = 0x1F, kCGBitmapFloatComponents = (1 &lt;&lt; 8), kCGBitmapByteOrderMask = 0x7000, kCGBitmapByteOrderDefault = (0 &lt;&lt; 12), kCGBitmapByteOrder16Little = (1 &lt;&lt; 12), kCGBitmapByteOrder32Little = (2 &lt;&lt; 12), kCGBitmapByteOrder16Big = (3 &lt;&lt; 12), kCGBitmapByteOrder32Big = (4 &lt;&lt; 12)&#125; provider：数据源提供者 decode[]：解码渲染数组 shouldInterpolate：是否抗锯齿 intent：图片相关参数 CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat decode\\[\\], bool shouldInterpolate) 这个方法用于创建mask图片图层，可以设置其显示部分与不显示部分达到特殊的效果，参数意义同上。 CGImageRef CGImageCreateCopy(CGImageRef image) 这个方法可以复制一个CGImageRef对象 CGImageRef CGImageCreateWithJPEGDataProvider(CGDataProviderRef source, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent) 通过JPEG数据源获取图像 CGImageRef CGImageCreateWithPNGDataProvider(CGDataProviderRef source, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent) 通过PNG数据源获取图像 CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect) 截取图像的一个区域重绘图像 CGImageRef CGImageCreateWithMask(CGImageRef image, CGImageRef mask) 截取mask图像的某一区域重绘 CGImageRef CGImageCreateWithMaskingColors(CGImageRef image, const CGFloat components\\[\\]) 通过颜色分量数组创建位图 CGImageRef CGImageCreateCopyWithColorSpace(CGImageRef image, CGColorSpaceRef space) 通过颜色空间模式复制位图 CGImageRef CGImageRetain(CGImageRef image) 引用+1 void CGImageRelease(CGImageRef image) 引用-1 bool CGImageIsMask(CGImageRef image) 返回是否为Mask图层 size_t CGImageGetWidth(CGImageRef image) 获取宽度像素 size_t CGImageGetHeight(CGImageRef image) 获取高度像素 下面这些方法分别获取相应属性 size_t CGImageGetBitsPerComponent(CGImageRef image) size_t CGImageGetBitsPerPixel(CGImageRef image) size_t CGImageGetBytesPerRow(CGImageRef image) CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)CG_EXTERN CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image) CGDataProviderRef CGImageGetDataProvider(CGImageRef image) const CGFloat *CGImageGetDecode(CGImageRef image) bool CGImageGetShouldInterpolate(CGImageRef image) CGColorRenderingIntent CGImageGetRenderingIntent(CGImageRef image) CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image) 三、应用举例使用CGImageRef进行图片截取 12345678910 //原图片 UIImage * img = [UIImage imageNamed:@&quot;11.11.52.png&quot;]; //转化为位图 CGImageRef temImg = img.CGImage; //根据范围截图 temImg=CGImageCreateWithImageInRect(temImg, CGRectMake(0, 0, 100, 100)); //得到新的图片 UIImage *new = [UIImage imageWithCGImage:temImg]; //释放位图对象 CGImageRelease(temImg); 注意：最后必须要调用这个函数，否则会造成内存泄露 1 CGImageRelease(temImg) 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中通知中心(NSNotificationCenter)的使用总结","slug":"33iOS中通知中心(NSNotificationCenter)的使用总结","date":"2015-04-24T16:00:00.000Z","updated":"2023-04-14T11:50:08.370Z","comments":true,"path":"2015/04/25/33iOS中通知中心(NSNotificationCenter)的使用总结/","link":"","permalink":"http://huishao.cc/2015/04/25/33iOS中通知中心(NSNotificationCenter)的使用总结/","excerpt":"","text":"iOS中通知中心NSNotificationCenter应用总结一、了解几个相关的类1、NSNotification这个类可以理解为一个消息对象，其中有三个成员变量。 这个成员变量是这个消息对象的唯一标识，用于辨别消息对象。 @property (readonly, copy) NSString *name; 这个成员变量定义一个对象，可以理解为针对某一个对象的消息。 @property (readonly, retain) id object; 这个成员变量是一个字典，可以用其来进行传值。 @property (readonly, copy) NSDictionary *userInfo; NSNotification的初始化方法： - (instancetype)initWithName:(NSString )name object:(id)object userInfo:(NSDictionary )userInfo; + (instancetype)notificationWithName:(NSString *)aName object:(id)anObject; + (instancetype)notificationWithName:(NSString )aName object:(id)anObject userInfo:(NSDictionary )aUserInfo; 注意:官方文档有明确的说明，不可以使用init进行初始化 2、NSNotificationCenter这个类是一个通知中心，使用单例设计，每个应用程序都会有一个默认的通知中心。用于调度通知的发送的接受。 添加一个观察者，可以为它指定一个方法，名字和对象。接受到通知时，执行方法。 - (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject; 发送通知消息的方法 - (void)postNotification:(NSNotification *)notification; - (void)postNotificationName:(NSString *)aName object:(id)anObject; - (void)postNotificationName:(NSString )aName object:(id)anObject userInfo:(NSDictionary )aUserInfo; 移除观察者的方法 - (void)removeObserver:(id)observer; - (void)removeObserver:(id)observer name:(NSString *)aName object:(id)anObject; 几点注意： 1、如果发送的通知指定了object对象，那么观察者接收的通知设置的object对象与其一样，才会接收到通知，但是接收通知如果将这个参数设置为了nil，则会接收一切通知。 2、观察者的SEL函数指针可以有一个参数，参数就是发送的死奥西对象本身，可以通过这个参数取到消息对象的userInfo，实现传值。 二、通知的使用流程首先，我们在需要接收通知的地方注册观察者，比如： 1234 //获取通知中心单例对象 NSNotificationCenter * center = [NSNotificationCenter defaultCenter]; //添加当前类对象为一个观察者，name和object设置为nil，表示接收一切通知 [center addObserver:self selector:@selector(notice:) name:@&quot;123&quot; object:nil]; 之后，在我们需要时发送通知消息 1234 //创建一个消息对象 NSNotification * notice = [NSNotification notificationWithName:@&quot;123&quot; object:nil userInfo:@&#123;@&quot;1&quot;:@&quot;123&quot;&#125;]; //发送消息 [[NSNotificationCenter defaultCenter]postNotification:notice]; 我们可以在回调的函数中取到userInfo内容，如下： 123-(void)notice:(id)sender&#123; NSLog(@&quot;%@&quot;,sender);&#125; 打印结果如下： 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS7使用原生API进行二维码和条形码的扫描","slug":"32iOS7使用原生API进行二维码和条形码的扫描","date":"2015-04-23T16:00:00.000Z","updated":"2023-04-14T11:50:08.368Z","comments":true,"path":"2015/04/24/32iOS7使用原生API进行二维码和条形码的扫描/","link":"","permalink":"http://huishao.cc/2015/04/24/32iOS7使用原生API进行二维码和条形码的扫描/","excerpt":"","text":"使用iOS7原生API进行二维码条形码的扫描IOS7之前，开发者进行扫码编程时，一般会借助第三方库。常用的是ZBarSDK，IOS7之后，系统的AVMetadataObject类中，为我们提供了解析二维码的接口。经过测试，使用原生API扫描和处理的效率非常高，远远高于第三方库。 一、使用方法示例官方提供的接口非常简单，代码如下： 123456789101112131415161718192021222324252627282930313233343536@interface ViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate&gt;//用于处理采集信息的代理&#123; AVCaptureSession * session;//输入输出的中间桥梁&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //获取摄像设备 AVCaptureDevice * device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; //创建输入流 AVCaptureDeviceInput * input = [AVCaptureDeviceInput deviceInputWithDevice:device error:nil]; //创建输出流 AVCaptureMetadataOutput * output = [[AVCaptureMetadataOutput alloc]init]; //设置代理 在主线程里刷新 [output setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()]; //初始化链接对象 session = [[AVCaptureSession alloc]init]; //高质量采集率 [session setSessionPreset:AVCaptureSessionPresetHigh]; [session addInput:input]; [session addOutput:output]; //设置扫码支持的编码格式(如下设置条形码和二维码兼容) output.metadataObjectTypes=@[AVMetadataObjectTypeQRCode,AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode128Code]; AVCaptureVideoPreviewLayer * layer = [AVCaptureVideoPreviewLayer layerWithSession:session]; layer.videoGravity=AVLayerVideoGravityResizeAspectFill; layer.frame=self.view.layer.bounds; [self.view.layer insertSublayer:layer atIndex:0]; //开始捕获 [session startRunning];&#125; 之后我们的UI上已经可以看到摄像头捕获的内容，只要实现代理中的方法，就可以完成二维码条形码的扫描： 12345678-(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection&#123; if (metadataObjects.count&gt;0) &#123; //[session stopRunning]; AVMetadataMachineReadableCodeObject * metadataObject = [metadataObjects objectAtIndex : 0 ]; //输出扫描字符串 NSLog(@&quot;%@&quot;,metadataObject.stringValue); &#125;&#125; 二、一些优化通过上面的代码测试，我们可以发现系统的解析处理效率是相当的高，IOS官方提供的API也确实非常强大，然而，我们可以做进一步的优化，将效率更加提高： 首先，AVCaptureMetadataOutput类中有一个这样的属性(在IOS7.0之后可用)： @property(nonatomic) CGRect rectOfInterest; 这个属性大致意思就是告诉系统它需要注意的区域，大部分APP的扫码UI中都会有一个框，提醒你将条形码放入那个区域，这个属性的作用就在这里，它可以设置一个范围，只处理在这个范围内捕获到的图像的信息。如此一来，可想而知，我们代码的效率又会得到很大的提高，在使用这个属性的时候。需要几点注意： 1、这个CGRect参数和普通的Rect范围不太一样，它的四个值的范围都是0-1，表示比例。 2、经过测试发现，这个参数里面的x对应的恰恰是距离左上角的垂直距离，y对应的是距离左上角的水平距离。 3、宽度和高度设置的情况也是类似。 3、举个例子如果我们想让扫描的处理区域是屏幕的下半部分，我们这样设置 1output.rectOfInterest=CGRectMake(0.5,0,0.5, 1); 具体apple为什么要设计成这样，或者是这个参数我的用法那里不对，还需要了解的朋友给个指导。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中使用本地通知为你的APP添加提示用户功能","slug":"31iOS中使用本地通知为你的APP添加提示用户功能","date":"2015-04-22T16:00:00.000Z","updated":"2023-04-14T11:50:08.366Z","comments":true,"path":"2015/04/23/31iOS中使用本地通知为你的APP添加提示用户功能/","link":"","permalink":"http://huishao.cc/2015/04/23/31iOS中使用本地通知为你的APP添加提示用户功能/","excerpt":"","text":"iOS中使用本地通知为你的APP添加提示用户功能首先，我们先要明白一个概念，这里的本地通知是UILocalNotification类，和系统的NSNotificationCenter通知中心是完全不同的概念。 一、我们可以通过本地通知做什么通知，实际上是由IOS系统管理的一个功能，比如某些后台应用做了某项活动需要我们处理、已经退出的应用在某个时间提醒我们唤起等等，如果注册了通知，系统都会在通知触发时给我们发送消息。由此，我们可以通过系统给我们的APP添加通知用户的功能，并且应用非常广泛。例如，闹种类应用，有按时签到相似功能的应用。下面，我们就来介绍如何注册并且设置一个本地通知。 二、了解UILocalNotification类顾名思义，这个类就是我们需要使用的本地通知类，先来看它的几个属性： 设置系统发送通知的时间(如果是过去的时间或者0，则会立刻发起通知) @property(nonatomic,copy) NSDate *fireDate; 设置时间的时区 @property(nonatomic,copy) NSTimeZone *timeZone; 设置周期性通知 @property(nonatomic) NSCalendarUnit repeatInterval; NSCalendarUnit对象是枚举，设定通知的周期 1234567891011typedef NS_OPTIONS(NSUInteger, NSCalendarUnit) &#123; NSCalendarUnitEra = kCFCalendarUnitEra, NSCalendarUnitYear = kCFCalendarUnitYear, NSCalendarUnitMonth = kCFCalendarUnitMonth, NSCalendarUnitDay = kCFCalendarUnitDay, NSCalendarUnitHour = kCFCalendarUnitHour, NSCalendarUnitMinute = kCFCalendarUnitMinute, NSCalendarUnitSecond = kCFCalendarUnitSecond, NSCalendarUnitWeekday = kCFCalendarUnitWeekday, NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal, &#125; 设置周期性通知参照的日历表 @property(nonatomic,copy) NSCalendar *repeatCalendar; 下面这两个函数是IOS8的新功能，在用户进去或者离开某一区域时发送通知 @property(nonatomic,copy) CLRegion *region; 设置区域检测通知是否重复(如果为YES，则没次进去出来都会发送，否则只发送一次) @property(nonatomic,assign) BOOL regionTriggersOnce; 设置通知的主体内容 @property(nonatomic,copy) NSString *alertBody; 是否隐藏滑动启动按钮 @property(nonatomic) BOOL hasAction; 设置滑动打开的提示文字 @property(nonatomic,copy) NSString *alertAction; 设置点击通知后启动的启动图片 @property(nonatomic,copy) NSString *alertLaunchImage; 下面这个方法是IOS8的新方法，是iwatch的接口，通知的短标题 @property(nonatomic,copy) NSString *alertTitle; 收到通知时，播放的系统音 @property(nonatomic,copy) NSString *soundName; 设置应用程序Icon头标数字 @property(nonatomic) NSInteger applicationIconBadgeNumber; 用户字典，可用于传递通知消息参数 @property(nonatomic,copy) NSDictionary *userInfo; 注意：这个字符串是系统默认的提示音 NSString *const UILocalNotificationDefaultSoundName; 三、本地通知的设计流程首先，想让我们的APP实现本地通知功能，必须得到用户的授权，在Appdelegate中实现如下代码： 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //如果已经得到授权，就直接添加本地通知，否则申请询问授权 if ([[UIApplication sharedApplication]currentUserNotificationSettings].types!=UIUserNotificationTypeNone) &#123; [self addLocalNotification]; &#125;else&#123; [[UIApplication sharedApplication]registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]]; &#125; return YES;&#125; 当用户点击允许或者不允许后，会执行如下代理方法，我们把处理逻辑在其中实现 12345-(void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings&#123; if (notificationSettings.types!=UIUserNotificationTypeNone) &#123; [self addLocalNotification]; &#125;&#125; 添加本地通知的方法： 12345678910111213-(void)addLocalNotification&#123; //定义本地通知对象 UILocalNotification *notification=[[UILocalNotification alloc]init]; //设置调用时间 notification.fireDate=[NSDate dateWithTimeIntervalSinceNow:0];//立即触发 //设置通知属性 notification.alertBody=@&quot;HELLO，我是本地通知哦!&quot;; //通知主体 notification.applicationIconBadgeNumber=1;//应用程序图标右上角显示的消息数 notification.alertAction=@&quot;打开应用&quot;; //待机界面的滑动动作提示 notification.soundName=UILocalNotificationDefaultSoundName;//收到通知时播放的声音，默认消息声音 //调用通知 [[UIApplication sharedApplication] scheduleLocalNotification:notification];&#125; 实现了上面三个步骤，本地通知的发出和接受基本都已完成，还有一些细节我们需要考虑： 应用进入前台后，将Icon上的头标清除： 123-(void)applicationWillEnterForeground:(UIApplication *)application&#123; [[UIApplication sharedApplication]setApplicationIconBadgeNumber:0];//进入前台取消应用消息图标&#125; 当不再需要这个通知时，清除它 1 [[UIApplication sharedApplication] cancelAllLocalNotifications]; 四、获取通知中的用户参数字典在上面，我们提到了一个参数 @property(nonatomic,copy) NSDictionary *userInfo; 我们可以在注册通知时将这个参数设置，然后在收到通知时使用get方法得到，但是这里有两种情况： 1、如果我们的APP在前台或者后台进入前台时-(void)application:(UIApplication )application didReceiveLocalNotification:(UILocalNotification )notification; 这个方法是APP在前台或者后台收到通知进入前台时调用的方法 2、如果我们的APP在关闭状态如果是这种情况，我们只能从下面函数的launchOptions中取到我们想要的参数 - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions; 代码示例如下： 123 //接收通知参数 UILocalNotification *notification=[launchOptions valueForKey:UIApplicationLaunchOptionsLocalNotificationKey]; NSDictionary *userInfo= notification.userInfo; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UITableView代理方法详解","slug":"29iOS UITableView代理方法详解","date":"2015-04-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.362Z","comments":true,"path":"2015/04/22/29iOS UITableView代理方法详解/","link":"","permalink":"http://huishao.cc/2015/04/22/29iOS UITableView代理方法详解/","excerpt":"","text":"iOS UITableView的代理方法详解一、补充在上一篇博客中，http://my.oschina.net/u/2340880/blog/404605，我将IOS中tableView(表视图)的一些常用方法总结了一下，这篇将tableView的代理方法作了总结，对上一篇博客进行了补充。 二、UITableViewDataSourc（数据源代理）1、必须实现的回调方法返回每个分区的行数 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; 返回每一行的cell - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; 2、可选实现的方法返回分区数(默认为1) - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 返回每个分区头部的标题 - (NSString )tableView:(UITableView )tableView titleForHeaderInSection:(NSInteger)section; 返回每个分区的尾部标题 - (NSString )tableView:(UITableView )tableView titleForFooterInSection:(NSInteger)section; 设置某行是否可编辑 - (BOOL)tableView:(UITableView )tableView canEditRowAtIndexPath:(NSIndexPath )indexPath; 设置某行是否可以被移动 - (BOOL)tableView:(UITableView )tableView canMoveRowAtIndexPath:(NSIndexPath )indexPath; 设置索引栏标题数组（实现这个方法，会在tableView右边显示每个分区的索引） - (NSArray )sectionIndexTitlesForTableView:(UITableView )tableView; 设置索引栏标题对应的分区 - (NSInteger)tableView:(UITableView )tableView sectionForSectionIndexTitle:(NSString )title atIndex:(NSInteger)index tableView接受编辑时调用的方法 - (void)tableView:(UITableView )tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath )indexPath; 这个方法中的editingStyle参数是一个枚举，代表了cell被编辑的模式，如下： 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone,//没有编辑操作 UITableViewCellEditingStyleDelete,//删除操作 UITableViewCellEditingStyleInsert//插入操作&#125;; tableView的cell被移动时调用的方法 - (void)tableView:(UITableView )tableView moveRowAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath; 三、UITableViewDelegate（tableView代理）cell将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath *)indexPath; 头视图将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayHeaderView:(UIView )view forSection:(NSInteger)section; 尾视图将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayFooterView:(UIView )view forSection:(NSInteger)section; 和上面的方法对应，这三个方法分别是cell，头视图，尾视图已经显示时调用的方法 - (void)tableView:(UITableView )tableView didEndDisplayingCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath*)indexPath; - (void)tableView:(UITableView )tableView didEndDisplayingHeaderView:(UIView )view forSection:(NSInteger)section; - (void)tableView:(UITableView )tableView didEndDisplayingFooterView:(UIView )view forSection:(NSInteger)section; 设置行高，头视图高度和尾视图高度的方法 - (CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath; - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section; 设置行高，头视图高度和尾视图高度的估计值(对于高度可变的情况下，提高效率) - (CGFloat)tableView:(UITableView )tableView estimatedHeightForRowAtIndexPath:(NSIndexPath )indexPath; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section; 设置自定义头视图和尾视图 - (UIView )tableView:(UITableView )tableView viewForHeaderInSection:(NSInteger)section; - (UIView )tableView:(UITableView )tableView viewForFooterInSection:(NSInteger)section; 设置cell是否可以高亮 - (BOOL)tableView:(UITableView )tableView shouldHighlightRowAtIndexPath:(NSIndexPath )indexPath; cell高亮和取消高亮时分别调用的函数 - (void)tableView:(UITableView )tableView didHighlightRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView )tableView didUnhighlightRowAtIndexPath:(NSIndexPath )indexPath; 当即将选中某行和取消选中某行时调用的函数，返回一直位置，执行选中或者取消选中 - (NSIndexPath )tableView:(UITableView )tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath; - (NSIndexPath )tableView:(UITableView )tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath; 已经选中和已经取消选中后调用的函数 - (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView )tableView didDeselectRowAtIndexPath:(NSIndexPath )indexPath; 设置tableView被编辑时的状态风格，如果不设置，默认都是删除风格 - (UITableViewCellEditingStyle)tableView:(UITableView )tableView editingStyleForRowAtIndexPath:(NSIndexPath )indexPath; 自定义删除按钮的标题 - (NSString )tableView:(UITableView )tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath; 下面这个方法是IOS8中的新方法，用于自定义创建tableView被编辑时右边的按钮，按钮类型为UITableViewRowAction。 - (NSArray )tableView:(UITableView )tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath ; 设置编辑时背景是否缩进 - (BOOL)tableView:(UITableView )tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath )indexPath; 将要编辑和结束编辑时调用的方法 - (void)tableView:(UITableView)tableView willBeginEditingRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView)tableView didEndEditingRowAtIndexPath:(NSIndexPath )indexPath; 移动特定的某行 - (NSIndexPath )tableView:(UITableView )tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath )sourceIndexPath toProposedIndexPath:(NSIndexPath )proposedDestinationIndexPath; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITableView","slug":"UITableView","permalink":"http://huishao.cc/tags/UITableView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS8的新特性：简洁易用的毛玻璃效果","slug":"30iOS8的新特性：简洁易用的毛玻璃效果","date":"2015-04-21T16:00:00.000Z","updated":"2023-04-14T11:50:08.365Z","comments":true,"path":"2015/04/22/30iOS8的新特性：简洁易用的毛玻璃效果/","link":"","permalink":"http://huishao.cc/2015/04/22/30iOS8的新特性：简洁易用的毛玻璃效果/","excerpt":"","text":"探寻iOS8的新亮点：毛玻璃效果的简易实现IOS8之前，apple官方并不建议开发者使用类似毛玻璃的模糊效果，也并没有开放相关的接口，大部分的开发者是通过转化CGImage这个类来实现毛玻璃的模糊效果，并且实现的效果也很优秀。在IOS8之后，苹果官方新出了一个类UIVisualEffectView，通过这个类，实现毛玻璃效果变得轻而易举，而且效率非常之高，下面，我们来介绍下这个类的简单用法。 一、了解几个类1、UIVisualEffectView 这个类为我们提供了一个方便的接口，用来展示复杂的图像效果。 2、UIVisualEffect 官方对这个类的解释相当简单，它没有任何方法，只是充当一个帮助UIVisualEffectView创建的对象，是UIBlurEffect和UIVibrancyEffect的父类，或者可以理解，它的功能相当于一个抽象类。 3、UIBlurEffect 这个类是创建模糊效果，也就是毛玻璃效果的类，可以设置风格。 4、UIVibrancyEffect 从这个类的名字就可以看出，这个类是UIBlurEffect的扩展，可以创建出明亮的标签的按钮。 二、开始创建虚化的背景首先，初始化一个UIVisualEffectView对象： - (instancetype)initWithEffect:(UIVisualEffect *)effect; 这个方法里面的参数是UIVisuaEffect对象，我们先用UIBlueEffect的方式来创建： + (UIBlurEffect *)effectWithStyle:(UIBlurEffectStyle)style; 这个方法可以设置一个风格参数，风格枚举如下： 12345typedef NS_ENUM(NSInteger, UIBlurEffectStyle) &#123; UIBlurEffectStyleExtraLight,//高亮的风格 UIBlurEffectStyleLight,//亮化的风格 UIBlurEffectStyleDark//暗化的风格&#125; ; 这些都做好之后，我们需要给这个UIVisualEfffectView对象一个frame，然后直接加到我们想要虚化的背景上，总体代码如下： 123456789 UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleExtraLight]]; //设置虚化度 effectView.alpha=1.0; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 三、UIVisualEffectView的几个属性@property (nonatomic, retain, readonly) UIView *contentView; 这个参数和我们后面将要说的创建明亮的标签和按钮有关，这里先不多介绍。 @property (nonatomic, copy, readonly) UIVisualEffect *effect; 获得UIVissualEffect对象 @property(nonatomic) CGFloat alpha; 这个参数和虚化的程度有关 四、在虚化的背景上创建颜色绚丽的标签我们先来看一个效果，我们在刚才创建的虚化的背景上添加一个标签，代码如下： 12345678910111213UILabel * view2 = [[UILabel alloc]init]; view2.text=@&quot;注意看字体的颜色!&quot;; view2.font=[UIFont boldSystemFontOfSize:32]; view2.frame=CGRectMake(0, 0,300, 100); UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleExtraLight]]; [effectView addSubview:view2]; effectView.alpha=0.8; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 我们换另一种虚化效果来对背景进行虚化： 12345678910111213UILabel * view2 = [[UILabel alloc]init]; view2.text=@&quot;注意看字体的颜色!&quot;; view2.font=[UIFont boldSystemFontOfSize:32]; view2.frame=CGRectMake(0, 0,300, 100); UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIVibrancyEffect effectForBlurEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]]]; [effectView.contentView addSubview:view2]; effectView.alpha=0.8; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 现在可以很明白的了解，UIBlurEffect是对整个背景进行虚化，UIVibrancyEffect是对添加的标签等附件进行背景虚化。注意，这些附件，必须加在UIVisualEffectView的contentView里，否则将不起任何作用。 五、一个小控件通过上面的介绍，我们可以发现，在IOS8中创建一个毛玻璃效果是如此的容易，apple官方提供的类也是如此的强大，我们很轻松就可以实现实时变化虚化程度的动画效果，这在以前是非常麻烦和低效的。但是apple还有一个忠告：莫要泛滥的使用虚化，导致很差的用户体验! 最后，和大家分享一个前两天写的小控件，实现的效果是仿IOS8中在桌面下拉会是背景渐变虚化，从顶部会滑出搜索框。如下：可以当做一个demo来参考。 链接地址：http://d.cocoachina.com/code/detail/297393。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS使用Xcode可视化图像编辑功能进行图片拉伸","slug":"27iOS使用xcode可视化图像编辑功能进行图片拉伸","date":"2015-04-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.357Z","comments":true,"path":"2015/04/21/27iOS使用xcode可视化图像编辑功能进行图片拉伸/","link":"","permalink":"http://huishao.cc/2015/04/21/27iOS使用xcode可视化图像编辑功能进行图片拉伸/","excerpt":"","text":"iOS中可视化拉伸图片技巧一、补充在我的另一篇博客http://my.oschina.net/u/2340880/blog/403996中探讨了IOS拉伸图像(UIImage)的几种方法和一些小经验，这篇是一个补充，再将xcode中的另一种可视化拉伸图像的方法的使用介绍给大家。 二、如何使用IOS开发文档中的描述：https://developer.apple.com/library/ios/recipes/xcode_help-image_catalog-1.0/chapters/SlicinganImage.html 1、xcode5的新特性xcode5之后，IOS为我们提供了一个管理图片的新方法Asset Catalogs，简单说来，它相当于一个目录，专门用来管理我们项目中的图片素材，包括Icon和启动页，这样使项目管理更加方便也更加简洁。 创建一个AssetCatalogs：在xcode中新建一个文件，选择AssetCatalogs，如下： 然后我们点开这个包，将图片直接拖入工具区即可： 2、使用AssetCatalogs中的可视化工具进行图片拉伸完成了上面的步骤之后，我们可以对管理的图片进行处理，点击右下角的show Slicing按钮，我们就会进入可视化编辑区，如下： 如上图，有三条竖直线，其中边界的两条分别约束了图片两侧不被拉伸的区域范围，中间虚线和左侧虚线围成的部分，将是被复制拉伸的区域。水平方向的线同理。 很重要的一点：官方文档告诉我们，这个方法只能在iOS 7 或者 OS X v10.10之后使用。效果如下： 3、在xib文件中UIImage的拉伸在xib文件中的UIImageView，在上面加上图片后，可以设置stretching这个属性： 这个属性的四个值：X,Y,Width,Height的取值范围是0-1；X，Y，用来确定一个点，比如我们设置为X=0.1，Y=0.1，则这个点就是图片的左上角开始，水平1/10处和竖直1/10处，设置图片的拉伸点为从这个点开始。后两个参数分别设置图片拉伸区域的宽度和高度，比如我们这样设置：Width=0.8，Height=0.8，则图片拉伸时上下左右各1/10的宽度不会被拉伸，中间部分被拉伸，还是刚才的图片，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中表视图(UITableView)使用详解","slug":"28iOS中表视图(UITableView)使用详解","date":"2015-04-20T16:00:00.000Z","updated":"2023-04-14T11:50:08.360Z","comments":true,"path":"2015/04/21/28iOS中表视图(UITableView)使用详解/","link":"","permalink":"http://huishao.cc/2015/04/21/28iOS中表视图(UITableView)使用详解/","excerpt":"","text":"iOS中UITableView使用总结一、初始化方法- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style; 这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下： 1234typedef NS_ENUM(NSInteger, UITableViewStyle) &#123; UITableViewStylePlain, // 标准的表视图风格 UITableViewStyleGrouped // 分组的表视图风格&#125;; 二、常用属性获取表视图的风格(只读属性) @property (nonatomic, readonly) UITableViewStyle style; 设置表示图代理和数据源代理(代理方法后面讨论) @property (nonatomic, assign) id &lt;UITableViewDataSource> dataSource; @property (nonatomic, assign) id &lt;UITableViewDelegate> delegate; 设置表示图的行高(默认为44) @property (nonatomic)CGFloat rowHeight; 设置分区的头视图高度和尾视图高度(当代理方法没有实现时才有效) @property (nonatomic) CGFloat sectionHeaderHeight; @property (nonatomic) CGFloat sectionFooterHeight; 设置一个行高的估计值(默认为0，表示没有估计,7.0之后可用) @property (nonatomic) CGFloat estimatedRowHeight; 注意：这个属性官方的解释是如果你的tableView的行高是可变的，那么设计一个估计高度可以加快代码的运行效率。 下面这两个属性和上面相似，分别设置分区头视图和尾视图的估计高度(7.0之后可用) @property (nonatomic) CGFloat estimatedSectionHeaderHeight; @property (nonatomic) CGFloat estimatedSectionFooterHeight; 设置分割线的位置 @property (nonatomic) UIEdgeInsets separatorInset; 如果细心，你可能会发现系统默认的tableView的分割线左端并没有顶到边沿。通过这个属性，可以手动设置分割线的位置偏移，比如你向让tableView的分割线只显示右半边，可以如下设置： 12UITableView * tab = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain];tab.separatorInset=UIEdgeInsetsMake(0, tab.frame.size.width/2, 0,0); 设置tableView背景view视图 @property(nonatomic, readwrite, retain) UIView *backgroundView; 三、常用方法详解重载tableView - (void)reloadData; 重载索引栏 - (void)reloadSectionIndexTitles; 这个方法常用语新加或者删除了索引类别而无需刷新整个表视图的情况下。 获取分区数 - (NSInteger)numberOfSections; 根据分区获取行数 - (NSInteger)numberOfRowsInSection:(NSInteger)section; 获取分区的大小(包括头视图，所有行和尾视图) - (CGRect)rectForSection:(NSInteger)section; 根据分区分别获取头视图，尾视图和行的高度 - (CGRect)rectForHeaderInSection:(NSInteger)section; - (CGRect)rectForFooterInSection:(NSInteger)section; - (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath; 获取某个点在tableView中的位置信息 - (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point; 获取某个cell在tableView中的位置信息 - (NSIndexPath )indexPathForCell:(UITableViewCell )cell; 根据一个矩形范围返回一个信息数组，数组中是每一行row的位置信息 - (NSArray *)indexPathsForRowsInRect:(CGRect)rect; 通过位置路径获取cell - (UITableViewCell )cellForRowAtIndexPath:(NSIndexPath )indexPath; 获取所有可见的cell - (NSArray *)visibleCells; 获取所有可见行的位置信息 - (NSArray *)indexPathsForVisibleRows; 根据分区获取头视图 - (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section; 根据分区获取尾视图 - (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section; 使表示图定位到某一位置(行) - (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated; 注意：indexPah参数是定位的位置，决定于分区和行号。animated参数决定是否有动画。scrollPosition参数决定定位的相对位置，它使一个枚举，如下： 123456typedef NS_ENUM(NSInteger, UITableViewScrollPosition) &#123; UITableViewScrollPositionNone,//同UITableViewScrollPositionTop UITableViewScrollPositionTop,//定位完成后，将定位的行显示在tableView的顶部 UITableViewScrollPositionMiddle,//定位完成后，将定位的行显示在tableView的中间 UITableViewScrollPositionBottom//定位完成后，将定位的行显示在tableView最下面&#125;; 使表示图定位到选中行 - (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated; 这个函数与上面的非常相似，只是它是将表示图定位到选中的行。 四、tableView操作刷新块的应用在介绍动画块之前，我们先看几个函数： 插入分区 - (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; animation参数是一个枚举，枚举的动画类型如下 12345678910typedef NS_ENUM(NSInteger, UITableViewRowAnimation) &#123; UITableViewRowAnimationFade,//淡入淡出 UITableViewRowAnimationRight,//从右滑入 UITableViewRowAnimationLeft,//从左滑入 UITableViewRowAnimationTop,//从上滑入 UITableViewRowAnimationBottom,//从下滑入 UITableViewRowAnimationNone, //没有动画 UITableViewRowAnimationMiddle, UITableViewRowAnimationAutomatic = 100 // 自动选择合适的动画&#125;; 删除分区 - (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; 重载一个分区 - (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation ; 移动一个分区 - (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection; 插入一些行 - (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 删除一些行 - (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 重载一些行 - (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 移动某行 - (void)moveRowAtIndexPath:(NSIndexPath )indexPath toIndexPath:(NSIndexPath )newIndexPath; 了解了上面几个函数，我们来看什么是操作刷新块： 当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，而然数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。 IOS为我们提供了下面两个函数解决这个问题： 开始块标志 - (void)beginUpdates; 结束快标志 - (void)endUpdates; 我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下： 1234[tab beginUpdates]; [tab deleteRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:1 inSection:0]] withRowAnimation:UITableViewRowAnimationLeft]; [dataArray removeObjectAtIndex:1]; [tab endUpdates]; 注意：不要在这个块中调用reloadData这个方法，它会使动画失效。 五、tableView的编辑操作设置是否是编辑状态(编辑状态下的cell左边会出现一个减号，点击右边会划出删除按钮) @property (nonatomic, getter=isEditing) BOOL editing; - (void)setEditing:(BOOL)editing animated:(BOOL)animated; 设置cell是否可以被选中(默认为YES) @property (nonatomic) BOOL allowsSelection; 设置cell编辑模式下是否可以被选中 @property (nonatomic) BOOL allowsSelectionDuringEditing; 设置是否支持多选 @property (nonatomic) BOOL allowsMultipleSelection; 设置编辑模式下是否支持多选 @property (nonatomic) BOOL allowsMultipleSelectionDuringEditing; 六、选中cell的相关操作获取选中cell的位置信息 - (NSIndexPath *)indexPathForSelectedRow; 获取多选cell的位置信息 - (NSArray *)indexPathsForSelectedRows; 代码手动选中与取消选中某行 - (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition; - (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated; 注意：这两个方法将不会回调代理中的方法。 七、tableView附件的相关方法设置索引栏最小显示行数 @property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount; 设置索引栏字体颜色 @property (nonatomic, retain) UIColor *sectionIndexColor; 设置索引栏背景颜色 @property (nonatomic, retain) UIColor *sectionIndexBackgroundColor; 设置索引栏被选中时的颜色 @property (nonatomic, retain) UIColor *sectionIndexTrackingBackgroundColor; 设置分割线的风格 @property (nonatomic) UITableViewCellSeparatorStyle separatorStyle; 这个风格是一个枚举，如下： 12345typedef NS_ENUM(NSInteger, UITableViewCellSeparatorStyle) &#123; UITableViewCellSeparatorStyleNone,//无线 UITableViewCellSeparatorStyleSingleLine,//有线 UITableViewCellSeparatorStyleSingleLineEtched &#125;; 设置分割线颜色 @property (nonatomic, retain) UIColor *separatorColor; 设置分割线毛玻璃效果(IOS8之后可用) @property (nonatomic, copy) UIVisualEffect *separatorEffect; 注意：这个属性是IOS8之后新的。 设置tableView头视图 @property (nonatomic, retain) UIView *tableHeaderView; 设置tableView尾视图 @property (nonatomic, retain) UIView *tableFooterView; 从复用池中取cell - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier; 获取一个已注册的cell - (id)dequeueReusableCellWithIdentifier:(NSString )identifier forIndexPath:(NSIndexPath )indexPath 从复用池获取头视图或尾视图 - (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier; 通过xib文件注册cell - (void)registerNib:(UINib )nib forCellReuseIdentifier:(NSString )identifier; 通过OC类注册cell - (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier 上面两个方法是IOS6之后的方法。 通过xib文件和OC类获取注册头视图和尾视图 - (void)registerNib:(UINib )nib forHeaderFooterViewReuseIdentifier:(NSString )identifier; - (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *) 关于tableView的代理方法，因为篇幅原因，总结在下一篇博客中。 错误之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中图片(UIImage)拉伸技巧","slug":"26iOS中图片(UIImage)拉伸技巧","date":"2015-04-19T16:00:00.000Z","updated":"2023-04-14T11:50:08.354Z","comments":true,"path":"2015/04/20/26iOS中图片(UIImage)拉伸技巧/","link":"","permalink":"http://huishao.cc/2015/04/20/26iOS中图片(UIImage)拉伸技巧/","excerpt":"","text":"iOS中图片拉伸技巧与方法总结一、了解几个图像拉伸的函数和方法1、直接拉伸法简单暴力，却是最最常用的方法，直接将图片设置为ImageView的image属性，图片便会随UIImageView对象的大小做自动拉伸。这种拉伸的方法有一个致命的缺陷，它会使图像发生失真与形变。 2、像素点的拉伸- (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight; 这个函数我们可以用来拉伸类似QQ，微信的聊天气泡背景图，它的两个参数分别leftCapWidth和topCapHeight，这两个参数给定一个坐标，比如： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img stretchableImageWithLeftCapWidth:1 topCapHeight:1]; 这段代码的意思是将图片从左起第2列，上起第2行，坐标为(2,2)的像素点进行复制。将图片进行拉伸。这个方法和上面的方法比起来似乎灵活性更多了，但其也有它的一些局限，如果被拉伸的图片中间也有需要拉伸的像素，这个方法就无能为力了，例如，如下的一张图片，我们需要将其拉伸放大： 便会出现这样的效果： 这明显和我们的意图是不符的，那么，我们可以使用下面的方法。 3、区域的拉伸- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; 这个函数需要设置一个UIEdgeInsets参数，UIEdgeInsets结构体如下： 123typedef struct UIEdgeInsets &#123; CGFloat top, left, bottom, right; &#125; UIEdgeInsets; 它分别对用了图片进行拉伸的区域距离顶部、左部、下部、右部的像素。比如，一个10*10像素的图片，将UIEdgeInsets参数全部设置为1，则实际拉伸的部分就是中间的8*8的区域的像素。有一点需要注意，这个方法默认使用的拉伸模式是区域复制，比如还是上面的图案，如下代码拉伸： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(1, 1, 1, 1)]; 结果如下： 可以明显的看到中间的虚线，这便是区域复制的杰作。 那么问题又来了，如果某些图片中间有渐变，我们该怎么处理了，来看下一个函数。 4、拉伸模式的设置- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode; 这个函数和上一个函数相比，唯一的差别是多了一个参数。这个参数是个枚举，如下： 1234typedef NS_ENUM(NSInteger, UIImageResizingMode) &#123; UIImageResizingModeTile,//进行区域复制模式拉伸 UIImageResizingModeStretch,//进行渐变复制模式拉伸&#125;; 现在就明了了，我们只需要设置一下模式，就可以实现渐变拉伸了： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(1, 1, 1, 1) resizingMode:UIImageResizingModeStretch]; 来看一下效果： 二、拉伸的用武之地圆角按钮，空心按钮，渐变的背景，内容可变的标签，聊天气泡等等这样的素材在APP中很可能会多次出现，并且每次出现的尺寸可能还会略微有些差异，如果仅仅依靠美工的素材，恐怕不仅很难达到要求，也会额外增加软件的内存开销，这时，我们使用恰当的拉伸技巧，能使我们的代码更加健壮，APP更加高效。 三、一点小经验你是否注意观察过最细的线？ 看到上面的问句，你可能有些差异。最细的线不就是一像素么？确实，能绘图画出来的最细的实心线确实是一像素，但在一个项目中，我们优秀的美工察觉到无论她把线做的多么细，无论我怎样控制拉伸方法，绘制出的登录框总是没有QQ的细，QQ的框线看起来更加干脆利索。后来索性用绘图画出登录框，结果很不幸，我依然无法将线做到像QQ登录框那样细致。后来偶然试了一种方法，不知原理是否正确，效果总算达到了，当然这也要归功于我们的美工，她将一个图片做的很大，适配最大的分辨率，然后让我手动缩，如此一来，那线就变得非常细。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIImage","slug":"UIImage","permalink":"http://huishao.cc/tags/UIImage/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"分分钟使用正则表达式","slug":"24分分钟使用正则表达式","date":"2015-04-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.350Z","comments":true,"path":"2015/04/19/24分分钟使用正则表达式/","link":"","permalink":"http://huishao.cc/2015/04/19/24分分钟使用正则表达式/","excerpt":"","text":"正则表达式简单语法总结一、什么是正则表达式从概念上来说，正则表达式也是一门小巧而精炼的语言，它可以用来简化检索特定的字符串，替换特定字符等功能，有许多开发语言工具，都内嵌支持正则表达式。那么一个正则表达式，究竟是什么？其实它就是一个字符串，但这个字符串具有特定含义。 二、正则表达式的基础语法1、字面值所谓字面值，就是没有任何转义，查找的对象就是其本身，比如正则表达式 abc ，查找的结果就是返回要查找字符串中 a，b，c三个字母连在一起的字符串。又如，123 就是查找到123这个子串。 2、特殊字符（元字符）（1）句号“.”在正则表达式中表示匹配任意字符，很相似于通配符*。如果我们查找a.b这个正则表达式，我们可以找到所有开头和结尾为a，b，中间是任意字符的字符串，比如abc，adc，a2c等。 （2）字符类（[]）如果你在一个正则表达式中看到有一些字符被[]括号括起来，那么他们的含义将不再是简单的字面值，他们表示某一个被括号中属性约束的字符。比如[123456]，这个正则表达式表示找到1-6中的任意一个字符，又比如a[bd]c，这表示查找abc或者adc。 注意： 1.在字符类中字符的顺序和重复性都不是我们关心的。\\[123\\]和\\[2233111\\]，含义是一模一样的。 2.句号在字符类中表示的就是其本身，\\[.\\]就是查找一个句号。 （3）区间符号（-）如果我们需要查找一个数字，[0123456789]，这样做是可以达到目的的，但这写起非常麻烦，并不符合正则表达式小巧的特性，这时我们可以使用区间符号来简化，[0-9]和上面的式子意义完全一样。同样，我们可以[a-zA-Z]，表示任意一个字母。 注意： 1.区间的范围应该有意义，\\[a-1\\]这样的区间并无任何意义，尽管它在语法上可能没有错误。 2.区间左右两端对应的是字符，并不是数字，比如\\[2-41\\]，这个式子的含义是找到2-4的一个数字或者1，和\\[1-4\\]是一样的。 （4）取反符号（^）“^”在正则表达式中表示取反，这个很好理解，[^a]，表示找到除了a之外的任意字符。[^0-9]，表示找到一个非数字的字符。 注意： 1.^必须在中括号内，及字符类属性中使用。 2.^是将后面的整体作为取反条件的。 （5）简化的字符类某些符号具有和字符类相同的含义： \\d和[0-9]相同 \\w和[0-9A-Za-z_]相同 表示数字，字母或者下划线 \\s表示匹配空格，tab和换行等不可见符。 与此相对的\\D,\\W,\\S，则表示上述条件的取反情况。 （6）乘法集（{}）乘法集的最大用处也是简化正则表达式，用大括号表示。比如，a{2}，表示找到aa这个字符串。 注意： 乘法集是已前面整体为乘法条件的，比如\\[ab\\]{2}，不是简单的比配aa，bb，而是和\\[ab\\]\\[ab\\]含义是相同的，会匹配ab，ba，aa，bb。 （7）乘法集中的区间（,）乘法集和字符类相同，也可以用区间进行简化，但是符号不相同。a{1,3}，表示找到a，aa，aaa这三个字符串。a{0,1}是合法的，表示找到空字符，或者a。 注意： 1.乘法集的&quot;越长越好&quot;属性：乘法集具有这样的特点，比如a{2,4}，如果我搜索myaaaa，它不会找到aa后就停止，而是会找到aaaa。 2.乘法集的&quot;全部获取&quot;属性：比如a{2.4}，如果搜索myaayouaaaa，它会找到aa和aaaa。 3.乘法集支持开区间，a{1,}是合法的，表示找到任何a相连的字符串。 （8）判断符号（？）这个符号的含义和{0,1}完全相同，123?4，表示匹配1234或者124； （9）统配符号（*）这个符号的含义和{0,}相同，比如.* 表示通配一切字符串。 （10）+符号这个符号和{1,}相同。 （11）或符号（|）“|”符号表示或的关系，比如abc|edf，表示找到abc或者def （12）组合（()）小括号在正则表达式中表示组合，比如(a|b|c)d，表示找到ad，bd，cd，可以将小括号的作用理解为优先级。 （13）单词边界（\\b）\\b表示单词的边界，比如\\b[a-z]{3}\\b，表示匹配一个三个字母的小写单词。 （14）行边界（^ $）单单的一个^符号表示的是行的开头，$表示行的结束。 注意： \\[^\\]是非法的，\\[$\\]表示匹配一个$符号。 三、做些小总结上面说了这么多正则表达式的语法规则，我们现在来做下总结： 1、几个概念：1、字面值:直接查找的字符，比如123，avb。 2、字符类：描述字符的一些属性，比如[123],[a-z],\\d,\\w,\\s,.。 3、乘法集：简化表达式，比如{0,3},?,+,*。 4、或和组合：比如(a|b|v)。 5、单词，行的边界\\b ^ $ 2、元字符列表. \\ [ ] { } ? * + | ( ) ^ $ 3、字符类中元字符列表[ ] \\ - ^ 四、一个特别重要的字符最后，还有一个特别特别重要的字符我们没考虑到，如果我们要查找元字符怎么办，在正则表达式中还有一个转义字符”\\“，如果我们要查找. 只要查找\\. 同理\\[\\]是查找”[]“这个字符串。如果要查找”\\“，再加一个转义字符就好:\\\\。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://huishao.cc/categories/正则表达式/"}],"tags":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/tags/编程珠玑/"}],"keywords":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://huishao.cc/categories/正则表达式/"}]},{"title":"iOS中正则表达式的使用","slug":"25iOS中正则表达式的使用","date":"2015-04-18T16:00:00.000Z","updated":"2023-04-14T11:50:08.352Z","comments":true,"path":"2015/04/19/25iOS中正则表达式的使用/","link":"","permalink":"http://huishao.cc/2015/04/19/25iOS中正则表达式的使用/","excerpt":"","text":"正则表达式在iOS开发中的应用正则表达式在字符串查找，替换，检测中的应用非常广泛，正则表达式是什么，有怎样的语法，我的另一篇博客中有详细的介绍：http://my.oschina.net/u/2340880/blog/403508。这里只简单说一下其概念 ，正则表达式是一种语法小巧简单的语言，用来约束一些过滤字符串条的条件。很多开发工具都有支持正则表达式的内容，IOS也不例外，在IOS中NSRegularExpression类就是一个专门来处理正则表达式的类。 一、初始化方法初始化NSRegularExpression的方法有两种，一个init方法和一个类方法。其作用基本是一样的 + (NSRegularExpression )regularExpressionWithPattern:(NSString )pattern options:(NSRegularExpressionOptions)options error:(NSError **)error; - (instancetype)initWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error 其中，pattern是正则表达式，options是参数。对于option参数，它是一个枚举，表示正则模式的设置，如下： 123456789typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) &#123; NSRegularExpressionCaseInsensitive = 1 &lt;&lt; 0, //不区分字母大小写的模式 NSRegularExpressionAllowCommentsAndWhitespace = 1 &lt;&lt; 1, //忽略掉正则表达式中的空格和#号之后的字符 NSRegularExpressionIgnoreMetacharacters = 1 &lt;&lt; 2, //将正则表达式整体作为字符串处理 NSRegularExpressionDotMatchesLineSeparators = 1 &lt;&lt; 3, //允许.匹配任何字符，包括换行符 NSRegularExpressionAnchorsMatchLines = 1 &lt;&lt; 4, //允许^和$符号匹配行的开头和结尾 NSRegularExpressionUseUnixLineSeparators = 1 &lt;&lt; 5, //设置\\n为唯一的行分隔符，否则所有的都有效。 NSRegularExpressionUseUnicodeWordBoundaries = 1 &lt;&lt; 6 //使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效&#125;; 注意：1、NSRegularExpressionCaseInsensitive模式下正则表达式 aBc 会匹配到abc. 2、NSRegularExpressionIgnoreMetacharacters模式下正则表达式a b c 会匹配到abc，正则表达式ab#c会匹配到ab。 3、NSRegularExpressionAllowCommentsAndWhitespace模式下正则表达式\\[a-z\\]，会匹配到\\[a-z\\]。 二、获取查询结果初始化完毕正则表达式的处理类后，我们需要进行正则表达式的查询，IOS官方提供了两种模式： 1、带block模式的方法：- (void)enumerateMatchesInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range usingBlock:(void (^)(NSTextCheckingResult \\result, NSMatchingFlags flags, BOOL *stop))block; 使用举例： 1234NSRegularExpression * regex = [[NSRegularExpression alloc]initWithPattern:@&quot;[a-z]&quot; options:NSRegularExpressionCaseInsensitive error:nil]; [regex enumerateMatchesInString:@&quot;124a&quot; options:NSMatchingReportProgress range:NSMakeRange(0, 4) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) &#123; NSLog(@&quot;%@&quot;,result); &#125; ]; 注意：1、这个函数的一个参数options是一个枚举，设置回调的方式，如下： 1234567typedef NS_OPTIONS(NSUInteger, NSMatchingOptions) &#123; NSMatchingReportProgress = 1 &lt;&lt; 0, //找到最长的匹配字符串后调用block回调 NSMatchingReportCompletion = 1 &lt;&lt; 1, //找到任何一个匹配串后都回调一次block NSMatchingAnchored = 1 &lt;&lt; 2, //从匹配范围的开始出进行极限匹配 NSMatchingWithTransparentBounds = 1 &lt;&lt; 3, //允许匹配的范围超出设置的范围 NSMatchingWithoutAnchoringBounds = 1 &lt;&lt; 4 //禁止^和$自动匹配行还是和结束&#125;; 2、block回调中的flags枚举对应如下： 1234567typedef NS_OPTIONS(NSUInteger, NSMatchingFlags) &#123; NSMatchingProgress = 1 &lt;&lt; 0, //匹配到最长串是被设置 NSMatchingCompleted = 1 &lt;&lt; 1, //全部分配完成后被设置 NSMatchingHitEnd = 1 &lt;&lt; 2, //匹配到设置范围的末尾时被设置 NSMatchingRequiredEnd = 1 &lt;&lt; 3, //当前匹配到的字符串在匹配范围的末尾时被设置 NSMatchingInternalError = 1 &lt;&lt; 4 //由于错误导致的匹配失败时被设置 &#125;; 3、还有一点需要注意，就是那个bool值stop，我们可以在block块中设置它为YES，之后便会停止查找。 2、非block的方法这个方法会返回一个结果数组，将所有匹配的结果返回 - (NSArray )matchesInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法会返回匹配到得字符串的个数 - (NSUInteger)numberOfMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法会返回第一个查询到得结果，这个NSTextCheckingResult对象中有一个range属性，可以得到匹配到的字符串的范围。 - (NSTextCheckingResult )firstMatchInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法直接返回匹配到得范围，NSRange。 - (NSRange)rangeOfFirstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range; 三、一个辅助方法在NSRegularExpression类中还提供了一个辅助方法： + (NSString )escapedPatternForString:(NSString )string; 它可以帮助我们将正则表达式加上”\\“进行保护，将元字符转化成字面值。 到此，在IOS中正则表达式的基本用法就介绍完了，希望正则表达式的应用，能为你的项目节省更多时间。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS 单例设计模式解读","slug":"22iOS 单例设计模式解读","date":"2015-04-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.346Z","comments":true,"path":"2015/04/17/22iOS 单例设计模式解读/","link":"","permalink":"http://huishao.cc/2015/04/17/22iOS 单例设计模式解读/","excerpt":"","text":"iOS 中单例设计模式的解读与用法一、单例的作用顾名思义，单例，即是在整个项目中，这个类的对象只能被初始化一次。它的这种特性，可以广泛应用于某些需要全局共享的资源中，比如管理类，引擎类，也可以通过单例来实现传值。UIApplication、NSUserDefaults等都是IOS中的系统单例。 二、单例的写法单例的写法常用的有两种方式： 方式1、不考虑线程12345678static SingleCase *manager = nil; + (SingleCase *)defaultManager &#123; if (!manager)&#123; SingleCase = [[self alloc] init]; return manager; &#125;&#125; 方式2、考虑线程安全123456789+ (SingleCase *)sharedManager &#123; static SingleCase *ManagerInstance = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; ManagerInstance = [[self alloc] init]; &#125;); return ManagerInstance; &#125; 三、代码的优化通过上面的方法，我们已经可以使用类方法来得到这个单例，但很多时候，项目的工程量很大，还有可能会很多开发者同时参与一个项目的开发，为了安全与管理代码的方便，也为了给不是这个单例的创作者但会用到这个单例的开发人员一些提示，我们通常会重写一些方法： 首先我们自己实现一个alloc方法： 123+(instancetype)myAlloc&#123; return [super allocWithZone:nil];&#125; 将我们的单例实现方法略作修改： 1234567+(ZYHPayManager *)sharedMamager&#123; static ZYHPayManager * manager; if (manager==nil) &#123; manager=[[ZYHPayManager myAlloc]init]; &#125; return manager;&#125; 将一些视图实例化对象的方法重写： 1234567891011121314+(instancetype)alloc&#123; NSAssert(0, @&quot;这是一个单例对象，请使用+(ZYHPayManager *)sharedMamager方法&quot;); return nil;&#125;+(instancetype)allocWithZone:(struct _NSZone *)zone&#123; return [self alloc];&#125;-(id)copy&#123; NSLog(@&quot;这是一个单例对象，copy将不起任何作用&quot;); return self;&#125;+(instancetype)new&#123; return [self alloc];&#125; 注意：这里的alloc使用了断言，让任何视图通过alloc创建对象的程序段断在此处，给程序员提示。copy方法这里只是简单的返回了原对象，并未做任何处理，打印信息给程序员提示。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://huishao.cc/categories/设计模式/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://huishao.cc/categories/设计模式/"}]},{"title":"iOS description与debugDescription在调试程序中的应用","slug":"23iOS description与debugDescription在调试程序中的应用","date":"2015-04-16T16:00:00.000Z","updated":"2023-04-14T11:50:08.348Z","comments":true,"path":"2015/04/17/23iOS description与debugDescription在调试程序中的应用/","link":"","permalink":"http://huishao.cc/2015/04/17/23iOS description与debugDescription在调试程序中的应用/","excerpt":"","text":"iOS 中打印函数description与debugDescription的应用一、description和debugDescription是什么description和debugDescription是NSObject协议中的声明的两个方法，同时NSObject类也实现了这个方法，如果子类没有重写，则会调用父类的description和debugDescription方法。首先，这两个方法适用于程序代码的调试的，当我们调用打印Log时，会向对象发送一个这样的消息。 我们先来看声明部分的代码： 12+ (NSString *)description;+ (NSString *)debugDescription; 这里返回的字符串就是我们打印在控制台显示的信息。 二、NSObject基类中的description方法是如何实现的我们写如下的测试代码： 12 NSObject * objc = [[NSObject alloc]init]; NSLog(@&quot;objc:%@&quot;,objc); 控制台输出的信息如下： 可以看到，方法的实现大致是这样的： 123-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;&lt;%@:%p&gt;&quot;,[self class],&amp;self];&#125; 三、重写description方法通过上面的介绍，我们大致知道description方法的原理了，在程序调试时，我们可以充分利用这个方法带来的便利，大大缩减我们调试程序所需要的时间。例如：创建一个Test类，给它定义两个属性如下： Text.h 12345#import &lt;Foundation/Foundation.h&gt;@interface TestObject : NSObject@property(nonatomic,strong)NSString * name;@property(nonatomic,strong)NSString * age;@end 我们在.m文件中将description方法重写： 123456#import &quot;TestObject.h&quot;@implementation TestObject-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;%@&quot;,@&#123;@&quot;name&quot;:_name,@&quot;age&quot;:_age&#125;];&#125;@end 重写的方法将Test类对象的属性打印了出来，这时我们在调用NSLog函数时，打印结果如下： 是不是很炫酷，如此一来，我们可以将我们基本不会用到的类名和地址转换成打印数据，极大的方便了我们代码的调试工作。 四、description与debugDescription的区别这两个方法的区别仅仅在于调试的位置不同，调用不同的函数。description是我们在程序中打Log会调用的方法，debugDescription则是我们在断点调试时，在控制台使用po命令打印会调用的方法，比如我们重写Test类的这个方法： 123-(NSString *)debugDescription&#123; return [NSString stringWithFormat:@&quot;&lt;%@:%p&gt;:%@&quot;,[self class],&amp;self,@&#123;@&quot;name&quot;:_name,@&quot;age&quot;:_age&#125;];&#125; 然后我们在程序中加个断点运行，在程序断掉之后，我们在调试区输入：po text，回车之后，会出现如下的信息： 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UIProgressView控件用法","slug":"18iOS UIProgressView控件用法","date":"2015-04-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.336Z","comments":true,"path":"2015/04/16/18iOS UIProgressView控件用法/","link":"","permalink":"http://huishao.cc/2015/04/16/18iOS UIProgressView控件用法/","excerpt":"","text":"进度条控件是IOS开发中一个简单的系统控件，使用总结如下： 初始化一个进度条： (instancetype)initWithProgressViewStyle:(UIProgressViewStyle)style; 注意：1.用这个方式初始化的进度条系统会默认给一个长度。 2.进度条的长度可以通过frame来设置，但是只有前三个参数有效。 3.风格枚举如下： typedef NS_ENUM(NSInteger, UIProgressViewStyle) { UIProgressViewStyleDefault, // 普通样式 UIProgressViewStyleBar, // 用于工具条的样式}; 设置进度条风格样式 @property(nonatomic) UIProgressViewStyle progressViewStyle; 设置进度条进度(0.0-1.0之间，默认为0.0) @property(nonatomic) float progress; 设置已走过进度的进度条颜色 @property(nonatomic, retain) UIColor* progressTintColor; 设置未走过进度的进度条颜色 @property(nonatomic, retain) UIColor* trackTintColor; 设置进度条已走过进度的背景图案和为走过进度的背景图案(IOS7后好像没有效果了) @property(nonatomic, retain) UIImage* progressImage; @property(nonatomic, retain) UIImage* trackImage; 设置进度条进度和是否动画显示(动画显示会平滑过渡) (void)setProgress:(float)progress animated:(BOOL)animated; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIProgressView","slug":"UIProgressView","permalink":"http://huishao.cc/tags/UIProgressView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIPageControl(分页控制器) 用法总结","slug":"19iOS UIPageControl(分页控制器) 用法总结","date":"2015-04-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.338Z","comments":true,"path":"2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","excerpt":"","text":"UIPageControll 是继承于UIControl的一个IOS系统UI控件，可以提供给开发者设计分页效果的功能。 初始化方法 UIPageControl * page = [[UIPageControl alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器页数（默认为0） @property(nonatomic) NSInteger numberOfPages; 设置当前所在页码 @property(nonatomic) NSInteger currentPage; 设置当总页数为1时，是否自动隐藏控制器 @property(nonatomic) BOOL hidesForSinglePage; 设置是否延迟自动更新控制器的当前页码（默认为NO） @property(nonatomic) BOOL defersCurrentPageDisplay; 注意：这个属性如果设置为YES，点击时并不会改变控制器显示的当前页码点，必须手动调用 (void)updateCurrentPageDisplay; 这个方法，才会更新。 更新控制器当前页码 (void)updateCurrentPageDisplay; 通过页数得到控制器大小 (CGSize)sizeForNumberOfPages:(NSInteger)pageCount; 这个属性用于页数会变化的情况下进行大小动态处理 设置控制器页码点得颜色 @property(nonatomic,retain) UIColor *pageIndicatorTintColor; 设置控制器当前所在页码点的颜色 @property(nonatomic,retain) UIColor *currentPageIndicatorTintColor; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIPageControl","slug":"UIPageControl","permalink":"http://huishao.cc/tags/UIPageControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIStepper(步进控件)使用总结","slug":"20iOS UIStepper(步进控件)使用总结","date":"2015-04-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.341Z","comments":true,"path":"2015/04/16/20iOS UIStepper(步进控件)使用总结/","link":"","permalink":"http://huishao.cc/2015/04/16/20iOS UIStepper(步进控件)使用总结/","excerpt":"","text":"iOS中步进控件的简单使用 初始化控件 1UIStepper * step = [[UIStepper alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器值是否连续触发变化 @property(nonatomic,getter=isContinuous) BOOL continuous; 若设置为YES，则长按会连续触发变化，若设置为NO，只有在按击结束后，才会触发。 设置长按是否一直触发变化 @property(nonatomic) BOOL autorepeat; 若设置为YES，则长按值会一直改变，若设置为NO，则一次点击只会改变一次值 设置控制器的值是否循环(到达边界后，重头开始，默认为NO) @property(nonatomic) BOOL wraps; 设置控制器的值 @property(nonatomic) double value; 设置控制器的最大值和最小值 @property(nonatomic) double minimumValue;//默认为0 @property(nonatomic) double maximumValue; //默认为100 设置控制器的步长 @property(nonatomic) double stepValue; 设置控制器风格颜色 @property(nonatomic,retain) UIColor *tintColor; 设置控制器背景图片 - (void)setBackgroundImage:(UIImage*)image forState:(UIControlState)state; 获取背景图片 - (UIImage*)backgroundImageForState:(UIControlState)state; 通过左右按钮的状态设置分割线的图片 - (void)setDividerImage:(UIImage*)image forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; 获取分割线图片 - (UIImage*)dividerImageForLeftSegmentState:(UIControlState)state rightSegmentState:(UIControlState)state; 设置和获取加号按钮的图片 - (void)setIncrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)incrementImageForState:(UIControlState)state; 设置和获取减号按钮的图片 - (void)setDecrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)decrementImageForState:(UIControlState)state; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIStepper","slug":"UIStepper","permalink":"http://huishao.cc/tags/UIStepper/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C 中变量的作用域","slug":"21Objective-C 中变量的作用域","date":"2015-04-15T16:00:00.000Z","updated":"2023-04-14T11:50:08.344Z","comments":true,"path":"2015/04/16/21Objective-C 中变量的作用域/","link":"","permalink":"http://huishao.cc/2015/04/16/21Objective-C 中变量的作用域/","excerpt":"","text":"iOS中，修饰变量的关键字有四个，分别是： 1 @public 被这个关键字修饰的变量是完全开放的，只要有这类的对象存在，就可以访问到这个变量。 2 @protected 被这个关键字修饰的变量是受保护的，只有在声明变量的这个类中和它的子类中，可以访问。 3 @private 被这个关键字修饰的变量是私有的，只能在声明这个变量的类中使用，子类也不能使用。 4 @package 这个关键字比较难理解，大致意思是被修饰的变量是封装的，在本框架内可以自由使用，效果和@public 相同，而在框架外不能使用，其子类也不能使用，效果又相当于@private。 因为@package的这种特点，它非常适用于franework框架。 一点扩展： 访问类中的变量，我们可以用-&gt;符号，它和点语法的区别在于，点语法实际上是调用的set与get方法，而-&gt;符号是直接访问变量。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://huishao.cc/tags/Objective-C/"}],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS UISlider用法总结","slug":"15iOS UISlider用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.328Z","comments":true,"path":"2015/04/15/15iOS UISlider用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/15iOS UISlider用法总结/","excerpt":"","text":"UIslider滑块控件在IOS开发中会常用到，可用于调节音量，字体大小等UI方面的交互，用法总结如下： 初始化一个滑块： 1 UISlider * slider = [[UISlider alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; 设置滑块位置 @property(nonatomic) float value;这个值是介于滑块的最大值和最小值之间的，如果没有设置边界值，默认为0-1； 设置滑块最小边界值（默认为0） @property(nonatomic) float minimumValue; 设置滑块最大边界值（默认为1） @property(nonatomic) float maximumValue; 设置滑块最左端显示的图片： @property(nonatomic,retain) UIImage *minimumValueImage； 设置滑块最右端显示的图片： @property(nonatomic,retain) UIImage *maximumValueImage; 设置滑块值是否连续变化(默认为YES) @property(nonatomic,getter=isContinuous) BOOL continuous; 这个属性设置为YES则在滑动时，其value就会随时变化，设置为NO，则当滑动结束时，value才会改变。 设置滑块左边（小于部分）线条的颜色 @property(nonatomic,retain) UIColor *minimumTrackTintColor； 设置滑块右边（大于部分）线条的颜色 @property(nonatomic,retain) UIColor *maximumTrackTintColor； 设置滑块颜色（影响已划过一端的颜色） @property(nonatomic,retain) UIColor *thumbTintColor； 注意这个属性：如果你没有设置滑块的图片，那个这个属性将只会改变已划过一段线条的颜色，不会改变滑块的颜色，如果你设置了滑块的图片，又设置了这个属性，那么滑块的图片将不显示，滑块的颜色会改变（IOS7） 手动设置滑块的值： - (void)setValue:(float)value animated:(BOOL)animated; 设置滑块的图片： - (void)setThumbImage:(UIImage *)image forState:(UIControlState)state; 设置滑块划过部分的线条图案 - (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state; 设置滑块未划过部分的线条图案 - (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state; 对应的几个get方法 - (UIImage )thumbImageForState:(UIControlState)state;- (UIImage )minimumTrackImageForState:(UIControlState)state;- (UIImage *)maximumTrackImageForState:(UIControlState)state; 对应的设置当前状态的响应属性的方法 @property(nonatomic,readonly) UIImage currentThumbImage;@property(nonatomic,readonly) UIImage currentMinimumTrackImage;@property(nonatomic,readonly) UIImage* currentMaximumTrackImage; 添加触发事件 1[slider addTarget:self action:@selector(log:) forControlEvents:UIControlEventValueChanged]; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISlider","slug":"UISlider","permalink":"http://huishao.cc/tags/UISlider/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISwitch 用法总结","slug":"16iOS UISwitch 用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.330Z","comments":true,"path":"2015/04/15/16iOS UISwitch 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/16iOS UISwitch 用法总结/","excerpt":"","text":"iOS 系统开关控件简单使用总结： 初始化： (instancetype)initWithFrame:(CGRect)frame; 这个frame是没有意义的，系统的开关控件大小是确定的。 设置开关开启状态时的颜色 @property(nonatomic, retain) UIColor *onTintColor; 设置开关风格颜色 @property(nonatomic, retain) UIColor *tintColor; 设置开关按钮颜色 @property(nonatomic, retain) UIColor *thumbTintColor; 设置开关开启状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *onImage; 设置开关关闭状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *offImage; 开关的状态 @property(nonatomic,getter=isOn) BOOL on; 手动设置开关状态 (void)setOn:(BOOL)on animated:(BOOL)animated; 一点感想：iOS的系统的UISwitch控件虽然定制性很差，配合IOS7之后的扁平化和俭约的风格，在美观上确实不逊色于任何私人定制的开关控件，在没有特殊需求的情况下，对于开关逻辑，这是一个非常不错的UI交互选择。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISwitch","slug":"UISwitch","permalink":"http://huishao.cc/tags/UISwitch/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIActivityIndicatorView(指示控制器)用法总结","slug":"17iOS UIActivityIndicatorView(指示控制器)用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2023-04-14T11:50:08.333Z","comments":true,"path":"2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","excerpt":"","text":"对于UIActivityIndicatorView的使用，我们一般会创建一个背景View,设置一定的透明度，然后将UIActivityIndicatorView贴在背景View上，在我们需要的时候将这个view呼出。 初始化UIActivityIndicatorView (instancetype)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style; 这个风格是一个枚举，如下 typedef NS_ENUM(NSInteger, UIActivityIndicatorViewStyle) { //大号白色 UIActivityIndicatorViewStyleWhiteLarge, //白色 UIActivityIndicatorViewStyleWhite, //灰色 UIActivityIndicatorViewStyleGray,}; 初始化之后，还需要给它一个Frame，但是只有前两个位置参数有效，大小参数将没有任何影响。 设置指示器风格： @property(nonatomic) UIActivityIndicatorViewStyle activityIndicatorViewStyle; 设置指示器是否停止动画时隐藏 @property(nonatomic) BOOL hidesWhenStopped; 设置指示器颜色 @property (readwrite, nonatomic, retain) UIColor *color； 让指示器开始动画 (void)startAnimating; 让指示器停止动画 (void)stopAnimating; 获取指示器动画状态 (BOOL)isAnimating; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIActivityIndicatorView","slug":"UIActivityIndicatorView","permalink":"http://huishao.cc/tags/UIActivityIndicatorView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UITextField 使用与方法解读","slug":"14iOS UITextField 使用与方法解读","date":"2015-04-13T16:00:00.000Z","updated":"2023-04-14T11:50:08.325Z","comments":true,"path":"2015/04/14/14iOS UITextField 使用与方法解读/","link":"","permalink":"http://huishao.cc/2015/04/14/14iOS UITextField 使用与方法解读/","excerpt":"","text":"UITextField是IOS开发中用户交互中重要的一个控件，常被用来做账号密码框，输入信息框等。 初始化一个文字框： UITextField * textField = [[UITextField alloc]initWithFrame:CGRectMake(100, 30, 100, 100)]; 设置和获取文字框文字： @property(nonatomic,copy) NSString *text; 通过AttributedString创建和获取文字： @property(nonatomic,copy) NSAttributedString *attributedText； 设置字体颜色属性： @property(nonatomic,retain) UIColor *textColor; 设置字体属性： @property(nonatomic,retain) UIFont *font; 设置字体对齐格式： @property(nonatomic)NSTextAlignment textAlignment; 设置输入框风格： @property(nonatomic) UITextBorderStyle borderStyle; 这个风格是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextBorderStyle) { //没有任何边框 UITextBorderStyleNone, //线性边框 UITextBorderStyleLine, //阴影效果边框 UITextBorderStyleBezel, //原型效果边框 UITextBorderStyleRoundedRect}; 设置默认字体属性 @property(nonatomic,copy) NSDictionary *defaultTextAttributes； 这个属性的设置会影响到全部字体的属性。 设置缺省时显示的灰度字符串 @property(nonatomic,copy) NSString *placeholder; 通过AttributedString设置缺省字符串 @property(nonatomic,copy) NSAttributedString *attributedPlaceholder； 设置是否在开始编辑时清空输入框内容 @property(nonatomic) BOOL clearsOnBeginEditing; 设置字体大小是否随宽度自适应（默认为NO） @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 设置最小字体大小 @property(nonatomic) CGFloat minimumFontSize; 设置背景图片（会被拉伸） @property(nonatomic,retain) UIImage *background; 设置禁用时的背景图片 @property(nonatomic,retain) UIImage *disabledBackground; 是否正在编辑（只读属性） @property(nonatomic,readonly,getter=isEditing) BOOL editing; 是否允许更改字符属性字典 @property(nonatomic) BOOL allowsEditingTextAttributes； 设置属性字典 @property(nonatomic,copy) NSDictionary *typingAttributes； 设置清除按钮的显示模式 @property(nonatomic) UITextFieldViewMode clearButtonMode; 这是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextFieldViewMode) { //从不显示 UITextFieldViewModeNever, //编辑的时候显示 UITextFieldViewModeWhileEditing, //非编辑的时候显示 UITextFieldViewModeUnlessEditing, //任何时候都显示 UITextFieldViewModeAlways}; 设置输入框左边的view @property(nonatomic,retain) UIView *leftView; 设置输入框左视图的显示模式 @property(nonatomic) UITextFieldViewMode leftViewMode; 设置输入框右边的view @property(nonatomic,retain) UIView *rightView; 设置输入框右视图的显示模式 @property(nonatomic) UITextFieldViewMode rightViewMode; 设置输入框成为第一响应时弹出的视图和辅助视图（类似键盘） @property (readwrite, retain) UIView inputView;@property (readwrite, retain) UIView inputAccessoryView; 这个属性设置是否允许再次编辑时在内容中间插入内容 @property(nonatomic) BOOL clearsOnInsertion； 注销第一响应（収键盘） (BOOL)endEditing:(BOOL)force; UITextFieldDelegate 代理中的方法 点击输入框时触发的方法，返回YES则可以进入编辑状态，NO则不能。 (BOOL)textFieldShouldBeginEditing:(UITextField *)textField; 开始编辑时调用的方法 (void)textFieldDidBeginEditing:(UITextField *)textField; 将要结束编辑时调用的方法，返回YES则可以结束编辑状态，NO则不能 (BOOL)textFieldShouldEndEditing:(UITextField *)textField; 结束编辑调用的方法 (void)textFieldDidEndEditing:(UITextField *)textField; 输入字符时调用的方法 (BOOL)textField:(UITextField )textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString )string; 点击清除按钮时调用的函数，返回YES则可以清除，点击NO则不能清除 (BOOL)textFieldShouldClear:(UITextField *)textField; 点击return键触发的函数 (BOOL)textFieldShouldReturn:(UITextField *)textField; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITextField","slug":"UITextField","permalink":"http://huishao.cc/tags/UITextField/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISegmentedControl","slug":"13iOS UISegmentedControl","date":"2015-04-12T16:00:00.000Z","updated":"2023-04-14T11:50:08.323Z","comments":true,"path":"2015/04/13/13iOS UISegmentedControl/","link":"","permalink":"http://huishao.cc/2015/04/13/13iOS UISegmentedControl/","excerpt":"","text":"SegmentedControl又被称作分段控制器，是IOS开发中经常用到的一个UI控件。 初始化方法：传入的数组可以是字符串也可以是UIImage对象的图片数组 (instancetype)initWithItems:(NSArray *)items; 设置控件风格： @property(nonatomic) UISegmentedControlStyle segmentedControlStyle 注意：这个属性已经废弃，不再起任何作用，它的枚举如下： typedef NS_ENUM(NSInteger, UISegmentedControlStyle) { UISegmentedControlStylePlain, // large plain UISegmentedControlStyleBordered, // large bordered UISegmentedControlStyleBar, // small button/nav bar style. tintable UISegmentedControlStyleBezeled, // DEPRECATED. Do not use this style.} NS_DEPRECATED_IOS(2_0, 7_0, “The segmentedControlStyle property no longer has any effect”); 设置是否保持选中状态： @property(nonatomic,getter=isMomentary) BOOL momentary; 注意：如果设置为YES，点击结束后，将不保持选中状态，默认为NO 获取标签个数：(只读) @property(nonatomic,readonly) NSUInteger numberOfSegments; 设置标签宽度是否随内容自适应： @property(nonatomic) BOOL apportionsSegmentWidthsByContent； 注意：如果设置为NO，则所有标签宽度一致，为最大宽度。 插入文字标签在index位置： (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated 插入图片标签在index位置 (void)insertSegmentWithImage:(UIImage *)image atIndex:(NSUInteger)segment animated:(BOOL)animated 根据索引删除标签 (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated; 删除所有标签 (void)removeAllSegments; 重设标签标题 (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment; 获取标签标题 (NSString *)titleForSegmentAtIndex:(NSUInteger)segment; 设置标签图片 (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment; 获取标签图片 (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment; 注意：标题的图片只能设置一个 根据索引设置相应标签宽度 (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;注意：如果设置为0.0，则为自适应，默认为此设置。 根据索引获取标签宽度 (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment; 设置标签内容的偏移量 (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment; 注意：这个偏移量指的是标签的文字或者图片 根据索引获取变标签内容的偏移量 (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment; 根据所以设置标签是否有效(默认有效) (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment; 根据索引获取当前标签是否有效 (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment; 设置和获取当前选中的标签索引 @property(nonatomic) NSInteger selectedSegmentIndex; 设置标签风格颜色 @property(nonatomic,retain) UIColor *tintColor; 注意：这个风格颜色会影响标签的文字和图片 设置特定状态下segment的背景图案 (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 注意：UIBarMetrics是一个枚举，如下：(defaulf风格会充满背景) typedef NS_ENUM(NSInteger, UIBarMetrics) { UIBarMetricsDefault, UIBarMetricsCompact, UIBarMetricsDefaultPrompt = 101, // Applicable only in bars with the prompt property, such as UINavigationBar and UISearchBar UIBarMetricsCompactPrompt, UIBarMetricsLandscapePhone NS_ENUM_DEPRECATED_IOS(5_0, 8_0, &quot;Use UIBarMetricsCompact instead&quot;) = UIBarMetricsCompact, UIBarMetricsLandscapePhonePrompt NS_ENUM_DEPRECATED_IOS(7_0, 8_0, &quot;Use UIBarMetricsCompactPrompt&quot;) = UIBarMetricsCompactPrompt, }; 获取背景图案 (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 设置标签之间分割线的图案 (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 获取标签之间分割线的图案 (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 通过Attribute字符串属性字典设置标签标题 (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state 获取Attribute字符串属性字典 (NSDictionary *)titleTextAttributesForState:(UIControlState)state 自行设置标签内容的偏移量 (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 注意：UIOffset为偏移量，这个结构体中又两个浮点数，分别表示水平量和竖直量；UISegmentedControlSegment类型参数是一个枚举，如下： typedef NS_ENUM(NSInteger, UISegmentedControlSegment) { UISegmentedControlSegmentAny = 0,//所有标签都受影响 UISegmentedControlSegmentLeft = 1, //只有左边部分受到影响 UISegmentedControlSegmentCenter = 2, // 只有中间部分受到影响 UISegmentedControlSegmentRight = 3, // 只有右边部分受到影响 UISegmentedControlSegmentAlone = 4, // 在只有一个标签的时候生效}; 获取自定义偏移量 (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 添加点击事件 [segmentedControl addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISegmentedControl","slug":"UISegmentedControl","permalink":"http://huishao.cc/tags/UISegmentedControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS 封装静态库(.a文件)","slug":"11iOS 封装静态库(.a文件)","date":"2015-04-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.319Z","comments":true,"path":"2015/04/11/11iOS 封装静态库(.a文件)/","link":"","permalink":"http://huishao.cc/2015/04/11/11iOS 封装静态库(.a文件)/","excerpt":"","text":"iOS中导入外部文件，一种是将源码导入，一种是导入静态库，有很多第三方库都是以静态库的形式提供给我们使用的，如何制作一个静态库呢？ 一、xCode创建文件时，选择创建静态库文件：cacoaTouchStaticLibrary 创建完成后，我们在里面写我们的方法和实现： .h文件和.m文件 1234#import &lt;Foundation/Foundation.h&gt;@interface MyStaticLibrary : NSObject-(void)myLog;@end 123456#import &quot;MyStaticLibrary.h&quot;@implementation MyStaticLibrary-(void)myLog&#123; NSLog(@&quot;myLog&quot;);&#125;@end 二、生成静态库文件：这里需要将设备选成IOS Device然后 使用command+B进行编译，如果xcode报出这样的一个错误：我们需要在Peoject-&gt;Code Signing -&gt;Code Signing Identity 改成IOS Developer再次编译，成功。然后你会看到，Products中的.a文件由红色编程了黑色。我们右键show in finder，就可以看到编译成功的静态库文件了。 三、合并静态库 在文件夹中，我们看到有两个.a文件，分别用在模拟器调试和真机调试中，如果我们在开发时需要真机模拟器不停的切换，我们可以将这两个静态库文件合并成为一个： 在终端使用：lipo -create -output 命令： 这时，我们的静态库文件就做好了。 三、静态库文件的使用： 将.a和.h文件导入工程，在需要的文件中导入头文件，即可使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"静态库","slug":"静态库","permalink":"http://huishao.cc/tags/静态库/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS UIButton解读","slug":"12iOS UIButton解读","date":"2015-04-10T16:00:00.000Z","updated":"2023-04-14T11:50:08.321Z","comments":true,"path":"2015/04/11/12iOS UIButton解读/","link":"","permalink":"http://huishao.cc/2015/04/11/12iOS UIButton解读/","excerpt":"","text":"UIButton控件是应用界面中常用的一个控件，用法总结： 一、初始化 UIButton的初始化一般使用其类方法，+ (id)buttonWithType:(UIButtonType)buttonType; 风格的枚举如下： typedef NS_ENUM(NSInteger, UIButtonType) { //用户自定义，无风格 UIButtonTypeCustom = 0, //系统默认风格 UIButtonTypeSystem NS_ENUM_AVAILABLE_IOS(7_0), //一下这三种创建出来的按钮一样，一个蓝色的圆圈，中间有个叹号 UIButtonTypeDetailDisclosure, UIButtonTypeInfoLight, UIButtonTypeInfoDark, //创建+号按钮 UIButtonTypeContactAdd, //废弃 UIButtonTypeRoundedRect = UIButtonTypeSystem,}; 二、属性设置 @property(nonatomic) UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR;//这个属性设置button里内容的偏移量，包括title和image，可以用如下方法设置btn.contentEdgeInsets=UIEdgeInsetsMake(20, 20, 0, 0); @property(nonatomic) UIEdgeInsets titleEdgeInsets;//这个属性设置标题的偏移量@property(nonatomic) BOOL reversesTitleShadowWhenHighlighted;//按钮高亮时，是否改变阴影效果@property(nonatomic) UIEdgeInsets imageEdgeInsets;//图片的偏移量@property(nonatomic)BOOL adjustsImageWhenHighlighted;//设置图片的绘制是否高亮时变暗@property(nonatomic)BOOL adjustsImageWhenDisabled;//设置图片是否轻绘制当按钮禁用时@property(nonatomic)BOOL showsTouchWhenHighlighted;//设置是否显示手指印在按钮高亮的时候@property(nonatomic,retain) UIColor *tintColor NS_AVAILABLE_IOS(5_0);//这个属性会作用于标题和图片，但是如果你是自定义风格的按钮，这个属性将不起任何作用，它只作用于系统的@property(nonatomic,readonly) UIButtonType buttonType;//设置button的风格 三、一些set方法 (void)setTitle:(NSString *)title forState:(UIControlState)state;//设置标题和显示当前标题的按钮状态 (void)setTitleColor:(UIColor *)color forState:(UIControlState)state;//设置标题颜色和显示当前颜色的按钮状态 (void)setTitleShadowColor:(UIColor *)color forState:(UIControlState)state;//设置标题阴影颜色及显示时的状态 (void)setImage:(UIImage *)image forState:(UIControlState)state;//设置按钮图片和显示当前图片时的状态 (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state;//设置按钮背景图片和显示图片时的状态 (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state NS_AVAILABLE_IOS(6_0);//通过AttributeString创建标题 注意：按钮图片设置和背景图片的不同在于： 1、设置图片，如果有标题会和标题并列显示 2、设置背景图片会出现在标题下面 3、图片的偏移量可以设置，背景图片不可以。 四、一些get方法，可以得到上述设置的属性 (NSString *)titleForState:(UIControlState)state; (UIColor *)titleColorForState:(UIControlState)state; (UIColor *)titleShadowColorForState:(UIControlState)state; (UIImage *)imageForState:(UIControlState)state; (UIImage *)backgroundImageForState:(UIControlState)state; (NSAttributedString *)attributedTitleForState:(UIControlState)state NS_AVAILABLE_IOS(6_0); 五、一些只读属性 @property(nonatomic,readonly,retain) NSString currentTitle;@property(nonatomic,readonly,retain) UIColor currentTitleColor;@property(nonatomic,readonly,retain) UIColor currentTitleShadowColor;@property(nonatomic,readonly,retain) UIImage currentImage;@property(nonatomic,readonly,retain) UIImage currentBackgroundImage;@property(nonatomic,readonly,retain) NSAttributedString currentAttributedTitle NS_AVAILABLE_IOS(6_0);//这两个参数需要注意，虽然他们是只读属性不能重新设置，但是我们可以设置label和imageView的相关属性@property(nonatomic,readonly,retain) UILabel titleLabel NS_AVAILABLE_IOS(3_0);@property(nonatomic,readonly,retain) UIImageView imageView NS_AVAILABLE_IOS(3_0); 六、下面这些函数，都会返回一个CGRect 矩形范围 (CGRect)backgroundRectForBounds:(CGRect)bounds;//返回背景大小 (CGRect)contentRectForBounds:(CGRect)bounds;//返回视图大小，包括标题和图片 (CGRect)titleRectForContentRect:(CGRect)contentRect;//返回标题大小 (CGRect)imageRectForContentRect:(CGRect)contentRect;//返回图片大小 关于触发事件，button是继承于UIControl,这里不再叙述。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIButton","slug":"UIButton","permalink":"http://huishao.cc/tags/UIButton/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS NSInvocation应用与理解","slug":"09iOS NSInvocation应用与理解","date":"2015-04-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.314Z","comments":true,"path":"2015/04/10/09iOS NSInvocation应用与理解/","link":"","permalink":"http://huishao.cc/2015/04/10/09iOS NSInvocation应用与理解/","excerpt":"","text":"IOS中有一个类型是SEL，它的作用很相似与函数指针，通过performSelector:withObject:函数可以直接调用这个消息。但是perform相关的这些函数，有一个局限性，其参数数量不能超过2个，否则要做很麻烦的处理，与之相对，NSInvocation也是一种消息调用的方法，并且它的参数没有限制。这两种直接调用对象消息的方法，在IOS4.0之后，大多被block结构所取代，只有在很老的兼容性系统中才会使用，简单用法总结如下： 一、初始化与调用 在官方文档中有明确说明，NSInvocation对象只能使用其类方法来初始化，不可使用alloc/init方法。它执行调用之前，需要设置两个方法：setSelector: 和setArgument:atIndex： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog); //创建一个函数签名，这个签名可以是任意的,但需要注意，签名函数的参数数量要和调用的一致。 NSMethodSignature * sig = [NSNumber instanceMethodSignatureForSelector:@selector(init)]; //通过签名初始化 NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; //设置target [invocatin setTarget:self]; //设置selecteor [invocatin setSelector:myMethod]; //消息调用 [invocatin invoke]; &#125;-(void)myLog&#123; NSLog(@&quot;MyLog&quot;);&#125; 注意：签名函数的参数数量要和调用函数的一致。测试后发现，当签名函数参数数量大于被调函数时，也是没有问题的。 调用多参数的方法，我们可以这样写： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 注意：1、这里设置参数的Index 需要从2开始，因为前两个被selector和target占用。下面这样写也没有任何问题： 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); SEL myMethod2 = @selector(myLog); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; ViewController * view = self; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 2、这里的传参方式必须是传递参数地址。 二、NSInvocation的返回值 NSInvocation对象，是可以有返回值的，然而这个返回值，并不是其所调用函数的返回值，需要我们手动设置： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; ViewController * view = self; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; //我们将c的值设置为返回值 [invocatin setReturnValue:&amp;c]; int d; //取这个返回值 [invocatin getReturnValue:&amp;d]; NSLog(@&quot;%d&quot;,d); &#125;-(int)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c); return a+b+c;&#125; 注意：这里的操作传递的都是地址。如果是OC对象，也是取地址。 三、关于内存 可以注意到- (void)retainArguments;这个方法，它会将传入的所有参数以及target都retain一遍。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSInvocation","slug":"NSInvocation","permalink":"http://huishao.cc/tags/NSInvocation/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSTimer 定时器用法总结","slug":"10iOS NSTimer 定时器用法总结","date":"2015-04-09T16:00:00.000Z","updated":"2023-04-14T11:50:08.317Z","comments":true,"path":"2015/04/10/10iOS NSTimer 定时器用法总结/","link":"","permalink":"http://huishao.cc/2015/04/10/10iOS NSTimer 定时器用法总结/","excerpt":"","text":"NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下： 一、初始化方法：有五种初始化方法，分别是 + (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个Invocation对象 NSInvocation * invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(init)]]; [invo setTarget:self]; [invo setSelector:@selector(myLog)]; NSTimer * timer = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES]; //加入主循环池中 [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; //开始循环 [timer fire];&#125; + (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 1 NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES]; + (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:NO] + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:@&quot;123&quot; repeats:YES] - (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep 12 NSTimer * timer = [[NSTimer alloc]initWithFireDate:[NSDate distantPast] interval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; 注意：这五种初始化方法的异同： 1、参数repeats是指定是否循环执行，YES将循环，NO将只执行一次。 2、timerWithTimeInterval这两个类方法创建出来的对象如果不用 addTimer: forMode方法手动加入主循环池中，将不会循环执行。并且如果不手动调用fair，则定时器不会启动。 3、scheduledTimerWithTimeInterval这两个方法不需要手动调用fair，会自动执行，并且自动加入主循环池。 4、init方法需要手动加入循环池，它会在设定的启动时间启动。 二、成员变量 @property (copy) NSDate *fireDate; 这是设置定时器的启动时间，常用来管理定时器的启动与停止 1234 //启动定时器 timer.fireDate = [NSDate distantPast]; //停止定时器 timer.fireDate = [NSDate distantFuture]; @property (readonly) NSTimeInterval timeInterval; 这个是一个只读属性，获取定时器调用间隔时间。 @property NSTimeInterval tolerance; 这是7.0之后新增的一个属性，因为NSTimer并不完全精准，通过这个值设置误差范围。 @property (readonly, getter=isValid) BOOL valid; 获取定时器是否有效 @property (readonly, retain) id userInfo; 获取参数信息 三、关于内存释放 如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。所以我们需要这样做： 123456789101112131415161718-(void)dealloc&#123; NSLog(@&quot;dealloc:%@&quot;,[self class]);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; timer= [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(btn) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;-(void)btn&#123; if (timer.isValid) &#123; [timer invalidate]; &#125; timer=nil; [self dismissViewControllerAnimated:YES completion:nil];&#125; 在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSTimer","slug":"NSTimer","permalink":"http://huishao.cc/tags/NSTimer/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS 中block结构的简单用法","slug":"08iOS 中block结构的简单用法","date":"2015-04-08T16:00:00.000Z","updated":"2023-04-14T11:50:08.314Z","comments":true,"path":"2015/04/09/08iOS 中block结构的简单用法/","link":"","permalink":"http://huishao.cc/2015/04/09/08iOS 中block结构的简单用法/","excerpt":"","text":"自从block出现之后，很多API都开始采用这样的结构，由此可见，block确实有许多优势存在，这里将一些简单用法总结如下： 一、如何声明一个block变量 我们通过^符号来声明block类型，形式如下： void (^myBlock)(); 其中第一个void是返回值，可以是任意类型，中间括号中^后面的是这个block变量的名字，我把它命名为myBlock，最后一个括号中是参数，如果多参数，可以写成如下样式： int (^myBlock)(int,int); 同样，你也可以给参数起名字： int (^myBlock)(int a,int b); 很多时候，我们需要将我们声明的block类型作为函数的参数，也有两种方式： 1、-(void)func:(int (^)(int a,int b))block； 第二种方式是通过typedef定义一种新的类型，这也是大多数情况下采用的方式： 2、typedef int (^myBlock)(int a,int b) ; -(void)func:(myBlock)block ; 二、如何实现一个block 既然block可以被声明为变量，那么就一定可以实现它，就像其他类型变量的赋值。我自己对block的理解为它是一断代码块，所以给它赋值赋便是一段代码段： 1234567891011121314151617typedef int (^myBlock)(int,int) ;@interface ViewController ()&#123; myBlock block1;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. block1 =^(int a, int b)&#123; return a+b; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 这里打印的结果是2，从这里可以发现block和函数的功能很像。 注意：1、在上面的代码里 block1是一个对象，如果直接打印将打印对象地址 2、block()，加上后面的括号才是执行block语句块 三、block中访问对象的微妙关系 1、如果你在一个block块中仅仅访问对象，而不是对他进行修改操作，是没有任何问题的： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; int count= tem+1; return count; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 而如果我在block块中直接修改，编译器会报错： 1234 block1 = ^(int a,int b)&#123; tem+=1; return tem+1; &#125;; 为什么会出现这样的情况，根据猜测，可能是block内部将访问的变量都备份了一份，如果我们在内部修改，外部的变量并不会被修改，我们可以通过打印变量的地址来证明这一点： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; int tem=2; NSLog(@&quot;%p&quot;,&amp;tem); block1 = ^(int a,int b)&#123; NSLog(@&quot;%p&quot;,&amp;tem); return tem+1; &#125;; NSLog(@&quot;%d&quot;,block1(1,1)); &#125; 打印结果如下： 可以看出，变量的地址已经改变。 2、__block 做了什么 为了可以在block块中访问并修改外部变量，我们常会把变量声明成__block类型，通过上面的原理，可以发现，其实这个关键字只做了一件事，如果在block中访问没有添加这个关键字的变量，会访问到block自己拷贝的那一份变量，它是在block创建的时候创建的，而访问加了这个关键字的变量，则会访问这个变量的地址所对应的变量。我们可以通过代码来证明： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; tem=4; NSLog(@&quot;%d&quot;,block1(1,1)); block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; __block int tem2=2; tem2=4; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 结果： 3、一点点扩展 由此，我们可以理解，如果block中操作的对象是指针，那么直接可以进行修改，这包括OC对象，如果不是，则需要用__block关键字修饰。 4、关于引用计数 在block中访问的对象，会默认retain： 1234567 UIImage * number; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 结果如下： 而添加__block的对象不会被retain; 注意：如果我们访问类的成员变量，或者通过类方法来访问对象，那么这些对象不会被retain，而类对象会被return，最常见的时self: 1234567891011121314151617181920212223242526272829303132typedef void(^myBlock)(int,int) ;@interface ViewController2 ()&#123; myBlock block1; __block UIImage * number; &#125;@end@implementation ViewController2-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number));&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; //block1(1,1); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 打印结果： 可以看出，UIImage对象没有被retain,而self也将循环引用，造成内存泄露。解决方法如下： 1234567 number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIImage * im = number; block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)im)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 打印结果： 注意：根据这个机制，如果我们将block用来传值，在block不用时，务必要置为nil,而在实现block的方法里，务必要释放;我们通过代码来解释： 首先，创建三个ViewController，为ViewController1，ViewController2，ViewController3； 1、在ViewController1中创建一个按钮，跳转ViewController2 2、在ViewController2中： 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController2.h&quot;#import &quot;ViewController3.h&quot;@interface ViewController2 ()&#123; UIButton * im;&#125;@end@implementation ViewController3-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(300, 300, 100, 100); btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; im = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; im.backgroundColor=[UIColor blackColor]; [im addTarget:self action:@selector(rele) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:im];&#125;-(void)rele&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController3 alloc]init]; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 3、在ViewController3中： 12345678910111213141516171819202122#import &quot;ViewController3.h&quot;void (^myBlock)();@implementation ViewController3-(void)setBlock:(void(^)())block&#123; myBlock = [block copy];&#125;-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; myBlock(); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 通过打印信息，我们会发现，ViewController2不被释放，原因是其成员变量im被block中retain没有释放，我们这样做： 1234567891011121314151617@interface ViewController2 ()&#123; UIButton * im; ViewController3 * tem;&#125;-(void)rele&#123; [tem setBlock:nil]; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController2 alloc]init]; tem=con; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 这样就解决了内存问题。 四、关于block的作用域 应避免将花括号中的block用于外面，如果需要，你可以将这个block声明为全局的。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"Block","slug":"Block","permalink":"http://huishao.cc/tags/Block/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中使用NSAttributedString灵活创建标签","slug":"07iOS中使用NSAttributedString灵活创建标签","date":"2015-04-07T16:00:00.000Z","updated":"2023-04-14T11:50:08.314Z","comments":true,"path":"2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","link":"","permalink":"http://huishao.cc/2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","excerpt":"","text":"灵活使用NSAttributedString可以更轻松的创建出内容复杂的标签。需要注意一点：如果一个label设置了这个属性，那它其他的设置都将失效。 首先，我们初始化一个NSMutableAttributedString对象。 12345678//通过字符串初始化//- (instancetype)initWithString:(NSString *)str;//通过字符串和属性字典直接初始化//- (instancetype)initWithString:(NSString *)str attributes:(NSDictionary *)attrs;//通过自身对象初始化//- (instancetype)initWithAttributedString:(NSAttributedString *)attrStr; NSMutableAttributedString * attribute = [[NSMutableAttributedString alloc]initWithString:@&quot;123!@#你好么QWE&quot;]; 可以通过下面两个函数对attrebute字符串进行设置与修改 123456//可以替换字符- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;//属性设置- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;//设置一定范围内字符属性- (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; 字典的键值对应如下： 123456789101112131415161718//kCTFontAttributeName 这个键是字体的名称 必须传入CTFont对象//kCTKernAttributeName 这个键设置字体间距 传入必须是数字对象 默认为0//kCTLigatureAttributeName 这个键设置连字方式 必须传入CFNumber对象//kCTParagraphStyleAttributeName 段落对其方式//kCTForegroundColorAttributeName 字体颜色 必须传入CGColor对象//kCTStrokeWidthAttributeName 笔画宽度 必须是CFNumber对象//kCTStrokeColorAttributeName 笔画颜色//kCTSuperscriptAttributeName 控制垂直文本定位 CFNumber对象//kCTUnderlineColorAttributeName 下划线颜色[attribute addAttribute:(NSString*)kCTKernAttributeName value:@5 range:NSMakeRange(0, 5)];[attribute addAttribute:(NSString *)kCTFontAttributeName value:(id)CFBridgingRelease(CTFontCreateWithName((CFStringRef)[UIFont boldSystemFontOfSize:14].fontName, 14, NULL)) range:NSMakeRange(0, 4)]; [attribute addAttribute:(NSString *)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; 通过测试，发现上面有些键值并没有作用，可以替换下面的方法，效果相同，不同的地方在于其传值的类型不同，下面的方法更加方便（使用UIFont UIColor NSString 和一些系统枚举） 1234567891011121314151617181920 NSParagraphStyleAttributeNameNSForegroundColorAttributeNameNSBackgroundColorAttributeNameNSLigatureAttributeNameNSKernAttributeNameNSStrikethroughStyleAttributeNameNSUnderlineStyleAttributeNameNSStrokeColorAttributeName NSStrokeWidthAttributeName NSShadowAttributeName NSTextEffectAttributeNameNSAttachmentAttributeName NSLinkAttributeName NSBaselineOffsetAttributeName NSUnderlineColorAttributeNameNSStrikethroughColorAttributeNameNSObliquenessAttributeName NSExpansionAttributeName NSWritingDirectionAttributeNameNSVerticalGlyphFormAttributeName 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://huishao.cc/tags/NSAttributedString/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS6中横屏的处理方法","slug":"05iOS6中横屏的处理方法","date":"2015-04-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.314Z","comments":true,"path":"2015/04/07/05iOS6中横屏的处理方法/","link":"","permalink":"http://huishao.cc/2015/04/07/05iOS6中横屏的处理方法/","excerpt":"","text":"IOS6以后，若想在项目中支持横屏，我们首先需要在plist文件中添加支持横屏的设置，否则有些代码设置将会失效。 有来那个方式设置： 1、在pilist的Supported interface orientations 字段中添加 2、在Xcode的设置中勾选 现在我们来看决定屏幕方向的几个函数： 在IOS6之前，我们只需通过一个函数 - (BOOL) shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation { return (toInterfaceOrientation == UIInterfaceOrientationLandscapeRight);} 就可以支持指定控制器的旋转。通过新的文档，我们可以看到： 1234// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);//这个方法在6.0之后被标记为过时的 我们通过下面两个方法来代替： //是否允许屏幕旋转 -(BOOL)shouldAutorotate{ return YES;}//支持的方向- (NSUInteger)supportedInterfaceOrientations { return UIInterfaceOrientationMaskLandscapeRight;}这是个枚举 123456789101112131415typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown=(1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125;; 通过这两个函数，如果我们需要某个控制器强制方向，我们可以设置支持单一的方向，即可达到目的。 注意： 如果你们项目中的RootViewController是导航，你会发现，你在Push出来的视图中添加刚才的代码并没有起作用，原因是导航，并没有进行设置，我们创建一个文件，继承于NavigationController。在里面重写刚才的方法，这么做后，屏幕确实横了过来，并且这个导航push的所有子界面都将横屏，这也不是我们想要的效果。我们想自由的控制每个push出来的界面的屏幕方向，可以在导航里这么做： 1234567-(BOOL)shouldAutorotate&#123; return [self.topViewController shouldAutorotate];&#125;//支持的方向- (NSUInteger)supportedInterfaceOrientations &#123; return [self.topViewController supportedInterfaceOrientations];;&#125; 我们还需要做一些处理，经过我的测试，导航必须在pop后才会重新调用这些函数，所以我的方法是这样做：弹出一个中间控制器后再POP回来 1234567@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController pushViewController:[[ViewController3 alloc]init] animated:YES];&#125; 1234567@implementation ViewController3- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController popViewControllerAnimated:YES];&#125; 这样做，我们就可以自由的控制每个视图控制器的方向了。 同理，如果根视图控制器是tabBar，则我们需要在tabBar中做操作。 如果我们大多是的视图控制器都是一个方向的，只有偶尔的几个会不同，这时候，我们其实可以采取presentationController的方式，然后直接在弹出的控制器中写那两个方法即可。这是最简单的途径了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"横屏","slug":"横屏","permalink":"http://huishao.cc/tags/横屏/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS UILabe及UIFont用法总结","slug":"06iOS UILabe及UIFont用法总结","date":"2015-04-06T16:00:00.000Z","updated":"2023-04-14T11:50:08.314Z","comments":true,"path":"2015/04/07/06iOS UILabe及UIFont用法总结/","link":"","permalink":"http://huishao.cc/2015/04/07/06iOS UILabe及UIFont用法总结/","excerpt":"","text":"初始化一个UILabel对象，并初始化大小 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置显示的文字 label.text=@”123”; 和字体相关的一个类，字号大小默认17 @property(nonatomic,retain) UIFont*font; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//7.0之后可用 设置字体风格// NSString *const UIFontTextStyleHeadline; 用于标题的风格// NSString *const UIFontTextStyleSubheadline;用于副标题的风格// NSString *const UIFontTextStyleBody;用于正文的字体// NSString *const UIFontTextStyleFootnote;用于脚注的字体// NSString *const UIFontTextStyleCaption1;用于标准字幕字体// NSString *const UIFontTextStyleCaption2;用于替换字幕字体 label.font=[UIFont preferredFontForTextStyle:UIFontTextStyleCaption2];//说实话，没看出什么太大的差别//设置字体和字体大小+ (UIFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize;//返回所有字体的字体家族名称数组+ (NSArray *)familyNames;//按字体家族名称返回字体名称数组+ (NSArray *)fontNamesForFamilyName:(NSString *)familyName;//设置普通字体字号大小+ (UIFont *)systemFontOfSize:(CGFloat)fontSize;//设置加粗字体字号大小+ (UIFont *)boldSystemFontOfSize:(CGFloat)fontSize;//设置斜体字号大小+ (UIFont *)italicSystemFontOfSize:(CGFloat)fontSize;//一些只读属性//字体家族名称@property(nonatomic,readonly,retain) NSString *familyName;//字体名称@property(nonatomic,readonly,retain) NSString *fontName;//字号大小@property(nonatomic,readonly) CGFloat pointSize;//字体设计模型，表示距离最高点偏移余量@property(nonatomic,readonly) CGFloat ascender;//底部的模型偏移量@property(nonatomic,readonly) CGFloat descender;//字体模型的头高信息@property(nonatomic,readonly) CGFloat capHeight;//字体模型的xHeight信息@property(nonatomic,readonly) CGFloat xHeight;//字体行高@property(nonatomic,readonly) CGFloat lineHeight NS_AVAILABLE_IOS(4_0);//模型主体信息@property(nonatomic,readonly) CGFloat leading;//创建一个新字体与当前字体相同，除了指定的大小- (UIFont *)fontWithSize:(CGFloat)fontSize;//通过描述信息返回字体 7.0后可用+ (UIFont *)fontWithDescriptor:(UIFontDescriptor *)descriptor size:(CGFloat)pointSize NS_AVAILABLE_IOS(7_0);//返回字体的描述信息，7.0后可用- (UIFontDescriptor *)fontDescriptor NS_AVAILABLE_IOS(7_0); 设置字体颜色 label.textColor=[UIColor redColor]; 设置阴影偏移量 label.shadowOffset=CGSizeMake(20, 20); 设置阴影颜色 label.shadowColor=[UIColor blackColor]; 设置对齐模式 label.textAlignment=NSTextAlignmentJustified; 1234567891011enum &#123; //沿左边沿对齐文本 NSTextAlignmentLeft = 0, //中心对齐 NSTextAlignmentCenter = 1, //右边沿对齐 NSTextAlignmentRight = 2, //最后一行自然对齐 NSTextAlignmentJustified = 3, //默认对齐 NSTextAlignmentNatural = 4,&#125;;typedef NSInteger NSTextAlignment; 多行文本设置 label.lineBreakMode=NSLineBreakByCharWrapping; 12345678910111213enum &#123; //文本边缘处理 NSLineBreakByWordWrapping = 0, //提前处理不合适的字符 NSLineBreakByCharWrapping, //简单线性处理 NSLineBreakByClipping, //丢失的开头用省略号表示 NSLineBreakByTruncatingHead, //丢失的文本在末尾显示省略号 NSLineBreakByTruncatingTail, //丢失的文本在中间显示省略号 NSLineBreakByTruncatingMiddle &#125;;typedef NSUInteger NSLineBreakMode 使用attributedText绘制 @property(nonatomic,copy) NSAttributedString *attributedText 设置高亮的字体颜色 label.highlightedTextColor=[UIColor blueColor]; //设置是否高亮 label.highlighted=YES; 用户交互 默认关闭 label.userInteractionEnabled=NO; 是否有效，默认是YES，无效为灰色 label.enabled=NO; 显示的行数，0为无限 @property(nonatomic) NSInteger numberOfLines; 宽度自适应大小 默认是NO @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 字符适应宽度：不赞成使用 @property(nonatomic) BOOL adjustsLetterSpacingToFitWidth 最小适应大小2.0-6.0 @property(nonatomic) CGFloat minimumFontSize 最小适应大小 6.0 之后 @property(nonatomic) CGFloat minimumScaleFactor 垂直方向的调整 @property(nonatomic) UIBaselineAdjustment baselineAdjustment; 1234567typedef enum &#123; //调整文本对应基线位置 UIBaselineAdjustmentAlignBaselines, //调整文本相对其边框的中心 UIBaselineAdjustmentAlignCenters, //调整文本相对于边界的左上角 默认的 UIBaselineAdjustmentNone,&#125; UIBaselineAdjustment; 返回文本绘制矩形 - (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines; 文本绘制函数 - (void)drawTextInRect:(CGRect)rect 文本自动布局参数 @property(nonatomic) CGFloat preferredMaxLayoutWidth 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UILabel","slug":"UILabel","permalink":"http://huishao.cc/tags/UILabel/"},{"name":"UIFont","slug":"UIFont","permalink":"http://huishao.cc/tags/UIFont/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS SEL的理解与使用","slug":"04iOS SEL的理解与使用","date":"2015-04-04T16:00:00.000Z","updated":"2023-04-14T11:50:08.313Z","comments":true,"path":"2015/04/05/04iOS SEL的理解与使用/","link":"","permalink":"http://huishao.cc/2015/04/05/04iOS SEL的理解与使用/","excerpt":"","text":"有很多人，认为block的推广可取代代理设计模式，其实block并不能取代代理，代理的模式可以让代码逻辑性更强，更整洁，也会有更高的可读性和可扩展性。相比之下，我觉得block更多的是取代了选择器@selector。 @selector是什么？我们要首先明白SEL，SEL并不是一种对象类型，我们通过xCode的字体颜色就可以判断出来，它是一个关键字，就像int，long一样，它声明了一种类型：类方法指针。其实就可以理解为一个函数指针。比如，我们生命一个叫myLog的函数指针： 1234567#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end 声明出了这个指针，我们该如何给它传递这个函数呢？有两种方式： 1、在编译时，使用@selector来取得函数 现在，我们应该明白@selector是什么了，它是一个编译标示，我们通过它来取到相应函数。 12345678910111213141516171819@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = @selector(myLogL); //通过performSelector来执行方法 [self performSelector:myLog];//打印 “myLog” &#125;-(void)myLogL&#123; NSLog(@&quot;myLog&quot;);&#125; 2、在运行时，通过NSSelectorFromString方法来取到相应函数： 12345678910111213141516171819202122#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = NSSelectorFromString(@&quot;myLogN&quot;); [self performSelector:myLog]; &#125;-(void)myLogN&#123; NSLog(@&quot;myLog&quot;);&#125; 这两种方式的差别在于，编译时的方法如果没有找到相应函数，xcode会报错，而运行时的方法不会。 至于SEL的应用，我相信最广泛的便是target——action设计模式了。我们来简单模拟一下系统button的工作原理： 我们先创建一个继承于UIButton的类： .h文件： 12345#import &lt;UIKit/UIKit.h&gt;@interface Mybutton : UIButton-(void)addMyTarget:(id)target action:(SEL)action;@end .m文件 1234567891011121314151617#import &quot;Mybutton.h&quot;@implementation Mybutton&#123; SEL _action; id _target;&#125;-(void)addMyTarget:(id)target action:(SEL)action&#123; _target=target; _action=action;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_target performSelector:_action];&#125;@end 在外部： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; Mybutton * btn = [[Mybutton alloc]initWithFrame:CGRectMake(100, 100, 60, 60)]; btn.backgroundColor=[UIColor redColor]; [btn addMyTarget:self action:@selector(click)]; [self.view addSubview:btn];&#125;-(void)click&#123; NSLog(@&quot;点击了btn&quot;);&#125; 当然，如果要调用参数，系统提供的默认参数不超过两个，如果参数很多，一种是我们可以通过字典传参，另一种方法比较复杂，在这里先不讨论。 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"SEL","slug":"SEL","permalink":"http://huishao.cc/tags/SEL/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS事件响应控制","slug":"03iOS事件响应控制","date":"2015-04-03T16:00:00.000Z","updated":"2023-04-14T11:50:08.313Z","comments":true,"path":"2015/04/04/03iOS事件响应控制/","link":"","permalink":"http://huishao.cc/2015/04/04/03iOS事件响应控制/","excerpt":"","text":"以前遇到一个项目，一个UIImageView对象上面有一个UIButton对象，然而项目的需求需要在点击 button的同时，UIImageView也接收到点击事件，在不使用代理和通知方法的前提下，通过事件响应链的原理，我们也可以很便捷的解决这个问题。 在处理这个问题之前，我们应该先清楚IOS的事件响应机制到底是个什么样的原理。 首先，这个事件响应的机制是分为两个部分的。 1、先在视图层级关系中找到应该响应事件的那个视图。 这一步是什么意思，其实很简单，就是找到你所触摸点对应的那个最上层的视图，它的工作原理是这样的：当用户发出事件后，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会取出队列中最前面的事件，发消息给UIWindow，然后UIWindow会对其所有子视图调用hitTest:withEvent:这个方法，这个方法会返回一个UIView的对象，这个方法在执行的时候，它会调用当前视图的pointInside:withEvent:这个方法，如果触摸事件在当前视图范围内，pointInside:withEvent:会返回YES，否则会返回NO；如果返回YES，则会遍历当前视图的所有子视图，统统发送hitTest:withEvent:这个消息，如果返回NO,则hitTest:withEvent:方法返回nil； 上面说起来有些绕，其实就是：hitTest:withEvent:方法会一层一层的向上找，若最上层响应的子视图pointInside:withEvent:返回YES，则返回此子视图，如果所有的都返回nil，则返回当前视图本身self。 例如：我们建两个文件，一个继承于UIButton，一个继承于UIImageView，我们在UIImageView里的代码如下： 12345678910111213141516171819#import &quot;MyImageView.h&quot;@implementation MyImageView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor=[UIColor redColor]; &#125; return self;&#125;//在这里，我们重写了这个方法，让它直接返回自身，而不是继续向下寻找应该响应事件的视图-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;点击了Image&quot;);&#125; 然后将他们创建在一个View上： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; // Do any additional setup after loading the view, typically from a nib.&#125; 我们运行，点击这个Btn，会打印如下的信息： 可以证明，在事件视图寻找中，UIImageView我们重写hitTest:withEvent:方法后，切断了寻找链，如果我们这个做： 123-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return nil;&#125; 你会发现，UIImageView也不再接收事件。2、寻找到应该响应的视图后，会进行消息处理，这个处理的方式是通过消息处理链来做的。如果它自身不能处理消息，会通过nextResponder将消息传递给下一个处理者，默认只要有一个view将消息处理了，这个消息处理传递链将不再传递。 现在，我们把刚才UIimageView里重写的hitTest:withEvent:方法注释掉，给btn添加一个点击方法，同时将用户交互关闭： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; image.userInteractionEnabled=YES; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click&#123; NSLog(@&quot;btn被点击了&quot;);&#125; 这样，我们的UIImageView又可以响应事件了，原因是事件处理传递链向下传递了。 现在，在回到我们刚开始的问题，如何让btn响应的同时imageView也响应，我们这样做： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; image.userInteractionEnabled=YES; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click:(UIButton *)btn&#123; NSLog(@&quot;btn被点击了&quot;); //响应链继续传递 [btn.nextResponder touchesBegan:nil withEvent:nil]; &#125; 结果如下： 虽然最终，我们完成了这个需求，可是我建议你最好不要这么干，因为这样的逻辑是违背现实生活中人们的行为认知的，更重要的是，我们的项目最后也确实改掉了这样的逻辑~~~ 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"事件","slug":"事件","permalink":"http://huishao.cc/tags/事件/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中DES与MD5加密方案","slug":"02MD","date":"2015-04-02T16:00:00.000Z","updated":"2023-04-14T11:50:08.313Z","comments":true,"path":"2015/04/03/02MD/","link":"","permalink":"http://huishao.cc/2015/04/03/02MD/","excerpt":"","text":"MD5算法和DES算法是常见的两种加密算法。 MD5：MD5是一种不可逆的加密算法，按我的理解，所谓不可逆，就是不能解密，那么它有什么用的，它的用处大了，大多数的登录功能都会使用到这种算法。后面根据我的项目经验来介绍。 DES：一种使用密钥加密的块算法，所以，使用它加密时，需要一个密钥，加上一些设置和你需要加密的文段。 在IOS中，使用这两种加密算法非常简单，系统的&lt;CommonCrypto/CommonCrypto.h&gt;库给我们提供的边界的接口。在很多移动项目中，安卓平台和IOS平台的后台服务是统一的，比如一个登录功能是这样的流程： 1、客户端向服务端请求密钥，请求的参数是双方约定好的一个MD5加密的字符串。我们可以通过下面的进行第一步加密： 1234567891011121314- (NSString *)MD5Digest&#123; //要进行UTF8的转码 const char* input = [self UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(input, (CC_LONG)strlen(input), result); NSMutableString *digest = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) &#123; [digest appendFormat:@&quot;%02x&quot;, result[i]]; &#125; return digest;&#125; 通过这样的方法，我们可以很容易的得到一串MD5加密字符串，但是一定要和后台约定好，MD5加密的位数是16位还是32位，用上述方法加密出来的时32位，当然他们之间是有联系的，通过下面的方法可以将其转成16为： 1234567+(NSString *)trransFromMD532ToMD516:(NSString *)MD532&#123; NSString * string; for (int i=0; i&lt;24; i++) &#123; string=[MD532 substringWithRange:NSMakeRange(8, 16)]; &#125; return string;&#125; 还有一点需要注意，加密后的大小写也要对应。 2、服务端将得到的MD5串和以约定好的MD5串进行对比，如果一致，可以放行，返回密钥。 3、客户端取到密钥，将密钥再进行一次MD5加密，然后通过DES将要传送的数据加密发给服务器。 这一步至关重要，我们先看DES的加密代码 12345678910111213141516171819202122232425262728293031+(NSString *) encryptUseDES:(NSString *)clearText key:(NSString *)key andiv:(NSString *)iv&#123; //这个iv 是DES加密的初始化向量，可以用和密钥一样的MD5字符 NSData * date = [iv dataUsingEncoding:NSUTF8StringEncoding]; NSString *ciphertext = nil; NSUInteger dataLength = [clearText length]; NSData *textData = [clearText dataUsingEncoding:NSUTF8StringEncoding]; unsigned char buffer[1024]; memset(buffer, 0, sizeof(char)); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,//加密模式 kCCDecrypt 代表解密 kCCAlgorithmDES,//加密方式 kCCOptionPKCS7Padding,//填充算法 [key UTF8String], //密钥字符串 kCCKeySizeDES,//加密位数 [date bytes],//初始化向量 [textData bytes] , dataLength, buffer, 1024, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; NSLog(@&quot;DES加密成功&quot;); NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted]; Byte* bb = (Byte*)[data bytes]; ciphertext = [Base64 parseByteArray2HexString:bb]; &#125;else&#123; NSLog(@&quot;DES加密失败&quot;); &#125; return ciphertext;&#125; 几点注意： （1）加密方式，IOS官方提供的是如下几种 12345678910enum &#123; kCCAlgorithmAES128 = 0, kCCAlgorithmAES = 0, kCCAlgorithmDES, kCCAlgorithm3DES, kCCAlgorithmCAST, kCCAlgorithmRC4, kCCAlgorithmRC2, kCCAlgorithmBlowfish &#125;; （2）填充算法 123456enum &#123; /* options for block ciphers */ kCCOptionPKCS7Padding = 0x0001, kCCOptionECBMode = 0x0002 /* stream ciphers currently have no options */&#125;; 我们可以发现，官方提供的只有这两种，然而JAVA使用的却是 1kCCOptionPKCS7Padding 但是不用担心，在密钥是8位的时候，这两种填充算法加密出来的结果试一模一样的。 4、服务器通过相同的方式，解密出密文，通配安卓端。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"加密","slug":"加密","permalink":"http://huishao.cc/tags/加密/"},{"name":"DES","slug":"DES","permalink":"http://huishao.cc/tags/DES/"},{"name":"MD5","slug":"MD5","permalink":"http://huishao.cc/tags/MD5/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"AFNetWorking用法及缓存处理","slug":"01AF","date":"2015-04-01T16:00:00.000Z","updated":"2023-04-14T11:50:08.313Z","comments":true,"path":"2015/04/02/01AF/","link":"","permalink":"http://huishao.cc/2015/04/02/01AF/","excerpt":"","text":"AFNetWorking 在IOS开发中是一个经常会用的第三方开源库，其最好处是维护及时，源码开源。 常用GET与POST请求方法： POST请求： 123456789//初始化一个请求对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; //dic 为参数字典 [manager POST:url parameters:dic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; GET请求： 1234567AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; 这里有一个地方需要注意， 1[AFHTTPRequestOperationManager manager] 这个类方法我们点进源码可以发现： 123+ (instancetype)manager &#123; return [[self alloc] initWithBaseURL:nil];&#125; 这里初始化了一个返回了一个新的对象，并不是单例。 使用这样的下载方法，下载完成后的数据AFNetWorking会帮我们自动解析，但是有时候服务器给的数据并不标准，这时我们需要加上这个设置： manager.responseSerializer = [AFHTTPResponseSerializer serializer]; 这样我们将得到原始的HTTP返回给我们数据。 我们再来探究一下，下载成功后，回调方法里的参数到底是什么东西 1success:^(AFHTTPRequestOperation *operation, id responseObject) 其中，第二个参数 responseObject 是下载下来的data数据，可直接进行JSON等解析。 第一个参数，是个AFHTTPRequestOperation对象，来看源文件 123456789@interface AFHTTPRequestOperation : AFURLConnectionOperation@property (readonly, nonatomic, strong) NSHTTPURLResponse *response;@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;@property (readonly, nonatomic, strong) id responseObject;@end 可以发现，里面有一个成员便是responseObject，同时，AFHTTPRequestOperation是继承于AFURLConnectionOperation,我们在看看AFURLConnectionOperation这个类： 123456789101112131415161718192021222324252627282930313233343536373839@interface AFURLConnectionOperation : NSOperation &lt;NSURLConnectionDelegate, NSURLConnectionDataDelegate, NSSecureCoding, NSCopying&gt;@property (nonatomic, strong) NSSet *runLoopModes;@property (readonly, nonatomic, strong) NSURLRequest *request;@property (readonly, nonatomic, strong) NSURLResponse *response;@property (readonly, nonatomic, strong) NSError *error;@property (readonly, nonatomic, strong) NSData *responseData;@property (readonly, nonatomic, copy) NSString *responseString;@property (readonly, nonatomic, assign) NSStringEncoding responseStringEncoding;@property (nonatomic, assign) BOOL shouldUseCredentialStorage;@property (nonatomic, strong) NSURLCredential *credential;@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;@property (nonatomic, strong) NSInputStream *inputStream;@property (nonatomic, strong) NSOutputStream *outputStream;@property (nonatomic, strong) dispatch_queue_t completionQueue;@property (nonatomic, strong) dispatch_group_t completionGroup;@property (nonatomic, strong) NSDictionary *userInfo;- (instancetype)initWithRequest:(NSURLRequest *)urlRequest NS_DESIGNATED_INITIALIZER;- (void)pause;- (BOOL)isPaused;- (void)resume; 看到这里，就离AFNETWorking封装的源头很近了，里面的成员非常多，其中包含了大部分我们需要的信息，可以通过点语法取到，其中有输入输出流，错误信息，请求到的Data数据，以及请求到的字符串数据 1responseString 我们可以通过 1NSLog ( @&quot;operation: %@&quot; , operation. responseString ); 来打印查看请求到的原始信息。 几点注意： 1.关于崩溃url为nil 大多数这样的原因是url中有特殊字符或者中文字符，AFNETWorking并没有做UTF8的转码，需要： 1url = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 2.添加HttpHead字段的方法 1234 //为这个下载任务HTTP头添加@&quot;User-Agent&quot;字段 [manager.requestSerializer setValue:_scrData forHTTPHeaderField:@&quot;User-Agent&quot;]; //打印头信息 NSLog(@&quot;%@&quot;,manager.requestSerializer.HTTPRequestHeaders); 在下载请求中，经常会请求一些不长变化的数据，如果每次APP启动都进行请求，会消耗许多资源，并且有时候缓存的处理，可以大大改善用户体验。 在AFNETWorking中，并没有提供现成的缓存方案，我们可以通过写文件的方式，自行做缓存。 在下载方法中： 1234567[manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //写缓存 NSString *cachePath = @&quot;你的缓存路径&quot;;// /Library/Caches/MyCache [data writeToFile:cachePath atomically:YES]; succsee(data); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; &#125;]; 然后在每次下载前，进行如下判断： 12345 NSString * cachePath = @&quot;你的缓存路径&quot;; if ([[NSFileManager defaultManager] fileExistsAtPath:cachePath]) &#123; //从本地读缓存文件 NSData *data = [NSData dataWithContentsOfFile:cachePath]; &#125; 有时，我们的下载请求可能是用户的动作触发的，比如一个按钮。我们还应该做一个保护机制的处理， 123456789101112131415//初始化一个下载请求数组NSArray * requestArray=[[NSMutableArray alloc]init];//每次开始下载任务前做如下判断for (NSString * request in requestArray) &#123; if ([url isEqualToString:request]) &#123; return; &#125; &#125; [requestArray addObject:url]; //下载成功或失败后 [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [requestArray removeObject:url] &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [requestArray removeObject:url] &#125;]; 至此，一个比较完成AFNETWorking请求使用流程就完成了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://huishao.cc/tags/网络/"},{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"AFNetWorking","slug":"AFNetWorking","permalink":"http://huishao.cc/tags/AFNetWorking/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]}]}