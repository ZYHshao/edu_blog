{"meta":{"title":"珲少的技术博客","subtitle":"专注技术 有趣生活","description":"珲少的技术博客","author":"珲少","url":"http://huishao.cc"},"pages":[],"posts":[{"title":"Bootstrap响应式前端框架笔记三——代码与表格","slug":"270Bootstrap响应式前端框架笔记三——代码与表格","date":"2016-12-04T16:00:00.000Z","updated":"2021-07-12T07:11:52.053Z","comments":true,"path":"2016/12/05/270Bootstrap响应式前端框架笔记三——代码与表格/","link":"","permalink":"http://huishao.cc/2016/12/05/270Bootstrap响应式前端框架笔记三——代码与表格/","excerpt":"","text":"Bootstrap响应式前端框架笔记三——代码与表格一、代码在技术博客文章类页面的开发中，常常需要在文本总插入说明代码，使用code便签可以创建这种效果，示例如下： 12&lt;p&gt;code标签用于在文本中插入代码&lt;/p&gt;&lt;div&gt;定义变量a:&lt;code&gt;int a = 3; &lt;/code&gt;&lt;/div&gt; 效果如下： kbd标签可以用来提示进行键盘输入，示例如下： 12&lt;p&gt;kbd标签可以创建用户键盘输入的效果&lt;/p&gt;&lt;div&gt;使用键盘上的&lt;kbd&gt;control&lt;/kbd&gt;+&lt;kbd&gt;v&lt;/kbd&gt;来进行文本的粘贴&lt;/div&gt; 效果： 可以使用pre标签来进行成段代码的插入，同时可以使用pre-scrollable类来将代码块修饰为可滚动的，示例如下： 1234567&lt;pre class=\"pre-scrollable\"&gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=\"UTF-8\"&amp;gt; &amp;lt;link rel=\"stylesheet\" href=\"../bower_components/bootstrap/dist/css/bootstrap.min.css\" /&amp;gt; &amp;lt;title&amp;lt;代码与表格&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&lt;/pre&gt; 效果如下： 除了上面描述的标签和类外，一般情况下，程序中的变量会以斜体来显示，也可以使用var标签来包裹，程序输出结果可以使用samp标签来包裹。 二、表格为H5标签table添加table类可以使用Bootstrap定义的表格样式，示例如下: 1234567891011121314&lt;p&gt;使用table标签添加table类可以进行表格的创建&lt;/p&gt;&lt;table class=\"table\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： 为表格添加tabke-striped类可以实现斑马纹样式的表格，示例如下： 12345678910111213141516171819&lt;p&gt;使用table-striped类可以为表格添加斑马纹&lt;/p&gt;&lt;table class=\"table table-striped\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： Bootstrap默认的列表样式是不带边框的，可以使用table-bordered类来为列表添加边框，示例如下： 12345678910111213141516171819&lt;p&gt;使用table-boardered类可以为表格添加边框&lt;/p&gt;&lt;table class=\"table table-striped table-bordered\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： 使用table-hover类修饰的列表，当鼠标悬停时会有高亮效果，示例如下： 12345678910111213141516171819&lt;p&gt;使用table-hover类修饰的列表，当鼠标悬停时 会有高亮效果&lt;/p&gt;&lt;table class=\"table table-hover\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 使用.table-condensed类可以是默认的列表padding减半。 对于行标签tr与列表前th，开发者也可以使用如下类来修饰，为其指定状态： .active类：将此行或者此列标记为高亮状态。 .success类：将此行或者此列标记为成功状态。 .info类：将此行或者此列标记为详情状态。 .warning类：将此行或者此列标记为警告状态。 .danger类：将此行或者此列标记为危险状态。 示例代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;p&gt;为列表设置状态&lt;/p&gt;&lt;table class=\"table table-hover table-condensed\"&gt; &lt;thead&gt;学生表&lt;/thead&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"active\"&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"info\"&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;CJ&lt;/th&gt; &lt;th&gt;19&lt;/th&gt; &lt;/tr&gt; &lt;tr class=\"warning\"&gt; &lt;th&gt;3年1班&lt;/th&gt; &lt;th&gt;jaki&lt;/th&gt; &lt;th&gt;24&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;3年2班&lt;/th&gt; &lt;th class=\"danger\"&gt;Annay&lt;/th&gt; &lt;th&gt;22&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 效果如下： 列表元素也可以包裹在table-responsive类内，此时列表会变成响应式列表，当屏幕尺寸小于768px时，会自动出现水平滚动条。 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/codeAndGroup.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS开发CoreGraphics核心图形框架之八——层聚合","slug":"269iOS开发CoreGraphics核心图形框架之八——层聚合","date":"2016-12-03T16:00:00.000Z","updated":"2021-07-12T07:09:44.931Z","comments":true,"path":"2016/12/04/269iOS开发CoreGraphics核心图形框架之八——层聚合/","link":"","permalink":"http://huishao.cc/2016/12/04/269iOS开发CoreGraphics核心图形框架之八——层聚合/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之八——层聚合正常情况下，在使用CoreGraphics框架中的方法进行图形绘制时，每一闭合的图形都是一个独立的层，如果在绘制时添加了阴影效果，则通过阴影可以很明显的看到图形的分层情况，后绘制的图形在上层，先绘制的图形在下层，示例代码如下： 123456789101112131415-(void)drawRect:(CGRect)rect&#123; float width = rect.size.width/2; CGPoint center = CGPointMake(rect.size.width/2, rect.size.height/2); CGSize myShadowOffset = CGSizeMake (10, -20); CGContextRef myContext = UIGraphicsGetCurrentContext(); //设置阴影 CGContextSetShadow (myContext, myShadowOffset, 10); //绘制三个圆形 CGContextSetRGBFillColor (myContext, 0, 1, 0, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/2, center.y-width/4*3, width, width)); CGContextSetRGBFillColor (myContext, 0, 0, 1, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/4, center.y-width/4, width, width)); CGContextSetRGBFillColor (myContext, 1, 0, 0, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/4*3, center.y-width/4, width, width));&#125; 运行效果如下图所示： 从图中可以发现，所绘制的3个圆形并非是在同一层级上，有时开发者可能需要绘制边界复杂的图形，还以上面的例子来说，如果开发者需要绘制某个图形的边界是有3个圆形拼接而成，出现这样的层级效果是不合理的。CoreGraphics框架中也提供了进行图形聚合绘制的方法，示例如下： 123456789101112131415161718-(void)drawRect:(CGRect)rect&#123; float width = rect.size.width/2; CGPoint center = CGPointMake(rect.size.width/2, rect.size.height/2); CGSize myShadowOffset = CGSizeMake (10, -20); CGContextRef myContext = UIGraphicsGetCurrentContext(); CGContextSetShadow (myContext, myShadowOffset, 10); CGContextBeginTransparencyLayer (myContext, NULL); //开启图形聚合绘制 //之后的绘制代码都将绘制到统一层上 CGContextSetRGBFillColor (myContext, 0, 1, 0, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/2, center.y-width/4*3, width, width)); CGContextSetRGBFillColor (myContext, 0, 0, 1, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/4, center.y-width/4, width, width)); CGContextSetRGBFillColor (myContext, 1, 0, 0, 1); CGContextFillEllipseInRect(myContext, CGRectMake(center.x-width/4*3, center.y-width/4, width, width)); //结束聚合绘制 CGContextEndTransparencyLayer (myContext);&#125; 效果如下图所示： 有了聚合绘制这样的方法，进行复杂图形的绘制将更加灵活！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Bootstrap响应式前端框架笔记二——排版标签与类","slug":"268Bootstrap响应式前端框架笔记二——排版标签与类","date":"2016-12-02T16:00:00.000Z","updated":"2021-07-12T07:06:41.048Z","comments":true,"path":"2016/12/03/268Bootstrap响应式前端框架笔记二——排版标签与类/","link":"","permalink":"http://huishao.cc/2016/12/03/268Bootstrap响应式前端框架笔记二——排版标签与类/","excerpt":"","text":"Bootstrap响应式前端框架笔记二——排版标签与类Bootstrap中对h标签的字体和字号进行了微调，开发者除了可以直接使用这些标签进行标题的修饰外，还可以使用.h1到.h6类来将其他元素的字体进行修饰，示例如下： 123456789101112131415&lt;p&gt;h1 到 h6 标签的样式&lt;/p&gt;&lt;h1&gt;h1. Bootstrap heading&lt;/h1&gt;&lt;h2&gt;h2. Bootstrap heading&lt;/h2&gt;&lt;h3&gt;h3. Bootstrap heading&lt;/h3&gt;&lt;h4&gt;h4. Bootstrap heading&lt;/h4&gt;&lt;h5&gt;h5. Bootstrap heading&lt;/h5&gt;&lt;h6&gt;h6. Bootstrap heading&lt;/h6&gt;&lt;hr /&gt;&lt;p&gt;.h1 到 .h6 类的样式&lt;/p&gt;&lt;div class=\"h1\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h2\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h3\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h4\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h5\"&gt;h1. Bootstrap heading&lt;/div&gt;&lt;div class=\"h6\"&gt;h1. Bootstrap heading&lt;/div&gt; 在标题或者其他标签中使用small标签或者small类可以添加内部副标题，副标题除了字号会进行缩小调整外，还会修改文字的颜色，示例如下： 123&lt;p&gt;可以使用small标签或者.samll类来向标题中添加副标题&lt;/p&gt;&lt;h3&gt;h3标题 &lt;small&gt;small标签副标题&lt;/small&gt;&lt;/h3&gt;&lt;span class=\"h3\"&gt;h3Class类 &lt;span class=\"small\"&gt;small类副标题&lt;/span&gt;&lt;/span&gt; 效果如下： 使用.lead可以实现段落的强调显示，示例如下： 123&lt;p&gt;这是一个普通段落&lt;/p&gt;&lt;p class=\"lead\"&gt;这是一个强调段落&lt;/p&gt;&lt;p&gt;这是一个普通段落&lt;/p&gt; 效果如下： 使用mark标签或者mark类可以进行特殊文本的标记，如下： 12&lt;p&gt;使用mark标签可以实现部分文本进行标记&lt;/p&gt;&lt;div class=\"mark\"&gt;进行&lt;mark&gt;特殊文字&lt;/mark&gt;的标记&lt;/div&gt; 效果如下： 使用del标签或者s标签可以实现对文本添加删除线效果，如下： 1234&lt;p&gt;使用del标签或者s标签可以实现文本的删除效果&lt;/p&gt;&lt;del&gt;del标签的删除效果&lt;/del&gt;&lt;br /&gt;&lt;s&gt;s标签的删除效果&lt;/s&gt; 效果如下： 使用ins标签或者u标签可以实现为本文添加下划线效果，示例如下： 1234&lt;p&gt;使用ins标签或者u标签可以实现文本添加下划线&lt;/p&gt;&lt;ins&gt;ins标签的下划线效果&lt;/ins&gt;&lt;br /&gt;&lt;u&gt;u标签的下划线效果&lt;/u&gt; 效果如下： 使用strong标签可以对特殊本文进行着重标记，如下: 12&lt;p&gt;使用strong标签可以实现对特殊文本进行着重标记&lt;/p&gt;&lt;div&gt;进行文本的&lt;strong&gt;着重&lt;/strong&gt;标记&lt;/div&gt; 效果如下图 使用em标签可以进行特殊文本的斜体处理，如下： 12&lt;p&gt;使用em标签可以进行文本的斜体处理&lt;/p&gt;&lt;p&gt;进行&lt;em&gt;特殊文本&lt;/em&gt;的斜体处理&lt;/p&gt; 效果如下： 使用text-left类可以实现文本的左对齐布局，与之对应text-center将文本进行中心对齐布局，text-right类来将文本进行右对齐布局，text-justufy类设置文本进行自适应对齐，text-nowarp类将设置文本不换行的进行布局，示例如下： 12345678910&lt;mark&gt;text-left类进行左对齐布局&lt;/mark&gt;&lt;p class=\"text-left \"&gt;文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。文本左对齐排版。&lt;/p&gt;&lt;mark&gt;text-center类进行中心对齐布局&lt;/mark&gt;&lt;p class=\"text-center \"&gt;文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。文本居中对齐。&lt;/p&gt;&lt;mark&gt;text-right类进行右对齐布局&lt;/mark&gt;&lt;p class=\"text-right \"&gt;文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。文本右对齐。&lt;/p&gt;&lt;mark&gt;text-justify类进行自适应布局&lt;/mark&gt;&lt;p class=\"text-justify \"&gt;正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。正常方向布局。&lt;/p&gt;&lt;mark&gt;text-nowarp类进行不换行布局&lt;/mark&gt;&lt;p class=\"text-nowrap\"&gt;不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。不换行布局。&lt;/p&gt; 效果如下图： text-lowercase类可以将所有修饰的文本转换成小写，与之对应text-uppercase类可以将所有修饰的文本转换成大写，text-capitalize类则只会处理每个单词的首字母，将其转换为大写。示例如下： 123456&lt;mark&gt;将所有字母转换成小写字母&lt;/mark&gt;&lt;p class=\"text-lowercase\"&gt;My name is Jaki.&lt;/p&gt;&lt;mark&gt;将所有字母转换成大写字母&lt;/mark&gt;&lt;p class=\"text-uppercase\"&gt;My name is Jaki.&lt;/p&gt;&lt;mark&gt;将所有单词首字母字母转换成大写字母&lt;/mark&gt;&lt;p class=\"text-capitalize\"&gt;My name is Jaki.&lt;/p&gt; 效果如下图： 使用abbr标签可以进行某些内容的缩略显示，示例如下： 12使用abbr标签可以将某些文本进行缩略设置，当鼠标放置在对应文本上时，会显示标签中title所设置的内容&lt;abbr title=\"这个是详细信息\"&gt;信息&lt;/abbr&gt; 效果如下： 如果要在页面中进行内容的引用，可以使用blockquote标签进行包裹，在blockquote标签中可以继续嵌套footer标签来进行引用的标注，如下： 12345使用blockquote标签可以进行内容的引用，其中可以嵌套fooer标签进行标注&lt;blockquote&gt; &lt;p&gt;冰冻三尺，非一日之寒。&lt;/p&gt; &lt;footer&gt;俗语&lt;/footer&gt;&lt;/blockquote&gt; 效果如下图所示： .blockquote-reverse类可以将blockquote中的内容进行右对齐，示例如下： 12345&lt;hr /&gt; 使用blockquote标签可以进行内容的引用，其中可以嵌套fooer标签进行标注&lt;blockquote class=\"blockquote-reverse\"&gt; &lt;p&gt;冰冻三尺，非一日之寒。&lt;/p&gt; &lt;footer&gt;俗语&lt;/footer&gt;&lt;/blockquote&gt; 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/typeset.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"Bootstrap响应式前端框架笔记一——强大的栅格布局","slug":"267Bootstrap响应式前端框架笔记一——强大的栅格布局","date":"2016-11-30T16:00:00.000Z","updated":"2021-07-12T06:59:29.228Z","comments":true,"path":"2016/12/01/267Bootstrap响应式前端框架笔记一——强大的栅格布局/","link":"","permalink":"http://huishao.cc/2016/12/01/267Bootstrap响应式前端框架笔记一——强大的栅格布局/","excerpt":"","text":"Bootstrap响应式前端框架笔记一——强大的栅格布局一、Bootstrap？Bootstrap是一款HTML，Css和JavaScript开发框架，其也支持开发者进行自定义构建，开发者也可以只打包自己需要的功能模块使用。Bootstrap的中文网址如下： http://v3.bootcss.com/。 Bootstrap是一款响应式的编程框架，所谓响应式，是指在不同屏幕尺寸的设备上，使用Bootstrap开发的项目可以自动进行布局调整适配。其响应式布局的核心是栅格系统，栅格系统将浏览器分隔成一定数量的行和列。默认栅格系统将浏览器窗口分为12列，开发者可以为元素设置其在对应设备尺寸中所占的列数。 二、均分与尺寸适配Bootstrap将浏览器尺寸分为4个等级，分别为xs，sm，md和lg。xs是指浏览器宽度小于768时的状态，一般对应移动手机设备，sm指浏览器宽度大于768且小于992时的状态，其一般对应平板设备，md指浏览器宽度大于768且小于1200时的状态，一般对应正常的个人电脑，lg是指浏览器宽度大于1200时的状态。如下表所示： 在开发者使用栅格类对标签进行定义的时候，需要注意，如果只设置了高等级的栅格类，则在此等级以下的浏览器尺寸都将采用竖直堆叠，此等级及以上等级的浏览器尺寸中都将水平排列。例如，如果配置了两个标签的类都为为col-md-6，则在992以下尺寸的的浏览器中竖直堆叠布局，在992即以上尺寸的浏览器中都将水平均分一行。 栅格系统的一行中被分成了12列，默认一行中也最多可以添加12个列，如下代码演示了竖直堆叠布局与水平布局在栅格系统中的应用： 123456789101112131415161718192021222324252627282930313233343536373839&lt;body class=\"container\"&gt; &lt;p&gt;将md以上尺寸窗口宽度分为12份，md一下尺寸的窗口将竖直堆叠排列&lt;/p&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;div class=\"col-md-1\"&gt;.col-md-1&lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p&gt;将md以上尺寸的窗口宽度进行2等分，md一下尺寸的窗口将竖直堆叠排列&lt;/p&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p&gt;将md以上尺寸的窗口宽度进行2:1等分，md一下尺寸的窗口将竖直堆叠排列&lt;/p&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;.col-md-8&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;/div&gt; &lt;hr /&gt; &lt;p&gt;将xs以上尺寸的窗口宽度进行6等分，xs为最小等级&lt;/p&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;div class=\"col-xs-2\"&gt;.col-xs-2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 上面代码在窗口尺寸大于等于992时的效果如下所示： 将浏览器窗口缩小，可以看到，除了第4行可以继续保持6等分外，其它行等变成了竖直堆叠布局： 如果需要对移动设备和桌面是被进行布局的区别化，可以为某个标签配置多套不同等级下的栅格类，示例如下： 1234567&lt;p&gt;在md及以上尺寸窗口中进行4等分，在md以下尺寸sm以上尺寸窗口进行2等分布局，在sm以下储存窗口进行竖直堆叠布局&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-3 col-sm-6\"&gt;.col-md-3 .col-sm-6&lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6\"&gt;.col-md-3 .col-sm-6&lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6\"&gt;.col-md-3 .col-sm-6&lt;/div&gt; &lt;div class=\"col-md-3 col-sm-6\"&gt;.col-md-3 .col-sm-6&lt;/div&gt;&lt;/div&gt; 需要注意，默认Bootstrap中一行最多可以包含12列，如果列数超出12，将另起一行进行布局，示例如下： 123456&lt;p&gt;Bootstrap最多一行可以分配12列，超出将另起一行，例如下面三个div，宽度分别为8，3，4，第3个div将另起一行布局&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;.col-md-8&lt;/div&gt; &lt;div class=\"col-md-3\"&gt;.col-md-3&lt;/div&gt; &lt;div class=\"col-md-4 \"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt; 效果如下图： 三、列的调整很多场景下，每列元素的高度并不一定均等，在列高度不均等情况下的栅格布局，很可能会出现开发者意想不到的布局差错，示例代码如下： 123456&lt;p&gt;列高度不均等造成的布局错乱&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-4 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4 \"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt; 上面代码的栅格布局效果如下： 如图所示，开发者本意是将第3个div另起一行进行布局，由于前两个div高度的不均等，导致第3个div直接布局在了第2个div下面，可以通过visible-md-block等类来进行强制另起一行，示例如下： 12345678&lt;p&gt;解决列高度不均等造成的布局错乱&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-4 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"clearfix visible-md-block\"&gt;&lt;/div&gt; &lt;div class=\"col-md-4 \"&gt;.col-md-4&lt;/div&gt;&lt;/div&gt; 效果如下： 在使用栅格布局时，开发者也不需要将每一行中的12列都占满，可以通过列偏移设置来进行列的定位，示例如下： 123456789&lt;p&gt;进行列偏移操作&lt;/p&gt;&lt;p&gt;将占1/3行的一列向右便宜1/3行 使其固定在中间&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-offset-4\"&gt;.col-md-4 .col-md-offset-4&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-2\"&gt;.col-md-2&lt;/div&gt; &lt;div class=\"col-md-2 col-md-offset-8\"&gt;.col-md-2 .col-md-offset-8&lt;/div&gt;&lt;/div&gt; 效果如下： Bootstrap的栅格系统也支持进行列的嵌套，需要注意，在嵌套中也不可以超过12列，示例如下： 123456789&lt;p&gt;进行列的嵌套&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt;.col-md-8 &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;.col-md-6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下图所示： .col-md-push- 和 .col-md-pull-两个类可以方便的实现对列的移动，示例如下： 12345&lt;p&gt;进行列的移动&lt;/p&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-md-2 col-md-push-8\"&gt;.col-md-8 向右移动8格&lt;/div&gt; &lt;div class=\"col-md-2 col-md-pull-2\"&gt;.col-md-2 向左移动2格&lt;/div&gt;&lt;/div&gt; 效果如下： 另外，本篇博客中所有的实例代码及显示效果，在如下地址中，需要的可以自行对照学习。 http://zyhshao.github.io/bootStrapDemo/gridSystem.html。 前端学习新人，有志同道合的朋友，欢迎交流与指导，QQ群:541458536","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS开发CoreGraphics核心图形框架之七——图像处理","slug":"266iOS开发CoreGraphics核心图形框架之七——图像处理","date":"2016-11-27T16:00:00.000Z","updated":"2021-07-12T06:34:22.595Z","comments":true,"path":"2016/11/28/266iOS开发CoreGraphics核心图形框架之七——图像处理/","link":"","permalink":"http://huishao.cc/2016/11/28/266iOS开发CoreGraphics核心图形框架之七——图像处理/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之七——图像处理一、引言位图图像数据实际上一个像素阵列，其中每个像素代表了图像中的一个点。位图实际上只支持矩形区域的渲染，但是使用透明技术可以实现任意形状图像的渲染。开发者也可以对要进行渲染的图像进行旋转、切割等操作。 二、通过图像裁剪创建图像CoreGraphics框架中提供了许多方法来创建位图数据引用CGImageRef对象，其中封装在CGImage.h文件中。在UIKit框架中也提供了方便的接口供开发者进行CGImageRef与UIImage对象的相互转换。 通过CoreGraphics框架中提供的图像裁剪方法，开发者可以截取一张大图片中的一部分作为新的图像进行渲染。在Web开发中，为了减少请求次数，常常会将许多小图片合成一张大图片返回给前端，同时还会给前端返回一个json文件，文件中存放着每个独立小图的坐标位置，前端在使用时进行截取即可，这种图片常常被称作雪碧图。在iOS开发中游戏开发中，很多游戏引擎也提供了类似的方法，方便开发者对游戏素材进行管理。实际上，通过CoreGraphics框架，开发者也可以自己实现一套这样的图片加载逻辑，如果在自己的应用中，同时需要异步加载的小图片很多，也可以设计成下载一张大图后从中截取需要的图片。进行图像截取的示例代码如下： 123456789101112-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image\"].CGImage; CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), orignImage); CGImageRef rectImage = CGImageCreateWithImageInRect(orignImage, CGRectMake(300, 400, 800, 400)); CGContextDrawImage(contextRef, CGRectMake(0, 220, 320, 200), rectImage); CGImageRelease(orignImage); CGImageRelease(rectImage);&#125; 效果如下图所示： 需要注意，CGContextDrawImage()方法渲染的图像是上下翻转的，可以通过调整坐标系来将图片翻转回来。 三、通过膜层来实现图像的自定义裁剪通过Mask膜层可以实现炫酷的图像裁剪与风格重绘。膜层可以简单的理解为将一个图层追加到原图层上，但需要注意，图层中颜色为纯黑的部分，会按照原图绘制，纯白的部分会被完全遮挡，这中间的颜色会以特定的算法进行alpha值的更改。例如将如下图片作为膜层绘制到原图像上： 代码如下： 123456789101112131415161718192021-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image\"].CGImage; CGImageRef maskRef = [UIImage imageNamed:@\"maskImage\"].CGImage; //通过图片数据创建膜层 CGImageRef mask = CGImageMaskCreate(CGImageGetWidth(maskRef), CGImageGetHeight(maskRef), CGImageGetBitsPerComponent(maskRef), CGImageGetBitsPerPixel(maskRef), CGImageGetBytesPerRow(maskRef), CGImageGetDataProvider(maskRef), nil, YES); CGImageRef resultImage = CGImageCreateWithMask(orignImage, mask); CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), resultImage); CGImageRelease(orignImage); CGImageRelease(maskRef); CGImageRelease(mask);&#125; 效果如下图所示： 除了使用图片膜层来对原图像数据进行裁剪处理外，还可以通过颜色数据定义膜层来进行裁剪。这个方法就能加强大了，其可以将图像中某个范围的颜色所对应的所有区域裁剪出来。示例代码如下： 1234567891011121314-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image2\"].CGImage; const CGFloat myMaskingColors[6] = &#123;35, 154, 23, 194, 103, 214&#125;; CGImageRef mask2 = CGImageCreateWithMaskingColors(orignImage, myMaskingColors); CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), mask2); CGImageRelease(orignImage); CGImageRelease(mask2);&#125; CGImageCreateWithMaskingColors()这个方法需要两个参数，第一个参数是要进行裁剪的图像，那二个参数需要设置为一个表示色彩的数组，需要注意，这个数组中元素的个数需要是当前色彩空间颜色原色数的两倍，例如RGB色彩空间对应这个数组需要有6个元素{min1,max1,min2,max2,min3,max3}。之后会对图像数据中的每一个像素点进行遍历，假如此像素点的颜色值为{c1,c2,c3}。则当满足如下条件时，这个像素点会被裁剪： min1&lt;c1&lt;max1,min2&lt;c2&lt;max2,min3&lt;c3&lt;max3 需要注意，使用这种方式进行膜层裁剪，原图像不可以有alpha通道，色值的取值范围为0-255之间。上面示例代码会将原图像裁剪成如下效果： 对于被裁剪出来的部分，开发者可以使用其他颜色进行填充，示例代码如下： 123456789101112131415-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image2\"].CGImage; //设置填充 [[UIColor redColor] setFill]; CGContextFillRect(contextRef, CGRectMake(0, 0, 320, 200)); const CGFloat myMaskingColors[6] = &#123;35, 154, 23, 194, 103, 214&#125;; CGImageRef mask2 = CGImageCreateWithMaskingColors(orignImage, myMaskingColors); CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), mask2); CGImageRelease(orignImage);&#125; 效果如下图： 除了上面介绍了两种对图像进行裁剪的方法外，CoreGraphics框架中还提供了一种裁剪方式，示例代码如下： 12345678910111213141516171819-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef orignImage = [UIImage imageNamed:@\"image2\"].CGImage; CGImageRef maskRef = [UIImage imageNamed:@\"maskImage\"].CGImage; CGImageRef mask = CGImageMaskCreate(CGImageGetWidth(maskRef), CGImageGetHeight(maskRef), CGImageGetBitsPerComponent(maskRef), CGImageGetBitsPerPixel(maskRef), CGImageGetBytesPerRow(maskRef), CGImageGetDataProvider(maskRef), nil, YES); //进行膜层的裁剪 CGContextClipToMask(contextRef, CGRectMake(0, 0, 320, 200), mask); CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), orignImage); CGImageRelease(orignImage);&#125; 四、进行图像混合使用CoreGraphics框架也可以绘制复杂的图像混合效果，在进行图像混合时，需要先绘制背景图像，之后设置图像混合模式，在绘制前景图像，CoreGraphics会根据混合模式来进行最后图像的绘制。例如使用如下背景图像来与前景图像来进行混合： 背景图像： 前景图像： 示例代码如下： 12345678910111213-(void)drawRect:(CGRect)rect&#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); //进行坐标系的翻转 CGContextTranslateCTM(contextRef, 0, rect.size.height); CGContextScaleCTM(contextRef, 1.0, -1.0); CGImageRef background = [UIImage imageNamed:@\"background\"].CGImage; CGContextDrawImage(contextRef, CGRectMake(60, 25, 200, 150), background); CGContextSetBlendMode(contextRef, kCGBlendModeNormal); CGImageRef orignImage = [UIImage imageNamed:@\"image2\"].CGImage; CGContextDrawImage(contextRef, CGRectMake(0, 0, 320, 200), orignImage); CGImageRelease(background); CGImageRelease(orignImage);&#125; kCGBlendModeNormal模式的混合就是简单覆盖，前景图像会完全将背景图像覆盖，运行效果如下： kCGBlendModeMultiply模式是叠加混合模式，其会将前景图alpha化，效果如下： kCGBlendModeScreen模式会将前景图进行裁剪，最终的结果颜色将比原图轻，效果如下： kCGBlendModeOverlay模式也会将前景图进行裁剪，会保持原图色彩，效果如下： kCGBlendModeDarken混合模式会将原图色值加深，效果如下： kCGBlendModeLighten在混合时则会选择色值较轻的图像进行混合，效果如下： kCGBlendModeColorDodge混合模式效果如下： kCGBlendModeColorBurn混合模式效果如下： kCGBlendModeSoftLight为柔光混合模式，效果如下： kCGBlendModeHardLight为重光混合模式，效果如下： kCGBlendModeDifference差异混合模式会取颜色的逆向值，效果如下： kCGBlendModeExclusion混合模式效果如下： kCGBlendModeHue混合模式会改变色彩的饱和度，效果如下： kCGBlendModeSaturation混合模式效果如下： kCGBlendModeColor混合模式效果如下： kCGBlendModeLuminosity光影混合模式会将前景图进行黑白化，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"使用Express快速搭建前端项目框架","slug":"265使用Express快速搭建前端项目框架","date":"2016-11-26T16:00:00.000Z","updated":"2021-07-12T06:31:48.290Z","comments":true,"path":"2016/11/27/265使用Express快速搭建前端项目框架/","link":"","permalink":"http://huishao.cc/2016/11/27/265使用Express快速搭建前端项目框架/","excerpt":"","text":"使用Express快速搭建前端项目框架Express是基于Node.js的前端Web开发框架，使用其可以简洁快速的创建健壮友好的API服务。在前端或移动端的开发过程中，可以借助Express的这项功能模拟API数据，方便开发调试。 Express是基于Node.js平台的，因此在安装Express之前，需要先安装Node.js。使用如下命令来检查系统中所安装的node版本： 1node -v 如果系统中没有安装Node.js，可以在如下网站进行下载安装： https://nodejs.org/en/。 创建一个测试工程目录，用于存放Express项目框架，首先在终端，使用如下命令进行Express的全局安装： 1npm install express-generator -g 需要注意，很多时候国内网络使用npm的时候会非常慢，可以通过如下命令来修改仓库源。 1npm install -g cnpm --registry=https://registry.npm.taobao.org 之后使用cnpm来进行包的安装： 1cnpm install express-generator -g 安装好Express后，在新建的文件夹目录下，执行Express的初始化： 1express 如果文件夹不为空，会提示是否继续操作，输入yes后回车即可。 初始化完成后的Express项目结构如下： 其中会默认创建一个package.json文件，其中会添加许多依赖包，在项目目录中执行如下命令来安装这些依赖： 1npm install 依赖安装完成后，工程中会多一个node_modules的文件夹，里面是所有依赖包文件。 再来看Express模板中的文件，其中bin文件夹下面的www.js文件是服务的启动文件，其中启动了HTTP的服务，默认端口为3000。routes文件夹下面的文件用于配置api路由，默认有index.js与users.js两个。app.js文件中对api进行了初始化与配置。可以在users.js中添加一个测试api如下： 123456789101112var express = require('express');var router = express.Router();/* 这个是默认生成的. */router.get('/', function(req, res, next) &#123; res.send('respond with a resource');&#125;);/* 添加一个测试api*/router.get('/testAPi',function(rep,res,next)&#123; res.send('&#123;name:jaki,age:24&#125;');&#125;);module.exports = router; 在项目目录下通过终端执行如下命令来将服务开启： 1node bin/www 如果服务启动成功，在浏览器输入http://127.0.0.1:3000/users/testAPi会返回我们send()方法传递的字符串。 小提示：MacOS系统在服务进行中，可以使用control+c来释放端口的监听，如果不小心使用control+z或者关闭了终端，会导致所监听端口的无法释放，下次如果再次启动node服务，会报Port 3000 is already in use的错误，可以使用如下方法来进行所监听端口的释放： 首先使用如下命令查看所有监听某个端口的服务，例如3000端口： 1sudo lsof -i:3000 之后终端会将服务名与进行id告诉我们，如下： 12COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 829 vip 13u IPv6 0x9c3536500e84e203 0t0 TCP *:hbci (LISTEN) 使用如下命令来杀死对应进程即可： 1sudo kill -9 829","categories":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}],"tags":[],"keywords":[{"name":"前后端","slug":"前后端","permalink":"http://huishao.cc/categories/前后端/"}]},{"title":"iOS开发CoreGraphics核心图形框架之六——梯度渐变","slug":"264iOS开发CoreGraphics核心图形框架之六——梯度渐变","date":"2016-11-14T16:00:00.000Z","updated":"2021-07-12T02:40:32.427Z","comments":true,"path":"2016/11/15/264iOS开发CoreGraphics核心图形框架之六——梯度渐变/","link":"","permalink":"http://huishao.cc/2016/11/15/264iOS开发CoreGraphics核心图形框架之六——梯度渐变/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之六——梯度渐变一、引言 关于颜色梯度渐变视图的创建，CoreGraphics框架中提供了两个类型CGShadingRef与CGGradientRef。CoreGraphics框架在绘制梯度渐变时，有两种绘制方式，分别为轴向绘制与径向绘制。轴向绘制是指确定两个点，起点与终点连接的直线作为梯度渐变的轴，垂直于此轴的线共享相同的颜色，由起点向终点进行颜色渐变。径向渐变是指由两个圆连接成圆台，在同一圆周上的所有点共享相同的颜色，由起始圆向终点圆进行颜色渐变。 轴向渐变： 径向渐变： 前面说到，CGShadingRef与CGGradientRef都可以用于创建梯度渐变视图，这两个类型在使用使又有一些不同，CGShadingRef在使用使需要开发者为其提供一个颜色计算方法，CGGradientRef则不需要，相比之下，CGGradientRef更像是为了方便开发者使用而从CGShadingRef中扩展出的一个类型。 二、使用CGGradientRef创建梯度渐变视图创建一个UIView子类，在其drawRect:方法中编写如下测试代码： 123456789101112131415-(void)drawRect:(CGRect)rect&#123; CGGradientRef gradientRef; CGColorSpaceRef colorSpaceRef; CGFloat locs[2] = &#123;0,1&#125;; CGFloat colors[8] = &#123; 1.0, 0, 0, 1.0, // 前4个为起始颜色的rgba 0, 1, 0, 1.0 &#125;; // 后4个为结束颜色的rgba colorSpaceRef = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB); gradientRef = CGGradientCreateWithColorComponents (colorSpaceRef, colors, locs, 2); CGContextRef contextRef = UIGraphicsGetCurrentContext(); //这个方法用于创建轴向渐变// CGContextDrawLinearGradient(contextRef, gradientRef, rect.origin, CGPointMake(rect.origin.x+rect.size.width, rect.origin.y+rect.size.height), 0); //这个方法用于创建径向渐变 CGContextDrawRadialGradient(contextRef, gradientRef, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2), rect.size.width/2, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2), rect.size.width/4, 0);&#125; CGContextDrawRadiaGradient()方法中的参数解析如下： 1234567891011121314151617/*c:绘图上下文gradieent:渐变对象startCenter:渐变起始圆心startRadius:渐变起始圆半径endCenter:渐变终止圆心endRadius:渐变终止圆半径options:渐变的填充风格 设置为0则不进行填充typedef CF_OPTIONS (uint32_t, CGGradientDrawingOptions) &#123; kCGGradientDrawsBeforeStartLocation = (1 &lt;&lt; 0), //起点以前也进行填充 kCGGradientDrawsAfterEndLocation = (1 &lt;&lt; 1) //终点之后也进行填充&#125;;*/ CG_EXTERN void CGContextDrawRadialGradient(CGContextRef cg_nullable c, CGGradientRef cg_nullable gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options) CG_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0); CGGradient中定义的方法解析如下： 1234567891011121314151617181920212223242526//获取CGGradient类在CoreGraphics框架中的idCFTypeID CGGradientGetTypeID(void);//创建CGGradientRef/*space:色彩空间components:色值数组locations:渐变临界点count:locations数组中元素个数*/CGGradientRef __nullable CGGradientCreateWithColorComponents( CGColorSpaceRef cg_nullable space, const CGFloat * cg_nullable components, const CGFloat * __nullable locations, size_t count);//创建CGGradientRef 这个方法locations中的元素个数需要与colors中的对应/*space:色彩空间colors:颜色数组locations:渐变临界点*/CGGradientRef __nullable CGGradientCreateWithColors( CGColorSpaceRef __nullable space, CFArrayRef cg_nullable colors, const CGFloat * __nullable locations);//进行引用计数+1CGGradientRef cg_nullable CGGradientRetain( CGGradientRef cg_nullable gradient);//进行引用计数-1void CGGradientRelease(CGGradientRef cg_nullable gradient); 三、CGShadingRef的应用CGShadingRef的使用就不像CGGradientRef那么方便，其中方法解析如下： 1234567891011121314151617181920212223//获取CGShadingRef在CoreGraphics框架中的idCFTypeID CGShadingGetTypeID(void);//创建轴向渐变的CGShadingRef对象/*space:色彩空间start:起始点end:结束点function:颜色计算函数extendStart:是否填充起始点以前extendEnd:是否填充结束点之后*/CGShadingRef __nullable CGShadingCreateAxial( CGColorSpaceRef cg_nullable space, CGPoint start, CGPoint end, CGFunctionRef cg_nullable function, bool extendStart, bool extendEnd);//创建径向渐变的CGShadingRef对象 参数同上CGShadingRef __nullable CGShadingCreateRadial( CGColorSpaceRef cg_nullable space, CGPoint start, CGFloat startRadius, CGPoint end, CGFloat endRadius, CGFunctionRef cg_nullable function, bool extendStart, bool extendEnd);//引用计数+1CGShadingRef cg_nullable CGShadingRetain(CGShadingRef cg_nullable shading);//引用计数-1void CGShadingRelease(CGShadingRef cg_nullable shading); 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//颜色计算函数/*info 是开发者后面将传入的色彩空间的参数个数in 为输入参数 对应0-1之间out 为输出参数 为所对应颜色空间的每个色值*/static void myCalculateShadingValues (void *info, const CGFloat *in, CGFloat *out)&#123; size_t k, components; double frequency[4] = &#123; 55, 220, 110, 0 &#125;; //获取色彩空间的色值数 components = (size_t)info; for (k = 0; k &lt; components - 1; k++) //*out++ 的作用是指针右移 out指针可以理解为数组 右移作用和数组赋值一致 *out++ = (1 + sin(*in * frequency[k]))/2; //最后追加上透明度值 *out++ = 1; // alpha&#125;-(void)drawRect:(CGRect)rect&#123; size_t numComponents; //输入参数的范围 其中元素个数是 输入参数个数的两倍 static const CGFloat input_value_range [2] = &#123; 0, 1 &#125;; //输出参数的范围 其中元素个数是 输出参数个数的两倍 static const CGFloat output_value_ranges [8] = &#123; 0, 1, 0, 1, 0, 1, 0, 1 &#125;; //组合回调函数 static const CGFunctionCallbacks callbacks = &#123; 0, &amp;myCalculateShadingValues, NULL &#125;; //获取色彩空间的色值数 numComponents = 1 + CGColorSpaceGetNumberOfComponents (CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB)); //创建CGFunctionRef CGFunctionRef func = CGFunctionCreate ((void *) numComponents, 1, input_value_range, numComponents, output_value_ranges, &amp;callbacks); CGPoint startPoint, endPoint; CGFloat startRadius, endRadius; CGAffineTransform myTransform; //起始圆位置 startPoint = CGPointMake(0.25,0.3); //半径 startRadius = .1; //终止圆位置 endPoint = CGPointMake(.7,0.7); //半径 endRadius = .25; //创建CGShadingRef CGShadingRef myShading = CGShadingCreateRadial (CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB), startPoint, startRadius, endPoint, endRadius, func, false, false); CGContextRef context = UIGraphicsGetCurrentContext(); //进行transform的映射 myTransform = CGAffineTransformMakeScale(320, 568); CGContextConcatCTM(context, myTransform); CGContextSaveGState(context); //进行绘制 CGContextDrawShading(context, myShading); &#125; 上面的示例代码效果如下图： 四、一些小技巧灵活的应用CGContextDrawRadialGradient()方法可以创建出伪立体效果的图形，例如如下代码： 123456789101112-(void)drawRect:(CGRect)rect&#123; CGGradientRef gradientRef; CGColorSpaceRef colorSpaceRef; CGFloat locs[2] = &#123;0,1&#125;; CGFloat colors[8] = &#123; 1.0, 0, 0, 1.0, // 前4个为起始颜色的rgba 1, 1, 1, 1.0 &#125;; // 后4个为结束颜色的rgba colorSpaceRef = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB); gradientRef = CGGradientCreateWithColorComponents (colorSpaceRef, colors, locs, 2); CGContextRef contextRef = UIGraphicsGetCurrentContext(); CGContextDrawRadialGradient(contextRef, gradientRef, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2), rect.size.width/2, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2-100), 0, 0);&#125; 通过调整内圆的位置和半径，可以做到光影的移动，效果如下： 1234567891011121314151617181920//模拟金属原子-(void)drawRect:(CGRect)rect&#123; CGGradientRef gradientRef; CGColorSpaceRef colorSpaceRef; CGFloat locs[8] = &#123;0,0.2,0.4,0.5,0.6,0.8,0.9,1.0&#125;; CGFloat colors[64] = &#123; 1.0, 0, 0, 1.0, // 前4个为起始颜色的rgba 0.0, 1, 0, 1.0, 0.0, 0, 1, 1.0, 1.0, 0, 0, 1.0, 0.0, 1, 0, 1.0, 1.0, 0, 0, 1.0, 1.0, 1, 0, 1.0, 1, 1, 1, 1.0 &#125;; // 后4个为结束颜色的rgba colorSpaceRef = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB); gradientRef = CGGradientCreateWithColorComponents (colorSpaceRef, colors, locs, 8); CGContextRef contextRef = UIGraphicsGetCurrentContext();// CGContextDrawLinearGradient(contextRef, gradientRef, rect.origin, CGPointMake(rect.origin.x+rect.size.width, rect.origin.y+rect.size.height), 0); CGContextDrawRadialGradient(contextRef, gradientRef, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2), rect.size.width/2, CGPointMake(rect.origin.x+rect.size.width/2, rect.origin.y+rect.size.height/2-100), 0, 0);&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之四——变换函数","slug":"263iOS开发CoreGraphics核心图形框架之五——Patterns模型的应用","date":"2016-11-01T16:00:00.000Z","updated":"2021-07-12T02:39:40.981Z","comments":true,"path":"2016/11/02/263iOS开发CoreGraphics核心图形框架之五——Patterns模型的应用/","link":"","permalink":"http://huishao.cc/2016/11/02/263iOS开发CoreGraphics核心图形框架之五——Patterns模型的应用/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之五——Patterns模型的应用一、引言Patterns称为模型可能并不直观，说一个场景我们或许就可以更加容易的理解Patterns。在开发中，开发者经常会遇到这样的需求，将某个图片或者某个图形进行平铺作为界面的背景，当然iOS中有现成的方法来将图片转换为背景色进行背景的渲染，但是这种方式并不太灵活，例如背景花纹的着色，背景图片的平铺间距设置等需求都无法满足。Patterns就是用来处理这样的需求。 Patterns可以理解为一个模型单元，即花纹背景中的一个花纹单元，开发者可以自定义这个单元的绘制内容，一旦创建了CGPatternRef引用，开发者就可以将它向普通颜色一样进行使用，可以进行填充，可以进行路径绘制等。 二、创建CGPatternRef模型引用在UIView子类的drawRect:方法中来做如下的测试： 12345678910111213141516171819- (void)drawRect:(CGRect)rect &#123; // Drawing code //创建回调结构体 后面会介绍 CGPatternCallbacks callback = &#123;0,&amp;drawPatternCallback,&amp;releaseInfoCallback&#125;; //创建模型引用 CGPatternRef pattren = CGPatternCreate(NULL, CGRectMake(0, 0, 30,30), CGAffineTransformIdentity, 35, 35, kCGPatternTilingConstantSpacing, false, &amp;callback); //创建颜色数组 代表RGBA的值 static const CGFloat color[4] = &#123; 0, 1, 0, 1 &#125;; //创建颜色空间 CGColorSpaceRef baseSpace = CGColorSpaceCreateWithName (kCGColorSpaceGenericRGB); CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern (baseSpace); //设置填充颜色空间 CGContextSetFillColorSpace (UIGraphicsGetCurrentContext(), patternSpace); //设置填充模型 CGContextSetFillPattern(UIGraphicsGetCurrentContext(), pattren, color); //进行填充 CGContextFillRect(UIGraphicsGetCurrentContext(), CGRectMake(0, 0, 200, 200)); &#125; 上面的示例代码中，有几个地方需要进行介绍： CGPatternCallBacks是CoreGraphics框架的CGPattern.h文件中定义的一个结构体，这个结构体组合了模型Pattern的版本，创建回调和释放回调。创建回调和释放回调需要传入两个方法块的地址，即block。这两个block的格式定义如下： 1234567//创建模型回调的格式定义//info参数为需要传递给回调函数的数据//content参数为所绘制的图形上下文typedef void (*CGPatternDrawPatternCallback)(void * __nullable info, CGContextRef cg_nullable context);//释放回调 开发者可以在其中进行内存的释放typedef void (*CGPatternReleaseInfoCallback)(void * __nullable info); 我们所实现的drawPatternCallback(),releaseInfoCallback()方法示例如下： 123456789101112131415161718192021222324252627// 绘制 回调#define PSIZE 16void drawPatternCallback(void *info,CGContextRef myContext)&#123;//这里我借用了官方文档中的代码 如下的代码将绘制出五角星 int k; double r, theta; r = 0.8 * PSIZE / 2; theta = 2 * M_PI * (2.0 / 5.0); // 144 degrees CGContextTranslateCTM (myContext, PSIZE/2, PSIZE/2); CGContextMoveToPoint(myContext, 0, r); for (k = 1; k &lt; 5; k++) &#123; CGContextAddLineToPoint (myContext, r * sin(k * theta), r * cos(k * theta)); &#125; CGContextClosePath(myContext); CGContextFillPath(myContext);&#125;// 移除 回调void releaseInfoCallback(void *info) &#123; &#125; 在回过来看创建CGPatternRef的方法： 123456789101112/*这个方法第1个参数为要传递进创建模型方法的信息第2个参数为设置每个模型单元的尺寸第3个参数设置模型的几何变换第4个参数设置模型的整体宽度 通过这个参数可以设置边距第5个参数设置模型的整体高度 通过这个参数可以设置边距第6个参数设置模型的渲染方式第7个参数设置为有色渲染还是无色渲染 第8个参数设置相关回调结构体*/CGPatternRef pattren = CGPatternCreate(NULL, CGRectMake(0, 0, 30,30), CGAffineTransformIdentity, 35, 35, kCGPatternTilingConstantSpacing, false, &amp;callback); 关于模型的渲染方式，需要设置为CGPatternTiling类型的枚举，如下： 12345678typedef CF_ENUM (int32_t, CGPatternTiling) &#123; //无失真的平铺 将调整单元之间的间距 kCGPatternTilingNoDistortion, //细微调整单元大小 kCGPatternTilingConstantSpacingMinimalDistortion, //恒定间距，通过调整单元大小实现 会失真 kCGPatternTilingConstantSpacing&#125;; CGContextSetFillPattern()方法用于将模型设置为要渲染界面的颜料，之后调用CGContextStrokePath(), CGContextFillPath(), CGContextFillRect()等相关方法都可以实现将模型铺平渲染到指定容器。需要注意，CGContextSetFillPattern()方法中第1个参数为绘图上下文，第2个参数为模型CGPatternRef引用，第3个参数为一个色值数组，这里如果模式是无色渲染方式创建的，需要传入4个元素的RGBA数组，如果是有色模式创建的，需要传入一个透明度值，可以是float类型的指针。 运行工程，效果如下图所示: 将代码简单修改如下，就可以实现以五角星围成的矩形： 1234567891011121314- (void)drawRect:(CGRect)rect &#123; // Drawing code CGPatternCallbacks callback = &#123;0,&amp;drawPatternCallback,&amp;releaseInfoCallback&#125;; CGPatternRef pattren = CGPatternCreate(NULL, CGRectMake(0, 0, 30,30), CGAffineTransformIdentity, 30, 30, kCGPatternTilingConstantSpacing, false, &amp;callback); static const CGFloat color[4] = &#123; 1, 0, 0, 1 &#125;; CGColorSpaceRef baseSpace; CGColorSpaceRef patternSpace; baseSpace = CGColorSpaceCreateWithName (kCGColorSpaceGenericRGB); patternSpace = CGColorSpaceCreatePattern (baseSpace); CGContextSetStrokeColorSpace (UIGraphicsGetCurrentContext(), patternSpace); CGContextSetStrokePattern(UIGraphicsGetCurrentContext(), pattren, color); CGContextSetLineWidth(UIGraphicsGetCurrentContext(), 40); CGContextStrokeRect(UIGraphicsGetCurrentContext(), CGRectMake(0, 0, 200, 200));&#125; 效果如下: 三、CGPattern中其他方法123456//获取CGPattern在CoreGraphics框架中的idCFTypeID CGPatternGetTypeID(void);//进行引用计数加1CGPatternRef cg_nullable CGPatternRetain(CGPatternRef cg_nullable pattern);//进行引用计数减1void CGPatternRelease(CGPatternRef cg_nullable pattern); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之四——变换函数","slug":"262iOS开发CoreGraphics核心图形框架之四——变换函数","date":"2016-10-29T16:00:00.000Z","updated":"2021-07-12T02:36:31.763Z","comments":true,"path":"2016/10/30/262iOS开发CoreGraphics核心图形框架之四——变换函数/","link":"","permalink":"http://huishao.cc/2016/10/30/262iOS开发CoreGraphics核心图形框架之四——变换函数/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之四——变换函数一、引言在上一篇博客中，介绍了有关CGContext相关操作方法，其中可以直接调用一些方法来进行所绘制图形的平移，缩放，翻转等变换。对于图形了几何变换，开发者也可以采用另一种方式实现，CoreGraphics框架中提供了CGAffineTransform结构体，这个结构体中定义了图形变换的相关信息。 关于CGContext的相关内如博地址客如下：https://my.oschina.net/u/2340880/blog/759070。 二、使用CGAffineTransform相关函数进行绘制图形的几何变换CGAffineTransform中定义的方法即意义列举如下： 123456789101112131415161718192021222324252627282930//创建标准的变换矩阵CGAffineTransform CGAffineTransformIdentity;//手动创建变换矩阵CGAffineTransform CGAffineTransformMake(CGFloat a, CGFloat b, CGFloat c, CGFloat d, CGFloat tx, CGFloat ty);//创建平移变换CGAffineTransform CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);//创建缩放变换CGAffineTransform CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);//创建旋转变换CGAffineTransform CGAffineTransformMakeRotation(CGFloat angle);//判断某个变化是否是来自标准矩阵的变换bool CGAffineTransformIsIdentity(CGAffineTransform t);//对某个变换矩阵进行平移变换CGAffineTransform CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty);//对某个变换矩阵进行缩放变换CGAffineTransform CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy);//对某个变换矩阵进行旋转变换CGAffineTransform CGAffineTransformRotate(CGAffineTransform t, CGFloat angle);//对某个变换矩阵进行翻转变换CGAffineTransform CGAffineTransformInvert(CGAffineTransform t);//对两个变换矩阵进行计算CGAffineTransform CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);//比较两个变换矩阵是否相同bool CGAffineTransformEqualToTransform(CGAffineTransform t1, CGAffineTransform t2);//获取应用变换后某点的坐标CGPoint CGPointApplyAffineTransform(CGPoint point, CGAffineTransform t);//获取应用变换后某个区域的尺寸CGSize CGSizeApplyAffineTransform(CGSize size, CGAffineTransform t);//获取应用变换后某个区域的位置和尺寸CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform t); 上述变换方法可以直接作用于View，示例如下： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 200, 200)]; view.backgroundColor =[UIColor whiteColor]; view.image = [UIImage imageNamed:@\"image\"]; view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, M_PI_4); [self.view addSubview:view];&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间","slug":"261 iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间","date":"2016-10-19T16:00:00.000Z","updated":"2021-07-12T02:35:47.245Z","comments":true,"path":"2016/10/20/261 iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间/","link":"","permalink":"http://huishao.cc/2016/10/20/261 iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之三——颜色与色彩空间一、引言颜色的实质是表示颜色的二进制数据，如果没有确定的规则，则这些二进制数据完全没有意义。所谓色彩空间，即是表示这些颜色数据信息是如何解释的。同样的一张图片，在不同的色彩空间下，其渲染的模样将有很大的不同。在CoreGraphics框架中，与色彩相关的功能主要有CGColor与CGColorSpace构成。 二、关于CGColor相关方法的解析CGColorRef是CoreGraphics框架中用于描述颜色的引用类型，其中常用方法解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//根据色彩空间创建一个CGColorRef实例/*需要注意，这个方法中的第2个参数需要传递一个float数据，其需要和第1个参数的色彩空间意义对应例如在RGBA色彩空间中，float数组中需要传递4个值，分别表示红绿蓝和透明度*/CGColorRef __nullable CGColorCreate(CGColorSpaceRef cg_nullable space, const CGFloat * cg_nullable components);//创建黑白色彩空间下的颜色/*参数 gray为灰度alpha 为透明度*/CGColorRef CGColorCreateGenericGray(CGFloat gray, CGFloat alpha);//创建RGB色彩空间下的颜色CGColorRef CGColorCreateGenericRGB(CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha);//创建CMYB印刷模式色彩空间下的颜色CGColorCreateGenericCMYK(CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha);//获取颜色常量/*colorName定义如下： //标准白色 CFStringRef kCGColorWhite; //标准黑色 CFStringRef kCGColorBlack; //标准透明色 CFStringRef kCGColorClear;*/CGColorRef __nullable CGColorGetConstantColor(CFStringRef cg_nullable colorName);//通过模式与色彩空间创建颜色CGColorRef __nullable CGColorCreateWithPattern(CGColorSpaceRef cg_nullable space, CGPatternRef cg_nullable pattern, const CGFloat * cg_nullable components);//复制一个CGColorRefCGColorRef __nullable CGColorCreateCopy(CGColorRef cg_nullable color);//复制颜色 并追加透明度CGColorRef __nullable CGColorCreateCopyWithAlpha(CGColorRef cg_nullable color, CGFloat alpha);//将原色彩空间与目标色彩空间相匹配 创建颜色实例/*CGColorRenderingInter设置颜色渲染模式typedef CF_ENUM (int32_t, CGColorRenderingIntent) &#123; kCGRenderingIntentDefault, //默认的渲染模式 kCGRenderingIntentAbsoluteColorimetric, //绝对比色模式 kCGRenderingIntentRelativeColorimetric, //相对比色模式 kCGRenderingIntentPerceptual, //压缩色域模式 kCGRenderingIntentSaturation //转换色域模式&#125;;*/CGColorRef __nullable CGColorCreateCopyByMatchingToColorSpace(cg_nullable CGColorSpaceRef, CGColorRenderingIntent intent, CGColorRef cg_nullable color, __nullable CFDictionaryRef options);//内存引用+1CGColorRef cg_nullable CGColorRetain(CGColorRef cg_nullable color);//内存引用-1void CGColorRelease(CGColorRef cg_nullable color);//比较两个颜色引用是否相同bool CGColorEqualToColor(CGColorRef cg_nullable color1, CGColorRef cg_nullable color2);//获取颜色内容的色彩描述值个数 包括alpha通道size_t CGColorGetNumberOfComponents(CGColorRef cg_nullable color);//获取颜色色彩描述值数组CGFloat * __nullable CGColorGetComponents(CGColorRef cg_nullable color);//获取颜色的透明度CGFloat CGColorGetAlpha(CGColorRef cg_nullable color);//获取颜色的色彩空间CGColorSpaceRef __nullable CGColorGetColorSpace(CGColorRef cg_nullable color);//获取与此颜色相关的模型CGPatternRef __nullable CGColorGetPattern(CGColorRef cg_nullable color);//获取CGColorRef类在CoreGraphics框架中的idCFTypeID CGColorGetTypeID(void); 三、关于CGColorSpace相关方法解析CGColorSpace用来描述色彩空间，其中方法解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//创建一个基于设备的黑白色彩空间CGColorSpaceRef cg_nullable CGColorSpaceCreateDeviceGray(void);//创建一个基于设备的RGB色彩空间CGColorSpaceRef cg_nullable CGColorSpaceCreateDeviceRGB(void);//创建一个基于设备的CMYK色彩空间CGColorSpaceRef cg_nullable CGColorSpaceCreateDeviceCMYK(void);//创建一个经过校准的黑白色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateCalibratedGray(const CGFloat whitePoint[3], const CGFloat blackPoint[3], CGFloat gamma);//创建一个经过校准的RGB色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateCalibratedRGB(const CGFloat whitePoint[3], const CGFloat blackPoint[3], const CGFloat gamma[3], const CGFloat matrix[9]);//创建一个经过校准的LAB色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateLab(const CGFloat whitePoint[3], const CGFloat blackPoint[3], const CGFloat range[4]);//使用ICC文件创建ICC-based色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateWithICCProfile(CFDataRef cg_nullable data);CGColorSpaceRef __nullable CGColorSpaceCreateICCBased(size_t nComponents, const CGFloat * __nullable range, CGDataProviderRef cg_nullable profile, CGColorSpaceRef __nullable alternate);//使用索引创建色彩空间CGColorSpaceRef __nullable CGColorSpaceCreateIndexed(CGColorSpaceRef cg_nullable baseSpace, size_t lastIndex, const unsigned char * cg_nullable colorTable);//通过名称创建色彩空间/*标准的黑白色彩空间CFStringRef kCGColorSpaceGenericGray;标准的RGB色彩空间const CFStringRef kCGColorSpaceGenericRGB;标准的CMYK色彩空间CFStringRef kCGColorSpaceGenericCMYK;displatP3色彩空间CFStringRef kCGColorSpaceDisplayP3;LinearRGB色彩空间CFStringRef kCGColorSpaceGenericRGBLinear;Adobe RGB 1998 版本的色彩空间CFStringRef kCGColorSpaceAdobeRGB1998;黑白色彩空间 设置伽马值为2.2CFStringRef kCGColorSpaceGenericGrayGamma2_2;XYZ色彩空间CFStringRef kCGColorSpaceGenericXYZ;ACEScg色彩空间kCGColorSpaceACESCGLinear;ITU-R Recommendation BT.709 色彩空间kCGColorSpaceITUR_709;ITU-R Recommendation BT.2020色彩空间kCGColorSpaceITUR_2020;RGB色彩空间kCGColorSpaceROMMRGB;DCI P3 色彩空间kCGColorSpaceDCIP3;扩展的sRGB色彩空间kCGColorSpaceExtendedSRGB;线性sRGB色彩空间kCGColorSpaceLinearSRGB;扩展的线性sRGB扩展空间CFStringRef kCGColorSpaceExtendedLinearSRGB;扩展的黑白色彩空间CFStringRef kCGColorSpaceExtendedGray;扩展的线性黑白色彩空间CFStringRef kCGColorSpaceLinearGray;扩展的Generic Gray 2.2色彩空间CFStringRef kCGColorSpaceExtendedLinearGray;*/CGColorSpaceRef __nullable CGColorSpaceCreateWithName(CFStringRef cg_nullable name);//内存引用计数+1CGColorSpaceRef cg_nullable CGColorSpaceRetain(CGColorSpaceRef cg_nullable space);//内存引用计数-1void CGColorSpaceRelease(CGColorSpaceRef cg_nullable space);//进行色彩空间的复制CFStringRef __nullable CGColorSpaceCopyName(CGColorSpaceRef cg_nullable space);//获取CGColorRef类在CoreGraphics框架中的idCFTypeID CGColorSpaceGetTypeID(void);//获取色彩空间颜色值参数个数CGColorSpaceGetNumberOfComponents(CGColorSpaceRef cg_nullable space);//获取色彩空间模式/*typedef CF_ENUM (int32_t, CGColorSpaceModel) &#123; kCGColorSpaceModelUnknown = -1, 未知模式 kCGColorSpaceModelMonochrome, 单色色彩空间模式 kCGColorSpaceModelRGB, RGB色彩空间模式 kCGColorSpaceModelCMYK, CMYK色彩空间模式 kCGColorSpaceModelLab, LAB色彩空间模式 kCGColorSpaceModelDeviceN, 设备色彩空间模式 kCGColorSpaceModelIndexed, 引用色彩空间模式 kCGColorSpaceModelPattern 模型色彩空间模式&#125;;*/CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef cg_nullable space); 相同的图像，使用不同的色彩空间进行渲染，得到的结果可能大不一样，例如如下代码修改图片的色彩空间： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; CGImageRef image = CGImageCreateCopyWithColorSpace([UIImage imageNamed:@\"image\"].CGImage, CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB)); CGImageRef image2 = CGImageCreateCopyWithColorSpace([UIImage imageNamed:@\"image\"].CGImage, CGColorSpaceCreateWithName(kCGColorSpaceROMMRGB)); UIImageView * imageView = [[UIImageView alloc]initWithImage:[UIImage imageWithCGImage:image]]; UIImageView * imageView2 = [[UIImageView alloc]initWithImage:[UIImage imageWithCGImage:image2]]; imageView.frame = CGRectMake(100, 100, 200, 200); imageView2.frame = CGRectMake(100, 300, 200, 200); [self.view addSubview:imageView]; [self.view addSubview:imageView2];&#125; 效果如下： 原图如下： 模拟器运行如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文","slug":"260iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文","date":"2016-10-15T16:00:00.000Z","updated":"2021-07-12T02:33:58.310Z","comments":true,"path":"2016/10/16/260iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文/","link":"","permalink":"http://huishao.cc/2016/10/16/260iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之二——深入理解图形上下文一、引言在上一篇博客中，介绍了有关CGPath绘制路径的相关方法，其中在View视图的drawRect方法中，已经使用过上下文将Path路径绘制到当前视图上，上一篇博客只是抛砖引玉，本片博客将更深入的介绍下有关上下文的更多内容。关于接胡搜啊CGPath应用的博客地址如下： iOS开发CoreGraphics核心图形框架之一——CGPath的应用：https://my.oschina.net/u/2340880/blog/757072。 二、关于图形上下文Graphics Context GraphicsContext对于开发者来说是完全透明的，开发者不需要关心其实现，也不需要关心其绘制方式，开发者只需要将要绘制的内容传递给图形上下文，由图形上下文来将内容绘制到对应的目标上。这个目标可以是视图，窗口，打印机，PDF文档或者位图对象。需要注意，绘制的顺序在CoreGraphics框架中十分重要，如果后绘制的内容和先绘制的内容有位置冲突，后绘制的内容将覆盖先绘制的内容。 特定的上下文用于将内容绘制到特定的输出源上，CoreGraphics中提供如下几种图形上下文： 1.位图图形上下文：位图图形上下文用于将RGB图像，GMYK图像或者黑白图像绘制到一个位图(bitmap)对象中。 2.PDF图形上下文：PDF图形上下文可以帮助开发者创建PDF文件，将内容绘制进PDF文件中，其与位图上下文最大的区别在于PDF数据可以保存多页图像。 3.窗口上下文：用于OS系统中的窗口绘制。 4.图层上下文：用于将内容绘制在Layer图层上。 5.打印上下文：使用Mac打印功能时，此上下文用于将内容绘制在打印输出源上。 三、在UIKit框架中操作图形上下文在UIKit框架中有一个UIGraphics头文件，其中封装了许多对当前图形上下文进行操作的方法。首先任何UIView和其子类的视图控件都有一个drawRect方法，当视图将要被绘制时会调用这个方法，在drawRect方法中开发者可以获取到当前视图的图形上下文，通过这个图形上下文可以对视图进行自定义的绘制。UIGraphics头文件中定义的如下方法可以对当前的图形上下文进行操作： 123456//这个方法用于获取当前的图形上下文UIKIT_EXTERN CGContextRef __nullable UIGraphicsGetCurrentContext(void) CF_RETURNS_NOT_RETAINED;//这个方法用于将某个图形上下文对象压入栈中 使其变为当前的图形上下文UIKIT_EXTERN void UIGraphicsPushContext(CGContextRef context);//这个方法用于将当前的图形上下文出栈 当前的图形上下文始终是栈顶的图形上下文UIKIT_EXTERN void UIGraphicsPopContext(void); 需要注意，上面的UIGraphicsPushContext()与UIGraphicsPopContext()方法常用于切换当前的图形上下文。 12345678//下面这两个方法用于向当前的图形上下文中填充矩形 UIKIT_EXTERN void UIRectFillUsingBlendMode(CGRect rect, CGBlendMode blendMode);UIKIT_EXTERN void UIRectFill(CGRect rect);//下面这两个方法用于向当前的图形上下文中绘制矩形边框UIKIT_EXTERN void UIRectFrameUsingBlendMode(CGRect rect, CGBlendMode blendMode);UIKIT_EXTERN void UIRectFrame(CGRect rect);//这个方法用于裁剪当前的图形上下文的绘制区域UIKIT_EXTERN void UIRectClip(CGRect rect); 上面方法中的CGBlendMode参数用于设置图像的混合模式，意义列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152typedef CF_ENUM (int32_t, CGBlendMode) &#123; //在背景图像之上绘制原图像 kCGBlendModeNormal, //将背景与原图像进行混合 kCGBlendModeMultiply, //将背景与原图像进行逆向混合 kCGBlendModeScreen, //覆盖原图像 同时保持背景阴影 kCGBlendModeOverlay, //进行灰度复合 kCGBlendModeDarken, //进行亮度复合 kCGBlendModeLighten, //复合时 黑色不进行复合 kCGBlendModeColorDodge, //复合时 白色不进行复合 kCGBlendModeColorBurn, //复合时 根据黑白色值比例进行复合 kCGBlendModeSoftLight, kCGBlendModeHardLight, //复合时 将原图像中有关背景图像的色值去除 kCGBlendModeDifference, //与kCGBlendModeDifference类似 对比度更低 kCGBlendModeExclusion, //使用原图像的色调与饱和度 kCGBlendModeHue, //同kCGBlendModeHue 纯灰度的区域不产生变化 kCGBlendModeSaturation, //同kCGBlendModeHue 保留灰度等级 kCGBlendModeColor, //与kCGBlendModeHue效果相反 kCGBlendModeLuminosity, //下面这些枚举定义了MacOS中图像复合的计算方式 //R 结果 //S 原图像 //D 背景图像 //Ra Sa Da为带透明alpha通道 kCGBlendModeClear, /* R = 0 */ kCGBlendModeCopy, /* R = S */ kCGBlendModeSourceIn, /* R = S*Da */ kCGBlendModeSourceOut, /* R = S*(1 - Da) */ kCGBlendModeSourceAtop, /* R = S*Da + D*(1 - Sa) */ kCGBlendModeDestinationOver, /* R = S*(1 - Da) + D */ kCGBlendModeDestinationIn, /* R = D*Sa */ kCGBlendModeDestinationOut, /* R = D*(1 - Sa) */ kCGBlendModeDestinationAtop, /* R = S*(1 - Da) + D*Sa */ kCGBlendModeXOR, /* R = S*(1 - Da) + D*(1 - Sa) */ kCGBlendModePlusDarker, /* R = MAX(0, (1 - D) + (1 - S)) */ kCGBlendModePlusLighter /* R = MIN(1, S + D) */&#125;; 下面这些方法用于操作位图图形上下文： 12345678//这个方法会创建一个位图图形上下文 并将其push进图形上下文栈中 size参数设置图像的大小UIKIT_EXTERN void UIGraphicsBeginImageContext(CGSize size);//方法同上，其中opaque参数设置是否为不透明的 scale设置缩放因子UIKIT_EXTERN void UIGraphicsBeginImageContextWithOptions(CGSize size, BOOL opaque, CGFloat scale) NS_AVAILABLE_IOS(4_0);//这个方法用于将当前的位图图形上下文内容画成UIImage对象UIKIT_EXTERN UIImage* __nullable UIGraphicsGetImageFromCurrentImageContext(void);//结束位图图形上下文的编辑 会POP出栈UIKIT_EXTERN void UIGraphicsEndImageContext(void); 我们可以通过代码来画一个简单的UIImage图像，示例如下： 12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123; [super viewDidLoad]; //创建位图图形上下文 设置大小为200*200 UIGraphicsBeginImageContext(CGSizeMake(200, 200)); //获取到当前图形上下文 CGContextRef ref = UIGraphicsGetCurrentContext(); //裁剪其进行绘制的尺寸为100*100 UIRectClip(CGRectMake(0, 0, 100, 100)); //设置线条颜色 [[UIColor redColor] setStroke]; //设置填充颜色 [[UIColor grayColor] setFill]; //设置边框宽度 CGContextSetLineWidth(ref, 10); //进行填充 UIRectFill(CGRectMake(0, 0, 100, 100)); //进行边框绘制 UIRectFrame(CGRectMake(0, 0, 200, 200)); //拿到UIImage实例 UIImage * image = UIGraphicsGetImageFromCurrentImageContext(); //结束位图上下文编辑 UIGraphicsEndImageContext(); //将UIImage展示到界面上 UIImageView * imageView = [[UIImageView alloc]initWithImage:image]; imageView.contentMode = UIViewContentModeCenter; imageView.frame = CGRectMake(100, 100, 200, 200); [self.view addSubview:imageView];&#125; 效果如下图所示： 与操作PDF图形上下文的相关方法如下： 1234567891011121314151617181920212223//这个方法用于创建一个PDF图形上下文 将其入栈 作为当前的图形上下文 /*其中path为PDF文件写入的路径bounds为PDF文档的尺寸decumentInfo地点为设置PDF文档信息 后面会介绍*/UIKIT_EXTERN BOOL UIGraphicsBeginPDFContextToFile(NSString *path, CGRect bounds, NSDictionary * __nullable documentInfo) NS_AVAILABLE_IOS(3_2);//这个方法用于穿件一个PDF图形上下文 但是将PDF内容写成Data数据 参数意义同上UIKIT_EXTERN void UIGraphicsBeginPDFContextToData(NSMutableData *data, CGRect bounds, NSDictionary * __nullable documentInfo) NS_AVAILABLE_IOS(3_2);//结束PDF图形上下文的编辑 将其出栈UIKIT_EXTERN void UIGraphicsEndPDFContext(void) NS_AVAILABLE_IOS(3_2);//这个方法用于将当前的PDF图形上下文新开一页内容UIKIT_EXTERN void UIGraphicsBeginPDFPage(void) NS_AVAILABLE_IOS(3_2);//同上UIKIT_EXTERN void UIGraphicsBeginPDFPageWithInfo(CGRect bounds, NSDictionary * __nullable pageInfo) NS_AVAILABLE_IOS(3_2);//返回当前PDF图形上下文所在页的尺寸UIKIT_EXTERN CGRect UIGraphicsGetPDFContextBounds(void) NS_AVAILABLE_IOS(3_2);//向PDF文档中的某个区域添加链接UIKIT_EXTERN void UIGraphicsSetPDFContextURLForRect(NSURL *url, CGRect rect) NS_AVAILABLE_IOS(3_2);//向PDF文档中的某个区域添加一个跳转目标 使其滚动到某点UIKIT_EXTERN void UIGraphicsAddPDFContextDestinationAtPoint(NSString *name, CGPoint point) NS_AVAILABLE_IOS(3_2);//向PDF文档中的某个区域添加一个跳转目标 使其滚动到某个区域UIKIT_EXTERN void UIGraphicsSetPDFContextDestinationForRect(NSString *name, CGRect rect) NS_AVAILABLE_IOS(3_2); 上面有提到，在创建PDF图形上下文时，可以设置一个信息字典，这个字典中常用的可以进行配置的键值如下： 1234567891011121314151617181920212223//这个键是可选的 对应需要设置为字符串类型的值 表明文档作者kCGPDFContextAuthor//这个键是可选的 对应需要设置为字符串类型的值 表示生成文档的命名名称kCGPDFContextCreator//这个键是可选的 对应需要设置为字符串类型的值 表示文档名称kCGPDFContextTitle//这个键设置所有者密码 需要设置为CFString的值kCGPDFContextOwnerPassword//这个键设置用户密码 需要设置为CFString的值kCGPDFContextUserPassword//这个键设置是否允许在未解锁状态下进行打印 需要设置为CFBollean的值 默认为允许kCGPDFContextAllowsPrinting//这个键设置是否允许在未解锁状态下进行复制 需要设置为CFBollean的值 默认为允许kCGPDFContextAllowsCopying//设置输出规范kCGPDFContextOutputIntentkCGPDFContextOutputIntents//设置文档的主题 需要设置为CFString的值kCGPDFContextSubject//设置文档的关键字kCGPDFContextKeywords//设置密钥长度kCGPDFContextEncryptionKeyLength 四、CGContext功能解析前边介绍了如何拿到对应的图形上下文，拿到图形上下文后，开发者便可以随心所欲的通过图形上下文向目标上绘制内容。CoreGraphics框架中提供的CGContext绘制相关方法解析如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243//获取CGContext类在CoreGraphics框架中的id值CFTypeID CGContextGetTypeID(void);//将当前图形上下文进行保存 会执行push入栈void CGContextSaveGState(CGContextRef cg_nullable c);//将图形上下文恢复到保存时的状态 void CGContextRestoreGState(CGContextRef cg_nullable c);//对context内容进行缩放操作void CGContextScaleCTM(CGContextRef cg_nullable c, CGFloat sx, CGFloat sy);//对context内容进行平移操作void CGContextTranslateCTM(CGContextRef cg_nullable c, CGFloat tx, CGFloat ty);//对context内容进行旋转操作void CGContextRotateCTM(CGContextRef cg_nullable c, CGFloat angle);//对context内容进行transform变换操作void CGContextConcatCTM(CGContextRef cg_nullable c,CGAffineTransform transform);//获取某个context的transform变换对象CGAffineTransform CGContextGetCTM(CGContextRef cg_nullable c);//设置绘制的线宽void CGContextSetLineWidth(CGContextRef cg_nullable c, CGFloat width);//设置绘制的线帽风格void CGContextSetLineCap(CGContextRef cg_nullable c, CGLineCap cap);//设置绘制的线连接处风格void CGContextSetLineJoin(CGContextRef cg_nullable c, CGLineJoin join);//设置绘制的先转折处风格void CGContextSetMiterLimit(CGContextRef cg_nullable c, CGFloat limit);//设置虚线配置参数void CGContextSetLineDash(CGContextRef cg_nullable c, CGFloat phase, const CGFloat * __nullable lengths, size_t count);//设置平滑度void CGContextSetFlatness(CGContextRef cg_nullable c, CGFloat flatness);//设置透明度void CGContextSetAlpha(CGContextRef cg_nullable c, CGFloat alpha);//设置图像复合模式void CGContextSetBlendMode(CGContextRef cg_nullable c, CGBlendMode mode);//开始新的路径 旧的路径将被抛弃void CGContextBeginPath(CGContextRef cg_nullable c);//将路径起点移动到某个点void CGContextMoveToPoint(CGContextRef cg_nullable c, CGFloat x, CGFloat y);//向路径中添加一条线void CGContextAddLineToPoint(CGContextRef cg_nullable c,CGFloat x, CGFloat y);//向路径中添加三次贝塞尔曲线void CGContextAddCurveToPoint(CGContextRef cg_nullable c, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y);//向路径中添加二次贝塞尔曲线void CGContextAddQuadCurveToPoint(CGContextRef cg_nullable c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y);//闭合路径void CGContextClosePath(CGContextRef cg_nullable c);//向路径中添加一个矩形void CGContextAddRect(CGContextRef cg_nullable c, CGRect rect);//向路径中添加一组矩形void CGContextAddRects(CGContextRef cg_nullable c, const CGRect * __nullable rects, size_t count);//向路径中添加一组线条void CGContextAddLines(CGContextRef cg_nullable c, const CGPoint * __nullable points, size_t count);//向路径中添加椭圆CGContextAddEllipseInRect(CGContextRef cg_nullable c, CGRect rect);//向路径中添加圆弧void CGContextAddArc(CGContextRef cg_nullable c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise);void CGContextAddArcToPoint(CGContextRef cg_nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius);//直接向上下文中添加一个路径对象void CGContextAddPath(CGContextRef cg_nullable c, CGPathRef cg_nullable path);//将上下文中的路径内容替换掉 只留下边框void CGContextReplacePathWithStrokedPath(CGContextRef cg_nullable c);//判断某个Context的路径是否为空bool CGContextIsPathEmpty(CGContextRef cg_nullable c);//获取一个Context路径当前端点的位置CGPoint CGContextGetPathCurrentPoint(CGContextRef cg_nullable c);//获取路径的尺寸CGRect CGContextGetPathBoundingBox(CGContextRef cg_nullable c);//进行图形上下文的拷贝CGPathRef __nullable CGContextCopyPath(CGContextRef cg_nullable c);//获取context的路径中是否包含某个点bool CGContextPathContainsPoint(CGContextRef cg_nullable c, CGPoint point, CGPathDrawingMode mode);//进行路径的绘制/*mode枚举意义如下： kCGPathFill, //进行填充 kCGPathEOFill, //补集进行填充绘制 kCGPathStroke, //边框绘制 kCGPathFillStroke, //边框绘制并填充 kCGPathEOFillStroke //补集进行边框和填充绘制*/void CGContextDrawPath(CGContextRef cg_nullable c, CGPathDrawingMode mode)；//进行路径的填充void CGContextFillPath(CGContextRef cg_nullable c);//进行路径所围成区域的补集区域填充void CGContextEOFillPath(CGContextRef cg_nullable c);//进行边框绘制void CGContextStrokePath(CGContextRef cg_nullable c);//填充某个矩形区域void CGContextFillRect(CGContextRef cg_nullable c, CGRect rect);//填充一组矩形区域void CGContextFillRects(CGContextRef cg_nullable c, const CGRect * __nullable rects, size_t count);//进行矩形区域的边框绘制void CGContextStrokeRect(CGContextRef cg_nullable c, CGRect rect);//进行矩形区域的边框绘制 可以设置边框宽度void CGContextStrokeRectWithWidth(CGContextRef cg_nullable c, CGRect rect, CGFloat width);//清除某个矩形区域void CGContextClearRect(CGContextRef cg_nullable c, CGRect rect);//进行虚线区域的填充void CGContextFillEllipseInRect(CGContextRef cg_nullable c, CGRect rect);//进行虚线区域边框的绘制void CGContextStrokeEllipseInRect(CGContextRef cg_nullable c,CGRect rect);//绘制一组线void CGContextStrokeLineSegments(CGContextRef cg_nullable c, const CGPoint * __nullable points, size_t count);//依据Context当前路径进行裁剪void CGContextClip(CGContextRef cg_nullable c);//进行路径区域的补集区域裁剪void CGContextEOClip(CGContextRef cg_nullable c);//这个方法十分重要 其可以将图片裁剪成图形上下文定义的形状void CGContextClipToMask(CGContextRef cg_nullable c, CGRect rect, CGImageRef cg_nullable mask);//获取裁剪的区域尺寸CGRect CGContextGetClipBoundingBox(CGContextRef cg_nullable c);//进行区域裁剪void CGContextClipToRect(CGContextRef cg_nullable c, CGRect rect);//进行一组区域的裁剪void CGContextClipToRects(CGContextRef cg_nullable c, const CGRect * rects, size_t count);//设置图形上下文的填充颜色void CGContextSetFillColorWithColor(CGContextRef cg_nullable c, CGColorRef cg_nullable color);//设置图形上下文的边框颜色void CGContextSetStrokeColorWithColor(CGContextRef cg_nullable c, CGColorRef cg_nullable color);//设置图形上下文填充颜色的色彩空间void CGContextSetFillColorSpace(CGContextRef cg_nullable c,CGColorSpaceRef cg_nullable space);//设置图形上下文边框颜色的色彩空间void CGContextSetStrokeColorSpace(CGContextRef cg_nullable c, CGColorSpaceRef cg_nullable space);//下面这些函数与设置颜色和组件模块属性相关void CGContextSetFillColor(CGContextRef cg_nullable c, const CGFloat * cg_nullable components);void CGContextSetStrokeColor(CGContextRef cg_nullable c, const CGFloat * cg_nullable components);void CGContextSetFillPattern(CGContextRef cg_nullable c, CGPatternRef cg_nullable pattern, const CGFloat * cg_nullable components);void CGContextSetStrokePattern(CGContextRef cg_nullable c, CGPatternRef cg_nullable pattern, const CGFloat * cg_nullable components);void CGContextSetPatternPhase(CGContextRef cg_nullable c, CGSize phase);void CGContextSetGrayFillColor(CGContextRef cg_nullable c, CGFloat gray, CGFloat alpha);void CGContextSetGrayStrokeColor(CGContextRef cg_nullable c, CGFloat gray, CGFloat alpha);void CGContextSetRGBFillColor(CGContextRef cg_nullable c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha);void CGContextSetRGBStrokeColor(CGContextRef cg_nullable c, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha);void CGContextSetCMYKFillColor(CGContextRef cg_nullable c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha);void CGContextSetCMYKStrokeColor(CGContextRef cg_nullable c, CGFloat cyan, CGFloat magenta, CGFloat yellow, CGFloat black, CGFloat alpha);//将当前上下文内容渲染进颜色intent中void CGContextSetRenderingIntent(CGContextRef cg_nullable c, CGColorRenderingIntent intent);//在指定区域内渲染图片void CGContextDrawImage(CGContextRef cg_nullable c, CGRect rect, CGImageRef cg_nullable image);//在区域内进行瓦片方式的图片渲染void CGContextDrawTiledImage(CGContextRef cg_nullable c, CGRect rect, CGImageRef cg_nullable image);//获取上下文渲染的图像质量CGInterpolationQuality CGContextGetInterpolationQuality(CGContextRef cg_nullable c);//设置上下文渲染时的图像质量void CGContextSetInterpolationQuality(CGContextRef cg_nullable c, CGInterpolationQuality quality);//设置进行阴影的渲染void CGContextSetShadowWithColor(CGContextRef cg_nullable c, CGSize offset, CGFloat blur, CGColorRef __nullable color);void CGContextSetShadow(CGContextRef cg_nullable c, CGSize offset, CGFloat blur);//绘制线性渐变效果void CGContextDrawLinearGradient(CGContextRef cg_nullable c, CGGradientRef cg_nullable gradient, CGPoint startPoint, CGPoint endPoint, CGGradientDrawingOptions options);//绘制半径渐变效果void CGContextDrawRadialGradient(CGContextRef cg_nullable c, CGGradientRef cg_nullable gradient, CGPoint startCenter, CGFloat startRadius, CGPoint endCenter, CGFloat endRadius, CGGradientDrawingOptions options);//用渐变填充上下文的裁剪区域void CGContextDrawShading(CGContextRef cg_nullable c, cg_nullable CGShadingRef shading);//设置绘制的文字间距void CGContextSetCharacterSpacing(CGContextRef cg_nullable c, CGFloat spacing);//设置绘制的文字位置void CGContextSetTextPosition(CGContextRef cg_nullable c, CGFloat x, CGFloat y);//获取绘制的文字位置CGPoint CGContextGetTextPosition(CGContextRef cg_nullable c);//设置文字transform变换void CGContextSetTextMatrix(CGContextRef cg_nullable c, CGAffineTransform t);//获取文字的transform变换CGAffineTransform CGContextGetTextMatrix(CGContextRef cg_nullable c);//设置文字的绘制模式/* kCGTextFill, //填充 kCGTextStroke, //空心 kCGTextFillStroke, //填充加边框 kCGTextInvisible, //在可是区域内 kCGTextFillClip, //裁剪填充 kCGTextStrokeClip, //裁剪绘制边框 kCGTextFillStrokeClip,//进行裁剪 kCGTextClip*/void CGContextSetTextDrawingMode(CGContextRef cg_nullable c, CGTextDrawingMode mode);//设置绘制文字的字体void CGContextSetFont(CGContextRef cg_nullable c, CGFontRef cg_nullable font);//设置绘制文字的字号void CGContextSetFontSize(CGContextRef cg_nullable c, CGFloat size);void CGContextShowGlyphsAtPositions(CGContextRef cg_nullable c, const CGGlyph * cg_nullable glyphs, const CGPoint * cg_nullable Lpositions, size_t count);//设置绘制的字符风格void CGContextShowGlyphsAtPositions(CGContextRef cg_nullable c, const CGGlyph * cg_nullable glyphs, const CGPoint * cg_nullable Lpositions, size_t count);//进行PDF页的绘制void CGContextDrawPDFPage(CGContextRef cg_nullable c, CGPDFPageRef cg_nullable page);//开启一个新的PDF页void CGContextBeginPage(CGContextRef cg_nullable c, const CGRect * __nullable mediaBox);//结束当前的PDF页void CGContextEndPage(CGContextRef cg_nullable c);//内存引用加1CGContextRef cg_nullable CGContextRetain(CGContextRef cg_nullable c);//内存引用计数减1void CGContextRelease(CGContextRef cg_nullable c);//将上下文中的内容立即渲染到目标void CGContextFlush(CGContextRef cg_nullable c);//将上下文中的内容进行同步void CGContextSynchronize(CGContextRef cg_nullable c);//是否开启抗锯齿效果void CGContextSetShouldAntialias(CGContextRef cg_nullable c, bool shouldAntialias);//是否允许抗锯齿效果void CGContextSetAllowsAntialiasing(CGContextRef cg_nullable c, bool allowsAntialiasing);//是否开启字体平滑void CGContextSetShouldSmoothFonts(CGContextRef cg_nullable c, bool shouldSmoothFonts);//是否允许字体平滑void CGContextSetAllowsFontSmoothing(CGContextRef cg_nullable c, bool allowsFontSmoothing);//设置是否开启subpixel状态渲染符号void CGContextSetShouldSubpixelPositionFonts(CGContextRef cg_nullable c, bool shouldSubpixelPositionFonts);//是否允许subpixel状态渲染符号void CGContextSetAllowsFontSubpixelPositioning(CGContextRef cg_nullable c, bool allowsFontSubpixelPositioning);//这个方法会在当前Context中开启一个透明的层 之后的绘制会绘制到这个透明的层上void CGContextBeginTransparencyLayer(CGContextRef cg_nullable c, CFDictionaryRef __nullable auxiliaryInfo);//在Context中开启一个透明的层void CGContextBeginTransparencyLayerWithRect(CGContextRef cg_nullable c, CGRect rect, CFDictionaryRef __nullable auxInfo);//完成透明层的渲染void CGContextEndTransparencyLayer(CGContextRef cg_nullable c);//返回用户控件的transform变换CGAffineTransform CGContextGetUserSpaceToDeviceSpaceTransform(CGContextRef cg_nullable c);//将用户控件点的坐标转换为设备控件坐标CGPoint CGContextConvertPointToDeviceSpace(CGContextRef cg_nullable c, CGPoint point);//将设备空间的点坐标转换为用户空间的点坐标CGPoint CGContextConvertPointToUserSpace(CGContextRef cg_nullable c, CGPoint point);//将用于空间的尺寸转换为设备空间的尺寸CGSize CGContextConvertSizeToDeviceSpace(CGContextRef cg_nullable c, CGSize size);//将设备空间的尺寸转换为用户空间的尺寸CGSize CGContextConvertSizeToUserSpace(CGContextRef cg_nullable c, CGSize size);//将用户空间的rect转换为设备空间的rectCGRect CGContextConvertRectToDeviceSpace(CGContextRef cg_nullable c, CGRect rect);//将设备空间的rect转换为用户空间的rectCGRect CGContextConvertRectToUserSpace(CGContextRef cg_nullable c, CGRect rect);//下面这些方法已经被弃用 //设置字体 使用CoreText相关的API代替void CGContextSelectFont(CGContextRef cg_nullable c, const char * cg_nullable name, CGFloat size, CGTextEncoding textEncoding);//绘制文本 使用CoreText相关API代替void CGContextShowText(CGContextRef cg_nullable c, const char * cg_nullable string, size_t length);//在相应位置绘制文本 使用CoreText相关API代替void CGContextShowTextAtPoint(CGContextRef cg_nullable c, CGFloat x, CGFloat y, const char * cg_nullable string, size_t length);//进行符号的绘制 使用CoreText相关API代替void CGContextShowGlyphs(CGContextRef cg_nullable c, const CGGlyph * __nullable g, size_t count);//在相应位置绘制符号 使用CoreText相关API代替void CGContextShowGlyphsAtPoint(CGContextRef cg_nullable c, CGFloat x, CGFloat y, const CGGlyph * __nullable glyphs, size_t count);//绘制符号 使用一个固定的缩进值 使用CoreText相关API代替void CGContextShowGlyphsWithAdvances(CGContextRef cg_nullable c, const CGGlyph * __nullable glyphs, const CGSize * __nullable advances, size_t count);//进行PDF文档绘制 CGPDFPage相关API代替void CGContextDrawPDFDocument(CGContextRef cg_nullable c, CGRect rect, CGPDFDocumentRef cg_nullable document, int page); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreGraphics核心图形框架之一——CGPath的应用","slug":"259iOS开发CoreGraphics核心图形框架之一——CGPath的应用","date":"2016-10-10T16:00:00.000Z","updated":"2021-07-12T02:33:11.817Z","comments":true,"path":"2016/10/11/259iOS开发CoreGraphics核心图形框架之一——CGPath的应用/","link":"","permalink":"http://huishao.cc/2016/10/11/259iOS开发CoreGraphics核心图形框架之一——CGPath的应用/","excerpt":"","text":"iOS开发CoreGraphics核心图形框架之一——CGPath的应用一、引言CoreGraphics核心图形框架相较于UIKit框架更加偏于底层。在Objective-C工程中，CoreGraphics其中方法都是采用C语言风格进行编写的，同时其并不支持Objective-C的自动引用计数，在使用这个框架进行编程时，开发者要手动对内存进行管理。在Swift工程中，Apple使用Swift语言对CoreGraphics矿建进行了重构，将CGPath，CGMutablePaht等都重新定义为了类。CGPath可以理解为图形的路径，在Objective-C工程中，其实系统定义的一个内部结构体，开发者不可以直接使用，开发者CGPathRef和CGMutablePathRef别名作为CGPath的引用，实际上，CGPathRef和CGMutablePathRef都是CGPath结构体类型的指针，不同的是一个是const类型不可修改的，一个是可以修改的，系统定义如下： 12typedef struct CGPath *CGMutablePathRef;typedef const struct CGPath *CGPathRef; 二、CGPath创建与内存管理的相关方法关于CGPath的创建与内存管理的相关方法，列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//这个方法获取CGPath类在CoreGraphics框架中的唯一标识//CFTypeID 实际上是无符号整型的别名 其为CoreGraphics框架中每个类都定义了一个标识 CGPath为280CFTypeID CGPathGetTypeID(void);//这个方法创建一个srtuct CGPath * 指针 可以理解为可变的CGPath类CGMutablePathRef CGPathCreateMutable(void);//这个方法通过一个CGPathRef来创建CGPathRef CGPathRef CGPathCreateCopy(CGPathRef path);//这个方法在通过CGPathRef创建CGPathRef时会将得路径进行transform变换后返回CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform * transform);//这个方法通过CGPathRef创建可变的CGMutablePathRefCGMutablePathRef CGPathCreateMutableCopy(CGPathRef path);//意义同上，在创建的CGMutablePathRef基础上进行一次transform变换在返回CGMutablePathRef CGPathCreateMutableCopyByTransformingPath(CGPathRef path, const CGAffineTransform * transform)//这个方法将创建矩形路径 第一个参数为要绘制的矩形区域 第2个参数为要进行的transform变换CGPathRef CGPathCreateWithRect(CGRect rect,const CGAffineTransform * transform);//这个方法将创建椭圆形路径CGPathRef CGPathCreateWithEllipseInRect(CGRect rect, const CGAffineTransform * transform);//这个方法用于创建圆角矩形路径/*rect :绘制的矩形区域cornerWidth: 横向圆角尺寸cornerHeight:纵向圆角尺寸*/CGPathRef CGPathCreateWithRoundedRect(CGRect rect, CGFloat cornerWidth, CGFloat cornerHeight,const CGAffineTransform * transform);//这个方法用于创建虚线路径/*这个方法略微有些复杂 其中参数意义如下：path：要进行虚线化的路径phase：从lengths数组的第几部分开始绘制虚线lengths:C风格的数组 其中为CGFloat值 表示每段虚线的绘制长度 例如传入数组为&#123;10,5&#125;，则虚线的先绘制长度为10的实线 在绘制长度为5的空白 在进行循环count：这个参数需要设置为lengths数组的长度*/CGPathRef CGPathCreateCopyByDashingPath(CGPathRef path, const CGAffineTransform * transform,CGFloat phase, const CGFloat *lengths, size_t count);//通过CGPathRef来创建斜线/*lineWidth:设置线宽lineCap:设置线帽风格 可选参数如下：typedef CF_ENUM(int32_t, CGLineCap) &#123; kCGLineCapButt, 默认的风格 线的端点精确到点 kCGLineCapRound, 圆滑的端点 线的端点为半径为线宽一半的圆弧 kCGLineCapSquare 尖锐的过渡&#125;;lineJoin：设置连接线处的风格 可选参数如下：typedef CF_ENUM(int32_t, CGLineJoin) &#123; kCGLineJoinMiter, //以锋利的角作为连接线的转折 kCGLineJoinRound, //以圆角作为连接线的转折 kCGLineJoinBevel //贝塞尔风格的转折&#125;;miterLimit：这个值将决定线连接处角的锋利程度*/CGPathRef CGPathCreateCopyByStrokingPath(CGPathRef cg_nullable path, const CGAffineTransform * __nullable transform,CGFloat lineWidth, CGLineCap lineCap,CGLineJoin lineJoin, CGFloat miterLimit);//手动使CGPathRef引用计数+1CGPathRef CGPathRetain(CGPathRef cg_nullable path);//手动使CGPathRef引用计数-1void CGPathRelease(CGPathRef cg_nullable path); 自定义一个View视图，在其drawRect方法中进行界面的绘制，示例代码如下： 123456789101112131415161718- (void)drawRect:(CGRect)rect &#123; //获取当前绘图上下文 CGContextRef contextRef = UIGraphicsGetCurrentContext(); CGPoint center = CGPointMake(rect.size.width/2, rect.size.height/2); //创建圆角矩形路径 CGPathRef pathRef = CGPathCreateWithRoundedRect(CGRectMake(center.x-50, center.y-50, 100, 100), 30, 10, nil); //将路径虚线化 CGFloat floats[] = &#123;10,5&#125;; pathRef = CGPathCreateCopyByDashingPath(pathRef, nil, 0, floats, 2); //设置绘制颜色 [[UIColor redColor] setStroke]; //将路径添加到绘图上下文中 CGContextAddPath(contextRef, pathRef); //进行绘制 CGContextDrawPath(contextRef, kCGPathStroke); //内存释放 CGPathRelease(pathRef);&#125; 运行后效果如下图所示： 三、CGPath的路径绘制相关方法123456789101112131415161718192021222324252627282930313233343536373839404142434445//将路径移动到一个点作为起点void CGPathMoveToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat x, CGFloat y);//将路径移动到某个点画出一条线void CGPathAddLineToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat x, CGFloat y);//向路径中添加一段二次贝塞尔曲线/*cpx:控制点的x坐标cpy:控制点的y坐标*/void CGPathAddQuadCurveToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat cpx, CGFloat cpy,CGFloat x, CGFloat y);//添加一段三次贝塞尔曲线void CGPathAddCurveToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat cp1x, CGFloat cp1y,CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y);//这个方法用于闭合路径 调用这个方法后 路径最后的端点将和起点闭合void CGPathCloseSubpath(CGMutablePathRef path);//向路径中追加一个矩形void CGPathAddRect(CGMutablePathRef path, const CGAffineTransform * m, CGRect rect);//向路径中追加一组矩形void CGPathAddRects(CGMutablePathRef path, const CGAffineTransform * m, const CGRect * rects,size_t count);//向路径中追加一组线条void CGPathAddLines(CGMutablePathRef path, const CGAffineTransform * m, const CGPoint * __nullable points, size_t count);//添加一组椭圆void CGPathAddEllipseInRect(CGMutablePathRef cg_nullable path,const CGAffineTransform * m, CGRect rect);//向路径中追加一组圆弧/*x:圆心x坐标y:圆心y坐标radius:弧线半径startAngle:起始角度endAngle:终止角度clockwise:是否顺时针绘制*/void CGPathAddArc(CGMutablePathRef path, const CGAffineTransform * m, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, bool clockwise);//向路径中追加一组圆弧/*x:圆心x坐标y:圆心y坐标radius:弧线半径startAngle:起始角度delta:圆弧绘制的长度 为弧度制 2π为整个圆*/void CGPathAddRelativeArc(CGMutablePathRef path, const CGAffineTransform * __nullable matrix, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat delta);//向路径中追加一段圆弧 弧线是以(x1,y1)到(x2,y2)为切线的弧线void CGPathAddArcToPoint(CGMutablePathRef path,const CGAffineTransform * m, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius);//向路径中追加一段路径void CGPathAddPath(CGMutablePathRef path1,const CGAffineTransform * m, CGPathRef path2); 示例代码如下： 123456789101112131415- (void)drawRect:(CGRect)rect &#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); CGPoint center = CGPointMake(rect.size.width/2, rect.size.height/2); CGMutablePathRef pathRef = CGPathCreateMutable(); CGPathMoveToPoint(pathRef, nil, center.x, center.y-50); CGPathAddLineToPoint(pathRef, nil, center.x+100, center.y); CGPathAddQuadCurveToPoint(pathRef, nil, 0, 0, center.x+100, center.y-100); CGPathAddRelativeArc(pathRef, nil, 100, 100, 50, 0, M_PI); CGPathCloseSubpath(pathRef); [[UIColor redColor] setStroke]; CGContextAddPath(contextRef, pathRef); CGContextDrawPath(contextRef, kCGPathStroke); CGPathRelease(pathRef); CGContextRelease(contextRef);&#125; 效果如下图所示： 四、CGPath中的其他方法汇总123456789101112//判断某个路径是否为空bool CGPathIsEmpty(CGPathRef path);//判断某个路径是否为某个矩形bool CGPathIsRect(CGPathRef cg_nullable path, CGRect * rect);//获取某个路径当前绘制所在的点CGPoint CGPathGetCurrentPoint(CGPathRef path);//获取某个路径包含所有点的尺寸CGPathGetBoundingBox(CGPathRef cg_nullable path);//获取某个路径的尺寸CGRect CGPathGetPathBoundingBox(CGPathRef path);//判断路径是否包含某个点bool CGPathContainsPoint(CGPathRef path, const CGAffineTransform * m, CGPoint point, bool eoFill); 五、关于CGPathElement结构体当每次向CGPath路径做操作时，操作的过程实际上都会被记录下来，每个操作行为节点都被封装为了CGPathElement结构体，开发者可以通过如下方法来获取所有操作行为： 1CGPathApply(pathRef, nil, func); CGPathApply()方法中的第3个参数为一个函数指针，示例C函数实现如下： 1234void func(void * __nullable info, const CGPathElement * element)&#123; printf(\"%d\",(*element).type);&#125; CGPathElement结构体的定义如下： 12345678910111213141516171819struct CGPathElement &#123; //操作节点的类型 CGPathElementType type; //对应的点集 CGPoint * points;&#125;;//CGPathElementType枚举定义如下typedef CF_ENUM(int32_t, CGPathElementType) &#123; //移动到点的操作行为 kCGPathElementMoveToPoint, //添加线的操作行为 kCGPathElementAddLineToPoint, //添加二次贝塞尔曲线的操作行为 kCGPathElementAddQuadCurveToPoint, //添加三次贝塞尔曲线的操作行为 kCGPathElementAddCurveToPoint, //闭合路径的操作行为 kCGPathElementCloseSubpath&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS10中更加灵活的色彩API","slug":"258iOS10中更加灵活的色彩API","date":"2016-10-08T16:00:00.000Z","updated":"2021-07-12T02:32:10.068Z","comments":true,"path":"2016/10/09/258iOS10中更加灵活的色彩API/","link":"","permalink":"http://huishao.cc/2016/10/09/258iOS10中更加灵活的色彩API/","excerpt":"","text":"iOS10中更加灵活的色彩API一、创建sRGB模式的色彩在iOS10中，UIColor类中新增加了两个方法，用来创建sRGB模式的色彩。与RGB相比，sRGB是更加标准的色彩模式，RGB色彩在不同设备上可能存在颜色偏差，sRGB则更加精准但同时色域范围也更窄一些。UIColor中新添加的方法如下： 1234//类方法创建sRGB模式色彩+ (UIColor *)colorWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0);//初始化方法创建sRGB模式色彩- (UIColor *)initWithDisplayP3Red:(CGFloat)displayP3Red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha NS_AVAILABLE_IOS(10_0); 二、全局的设置色彩风格一般情况下，iOS系统会根据用户所在环境的光线进行屏幕色彩的调节，在iOS10系统中，开发者可以在info.plist文件中全局的配置色彩风格来设置外界光线对APP内色彩的影响程度。 在info.plist文件中可以添加如下键： White Point Adaptivity Style 这个键可以设置的值列举如下： Standard White Point Adaptivity Style 标准色彩模式 Reading White Point Adaptivity Style 阅读色彩模式 Photo White Point Adaptivity Style 照片色彩模式 Video White Point Adaptivity Style 视频色彩模式 Game White Point Adaptivity Style 游戏色彩模式 上面几种模式从上到下，对色彩的保真度依次提高。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"iOS10语音识别框架SpeechFramework应用","slug":"257iOS10语音识别框架SpeechFramework应用","date":"2016-09-24T16:00:00.000Z","updated":"2021-07-12T02:31:13.871Z","comments":true,"path":"2016/09/25/257iOS10语音识别框架SpeechFramework应用/","link":"","permalink":"http://huishao.cc/2016/09/25/257iOS10语音识别框架SpeechFramework应用/","excerpt":"","text":"iOS10语音识别框架SpeechFramework应用一、引言iOS10系统是一个较有突破性的系统，其在Message，Notification等方面都开放了很多实用性的开发接口。本篇博客将主要探讨iOS10中新引入的SpeechFramework框架。有个这个框架，开发者可以十分容易的为自己的App添加语音识别功能，不需要再依赖于其他第三方的语音识别服务，并且，Apple的Siri应用的强大也证明了Apple的语音服务是足够强大的，不通过第三方，也大大增强了用户的安全性。 二、SpeechFramework框架中的重要类SpeechFramework框架比较轻量级，其中的类并不十分冗杂，在学习SpeechFramework框架前，我们需要对其中类与类与类之间的关系有个大致的熟悉了解。 SFSpeechRecognizer：这个类是语音识别的操作类，用于语音识别用户权限的申请，语言环境的设置，语音模式的设置以及向Apple服务发送语音识别的请求。 SFSpeechRecognitionTask：这个类是语音识别服务请求任务类，每一个语音识别请求都可以抽象为一个SFSpeechRecognitionTask实例，其中SFSpeechRecognitionTaskDelegate协议中约定了许多请求任务过程中的监听方法。 SFSpeechRecognitionRequest:语音识别请求类，需要通过其子类来进行实例化。 SFSpeechURLRecognitionRequest：通过音频URL来创建语音识别请求。 SFSpeechAudioBufferRecognitionRequest:通过音频流来创建语音识别请求。 SFSpeechRecognitionResult：语音识别请求结果类。 SFTranscription：语音转换后的信息类。 SFTranscriptionSegment：语音转换中的音频节点类。 了解了上述类的作用于其之间的联系，使用SpeechFramework框架将十分容易。 三、申请用户语音识别权限与进行语音识别请求开发者若要在自己的App中使用语音识别功能，需要获取用户的同意。首先需要在工程的Info.plist文件中添加一个Privacy-Speech Recognition Usage Description键，其实需要对应一个String类型的值，这个值将会在系统获取权限的警告框中显示，Info.plist文件如下图所示： 使用SFSpeechRecognize类的requestAuthorization方法来进行用户权限的申请，用户的反馈结果会在这个方法的回调block中传入，如下： 123//申请用户语音识别权限[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123; &#125;]; SFSpeechRecognizerAuthorzationStatus枚举中定义了用户的反馈结果，如下： 12345678910typedef NS_ENUM(NSInteger, SFSpeechRecognizerAuthorizationStatus) &#123; //结果未知 用户尚未进行选择 SFSpeechRecognizerAuthorizationStatusNotDetermined, //用户拒绝授权语音识别 SFSpeechRecognizerAuthorizationStatusDenied, //设备不支持语音识别功能 SFSpeechRecognizerAuthorizationStatusRestricted, //用户授权语音识别 SFSpeechRecognizerAuthorizationStatusAuthorized,&#125;; 如果申请用户语音识别权限成功，开发者可以通过SFSpeechRecognizer操作类来进行语音识别请求，示例如下： 123456789//创建语音识别操作类对象SFSpeechRecognizer * rec = [[SFSpeechRecognizer alloc]init];//通过一个音频路径创建音频识别请求SFSpeechRecognitionRequest * request = [[SFSpeechURLRecognitionRequest alloc]initWithURL:[[NSBundle mainBundle] URLForResource:@\"7011\" withExtension:@\"m4a\"]];//进行请求[rec recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; //打印语音识别的结果字符串 NSLog(@\"%@\",result.bestTranscription.formattedString);&#125;]; 四、深入SFSpeechRecognizer类SFSpeechRecognizer类的主要作用是申请权限，配置参数与进行语音识别请求。其中比较重要的属性与方法如下： 123456789101112131415161718192021222324252627282930313233//获取当前用户权限状态+ (SFSpeechRecognizerAuthorizationStatus)authorizationStatus;//申请语音识别用户权限+ (void)requestAuthorization:(void(^)(SFSpeechRecognizerAuthorizationStatus status))handler;//获取所支持的所有语言环境+ (NSSet&lt;NSLocale *&gt; *)supportedLocales;//初始化方法 需要注意 这个初始化方法将默认以设备当前的语言环境作为语音识别的语言环境- (nullable instancetype)init;//初始化方法 设置一个特定的语言环境- (nullable instancetype)initWithLocale:(NSLocale *)locale NS_DESIGNATED_INITIALIZER;//语音识别是否可用@property (nonatomic, readonly, getter=isAvailable) BOOL available;//语音识别操作类协议代理@property (nonatomic, weak) id&lt;SFSpeechRecognizerDelegate&gt; delegate;//设置语音识别的配置参数 需要注意 在每个语音识别请求中也有这样一个属性 这里设置将作为默认值//如果SFSpeechRecognitionRequest对象中也进行了设置 则会覆盖这里的值/*typedef NS_ENUM(NSInteger, SFSpeechRecognitionTaskHint) &#123; SFSpeechRecognitionTaskHintUnspecified = 0, // 无定义 SFSpeechRecognitionTaskHintDictation = 1, // 正常的听写风格 SFSpeechRecognitionTaskHintSearch = 2, // 搜索风格 SFSpeechRecognitionTaskHintConfirmation = 3, // 短语风格&#125;;*/@property (nonatomic) SFSpeechRecognitionTaskHint defaultTaskHint;//使用回调Block的方式进行语音识别请求 请求结果会在Block中传入- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler;//使用代理回调的方式进行语音识别请求- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request delegate:(id &lt;SFSpeechRecognitionTaskDelegate&gt;)delegate;//设置请求所占用的任务队列@property (nonatomic, strong) NSOperationQueue *queue; SFSpeechRecognizerDelegate协议中只约定了一个方法，如下: 12//当语音识别操作可用性发生改变时会被调用- (void)speechRecognizer:(SFSpeechRecognizer *)speechRecognizer availabilityDidChange:(BOOL)available; 通过Block回调的方式进行语音识别请求十分简单，如果使用代理回调的方式，开发者需要实现SFSpeechRecognitionTaskDelegate协议中的相关方法，如下： 123456789101112131415//当开始检测音频源中的语音时首先调用此方法- (void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task;//当识别出一条可用的信息后 会调用/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法*/- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription;//当识别完成所有可用的结果后调用- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult;//当不再接受音频输入时调用 即开始处理语音识别任务时调用- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task;//当语音识别任务被取消时调用- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task;//语音识别任务完成时被调用- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully; SFSpeechRecognitionTask类中封装了属性和方法如下： 12345678910111213141516171819//此任务的当前状态/*typedef NS_ENUM(NSInteger, SFSpeechRecognitionTaskState) &#123; SFSpeechRecognitionTaskStateStarting = 0, // 任务开始 SFSpeechRecognitionTaskStateRunning = 1, // 任务正在运行 SFSpeechRecognitionTaskStateFinishing = 2, // 不在进行音频读入 即将返回识别结果 SFSpeechRecognitionTaskStateCanceling = 3, // 任务取消 SFSpeechRecognitionTaskStateCompleted = 4, // 所有结果返回完成&#125;;*/@property (nonatomic, readonly) SFSpeechRecognitionTaskState state;//音频输入是否完成@property (nonatomic, readonly, getter=isFinishing) BOOL finishing;//手动完成音频输入 不再接收音频- (void)finish;//任务是否被取消@property (nonatomic, readonly, getter=isCancelled) BOOL cancelled;//手动取消任务- (void)cancel; 关于音频识别请求类，除了可以使用SFSpeechURLRecognitionRequest类来进行创建外，还可以使用SFSpeechAudioBufferRecognitionRequest类来进行创建： 12345678910@interface SFSpeechAudioBufferRecognitionRequest : SFSpeechRecognitionRequest@property (nonatomic, readonly) AVAudioFormat *nativeAudioFormat;//拼接音频流- (void)appendAudioPCMBuffer:(AVAudioPCMBuffer *)audioPCMBuffer;- (void)appendAudioSampleBuffer:(CMSampleBufferRef)sampleBuffer;//完成输入- (void)endAudio;@end 五、语音识别结果类SFSpeechRecognitionResultSFSpeechRecognitionResult类是语音识别结果的封装，其中包含了许多套平行的识别信息，其每一份识别信息都有可信度属性来描述其准确程度。SFSpeechRecognitionResult类中属性如下： 123456//识别到的多套语音转换信息数组 其会按照准确度进行排序@property (nonatomic, readonly, copy) NSArray&lt;SFTranscription *&gt; *transcriptions;//准确性最高的识别实例@property (nonatomic, readonly, copy) SFTranscription *bestTranscription;//是否已经完成 如果YES 则所有所有识别信息都已经获取完成@property (nonatomic, readonly, getter=isFinal) BOOL final; SFSpeechRecognitionResult类只是语音识别结果的一个封装，真正的识别信息定义在SFTranscription类中，SFTranscription类中属性如下： 1234//完整的语音识别准换后的文本信息字符串@property (nonatomic, readonly, copy) NSString *formattedString;//语音识别节点数组@property (nonatomic, readonly, copy) NSArray&lt;SFTranscriptionSegment *&gt; *segments; 当对一句完整的话进行识别时，Apple的语音识别服务实际上会把这句语音拆分成若干个音频节点，每个节点可能为一个单词，SFTranscription类中的segments属性就存放这些节点。SFTranscriptionSegment类中定义的属性如下： 123456789101112//当前节点识别后的文本信息@property (nonatomic, readonly, copy) NSString *substring;//当前节点识别后的文本信息在整体识别语句中的位置@property (nonatomic, readonly) NSRange substringRange;//当前节点的音频时间戳@property (nonatomic, readonly) NSTimeInterval timestamp;//当前节点音频的持续时间@property (nonatomic, readonly) NSTimeInterval duration;//可信度/准确度 0-1之间@property (nonatomic, readonly) float confidence;//关于此节点的其他可能的识别结果 @property (nonatomic, readonly) NSArray&lt;NSString *&gt; *alternativeSubstrings; 温馨提示：SpeechFramework框架在模拟器上运行会出现异常情况，无法进行语音识别请求。会报出kAFAssistantErrorDomain的错误，还望有知道解决方案的朋友，给些建议，Thanks。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"iOS10中Messages独立应用与扩展插件详析","slug":"256iOS10中Messages独立应用与扩展插件详析","date":"2016-09-17T16:00:00.000Z","updated":"2021-07-12T02:30:30.707Z","comments":true,"path":"2016/09/18/256iOS10中Messages独立应用与扩展插件详析/","link":"","permalink":"http://huishao.cc/2016/09/18/256iOS10中Messages独立应用与扩展插件详析/","excerpt":"","text":"iOS10中Messages独立应用与扩展插件详析一、引言Messages是iOS系统中原生的信息应用，其既可以通过运营商网络发送短信息，也可以通过互联网进行类似微信类社交软件的即时聊天。但是由于其封闭性与功能的单一，使用其进行即时聊天的用户并不多。随着iOS10系统的推出，或许可以改变这一现状。在iOS10中，Messages的功能被扩展的十分强大，通过Messages，用户可以分享图片，音乐，视频，可以随手涂鸦，使用自定义的表情包，可以进行Apple Pay支付，购物，甚至可以在Messages中玩游戏。并且，上面所提到的这些功能都全面开发出了接口供开发者进行开发与扩展。 在iOS10中，开发者可以进行与Messages相关的开发有两类：独立的Messages应用与Messages应用扩展。其中，Messages应用扩展需要依附一个宿主App而存在。无论哪种类型的Messages应用，其都又分为两类，StickerPicks（表情包）与iMessage Apps(Messages应用)。 二、开发表情包StickerPicks1.开发独立的表情包Sticker Picks可谓是iOS10中一个十分强大的新功能。在iOS10系统的iPhone上，Messages应用中会内嵌一个Message App Store，用户可以直接从里面下载针对于Messages的独立表情包和独立第三方应用。开发者也可以独立开发表情包发布到这个Message App Store中。 开发Sticker Picks表情包十分简单，开发者可以不用写一句代码，将整理好的表情进行打包提交即可完成。使用Xcode8创建一个新的工程，选择Sticker Pack Application模板，如下图所示： 创建出工程后，可以发现模板中没有任何代码文件，只有一个Stickers.xcstickers包。将准备好的表情包图片导入这个Stickers中，其中支持静态图片，也支持动态表情gif图片。关于导入的图片，有如下几条规则： 1.图片文件的格式必须是PNG、APNG、GIF或者JPEG。 2.单个文件的大小不能超过500KB。 3.最优的效果是当图片尺寸在100*100到206*206之间。 注意：在提供图片的时候，开发者只需要提供@3倍图即可，即最优尺寸在300*300到618*618之间的图片。系统会自动生成@2与@1倍图。 开发的表情包会显示在Messages应用的工具中，需要注意，在表情列表的排版中，每个表情缩略图只支持3种尺寸的排版，对应的尺寸分别如下： Small类型：100*100 Medium类型：136*136 Large类型：206*206 在Xcode中，可以对要使用的模板进行选择，如下图： 在模拟器中运行工程，Messages中效果如下图： 和普通iOS应用程序一样，将设备选择为Generic iOS Device后直接Archives即可将表情包提交到AppStore，审核通过后，即可在Message App Store中进行下载。 小提示：其实StickerPicks翻译成表情包并不合适，其更有一层贴纸的概念。实际上其也确实有贴纸的功能，在Messages应用中，用户可以通过长按移动手势，来将某个Sticker添加在另一个Sticker上面。如下图： 2.开发寄宿于宿主App的表情包扩展扩展表情包与独立表情包最大的不同在于扩展需要寄宿于某个宿主App中，创建扩展target，选择Sticker Pick Extension，如下图，之后和独立表情包开发过程一致。 3.关于表情包的icon图标StickerPicks的图标和宿主App并不共用，其需要一套独特尺寸的icon，尺寸如下： 效果如下图所示： 三、开发Messages App应用1.认识Messages框架和StickerPicks表情包一样，Messages App也分为独立应用与扩展两种。其实它们的开发思路和方法完全一致，只是有无宿主App的区别。 开发Messages App需要使用到iOS中引入的一个新的开发框架Messages。Messages比较简单，其中涉及到的类并不十分多，下图中概述了其中重要的类和之间的关系： MSMessageAppViewController：这个类Messages App的基础视图控制器类，其继承自UIViewController，但其中添加了许多Messages App相关的声明周期方法。 MSConversation：描述一个会话实例。 MSSticker：表情贴图实例。 MSMessage：在Messages App之间进行传递的消息实体。 MSMessageLayout：抽象类，其并没有实现任何方法，有子类实现。 MSMessageTemplateLayout：用于对消息实体MSMessage进行布局排版。 MSStickerBorwserViewController：用于创建表情包视图控制器。 MSStickerBorwserView：表情包视图容器，类似CollectionView。 MSStickerView：表情承载视图。 2.实现一个Messages App的列表界面使用Xcode新建一个Messages App工程如下： 其会自动生成一个MessagesViewController类，这个类就是此Messages App的主界面视图控制器。需要注意，Messages App的视图控制器都分为两种状态，分别为Compact(紧凑的)和Expanded(扩宽的)。并且在这两种状态进行切换时，视图的底部的工具栏和头部的导航栏也会交替出现，这导致了即使是使用自动布局，依然无法完美的解决Messages App布局的统一性，需要手动进行调整处理，后面会介绍到。 在MessagesViewController类中添加其他视图控件，大部分iOS App开发中可以使用的UI控件这里都可以使用，但是有一点需要注意，对于可以弹出键盘的UI控件，例如UITextView与UITextField，当Messages App界面处理Compact模式时，键盘是不能弹出的，只有当界面处于Expanded模式时，键盘才被允许弹出。 为了使Messages App的界面在任何模式下都能保持统一，需要手动对其中视图约束进行修改，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.dataArray = [NSMutableArray array]; [self.dataArray addObjectsFromArray:@[@\"发送文本信息\",@\"插入表情\",@\"插入文件\",@\"插入消息实体\",@\"跳转第二个界面\",@\"贴图包\"]]; [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@\"cellId\"]; self.tableView.dataSource = self; self.tableView.delegate = self; self.session = [[MSSession alloc]init];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return self.dataArray.count;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"cellId\"]; cell.textLabel.text = self.dataArray[indexPath.row]; return cell;&#125;//这个方法在Messages App加载完成处于活跃状态时被调用 在其中根据模式设置布局参数-(void)didBecomeActiveWithConversation:(MSConversation *)conversation &#123; // Called when the extension is about to move from the inactive to active state. // This will happen when the extension is about to present UI. if (self.presentationStyle==MSMessagesAppPresentationStyleCompact) &#123; _topMargan.constant = 0; _leftMargan.constant = -15; _rightMargan.constant = -15; _bottomMargan.constant=-44; &#125;else&#123; _topMargan.constant = -85; _leftMargan.constant = -15; _rightMargan.constant = -15; _bottomMargan.constant=0; &#125; [self.view layoutIfNeeded]; &#125;//这个方法在视图控制器的模式发生了改变时调用 在其中根据模式修改布局参数-(void)didTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle &#123; // Called after the extension transitions to a new presentation style. // Use this method to finalize any behaviors associated with the change in presentation style. if (presentationStyle==MSMessagesAppPresentationStyleCompact) &#123; _topMargan.constant = 0; _leftMargan.constant = -15; _rightMargan.constant = -15; _bottomMargan.constant=-44; &#125;else&#123; _topMargan.constant = -85; _leftMargan.constant = -15; _rightMargan.constant = -15; _bottomMargan.constant=0; &#125; [self.view layoutIfNeeded];&#125; 3.解析MSMessagesAppViewController类由于MSMessagesAppViewController类是继承于UIViewController类的，因此UIViewController中的视图控制器切换方法这里都可以直接使用，MSMessagesAppViewController中供开发者进行调用的属性和方法如下： 12345678910111213141516//当前激活的会话实例 后面会介绍@property (nonatomic, strong, readonly, nullable) MSConversation *activeConversation;//当前界面所在的状态/*typedef NS_ENUM(NSUInteger, MSMessagesAppPresentationStyle) &#123; //紧凑状态 MSMessagesAppPresentationStyleCompact, //扩宽状态 MSMessagesAppPresentationStyleExpanded&#125; NS_ENUM_AVAILABLE_IOS(10_0);*/@property (nonatomic, assign, readonly) MSMessagesAppPresentationStyle presentationStyle;//切换界面状态-(void)requestPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;//调用此方法后，MessagesApp被收回 弹出键盘-(void)dismiss; MSMessagesAppViewController中新增加的声明周期方法如下： 12345678910111213141516171819202122//当Messages App将要激活时调用-(void)willBecomeActiveWithConversation:(MSConversation *)conversation;//当Messages App已经被激活后调用-(void)didBecomeActiveWithConversation:(MSConversation *)conversation;//当Messages App将要被注销时调用-(void)willResignActiveWithConversation:(MSConversation *)conversation;//当MessageApp已经被注销时调用-(void)didResignActiveWithConversation:(MSConversation *)conversation;//消息实体在会话中将要被选中时调用-(void)willSelectMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//消息实体在会话中已经被选中时调用-(void)didSelectMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//接收到同一Messages App发送的消息实体时调用-(void)didReceiveMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//开发发送消息时调用-(void)didStartSendingMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//取消发送时调用-(void)didCancelSendingMessage:(MSMessage *)message conversation:(MSConversation *)conversation;//控制器界面模式将要改变时调用-(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;//控制器界面已经改变时调用-(void)didTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle; 4.使用MSConversation会话类来进行消息的发送MSConversation类用来描述会话，MSMessagesAppViewController中内置MSConversation对象，开发者可以用它来进行消息传递，示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; switch (indexPath.row) &#123; case 0: &#123; [self.activeConversation insertText:@\"新的信息\" completionHandler:^(NSError * error) &#123; &#125;]; &#125; break; case 1: &#123; [self.activeConversation insertSticker:[[MSSticker alloc] initWithContentsOfFileURL:[[NSURL alloc] initFileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"productImage\" ofType:@\"png\"]] localizedDescription:@\"image\" error:nil] completionHandler:nil]; &#125; break; case 2: &#123; [self.activeConversation insertAttachment:[[NSURL alloc] initFileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"file\" ofType:nil]] withAlternateFilename:@\"文件\" completionHandler:nil]; &#125; break; case 3: &#123; MSMessage * message = [[MSMessage alloc]initWithSession:_session]; message.URL = [NSURL URLWithString:@\"http://www.baidu.com\"]; message.accessibilityLabel = @\"message\"; message.summaryText = @\"message\"; MSMessageTemplateLayout * layout = [[MSMessageTemplateLayout alloc]init]; layout.caption = @\"caption\"; layout.subcaption = @\"subcaption\"; layout.trailingCaption = @\"trailing\"; layout.trailingSubcaption =@\"subtrailing\"; layout.image = [UIImage imageNamed:@\"productImage\"]; layout.mediaFileURL =[[NSURL alloc] initFileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"productImage\" ofType:@\"png\"]]; layout.imageTitle = @\"杜康\"; layout.imageSubtitle = @\"酒水\"; message.layout = layout; [self.activeConversation insertMessage:message completionHandler:nil]; &#125; break; case 4: &#123; [self presentViewController:[StackerViewController new] animated:YES completion:nil ]; &#125; break; case 5: &#123; [self presentViewController:[StackController new] animated:YES completion:nil ]; &#125; break; default: break; &#125;&#125; MSConversation支持发送的消息分为4中，分别为文本消息，表情贴图消息，文件消息和Message实体消息，上面代码都做了演示。MSConversation中重要属性和方法解析如下： 1234567891011121314//本地的设备UUID@property (nonatomic, readonly) NSUUID *localParticipantIdentifier;//会话中远程设备的UUID 支持多人会话@property (nonatomic, readonly) NSArray&lt;NSUUID *&gt; *remoteParticipantIdentifiers;//当前选中的消息实体@property (nonatomic, readonly, nullable) MSMessage *selectedMessage;//插入文本消息- (void)insertText:(NSString *)text completionHandler:(nullable void (^)(NSError * _Nullable))completionHandler;//插入表情贴图消息- (void)insertSticker:(MSSticker *)sticker completionHandler:(nullable void (^)(NSError * _Nullable))completionHandler;//插入文件附件消息- (void)insertAttachment:(NSURL *)URL withAlternateFilename:(nullable NSString *)filename completionHandler:(nullable void (^)(NSError * _Nullable))completionHandler;//插入Message实体消息- (void)insertMessage:(MSMessage *)message completionHandler:(nullable void (^)(NSError * _Nullable))completionHandler; 效果图如下： 5.消息实体MSMessage的应用MSMessage是Messages App定义的一种消息实体，其可以用来在Messages App间传递信息，因为它的存在，通过Messages用用实现休闲对战游戏变得十分容易，开发者不需要在写即时通信链接，只需设计游戏逻辑即可。MSMessage不能够完全自定义UI，但是Messages框架中的MSMessageTemplateLayout类可以对其UI进行简单的配置。 MSMessage类中常用的属性和方法如下： 12345678910111213//初始化方法 可以绑定一个session，同一个session种的消息实体会被归为一类-(instancetype)initWithSession:(MSSession *)session NS_DESIGNATED_INITIALIZER;//发送此消息的设备@property (nonatomic, readonly) NSUUID *senderParticipantIdentifier;//消息的UI布局信息@property (nonatomic, copy, nullable) MSMessageLayout* layout;//消息附带的URL 开发者可以通过这个URL来传值 @property (nonatomic, copy, nullable) NSURL *URL;//是否保留过期的消息@property (nonatomic, assign) BOOL shouldExpire;//盲人模式中对应的文案@property (nonatomic, copy, nullable) NSString *accessibilityLabel; 6.消息实体布局类MSMessageLayout前面介绍，MSMessage类中并没有定义UI，UI部分需要配合MSMessageLayout类来配置。需要注意，MSMessageLayout类是一个抽象类，apple设计的目的可能是为了以后便于扩展多个消息布局模板。目前，开发者只需要使用MSMessageTemplateLayout类来对消息实体进行布局。 MSMessageTemplateLayout类中可以配置的属性如下： 12345678910111213141516//设置消息实体的标题@property (nonatomic, copy, nullable) NSString *caption;//设置消息实体的子标题@property (nonatomic, copy, nullable) NSString *subcaption;//设置消息实体的右侧标题@property (nonatomic, copy, nullable) NSString *trailingCaption;//设置消息实体的右侧子标题@property (nonatomic, copy, nullable) NSString *trailingSubcaption;//设置消息实体的图片@property (nonatomic, strong, nullable) UIImage *image;//设置消息实体的媒体地址 需要注意 如果设置的image属性 这个属性将被忽略@property (nonatomic, copy, nullable) NSURL *mediaFileURL;//设置消息实体的图标标题@property (nonatomic, copy, nullable) NSString *imageTitle;//设置消息实体的图片子标题@property (nonatomic, copy, nullable) NSString *imageSubtitle; 7.表情贴图类MSSticker与MSStickerView在制作表情包Sticker Picks的时候，开发者不需要编写一行代码，实际上如果要通过代码来开发表情包也是没有问题的，这里需要用到的一个类就是MSSticker类，简单理解，MSSticker类对象就是一个表情贴图，但是它不是一个View视图，若想在Messages App中看到这个表情贴图，还需要借助一个类MSStickerView，MSStickerView是用于承载表情贴图的视图类，用户选中它后，可以在Messages应用中进行发送。 首先，MSSticker类创建方法如下： 12//初始化方法 通过文件URL 来创建实例- (nullable instancetype)initWithContentsOfFileURL:(NSURL *)fileURL localizedDescription:(NSString *)localizedDescription error:(NSError * _Nullable *)error NS_DESIGNATED_INITIALIZER; MSStickerView类解析如下： 1234567891011//通过MSSticker来进行MSStickerView类的创建- (instancetype)initWithFrame:(CGRect)frame sticker:(nullable MSSticker *)sticker;//获取动画播放一遍的时间 如果是gif@property(nonatomic, readonly) NSTimeInterval animationDuration;//开始动画-(void) startAnimating;//结束动画-(void) stopAnimating;//获取动画状态- (BOOL)isAnimating; 需要注意，MSStickerView如果加载的是gif类型的表情贴图，默认不会播放动画，开发者可以调用开始动画的方法来进行gif动画的播放。 8.表情包视图控制器MSStickerBrowserViewController其实通过前面的内容，已经可以自定义开发一个表情包Messages App了，但是还有一个视图控制器类MSStickerBrowserViewController，这个类可以更加简单方面的创建表情包视图控制器。要了解MSStickerBrowserViewController类，首先应该先了解MSStickerBrowserView类，这两个类的关系十分类似于UITableViewController与UITableView类的关系。MSStickerBrowserView是用于展示表情视图的容器，其继承自UIView，但却和UICollectionView十分类似，其中方法解析如下： 12345678910111213141516171819202122//初始化方法 设置frame 和其中表情视图的尺寸模式/*typedef NS_ENUM(NSInteger, MSStickerSize) &#123; //小尺寸 MSStickerSizeSmall, //标准尺寸 MSStickerSizeRegular, //大尺寸 MSStickerSizeLarge&#125; NS_ENUM_AVAILABLE_IOS(10_0);*/- (instancetype)initWithFrame:(CGRect)frame stickerSize:(MSStickerSize)stickerSize NS_DESIGNATED_INITIALIZER;//数据源代理@property (nonatomic, weak, nullable) id &lt;MSStickerBrowserViewDataSource&gt; dataSource;//当前的滑动位置@property (nonatomic, assign, readwrite) CGPoint contentOffset;//内容偏移尺寸@property (nonatomic, assign, readwrite) UIEdgeInsets contentInset;//设置当前的滑动位置- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;//刷新数据- (void)reloadData; MSStickerBrowserView的数据填充需要在代理方法中实现，如下： 1234//设置表情贴图个数- (NSInteger)numberOfStickersInStickerBrowserView:(MSStickerBrowserView *)stickerBrowserView;//设置具体每个位置的表情贴图- (MSSticker *)stickerBrowserView:(MSStickerBrowserView *)stickerBrowserView stickerAtIndex:(NSInteger)index; 再看MSStickerBrowserViewController就十分容易了，它只是将MSStickerBrowserView封装在了一个UIViewController中，并且这个UIViewController遵守了MSStickerBrowserViewDataSource协议，开发者直接实现协议方法即可。 四、开发Messages App中的建议下面是Apple对Messages App的定位和一些建议，还有我的一些理解： 1.确保应用是有用的并且易于理解。 2.功能要聚焦单一，不要组合多种功能在一起。 3.Messages通常用在双人非正式的交谈中，应从这里入手，让交流更加有趣。 4.Messages的最大两点是分享，利用这一点出发开发Messages App。 5.插图内容布局要注意，系统会自动将内容变为圆角，不要把重要的信息放在角落。 6.注意，在紧凑模式下，Messages App的界面是不允许水平滚动的。 7.同样，在紧凑模式下，Messages App不允许键盘输入。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"iOS10通知框架UserNotification理解与应用","slug":"255iOS10通知框架UserNotification理解与应用","date":"2016-09-17T16:00:00.000Z","updated":"2021-07-12T02:29:36.715Z","comments":true,"path":"2016/09/18/255iOS10通知框架UserNotification理解与应用/","link":"","permalink":"http://huishao.cc/2016/09/18/255iOS10通知框架UserNotification理解与应用/","excerpt":"","text":"iOS10通知框架UserNotification理解与应用一、引言关于通知，无论与远程Push还是本地通知，以往的iOS系统暴漏给开发者的接口都是十分有限的，开发者只能对标题和内容进行简单的定义，至于UI展示和用户交互行为相关的部分，开发者开发起来都十分困难。至于本地通知，iOS10之前采用的是UILocationNotification类，远程通知有苹果服务器进行转发，本地通知和远程通知其回调的处理都是通过AppDelegate中的几个回调方法来完成。iOS10系统中，通知功能的增强是一大优化之处，iOS10中将通知功能整合成了一个框架UserNotification，其结构十分类似于iOS8中的UIWebView向WebKit框架整合的思路。并且UserNotification相比之前的通知功能更加强大，主要表现在如下几点： 1.通知处理代码可以从AppDelegate中剥离。 2.通知的注册，设置，处理更加结构化，更易于模块化开发。 3.UserNotification支持自定义通知音效和启动图。 4.UserNotification支持向通知内容中添加媒体附件，例如音频，视频。 5.UserNotification支持开发者定义多套通知模板。 6.UserNotification支持完全自定义的通知界面。 7.UserNotification支持自定义通知中的用户交互按钮。 8.通知的触发更加容易管理。 从上面列举的几点就可以看出，iOS10中的UsreNotification真的是一个大的改进，温故而知新，关于iOS之前版本本地通知和远程通知的相关内容请查看如下博客： 本地推送：http://my.oschina.net/u/2340880/blog/405491。 远程推送：http://my.oschina.net/u/2340880/blog/413584。 二、UserNotification概览学习一个新的框架或知识模块时，宏观上了解其体系，大体上掌握其结构是十分必要的，这更有利于我们对这个框架或模块的整体把握与理解。UserNotification框架中拆分定义了许多类、枚举和结构体，其中还定义了许多常量，类与类之间虽然关系复杂，但脉络十分清晰，把握住主线，层层分析，边很容易理解和应用UserNotification框架。 下图中列举了UserNotification框架中所有核心的类： 如图中关系所示，UserNotification框架中的核心类列举如下： UNNotificationCenter：通知管理中心，单例，通知的注册，接收通知后的回调处理等，是UserNotification框架的核心。 UNNotification：通知对象，其中封装了通知请求。 UNNotificationSettings：通知相关设置。 UNNotificationCategory：通知模板。 UNNotificationAction：用于定义通知模板中的用户交互行为。 UNNotificationRequest：注册通知请求，其中定义了通知的内容和触发方式。 UNNotificationResponse：接收到通知后的回执。 UNNotificationContent：通知的具体内容。 UNNotificationTrigger：通知的触发器，由其子类具体定义。 UNNotificationAttachment：通知附件类，为通知内容添加媒体附件。 UNNotificationSound：定义通知音效。 UNPushNotificationTrigger：远程通知的触发器，UNNotificationTrigger子类。 UNTimeInervalNotificationTrigger：计时通知的触发器，UNNotificationTrigger子类。 UNCalendarNotificationTrigger：周期通知的触发器，UNNotificationTrigger子类。 UNLocationNotificationTrigger：地域通知的触发器，UNNotificationTrigger子类。 UNNotificationCenterDelegate：协议，其中方法用于监听通知状态。 三、进行通知用户权限申请与创建普通的本地通知要在iOS系统中使用通知，必须获取到用户权限，UserNotification框架中申请通知用户权限需要通过UNNotificationCenter来完成，示例如下： 12345678//进行用户权限的申请[[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionBadge|UNAuthorizationOptionSound|UNAuthorizationOptionAlert|UNAuthorizationOptionCarPlay completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; //在block中会传入布尔值granted，表示用户是否同意 if (granted) &#123; //如果用户权限申请成功，设置通知中心的代理 [UNUserNotificationCenter currentNotificationCenter].delegate = self; &#125;&#125;]; 申请用户权限的方法中需要传入一个权限内容的参数，其枚举定义如下： 12345678910typedef NS_OPTIONS(NSUInteger, UNAuthorizationOptions) &#123; //允许更新app上的通知数字 UNAuthorizationOptionBadge = (1 &lt;&lt; 0), //允许通知声音 UNAuthorizationOptionSound = (1 &lt;&lt; 1), //允许通知弹出警告 UNAuthorizationOptionAlert = (1 &lt;&lt; 2), //允许车载设备接收通知 UNAuthorizationOptionCarPlay = (1 &lt;&lt; 3),&#125;; 获取到用户权限后，使用UserNotification创建普通的通知，示例代码如下： 123456789101112131415161718192021//通知内容类UNMutableNotificationContent * content = [UNMutableNotificationContent new];//设置通知请求发送时 app图标上显示的数字content.badge = @2;//设置通知的内容content.body = @\"这是iOS10的新通知内容：普通的iOS通知\";//默认的通知提示音content.sound = [UNNotificationSound defaultSound];//设置通知的副标题content.subtitle = @\"这里是副标题\";//设置通知的标题content.title = @\"这里是通知的标题\";//设置从通知激活app时的launchImage图片content.launchImageName = @\"lun\";//设置5S之后执行UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefault\" content:content trigger:trigger];//添加通知请求[[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 效果如下面图示： 四、通知音效类UNNotificationSound通知可以进行自定义的音效设置，其中方法如下： 1234567//系统默认的音效+ (instancetype)defaultSound;//自定义的音频音效/*注意，音频文件必须在bundle中或者在Library/Sounds目录下*/+ (instancetype)soundNamed:(NSString *)name __WATCHOS_PROHIBITED; 五、通知触发器UNNotificationTrigger通知触发器可以理解为定义通知的发送时间，UNNotificationTrigger是触发器的基类，具体的触发器由它的四个子类实现，实际上，开发者在代码中可能会用到的触发器只有三种，UNPushNotificationTrigger远程推送触发器开发者不需要创建使用，远程通知有远程服务器触发，开发者只需要创建与本地通知有关的触发器进行使用。 1.UNTimeIntervalNotificationTriggerUNTimeIntervalNotificationTrigger是计时触发器，开发者可以设置其在添加通知请求后一定时间发送。 1234//创建触发器 在timeInterval秒后触发 可以设置是否循环触发+ (instancetype)triggerWithTimeInterval:(NSTimeInterval)timeInterval repeats:(BOOL)repeats;//获取下次触发的时间点- (nullable NSDate *)nextTriggerDate; 2.UNCalendarNotificationTriggerUNCalendarNotificationTrigger是日历触发器，开发者可以设置其在某个时间点触发。 1234//创建触发器 设置触发时间 可以设置是否循环触发+ (instancetype)triggerWithDateMatchingComponents:(NSDateComponents *)dateComponents repeats:(BOOL)repeats;//下一次触发的时间点- (nullable NSDate *)nextTriggerDate; 3.UNLocationNotificationTriggerUNLocationNotificationTrigger是地域触发器，开发者可以设置当用户进入某一区域时触发。 1234//地域信息@property (NS_NONATOMIC_IOSONLY, readonly, copy) CLRegion *region;//创建触发器+ (instancetype)triggerWithRegion:(CLRegion *)region repeats:(BOOL)repeats __WATCHOS_PROHIBITED; 六、为通知内容添加附件附件主要指的是媒体附件，例如图片，音频和视频，为通知内容添加附件需要使用UNNotificationAttachment类。示例代码如下： 1234567891011121314151617//创建图片附件UNNotificationAttachment * attach = [UNNotificationAttachment attachmentWithIdentifier:@\"imageAttach\" URL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"2\" ofType:@\"jpg\"]] options:nil error:nil];UNMutableNotificationContent * content = [UNMutableNotificationContent new];//设置附件数组content.attachments = @[attach];content.badge = @1;content.body = @\"这是iOS10的新通知内容：普通的iOS通知\";//默认的通知提示音content.sound = [UNNotificationSound defaultSound];content.subtitle = @\"这里是副标题\";content.title = @\"这里是通知的标题\";//设置5S之后执行UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO];UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefaultImage\" content:content trigger:trigger];[[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 效果如下图： 需要注意，UNNotificationContent的附件数组虽然是一个数组，但是系统的通知模板只能展示其中的第一个附件，设置多个附件也不会有额外的效果，但是如果开发者进行通知模板UI的自定义，则此数组就可以派上用场了。音频附件界面如下： 需要注意，添加附件的格式和大小都有一定的要求，如下表格所示： 创建通知内容附件UNNotificationAttachment实例的方法中有一个options配置字典，这个字典中可以进行配置的键值对如下： 12345678//配置附件的类型的键 需要设置为NSString类型的值，如果不设置 则默认从扩展名中推断extern NSString * const UNNotificationAttachmentOptionsTypeHintKey __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);//配置是否隐藏缩略图的键 需要配置为NSNumber 0或者1extern NSString * const UNNotificationAttachmentOptionsThumbnailHiddenKey __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);//配置使用一个标准的矩形来对缩略图进行裁剪，需要配置为CGRectCreateDictionaryRepresentation(CGRect)创建的矩形引用extern NSString * const UNNotificationAttachmentOptionsThumbnailClippingRectKey __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);//使用视频中的某一帧作为缩略图 配置为NSNumber时间extern NSString * const UNNotificationAttachmentOptionsThumbnailTimeKey __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0); 七、定义通知模板UNNotificationCategory聊天类软件在iOS系统中，常常采用后台推送的方式推送新消息，用户可以在不进入应用程序的情况下，直接在左面回复通知推送过来的信息，这种功能就是通过UNNotificationCategory模板与UNNotificationAction用户活动来实现的。关于文本回复框，UserNotification框架中提供了UNTextInputNotificationAction类，其是UNNotificationAction的子类。示例代码如下： 1234567891011121314151617181920212223242526272829303132//创建用户活动/*options参数可选如下：//需要在解开锁屏下使用UNNotificationActionOptionAuthenticationRequired//是否指示有破坏性UNNotificationActionOptionDestructive//是否允许活动在后台启动appUNNotificationActionOptionForeground//无设置UNNotificationActionOptionNone*/UNTextInputNotificationAction * action = [UNTextInputNotificationAction actionWithIdentifier:@\"action\" title:@\"回复\" options:UNNotificationActionOptionAuthenticationRequired textInputButtonTitle:@\"活动\" textInputPlaceholder:@\"请输入回复内容\"];//创建通知模板UNNotificationCategory * category = [UNNotificationCategory categoryWithIdentifier:@\"myNotificationCategoryText\" actions:@[action] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction];UNMutableNotificationContent * content = [UNMutableNotificationContent new];content.badge = @1;content.body = @\"这是iOS10的新通知内容：普通的iOS通知\";//默认的通知提示音content.sound = [UNNotificationSound defaultSound];content.subtitle = @\"这里是副标题\";content.title = @\"这里是通知的标题\";//设置通知内容对应的模板 需要注意 这里的值要与对应模板id一致content.categoryIdentifier = @\"myNotificationCategoryText\";//设置5S之后执行UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithObjects:category, nil]];UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefaultText\" content:content trigger:trigger]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 需要注意，要使用模板，通知内容UNNotificationContent的categoryIdentifier要与UNNotificationCategory的id一致。效果如下： 也可以为通知模板添加多个自定义的用户交互按钮，示例如下： 1234567891011121314151617181920UNNotificationAction * action = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题1\" options:UNNotificationActionOptionNone]; UNNotificationAction * action2 = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题2\" options:UNNotificationActionOptionNone]; UNNotificationAction * action3 = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题3\" options:UNNotificationActionOptionNone]; UNNotificationAction * action4 = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题4\" options:UNNotificationActionOptionNone]; UNNotificationCategory * category = [UNNotificationCategory categoryWithIdentifier:@\"myNotificationCategoryBtn\" actions:@[action,action2,action3,action4] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; UNMutableNotificationContent * content = [UNMutableNotificationContent new]; content.badge = @1; content.body = @\"这是iOS10的新通知内容：普通的iOS通知\"; //默认的通知提示音 content.sound = [UNNotificationSound defaultSound]; content.subtitle = @\"这里是副标题\"; content.title = @\"这里是通知的标题\"; content.categoryIdentifier = @\"myNotificationCategoryBtn\"; //设置5S之后执行 UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefault\" content:content trigger:trigger]; [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithObjects:category, nil]]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 需要注意，系统模板最多支持添加4个用户交互按钮，如下图： 八、自定义通知模板UI通过前边的介绍，我们发现通过UserNotification框架开发者已经可以完成许多从来很难实现的效果。然而这都不是UserNotification框架最强大的地方，UserNotification框架最强大的地方在于其可以完全自定义通知的UI界面。 完全自定义通知界面是通过iOS扩展来实现的，首先创建一个新的target，如下图： 选择Notification Content，如下： 创建完成后，会发现工程中多了一个Notification Content的扩展，其中自带一个storyboard文件和一个NotificationViewController类，开发者可以在storyboard文件或者直接在Controller类中进行自定义界面的编写。 需要注意，NotificationViewController自动遵守了UNNotificationContentExtension协议，这个协议专门用来处理自定义通知UI的内容展示，其中方法列举如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//接收到通知时会被调用/*开发者可以从notification对象中拿到附件等内容进行UI刷新*/- (void)didReceiveNotification:(UNNotification *)notification;//当用户点击了通知中的用户交互按钮时会被调用/*response对象中有通知内容相关信息在回调block块completion中，开发者可以传入一个UNNotificationContentExtensionResponseOption参数来告诉系统如何处理这次用户活动UNNotificationContentExtensionResponseOption枚举中可选值如下：typedef NS_ENUM(NSUInteger, UNNotificationContentExtensionResponseOption) &#123; //不关闭当前通知界面 UNNotificationContentExtensionResponseOptionDoNotDismiss, //关闭当前通知界面 UNNotificationContentExtensionResponseOptionDismiss, //关闭当前通知界面并将用户活动传递给宿主app处理 UNNotificationContentExtensionResponseOptionDismissAndForwardAction,&#125; __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE;*/- (void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption option))completion;/*这个属性作为get方法进行实现 这个方法用来返回一个通知界面要显示的媒体按钮typedef NS_ENUM(NSUInteger, UNNotificationContentExtensionMediaPlayPauseButtonType) &#123; //不显示媒体按钮 UNNotificationContentExtensionMediaPlayPauseButtonTypeNone, //默认的媒体按钮 当点击按钮后 进行播放与暂停的切换 按钮始终显示 UNNotificationContentExtensionMediaPlayPauseButtonTypeDefault, //Overlay风格 当点击按钮后，媒体播放，按钮隐藏 点击媒体后，播放暂停，按钮显示。 UNNotificationContentExtensionMediaPlayPauseButtonTypeOverlay,&#125; __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE;*/@property (nonatomic, readonly, assign) UNNotificationContentExtensionMediaPlayPauseButtonType mediaPlayPauseButtonType;//返回媒体按钮的位置@property (nonatomic, readonly, assign) CGRect mediaPlayPauseButtonFrame;//返回媒体按钮的颜色@property (nonatomic, readonly, copy) UIColor *mediaPlayPauseButtonTintColor;//点击播放按钮的回调- (void)mediaPlay;//点击暂停按钮的回调- (void)mediaPause;//媒体开始播放的回调- (void)mediaPlayingStarted __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE;//媒体开始暂停的回调- (void)mediaPlayingPaused __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE; 需要注意，自定义的通知界面上虽然可以放按钮，可以放任何UI控件，但是其不能进行用户交互，唯一可以进行用户交互的方式是通过协议中的媒体按钮及其回调方法。 定义好了通知UI模板，若要进行使用，还需要再Notification Content扩展中的info.plist文件的NSExtension字典的NSExtensionAttributes字典里进行一些配置，正常情况下，开发者需要进行配置的键有3个，分别如下： UNNotificationExtensionCategory：设置模板的categoryId，用于与UNNotificationContent对应。 UNNotificationExtensionInitialContentSizeRatio：设置自定义通知界面的高度与宽度的比，宽度为固定宽度，在不同设备上有差别，开发者需要根据宽度计算出高度进行设置，系统根据这个比值来计算通知界面的高度。 UNNotificationExtensionDefaultContentHidden：是有隐藏系统默认的通知界面。 配置info.plist文件如下： 用如下的代码创建通知： 123456789101112131415161718UNNotificationAction * action = [UNNotificationAction actionWithIdentifier:@\"action\" title:@\"活动标题1\" options:UNNotificationActionOptionNone]; //根据id拿到自定义UI的模板 UNNotificationCategory * category = [UNNotificationCategory categoryWithIdentifier:@\"myNotificationCategoryH\" actions:@[action] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction]; UNMutableNotificationContent * content = [UNMutableNotificationContent new]; content.badge = @1; content.body = @\"这是iOS10的新通知内容：普通的iOS通知\"; //默认的通知提示音 content.sound = [UNNotificationSound defaultSound]; content.subtitle = @\"这里是副标题\"; content.title = @\"这里是通知的标题\"; content.categoryIdentifier = @\"myNotificationCategoryH\"; //设置5S之后执行 UNTimeIntervalNotificationTrigger * trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:5 repeats:NO]; UNNotificationRequest * request = [UNNotificationRequest requestWithIdentifier:@\"NotificationDefaultCustomUIH\" content:content trigger:trigger]; [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithObjects:category, nil]]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; &#125;]; 效果如下图： 如果将UNNotificationExtensionDefaultContentHidden键值设置为0或者不设置，则不会隐藏系统默认的UI，如下： 九、通知回调的处理UserNotification框架对于通知的回调处理，是通过UNUserNotificationCenterDelegate协议来实现的，这个协议中有两个方法，如下： 1234567891011121314151617181920/*这个方法在应用在前台，并且将要弹出通知时被调用，后台状态下弹通知不会调用这个方法这个方法中的block块completionHandler()可以传入一个UNNotificationPresentationOptions类型的枚举有个这个参数，开发者可以设置在前台状态下，依然可以弹出通知消息，枚举如下：typedef NS_OPTIONS(NSUInteger, UNNotificationPresentationOptions) &#123; //只修改app图标的消息数 UNNotificationPresentationOptionBadge = (1 &lt;&lt; 0), //只提示通知音效 UNNotificationPresentationOptionSound = (1 &lt;&lt; 1), //只弹出通知框 UNNotificationPresentationOptionAlert = (1 &lt;&lt; 2),&#125; __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);//什么都不做static const UNNotificationPresentationOptions UNNotificationPresentationOptionNone */- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0);/*这个方法当接收到通知后，用户点击通知激活app时被调用，无论前台还是后台*/- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler __IOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0) __TVOS_PROHIBITED; 十、UserNotification框架中其他零散知识前面所介绍的内容基本涵盖了UserNotification框架中所有的内容，在以后的应用开发中，开发者可以在通知方面发挥更大的想象力与创造力，给用户更加友好的体验。除了前边所介绍过的核心内容外，UserNotification框架中还有一些零散的类、枚举等。 1.错误码描述1234567891011121314151617181920typedef NS_ENUM(NSInteger, UNErrorCode) &#123; //通知不被允许 UNErrorCodeNotificationsNotAllowed = 1, //附件无效url UNErrorCodeAttachmentInvalidURL = 100, //附件类型错误 UNErrorCodeAttachmentUnrecognizedType, //附件大小错误 UNErrorCodeAttachmentInvalidFileSize, //附件数据错误 UNErrorCodeAttachmentNotInDataStore, UNErrorCodeAttachmentMoveIntoDataStoreFailed, UNErrorCodeAttachmentCorrupt, //时间无效 UNErrorCodeNotificationInvalidNoDate = 1400, //无内容 UNErrorCodeNotificationInvalidNoContent,&#125; __IOS_AVAILABLE(10.0) __TVOS_AVAILABLE(10.0) __WATCHOS_AVAILABLE(3.0); 2.UNNotification类123456789@interface UNNotification : NSObject &lt;NSCopying, NSSecureCoding&gt;//触发的时间@property (nonatomic, readonly, copy) NSDate *date;//内置的通知请求对象@property (nonatomic, readonly, copy) UNNotificationRequest *request;- (instancetype)init NS_UNAVAILABLE;@end 3.UNNotificationSettings类UNNotificationSettings类主要用来获取与通知相关的信息。 12345678910111213141516171819@interface UNNotificationSettings : NSObject &lt;NSCopying, NSSecureCoding&gt;//用户权限状态@property (NS_NONATOMIC_IOSONLY, readonly) UNAuthorizationStatus authorizationStatus;//音效设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting soundSetting __TVOS_PROHIBITED;//图标提醒设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting badgeSetting __WATCHOS_PROHIBITED;//提醒框设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting alertSetting __TVOS_PROHIBITED;//通知中心设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting notificationCenterSetting __TVOS_PROHIBITED;//锁屏设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting lockScreenSetting __TVOS_PROHIBITED __WATCHOS_PROHIBITED;//车载设备设置@property (NS_NONATOMIC_IOSONLY, readonly) UNNotificationSetting carPlaySetting __TVOS_PROHIBITED __WATCHOS_PROHIBITED;//提醒框风格@property (NS_NONATOMIC_IOSONLY, readonly) UNAlertStyle alertStyle __TVOS_PROHIBITED __WATCHOS_PROHIBITED;@end UNNotificationSetting枚举如下： 12345678910typedef NS_ENUM(NSInteger, UNNotificationSetting) &#123; //不支持 UNNotificationSettingNotSupported = 0, //不可用 UNNotificationSettingDisabled, //可用 UNNotificationSettingEnabled,&#125; UNAuthorizationStatus枚举如下： 12345678910typedef NS_ENUM(NSInteger, UNAuthorizationStatus) &#123; //为做选择 UNAuthorizationStatusNotDetermined = 0, // 用户拒绝 UNAuthorizationStatusDenied, // 用户允许 UNAuthorizationStatusAuthorized&#125; UNAlertStyle枚举如下： 12345678typedef NS_ENUM(NSInteger, UNAlertStyle) &#123; //无 UNAlertStyleNone = 0, //顶部Banner样式 UNAlertStyleBanner, //警告框样式 UNAlertStyleAlert,&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}],"tags":[],"keywords":[{"name":"iOS10专题","slug":"iOS10专题","permalink":"http://huishao.cc/categories/iOS10专题/"}]},{"title":"iOS文本布局探讨之三——使用TextKit框架进行富文本布局","slug":"254iOS文本布局探讨之三——使用TextKit框架进行富文本布局","date":"2016-09-09T16:00:00.000Z","updated":"2021-07-12T02:27:59.479Z","comments":true,"path":"2016/09/10/254iOS文本布局探讨之三——使用TextKit框架进行富文本布局/","link":"","permalink":"http://huishao.cc/2016/09/10/254iOS文本布局探讨之三——使用TextKit框架进行富文本布局/","excerpt":"","text":"iOS文本布局探讨之三——使用TextKit框架进行富文本布局一、引言关于图文混排，其实以前的博客已经讨论很多，在实际开发中，经常使用第三方的框架来完成排版的需求，其中RCLabel和RTLabel是两个比较好用的第三方库，他们的实现都是基于UIView的，通过更底层的CoreText相关API来进行图文处理。相关介绍博客地址如下： iOS中支持HTML标签渲染的MDHTMLLaebl：http://my.oschina.net/u/2340880/blog/703254。 扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计：http://my.oschina.net/u/2340880/blog/499311。 iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展：http://my.oschina.net/u/2340880/blog/550194。 二、原生UILabel真的只能渲染文字么？CoreText是一个比较底层且十分强大的文本渲染框架，但是其使用起来并不是十分方便。在较低版本的iOS系统中，要进行富文本排版十分困难。在iOS6中，系统为UILabel，UITextView等这类文本渲染控件引入了NSAttributedString属性，有了NSAttributedString这个类，创建灵活多彩的文本控件变得十分轻松，开发者只需要配置NSAttributedString属性字符串即可。但是要进行图文混排，依然比较困难。iOS7之后引入TextKit框架，就完美的解决了图文混排这样的问题。 首先，iOS7中新添加了一类NSTextAttachment，从类名理解它是一个文本附件，其实也正是如此，NSTextAttachment类可以向文本中添加一些附件，这有些向邮件系统，寄信者可以向邮件中添加附件一同发送出去。NSTextAttachment类并不直接参与富文本的渲染与布局，渲染和布局依然由NSAttributedString类来完成，NSAttributedString类中提供了方法将NSTextAttachment所描述的内容转换为NSAttributedString示例。以一个简单的图文混排为例： 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; //进行NSTextAttachment的创建 NSTextAttachment * attach = [[NSTextAttachment alloc]init]; //设置显示的图片 attach.image =[UIImage imageNamed:@\"image\"]; //设置尺寸 attach.bounds = CGRectMake(0, 0, 120, 60); NSTextAttachment * attach2 = [[NSTextAttachment alloc]init]; attach2.image =[UIImage imageNamed:@\"image2\"]; attach2.bounds = CGRectMake(0, 0, 100, 90); //创建文本NSAttributedString对象 NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:@\"Describes a dictionary that fully specifies a font.... UIFontDescriptorInherits From NSObject UIFontDescriptor NSObject UIFontDescriptor Conforms To CVarArgT... 这里是中文\"]; //将NSTextAttachment映射为NSAttributedString对象 NSMutableAttributedString * att = [[NSMutableAttributedString alloc]initWithAttributedString:[NSAttributedString attributedStringWithAttachment:attach]]; //将图片插入NSAttributedString中 [attri insertAttributedString:att atIndex:15]; [attri insertAttributedString:[NSAttributedString attributedStringWithAttachment:attach2] atIndex:130]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(20, 20, 280, 540)]; label.backgroundColor = [UIColor grayColor]; label.numberOfLines = 0; label.attributedText = attri; [self.view addSubview:label];&#125; 运行工程后，效果如下图所示，其实只使用UILabel也可以实现复杂的富文本和图文混排： 三、为富文本附件添加用户交互能力TextKit框架强大到只使用UILabel就可以完成复杂的富文本布局，但是UILabel有一个致命的缺陷，其无法进行用户交互。试想，如果可以向一段文本中添加任意数据类型的文件，当用户点击这个文件时，可以获取到文件数据并进行业务逻辑处理，这将十分酷。这样富文本布局其实就不只局限于图文混排了，我们可以插入音频，插入视频，甚至插入任意自定义格式的数据。结合使用NSTextAttachment与UITextView，这些都能实现。先看NSTextAttachment类中的一些常用属性与方法： 1234567891011121314//这个初始化方法用于创建携带任意数据的文本附件- (instancetype)initWithData:(nullable NSData *)contentData ofType:(nullable NSString *)uti NS_DESIGNATED_INITIALIZER NS_AVAILABLE(10_11, 7_0);//携带的数据内容@property(nullable, copy, NS_NONATOMIC_IOSONLY) NSData *contents NS_AVAILABLE(10_11, 7_0);//数据类型@property(nullable, copy, NS_NONATOMIC_IOSONLY) NSString *fileType NS_AVAILABLE(10_11, 7_0);//设置渲染的图片 需要注意 如果设置的这个 附件携带的数据 fileWrapper目录内容将无效@property(nullable, strong, NS_NONATOMIC_IOSONLY) UIImage *image NS_AVAILABLE(10_11, 7_0);//设置图片渲染的尺寸@property(NS_NONATOMIC_IOSONLY) CGRect bounds NS_AVAILABLE(10_11, 7_0);//设置附件携带的文件目录 需要注意 如果设置了这个属性 image和data将无效@property(nullable, strong, NS_NONATOMIC_IOSONLY) NSFileWrapper *fileWrapper; 结合UITextView可以为NSAttributedString属性字符串添加超链接，在代码回调中监听此超链接的回调可以获取NSTextAttachment携带的附件内容，如此就可以自由的进行业务处理了，示例代码如下： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; //保留一个数组存放附件 _attArray = [NSMutableArray array]; //创建附件数据 NSData * stringData = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"image3\" ofType:@\"gif\"]]; NSTextAttachment * attach = [[NSTextAttachment alloc]initWithData:stringData ofType:@\"gif\"]; [_attArray addObject:attach]; attach.bounds = CGRectMake(0, 0, 30, 40); NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:@\"Describes a dictionary that fully specifies a font.... UIFontDescriptorInherits From NSObject UIFontDescriptor NSObject UIFontDescriptor Conforms To CVarArgT... 这里是中文\"]; NSMutableAttributedString * att = [[NSMutableAttributedString alloc]initWithAttributedString:[NSAttributedString attributedStringWithAttachment:attach]]; //为NSTextAttachment转换为的NSAttributedString添加超链接 [att addAttributes:@&#123;NSLinkAttributeName:@\"url...\"&#125; range:NSMakeRange(0, att.string.length)]; [attri insertAttributedString:att atIndex:15]; UITextView * textView = [[UITextView alloc]initWithFrame:CGRectMake(20, 20, 280, 540)]; textView.backgroundColor = [UIColor grayColor]; textView.dataDetectorTypes = UIDataDetectorTypeLink; textView.delegate =self; textView.attributedText = attri; textView.editable = NO; [self.view addSubview:textView];&#125; 实现如下的TextView代理方法： 12345678-(BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange&#123; //可以获取到url 进行匹配 NSLog(@\"%@\",URL); //取出NSTextAttachment附件 NSTextAttachment * attach =_attArray.firstObject; NSLog(@\"%@--\",attach.contents); return YES;&#125; 向文本中添加任意数据的NSTextAttachment会展现一个文件的图标，如下图所示： 当用户点击文件图标时，会将携带的gif文件数据进行打印。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS文本布局探讨之二——关于TextKit框架中的字体描述","slug":"253iOS文本布局探讨之二——关于TextKit框架中的字体描述","date":"2016-09-08T16:00:00.000Z","updated":"2021-07-12T02:27:07.823Z","comments":true,"path":"2016/09/09/253iOS文本布局探讨之二——关于TextKit框架中的字体描述/","link":"","permalink":"http://huishao.cc/2016/09/09/253iOS文本布局探讨之二——关于TextKit框架中的字体描述/","excerpt":"","text":"iOS文本布局探讨之二——关于TextKit框架中的字体描述一、引言UIFont是iOS开发中处理文本字体的类，关于UIFont的相关内容，以前的一篇博客有详细介绍，本片博客主要介绍关于动态字体的应用与字体描述类NSFontDescriptor的应用。 UIFont应用介绍：http://my.oschina.net/u/2340880/blog/397115。 二、iOS系统中的动态字体所谓动态字体，是指在应用使用中，用户可以动态调整字体的风格字号等。在iOS7及之后的iOS系统版本，TextKit框架中提供了一个新的类UIFontDescriptor。简单理解，UIFontDescriptor类是专门用来描述字体的，其中提供了许多方法可以直接创建出某种字体，也可以对字体进行设置和调整。动态字体也由这个类来创建。 在iOS7之后，系统增加了动态字体的功能，当用户在系统设置中修改字体的属性或者字号时，不仅会影响系统应用的字体，第三方应用的字体也可以进行相应调整。系统设置字体界面如下： 使用UIFontDescriptor类中的如下方法可以创建动态字体： 12//创建动态字体的字体描述类实例+ (UIFontDescriptor *)preferredFontDescriptorWithTextStyle:(NSString *)style; UIFont类中的如下方法可以将字体描述类转换成UIFont字体： 1+ (UIFont *)fontWithDescriptor:(UIFontDescriptor *)descriptor size:(CGFloat)pointSize NS_AVAILABLE_IOS(7_0); 系统定义了一组动态字体的风格字符创常量，开发者可以根据需求选用： 1234567891011121314151617181920//标题1UIKIT_EXTERN NSString *const UIFontTextStyleTitle1 NS_AVAILABLE_IOS(9_0);//标题2UIKIT_EXTERN NSString *const UIFontTextStyleTitle2 NS_AVAILABLE_IOS(9_0);//标题3UIKIT_EXTERN NSString *const UIFontTextStyleTitle3 NS_AVAILABLE_IOS(9_0);//大标题UIKIT_EXTERN NSString *const UIFontTextStyleHeadline NS_AVAILABLE_IOS(7_0);//子标题UIKIT_EXTERN NSString *const UIFontTextStyleSubheadline NS_AVAILABLE_IOS(7_0);//内容UIKIT_EXTERN NSString *const UIFontTextStyleBody NS_AVAILABLE_IOS(7_0);//标注UIKIT_EXTERN NSString *const UIFontTextStyleCallout NS_AVAILABLE_IOS(9_0);//注脚UIKIT_EXTERN NSString *const UIFontTextStyleFootnote NS_AVAILABLE_IOS(7_0);//字幕UIKIT_EXTERN NSString *const UIFontTextStyleCaption1 NS_AVAILABLE_IOS(7_0);//字幕2UIKIT_EXTERN NSString *const UIFontTextStyleCaption2 NS_AVAILABLE_IOS(7_0); 三、关于UIFontDescriptor类UIFontDescriptor类可以直接通过字体名称来进行创建： 1234//通过字体名称和字号尺寸来进行UIFontDescriptor对象的创建+ (UIFontDescriptor *)fontDescriptorWithName:(NSString *)fontName size:(CGFloat)size;//通过字体名称创建UIFontDescriptor对象，并且设置变换参数+ (UIFontDescriptor *)fontDescriptorWithName:(NSString *)fontName matrix:(CGAffineTransform)matrix; CGAffineTransform是一个结构体，其用于文本的控件变换十分强大，在CoreAnimation框架中有CATransform3D这个结构体，CGAffineTransform与其用法十分相似，使其它可以完成文字的形变，旋转等。示例如下： 123456789101112//进行旋转CGAffineTransform transfom = CGAffineTransformRotate(CGAffineTransformIdentity, 0.1);//进行纵向拉伸transfom = CGAffineTransformScale(transfom, 1, 3);UIFontDescriptor * fontDes = [UIFontDescriptor fontDescriptorWithName:[UIFont systemFontOfSize:14].fontName matrix:transfom];UIFont * font = [UIFont fontWithDescriptor:fontDes size:14];UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 280, 400)];label.backgroundColor = [UIColor grayColor];label.font = font;label.numberOfLines = 0;label.text = @\"Describes a dictionary that fully specifies a font.... UIFontDescriptorInherits From NSObject UIFontDescriptor NSObject UIFontDescriptor Conforms To CVarArgT... 这里是中文\";[self.view addSubview:label]; 效果如下： 开发者也可以通过配置地点的方式来创建UIFontDescriptor对象： 1- (instancetype)initWithFontAttributes:(NSDictionary&lt;NSString *, id&gt; *)attributes; 字典中可以配置的键值如下： 12345678910111213141516171819//需要配置为NSValue值 CGAffineTransformUIKIT_EXTERN NSString *const UIFontDescriptorMatrixAttribute;//需要配置为一个集合set 包含所有字体字符UIKIT_EXTERN NSString *const UIFontDescriptorCharacterSetAttribute;//需要配置为一个数组 数组中为字体描述对象UIKIT_EXTERN NSString *const UIFontDescriptorCascadeListAttribute;//需要配置为一个字典 其中进行字体特征的描述 后面会介绍UIKIT_EXTERN NSString *const UIFontDescriptorTraitsAttribute;//需要配置为NSNumber类型的 浮点数 其会影响到字体排版时的字符间距UIKIT_EXTERN NSString *const UIFontDescriptorFixedAdvanceAttribute;//需要配置为一个数组 数组中为字典 字典中对字型进行配置/*//字典中需要配置这两个键UIKIT_EXTERN NSString *const UIFontFeatureTypeIdentifierKey NS_AVAILABLE_IOS(7_0);UIKIT_EXTERN NSString *const UIFontFeatureSelectorIdentifierKey NS_AVAILABLE_IOS(7_0);*/UIKIT_EXTERN NSString *const UIFontDescriptorFeatureSettingsAttribute;//配置字体风格 可用的在前面列举过UIKIT_EXTERN NSString *const UIFontDescriptorTextStyleAttribute; 关于字体的特征藐视，即上面UIFontDescriptorTraitsAttribute键值所配置的字典，这个字典中可以设置的键值如下： 1234567891011121314151617181920//这个键值需要配置为一个NSNumber值，设置文字的渲染特征 后面会介绍UIKIT_EXTERN NSString *const UIFontSymbolicTrait;//设置字体的粗细属性 /*这个键可以设置的值如下UIKIT_EXTERN const CGFloat UIFontWeightUltraLight NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightThin NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightLight NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightRegular NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightMedium NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightSemibold NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightBold NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightHeavy NS_AVAILABLE_IOS(8_2);UIKIT_EXTERN const CGFloat UIFontWeightBlack NS_AVAILABLE_IOS(8_2);*/UIKIT_EXTERN NSString *const UIFontWeightTrait;//设置字体宽度UIKIT_EXTERN NSString *const UIFontWidthTrait;//设置字体倾斜UIKIT_EXTERN NSString *const UIFontSlantTrait; 关于上面UIFontSymbolicTrait键值，定义在UIFontDescriptorSymbolicTraits枚举中，如下： 12345678910111213141516171819202122232425typedef NS_OPTIONS(uint32_t, UIFontDescriptorSymbolicTraits) &#123; UIFontDescriptorTraitItalic = 1u &lt;&lt; 0, UIFontDescriptorTraitBold = 1u &lt;&lt; 1, UIFontDescriptorTraitExpanded = 1u &lt;&lt; 5, UIFontDescriptorTraitCondensed = 1u &lt;&lt; 6, UIFontDescriptorTraitMonoSpace = 1u &lt;&lt; 10, UIFontDescriptorTraitVertical = 1u &lt;&lt; 11, UIFontDescriptorTraitUIOptimized = 1u &lt;&lt; 12, UIFontDescriptorTraitTightLeading = 1u &lt;&lt; 15, UIFontDescriptorTraitLooseLeading = 1u &lt;&lt; 16, UIFontDescriptorClassMask = 0xF0000000, UIFontDescriptorClassUnknown = 0u &lt;&lt; 28, UIFontDescriptorClassOldStyleSerifs = 1u &lt;&lt; 28, UIFontDescriptorClassTransitionalSerifs = 2u &lt;&lt; 28, UIFontDescriptorClassModernSerifs = 3u &lt;&lt; 28, UIFontDescriptorClassClarendonSerifs = 4u &lt;&lt; 28, UIFontDescriptorClassSlabSerifs = 5u &lt;&lt; 28, UIFontDescriptorClassFreeformSerifs = 7u &lt;&lt; 28, UIFontDescriptorClassSansSerif = 8u &lt;&lt; 28, UIFontDescriptorClassOrnamentals = 9u &lt;&lt; 28, UIFontDescriptorClassScripts = 10u &lt;&lt; 28, UIFontDescriptorClassSymbolic = 12u &lt;&lt; 28&#125; NS_ENUM_AVAILABLE_IOS(7_0); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS文本布局探讨之一——文本布局框架TextKit浅析","slug":"252iOS文本布局探讨之一——文本布局框架TextKit浅析","date":"2016-09-07T16:00:00.000Z","updated":"2021-07-12T02:26:22.142Z","comments":true,"path":"2016/09/08/252iOS文本布局探讨之一——文本布局框架TextKit浅析/","link":"","permalink":"http://huishao.cc/2016/09/08/252iOS文本布局探讨之一——文本布局框架TextKit浅析/","excerpt":"","text":"iOS文本布局探讨之一——文本布局框架TextKit浅析一、引言在iOS开发中，处理文本的视图控件主要有4中，UILabel，UITextField，UITextView和UIWebView。其中UILabel与UITextField相对简单，UITextView是功能完备的文本布局展示类，通过它可以进行复杂的富文本布局，UIWebView主要用来加载网页或者pdf文件，其可以进行HTML,CSS和JS等文件的解析。 TextKit是一个偏上层的开发框架，在iOS7以上可用，使用它开发者可以方便灵活处理复杂的文本布局，满足开发中对文本布局的各种复杂需求。TextKit实际上是基于CoreText的一个上层框架，其是面向对象的，如果TextKit中提供的API无法满足需求，可以使用CoreText中的API进行更底层的开发。 官方文档中的一张图片很确切，经常会被用来描述TextKit框架在iOS系统文本渲染中所处的位置。 二、TextKit框架的结构界面在进行文本的渲染时，有下面几个必要条件： 1.要渲染展示的内容。 2.将内容渲染在某个视图上。 3.内容渲染在视图上的尺寸位置和形状。 在TextKit框架中，提供了几个类分别对应处理上述的必要条件： 1.NSTextStorage对应要渲染展示的内容。 2.UITextView对应要渲染的视图。 3.NSTextContainer对应渲染的尺寸位置和形状信息。 除了上述3个类之外，TextKit框架中的NSLayoutManager类作为协调者来进行布局操作。 上述关系如下图所示： 三、使用TextKit进行文本布局流程个人理解，TextKit主要用于更精细的处理文本布局以及进行复杂的图文混排布局，使用TextKit进行文本的布局展示十分繁琐，首先需要将显示内容定义为一个NSTextStorage对象，之后为其添加一个布局管理器对象NSLayoutManager，在NSLayoutManager中，需要进行NSTextContainer的定义，定义多了NSTextContainer对象则会将文本进行分页。最后，将要展示的NSTextContainer绑定到具体的UITextView视图上。 示例代码如下： 12345678910111213//定义ContainerNSTextContainer * container = [[NSTextContainer alloc]initWithSize:CGSizeMake(150, 200)];//定义布局管理类NSLayoutManager * layoutManager = [[NSLayoutManager alloc]init];//将container添加进布局管理类管理[layoutManager addTextContainer:container];//定义一个StorageNSTextStorage * storage = [[NSTextStorage alloc]initWithString:@\"The NSTextContainer class defines a region where text is laid out. An NSLayoutManager uses NSTextContainer to determine where to break lines, lay out portions of text, and so on.\"];//为Storage添加一个布局管理器[storage addLayoutManager:layoutManager];//将要显示的container与视图TextView绑定UITextView * textView = [[UITextView alloc]initWithFrame:self.view.frame textContainer:container];[self.view addSubview:textView]; 上面代码演示的过程如下图所示： 需要注意，TextKit进行布局的核心思路是最终的视图对应一个文本块Container，并不是一段文本内容Storage，LayoutManager会将完整的内容根据其中Container的尺寸进行分页，TextView根据需要显示的部分进行Container的选择。 四、了解NSTextContainer类NSTextContainer可以简单理解为创建一个文本区块，文本内容将在这个区块中进行渲染，其中常用属性与方法如下： 1234567891011121314151617181920212223//初始化方法 设置区块的尺寸- (instancetype)initWithSize:(CGSize)size;//与其绑定的layoutManager 需要注意，不是设置这个属性 使用[NSLayoutManager addTextContainer:]方式来进行绑定@property(nullable, assign, NS_NONATOMIC_IOSONLY) NSLayoutManager *layoutManager;//替换绑定的布局管理类对象- (void)replaceLayoutManager:(NSLayoutManager *)newLayoutManager;//获取区块尺寸@property(NS_NONATOMIC_IOSONLY) CGSize size;//设置从区块中剔除某一区域@property(copy, NS_NONATOMIC_IOSONLY) NSArray&lt;UIBezierPath *&gt; *exclusionPaths;//设置截断模式 需要注意 这个属性的设置只是会影响此区块的最后一行的截断模式@property(NS_NONATOMIC_IOSONLY) NSLineBreakMode lineBreakMode;//设置每行文本左右空出的间距@property(NS_NONATOMIC_IOSONLY) CGFloat lineFragmentPadding;//设置TextView上可输入的文本最大行数@property(NS_NONATOMIC_IOSONLY) NSUInteger maximumNumberOfLines;//这个方法用于提供给子类进行重写 这里返回的Rect是可以布局文本的区域- (CGRect)lineFragmentRectForProposedRect:(CGRect)proposedRect atIndex:(NSUInteger)characterIndex writingDirection:(NSWritingDirection)baseWritingDirection remainingRect:(nullable CGRect *)remainingRect;//这个BOOL值的属性决定Container的宽度是否自适应TextView的宽度@property(NS_NONATOMIC_IOSONLY) BOOL widthTracksTextView;//这个BOOL值的属性决定Container的高度是否自适应TextView的高度@property(NS_NONATOMIC_IOSONLY) BOOL heightTracksTextView; 上面所列举的方法中，exclusionPaths属性十分强大，通过设置它，可以将布局区域内剔出一块区域不进行布局，示例代码如下： 123456789101112[super viewDidLoad]; NSTextContainer * container = [[NSTextContainer alloc]initWithSize:CGSizeMake(300, 500)]; UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:self.view.center radius:70 startAngle:0 endAngle:M_PI*2 clockwise:YES]; container.exclusionPaths = @[path]; container.lineBreakMode = NSLineBreakByCharWrapping; NSLayoutManager * layoutManager = [[NSLayoutManager alloc]init]; [layoutManager addTextContainer:container]; NSTextStorage * storage = [[NSTextStorage alloc]initWithString:@\"The NSTextContainer class defines a region where text is laid out. An NSLayoutManager uses NSTextContainer to determine where to break lines, lay out portions of text, and so on. An NSTextContainer object normally defines rectangular regions, but you can define exclusion paths inside the text container to create regions where text does not flow. You can also subclass to create text containers with nonrectangular regions, such as circular regions, regions with holes in them, or regions that flow alongside graphics.The NSTextContainer class defines a region where text is laid out. An NSLayoutManager uses NSTextContainer to determine where to break lines, lay out portions of text, and so on. An NSTextContainer object normally defines rectangular regions, but you can define exclusion paths inside the text container to create regions where text does not flow. You can also subclass to create text containers with nonrectangular regions, such as circular regions, regions with holes in them, or regions that flow alongside graphics.An NSLayoutManager uses NSTextContainer to determine where to break lines, lay out portions of text, and so on. An NSTextContainer object normally defines rectangular regions, but you can define exclusion paths inside the text container to create regions where text does not flow. You can also subclass to create text containers with nonrectangular regions, such as circular regions, regions with holes in them, or regions that flow alongside graphics.\"]; [storage addLayoutManager:layoutManager]; UITextView * textView = [[UITextView alloc]initWithFrame:self.view.frame textContainer:container]; [self.view addSubview:textView]; 效果如下图： 五、关于NSLayoutManager顾名思义，NSLayoutManager专门负责对文本的布局渲染，简单理解，其从NSTextStorage从拿去展示的内容，将去处理后布局到NSTextContainer中。 NSLayoutManager与NSTextContainer的关系为一对多，放入NSLayoutManager中的NSTextContainer会以有序数组的形式进行管理，在内容布局时，超出第一个NSTextContainer的内容会被布局到后一个NSTextContainer中。 NSLayoutManager中有关NSTextContainer操作的方法如下： 12345678910//container数组@property(readonly, NS_NONATOMIC_IOSONLY) NSArray&lt;NSTextContainer *&gt; *textContainers;//添加一个container- (void)addTextContainer:(NSTextContainer *)container;//在指定位置插入一个container- (void)insertTextContainer:(NSTextContainer *)container atIndex:(NSUInteger)index;//删除一个指定的container- (void)removeTextContainerAtIndex:(NSUInteger)index;//注意 这个方法不需要显式的调用 当布局Container发生变化时 系统会自动调用- (void)textContainerChangedGeometry:(NSTextContainer *)container; 与布局管理相关的属性与方法如下： 12345678910111213141516171819202122232425//是否显示隐形的符号/*默认为NO，如果设置为YES，则会将空格等隐形字符显示出来*/@property(NS_NONATOMIC_IOSONLY) BOOL showsInvisibleCharacters;//是否显示某些布局控制字符@property(NS_NONATOMIC_IOSONLY) BOOL showsControlCharacters;//这个属性可以用于设置断字/*这个属性的取值为0到1之间 默认为0 即单词换行时从来不会中断 越接近1 则使用连字符进行单词换行中断的概率越大*/@property(NS_NONATOMIC_IOSONLY) CGFloat hyphenationFactor;//是否使用字体定义的行距/*默认使用字体所定义的行距信息 通过设置这个属性为NO可以关闭此功能*/@property(NS_NONATOMIC_IOSONLY) BOOL usesFontLeading;//这个属性设置是否允许对相邻位置的内容进行布局 默认为YES，设置为NO后将可以提供大文本布局的效率@property(NS_NONATOMIC_IOSONLY) BOOL allowsNonContiguousLayout;//下面这几个方法用于移除某一范围内的布局- (void)invalidateGlyphsForCharacterRange:(NSRange)charRange changeInLength:(NSInteger)delta actualCharacterRange:(nullable NSRangePointer)actualCharRange;- (void)invalidateLayoutForCharacterRange:(NSRange)charRange actualCharacterRange:(nullable NSRangePointer)actualCharRange NS_AVAILABLE(10_5, 7_0);- (void)invalidateDisplayForCharacterRange:(NSRange)charRange;- (void)invalidateDisplayForGlyphRange:(NSRange)glyphRange; 六、文本内容类NSTextStorageNSTextStorage实际上是继承自NSMutableAttributedString。NSAttributedString是一种自带属性的字符串类，关于NSAttributedString的基本用法，如下博客中有介绍： http://my.oschina.net/u/2340880/blog/397500。 TextKit框架中在对文本进行布局时，主要关注于3个方面： 1.字符的属性，例如颜色，字体等。 2.行与段落的属性，如缩进，行间距等。 3.文档属性，包括四周边距、文档尺寸等。 这些都由NSAttributedString来进行定义。 如上所介绍的是TextKit框架的主要工作原理，文字渲染，图文混排的更多内容，后面博客会继续探讨。有疏漏之处，共同讨论进步。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Android开发中RelativeLayout相对布局","slug":"251Android开发中RelativeLayout相对布局","date":"2016-09-05T16:00:00.000Z","updated":"2021-07-12T02:25:31.791Z","comments":true,"path":"2016/09/06/251Android开发中RelativeLayout相对布局/","link":"","permalink":"http://huishao.cc/2016/09/06/251Android开发中RelativeLayout相对布局/","excerpt":"","text":"Android开发中RelativeLayout相对布局RelativeLayout布局是Android界面布局中应用最广也最强大的一种布局，其不仅十分灵活，可以解决开发中各种界面布局需求，同时也很方便了解决了多屏幕尺寸的适配问题。在iOS开发中，Autolayout技术总是被赞不绝口，RelativeLayout布局就是Andriod系统中的Autolayout，其又被称为相对布局。 所谓相对布局，是指其坐标的确定并不是开发者写死的，而是有系统自动计算出来的，那么系统如何计算每个视图控件的位置呢？开发者需要为其添加一些规则进行约束，这些规则大致包括2类： 第1类 与父视图之间位置关系的规则： 此类规则包括在父视图中的居中、左对齐、右对齐、上对齐、下对齐等。 第2类 平级视图之间相对位置关系的规则： 此类规则包括同级视图间对其关系，相对位置关系，例如A在B左侧20像素位置，B与C上边缘对齐等。 使用RelativeLayout进行布局示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); RelativeLayout relativeLayout = new RelativeLayout(this); Button button1 = new Button(this); button1.setText(\"按钮一\"); button1.setId(R.id.button1); RelativeLayout.LayoutParams layoutParams1 = new RelativeLayout.LayoutParams(200,200); //添加约束 使其靠近父视图右上角 layoutParams1.addRule(RelativeLayout.ALIGN_PARENT_TOP); layoutParams1.addRule(RelativeLayout.ALIGN_PARENT_RIGHT); button1.setLayoutParams(layoutParams1); Button button2 = new Button(this); button2.setText(\"按钮二\"); button2.setId(R.id.button2); RelativeLayout.LayoutParams layoutParams2 = new RelativeLayout.LayoutParams(200,200); //添加约束 让其右侧靠近按钮一左侧 上侧靠近按钮一下侧 layoutParams2.addRule(RelativeLayout.BELOW,R.id.button1); layoutParams2.addRule(RelativeLayout.LEFT_OF,R.id.button1); button2.setLayoutParams(layoutParams2); Button button3 = new Button(this); button3.setText(\"按钮三\"); button3.setId(R.id.button3); RelativeLayout.LayoutParams layoutParams3 = new RelativeLayout.LayoutParams(200,200); //添加约束 让其固定距离按钮二 下方100px 左侧边缘对其 layoutParams3.addRule(RelativeLayout.ALIGN_LEFT,R.id.button2); layoutParams3.addRule(RelativeLayout.BELOW,R.id.button2); layoutParams3.topMargin = 100; button3.setLayoutParams(layoutParams3); relativeLayout.addView(button1); relativeLayout.addView(button2); relativeLayout.addView(button3); setContentView(relativeLayout);&#125; 小提示：使用代码创建的视图，可以通过xml文件配置id，如下： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;item name=\"button1\" type=\"id\"&gt;&lt;/item&gt; &lt;item name=\"button2\" type=\"id\"&gt;&lt;/item&gt; &lt;item name=\"button3\" type=\"id\"&gt;&lt;/item&gt;&lt;/resources&gt; 效果如下图： RelativeLayout布局中视图位置的配置主要使用其内部类LayoutParams，这个内部类LayoutParams是继承自MarginLayoutParams。其中常用方法和属性列举如下： 123456789101112131415//设置左边距public int leftMargin;//设置上边距public int topMargin;//设置右边距public int rightMargin;//设置下边距public int bottomMargin;//添加一个规则 这个方法添加的规则不需要参照视图 例如靠近父视图边缘public void addRule(int verb)//添加一个规则 这个方法添加的规则需要一个参照视图 例如某两个平级视图间的位置关系 anchor参数为视图idpublic void addRule(int verb, int anchor) //移除一个布局规则public void removeRule(int verb) 用于进行布局规则配置的参数如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*=======需要使用addRule(int verb, int anchor)方法添加的约束规则==========*///将当前视图约束到某个视图左边public static final int LEFT_OF//将当前视图约束到某个视图右边public static final int RIGHT_OF//将当前视图约束到某个视图上边public static final int ABOVE//将当前视图约束到某个视图下边public static final int BELOW//将当前视图约束与某个视图基线对齐public static final int ALIGN_BASELINE//将当前视图约束与某个视图左侧对齐public static final int ALIGN_LEFT//将当前视图约束与某个视图上侧对齐public static final int ALIGN_TOP//将当前视图约束与某个视图右侧对齐public static final int ALIGN_RIGHT//将当前视图约束与某个视图下侧对齐public static final int ALIGN_BOTTOM//将当前视图约束与某个视图起始对齐public static final int START_OF//当当前视图约束与某个视图末尾对齐public static final int END_OF/*========需要使用addRule(int verb)方法添加的约束规则====================*///约束当前视图与父视图左侧对齐public static final int ALIGN_PARENT_LEFT//约束当前视图与父视图上侧对齐public static final int ALIGN_PARENT_TOP//约束当前视图与父视图上侧对齐public static final int ALIGN_PARENT_RIGHT//约束当前视图与父视图下侧对齐public static final int ALIGN_PARENT_BOTTOM//约束当前视图与父视图居中对齐public static final int CENTER_IN_PARENT//约束当前视图与父视图水平居中public static final int CENTER_HORIZONTAL//约束当前视图与父视图垂直居中public static final int CENTER_VERTICAL//约束当前视图与父视图起始对齐public static final int ALIGN_PARENT_START//约束当前视图与父视图末尾对齐public static final int ALIGN_PARENT_END 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发中TableLayout表格布局","slug":"250Android开发中TableLayout表格布局","date":"2016-09-04T16:00:00.000Z","updated":"2021-07-12T02:24:51.205Z","comments":true,"path":"2016/09/05/250Android开发中TableLayout表格布局/","link":"","permalink":"http://huishao.cc/2016/09/05/250Android开发中TableLayout表格布局/","excerpt":"","text":"Android开发中TableLayout表格布局一、引言在移动端应用程序开发中，常常会使用到表格布局，iOS和Android开发框架中都提供了独立的表格视图控件供开发者使用，例如iOS中的UITableView、UICollectionView，Android中的ListView、GridView等。除了独立的视图控件外，Android中还提供了一个布局容器类TableLayout，使用其也可以进行方便的表格布局。 前边博客有介绍过关于LinearLayout线性布局的相关内容，LinearLayout只能进行水平或者垂直方向上的排列布局，使用LinearLayout的布局嵌套，实际上也可以实现表格布局的样式。实际上，TableLayout就是采用这样的原理，TableLayout继承于LinearLayout，其中每个视图元素作为一行，同时Android中还提供了一个TableRow类，这个类同样继承自LinearLayout，其中每个视图元素作为当前行中的一列，结合使用TableLayout与TableRow，就实现了行列的表格布局。 二、关于TableRowTableRow可以简单理解为TableLayout布局中的一行，当然，TableLayout中也可以直接添加任意的View视图，但是默认添加的View视图将独占一行。TableRow中可以添加其他视图，每个视图被作为一列处理，通过TableRow的内部类LayoutParams来设置TableRow内部视图的布局方式，其中主要可以通过设置宽高或者设置权重来定制每列视图元素的尺寸，例如： 123456789101112131415161718192021222324252627282930TableLayout tableLayout = new TableLayout(this);//创建行 第一行用单个元素TextView textView = new TextView(this);textView.setText(\"1000\");textView.setTextSize(20);textView.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);tableLayout.addView(textView);//第二行使用TableRowTableRow tableRow1 = new TableRow(this);//设置本行中每一列的权重和tableRow1.setWeightSum(10);Button button11 = new Button(this);button11.setText(\"AC\");//设置固定宽高TableRow.LayoutParams layoutParams1 = new TableRow.LayoutParams(300,200);button11.setLayoutParams(layoutParams1);tableRow1.addView(button11);Button button12 = new Button(this);//通过权重设置列的宽度 占正常列宽的一半TableRow.LayoutParams layoutParams2 = new TableRow.LayoutParams(0,200,5);button12.setLayoutParams(layoutParams2);button12.setText(\"+/-\");tableRow1.addView(button12);Button button13 = new Button(this);button13.setText(\"%\");tableRow1.addView(button13);Button button14 = new Button(this);button14.setText(\"÷\");tableRow1.addView(button14);tableLayout.addView(tableRow1); 上面代码向TableRow中添加了4个视图，默认情况下会生成四列，setWeightSum()方法用于设置每列的权重和，需要注意，它作用的对象是每一列元素，而不是整行。上面的代码效果如下： 默认的列宽是评分整个行宽，可以通过指定宽度或者权重来修改特定列的列宽。 还有一点需要注意，如果一个TableLayout布局中多个TableRow，则表格的列数会以最多列的一行为准，例如在添加一行TableRow，而其中只有一列，则其依然会预留4列的位置，示例如下： 12345TableRow tableRow2 = new TableRow(this);Button button = new Button(this);button.setText(\"跳过\");tableRow2.addView(button);tableLayout.addView(tableRow2); 效果如下： 也可以设置跳过某列进行布局，或者进行列的合并，示例如下： 1234567891011TableRow tableRow2 = new TableRow(this);Button button = new Button(this);button.setText(\"跳过\");TableRow.LayoutParams layoutParams21 = new TableRow.LayoutParams();//从第2列开始layoutParams21.column = 1;//合并3列layoutParams21.span = 3;button.setLayoutParams(layoutParams21);tableRow2.addView(button);tableLayout.addView(tableRow2); 三、关于TableLayout在向TableLayout容器中添加或者移除视图的时候，开发者可以对其进行监听，示例如下： 123456789101112TableLayout tableLayout = new TableLayout(this);tableLayout.setOnHierarchyChangeListener(new ViewGroup.OnHierarchyChangeListener() &#123; @Override public void onChildViewAdded(View parent, View child) &#123; Toast.makeText(getBaseContext(),\"add\",Toast.LENGTH_SHORT).show(); &#125; @Override public void onChildViewRemoved(View parent, View child) &#123; Toast.makeText(getBaseContext(),\"remove\",Toast.LENGTH_SHORT).show(); &#125;&#125;); 开发者还可以对表格中视图元素的一些尺寸自适应做一些设置，其中还有一些常用的方法列举如下： 12345678910111213141516//获取表格中所有列是否是可收缩的public boolean isShrinkAllColumns()//设置表格中的所有列是否可收缩public void setShrinkAllColumns()//获取表格中的所有列是否可拉伸public boolean isStretchAllColumns()//设置表格中的所有列是否可拉伸public void setStretchAllColumns()//设置某一列是否可拉伸public void setColumnStretchable(int columnIndex, boolean isStretchable)//获取某一列是否可拉伸public boolean isColumnStretchable(int columnIndex)//设置某一列是否可收缩public void setColumnShrinkable(int columnIndex, boolean isShrinkable)//获取某一列是否可收缩public boolean isColumnShrinkable(int columnIndex) 所谓可收缩的列，是指如果此列的内容宽度超出一定宽度，为了使后面的列内容展示出来，此列宽度会自动收缩，高度会增加，如下图所示： 至于可拉伸的列，是指如果此行内容内有充满整行，此列会进行拉伸自动充满。 下面这些方法与表格中列的隐藏有关： 1234//设置某列是否隐藏public void setColumnCollapsed(int columnIndex, boolean isCollapsed)//获取某列是否被隐藏public boolean isColumnCollapsed(int columnIndex) 需要注意，在TableLayout中也定义了一个LayoutParams的内部类，其用于设置其中每一行视图元素的布局，但是开发者只能设置此布局类对应的高度参数，宽度将强制设置为MATCH_PARENT。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发之AbsoluteLayout绝对布局","slug":"249Android开发之AbsoluteLayout绝对布局","date":"2016-09-01T16:00:00.000Z","updated":"2021-07-12T02:24:10.327Z","comments":true,"path":"2016/09/02/249Android开发之AbsoluteLayout绝对布局/","link":"","permalink":"http://huishao.cc/2016/09/02/249Android开发之AbsoluteLayout绝对布局/","excerpt":"","text":"Android开发之AbsoluteLayout绝对布局AbsoluteLayout绝对布局已经被弃用，但是相关API依然有效，其又被称为坐标布局，在iOS开发支持Autolayout之前，所有的布局模式都可以理解为绝对布局。但是iPhone设备的屏幕尺寸有限，使用绝对不觉并不会出现太多难以解决的问题，但是对于Android设备就不同了，Android设备的屏幕尺寸和分辨率都无规范，使用坐标绝对布局的缺陷就十分明显。 AbsoluteLayout直接通过定位其内部视图的位置坐标点和尺寸来进行布局，后添加的视图优先级更高，如果坐标有重合，会覆盖先添加的视图，示例代码如下： 123456789101112131415161718192021222324252627282930313233@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); AbsoluteLayout absoluteLayout = new AbsoluteLayout(this); absoluteLayout.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); setContentView(absoluteLayout); //添加4个TextView TextView textView1 = new TextView(this); textView1.setText(\"第1个textView\"); //需要注意 这里的LayoutParams()构造方法中的参数 前两个参数为视图的宽和高 后两个为x与y位置坐标点 textView1.setLayoutParams(new AbsoluteLayout.LayoutParams(800,300,10,10)); textView1.setBackgroundColor(Color.RED); absoluteLayout.addView(textView1); TextView textView2 = new TextView(this); textView2.setText(\"第2个textView\"); textView2.setLayoutParams(new AbsoluteLayout.LayoutParams(800,300,100,200)); textView2.setBackgroundColor(Color.YELLOW); absoluteLayout.addView(textView2); TextView textView3 = new TextView(this); textView3.setText(\"第3个textView\"); textView3.setLayoutParams(new AbsoluteLayout.LayoutParams(800,300,200,400)); textView3.setBackgroundColor(Color.BLUE); absoluteLayout.addView(textView3); TextView textView4 = new TextView(this); textView4.setText(\"第4个textView\"); textView4.setLayoutParams(new AbsoluteLayout.LayoutParams(800,300,300,600)); textView4.setBackgroundColor(Color.GREEN); absoluteLayout.addView(textView4);&#125; 布局效果如下图： 其实布局容器中子视图的布局参数主要有定义在各个布局容器类的内部类LayoutParams来设置。需要注意，在不同分辨率的屏幕上，使用AbsoluteLayout布局效果可能会难于把控。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发之FrameLayout布局","slug":"248Android开发之FrameLayout布局","date":"2016-09-01T16:00:00.000Z","updated":"2021-07-12T02:23:22.881Z","comments":true,"path":"2016/09/02/248Android开发之FrameLayout布局/","link":"","permalink":"http://huishao.cc/2016/09/02/248Android开发之FrameLayout布局/","excerpt":"","text":"Android开发之FrameLayout布局在Android开发中，FrameLayout是所有布局容器中最简单的一种，在前边博客中有介绍关于Android开发中线性布局LinearLayout的应用。LinearLayout采用的是线性平铺的布局模式，FrameLayout也被称为帧布局。 LinearLayout应用介绍地址：http://my.oschina.net/u/2340880/blog/740714。 FrameLayout简单理解，可以将布局容器理解为一个单元素栈，先放入的视图在栈底，后放入的视图在栈顶，后放入的视图会覆盖先放入的视图。并且，FrameLayout不能够设置其内视图的位置，默认都是从左上角开始布局，这个布局模式在简单的重叠界面中使用十分方便。 使用代码进行FrameLayout布局示例如下： 1234567891011121314151617181920212223242526@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); FrameLayout frameLayout = new FrameLayout(this); setContentView(frameLayout); //添加子视图 TextView textView1 = new TextView(this); textView1.setLayoutParams(new FrameLayout.LayoutParams(600,600)); textView1.setBackgroundColor(Color.RED); frameLayout.addView(textView1); TextView textView2 = new TextView(this); textView2.setLayoutParams(new FrameLayout.LayoutParams(400,400)); textView2.setBackgroundColor(Color.YELLOW); frameLayout.addView(textView2); TextView textView3 = new TextView(this); textView3.setLayoutParams(new FrameLayout.LayoutParams(200,200)); textView3.setBackgroundColor(Color.BLUE); frameLayout.addView(textView3); TextView textView4 = new TextView(this); textView4.setLayoutParams(new FrameLayout.LayoutParams(100,100)); textView4.setBackgroundColor(Color.GREEN); frameLayout.addView(textView4);&#125; 上面示例代码在FrameLayout中放入4个TextView，后放入的视图依次减小，运行后效果如下图所示： FrameLayout应该是开发中很少使用到的一种布局模式，在十分简单的界面需求中，使用它往往十分方便。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发之LinearLayout布局详解","slug":"247Android开发之LinearLayout布局详解","date":"2016-08-30T16:00:00.000Z","updated":"2021-07-09T11:48:44.753Z","comments":true,"path":"2016/08/31/247Android开发之LinearLayout布局详解/","link":"","permalink":"http://huishao.cc/2016/08/31/247Android开发之LinearLayout布局详解/","excerpt":"","text":"Android开发之LinearLayout布局详解LinaerLayout又被称为线性布局，是Android界面开发中常用的一种容器视图控件。可以使用XML布局文件配置和代码动态创建两种方式来使用LinearLayout。使用LinearLayout可以十分轻松的布局出横向或者纵向线性堆叠界面，并且，嵌套使用LinearLayout也可以方便的布局出复杂的平面组合布局，通常情况下，ScrollView会与LinearLayout进行结合使用。在iOS9中推出的UIStackView、在watchOS开发中使用和核心布局模型Group与LinearLayout的思路十分一致，可见这种线性堆叠的布局方式在一定场景下十分有优势。 使用代码动态创建LinearLayout示例如下： 12345678910111213141516171819202122232425@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //创建对象 LinearLayout linearLayout = new LinearLayout(this); linearLayout.setBackgroundColor(Color.WHITE); setContentView(linearLayout); //设置布局方向 /* 支持水平和竖直两种 public static final int HORIZONTAL = 0; 水平线性布局 public static final int VERTICAL = 1; 竖直线性布局 */ linearLayout.setOrientation(LinearLayout.VERTICAL); //设置显示分割线的模式 /* public static final int SHOW_DIVIDER_NONE = 0; 不显示分割线 public static final int SHOW_DIVIDER_BEGINNING = 1; 在开始处显示分割线 public static final int SHOW_DIVIDER_MIDDLE = 2; 在子视图之间显示分割线 public static final int SHOW_DIVIDER_END = 4; 在结束尾部显示分割线 */ linearLayout.setShowDividers(LinearLayout.SHOW_DIVIDER_MIDDLE); //设置分割线Drawable linearLayout.setDividerDrawable(ResourcesCompat.getDrawable(getResources(),R.drawable.line,null)); &#125; LinearLayout中常用属性与方法，列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//获取分割线Drawable对象Drawable getDividerDrawable ()//获取分割线的padding值int getDividerPadding ()//获取子视图布局模式int getGravity ()//获取线性布局方向int getOrientation ()//获取展示分割线模式int getShowDividers ()//获取布局权重和float getWeightSum ()//设置是否允许计量最大子元素 与权重有关boolean isMeasureWithLargestChildEnabled ()//设置分割线Drawablevoid setDividerDrawable (Drawable divider)//设置分割线padding值void setDividerPadding (int padding)//设置子视图布局模式/*可选参数AXIS_CLIP //原始对齐AXIS_PULL_AFTER AXIS_PULL_BEFOREAXIS_SPECIFIEDAXIS_X_SHIFTAXIS_Y_SHIFTBOTTOM //下对齐CENTER //居中对齐CENTER_HORIZONTAL // 水平居中对齐CENTER_VERTICAL // 竖直居中对齐CLIP_HORIZONTALCLIP_VERTICALDISPLAY_CLIP_HORIZONTALDISPLAY_CLIP_VERTICALEND //末尾对齐FILL //充满FILL_HORIZONTAL //水平充满FILL_VERTICAL //竖直充满HORIZONTAL_GRAVITY_MASKLEFT //左对齐NO_GRAVITY //空模式RELATIVE_HORIZONTAL_GRAVITY_MASKRELATIVE_LAYOUT_DIRECTIONRIGHT //右对齐START //起始对齐TOP //上对齐VERTICAL_GRAVITY_MASK*/void setGravity (int gravity)//设置水平布局模式void setHorizontalGravity (int horizontalGravity)//设置布局方向void setOrientation (int orientation)//设置竖直布局模式void setVerticalGravity (int verticalGravity)//设置布局权重和/*当布局容器内子视图是通过权重来计算所占比例时 这个值表示权重总和*/void setWeightSum (float weightSum)//设置子视图的触摸事件是否延迟执行/*这个属性用于类型ScrollView，ListView可以滑动的视图中，避免手势冲突*/boolean shouldDelayChildPressedState () 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"iOS开发中行高灵活可变的UITableView的性能优化","slug":"246iOS开发中行高灵活可变的UITableView的性能优化","date":"2016-08-26T16:00:00.000Z","updated":"2021-07-09T11:45:01.131Z","comments":true,"path":"2016/08/27/246iOS开发中行高灵活可变的UITableView的性能优化/","link":"","permalink":"http://huishao.cc/2016/08/27/246iOS开发中行高灵活可变的UITableView的性能优化/","excerpt":"","text":"iOS开发中行高灵活可变的UITableView的性能优化一、UITableView的构建原理在新闻类，电商类等应用中，应用着大量的图文混排视图，在表视图UITableView中，开发者通常需要在如下代理方法中计算出当前cell填充内容后的高度，之后将其返回： 12345-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //先根据数据源中数据计算高度 CGFloat height = 0; return height;&#125; 然而，如果在如上方法中进行打印调试可以发现，heightForRowAtIndexPath方法会重复执行好多次，首先，并且heightForRowAtIndexPath方法的执行机制在不同版本的iOS系统还会有很大不同。以iOS9为例，一行cell要展示在屏幕上，至少要执行5遍TableView的heightForRowAtIndexPath方法： TableView配置部分： ① 当TableView视图即将展现在屏幕上时，会把所有行的行高数据进行拉取。 ②当TableView在执行setLayoutMargins方法进行自身布局时会把所有行高数据进行拉取。 ③TableView在执行layoutSubViews方法进行子视图布局时会再次把所有行高数据进行拉取。 TableViewCell配置部分： ④当使用cellID进行与TableView绑定的cell获取时会拉取本行cell的高度数据。 ⑤当cell进行layoutSubViews方法进行布局时会再次拉取本行cell的高度数据。 上面列举的5中拉取cell高度的场景中，TableView配置部分只会在TableView第一次展现在屏幕上时出现，但是其拉取的是所有行的行高数据，如果表视图有100行或者更多，这将是一个十分耗费性能的过程。TableViewCell配置部分，只有当cell将要出现在屏幕上时才会出现，并且只拉取当前行的行高，这两种场景会在用户滑动TableView时不断被执行，并且根据UITableView的布局cell原理，系统会默认准备当前一屏高度所能容纳cell个数加1个cell。 当执行TableView的reloadData方法进行界面刷新时，系统先会把所有行的行高数据拉取一遍，之后和UITableViewCell配置部分的场景一直，会拉取即将出现在屏幕上的cell的行高数据。 用示意图形象的表示上述逻辑如下： 通过上面分析，以10行数据的表格视图为例，若一屏幕可以呈现7行数据(TableView需要准备8行)，则在第一次展示TableView视图时，会执行44次heightForRwoAtIndexPath方法，每次刷新TableView需要执行24次heightForRwoAtIndexPath方法，如果TableView的行数增加到3位数，则这个方法的执行次数将会十分恐怖👿。 至于为何UITableView在进行配置时也需要拉取所有的行高数据，我猜想其为了进行视图的一些初始化操作，例如表视图右侧滚动条的宽度和所占比例等。并且，每次拉取高度都从代理方法拉取，而不是存入内部的一个变量属性中，避免了因为数据源更改时机巧合而产生的界面与预期不一致的风险。 二、对UITableView可变行高的计算方式进行优化通过前面的分析，可以理解如果将复杂的计算代码写在heightForRowAtIndexPath方法中，代价将是非常惨重的。滑动不流畅，屏幕卡顿很多性能问题都是由于这个原因。对于行高固定的表格视图，开发者可以直接设置TableView的固定行高，如下： 1_tableView.rowHeight = 200; 如果行高是不固定了，则应该想办法让heightForRowAtIndexPath方法完成最少的工作，其实最少的工作莫过于拿过一个高度，直接返回，因此开发者通常会将对应行的行高计算一次后，把值进行保存，之后在执行heightForRowAtIndexPath方法拉取行高时，直接返回已经计算过的行高数据，具体如何操作比较灵活，可以对应一个数组属性，将计算后的行高放入数组中，每次取行高时，检查数组中是否已经有计算过的行高数据，如果有直接返回。我个人更倾向将行高数据封装进cell的数据模型Model中。 通过优化，可以有效的减少重复的高度计算，这也是我原先处理此类问题的主要方式。然而，只是提高了代码的性能，对开发者来说，工作量和复杂度有增而无减。在开发中通常会遇到一些十分复杂的界面，而这些界面中cell的高度都是需要通过请求到的数据动态改变的，每个cell都要写复杂的尺寸计算代码十分令人心烦。在iOS7之后，系统提供了一种自动计算cell高度的方法，这无论在性能还是工作量上，都完全解放了开发者。 在iOS7系统之后，UITableView类中增加了一个estimatedRowHeight属性，顾名思义，这个属性是设置UITableViewCell中的大约行高值。这个值设置之后，开发者无需设置rowHeight属性，也不需要实现heightForRowAtIndexPath方法，系统会自动根据UITableViewCell中contentView的约束来计算自己的行高。estimatedRowHeight属性用于TableView进行初始化，其会影响到表格视图右侧滚动条的宽度。cell展现出来时真正的行高并不受这个属性值的影响。 那么现在问题来了，如何才能让cell正确计算自己的高度，这就要使用到Autolayout了，无论是通过xib文件创建的cell还是代码创建的cell，若想让cell自动正确的计算出自身的高度，必须添加足够压力的约束。所谓足够压力，是指UITableViewCell的contentView的上、下、左、右必须被内部控件的约束所撑满，需要注意，cell上的视图必须添加在contentView上，否则计算会出现问题。 例如下图所示，左侧的图标进行了与父视图的左侧距离约束，标题Label进行了与父视图的上侧距离约束和右侧距离约束，内容Label进行了与标题Label的上侧约束和与父视图的下册约束，并且对宽度进行了约束。此时，UITableViewCell的contentView四周都被子视图进行了约束，可以想象，内容Label的文本长度是不定的，当文本长度是的内容Label进行换行，内容Label的高度改变的时候，contentView下册会受到内容Label施加的压力，这时cell也会根据约束自动扩充自己的高度。 示例代码如下： 123456789101112131415161718192021222324252627282930313233- (void)viewDidLoad &#123; [super viewDidLoad]; self.title = @\"表视图\"; _tableView = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain]; [_tableView registerNib:[UINib nibWithNibName:@\"TableViewCell\" bundle:nil] forCellReuseIdentifier:@\"cellid\"]; _tableView.delegate = self; _tableView.dataSource = self; //设置一个模糊的行高用于配置TableView右侧滚动条 _tableView.estimatedRowHeight = 60; [self.view addSubview:_tableView]; titleArray = @[@\"标题1\",@\"标题2\",@\"标题3\",@\"标题4\",@\"标题5\",@\"标题6\",@\"标题7\",@\"标题8\",@\"标题9\",@\"标题10\"]; detailArray = @[@\"内容内容内容内容内容内容内容内容内容\", @\"内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\", @\"内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\", @\"内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\", @\"内容内容容内容内内容内容内容内容内容内容内容\", @\"容内容内内容内容\", @\"内容内容内容内容容内容内容内容\", @\"内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\", @\"内容内容内容内容内容内容容内容内内容内容内容\", @\"内容内容内容内容内容内容内容内容内容\"];&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 10;&#125;-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; TableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"cellid\" forIndexPath:indexPath]; cell.title.text = titleArray[indexPath.row]; cell.detail.text = detailArray[indexPath.row]; return cell;&#125; 通过上面示例可以看到，十分简单的代码完美的解决了图文混排cell高度的自适应。Autolayout真的是一种十分强大的技术😄。 关于细节方面，还有一个问题需要注意，预估的行高会影响到TableView右侧滚动条的展现，如果每个cell行高跳跃跨度十分大，滚动条宽度的配置会失准，随着用户滑动表视图，右侧滚动条可能会出现长短跳跃的情况，如果开发者需要精准这个滚动条的配置，可以在如下代理方法中返回具体cell的估计行高。 1234-(CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //这里根据不同分区 或者不同行 设置估计的行高 return 44;&#125; 关于estimatedHeightForRowAtIndexPath方法其实还有一种应用场景，前面介绍的优化方式都是以Autolyout为前提，对于没有使用自动布局，cell的高度需要手动计算的场景中，如果实现了这个方法，并且实现了heightForRowAtIndexPath方法，heightForRowAtIndexPath方法会以懒加载的方式执行，只有在cell将要展现在屏幕上时heightForRowAtIndexPath方法才会被执行，这也可以有效减小由于高度计算带来的性能负担。 三、关于高度不定的UITableView分区头尾视图一般情况下，TableView的分区头尾视图高度都是固定的，因此一般不需要考虑计算分区头尾视图高度产生的性能问题，类比如cell的布局原理，其实分区头尾视图也可以通过Autolayout实现自适应高度，示例代码如下： 123456789101112131415161718192021222324//返回一个估计的分区头视图高度-(CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section&#123; return 10;&#125;//使用自动布局给头视图添加足够的布局压力-(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section&#123; UIView * view = [[UIView alloc]init]; UILabel * label = [[UILabel alloc]init]; label.numberOfLines = 0; if (section==0) &#123; label.text = @\"头视图头视图头视图\"; &#125;else&#123; label.text = @\"头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图头视图\"; &#125; [view addSubview:label]; [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(@10); make.right.equalTo(@-10); make.top.equalTo(@10); make.bottom.equalTo(@-10); &#125;]; return view;&#125; 效果如下图： 分区为视图的设置方式与头视图一样。 UITableView类中还有一个十分有趣的常量： 1UIKIT_EXTERN const CGFloat UITableViewAutomaticDimension; UITableViewAutomaticDimension是一个CGFloat类型的常量，其需要和用来处理返回头尾视图标题的方法结合使用，用它来作为TableView分区头尾视图的高度返回，系统会自动根据标题是否存在来进行自适应，举个例子，如果返回的标题为nil，则头视图会被自动隐藏，示例代码如下： 1234567891011121314-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; //视图为nil则会自动返回0 return UITableViewAutomaticDimension;&#125;-(NSString*)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section&#123; if (section==0) &#123; return nil; &#125;else&#123; return @\"头视图头视图头视图头视图头视图头视图头视图头视\"; &#125;&#125; 小提示：UITableViewCell在创建出来时，其宽度并不一定和UITableView宽度一致，如果开发者需要通过获取cell的宽度来处理逻辑，要在cell的layoutSubViews里面进行，此时cell的宽度才正确。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Android Studio2.x版本无法自动关联源码的解决方法","slug":"245Android Studio2.x版本无法自动关联源码的解决方法","date":"2016-08-19T16:00:00.000Z","updated":"2021-07-09T11:32:09.578Z","comments":true,"path":"2016/08/20/245Android Studio2.x版本无法自动关联源码的解决方法/","link":"","permalink":"http://huishao.cc/2016/08/20/245Android Studio2.x版本无法自动关联源码的解决方法/","excerpt":"","text":"Android Studio2.x版本无法自动关联源码的解决方法在学习android开发过程中，对于一个不熟悉的类，阅读源码是一个很好的学习方式，使用andorid studio开发工具的SDK Manager管理工具可以十分方便的下载SDK源码，打开SDK Manager工具，下载源码界面如下图所示： 在对应的SDK版本中可以下载SDK源码。 安卓源码下载完成后，在类名上按住command键，点击鼠标左键会跳转进对应源码文件，如果是Windows系统，使用按住control键点击鼠标左键。如果android studio的版本为2.0以上，需要注意，尽管下载了源码文件，可以在跳转源码的时候，会报错误找不到源码 Sources for &apos;Android API 23 Platform&apos; not found，并且会跳转类对应的class文件。如下图： 我猜想出现这样的原因是android studio2.x工具的一个小bug，下载源码后，它没有自动对源码路径进行关联，我们可以手段添加源码路径来解决这个问题。 1.检查andriod sdk源码是否下载成功：首先进入andorid sdk路径下的sources目录，如果其中有源码文件，说明andorid sdk的源码文件已经下载成功。在OS系统中，这个路径一般是：~/Library/Android/sdk/sources。 2.在android studio偏好设置jdk.table.xml文件中添加源码路径，这个文件在android studio开发工具的配置目录中，路径如下： 在Windows系统中，一般为：系统盘:\\Users\\username\\.你的android studio名称及版本\\config\\options 在OS系统中，一般为：~/Library/Preferences/你的android studio名称及版本/options 打开jdk.table.xml文件后，找到对应SDK版本的源码路径配置标签，将第一步中检查的源码文件路径添加进入，如下图： 3.完全关闭android studio开发工具，重新启动，这次可以成功跳进源码了，Have fun。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Android开发中基础动画技巧的应用","slug":"244Android开发中基础动画技巧的应用","date":"2016-08-16T16:00:00.000Z","updated":"2021-07-09T11:30:13.594Z","comments":true,"path":"2016/08/17/244Android开发中基础动画技巧的应用/","link":"","permalink":"http://huishao.cc/2016/08/17/244Android开发中基础动画技巧的应用/","excerpt":"","text":"Android开发中基础动画技巧的应用一、引言我是先入门iOS的移动开发者，提到动画开发，iOS开发者很容易联想到3种方式，UIImageView的帧动画，UIView层的属性动画和CoreAnimation动画。Android中也有3种方式创建基础动画效果，分别为View Animation，Property Animation和Drawable Animation。由于Android开发的固有特点，其在进行动画编程时也支持使用代码和xml配置文件两种方式。本篇博客，将主要向大家介绍这3种创建Android动画方式的使用方法与可以做到的效果。 二、View Animation动画的应用View Animation又被称为Tweened Animation，其应用于View视图变化的动画过渡效果。View Animation主要分为如下4类： ①.AlphaAnimation：透明度动画 ②.RotateAnimation：旋转动画 ③.ScaleAnimation:缩放动画 ④.TranslateAnimation：位移动画 1.AlphaAnimation的应用AlphaAnimation用于当视图透明度发生变化时展示过渡动画，可以渐隐也可以渐现。使用AlphaAnimation创建动画的核心代码如下： 123456//创建AlphaAnimation动画对象 构造方法中需要传入两个float值 分别是视图动画起始的alpha值与最终的alpha值AlphaAnimation alphaAnimation = new AlphaAnimation(1,0);//设置动画执行时间 alphaAnimation.setDuration(3000);//调用视图的startAnimation方法来开启动画animationImageView.startAnimation(alphaAnimation); 2.RotateAnimation的应用RotateAnimation用于创建视图的旋转动画。其相比AlphaAnimation要复杂一些，在使用时，除了需要设置其动画的起始角度和最终角度外，还可以设置视图旋转时的参照位置，示例代码如下： 123456//创建旋转动画对象RotateAnimation rotateAnimation = new RotateAnimation(0,360, Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);//设置动画时间rotateAnimation.setDuration(3000);//开始动画animationImageView.startAnimation(rotateAnimation); 这里使用了RotateAnimation类中最复杂的一个构造方法，其中需要传入6个参数，前两个参数分别为旋转动画的起始角度与终止角度，第3个参数为旋转参照点的x轴相对位置类型，第4个参数为参照点x轴位置，第5个和第6个参数分别为旋转参照点的y轴相对位置类型与y轴相对位置。 关于参照点的相对位置类型，Animation类中定义了几个常量供开发者选择使用，意义如下： 123456//绝对定位 以当前窗口做参照public static final int ABSOLUTE = 0;//以其父视图做为位置参照public static final int RELATIVE_TO_PARENT = 2;//以本身作为位置参照public static final int RELATIVE_TO_SELF = 1; 还有一点需要注意，如果选择的参照类型是RELATIVE_TO_SELF，则参照点的位置参数取值范围为0-1之间，代表的是相对于自身的位置比例，如果参照类型是RELATIVE_TO_PARENT，则参照点的位置参数取值范围为0-1之间，代表的是相对于父视图的位置比例，如果参照类型是ABSOLUTE，则参照点的位置参数取值为绝对坐标值，例如100，150，其代表了相对窗口视图的坐标位置。例如上面示例代码中，以视图本身为参照物，x、y轴位置都设置为0.5，则旋转动画以视图本身中心为旋转点，如果需要以视图右下角为旋转点，修改代码如下： 1RotateAnimation rotateAnimation = new RotateAnimation(0,360, Animation.RELATIVE_TO_SELF,1f,Animation.RELATIVE_TO_SELF,1f); 3.ScaleAnimation的应用ScaleAnimation用于创建放大或者缩小的形变动画，示例代码如下： 123456//创建缩放动画对象ScaleAnimation scaleAnimation = new ScaleAnimation(1,2,1,2,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);//设置动画时间scaleAnimation.setDuration(3000);//执行动画animationImageView.startAnimation(scaleAnimation); 上面示例代码中前4个参数分别设置缩放动画x轴方向的起始值、最终值和y轴方向的起始值、终止值。需要注意，这里的单位都是比例，1表示原视图尺寸，2表示原视图尺寸的2倍。这个方法后4个参数的意义是确定缩放参照点的位置，和RotateAniamtion构造方法中的参数意义一致。 4.TranslateAnimation的应用TranslateAnimation用于创建位移动画，示例代码如下： 123456//创建位移动画对象TranslateAnimation translateAnimation = new TranslateAnimation(Animation.ABSOLUTE,0,Animation.ABSOLUTE,100,Animation.RELATIVE_TO_SELF,0,Animation.RELATIVE_TO_SELF,1);//设置动画时间translateAnimation.setDuration(3000);//执行动画animationImageView.startAnimation(translateAnimation); 上面示例代码中使用的TranslateAnimation构造方法中的8个参数分别代表，起始位置的x轴参照点类型与起始位置的x轴值、终止位置的x轴参照点类型与终止位置的x轴值、起始位置的y轴参照点类型与起始位置的y轴值、终止位置的y轴参照点类型与终止位置的y轴值。 5.Animation类中的通用方法上面介绍的4种动画实际上都是Animation类的子类，Animation类中封装了许多动画通用的方法，例如前面使用的设置动画执行时间的方法setDuration就是Animation类的方法，其中更多常用方法列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//取消正在执行的动画public void cancel();//设置动画的执行函数public void setInterpolator(Interpolator i);//这只方法设置开始动画的延时值 单位为毫秒public void setStartOffset(long startOffset);//设置动画的执行时间public void setDuration(long durationMillis);//设置动画特效的最长运行时间public void restrictDuration(long durationMillis);//设置动画的执行强度比例 例如放大两倍的动画 这个值如果设置为2 将被放大4倍public void scaleCurrentDuration(float scale);//为动画设置一个开始的时间public void setStartTime(long startTimeMillis);//设置动画循环模式/*只有当动画的循环次数大于1时这个值才有效果，其可以设置为如下常量：RESTART 每次循环都从头执行REVERSE 正逆交替执行*/public void setRepeatMode(int repeatMode);//设置循环次数 设置为INFINITE则为无限循环public void setRepeatCount(int repeatCount);//设置是否允许填充动画 这个方法设置为true后setFillBefore()与setFillAfter()方法才会生效public void setFillEnabled(boolean fillEnabled);//动画结束后 是否以起始位置填充视图public void setFillBefore(boolean fillBefore);//动画结束后 是否以结束位置填充视图public void setFillAfter(boolean fillAfter)//设置动画执行时在Z轴上的位置/*可以设置为如下3中常量 public static final int ZORDER_BOTTOM = -1; //将动画放在Z轴最下边 public static final int ZORDER_NORMAL = 0; //将动画放在Z轴原位置 public static final int ZORDER_TOP = 1; //将动画放在Z轴最上边*/public void setZAdjustment(int zAdjustment);//设置动画的执行是否影响到壁纸public void setDetachWallpaper(boolean detachWallpaper);//获取动画是否开始执行了public boolean hasStarted();//获取动画是否结束执行了public boolean hasEnded(); 上面列举的方法中，setInterpolator()方法很有意思，其可以设置动画执行的时间函数，例如是先快后慢还是先慢后快等等，这个方法需要传入一个Interpolator类型的参数，实际上使用时是通过Interpolator的子类来实现的，示例如下： 1ranslateAnimation.setInterpolator(new AccelerateDecelerateInterpolator()); 对于Interpolator参数开发者可以设置的子类及意义列举如下： AccelerateDecelerateInterpolator：先加速后减速执行 AccelerateInterpolator：加速执行 AnticipateInterpolator：先后退执行一步后正向加速执行(类似弹簧效果) AnticipateOvershootInterpolator：先后退执行一步后加速执行到达极限后再前进一步后再回到极限(弹簧) BounceInterpolator：动画执行到结尾后进行阻尼效果 CycleInterpolator：以正弦规则循环执行数次动画，这个类来构造时需要传入循环次数，如下： 1new CycleInterpolator(3) DecelerateInterpolator：减速执行动画 FastOutLinearInInterpolator：基于贝塞尔曲线的速率变化 FastOutSlowInInterpolator：基于贝塞尔曲线的速率变化 LinearInterpolator：线性匀速执行 LinearOutSlowInInterpolator：基于贝塞尔曲线的速率变化 OvershootInterpolator：执行超出极限后在回退 PathInterpolator：自定义运动路径 6.实现对Animation动画状态的监听Animation类中也定义了一个监听器协议，其中提供了对动画状态进行监听的方法，如下： 12345678public interface AnimationListener &#123; //当动画开始执行时触发的方法 void onAnimationStart(Animation var1); //动画执行结束后触发的方法 void onAnimationEnd(Animation var1); //动画重复执行的时候会触发 void onAnimationRepeat(Animation var1);&#125; 7.使用xml文件配置View Animation上面介绍的全部是通过代码来创建View Animation动画，Android也支持使用xml文件来配置View Animation动画。 首先在Android Studio的res目录中创建一个动画文件目录，将其类型选择为anim，如下图所示： 在创建的目录中创建一个新的xml文件，在其中编写动画代码如下： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0\" android:duration = \"3000\"/&gt;&lt;/set&gt; 在代码中，使用如下代码来加载xml配置的动画： 1234//加载动画文件Animation animation = AnimationUtils.loadAnimation(this,R.anim.my_anmi);//执行动画animationImageView.startAnimation(animation); 8.复合的View AnimationView Animation也支持进行复合动画的操作，如果使用xml配置复合动画，十分简单，只需要将要要复合的动画都配置进xml文件的set标签中即可，如下： 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0\" android:duration = \"3000\"/&gt; &lt;scale android:fromXScale=\"1\" android:toXScale=\"2\" android:fromYScale=\"1\" android:toYScale=\"2\" android:duration=\"3000\"/&gt;&lt;/set&gt; 如果要用代码创建复合动画，需要使用到AnimationSet类进行复合，示例如下： 123456789101112//创建动画集合容器 参数决定容器中所有动画是否共用Interpolator时序函数AnimationSet set = new AnimationSet(true);//创建动画RotateAnimation rotateAnimation = new RotateAnimation(0,360, Animation.RELATIVE_TO_SELF,1f,Animation.RELATIVE_TO_SELF,1f);ScaleAnimation scaleAnimation = new ScaleAnimation(1,2,1,2,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);scaleAnimation.setDuration(3000);rotateAnimation.setDuration(3000);//将动画添加进集合中set.addAnimation(rotateAnimation);set.addAnimation(scaleAnimation);//执行动画animationImageView.startAnimation(set); 三、Property Animation动画的应用在前面介绍的View Animation动画体系中，虽然使用起来十分方便，但也有十分多的局限性，例如只能支持透明度，位置，缩放和旋转动画，并且在动画执行时，视图实际上并没有移动，如果需要做动画的是可以用户交互的按钮控件则会带来很多的不便。在Android3.0之后，系统推出了Property Animation动画，这种机制可以将对象任意属性的修改实现过渡动画效果。 1.ObjectAnimator动画的应用ObjectAnimator是Property Animation动画体系中最简单易用的一种方式，开发者只需要设置要改变的属性值和一些动画参数即可使用，例如若要实现视图以y方向为轴进行旋转操作，使用 如下代码实现： 123456//创建属性动画对象ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(animationImageView,\"rotationY\",0,360,0);//设置动画时间objectAnimator.setDuration(3000);//开始动画objectAnimator.start(); ObjectAnimator类的静态方法ofFloat()用于创建属性动画实例本身，与其类似的方法还有ofInt()与ofObject()。需要注意，这些方法第1个参数为要执行动画的视图，第2个参数为要发生动画改变的属性名，从第3个参数开始后面可以添加任意多个值，这些值代表了属性值改变的路径，例如上面示例代码表示将视图以y方向为轴从0°开始旋转到360°后再旋转回0°。 ObjectAnimator类继承自ValueAnimator，ValueAnimator类则更加灵活自由，其可以为自定义类的自定义属性做动画处理，后面会介绍，ValueAnimator类中提供了许多动画配置的方法，常用如下： 1234567891011121314151617181920//设置动画执行时间public ValueAnimator setDuration(long duration);//设置延时执行public void setStartDelay(long startDelay);//设置动画循环次数public void setRepeatCount(int value);//设置动画循环模式public void setRepeatMode(int value);//设置动画执行时序模式public void setInterpolator(TimeInterpolator value);//开始执行动画public void start();//结束动画public void end();//取消动画public void cancel();//恢复动画public void resume();//暂停动画public void pause(); 需要注意，使用ObjectAnimator创建动画的属性必须实现set和get方法。 2.ValueAnimator实现更加灵活的自定义动画ObjectAnimator是ValueAnimator的子类，可以理解，ValueAnimator要比ObjectAnimator更加灵活自由，其可以实现任意自定义属性的动画行为。示例代码如下： 1234567891011121314151617//创建ValueAnimator实例ValueAnimator valueAnimator = new ValueAnimator();//设置动画的路径值valueAnimator.setFloatValues(0,200,100,300,0);//设置动画的执行时间valueAnimator.setDuration(6000);//添加动画执行监听valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; //这个方法会在每次动画值改变时调用 @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; //设置视图的横坐标 animationImageView.setX((Float) valueAnimator.getAnimatedValue()); &#125;&#125;);//执行动画valueAnimator.start(); 如果运行上面代码，可以看到视图在6s内从x坐标点为0的地方平移到200后再次回到100后再次移动到300最终回到原点0。 上面的示例代码只是演示了ValueAnimator的工作原理，开发者可以在onAnimationUpdate()方法中进行任意属性的修改。仅从上面演示代码并不能体现出ValueAnimator的强大之处，可以通过实现类似抛物线的动画来理解ValueAnimator的灵活之处，示例代码如下： 12345678910111213141516171819202122232425262728293031//创建ValueAnimator实例final ValueAnimator animator = new ValueAnimator();//示例进行抛物线动画 让控件从(0,0)点位置移动到x轴为400的位置，y轴方向做自由落体animator.setObjectValues(new Point(0,0),new Point(400,0));//设置动画时间animator.setDuration(4000);//设置时序为线性函数animator.setInterpolator(new LinearInterpolator());//由于抛物线运动在x轴和y轴上的速度变化并不相同 需要自定义枚举器animator.setEvaluator(new TypeEvaluator&lt;Point&gt;() &#123; //这个枚举方法中传入的v值为动画执行的比例 0为初始状态 1为动画执行完成 开发者根据这个值模拟抛物线坐标 @Override public Point evaluate(float v, Point o,Point t1) &#123; //创建Point对象 模拟抛物运动 Point point = new Point(); point.x = (int)((v*8)*100); point.y = (int)((v*60)*(v*60)/4); return point; &#125;&#125;);//监听动画执行animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; //设置视图位置 animationImageView.setX(((Point)valueAnimator.getAnimatedValue()).x); animationImageView.setY(((Point)valueAnimator.getAnimatedValue()).y); &#125;&#125;);//执行动画animator.start(); 需要注意，Property Animation与View Animation最大的不同在于View Animation只是展示视图的界面动画，它并没有真正改变视图的属性，而Property Animation是实实在在的改变了发生动画控件的属性。 3.Property Animation动画的监听ValueAnimator对象可以使用addListener()方法来添加监听者，接口方法如下： 1234567891011//动画监听接口public interface AnimatorListener &#123; //动画开始 void onAnimationStart(Animator var1); //动画结束 void onAnimationEnd(Animator var1); //动画取消 void onAnimationCancel(Animator var1); //动画重复 void onAnimationRepeat(Animator var1);&#125; 4.使用PropertyValuesHolder进行动画复合对于Property Animation，开发者可以通过ValueAnimator实现自定义的复合动画，也可以使用PropertyValuesHolder进行属性动画的复合操作，示例如下： 123456789//创建子属性动画 翻转PropertyValuesHolder holder = PropertyValuesHolder.ofFloat(\"rotationY\",0,360,90);//创建子属性动画 透明PropertyValuesHolder holder2 = PropertyValuesHolder.ofFloat(\"alpha\",1,0,1);//进行动画复合ObjectAnimator objectAnimation = ObjectAnimator.ofPropertyValuesHolder(animationImageView,holder,holder2);//执行动画objectAnimation.setDuration(3000);objectAnimation.start(); 三、Drawable Animation动画的应用相比前两种动画模式，Drawable Animation动画要容易的多，其使用一组图像快速切换的原理来实现动画效果。 在Android Studio的drawable文件夹中添加一个animation文件，xml代码如下： 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/bird1\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird2\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird3\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird4\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird5\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird6\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird7\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/bird8\" android:duration=\"200\" /&gt;&lt;/animation-list&gt; 将需要展示动画的视图背景设置为这个drawable文件，示例如下： 12345&lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/anmi_draw_list\" android:id=\"@+id/animatedImageView\"/&gt; 在需要开始动画时，调用如下代码即可： 12//获取到drawable背景 调用start()方法开始动画((AnimationDrawable)animationImageView.getBackground()).start(); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"iOS开发中UITableViewCell点击时子视图背景透明的解决方法","slug":"243iOS开发中UITableViewCell点击时子视图背景透明的解决方法","date":"2016-08-09T16:00:00.000Z","updated":"2021-07-09T11:29:13.357Z","comments":true,"path":"2016/08/10/243iOS开发中UITableViewCell点击时子视图背景透明的解决方法/","link":"","permalink":"http://huishao.cc/2016/08/10/243iOS开发中UITableViewCell点击时子视图背景透明的解决方法/","excerpt":"","text":"iOS开发中UITableViewCell点击时子视图背景透明的解决方法在做iOS项目的开发中，UITableView控件的应用十分广泛。在进行自定义UITableViewCell时，经常有小伙伴遇到这样的问题：在UITableViewCell上面添加了一个有背景颜色的子视图，当用户点击UITableViewCell或者选中UITableViewCell时，Cell上的子视图发生了奇怪的变化，其背景色变透明了，如果添加在Cell上的子视图只是一个色块，那么我们看起来，这个子视图好像莫名其妙的消失了一样。如下图所示： 产生这种情况的主要原因是由于UITableViewCell的选中风格所致。如果开发者不进行设置，UITableViewCell中的selectionStyle属性默认风格为UITableViewCellSelectionStyleBlue。这时，如果用户点击或者选中了某个Cell，系统会自动将其上子视图的背景色改成透明以便统一Cell的整体背景颜色。开发者可以将其设置为UITableViewCellSelectionStyleNone枚举值来不适用任何Cell的选中风格。 如果需要使用Cell的选中风格同时又不想让Cell上的子视图收到影响，我们可以继承UITableViewCell后在其中覆写父类的如下两个方法，在这些方法中重新设置子视图的背景色： 12345678910//这个方法在Cell被选中或者被取消选中时调用- (void)setSelected:(BOOL)selected animated:(BOOL)animated &#123; [super setSelected:selected animated:animated]; self.testLabel.backgroundColor = [UIColor orangeColor];&#125;//这个方法在用户按住Cell时被调用-(void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated&#123; [super setHighlighted:highlighted animated:animated]; self.testLabel.backgroundColor = [UIColor orangeColor];&#125; 如下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"Android中SharedPreferences使用小记","slug":"242Android中SharedPreferences使用小记","date":"2016-08-02T16:00:00.000Z","updated":"2021-07-09T07:53:35.379Z","comments":true,"path":"2016/08/03/242Android中SharedPreferences使用小记/","link":"","permalink":"http://huishao.cc/2016/08/03/242Android中SharedPreferences使用小记/","excerpt":"","text":"Android中SharedPreferences使用小记一、引言Android中使用SharedPreferences来进行简单数据的持久化处理，从名字就可以了解，其设计目的是为了保存应用程序的一些偏好设置，如音量，主题等信息。其与iOS开发中的NSUserDefault十分类似，并且，他们的实质都是采用XML格式的文件来存储数据。 二、SharedPreferences的简单应用对数据的持久化操作都会分为两个部分，一部分为存，另一部分为取。首先，开发者在Activity中使用如下方法可以获取获取创建一个SharedPreferences实例： 1234/*这个方法需要传入两个参数，第一个参数为文件名，第二个参数为文件模式*/SharedPreferences sharedPreferences = getSharedPreferences(\"MyPreference\",MODE_PRIVATE); 在getSharedPreference()方法中第一个参数决定这个存储文件的名字，在获取SharedPreferences实例时，如果系统创建过这个文件，则会返回本地的原文件，如果没有这个文件，则会进行创建。第二个参数决定这个文件的访问权限，可选参数如下： 123Activity.MODE_PRIVATE,//默认操作模式，代表该文件是私有数据，只能被应用本身访问Activity.MODE_WORLD_READABLE,//表示当前文件可以被其他应用读取， Activity.MODE_WORLD_WRITEABLE,//表示当前文件可以被其他应用写入； 有了SharedPreferences实例，在需要进行数据存储时，需要获取到SharedPreferences实例中的Editor对象，SharedPreferences类中有一个Editor的内部接口，其中提供了存储数据的相关方法，示例代码如下: 123456//获取Editor对象SharedPreferences.Editor editor = sharedPreferences.edit();//进行字符串存储editor.putString(\"password\",\"123456\");//提交存储内容editor.commit(); Editor采用键值对的存储方式，可以存储的数据即常用方法如下： 12345678910111213141516171819202122public interface Editor &#123; //进行字符串数据存储 SharedPreferences.Editor putString(String var1, String var2); //进行字符Set存储 SharedPreferences.Editor putStringSet(String var1, Set&lt;String&gt; var2); //进行Int值存储 SharedPreferences.Editor putInt(String var1, int var2); //进行Long值存储 SharedPreferences.Editor putLong(String var1, long var2); //进行Float值存储 SharedPreferences.Editor putFloat(String var1, float var2); //进行布尔值存储 SharedPreferences.Editor putBoolean(String var1, boolean var2); //删除一个键 与其对应的值 SharedPreferences.Editor remove(String var1); //清空所有数据 SharedPreferences.Editor clear(); //提交存储 boolean commit(); //提交存储请求 void apply(); &#125; 上面的方法中，有两点需要注意，首先clear()方法是将所有的键的值清空，并没有删除键，而remove是删除键和值。第二点，commit()方法和apply()方法都用于提交数据，不同的是，commit()方法会直接将数据同步到磁盘，返回值会告知开发者是否同步成功，而apply()方法只是将数据存储在内存，之后异步进行存盘操作，没有返回值，在开发中，如果要保证数据立马存入磁盘，要使用commit()方法。 对存储的数据进行读取，可以直接调用SharedPreferences实例的如下方法： 12345678910111213141516171819202122232425public interface SharedPreferences &#123; //获取所有键值映射表 Map&lt;String, ?&gt; getAll(); //通过键获取字符串值 第一个参数为键 第二个参数为此键不存在时使用的默认值 String getString(String var1, String var2); //通过键获取字符串值集合 第一个参数为键 第二个参数为此键不存在时使用的默认值 Set&lt;String&gt; getStringSet(String var1, Set&lt;String&gt; var2); //通过键获取整形值 第一个参数为键 第二个参数为此键不存在时使用的默认值 int getInt(String var1, int var2); //通过键获取长整形值 第一个参数为键 第二个参数为此键不存在时使用的默认值 long getLong(String var1, long var2); //通过键获取浮点值 第一个参数为键 第二个参数为此键不存在时使用的默认值 float getFloat(String var1, float var2); //通过键获取布尔值 第一个参数为键 第二个参数为此键不存在时使用的默认值 boolean getBoolean(String var1, boolean var2); //检查文件中是否包含某个键 boolean contains(String var1); //注册监听 void registerOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener var1); //取消注册监听 void unregisterOnSharedPreferenceChangeListener(SharedPreferences.OnSharedPreferenceChangeListener var1); public interface OnSharedPreferenceChangeListener &#123; void onSharedPreferenceChanged(SharedPreferences var1, String var2); &#125;&#125; 注册监听方法可以提供给开发者一个回调接口，当SharedPreferences中数据改变时，会通知给开发者进行逻辑处理，示例代码如下： 12345678910//创建监听者 final SharedPreferences.OnSharedPreferenceChangeListener listener = new SharedPreferences.OnSharedPreferenceChangeListener() &#123; //需要重写这个方法 这个方法中会传入发生变化的键s @Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String s) &#123; Log.d(\"**********\",s); &#125; &#125;;//进行注册sharedPreferences.registerOnSharedPreferenceChangeListener(listener); 温馨提示：可以在Android Device Monitor中查看创建的SharedPreferences文件，路径为data/data/APP包名/shared_prefs目录下，可以看到其为XML文件，如下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：435043639","categories":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}],"tags":[],"keywords":[{"name":"Android小记","slug":"Android小记","permalink":"http://huishao.cc/categories/Android小记/"}]},{"title":"Objective-C中NSArray类的解读","slug":"241 Objective-C中NSArray类的解读","date":"2016-07-18T16:00:00.000Z","updated":"2021-07-09T07:50:39.849Z","comments":true,"path":"2016/07/19/241 Objective-C中NSArray类的解读/","link":"","permalink":"http://huishao.cc/2016/07/19/241 Objective-C中NSArray类的解读/","excerpt":"","text":"Objective-C中NSArray类的解读NSArray数组类是Objective-C语言中常用的也是重要的一个类，除了开发中常用到的一些基础功能，NSArray及其相关类中还封装了许多更加强大的功能。有机会总结了一下，与需要的朋友们分享。 NSArray中属性与方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//获取数组中元素个数@property (readonly) NSUInteger count;//通过下标获数组中的元素- (ObjectType)objectAtIndex:(NSUInteger)index;//初始化方法- (instancetype)init;//通过C语言风格的数组创建NSArray对象 需要注意，C数组中需要为Objective对象，cnt参数为C数组的长度//如果cnt的值小于C数组的长度，则会对C数据进行截取赋值，如果大于则程序会崩溃- (instancetype)initWithObjects:(const ObjectType [])objects count:(NSUInteger)cnt;//数组的归档方法- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder;//像数组中追加一个元素 这个方法会返回一个新的数组- (NSArray&lt;ObjectType&gt; *)arrayByAddingObject:(ObjectType)anObject;//像数组中追加一组元素 这个方法会返回一个新的数组- (NSArray&lt;ObjectType&gt; *)arrayByAddingObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray;//返回一个字符串，将数组中的元素以separator为分隔符进行组合/*NSArray * array = @[@1,@2,@3,@4];将打印1,2,3,4NSString * res = [array componentsJoinedByString:@\",\"];*/- (NSString *)componentsJoinedByString:(NSString *)separator;//判断数组中是否包含某个元素- (BOOL)containsObject:(ObjectType)anObject;//数组的打印方法@property (readonly, copy) NSString *description;- (NSString *)descriptionWithLocale:(nullable id)locale;- (NSString *)descriptionWithLocale:(nullable id)locale indent:(NSUInteger)level;//获取第一个包含于另一个数组中的元素- (nullable ObjectType)firstObjectCommonWithArray:(NSArray&lt;ObjectType&gt; *)otherArray;//将数组中一定范围的元素读取到一个C数组中 objects参数需要为分配好空间的C指针- (void)getObjects:(ObjectType __unsafe_unretained [])objects range:(NSRange)range;//获取某个元素在数值中的下标值- (NSUInteger)indexOfObject:(ObjectType)anObject;//获取某个范围内的元素的下标值- (NSUInteger)indexOfObject:(ObjectType)anObject inRange:(NSRange)range;//获取与给定元素相同的元素在数组中的最小下标值- (NSUInteger)indexOfObjectIdenticalTo:(ObjectType)anObject;//在一定范围内 获取与给定元素相同的元素在数组中的最小下标值- (NSUInteger)indexOfObjectIdenticalTo:(ObjectType)anObject inRange:(NSRange)range;//判断两个数组是否相同- (BOOL)isEqualToArray:(NSArray&lt;ObjectType&gt; *)otherArray;//获取数组中第一个元素@property (nullable, nonatomic, readonly) ObjectType firstObject NS_AVAILABLE(10_6, 4_0);//获取数组中最后一个元素@property (nullable, nonatomic, readonly) ObjectType lastObject;//获取数组的枚举对象- (NSEnumerator&lt;ObjectType&gt; *)objectEnumerator;//获取数组的逆向枚举对象- (NSEnumerator&lt;ObjectType&gt; *)reverseObjectEnumerator;/*这个属性可以获取一个已经排序数组的排序规则 在使用- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))comparator context:(nullable void *)context hint:(nullable NSData *)hint;方法时可以将此排序规则传入 对于没有排序过的数组，使用- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))comparator context:(nullable void *)context;方法会自动产生一个这样的排序规则*/@property (readonly, copy) NSData *sortedArrayHint;//通过C排序函数进行排序/*示例：NSInteger sort(id obj1, id obj2, void *context)&#123; NSNumber *str1 =(NSNumber*) obj1; NSNumber *str2 =(NSNumber*) obj2; if ([str1 intValue] &lt; [str2 intValue]) &#123; return NSOrderedDescending; &#125; else if([str1 intValue] == [str2 intValue]) &#123; return NSOrderedSame; &#125; return NSOrderedAscending;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; NSArray * array = @[@1,@3,@2,@4]; array = [array sortedArrayUsingFunction:sort context:nil]; NSString * res = [array componentsJoinedByString:@\",\"]; NSLog(@\"%@\",res);&#125;*/- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))comparator context:(nullable void *)context;//通过C排序函数进行数组排序- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))comparator context:(nullable void *)context hint:(nullable NSData *)hint;//使用函数选择器进行数组排序- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingSelector:(SEL)comparator;//获取数组一定范围的子数组- (NSArray&lt;ObjectType&gt; *)subarrayWithRange:(NSRange)range;//将数组写入文件- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;//将数组写入指定url路径- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically;//是数组中的所有元素调用某个方法选择器- (void)makeObjectsPerformSelector:(SEL)aSelector;//功能同上 支持传参- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(nullable id)argument;//获取一个下标集合所对应的元素- (NSArray&lt;ObjectType&gt; *)objectsAtIndexes:(NSIndexSet *)indexes;//数组的下标方法 子类重写- (ObjectType)objectAtIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0);//对数组中的元素进行枚举遍历- (void)enumerateObjectsUsingBlock:(void (^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);//对数组中的元素进行枚举遍历/*typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) &#123; NSEnumerationConcurrent = (1UL &lt;&lt; 0),//正向枚举 NSEnumerationReverse = (1UL &lt;&lt; 1), //逆向枚举&#125;; */- (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);//在一个下标集合中枚举- (void)enumerateObjectsAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts usingBlock:(void (^)(ObjectType obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);//通过遍历的方式查找符合条件的元素下标- (NSUInteger)indexOfObjectPassingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//通常 可以设置遍历方式- (NSUInteger)indexOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//同上 在一定下标集合中遍历- (NSUInteger)indexOfObjectAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//通过遍历的方式查找所有符合条件的元素下标- (NSIndexSet *)indexesOfObjectsPassingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//同上- (NSIndexSet *)indexesOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//同上- (NSIndexSet *)indexesOfObjectsAtIndexes:(NSIndexSet *)s options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(ObjectType obj, NSUInteger idx, BOOL *stop))predicate NS_AVAILABLE(10_6, 4_0);//通过block进行数组排序- (NSArray&lt;ObjectType&gt; *)sortedArrayUsingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);//同上/*typedef NS_OPTIONS(NSUInteger, NSSortOptions) &#123; NSSortConcurrent = (1UL &lt;&lt; 0),//同步排序 NSSortStable = (1UL &lt;&lt; 4),//稳定排序&#125;;*/- (NSArray&lt;ObjectType&gt; *)sortedArrayWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);//二分查找的枚举参数typedef NS_OPTIONS(NSUInteger, NSBinarySearchingOptions) &#123; NSBinarySearchingFirstEqual = (1UL &lt;&lt; 8), NSBinarySearchingLastEqual = (1UL &lt;&lt; 9), NSBinarySearchingInsertionIndex = (1UL &lt;&lt; 10),&#125;;//对区域排序的数组进行二分查找- (NSUInteger)indexOfObject:(ObjectType)obj inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator)cmp NS_AVAILABLE(10_6, 4_0); // binary search//创建对象+ (instancetype)array;//通过一个元素创建数组对象+ (instancetype)arrayWithObject:(ObjectType)anObject;//通过C数组创建数组对象+ (instancetype)arrayWithObjects:(const ObjectType [])objects count:(NSUInteger)cnt;//通过一组元素创建数组对象+ (instancetype)arrayWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION;//通过另一个数组创建数组对象+ (instancetype)arrayWithArray:(NSArray&lt;ObjectType&gt; *)array;//初始化方法- (instancetype)initWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION;- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array;- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag;//通过文件创建数组+ (nullable NSArray&lt;ObjectType&gt; *)arrayWithContentsOfFile:(NSString *)path;//通过url创建数组+ (nullable NSArray&lt;ObjectType&gt; *)arrayWithContentsOfURL:(NSURL *)url;同上- (nullable NSArray&lt;ObjectType&gt; *)initWithContentsOfFile:(NSString *)path;- (nullable NSArray&lt;ObjectType&gt; *)initWithContentsOfURL:(NSURL *)url;//获取数组所有元素 需要传入分配了内存的C指针- (void)getObjects:(ObjectType __unsafe_unretained [])objects; NSMutableArray中属性与方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//向数组中追加一个元素- (void)addObject:(ObjectType)anObject;//向数组某个位置插入一个元素- (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;//删除数组中最后一个元素- (void)removeLastObject;//删除数组中指定位置的元素- (void)removeObjectAtIndex:(NSUInteger)index;//替换数组中一个位置的元素- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;//初始化- (instancetype)init NS_DESIGNATED_INITIALIZER;- (instancetype)initWithCapacity:(NSUInteger)numItems NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;//通过数组来追加元素- (void)addObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray;//交换两个元素- (void)exchangeObjectAtIndex:(NSUInteger)idx1 withObjectAtIndex:(NSUInteger)idx2;//删除所有元素- (void)removeAllObjects;//在一定范围内删除元素- (void)removeObject:(ObjectType)anObject inRange:(NSRange)range;//删除一个元素- (void)removeObject:(ObjectType)anObject;//删除指定范围内下标最小的某个元素- (void)removeObjectIdenticalTo:(ObjectType)anObject inRange:(NSRange)range;//删除某个元素 下标最小的- (void)removeObjectIdenticalTo:(ObjectType)anObject;//删除一定范围内的所有元素- (void)removeObjectsFromIndices:(NSUInteger *)indices numIndices:(NSUInteger)cnt NS_DEPRECATED(10_0, 10_6, 2_0, 4_0);//通过数组删除元素- (void)removeObjectsInArray:(NSArray&lt;ObjectType&gt; *)otherArray;//通过范围删除元素- (void)removeObjectsInRange:(NSRange)range;//替换一组元素- (void)replaceObjectsInRange:(NSRange)range withObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray range:(NSRange)otherRange;//替换一组元素- (void)replaceObjectsInRange:(NSRange)range withObjectsFromArray:(NSArray&lt;ObjectType&gt; *)otherArray;//设置数组元素- (void)setArray:(NSArray&lt;ObjectType&gt; *)otherArray;//进行数组排序- (void)sortUsingFunction:(NSInteger (*)(ObjectType, ObjectType, void * __nullable))compare context:(nullable void *)context;//进行数组排序- (void)sortUsingSelector:(SEL)comparator;//插入一组元素- (void)insertObjects:(NSArray&lt;ObjectType&gt; *)objects atIndexes:(NSIndexSet *)indexes;//删除一组元素- (void)removeObjectsAtIndexes:(NSIndexSet *)indexes;//替换一组元素- (void)replaceObjectsAtIndexes:(NSIndexSet *)indexes withObjects:(NSArray&lt;ObjectType&gt; *)objects;//设置某个下标对应的元素 子类覆写- (void)setObject:(ObjectType)obj atIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0);//进行数组排序- (void)sortUsingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);//进行数组排序- (void)sortWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr NS_AVAILABLE(10_6, 4_0);//创建数组 numItems为元素个数+ (instancetype)arrayWithCapacity:(NSUInteger)numItems;//通过文件创建数组+ (nullable NSMutableArray&lt;ObjectType&gt; *)arrayWithContentsOfFile:(NSString *)path;//通过url创建数组+ (nullable NSMutableArray&lt;ObjectType&gt; *)arrayWithContentsOfURL:(NSURL *)url;同上- (nullable NSMutableArray&lt;ObjectType&gt; *)initWithContentsOfFile:(NSString *)path;- (nullable NSMutableArray&lt;ObjectType&gt; *)initWithContentsOfURL:(NSURL *)url; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS中Today扩展插件与宿主APP的交互","slug":"240iOS中Today扩展插件与宿主APP的交互","date":"2016-07-13T16:00:00.000Z","updated":"2021-07-09T07:48:00.202Z","comments":true,"path":"2016/07/14/240iOS中Today扩展插件与宿主APP的交互/","link":"","permalink":"http://huishao.cc/2016/07/14/240iOS中Today扩展插件与宿主APP的交互/","excerpt":"","text":"iOS中Today扩展插件与宿主APP的交互扩展是iOS8后系统开发给开发者的新开发思路与接口，每一个扩展都可以理解为一个简单的小应用程序，只是其不是独立存在的，要寄附于某一个主应用上。介绍iOS8扩展与Today插件的专题见如下博客： iOS8中扩展与Today插件：http://my.oschina.net/u/2340880/blog/485533。 上述博客中只是简单的介绍扩展的应用场景与创建Today扩展插件的方法，在实际开发中，由于扩展是寄附于某个应用程序之上的，因此其通常需要和宿主APP进行数据交互。创建Today扩展Target后，Xcode模板会自动帮助开发者生成一个ViewController作为主界面，开发者可以向其中添加展示UI或者交互控件，十分强大的是，Today扩展中是支持对UIViewController的切换的。需要注意，扩展与原APP是在不同的目录结构中的，默认情况下，扩展与原APP的数据并不共享，代码也不能复用。例如原APP中可能有网络请求，数据持久化存储等结构框架，扩展中不可以直接使用，扩展需要提供自己的网络请求框架爱，数据持久化结构框架等。 如果项目是使用Pod进行的管理，则可以通过手动设置，使扩展中可以使用继承的Pod库，步骤如下： 完成上面两张图中的步骤，即可在扩展中使用Pod库了。 Xcode扩展模板创建的ViewController会自动遵守NSWidgetProviding这个协议，这个协议中的方法和意义如下，开发者可以根据需求选择实现： 1234//数据更新时调用的方法 系统会定期更新扩展- (void)widgetPerformUpdateWithCompletionHandler:(void (^)(NCUpdateResult result))completionHandler;//设置扩展UI边距 注意 在使用Storyboard时，若要所见即所得 这个方法中需要返回UIEdgeInsetsZero- (UIEdgeInsets)widgetMarginInsetsForProposedMarginInsets:(UIEdgeInsets)defaultMarginInsets; 注意：Today扩展有其自己的plist配置文件，若需要对扩展进行配置，注意不要与宿主工程的plist文件混淆。 在Today扩展中打开原宿主APP使用openURL的方式，示例如下： 1[viewController.extensionContext openURL:[NSURL URLWithString:[NSString stringWithFormat:@\"MyApp://action=%@\",@\"action\"]] completionHandler:nil]; 上面打开原宿主APP的代码中，MyApp是宿主APP配置的url Schemes，配置方式如下图： 可以通过为url配置参数的方式来进行Today扩展与原宿主APP的信息交互，当扩展使用openURL的方式打开原宿主APP时，宿主APP会调用AppDelegate中的如下方法： 123456-(BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123;//可以拿到url做相应逻辑处理 UIAlertView * alert = [[UIAlertView alloc]initWithTitle:url.absoluteString message:nil delegate:nil cancelButtonTitle:@\"确定\" otherButtonTitles:nil, nil]; [alert show]; return YES;&#125; 上面介绍的openURL的方式只是进行跳转交互，参数传递，并不能完成数据共享的需求，并且通过openURL的方式传递的数据是单向的。实际上，扩展和原宿主APP共享数据的应用场景十分广泛，例如电商类宿主APP中拉取到一批商品信息，Today扩展中也需要这些信息进行展示，如果数据不共享，同样的数据将在宿主APP内部和扩展都都请求一次，十分浪费，难很难同步。系统还提供了另一种方式来使宿主APP和Today扩展可以共享一块存储空间，这需要使用App Group技术来实现。开发者在进行App Group相关功能的测试时，必须与AppID进行关联。 首先，需要开启宿主APP的App Group，示例图如下： 在Today扩展中，选择相同的App Group，如下： 开启了App Group功能后，Xcode会自动生成一套匹配的权限文件，如下： 配置工作完成后，可以通过两种方式共享数据存储空间，示例如下： 123456789//使用数据共享的NSUserDefaults 这个NSUserDefaults是宿主APP与扩展所共享的NSUserDefaults * defaults =[NSUserDefaults alloc]initWithSuiteName:@\"开发者设置的AppGroup名称\"];//使用数据共享的文件目录NSFileManager * manager = [NSFileManager defaultManager];//共享目录NSURL * baseURL = [manager containerURLForSecurityApplicationGroupIdentifier:@\"开发者设置的AppGroup名称\"];//找文件NSURL * filePath = [baseURL URLByAppendingPathComponent:@\"file\"]; 注意：还有一点细节需要注意，扩展与原宿主APP素材文件也是互相独立的，要在扩展中使用的素材必须添加进扩展Target。 小提示：使用Xcode调试扩展时，需要运行扩展的Target，开发者有时会发现断点失效，将模拟器上的应用删掉，重新运行扩展即可解决。 Demo地址：http://pan.baidu.com/s/1bp0ZcYF。 截图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中UIPopoverController使用详解","slug":"239iOS中UIPopoverController使用详解","date":"2016-07-12T16:00:00.000Z","updated":"2021-07-09T07:46:12.375Z","comments":true,"path":"2016/07/13/239iOS中UIPopoverController使用详解/","link":"","permalink":"http://huishao.cc/2016/07/13/239iOS中UIPopoverController使用详解/","excerpt":"","text":"iOS中UIPopoverController使用详解一、引言UIPopoverController是Pad设备中常用的一种视图控制器，其在UI表现上为在当前视图控制器上面弹出一个子视图控制器，通常用来展示交互列表。示例如下图： UIPopoverController只能用于iPad，在要兼容iPad和iPhone的项目中，需要根据设备类型使用两套代码。在iOS8之后，系统提供了UIPresentationController来代替她，UIPresentationController可以兼容iPhone与iPad。 二、UIPopoverController的使用详解首先UIPopoverController是一个容器控制器，其中需要承载一个ViewControler作为内容视图。UIPopoverController使用如下初始化方法创建： 12//创建视图控制器的方法 通过一个内容视图控制器创建- (instancetype)initWithContentViewController:(UIViewController *)viewController; 创建出控制器后，调用如下方法可以将控制器弹出： 12345678910111213141516//这个方法将控制器以一个CGRect区域为基准弹出/*UIPopoverArrowDirection为箭头出现的方向typedef NS_OPTIONS(NSUInteger, UIPopoverArrowDirection) &#123; UIPopoverArrowDirectionUp = 1UL &lt;&lt; 0,//上 UIPopoverArrowDirectionDown = 1UL &lt;&lt; 1,//下 UIPopoverArrowDirectionLeft = 1UL &lt;&lt; 2,//左 UIPopoverArrowDirectionRight = 1UL &lt;&lt; 3,//右 UIPopoverArrowDirectionAny = UIPopoverArrowDirectionUp | UIPopoverArrowDirectionDown | UIPopoverArrowDirectionLeft | UIPopoverArrowDirectionRight,//任意方向 UIPopoverArrowDirectionUnknown = NSUIntegerMax//未知&#125;;*///view参数为选择要在那个View视图上弹出 animated参数设置是否带动画- (void)presentPopoverFromRect:(CGRect)rect inView:(UIView *)view permittedArrowDirections:(UIPopoverArrowDirection)arrowDirections animated:(BOOL)animated;//以一个BarButtonItem为基准弹出 其余参数意义同上- (void)presentPopoverFromBarButtonItem:(UIBarButtonItem *)item permittedArrowDirections:(UIPopoverArrowDirection)arrowDirections animated:(BOOL)animated; UIPopoverController的相关设置方法如下： 12345678910111213141516171819202122232425//设置代理@property (nullable, nonatomic, weak) id &lt;UIPopoverControllerDelegate&gt; delegate;//设置内容视图控制器@property (nonatomic, strong) UIViewController *contentViewController;- (void)setContentViewController:(UIViewController *)viewController animated:(BOOL)animated;//设置界面展示尺寸@property (nonatomic) CGSize popoverContentSize;- (void)setPopoverContentSize:(CGSize)size animated:(BOOL)animated;//获取控制器当前是否正在展示@property (nonatomic, readonly, getter=isPopoverVisible) BOOL popoverVisible;//获取控制器箭头方向@property (nonatomic, readonly) UIPopoverArrowDirection popoverArrowDirection;//这个属性可以增强控制器的交互能力/*默认情况下，当视图控制器弹出时，点击界面上的其他位置，视图控制器会被隐藏 如果需要当视图控制爱弹出时界面上的其他控件依然可以进行用户交互，则需要将这些UI控件设置进这个数组中*/@property (nullable, nonatomic, copy) NSArray&lt;__kindof UIView *&gt; *passthroughViews;//隐藏视图控制器的方法- (void)dismissPopoverAnimated:(BOOL)animated;//设置视图控制器的背景颜色@property (nullable, nonatomic, copy) UIColor *backgroundColor NS_AVAILABLE_IOS(7_0);//设置视图Margin@property (nonatomic, readwrite) UIEdgeInsets popoverLayoutMargins NS_AVAILABLE_IOS(5_0);//这个属性用于自定义PopoverController的UI展现 传入自定义的背景视图类@property (nullable, nonatomic, readwrite, strong) Class popoverBackgroundViewClass NS_AVAILABLE_IOS(5_0); 三、自定义UI展现的UIPopoverController通过设置UIPopoverController对象的popoverBacjgroundViewClass属性可以将一个自定义的类作为控制器的背景视图，需要注意，此自定义的类必须继承自UIPopoverBackgroundView，并且子类必须覆写父类中的一些列方法，示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@interface MyView : UIPopoverBackgroundView@end@implementation MyView//这个方法返回箭头宽度+ (CGFloat)arrowBase&#123; return 20;&#125;//这个方法中返回内容视图的偏移+(UIEdgeInsets)contentViewInsets&#123; return UIEdgeInsetsMake(20, 20, 20, 20);&#125;//这个方法返回箭头高度+(CGFloat)arrowHeight&#123; return 30;&#125;//这个方法返回箭头的方向-(UIPopoverArrowDirection)arrowDirection&#123; return UIPopoverArrowDirectionUp;&#125;//这个在设置箭头方向时被调用 可以监听做处理-(void)setArrowDirection:(UIPopoverArrowDirection)arrowDirection&#123; &#125;//这个方法在设置箭头偏移量时被调用 可以监听做处理-(void)setArrowOffset:(CGFloat)arrowOffset&#123; &#125;//重写layout方法来来定义箭头样式- (void)layoutSubviews&#123; [super layoutSubviews]; CGSize arrowSize = CGSizeMake([[self class] arrowBase], [[self class] arrowHeight]); UIImage * image = [self drawArrowImage:arrowSize]; UIImageView * imageView = [[UIImageView alloc]initWithImage:image]; imageView.frame = CGRectMake(0, 0.0f, arrowSize.width, arrowSize.height); [self addSubview:imageView];&#125;//这个方法中进行背景色的设置- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor = [UIColor redColor]; &#125; return self;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; &#125; return self;&#125;//返回值决定是否渲染阴影+(BOOL)wantsDefaultContentAppearance&#123; return NO;&#125;//画箭头方法- (UIImage *)drawArrowImage:(CGSize)size&#123; UIGraphicsBeginImageContextWithOptions(size, NO, 0); CGContextRef ctx = UIGraphicsGetCurrentContext(); [[UIColor clearColor] setFill]; CGContextFillRect(ctx, CGRectMake(0.0f, 0.0f, size.width, size.height)); CGMutablePathRef arrowPath = CGPathCreateMutable(); CGPathMoveToPoint(arrowPath, NULL, (size.width/2.0f), 0.0f); CGPathAddLineToPoint(arrowPath, NULL, size.width, size.height); CGPathAddLineToPoint(arrowPath, NULL, 0.0f, size.height); CGPathCloseSubpath(arrowPath); CGContextAddPath(ctx, arrowPath); CGPathRelease(arrowPath); UIColor *fillColor = [UIColor yellowColor]; CGContextSetFillColorWithColor(ctx, fillColor.CGColor); CGContextDrawPath(ctx, kCGPathFill); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125;@end 四、UIPopoverPresentationController应用解析UIPopoverPresentationController是iOS8后系统新引入的控制器，其可以很好的兼容iPhone与iPad。UIPopoverPresentationContriller的使用需要和UIViewController结合进行，使用过程示例如下： 12345678UITableViewController tabCon = [[UITableViewController alloc]initWithStyle:UITableViewStylePlain];//设置跳转模式为popover模式tabCon.modalPresentationStyle = UIModalPresentationPopover;//获取到UIPopoverPresentationController对象UIPopoverPresentationController* con = tabCon.popoverPresentationController;//设置弹出的基准视图con.sourceView = self.view;[self presentViewController:tabCon animated:YES completion:nil]; UIPopoverPresentationController中属性如下： 12345678910111213141516171819//设置代理@property (nullable, nonatomic, weak) id &lt;UIPopoverPresentationControllerDelegate&gt; delegate;//设置允许的箭头方向@property (nonatomic, assign) UIPopoverArrowDirection permittedArrowDirections;//设置基准视图或者区域@property (nullable, nonatomic, strong) UIView *sourceView;@property (nonatomic, assign) CGRect sourceRect;//设置是否覆盖基准视图区域@property (nonatomic, assign) BOOL canOverlapSourceViewRect NS_AVAILABLE_IOS(9_0);//设置基准BarButtonItem@property (nullable, nonatomic, strong) UIBarButtonItem *barButtonItem;//设置可以进行用户交互的视图@property (nullable, nonatomic, copy) NSArray&lt;UIView *&gt; *passthroughViews;//设置背景颜色@property (nullable, nonatomic, copy) UIColor *backgroundColor;//设置Margin@property (nonatomic, readwrite) UIEdgeInsets popoverLayoutMargins;//设置自定义视图@property (nullable, nonatomic, readwrite, strong) Class &lt;UIPopoverBackgroundViewMethods&gt; popoverBackgroundViewClass; UIPopoverPresentationControllerDelegate中的方法如下： 12345678//控制器将要弹出时调用- (void)prepareForPopoverPresentation:(UIPopoverPresentationController *)popoverPresentationController;//控制器将要消失时调用- (BOOL)popoverPresentationControllerShouldDismissPopover:(UIPopoverPresentationController *)popoverPresentationController;//控制器已经消失时调用- (void)popoverPresentationControllerDidDismissPopover:(UIPopoverPresentationController *)popoverPresentationController;//控制器接收到弹出消息时调用- (void)popoverPresentationController:(UIPopoverPresentationController *)popoverPresentationController willRepositionPopoverToRect:(inout CGRect *)rect inView:(inout UIView * __nonnull * __nonnull)view; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS使用UIImagePickerController调用系统相机、相册与图库","slug":"238 iOS使用UIImagePickerController调用系统相机、相册与图库","date":"2016-07-11T16:00:00.000Z","updated":"2021-07-09T07:45:08.522Z","comments":true,"path":"2016/07/12/238 iOS使用UIImagePickerController调用系统相机、相册与图库/","link":"","permalink":"http://huishao.cc/2016/07/12/238 iOS使用UIImagePickerController调用系统相机、相册与图库/","excerpt":"","text":"iOS使用UIImagePickerController调用系统相机、相册与图库一、引言UIImagePickerController是系统封装好的一个导航视图控制器，使用其开发者可以十分方便的进行相机相册相关功能的调用。UIImagePickerController继承于UINavigationController，其通过代理的方式将用户获取的图片或者视频文件传入给开发者。 二、UIImagePickerController中属性与方法的应用在使用UIImagePickerController之前，应该先判断设备做支持的媒体文件获取类型，使用如下方法进行判断： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//判断是否支持某个数据提供类型/*UIImagePickerControllerSourceType枚举定义如下:typedef NS_ENUM(NSInteger, UIImagePickerControllerSourceType) &#123; //系统图库 UIImagePickerControllerSourceTypePhotoLibrary, //相机 UIImagePickerControllerSourceTypeCamera, //系统相册 UIImagePickerControllerSourceTypeSavedPhotosAlbum&#125; __TVOS_PROHIBITED;*/+ (BOOL)isSourceTypeAvailable:(UIImagePickerControllerSourceType)sourceType;//判断某个数据提供者所支持的文件格式/*文件格式定义在&lt;MobileCoreServices/MobileCoreServices.h&gt;框架中*/+ (nullable NSArray&lt;NSString *&gt; *)availableMediaTypesForSourceType:(UIImagePickerControllerSourceType)sourceType; //判断所支持的相机设备/*typedef NS_ENUM(NSInteger, UIImagePickerControllerCameraDevice) &#123; //前置摄像头 UIImagePickerControllerCameraDeviceRear, //后置摄像头 UIImagePickerControllerCameraDeviceFront&#125; __TVOS_PROHIBITED;*/+ (BOOL)isCameraDeviceAvailable:(UIImagePickerControllerCameraDevice)cameraDevice NS_AVAILABLE_IOS(4_0); //判断对闪光灯的支持+ (BOOL)isFlashAvailableForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice NS_AVAILABLE_IOS(4_0);//判断相机设备支持的媒体模式/*返回值为如下枚举：typedef NS_ENUM(NSInteger, UIImagePickerControllerCameraCaptureMode) &#123; //照片模式 UIImagePickerControllerCameraCaptureModePhoto, //视频模式 UIImagePickerControllerCameraCaptureModeVideo&#125; __TVOS_PROHIBITED;*/+ (nullable NSArray&lt;NSNumber *&gt; *)availableCaptureModesForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice NS_AVAILABLE_IOS(4_0); 上面提到的定义于&lt;MobileCoreServices/MobileCoreServices.h&gt;框架中的文件类型，列举如下： 1234567891011121314151617181920212223242526272829303132333435363738//图片类型extern const CFStringRef kUTTypeImage __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);//JPEG格式extern const CFStringRef kUTTypeJPEG __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);//JPEG2000格式extern const CFStringRef kUTTypeJPEG2000 __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeTIFF __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypePICT __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeGIF __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypePNG __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeQuickTimeImage __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeAppleICNS __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeBMP __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeICO __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeRawImage __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeScalableVectorGraphics __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeLivePhoto __OSX_AVAILABLE_STARTING(__MAC_NA,__IPHONE_9_1);//视频格式extern const CFStringRef kUTTypeAudiovisualContent __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMovie __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeVideo __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeAudio __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeQuickTimeMovie __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMPEG __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMPEG2Video __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeMPEG2TransportStream __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeMP3 __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMPEG4 __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeMPEG4Audio __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeAppleProtectedMPEG4Audio __OSX_AVAILABLE_STARTING(__MAC_10_4,__IPHONE_3_0);extern const CFStringRef kUTTypeAppleProtectedMPEG4Video __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeAVIMovie __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeAudioInterchangeFileFormat __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeWaveformAudio __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0);extern const CFStringRef kUTTypeMIDIAudio __OSX_AVAILABLE_STARTING(__MAC_10_10,__IPHONE_8_0); CFStringRef与NSString类型的转换，可以使用如下方法： 1NSString * str = (__bridge NSString*)kUTTypeMovie; UIImagePickerController中更多属性与方法解析如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//设置代理@property(nullable,nonatomic,weak) id &lt;UINavigationControllerDelegate, UIImagePickerControllerDelegate&gt; delegate;//设置书体提供者类型 默认为图库@property(nonatomic) UIImagePickerControllerSourceType sourceType; //设置所需要的数据类型，需要设置为系统定义的文件类型字符串数组 默认为kUTTypeImage@property(nonatomic,copy) NSArray&lt;NSString *&gt; *mediaTypes;//设置是否允许编辑图片 设置为YES，则用户选择图片时可以编辑裁剪图片@property(nonatomic) BOOL allowsEditing;//设置媒体文件的最大时长 默认为10分钟@property(nonatomic) NSTimeInterval videoMaximumDuration; //设置媒体文件的质量 枚举如下：/*typedef NS_ENUM(NSInteger, UIImagePickerControllerQualityType) &#123; UIImagePickerControllerQualityTypeHigh = 0, // 高质量 UIImagePickerControllerQualityTypeMedium = 1, // 中等质量 UIImagePickerControllerQualityTypeLow = 2, // 低质量 UIImagePickerControllerQualityType640x480 NS_ENUM_AVAILABLE_IOS(4_0) = 3, UIImagePickerControllerQualityTypeIFrame1280x720 NS_ENUM_AVAILABLE_IOS(5_0) = 4, UIImagePickerControllerQualityTypeIFrame960x540 NS_ENUM_AVAILABLE_IOS(5_0) = 5,&#125; __TVOS_PROHIBITED;*/@property(nonatomic) UIImagePickerControllerQualityType videoQuality;//设置是否显示相机控制界面@property(nonatomic) BOOL showsCameraControls;//自定义的拍照界面 其会覆盖在原拍照界面上@property(nullable, nonatomic,strong) __kindof UIView *cameraOverlayView NS_AVAILABLE_IOS(3_1); //设置拍照界面的transform@property(nonatomic) CGAffineTransform cameraViewTransform ;//拍照- (void)takePicture NS_AVAILABLE_IOS(3_1); //进行视频捕获- (BOOL)startVideoCapture NS_AVAILABLE_IOS(4_0);//停止视频捕获- (void)stopVideoCapture NS_AVAILABLE_IOS(4_0);//设置相机捕获模式 照片或视频@property(nonatomic) UIImagePickerControllerCameraCaptureMode cameraCaptureMode;//设置相机设备 前置或后置摄像头@property(nonatomic) UIImagePickerControllerCameraDevice cameraDevice;//设置闪光灯模式/*typedef NS_ENUM(NSInteger, UIImagePickerControllerCameraFlashMode) &#123; UIImagePickerControllerCameraFlashModeOff = -1, //关闭 UIImagePickerControllerCameraFlashModeAuto = 0, //自动 UIImagePickerControllerCameraFlashModeOn = 1 //开启&#125; __TVOS_PROHIBITED;*/@property(nonatomic) UIImagePickerControllerCameraFlashMode cameraFlashMode; 三、UIImagePickerControllerDelegate中方法解析123456//相机拍照完成或者从图库相册选择相片完成后触发的回调方法 editingInfo字典中将传入编辑信息- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingImage:(UIImage *)image editingInfo:(nullable NSDictionary&lt;NSString *,id&gt; *)editingInfo NS_DEPRECATED_IOS(2_0, 3_0);//相机录像或者从图库相册选择视频完成后触发的回调方法 info字典中是具体信息- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info;//ImagePickerController取消选择是回调的方法- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker; 上面方法中的编辑字典与信息字典中，约定好了一些键值对，开发者可以通过相应的键获取需要的信息，规则如下： 12345678910111213141516//这个键对应NSString类型的值 意义为媒体文件的格式UIKIT_EXTERN NSString *const UIImagePickerControllerMediaType;//这个键对应UIImage类型的值 意义为获取的原始图片UIKIT_EXTERN NSString *const UIImagePickerControllerOriginalImage;//这个件对应UIIImage类型的值 意义为获取编辑后的图片UIKIT_EXTERN NSString *const UIImagePickerControllerEditedImage;//这个键对应一个NSValue值 可以转为CGRect类型 意义为编辑的图片范围UIKIT_EXTERN NSString *const UIImagePickerControllerCropRect;//这个键对应媒体文件的URLUIKIT_EXTERN NSString *const UIImagePickerControllerMediaURL;//这个键对应图库中的URLUIKIT_EXTERN NSString *const UIImagePickerControllerReferenceURL;//这个键对应一个NSDictionary 里面存放媒体数据UIKIT_EXTERN NSString *const UIImagePickerControllerMediaMetadata;//现场图片数据 相机捕捉图片时会记录声音UIKIT_EXTERN NSString *const UIImagePickerControllerLivePhoto; 四、对捕获的图片与视频进行持久化系统也提供了对相机照片和视频进行存储的方式，列举如下： 12345//将图片数据存储到相册void UIImageWriteToSavedPhotosAlbum(UIImage *image, __nullable id completionTarget, __nullable SEL completionSelector, void * __nullable contextInfo);//将视频保存到相册BOOL UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(NSString *videoPath);void UISaveVideoAtPathToSavedPhotosAlbum(NSString *videoPath, __nullable id completionTarget, __nullable SEL completionSelector, void * __nullable contextInfo); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS第三方文件压缩框架——Godzippa","slug":"237iOS第三方文件压缩框架——Godzippa","date":"2016-07-10T16:00:00.000Z","updated":"2021-07-09T03:07:31.040Z","comments":true,"path":"2016/07/11/237iOS第三方文件压缩框架——Godzippa/","link":"","permalink":"http://huishao.cc/2016/07/11/237iOS第三方文件压缩框架——Godzippa/","excerpt":"","text":"iOS第三方文件压缩框架——GodzippaGodzippa是iOS开发中常用的一个第三方数据压缩框架，其采用类别的方式，为NSData类与NSFileManager类提供了压缩和解压缩数据的方法。 Godzippa的github地址如下：[https://github.com/mattt/Godzippa](https://github.com/mattt/Godzippa)。 NSData类别中提供的方法如下： 123456789101112//进行数据压缩操作- (NSData *)dataByGZipCompressingWithError:(NSError * __autoreleasing *)error;//进行数据压缩操作，支持配置缓存区大小，压缩比等参数- (NSData *)dataByGZipCompressingAtLevel:(int)level windowSize:(int)windowBits memoryLevel:(int)memLevel strategy:(int)strategy error:(NSError * __autoreleasing *)error;//进行数据解压缩操作- (NSData *)dataByGZipDecompressingDataWithError:(NSError * __autoreleasing *)error;- (NSData *)dataByGZipDecompressingDataWithWindowSize:(int)windowBits error:(NSError * __autoreleasing *)error; NSFileManager类别中提供的方法如下： 12345678910111213//压缩文件并写入磁盘 返回值确定压缩操作是否成功- (BOOL)GZipCompressFile:(NSURL *)sourceFile writingContentsToFile:(NSURL *)destinationFile error:(NSError * __autoreleasing *)error;//进行文件压缩，支持配置压缩级别- (BOOL)GZipCompressFile:(NSURL *)sourceFile writingContentsToFile:(NSURL *)destinationFile atLevel:(int)level error:(NSError *__autoreleasing *)error;//进行文件的解压缩- (BOOL)GZipDecompressFile:(NSURL *)sourceFile writingContentsToFile:(NSURL *)destinationFile error:(NSError * __autoreleasing *)error; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS第三方网络诊断库——LDNetDiagnoService","slug":"236iOS第三方网络诊断库——LDNetDiagnoService","date":"2016-07-07T16:00:00.000Z","updated":"2021-07-09T03:06:49.639Z","comments":true,"path":"2016/07/08/236iOS第三方网络诊断库——LDNetDiagnoService/","link":"","permalink":"http://huishao.cc/2016/07/08/236iOS第三方网络诊断库——LDNetDiagnoService/","excerpt":"","text":"iOS第三方网络诊断库——LDNetDiagnoService_IOSLDNetDiagnoService\\_IOS是一个开源的第三方网络诊断框架，它通过ping与traceroute原理来对指定域名进行网络诊断。并且这个库一直在跟进维护，进行IPV\\_6-Only的支持。 LDNetDiagnoService_IOS的git地址如下：[https://github.com/Lede-Inc/LDNetDiagnoService_IOS](https://github.com/Lede-Inc/LDNetDiagnoService_IOS)。 LDNetDiagnoService的使用十分简单，只需要3步即可完成。 首先需要对服务引擎进行初始化，代码如下： 12345678910111213//进行服务引擎的初始化 其中AppCode，AppName，UserID与dormain参数必须填写，其他参数会自动生成service = [[LDNetDiagnoService alloc]initWithAppCode:@\"app编码\" appName:@\"demo\" appVersion:nil userID:@\"UserID\" deviceID:nil dormain:@\"www.baidu.com\" carrierName:nil ISOCountryCode:nil MobileCountryCode:nil MobileNetCode:nil];//设置代理service.delegate = self; 初始化完成服务引擎后，需要开启检测，如下： 1234//开始诊断网络- (void)startNetDiagnosis;//停止诊断网络- (void)stopNetDialogsis; 开始诊断网络后，会通过代理方法将诊断信息回调给开发者，代码如下： 12345678910111213141516171819202122232425/** * 告诉调用者诊断开始 */- (void)netDiagnosisDidStarted&#123; NSLog(@\"开始进行诊断~~\");&#125;/** * 逐步返回监控信息， * 如果需要实时显示诊断数据，实现此接口方法 */- (void)netDiagnosisStepInfo:(NSString *)stepInfo&#123; NSLog(@\"正在诊断：%@\",stepInfo);&#125;/** * 因为监控过程是一个异步过程，当监控结束后告诉调用者； * 在监控结束的时候，对监控字符串进行处理 */- (void)netDiagnosisDidEnd:(NSString *)allLogInfo&#123; NSLog(@\"诊断结束\"); NSLog(@\"%@\",allLogInfo);&#125; Xcode调试区信息如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS第三方星级视图控件——HCSStarRatingView","slug":"235iOS第三方星级视图控件——HCSStarRatingView","date":"2016-07-05T16:00:00.000Z","updated":"2021-07-09T03:06:06.368Z","comments":true,"path":"2016/07/06/235iOS第三方星级视图控件——HCSStarRatingView/","link":"","permalink":"http://huishao.cc/2016/07/06/235iOS第三方星级视图控件——HCSStarRatingView/","excerpt":"","text":"iOS第三方星级视图控件——HCSStarRatingViewHCStarRatingView是一款十分小巧的星级视图控件，其通过原生画图的方式来渲染星级视图页面，同时，其也支持开发者对星级图片的自定义操作。 HCStarRatingView的git地址如下：[https://github.com/hsousa/HCSStarRatingView](https://github.com/hsousa/HCSStarRatingView)。 HCStarRatingView的使用十分简单，示例如下： 1234HCSStarRatingView * starView = [[HCSStarRatingView alloc]initWithFrame:CGRectMake(20, 100, 280, 50)];starView.tintColor = [UIColor redColor];[starView addTarget:self action:@selector(didChange:) forControlEvents:UIControlEventValueChanged];[self.view addSubview:starView]; 效果如下图： 开发者也对其进行一些自定义的设置，列举如下： 12345678910111213141516171819202122232425//设置最大值@property (nonatomic) IBInspectable NSUInteger maximumValue;//设置最小值@property (nonatomic) IBInspectable CGFloat minimumValue;//星级视图当前值@property (nonatomic) IBInspectable CGFloat value;//星星间间距@property (nonatomic) IBInspectable CGFloat spacing;//是否允许选择半星@property (nonatomic) IBInspectable BOOL allowsHalfStars;//是否是否允许精确选择 可以根据选择位置进行精确@property (nonatomic) IBInspectable BOOL accurateHalfStars;//是否连续调用回调方法 如果设置为YES 则在手指拖动时 会持续调用回调方法 如果设置为NO，则只有拖动结束后才调用回调@property (nonatomic) IBInspectable BOOL continuous;//是否允许成为第一响应@property (nonatomic) BOOL shouldBecomeFirstResponder;//添加手势时使用@property (nonatomic, copy) HCSStarRatingViewShouldBeginGestureRecognizerBlock shouldBeginGestureRecognizerBlock;//自定义星星视图UI//设置空星的图片@property (nonatomic, strong) IBInspectable UIImage *emptyStarImage;//设置半星的图片@property (nonatomic, strong) IBInspectable UIImage *halfStarImage;//设置全星时的图片@property (nonatomic, strong) IBInspectable UIImage *filledStarImage; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayout","slug":"234iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayout","date":"2016-07-04T16:00:00.000Z","updated":"2021-07-09T03:05:19.642Z","comments":true,"path":"2016/07/05/234iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayout/","link":"","permalink":"http://huishao.cc/2016/07/05/234iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayout/","excerpt":"","text":"iOS第三方左对齐布局类——UICollectionViewLeftAlignedLayoutUICollectionViewLeftAlignedLayout是第三方的左对齐布局管理类，其继承自UICollectionViewFlowLayout，使用其可以方便的进行左对齐的瀑布流界面布局。 UICollectionViewLeftAlignedLayout的git地址如下：[https://github.com/mokagio/UICollectionViewLeftAlignedLayout](https://github.com/mokagio/UICollectionViewLeftAlignedLayout)。 使用示例如下： 12345678910111213141516171819202122232425262728293031323334#import &lt;UICollectionViewLeftAlignedLayout.h&gt;@interface ViewController ()&lt;UICollectionViewDataSource,UICollectionViewDelegateFlowLayout&gt;@property(nonatomic,strong)UICollectionView * collectionView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UICollectionViewLeftAlignedLayout* layout = [[UICollectionViewLeftAlignedLayout alloc]init]; self.collectionView = [[UICollectionView alloc]initWithFrame:self.view.frame collectionViewLayout:layout]; self.collectionView.dataSource = self; self.collectionView.delegate=self; [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@\"cellID\"]; [self.view addSubview:self.collectionView];&#125;-(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; return CGSizeMake(arc4random()%100+50, 100);&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@\"cellID\" forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125;@end 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS中表单视图第三方控件——FXForms","slug":"233iOS中表单视图第三方控件——FXForms","date":"2016-07-03T16:00:00.000Z","updated":"2021-07-09T03:04:33.884Z","comments":true,"path":"2016/07/04/233iOS中表单视图第三方控件——FXForms/","link":"","permalink":"http://huishao.cc/2016/07/04/233iOS中表单视图第三方控件——FXForms/","excerpt":"","text":"iOS中表单视图第三方控件——FXForms一、引言表单视图是移动开发中十分常用的一种UI方式。在iOS开发中，系统的UITableView可以用来创建表单视图，其界面的渲染与逻辑的处理需要开发者实现许多代理方法。FXForms是一个第三方的表单创建工具，其通过配置的方式来进行表单界面的创建，并且其中为开发者封装好了各种常用类型的表单cell。 FXForms的github地址如下：[https://github.com/nicklockwood/FXForms](https://github.com/nicklockwood/FXForms)。 二、使用FXForms进行表单视图的创建FXForms框架中提供了一个FXFormViewController视图控制器类，开发者可以直接编写继承于这个类的ViewController来便捷的创建表单界面，首先，FXForms是通过节点配置的方式来进行表单的创建的，表单中每一个cell都是一个节点，这个节点可以是简单的单节点，也可以是父节点，点击父节点后，会跳转新的视图控制器，父节点中可以进行层层嵌套。对于每一个节点，开发者可以设置一个节点类型，不同的节点类型将展现不同的UI，实现不同的功能。 FXForms中的节点由FXForm协议来进行配置，创建一个简单的表单视图，示例如下： 123456789101112131415161718//视图控制器类部分@interface ViewController : FXFormViewController@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //节点信息设置 self.formController.form = [MyForm new];&#125;@end//节点类配置@interface MyForm : NSObject&lt;FXForm&gt;@property(nonatomic,strong)NSString * email;@property(nonatomic,strong)NSString * password;@property(nonatomic,assign)BOOL rememberMe;@end@implementation MyForm@end 上面的MyForm类中只定义了一些属性，并没有进行任何方法的实现，FXForms框架中实现了这样的功能，如果开发者不进行节点信息的配置，则FXForms会自动根据节点配置类中所有的属性来推断节点的类型，如上所示，NSString类型的属性会被自动推断成带文本框的cell，BOOL类型的属性会被自动推断成带UISwitch控件的cell。运行效果如下： 开发者可以为节点配置类中的每一个属性提供一个约定好的方法，在方法中对此属性对应的节点进行配置，这个约定好的方法名需要与属性对应，其格式是使用属性名加上Field，示例如下： 12345678910111213141516@implementation MyForm//方法名必须是 属性名+Field 返回为NSDictionary字典 字典中为节点的配置信息-(NSDictionary *)emailField&#123; //配置节点的类型 点击后 将弹出时间选择控件 return @&#123;FXFormFieldType:FXFormFieldTypeDate&#125;;&#125;-(NSDictionary *)passwdField&#123; //设置节点名称 return @&#123;FXFormFieldTitle:@\"名称\"&#125;;&#125;-(NSDictionary *)rememberMeField&#123; //设置节点头视图名称 return @&#123;FXFormFieldHeader:@\"配置\"&#125;;&#125;@end 运行工程，效果如下图所示： 返回的配置字典中可以用来配置的属性定义如下： 12345678910111213141516171819202122232425262728293031323334//配置此节点的标识符UIKIT_EXTERN NSString *const FXFormFieldKey;//配置此节点的类型UIKIT_EXTERN NSString *const FXFormFieldType; //指定当前节点属性对应的类 一般不需设置UIKIT_EXTERN NSString *const FXFormFieldClass;//设置当前节点对应的cell类UIKIT_EXTERN NSString *const FXFormFieldCell;//设置当前节点显示的名称UIKIT_EXTERN NSString *const FXFormFieldTitle;//设置当前节点的placeHolderUIKIT_EXTERN NSString *const FXFormFieldPlaceholder;//设置节点上默认显示的文字UIKIT_EXTERN NSString *const FXFormFieldDefaultValue; //设置选项数组 这个属性的设置 必须配合特定配型的cell使用UIKIT_EXTERN NSString *const FXFormFieldOptions;//如果某个节点是一个数组 则FXFormFieldTemplate可以用来设置数组中节点的属性UIKIT_EXTERN NSString *const FXFormFieldTemplate;//进行类型转换UIKIT_EXTERN NSString *const FXFormFieldValueTransformer;//设置节点的触发方法UIKIT_EXTERN NSString *const FXFormFieldAction;//连接StoryboardSegueUIKIT_EXTERN NSString *const FXFormFieldSegue;//设置节点头部内容UIKIT_EXTERN NSString *const FXFormFieldHeader;//设置节点尾部内容UIKIT_EXTERN NSString *const FXFormFieldFooter;//设置是否是内嵌节点 对于父节点或者数组类界定 这个如果设置为@YES 则会在当前界面中展示表单 如果设置为@NO，则会在新的视图控制器中展示UIKIT_EXTERN NSString *const FXFormFieldInline;//对于数组类型的节点，设置是否支持排序 设置为@YES则为支持排序UIKIT_EXTERN NSString *const FXFormFieldSortable;//设置选中cell后跳转的ViewControllerUIKIT_EXTERN NSString *const FXFormFieldViewController; 关于设置节点的类型，FXFormFieldType可以设置的值有如下几种： 123456789101112131415161718192021222324252627282930313233343536//默认的节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeDefault;//文本标签节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeLabel;//输入框节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeText;//长文本输入节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeLongText; //URL节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeURL;//Email节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeEmail; //号码节点类型UIKIT_EXTERN NSString *const FXFormFieldTypePhone; //密码框节点类型UIKIT_EXTERN NSString *const FXFormFieldTypePassword;//数字节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeNumber;//只允许输入整数的节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeInteger;//无符号整数节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeUnsigned; //浮点节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeFloat;//BOOL节点类型 默认带UISwitch控件UIKIT_EXTERN NSString *const FXFormFieldTypeBoolean;//选项节点类型 默认带对号符号UIKIT_EXTERN NSString *const FXFormFieldTypeOption;//日期节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeDate;//时间节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeTime;//日期时间节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeDateTime;//图片节点类型UIKIT_EXTERN NSString *const FXFormFieldTypeImage; FXForms中也提供了许多封装好的cell，列举如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//默认的cell@interface FXFormDefaultCell : FXFormBaseCell@end//带文本输入框的cell@interface FXFormTextFieldCell : FXFormBaseCell@property (nonatomic, readonly) UITextField *textField;@end//带文本输入视图的cell@interface FXFormTextViewCell : FXFormBaseCell@property (nonatomic, readonly) UITextView *textView;@end//带UISwitch控件的cell@interface FXFormSwitchCell : FXFormBaseCell@property (nonatomic, readonly) UISwitch *switchControl;@end//带UIStepper控件的cell@interface FXFormStepperCell : FXFormBaseCell@property (nonatomic, readonly) UIStepper *stepper;@end//带UISlider控件的cell@interface FXFormSliderCell : FXFormBaseCell@property (nonatomic, readonly) UISlider *slider;@end//带日期选择控件的cell@interface FXFormDatePickerCell : FXFormBaseCell@property (nonatomic, readonly) UIDatePicker *datePicker;@end//带图片选择控件的cell@interface FXFormImagePickerCell : FXFormBaseCell@property (nonatomic, readonly) UIImageView *imagePickerView;@property (nonatomic, readonly) UIImagePickerController *imagePickerController;@end//带自定义PickerView的cell@interface FXFormOptionPickerCell : FXFormBaseCell@property (nonatomic, readonly) UIPickerView *pickerView;@end//带UISegmentedControl控件的cell@interface FXFormOptionSegmentsCell : FXFormBaseCell@property (nonatomic, readonly) UISegmentedControl *segmentedControl;@end 还有一点需要注意，如果是继承与FXFormViewController的视图控制器，其节点设置的action方法要在视图控制器中进行实现。 三、通过协议方法来进行节点配置上面演示的创建表格视图的方式是在节点配置类中创建属性，分别配置属性的节点信息来创建每一个cell，开发者也可以不创建属性，或者创建属性但是不以属性为节点来进行cell配置，使用FXFrom协议的方法，也可以完成节点的创建和配置，示例如下： 12345678910111213141516@interface MyForm : NSObject&lt;FXForm&gt;@end@implementation MyForm//创建与配置节点- (NSArray *)fields&#123; return @[ //这里面配置字典的方法和属性字典的配置方法一一致 @&#123;FXFormFieldKey: @\"email\", FXFormFieldTitle: @\"email\"&#125;, @&#123;FXFormFieldKey: @\"phone\", FXFormFieldTitle: @\"phone\"&#125;, @&#123;FXFormFieldKey: @\"address\", FXFormFieldTitle: @\"address\"&#125;, @&#123;FXFormFieldKey: @\"name\", FXFormFieldTitle: @\"name\"&#125; ];&#125;@end 效果如下： -(NSArray *)fields方法是FXForm协议中的一个方法，在这个方法中，可以直接进行节点的创建和配置，FXForm协议中还提供了两个方法，意义如下： 1234//这个方法用于配置额外的节点，如果需要某些节点不对应任何属性，可以在这个方法中配置- (NSArray *)extraFields;//这个方法需要返回一个字符串数组，如果需要某些属性不对应节点，即有属性的存在，但是不生成cell，可以将属性名传入返回- (NSArray *)excludedFields; 节点也可以进行复合，例如可以将一个节点配置类作为属性设置给另一个节点配置类，示例如下： 123456789101112131415161718//子节点信息配置类@interface SubForm : NSObject&lt;FXForm&gt;@property(nonatomic,assign)NSInteger age;@property(nonatomic,assign)NSDate * date;@end@implementation SubForm@end//父节点信息配置类@interface MyForm : NSObject&lt;FXForm&gt;@property(nonatomic,strong)NSString * email;@property(nonatomic,strong)NSString * passwd;@property(nonatomic,assign)BOOL rememberMe;//其中有属性为子节点@property(nonatomic,strong)SubForm * subForm;@end@implementation MyForm@end 子节点会被默认包装在新的视图控制器中，也可以设置FXFormFieldInline为@YES来使其复合进当前视图控制器，效果如下： 四、关于自定义视图控制器如果开发者的视图控制器并不是继承于FXFormViewController，也可以使用FXForms来快捷的创建表单视图，开发者自定义的视图控制器需要遵守FXFormControllerDelegate协议，示例如下: 12345678910111213141516171819@interface ViewController : UIViewController&lt;FXFormControllerDelegate&gt;//系统的tableView@property(nonatomic,strong)UITableView * tableView;//FX表单控制器@property(nonatomic,strong)FXFormController * formController;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.tableView = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStyleGrouped]; self.formController = [[FXFormController alloc] init]; self.formController.tableView = self.tableView; self.formController.delegate = self; self.formController.form = [[MyForm alloc] init]; self.formController.form = [MyForm new]; [self.view addSubview:self.tableView];&#125;@end 上面的代码极大了简化了ViewController中的代码量。 五、对Cell进行属性设置在进行节点属性字典的配置时，可以通过访问属性路径的方式来对cell的属性进行一些配置，例如： 123-(NSDictionary *)passwdField&#123; return @&#123;@\"textLabel.textColor\":[UIColor redColor]&#125;;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS中第三方有序字典框架——M13OrderedDictionary","slug":"232iOS中第三方有序字典框架——M13OrderedDictionary","date":"2016-06-30T16:00:00.000Z","updated":"2021-07-09T03:03:32.644Z","comments":true,"path":"2016/07/01/232iOS中第三方有序字典框架——M13OrderedDictionary/","link":"","permalink":"http://huishao.cc/2016/07/01/232iOS中第三方有序字典框架——M13OrderedDictionary/","excerpt":"","text":"iOS中第三方有序字典框架——M13OrderedDictionary一、引言M13OrderedDictionary是拥有字典和数组功能的第三方集合序列，开发者可以通过索引和键值来实现对其中元素的访问。其实现了NSArray和NSDictionary中的所有方法，并且支持KVC与KVO。 M13OederedDictionary中提供的方法包括： 1.创建与初始化。 2.访问键和值 3.查询与搜索。 4.发送消息。 5.比较与排序。 6.枚举与遍历。 7.描述与存储。 8.KVO键值监听。 9.KVC键值编码。 10.索引与下标。 另外，M13OrderedDictionary针对Xcode7也做了许多优化，例如引入了泛型的代码支持的风格。M13OrderedDictionary库的git地址如下：[https://github.com/Marxon13/M13OrderedDictionary](https://github.com/Marxon13/M13OrderedDictionary)。 二、M13OrderedDictionary中方法与属性解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228//类方法创建实例对象//默认的初始化方法+ (instancetype)orderedDictionary;//使用M13OrderedDictionary来创建实例对象+ (instancetype)orderedDictionaryWithOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;//通过文件来创建实例对象+ (instancetype)orderedDictionaryWithContentsOfFile:(NSString *)path;//通过URL来创建实例对象+ (instancetype)orderedDictionaryWithContentsOfURL:(NSURL *)URL;//创建单键值实例对象+ (instancetype)orderedDictionaryWithObject:(M13GenericType(ObjectType, id))anObject pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))aKey;//通过NSDictionary创建实例对象+ (instancetype)orderedDictionaryWithDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)entries;//初始化方法创建实例对象//默认的初始化方法- (instancetype)init;//使用M13OrderedDictionary来进行初始化- (instancetype)initWithOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;//使用M13OrderedDictionary来进行初始化 可选是否对其中元素进行复制操作- (instancetype)initWithOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary copyEntries:(BOOL)flag;//通过文件来进行初始化- (instancetype)initWithContentsOfFile:(NSString *)path;//通过url来进行初始化- (instancetype)initWithContentsOfURL:(NSURL *)URL;//通过NSDictionary对象来进行初始化- (instancetype)initWithContentsOfDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)entries;//通过键数组与值数组来进行初始化- (instancetype)initWithObjects:(NSArray M13Generics(ObjectType) *)orderedObjects pairedWithKeys:(NSArray M13Generics(KeyType) *)orderedKeys NS_DESIGNATED_INITIALIZER;//方法//判断字典中是否包含某个元素- (BOOL)containsObject:(M13GenericType(ObjectType, id))object;//判断字典中是否包含某个键值对- (BOOL)containsObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;//判断字典中是否包含某个键值对 传入的字典参数需要为单键值字典- (BOOL)containsEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;//获取字典中元素个数@property (nonatomic, readonly) NSUInteger count;//获取字典中最后一个元素的值@property (nonatomic, readonly, M13_NULLABLE) M13GenericType(ObjectType, id) lastObject;//获取字典中最后一个元素的键@property (nonatomic, readonly, M13_NULLABLE) M13GenericType(KeyType, id&lt;NSCopying&gt;) lastKey;//获取字典中最后一个元素键值对@property (nonatomic, readonly, M13_NULLABLE) NSDictionary M13Generics(KeyType, ObjectType) *lastEntry;//通过某个下标获取字典中的元素的值- (M13GenericType(ObjectType, id))objectAtIndex:(NSUInteger)index;//通过某个下标获取字典中的元素的键- (M13GenericType(KeyType, id&lt;NSCopying&gt;))keyAtIndex:(NSUInteger)index;//通过某个下标获取字段中的元素 返回的为单键值对NSDictionary对象- (NSDictionary M13Generics(KeyType, ObjectType) *)entryAtIndex:(NSUInteger)index;//通过一组下标获取一组元素的值- (NSArray M13Generics(ObjectType) *)objectsAtIndices:(NSIndexSet *)indeces;//通过一组下标获取一组元素的键- (NSArray M13Generics(KeyType) *)keysAtIndices:(NSIndexSet *)indices;//通过一组下标获取一组元素 这个方法获取的是有序集合- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)entriesAtIndices:(NSIndexSet *)indices;//通过一组下标获取一组元素 这个方法获取的是无序集合- (NSDictionary M13Generics(KeyType, ObjectType) *)unorderedEntriesAtIndices:(NSIndexSet *)indices;//示例中包含的无序字典集合@property (nonatomic, readonly) NSDictionary M13Generics(KeyType, ObjectType) *unorderedDictionary;//所有键组成的数组@property (nonatomic, readonly) NSArray M13Generics(KeyType) *allKeys;//所有值组成的数组@property (nonatomic, readonly) NSArray M13Generics(ObjectType) *allObjects;//获取某个值对应的所有键组成的数组- (NSArray M13Generics(KeyType) *)allKeysForObject:(M13GenericType(ObjectType, id))anObject;//获取某个键对应的值- (M13_NULLABLE M13GenericType(ObjectType, id))objectForKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;//获取某些键对应的值 如果没有找到 则可以设置默认返回的值 即参数anObject- (NSArray M13Generics(ObjectType) *)objectForKeys:(NSArray M13Generics(KeyType) *)keys notFoundMarker:(M13GenericType(ObjectType, id))anObject;//所有值的枚举@property (nonatomic, readonly) NSEnumerator M13Generics(ObjectType) *objectEnumerator;//所有键的枚举@property (nonatomic, readonly) NSEnumerator M13Generics(KeyType) *keyEnumerator;//所有元素的枚举@property (nonatomic, readonly) NSEnumerator M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *entryEnumerator;//所有值的反向枚举@property (nonatomic, readonly) NSEnumerator M13Generics(ObjectType) *reverseObjectEnumerator;//所有键的反向枚举@property (nonatomic, readonly) NSEnumerator M13Generics(KeyType) *reverseKeyEnumerator;//所有元素的反向枚举@property (nonatomic, readonly) NSEnumerator M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *reverseEntryEnumerator;//获取某个值的下标 找不到会返回NSNotFound- (NSUInteger)indexOfObject:(M13GenericType(ObjectType, id))object;//获取某个键的下标 找不到会返回NSNotFound- (NSUInteger)indexOfKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;//获取某个元素的下标 找不到会返回NSNotFound- (NSUInteger)indexOfEntryWithObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;//通过NSDictionary来获取某个元素的下标 找不到会返回NSNotFound- (NSUInteger)indexOfEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;//通过元素的值在某个范围内查询下标- (NSUInteger)indexOfObject:(M13GenericType(ObjectType, id))object inRange:(NSRange)range;//通过元素的键在某个范围内查询下标- (NSUInteger)indexOfKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key inRange:(NSRange)range;//在某个范围内查询某个元素的下标- (NSUInteger)indexOfEntryWithObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key inRange:(NSRange)range;- (NSUInteger)indexOfEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry inRange:(NSRange)range;//查找与某个元素的值相同的元素下标- (NSUInteger)indexOfObjectIdenticalTo:(M13GenericType(ObjectType, id))object;//查找获取与某个元素的值相同的元素的键- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectIdenticalTo:(M13GenericType(ObjectType, id))object;//查找与某个元素的值相同的元素下标 在某个范围内进行查找- (NSUInteger)indexOfObjectIdenticalTo:(M13GenericType(ObjectType, id))object inRange:(NSRange)range;//查找获取与某个元素的值相同的元素的键 在某个范围内进行查找- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectIdenticalTo:(M13GenericType(ObjectType, id))object inRange:(NSRange)range;//符合查找block中检测条件的元素的下标/*开发者可以在block中获取到遍历出的 object与index，返回值决定是否停止查找*/- (NSUInteger)indexOfObjectPassingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//同上 获取到的是键- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectPassingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx,BOOL *stop))predicate;//同上 只是这个方法可以设置枚举类型/*typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions) &#123; NSEnumerationConcurrent = (1UL &lt;&lt; 0), //正向枚举 NSEnumerationReverse = (1UL &lt;&lt; 1), //逆向枚举&#125;;*/- (NSUInteger)indexOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//同上 获取到的是元素- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx,BOOL *stop))predicate;//在一定下标集合中进行查找- (NSUInteger)indexOfObjectAtIndices:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//同上- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObjectAtIndices:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj,NSUInteger idx,BOOL *stop))predicate;//在范围内进行比较查询- (NSUInteger)indexOfObject:(M13GenericType(ObjectType, id))object inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator)cmp;//同上- (M13_NULLABLE M13GenericType(KeyType, id&lt;NSCopying&gt;))keyOfObject:(M13GenericType(ObjectType, id))object inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator)cmp;//进行一组元素下标的查询- (NSIndexSet *)indicesOfObjectsPassingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;- (NSIndexSet *)indicesOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//进行一组元素键的查询- (NSArray M13Generics(KeyType) *)keysOfObjectsPassingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;- (NSArray M13Generics(KeyType) *)keysOfObjectsWithOptions:(NSEnumerationOptions)opts passingTest:(BOOL (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))predicate;//向字典中的每一个元素发送消息- (void)makeObjectsPerformSelector:(SEL)aSelector;//向字典中的每一个元素发送消息 带参数- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)anObject;//对字典中的元素进行枚举遍历- (void)enumerateObjectsUsingBlock:(void (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))block;- (void)enumerateObjectsWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))block;//在一定范围内进行枚举- (void)enumerateObjectsAtIndices:(NSIndexSet *)indexSet options:(NSEnumerationOptions)opts usingBlock:(void (^)(M13GenericType(ObjectType, id) obj, NSUInteger idx, BOOL *stop))block;//获取与另一个数组中第一个相同的元素的值- (M13GenericType(ObjectType, id))firstObjectInCommonWithOrderedDictionary:(M13OrderedDictionary *)otherOrderedDictionary;//获取与另一个数组中第一个相同的元素的键- (M13GenericType(ObjectType, id&lt;NSCopying&gt;))firstKeyInCommonWithOrderedDictionary:(M13OrderedDictionary *)otherOrderedDictionary;//获取与另一个数组中第一个相同的元素- (NSDictionary M13Generics(KeyType, ObjectType) *)firstEntryInCommonWithOrderedDictionary:(M13OrderedDictionary *)otherOrderedDictionary;//判断两个字典是否相同- (BOOL)isEqualToOrderedDictionary:(M13OrderedDictionary *)otherOrderedDictionary;//向字典中追加键值对- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionaryByAddingObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))aKey;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionaryByAddingEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;//向字典中追加一组键值对- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionaryByAddingObjects:(NSArray M13Generics(ObjectType) *)orderedObjects pairedWithKeys:(NSArray M13Generics(KeyType) *)orderedKeys;//筛选元素- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)filteredOrderDictionarysUsingPredicateForObjects:(NSPredicate *)predicate;//获取一定范围内的子字典- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)subOrderedDictionaryWithRange:(NSRange)range;//进行元素排序相关的方法- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingFunction:(NSInteger (*)(M13GenericType(ObjectType, id),M13GenericType(ObjectType, id),void * M13__NULLABLE))comparator context:(M13_NULLABLE void *)context;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingFunction:(NSInteger (*)(M13GenericType(KeyType, id&lt;NSCopying&gt;),M13GenericType(KeyType, id&lt;NSCopying&gt;),void * M13__NULLABLE))comparator context:(M13_NULLABLE void *)context;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingFunction:(NSInteger (*)(M13GenericType(ObjectType, id),M13GenericType(ObjectType, id), void * M13__NULLABLE))comparator context:(M13_NULLABLE void *)context hint:(M13_NULLABLE NSData *)hint;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingFunction:(NSInteger (*)(M13GenericType(KeyType, id&lt;NSCopying&gt;),M13GenericType(KeyType, id&lt;NSCopying&gt;),void * M13__NULLABLE))comparator context:(M13_NULLABLE void *)context hint:(M13_NULLABLE NSData *)hint;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingDescriptors:(NSArray *)descriptors;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingDescriptors:(NSArray *)descriptors;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingSelector:(SEL)comparator;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingSelector:(SEL)comparator;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsUsingComparator:(NSComparator)cmptr;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysUsingComparator:(NSComparator)cmptr;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByObjectsWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr;- (M13OrderedDictionary M13Generics(KeyType, ObjectType) *)sortedByKeysWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr;//写入文件- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)flag;//写入到URL- (BOOL)writeToURL:(NSURL *)aURL atomically:(BOOL)flag;//添加监听- (void)addObserver:(NSObject *)anObserver toObjectsAtIndices:(NSIndexSet *)indices forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(M13_NULLABLE void *)context;- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(M13_NULLABLE void *)context;//移除监听- (void)removeObserver:(NSObject *)anObserver fromObjectsAtIndices:(NSIndexSet *)indices forKeyPath:(NSString *)keyPath;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(M13_NULLABLE void *)context;//KVC相关方法- (void)setValue:(M13_NULLABLE id)value forKey:(NSString *)key;- (void)setValue:(M13_NULLABLE id)value forKeyPath:(NSString *)keyPath;- (id)valueForKey:(NSString *)key;- (id)valueForKeyPath:(NSString *)keyPath;//归档相关方法- (void)encodeWithCoder:(NSCoder *)aCoder;- (id)initWithCoder:(NSCoder *)decoder;//copy相关方法- (id)copy;- (id)copyWithZone:(M13_NULLABLE NSZone *)zone;- (id)mutableCopy;- (id)mutableCopyWithZone:(NSZone *)zone; 三、M13MutableOrderedDictionary基于M13OrderedDictionary，M13MutableOrderedDictionary为可变的有序字典类，其中方法解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//类创建方法+ (instancetype)orderedDictionaryWithCapacity:(NSUInteger)numEntries;//初始化方法- (id)initWithCapacity:(NSUInteger)numEntries;//添加键值对的方法- (void)addObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)addEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;- (void)addEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;- (void)addEntriesFromDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)dictionary;//插入键值对的方法- (void)insertObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key atIndex:(NSUInteger)index;- (void)insertEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry atIndex:(NSUInteger)index;- (void)insertEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary atIndex:(NSUInteger)index;- (void)insertEntriesFromDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)dictionary atIndex:(NSUInteger)index;//设置键值对的方法- (void)setObject:(M13GenericType(ObjectType, id))object forKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))aKey;- (void)setEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;- (void)setEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;- (void)setEntriesFromDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)dictionary;- (void)setObject:(M13GenericType(ObjectType, id))object forKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))aKey atIndex:(NSUInteger)index;- (void)setEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry atIndex:(NSUInteger)index;- (void)setEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary atIndex:(NSUInteger)index;- (void)setEntriesFromDictionary:(NSDictionary M13Generics(KeyType, ObjectType) *)dictionary atIndex:(NSUInteger)index;//移除键值对的方法- (void)removeObjectForKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)removeObjectsForKeys:(NSArray M13Generics(KeyType) *)keys;- (void)removeAllObjects;- (void)removeAllEntries;- (void)removeLastEntry;- (void)removeEntryWithObject:(M13GenericType(ObjectType, id))object;- (void)removeEntryWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)removeEntryWithObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)removeEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;- (void)removeEntryWithObject:(M13GenericType(ObjectType, id))object inRange:(NSRange)range;- (void)removeEntryWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key inRange:(NSRange)range;- (void)removeEntryWithObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key inRange:(NSRange)ramge;- (void)removeEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry inRange:(NSRange)range;- (void)removeEntryAtIndex:(NSUInteger)index;- (void)removeEntriesAtIndices:(NSIndexSet *)indices;- (void)removeEntryWithObjectIdenticalTo:(M13GenericType(ObjectType, id))anObject;- (void)removeEntryWithObjectIdenticalTo:(M13GenericType(ObjectType, id))anObject inRange:(NSRange)range;- (void)removeEntriesWithObjectsInArray:(NSArray M13Generics(ObjectType) *)array;- (void)removeEntriesWithKeysInArray:(NSArray M13Generics(KeyType) *)array;- (void)removeEntriesInRange:(NSRange)range;//替换键值对的方法- (void)replaceEntryAtIndex:(NSInteger)index withObject:(M13GenericType(ObjectType, id))object pairedWithKey:(M13GenericType(KeyType, id&lt;NSCopying&gt;))key;- (void)replaceEntryAtIndex:(NSUInteger)index withEntry:(NSDictionary M13Generics(KeyType, ObjectType) *)entry;- (void)replaceEntriesAtIndices:(NSIndexSet *)indices withObjects:(NSArray M13Generics(ObjectType) *)objects pairedWithKeys:(NSArray M13Generics(KeyType) *)keys;- (void)replaceEntriesAtIndices:(NSIndexSet *)indices withEntries:(NSArray M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *)orderedEntries;- (void)replaceEntriesAtIndices:(NSIndexSet *)indiceswithEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;- (void)replaceEntriesInRange:(NSRange)range withObjectsFromArray:(NSArray M13Generics(ObjectType) *)objects pairedWithKeysFromArray:(NSArray M13Generics(KeyType) *)keys inRange:(NSRange)range2;- (void)replaceEntriesInRange:(NSRange)range withEntriesFrom:(NSArray M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *)orderedEntries inRange:(NSRange)range2;- (void)replaceEntriesInRange:(NSRange)rangewithEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)dictionary inRange:(NSRange)range2;- (void)replaceEntriesInRange:(NSRange)range withObjectsFromArray:(NSArray M13Generics(ObjectType) *)objects pairedWithKeysFromArray:(NSArray M13Generics(KeyType) *)keys;- (void)replaceEntriesInRange:(NSRange)range withEntriesFrom:(NSArray M13Generics(NSDictionary&lt;KeyType, ObjectType&gt; *) *)orderedEntries;- (void)replaceEntriesInRange:(NSRange)rangewithEntriesFromOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)dictionary;- (void)setEntriesToObjects:(NSArray M13Generics(ObjectType) *)objects pairedWithKeys:(NSArray M13Generics(KeyType) *)keys;- (void)setEntriesToOrderedDictionary:(M13OrderedDictionary M13Generics(KeyType, ObjectType) *)orderedDictionary;//进行元素筛选- (void)filterEntriesUsingPredicateForObjects:(NSPredicate *)predicate;//进行元素交换- (void)exchangeEntryAtIndex:(NSUInteger)idx1 withEntryAtIndex:(NSUInteger)idx2;//进行元素排序- (void)sortEntriesByObjectUsingDescriptors:(NSArray *)descriptors;- (void)sortEntriesByKeysUsingDescriptors:(NSArray *)descriptors;- (void)sortEntriesByObjectUsingComparator:(NSComparator)cmptr;- (void)sortEntriesByKeysUsingComparator:(NSComparator)cmptr;- (void)sortEntriesByObjectWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr;- (void)sortEntriesByKeysWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr;- (void)sortEntriesByObjectUsingFunction:(NSInteger (*)(M13GenericType(ObjectType, id), M13GenericType(ObjectType, id), void * M13__NULLABLE))compare context:(M13_NULLABLE void *)context;- (void)sortEntriesByKeysUsingFunction:(NSInteger (*)(M13GenericType(KeyType, id&lt;NSCopying&gt;), M13GenericType(KeyType, id&lt;NSCopying&gt;), void * M13__NULLABLE))compare context:(M13_NULLABLE void *)context;- (void)sortEntriesByObjectUsingSelector:(SEL)comparator;- (void)sortEntriesByKeysUsingSelector:(SEL)comparator; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS运行时函数替换框架——RSSwizzle","slug":"231iOS运行时函数替换框架——RSSwizzle","date":"2016-06-29T16:00:00.000Z","updated":"2021-07-09T03:02:36.212Z","comments":true,"path":"2016/06/30/231iOS运行时函数替换框架——RSSwizzle/","link":"","permalink":"http://huishao.cc/2016/06/30/231iOS运行时函数替换框架——RSSwizzle/","excerpt":"","text":"iOS运行时函数替换框架——RSSwizzle一、引言Objective-C是的运行时特性在iOS开发中应用广泛，通过runtime方法，开发者可以在运行时动态为类添加方法，修改类的方法，系统的class\\_addMethod()方法和class\\_replaceMethod()方法可以十分简单的添加和修改方法，然而，直接使用这两个函数有时并不安全，其主要问题有如下几点： 1.在进行动态函数修改的时候，有可能其他线程也在做同样的操作。 2.在继承中，子类执行父类替换的方法会出现问题。 3.函数的替换必须依靠_cmd参数。 4.可能会出现命名冲突。 有关Objective-C运行时的相关内容可在如下博客中查看：http://my.oschina.net/u/2340880/blog/489072。 RSSwizzle框架可以解决上面所有问题，在要求比较高的项目中如果需要使用到运行时函数替换的需求，可以直接使用这个框架。git地址如下： https://github.com/rabovik/RSSwizzle。 二、RSSwizzle的使用RSSwizzle中提供了两种使用方式，一种是通过调用类方法来实现函数的替换，另一种是使用RSSwizzle定义的宏来进行函数的替换。使用类方法的方式示例如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //替换类方法 [RSSwizzle swizzleClassMethod:NSSelectorFromString(@\"log\") inClass:NSClassFromString(@\"ViewController\") newImpFactory:^id(RSSwizzleInfo *swizzleInfo) &#123; return ^(__unsafe_unretained id self)&#123; NSLog(@\"Class log Swizzle\"); &#125;; &#125;];&#125;+(void)log&#123; NSLog(@\"Class log\");&#125; 这个函数用来替换类方法，第1个参数为要替换的函数选择器，第2个参数为要替换此函数的类，block参数中需要返回一个方法函数，这个函数为要替换成的函数，要和原函数类型相同。在类中的函数默认都会有一个名为self的id参数。进行实例函数的替换实例代码如下： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //进行实例方法的替换 /* 第一个参数为要替换的函数，第二个参数为要替换方法的类，第三个的block中返回替换后的方法，第四个参数设置替换模式，最后一个参数是此替换操作的标识符 */ [RSSwizzle swizzleInstanceMethod:NSSelectorFromString(@\"touchesBegan:withEvent:\") inClass:NSClassFromString(@\"ViewController\") newImpFactory:^id(RSSwizzleInfo *swizzleInfo) &#123; return ^(__unsafe_unretained id self,NSSet* touches,UIEvent* event)&#123; NSLog(@\"text Swizzle\"); &#125;; &#125; mode:RSSwizzleModeAlways key:@\"key\"];&#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@\"test\"); [ViewController log];&#125; 替换模式的枚举RSSwizzleMode意义如下： 12345678typedef NS_ENUM(NSUInteger, RSSwizzleMode) &#123; //任何情况下 始终执行替换操作 RSSwizzleModeAlways = 0, //相同key标识的替换操作只会被执行一次 RSSwizzleModeOncePerClass = 1, //相同key标识的替换操作在子类父类中只会被执行一次 RSSwizzleModeOncePerClassAndSuperclasses = 2&#125;; 使用宏的模式进行方法替换操作的代码更加简单，示例如下： 123456789101112131415//进行类方法的替换/* 第1个参数为要替换方法的类 第二个参数为要替换的方法选择器 第三个参数为方法的返回值类型，第四个参数为方法的参数列表，最后一个参数为要替换的方法代码块 */RSSwizzleClassMethod(NSClassFromString(@\"ViewController\"), NSSelectorFromString(@\"log\"), RSSWReturnType(void), RSSWArguments(), RSSWReplacement( &#123; //先执行原始方法 RSSWCallOriginal(); NSLog(@\"Class log Swillze\"); &#125;));//进行实例方法的替换/* 第一个参数为要替换方法的类，第二个参数为要替换的方法选择器，第三个参数为返回值类型，第四个参数为参数列表 第五个参数为要替换的代码块，第六个参数为执行模式，最后一个参数为key值标识。 */RSSwizzleInstanceMethod(NSClassFromString(@\"ViewController\"),NSSelectorFromString(@\"touchesBegan:withEvent:\"), RSSWReturnType(void), RSSWArguments(NSSet* touchs,UIEvent * event), RSSWReplacement(&#123; NSLog(@\"test Swizzle\");&#125;), RSSwizzleModeAlways, @\"key\"); 在宏内，可以直接调用RSSWCallOriginal()来执行替换前的原始函数，十分方便。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS中支持HTML文本的标签控件——MDHTMLLabel","slug":"230iOS中支持HTML文本的标签控件——MDHTMLLabel","date":"2016-06-29T16:00:00.000Z","updated":"2021-07-09T03:01:52.534Z","comments":true,"path":"2016/06/30/230iOS中支持HTML文本的标签控件——MDHTMLLabel/","link":"","permalink":"http://huishao.cc/2016/06/30/230iOS中支持HTML文本的标签控件——MDHTMLLabel/","excerpt":"","text":"iOS中支持HTML文本的标签控件——MDHTMLLabel一、引言在iOS开发中对HTML的处理很多时候除了使用WebView外，还需要原生的控件对其进行渲染，例如将HTML字符串渲染为图文混排的View视图。Git上有很多轻量级的HTML渲染框架，列举一些如下： RTLabel：基于UIView的HTML文本渲染控件，git地址：https://github.com/honcheng/RTLabel。 RCLabel：与RTLabel思路相同，基于RCLabel之上，也是UIView的子类，支持了对HTML中的本地图片标签进行渲染。git地址：https://github.com/Janak-Nirmal/RichContentLabel。 MDHTMLLabel：与RTLabel和RCLabel不同的是，其是UILabel的子类，更加轻量级，不能支持图片标签。git地址：https://github.com/mattdonnelly/MDHTMLLabel。 关于RCLabel对图片便签的支持，其只能支持本地的图片，不能支持远程URL图片链接，这在开发中将十分局限，以前我曾加RCLabel做了改造，加了支持远程图片URL的方法，我把它集成在了一个基础框架中，需要的伙伴可以参考下，git地址：[https://github.com/ZYHshao/YHBaseFoundationTest](https://github.com/ZYHshao/YHBaseFoundationTest)。配套的讲解博客地址如下：[http://my.oschina.net/u/2340880/blog/499311](http://my.oschina.net/u/2340880/blog/499311)。 本篇博客主要讨论MDHTMLLabel的使用。 二、MDHTMLLabel的创建与设置MDHTMLLabel框架十分小巧，其中只有两个文件，总计2000余行代码。通过HTML字符串来创建一个MDHTMLLabel控件示例代码如下： 12345NSString * kDemoText = @\"&lt;a href='http://github.com/mattdonnelly/MDHTMLLabel'&gt;MDHTMLLabel&lt;/a&gt; is a lightweight, easy to use replacement for &lt;b&gt;UILabel&lt;/b&gt; which allows you to fully &lt;font face='Didot-Italic' size='19'&gt;customize&lt;/font&gt; the appearence of the text using HTML (with a few added features thanks to &lt;b&gt;CoreText&lt;/b&gt;), as well letting you handle whenever a user taps or holds down on link and automatically detects ones not wrapped in anchor tags/&gt;\";MDHTMLLabel *htmlLabel = [[MDHTMLLabel alloc] initWithFrame:self.view.frame];htmlLabel.numberOfLines = 0;htmlLabel.htmlText = kDemoText;[self.view addSubview:htmlLabel]; 效果如下图所示： MDHTMLLabel中可以设置的一些属性解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940//设置超链接文字的属性字典 和设置AttributeString方法一致@property (nonatomic, strong) NSDictionary *linkAttributes;//设置超链接文字激活时的属性字典@property (nonatomic, strong) NSDictionary *activeLinkAttributes;//设置超链接非激活时的属性字典@property (nonatomic, strong) NSDictionary *inactiveLinkAttributes;//设置超链接文字触发长按事件的最小按下时间@property (nonatomic, assign) NSTimeInterval minimumPressDuration;//设置label文件阴影的模糊半径@property (nonatomic, assign) CGFloat shadowRadius;//设置label在高亮状态下的文字模糊半径 注：非高亮状态的由原生UILabel的属性设置@property (nonatomic, assign) CGFloat highlightedShadowRadius;//设置label在高亮状态下的文字阴影偏移 注：非高亮状态的由原生UILabel的属性设置@property (nonatomic, assign) CGSize highlightedShadowOffset;//设置在label高亮状态下的文字阴影颜色 注：非高亮状态的由原生UILabel的属性设置@property (nonatomic, strong) UIColor *highlightedShadowColor;//设置首行文字的缩进距离@property (nonatomic, assign) CGFloat firstLineIndent;//设置文字的行间距@property (nonatomic, assign) CGFloat leading;//设置行高的倍数@property (nonatomic, assign) CGFloat lineHeightMultiple;//设置文字内容的边距@property (nonatomic, assign) UIEdgeInsets textInsets;//设置文字垂直方向的对其模式 默认为居中对其 MDHTMLLabelVerticalAlignment枚举意义如下:/*typedef NS_ENUM(NSUInteger, MDHTMLLabelVerticalAlignment) &#123; MDHTMLLabelVerticalAlignmentCenter = 0, //居中对其 MDHTMLLabelVerticalAlignmentTop = 1, //顶部对其 MDHTMLLabelVerticalAlignmentBottom = 2, //底部对其&#125;;*/@property (nonatomic, assign) MDHTMLLabelVerticalAlignment verticalAlignment;//设置文字的截断模式@property (nonatomic, strong) NSString *truncationTokenString;//根据内容获取控件尺寸+ (CGFloat)sizeThatFitsHTMLString:(NSString *)htmlString withFont:(UIFont *)font constraints:(CGSize)size limitedToNumberOfLines:(NSUInteger)numberOfLines; 关于HTML数据中的超链接的相应，MDHTMLLabel是通过代理回调的方式处理的，如下： 1234567@protocol MDHTMLLabelDelegate &lt;NSObject&gt;@optional//点击超链接的时候触发的方法- (void)HTMLLabel:(MDHTMLLabel *)label didSelectLinkWithURL:(NSURL*)URL;//长按超链接时触发的方法- (void)HTMLLabel:(MDHTMLLabel *)label didHoldLinkWithURL:(NSURL*)URL;@end 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"iOS好用的第三方侧边栏控件——MMDrawerController","slug":"229iOS好用的第三方侧边栏控件——MMDrawerController","date":"2016-06-28T16:00:00.000Z","updated":"2021-07-09T03:01:03.801Z","comments":true,"path":"2016/06/29/229iOS好用的第三方侧边栏控件——MMDrawerController/","link":"","permalink":"http://huishao.cc/2016/06/29/229iOS好用的第三方侧边栏控件——MMDrawerController/","excerpt":"","text":"iOS好用的第三方侧边栏控件——MMDrawerController一、引言很多应用程序都采用了侧边栏这样的界面结构，MMDrawerController是一个轻量级的侧边栏抽屉控件，其支持左侧抽屉和右侧抽屉，可以很好的支持导航控制器，并且支持开发者对手势和动画进行自定义。MMDrawerController的git地址如下： https://github.com/mutualmobile/MMDrawerController。 二、MMDrawerController的使用及相关设置MMDrawerController的使用十分简单，只需将中心视图控制器和左边栏视图控制器传入初始化方法即可完成MMDrawerController的创建。示例代码如下： 12345678UIViewController * leftViewController = [[UIViewController alloc]init];leftViewController.view.backgroundColor = [UIColor redColor];UIViewController * rightViewController = [[UIViewController alloc]init];rightViewController.view.backgroundColor = [UIColor greenColor];ViewController * centerViewController = [[ViewController alloc]init];centerViewController.view.backgroundColor = [UIColor blueColor];//创建控件MMDrawerController * rootController = [[MMDrawerController alloc]initWithCenterViewController:centerViewController leftDrawerViewController:leftViewController rightDrawerViewController:rightViewController]; MMDrawerController中还提供了两个方法供开发者创建单侧边栏，如下： 1234//只创建带左侧边栏的视图控制器-(id)initWithCenterViewController:(UIViewController *)centerViewController leftDrawerViewController:(UIViewController *)leftDrawerViewController;//只创建带右侧边栏的视图控制器-(id)initWithCenterViewController:(UIViewController *)centerViewController rightDrawerViewController:(UIViewController *)rightDrawerViewController; MMDrawerController中也提供了许多属性和方法供开发者进行自定义的设置，其中可用属性解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//设置左侧边栏的最大宽度 默认280@property (nonatomic, assign) CGFloat maximumLeftDrawerWidth;//设置右侧边栏的最大宽度 默认280@property (nonatomic, assign) CGFloat maximumRightDrawerWidth;//这个是一个只读属性，用于获取可见的左侧边栏宽度@property (nonatomic, assign, readonly) CGFloat visibleLeftDrawerWidth;//这个是一个只读属性，用于获取可见的右侧边栏宽度@property (nonatomic, assign, readonly) CGFloat visibleRightDrawerWidth;//动画速度，这个参数的意义是每秒移动多少单位 默认为800/s@property (nonatomic, assign) CGFloat animationVelocity;//设置是否允许回弹效果，如果设置为YES，当使用手势进行侧边栏的开启时会出现回弹效果@property (nonatomic, assign) BOOL shouldStretchDrawer;//获取当前开启的侧边栏类型，MMDrawerSide枚举如下：/*typedef NS_ENUM(NSInteger,MMDrawerSide)&#123; MMDrawerSideNone = 0,//无侧边栏 MMDrawerSideLeft, //左侧边栏 MMDrawerSideRight, //右侧边栏&#125;;*/@property (nonatomic, assign, readonly) MMDrawerSide openSide;//开启侧边栏的手势模式 MMOpenDrawerGestureMode枚举意义如下/*typedef NS_OPTIONS(NSInteger, MMOpenDrawerGestureMode) &#123; //没有手势 此模式为默认模式 MMOpenDrawerGestureModeNone = 0, //在导航栏上拖动时可以打开侧边栏 MMOpenDrawerGestureModePanningNavigationBar = 1 &lt;&lt; 1, //在中心视图控制器的视图上拖动时可以打开侧边栏 MMOpenDrawerGestureModePanningCenterView = 1 &lt;&lt; 2, //在中心视图控制器的视图边缘20个单位内拖动时可以打开侧边栏 MMOpenDrawerGestureModeBezelPanningCenterView = 1 &lt;&lt; 3, //自定义手势 需配合自定义手势的方法使用 MMOpenDrawerGestureModeCustom = 1 &lt;&lt; 4, //所有模式兼容 MMOpenDrawerGestureModeAll = MMOpenDrawerGestureModePanningNavigationBar | MMOpenDrawerGestureModePanningCenterView | MMOpenDrawerGestureModeBezelPanningCenterView | MMOpenDrawerGestureModeCustom,&#125;;*/@property (nonatomic, assign) MMOpenDrawerGestureMode openDrawerGestureModeMask;//关闭侧边栏的手势模式 MMCloseDrawerGestureMode枚举的意义如下/*typedef NS_OPTIONS(NSInteger, MMCloseDrawerGestureMode) &#123; //没有关闭手势 MMCloseDrawerGestureModeNone = 0, //在导航栏上拖动时可以关闭侧边栏 MMCloseDrawerGestureModePanningNavigationBar = 1 &lt;&lt; 1, //在中心视图控制器上推动时可以关闭侧边栏 MMCloseDrawerGestureModePanningCenterView = 1 &lt;&lt; 2, //在中心视图控制器边缘20单位内拖动是可以关闭侧边栏 MMCloseDrawerGestureModeBezelPanningCenterView = 1 &lt;&lt; 3, //点击导航栏时可以关闭侧边栏 MMCloseDrawerGestureModeTapNavigationBar = 1 &lt;&lt; 4, //点击中心视图控制器视图时可以关闭侧边栏 MMCloseDrawerGestureModeTapCenterView = 1 &lt;&lt; 5, //在侧边栏视图上拖动时可以关闭侧边栏 MMCloseDrawerGestureModePanningDrawerView = 1 &lt;&lt; 6, //自定义关闭手势，需要和自定义手势的方法结合使用 MMCloseDrawerGestureModeCustom = 1 &lt;&lt; 7, //所有模式兼容 MMCloseDrawerGestureModeAll = MMCloseDrawerGestureModePanningNavigationBar | MMCloseDrawerGestureModePanningCenterView | MMCloseDrawerGestureModeBezelPanningCenterView | MMCloseDrawerGestureModeTapNavigationBar | MMCloseDrawerGestureModeTapCenterView | MMCloseDrawerGestureModePanningDrawerView | MMCloseDrawerGestureModeCustom,&#125;;*/@property (nonatomic, assign) MMCloseDrawerGestureMode closeDrawerGestureModeMask;//设置侧边栏显示时的中心视图控制器的用户交互规则 MMDrawerOpenCenterInteractionMode枚举意义如下/*typedef NS_ENUM(NSInteger, MMDrawerOpenCenterInteractionMode) &#123; //中心视图控制器不能进行用户交互 默认为此枚举 MMDrawerOpenCenterInteractionModeNone, //中心视图控制器完全可以进行用户交互 MMDrawerOpenCenterInteractionModeFull, //中心视图控制器只有导航可以进行用户交互 MMDrawerOpenCenterInteractionModeNavigationBarOnly,&#125;;*/@property (nonatomic, assign) MMDrawerOpenCenterInteractionMode centerHiddenInteractionMode;//设置是否显示阴影效果@property (nonatomic, assign) BOOL showsShadow;//设置是否显示状态栏的自定义视图 只有在iOS7之后可用@property (nonatomic, assign) BOOL showsStatusBarBackgroundView;//设置状态栏视图颜色 只有在iOS7之后可用@property (nonatomic, strong) UIColor * statusBarViewBackgroundColor; 相关方法解析如下： 123456789101112131415161718192021222324//切换侧边栏的状态，drawerSide参数为要切换的侧边栏，animated设置是否有动画效果，completion会在切换完成后执行//注意：如果在切换一个关着的侧边栏时，如果另一个侧边栏正在开启状态，则此方法不会有任何效果-(void)toggleDrawerSide:(MMDrawerSide)drawerSide animated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//关闭侧边栏-(void)closeDrawerAnimated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//开启侧边栏-(void)openDrawerSide:(MMDrawerSide)drawerSide animated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//更换中心视图控制器-(void)setCenterViewController:(UIViewController *)centerViewController withCloseAnimation:(BOOL)closeAnimated completion:(void(^)(BOOL finished))completion;-(void)setCenterViewController:(UIViewController *)newCenterViewController withFullCloseAnimation:(BOOL)fullCloseAnimated completion:(void(^)(BOOL finished))completion;//设置左侧边栏最大宽度-(void)setMaximumLeftDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//设置右侧边栏最大宽度-(void)setMaximumRightDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void(^)(BOOL finished))completion;//进行侧边栏的预览操作 默认预览距离为40个单位-(void)bouncePreviewForDrawerSide:(MMDrawerSide)drawerSide completion:(void(^)(BOOL finished))completion;//进行侧边栏的预览操作 可以设置预览距离-(void)bouncePreviewForDrawerSide:(MMDrawerSide)drawerSide distance:(CGFloat)distance completion:(void(^)(BOOL finished))completion;//这个方法用于进行视图侧边栏视图出现动画的自定义-(void)setDrawerVisualStateBlock:(void(^)(MMDrawerController * drawerController, MMDrawerSide drawerSide, CGFloat percentVisible))drawerVisualStateBlock;//这个方法用于设置当一个手势触发完成后的回调-(void)setGestureCompletionBlock:(void(^)(MMDrawerController * drawerController, UIGestureRecognizer * gesture))gestureCompletionBlock;//这个方法用于定义自定义的手势操作 要将开启侧边栏与关闭侧边栏的模式设置为MMOpenDrawerGestureModeCustom和MMCloseDrawerGestureModeCustom才有效-(void)setGestureShouldRecognizeTouchBlock:(BOOL(^)(MMDrawerController * drawerController, UIGestureRecognizer * gesture, UITouch * touch))gestureShouldRecognizeTouchBlock; 对于自定义过渡动画的方法： -(void)setDrawerVisualStateBlock:(void(^)(MMDrawerController * drawerController, MMDrawerSide drawerSide, CGFloat percentVisible))drawerVisualStateBlock; 回调block中会传递进来侧边栏显示完成的百分比，并且在侧边栏出现过程中，这个回调block会被不停刷新调用，开发者可以直接在其中对要过渡的属性进行设置，例如透明度的渐变动画，示例如下： 123456789101112//进行自定义动画 [rootController setDrawerVisualStateBlock:^(MMDrawerController *drawerController, MMDrawerSide drawerSide, CGFloat percentVisible) &#123; UIViewController * sideDrawerViewController; if(drawerSide == MMDrawerSideLeft)&#123; sideDrawerViewController = drawerController.leftDrawerViewController; &#125; else if(drawerSide == MMDrawerSideRight)&#123; sideDrawerViewController = drawerController.rightDrawerViewController; &#125; [sideDrawerViewController.view setAlpha:percentVisible]; &#125;]; 三、关于MMDrawerController的子类开发者如果有特殊的需求，也可以通过继承MMDrawerController来实现自己的侧边栏控制器类，MMDrawerController框架中提供了一个扩展，在编写MMDrawerController时，开发者可以导入MMDrawerController+Subclass.h文件，这个文件中提供了许多控制器的监听方法供开发者重写，解析如下： 123456789101112131415//出现单击手势会回调的方法 如果要重写 必须调用父类的此方法-(void)tapGestureCallback:(UITapGestureRecognizer *)tapGesture __attribute((objc_requires_super));//出现滑动手势会回调的方法 如果要重写 必须调用父类的此方法-(void)panGestureCallback:(UIPanGestureRecognizer *)panGesture __attribute((objc_requires_super));//决定是否响应某个手势-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch __attribute((objc_requires_super));//准备展示侧边栏时调用的方法-(void)prepareToPresentDrawer:(MMDrawerSide)drawer animated:(BOOL)animated __attribute((objc_requires_super));//关闭侧边栏时调用的方法-(void)closeDrawerAnimated:(BOOL)animated velocity:(CGFloat)velocity animationOptions:(UIViewAnimationOptions)options completion:(void (^)(BOOL))completion __attribute((objc_requires_super));//打开侧边栏时调用的方法-(void)openDrawerSide:(MMDrawerSide)drawerSide animated:(BOOL)animated velocity:(CGFloat)velocity animationOptions:(UIViewAnimationOptions)options completion:(void (^)(BOOL))completion __attribute((objc_requires_super));//设备旋转方向时调用的方法-(void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration __attribute((objc_requires_super));-(void)willAnimateRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration __attribute((objc_requires_super)); 四、一些辅助类MMDrawerController框架中还提供了一个MMDrawerBarButtonItem的辅助类，这个类可以创建三道杠的菜单按钮。其中方法如下： 123456//初始化方法-(id)initWithTarget:(id)target action:(SEL)action;//获取某个状态下的按钮颜色-(UIColor *)menuButtonColorForState:(UIControlState)state __attribute__((deprecated(\"Use tintColor instead\")));//设置某个状态的按钮颜色-(void)setMenuButtonColor:(UIColor *)color forState:(UIControlState)state __attribute__((deprecated(\"Use tintColor instead\"))); MMDrawerBarButtonItem继承自UIBarButtonItem，可以直接在导航栏上使用。 前面有提到，侧边栏的展现动画开发者可以进行自定义，为了使开发者在使用MMDrawerController时更加方便，MMDrawerController框架中还提供了一个动画辅助类MMDrawerVisualState，这个类中封装好了许多动画效果，开发者可以直接使用，示例如下： 12//使用提供的动画模板[rootController setDrawerVisualStateBlock:[MMDrawerVisualState slideAndScaleVisualStateBlock]]; MMDrawerVisualState中所提供的动画模板列举如下： 12345678//从后向前渐现+(MMDrawerControllerDrawerVisualStateBlock)slideAndScaleVisualStateBlock;//滑动渐现+(MMDrawerControllerDrawerVisualStateBlock)slideVisualStateBlock;//立方动画+(MMDrawerControllerDrawerVisualStateBlock)swingingDoorVisualStateBlock;//视差动画+(MMDrawerControllerDrawerVisualStateBlock)parallaxVisualStateBlockWithParallaxFactor:(CGFloat)parallaxFactor; 五、MMDrawerController无法完成的需求为了确保MMDrawerController库的轻量级，其作者在设计时也做了功能上的取舍权衡，MMDrawerController无法完成以下需求： 1.上边栏与下边栏。 2.同时展示左边栏与又边栏。 3.无法设置显示一个最小的抽屉宽度。 4.不能支持UITabBarController容器。 5.不能在中心视图控制器之上呈现侧边栏视图。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}],"tags":[],"keywords":[{"name":"iOS第三方库","slug":"iOS第三方库","permalink":"http://huishao.cc/categories/iOS第三方库/"}]},{"title":"Swift3.0带来的变化汇总系列三——函数和闭包写法上的微调","slug":"228Swift3.0带来的变化汇总系列三——函数和闭包写法上的微调","date":"2016-06-25T16:00:00.000Z","updated":"2021-07-09T03:00:08.594Z","comments":true,"path":"2016/06/26/228Swift3.0带来的变化汇总系列三——函数和闭包写法上的微调/","link":"","permalink":"http://huishao.cc/2016/06/26/228Swift3.0带来的变化汇总系列三——函数和闭包写法上的微调/","excerpt":"","text":"Swift3.0带来的变化汇总系列三——函数写法上的微调一、函数方面Swift3.0相比Swift2.2的版本在API上做了大量的修改，代码风格也更加统一。在函数方面，Swift3.0中做的最大修改是修改了内部名称与外部名称的默认规则。 在Swift2.2中，函数参数列表的第一个参数如果开发者不手动设置外部名称，默认是匿名的，除第一个参数以外的其他参数，开发者如果不设置外部名称，默认外部名称是和内部名称相同的，因此在调用函数时，代码常常是这样的： 1234567//多参数函数Swift2.2中 第一个参数默认匿名，其他参数默认内部命名与外部命名相同func myFunc5(param1: Int,param2: Int,param3: Int) &#123; //这里使用的param1，param2，param3是参数的内部命名 param1+param2+param3&#125;//调用函数的参数列表中使用的param2和param3为外部命名myFunc5(1, param2: 2, param3: 3) Swift3.0中将这一规则修改为：如果开发者不设置函数中参数的外部名称，则全部参数都默认外部名称和内部名称相同，上面相同的代码，在Swift3.0的环境下是下面这样的： 12345678//多参数函数 默认内部命名与外部命名相同func myFunc5(param1: Int,param2: Int,param3: Int) &#123; //这里使用的param1，param2，param3是参数的内部命名 param1+param2+param3&#125;//调用函数的参数列表中使用的param1、param2和param3为外部命名//swift3.0myFunc5(param1: 1, param2: 2, param3: 3) Swift3.0在函数参数名方面的微调使得函数的参数名规则更加统一也更加符合Swift语言的风格。 在函数方面，Swift3.0中做的另一项更改是关于inout参数的声明方式，修改了inout关键字的声明位置，Swift2.2与Swift3.0版本比如如下： 123456789//在函数内部修改参数变量的值//swift2.2func myFunc12(inout param:Int)&#123; param+=1&#125;//swift3.0func myFunc12( param:inout Int)&#123; param+=1&#125; 有关Swift中函数的更多内容，可以在如下博客连接中找到： http://my.oschina.net/u/2340880/blog/674616 二、闭包方面在闭包方面，Swift3.0版本中只对某些修饰符的位置做了修改。示例如下： 1234567891011121314151617//逃逸闭包//swift2.2//func myFunc(@noescape closure:(Int,Int)-&gt;Bool)&#123;// //&#125;//swift3.0func myFunc( closure:@noescape(Int,Int)-&gt;Bool)&#123;&#125;//自动闭包//swift2.2//func myFunc2(@autoclosure(escaping) closure:()-&gt;Bool) &#123;// //&#125;func myFunc2( closure:@autoclosure(escaping)()-&gt;Bool) &#123; &#125; 关于Swift中闭包的更多内容，可以在如下博客链接中找到： http://my.oschina.net/u/2340880/blog/675233。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"iOS中WebKit框架应用与解析","slug":"227iOS中WebKit框架应用与解析","date":"2016-06-23T16:00:00.000Z","updated":"2021-07-09T02:59:16.125Z","comments":true,"path":"2016/06/24/227iOS中WebKit框架应用与解析/","link":"","permalink":"http://huishao.cc/2016/06/24/227iOS中WebKit框架应用与解析/","excerpt":"","text":"iOS中WebKit框架应用与解析一、引言在iOS8之前，在应用中嵌入网页通常需要使用UIWebView这样一个类，这个类通过URL或者HTML文件来加载网页视图，功能十分有限，只能作为辅助嵌入原生应用程序中。虽然UIWebView也可以做原生与JavaScript交互的相关处理，然而也有很大的局限性，JavaScript要调用原生方法通常需要约定好协议之后通过Request来传递。WebKit框架中添加了一些原生与JavaScript交互的方法，增强了网页视图与原生的交互能力。并且WebKit框架中采用导航堆栈的模型来管理网页的跳转，开发者也可以更加容易的控制和管理网页的渲染。关于UIWebView的相关使用，在前面的博客中有详细介绍，地址如下。 UIWebView的使用详解：http://my.oschina.net/u/2340880/blog/469916。 二、WebKit框架概览WebKit框架中涉及的类很多，框架的设计十分面向对象和模块化，开发者在使用时可以轻松的写出结构清晰的代码。在进行使用前，我们首先应该清楚整个框架的结构和开发思路，下面一张脑图中基本列出了WebKit框架中所涉及到的所有重要的类以及他们之间的相互关系： 如上图所示，WebKit框架中最核心的类应该属于WKWebView了，这个类专门用来渲染网页视图，其他类和协议都将基于它和服务于它。 WKWebView：网页的渲染与展示，通过WKWebViewConfiguration可以进行配置。 WKWebViewConfiguration：这个类专门用来配置WKWebView。 WKPreference:这个类用来进行M相关设置。 WKProcessPool：这个类用来配置进程池，与网页视图的资源共享有关。 WKUserContentController：这个类主要用来做native与JavaScript的交互管理。 WKUserScript：用于进行JavaScript注入。 WKScriptMessageHandler：这个类专门用来处理JavaScript调用native的方法。 WKNavigationDelegate：网页跳转间的导航管理协议，这个协议可以监听网页的活动。 WKNavigationAction：网页某个活动的示例化对象。 WKUIDelegate：用于交互处理JavaScript中的一些弹出框。 WKBackForwardList：堆栈管理的网页列表。 WKBackForwardListItem：每个网页节点对象。 三、使用WKWebViewConfiguration对WebView进行配置使用下面的代码可以创建一个WKWebView视图，创建WebView视图时，需要使用WKWebViewConfiguration来进行配置： 1234WKWebView * WK;WKWebViewConfiguration * config = [[WKWebViewConfiguration alloc]init];WK = [[WKWebView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height-40) configuration:config];[WK loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@\"http://www.baidu.com\"]]]; WKWebViewConfiguration中可以进行配置的方法和属性如下： 123//设置进程池WKProcessPool * pool = [[WKProcessPool alloc]init];config.processPool = pool; WKProcessPool类中没有暴露任何属性和方法，配置为同一个进程池的WebView会共享数据，例如Cookie、用户凭证等，开发者可以通过编写管理类来分配不同维度的WebView在不同进程池中。 123456789//进行偏好设置WKPreferences * preference = [[WKPreferences alloc]init];//最小字体大小 当将javaScriptEnabled属性设置为NO时，可以看到明显的效果preference.minimumFontSize = 0;//设置是否支持javaScript 默认是支持的preference.javaScriptEnabled = YES;//设置是否允许不经过用户交互由javaScript自动打开窗口preference.javaScriptCanOpenWindowsAutomatically = YES;config.preferences = preference; WKPerference实例为WebView提供一个偏好设置。 123456789//设置内容交互控制器 用于处理JavaScript与native交互WKUserContentController * userController = [[WKUserContentController alloc]init];//设置处理代理并且注册要被js调用的方法名称[userController addScriptMessageHandler:self name:@\"name\"];//js注入，注入一个测试方法。NSString *javaScriptSource = @\"function userFunc()&#123;window.webkit.messageHandlers.name.postMessage( &#123;\\\"name\\\":\\\"HS\\\"&#125;)&#125;\";WKUserScript *userScript = [[WKUserScript alloc] initWithSource:javaScriptSource injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:YES];// forMainFrameOnly:NO(全局窗口)，yes（只限主窗口）[userController addUserScript:userScript];config.userContentController = userController; WKUserContentController专门用来管理native与JavaScript的交互行为，addScriptMessageHandler:name:方法来注册要被js调用的方法名称，之后再JavaScript中使用window.webkit.messageHandlers.name.postMessage()方法来像native发送消息，支持OC中字典，数组，NSNumber等原生数据类型，JavaScript代码中的name要和上面注册的相同。在native代理的回调方法中，会获取到JavaScript传递进来的消息，如下： 123-(void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123; //这里可以获取到JavaScript传递进来的消息&#125; WKScriptMessage类是JavaScript传递的对象实例，其中属性如下： 12345678//传递的消息主体@property (nonatomic, readonly, copy) id body;//传递消息的WebView@property (nullable, nonatomic, readonly, weak) WKWebView *webView;//传递消息的WebView当前页面对象@property (nonatomic, readonly, copy) WKFrameInfo *frameInfo;//消息名称@property (nonatomic, readonly, copy) NSString *name; WKUserContentController实例的addUserScript:用于注入JavaScript代码，后面会专门介绍。 12//设置数据存储storeconfig.websiteDataStore = [WKWebsiteDataStore defaultDataStore]; WebKit框架采用其本身的缓存框架，WKWebsiteDataStore类用来处理数据的存储，其中属性和方法如下： 12345678910@interface WKWebsiteDataStore : NSObject//获取默认的存储器 此存储器为持久性的会被写入磁盘+ (WKWebsiteDataStore *)defaultDataStore;//获取一个临时的存储器+ (WKWebsiteDataStore *)nonPersistentDataStore;//存储器是否是临时的@property (nonatomic, readonly, getter=isPersistent) BOOL persistent;//所有可以存储的类型+ (NSSet&lt;NSString *&gt; *)allWebsiteDataTypes;@end 12345678910111213141516171819202122//设置是否将网页内容全部加载到内存后再渲染config.suppressesIncrementalRendering = NO;//设置HTML5视频是否允许网页播放 设置为NO则会使用本地播放器config.allowsInlineMediaPlayback = YES;//设置是否允许ariPlay播放config.allowsAirPlayForMediaPlayback = YES;//设置视频是否需要用户手动播放 设置为NO则会允许自动播放config.requiresUserActionForMediaPlayback = NO;//设置是否允许画中画技术 在特定设备上有效config.allowsPictureInPictureMediaPlayback = YES;//设置选择模式 是按字符选择 还是按模块选择/*typedef NS_ENUM(NSInteger, WKSelectionGranularity) &#123; //按模块选择 WKSelectionGranularityDynamic, //按字符选择 WKSelectionGranularityCharacter,&#125; NS_ENUM_AVAILABLE_IOS(8_0);*/config.selectionGranularity = WKSelectionGranularityCharacter;//设置请求的User-Agent信息中应用程序名称 iOS9后可用config.applicationNameForUserAgent = @\"HS\"; 四、WKWebView中的属性和方法解析下面列举了WKWebView中常用的属性和方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//设置导航代理@property (nullable, nonatomic, weak) id &lt;WKNavigationDelegate&gt; navigationDelegate;//设置UI代理@property (nullable, nonatomic, weak) id &lt;WKUIDelegate&gt; UIDelegate;//导航列表@property (nonatomic, readonly, strong) WKBackForwardList *backForwardList;//通过url加载网页视图- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;//通过文件加载网页视图- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL NS_AVAILABLE(10_11, 9_0);//通过HTML字符串加载网页视图- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;//通过data数据加载网页视图- (nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL NS_AVAILABLE(10_11, 9_0);//渲染导航列表中的某个网页节点- (nullable WKNavigation *)goToBackForwardListItem:(WKBackForwardListItem *)item;//网页标题@property (nullable, nonatomic, readonly, copy) NSString *title;//网页的url@property (nullable, nonatomic, readonly, copy) NSURL *URL;//网页是否正在加载中@property (nonatomic, readonly, getter=isLoading) BOOL loading;//加载进度 可以监听这个属性的值配合UIProgressView来设计进度条@property (nonatomic, readonly) double estimatedProgress;//是否全部是安全连接@property (nonatomic, readonly) BOOL hasOnlySecureContent;//证书列表@property (nonatomic, readonly, copy) NSArray *certificateChain;//是否可以回退@property (nonatomic, readonly) BOOL canGoBack;//是否可以前进@property (nonatomic, readonly) BOOL canGoForward;//回退网页- (nullable WKNavigation *)goBack;//前进网页- (nullable WKNavigation *)goForward;//刷新网页- (nullable WKNavigation *)reload;//忽略缓存的刷新- (nullable WKNavigation *)reloadFromOrigin;//停止加载- (void)stopLoading;//执行JavaScript代码- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ __nullable)(__nullable id, NSError * __nullable error))completionHandler;//是否允许右滑返回手势@property (nonatomic) BOOL allowsBackForwardNavigationGestures; WKBackForwardList类为导航管理的网页列表类，其中属性方法意义如下： 1234567891011121314@interface WKBackForwardList : NSObject//当前所在的网页节点@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *currentItem;//前进的一个网页节点@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *forwardItem;//回退的一个网页节点@property (nullable, nonatomic, readonly, strong) WKBackForwardListItem *backItem;//获取某个index的网页节点- (nullable WKBackForwardListItem *)itemAtIndex:(NSInteger)index;//获取回退的节点数组@property (nonatomic, readonly, copy) NSArray&lt;WKBackForwardListItem *&gt; *backList;//获取前进的节点数组@property (nonatomic, readonly, copy) NSArray&lt;WKBackForwardListItem *&gt; *forwardList;@end 在WebKit中，网页节点被抽象成为了WKBackForwardListItem类，这个类中封装的属性如下： 1234567@interface WKBackForwardListItem : NSObject//当前节点的URL@property (readonly, copy) NSURL *URL;//当前节点的标题@property (nullable, readonly, copy) NSString *title;//创建此WebView的初始URL@property (readonly, copy) NSURL *initialURL; 五、关于native与JavaScript交互WebKit中的native与JavaScript的交互主要有4类。 1.JavaScript调用native方法这种方式是由WKUserContentController注册，并在代理方法中实现的。 2.native调用JavaScript方法这种方式通过WKWebView直接调用evaluteJavaScript:completionHandler:方法来实现。 3.将JavaScript代码注入这种方式可以在网页中注入一些自定义的JavaScript代码，也可以注入自定义的方法，再使用evaluteJavaScript:completionHandler:来调用方法。JavaScript代码的注入也是通过WKUserContentController来完成的，使用addUserScript:方法来注入JavaScript，其中需要通过WKUserScript类来生成要注入的对象，这个类使用如下方法来进行实例化： 12345678910111213/*source为要注入的js代码WKUserScriptInjectionTime设置注入的时机forMainFrameOnly参数设置是否只在主页面注入typedef NS_ENUM(NSInteger, WKUserScriptInjectionTime) &#123; //原js代码运行前注入 WKUserScriptInjectionTimeAtDocumentStart, //原js代码运行后注入 WKUserScriptInjectionTimeAtDocumentEnd&#125; NS_ENUM_AVAILABLE(10_10, 8_0);*/- (instancetype)initWithSource:(NSString *)source injectionTime:(WKUserScriptInjectionTime)injectionTime forMainFrameOnly:(BOOL)forMainFrameOnly; 4.通过WKUIDelegate来交互这种方式主要用于相应JavaScript中的弹出框，后面会详细介绍这个协议。 六、WKNavagationDelegate中方法解析WKNavagationDelegate协议重要有两个作用，监听页面渲染流程与控制页面跳转，其中方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*决定是否响应网页的某个动作，例如加载，回退，前进，刷新等，在这个方法中，必须执行decisionHandler()代码块，并将是否允许这个活动执行在block中进行传入*//*WKNavigationAction是网页动作的抽象化，其中封装了许多行为信息，后面会介绍WKNavigationActionPolicy为开发者回执，枚举如下：typedef NS_ENUM(NSInteger, WKNavigationActionPolicy) &#123; //取消此次行为 WKNavigationActionPolicyCancel, //允许此次行为 WKNavigationActionPolicyAllow,&#125; NS_ENUM_AVAILABLE(10_10, 8_0);*/-(void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; decisionHandler(WKNavigationActionPolicyAllow);&#125;//需要响应身份验证时调用 同样在block中需要传入用户身份凭证-(void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler&#123; //用户身份信息 NSURLCredential *newCred = [NSURLCredential credentialWithUser:@\"\" password:@\"\" persistence:NSURLCredentialPersistenceNone]; // 为 challenge 的发送方提供 credential [[challenge sender] useCredential:newCred forAuthenticationChallenge:challenge]; completionHandler(NSURLSessionAuthChallengeUseCredential,newCred);&#125;//接收到数据后是否允许执行渲染/*其中，WKNavigationResponse为请求回执信息WKNavigationResponsePokicy为开发者回执，枚举如下：typedef NS_ENUM(NSInteger, WKNavigationResponsePolicy) &#123; //取消渲染 WKNavigationResponsePolicyCancel, //允许渲染 WKNavigationResponsePolicyAllow,&#125; NS_ENUM_AVAILABLE(10_10, 8_0);*/-(void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler&#123; decisionHandler(WKNavigationResponsePolicyAllow);&#125;//=====================下面这个协议方法用于监听流程=========================================//页面加载启动时调用-(void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation&#123;&#125;//当主机接收到的服务重定向时调用-(void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation&#123;&#125;//内容到达主机时调用-(void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation&#123;&#125;//主页加载完成时调用-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123;&#125;//提交发生错误时调用-(void)webView:(WKWebView *)webView didFailNavigation:(WKNavigation *)navigation withError:(NSError *)error&#123;&#125;//主页数据加载发生错误时调用-(void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(nonnull NSError *)error&#123;&#125;//进程被终止时调用-(void)webViewWebContentProcessDidTerminate:(WKWebView *)webView&#123;&#125; 七、WKUIDelegate协议中方法解析123456789101112131415161718192021222324//创建新的webView时调用的方法-(WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures&#123; return webView;&#125;//关闭webView时调用的方法-(void)webViewDidClose:(WKWebView *)webView&#123;&#125;//下面这些方法是交互JavaScript的方法//JavaScript调用alert方法后回调的方法 message中为alert提示的信息 必须要在其中调用completionHandler()-(void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; NSLog(@\"%@\",message); completionHandler();&#125;//JavaScript调用confirm方法后回调的方法 confirm是js中的确定框，需要在block中把用户选择的情况传递进去-(void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler&#123; NSLog(@\"%@\",message); completionHandler(YES);&#125;//JavaScript调用prompt方法后回调的方法 prompt是js中的输入框 需要在block中把用户输入的信息传入-(void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler&#123; NSLog(@\"%@\",prompt); completionHandler(@\"123\");&#125; 八、扩展首先，在注册要被JavaScript调用的方法时需要设置代理，在不需要时需要将代理移除，WKUserContentController中也提供了移除这个代理的方法，如果不移除，将会造成WebView不能释放。方法如下： 1234//注册一个监听方法- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;//移除一个方法的监听- (void)removeScriptMessageHandlerForName:(NSString *)name; 同样与注入JavaScript对应，也可以将注入的代码移除，方法如下： 1234//注入一个JavaScript抽象对象- (void)addUserScript:(WKUserScript *)userScript;//移除所有注入- (void)removeAllUserScripts; 在上面，经常会见到WKNavagationAction这个类，这个类中封装的是一些页面活动信息，如下： 1234567891011121314151617181920212223242526@interface WKNavigationAction : NSObject//原页面@property (nonatomic, readonly, copy) WKFrameInfo *sourceFrame;//目标页面@property (nullable, nonatomic, readonly, copy) WKFrameInfo *targetFrame;//请求URL@property (nonatomic, readonly, copy) NSURLRequest *request;//活动类型/*typedef NS_ENUM(NSInteger, WKNavigationType) &#123; //链接激活 WKNavigationTypeLinkActivated, //提交操作 WKNavigationTypeFormSubmitted, //前进操作 WKNavigationTypeBackForward, //刷新操作 WKNavigationTypeReload, //重提交操作 例如前进 后退 刷新 WKNavigationTypeFormResubmitted, //其他类型 WKNavigationTypeOther = -1,&#125; NS_ENUM_AVAILABLE(10_10, 8_0);*/@property (nonatomic, readonly) WKNavigationType navigationType;@end 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Swift3.0带来的变化汇总系列二——集合类型中的变化","slug":"226Swift3.0带来的变化汇总系列二——集合类型中的变化","date":"2016-06-17T16:00:00.000Z","updated":"2021-07-08T11:39:00.322Z","comments":true,"path":"2016/06/18/226Swift3.0带来的变化汇总系列二——集合类型中的变化/","link":"","permalink":"http://huishao.cc/2016/06/18/226Swift3.0带来的变化汇总系列二——集合类型中的变化/","excerpt":"","text":"Swift3.0带来的变化汇总系列二——集合类型中的变化与字符串类似，Swift中集合的类型在3.0版本中也做了大量API上面的修改。 一、Array数组的更改array数组中修改的API示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//创建大量相同元素的数组//创建有10个String类型元素的数组，并且每个元素都为字符串\"Hello\"//swift2.2//var array3 = [String](count: 10, repeatedValue: \"Hello\")//swift3.0var array3 = [String](repeating: \"Hello\", count: 10)//创建有10个Int类型元素的数组，且每个元素都为1//swift2.2//var array4 = Array(count: 10, repeatedValue: 1)//swift3.0var array4 = Array(repeating: 1, count: 10)var array = [1,2,3,4,5,6,7,8,9]//向数组中追加一组元素//swift2.2//array.appendContentsOf([11,12,13])//swift3.0array.append(contentsOf: [11,12,13])//向数组中的某个位置插入一个元素//swift2.2//array.insert(0, atIndex: 0)//swift3.0array.insert(0, at: 0)//向数组中的某个位置插入一组元素//swift2.2//array.insertContentsOf([-2,-1], at: 0)//swift3.0array.insert(contentsOf: [-2,-1], at: 0)//移除数组中某个位置的元素//swift2.2//array.removeAtIndex(1)//swift3.0array.remove(at: 1)//移除一个范围内的元素//swift2.2//array.removeRange(0...2)//swift3.0array.removeSubrange(0...2)//修改一个范围内的元素//swift2.2//array.replaceRange(0...2, with: [0,1])//swift3.0array.replaceSubrange(0...2, with: [0,1])//进行数组枚举遍历 将输出 (0,0) (1,1) (2,2) (3,3) (4,4)//swift3.0 中将枚举属性enumerate 修改为enumerated()方法for item in arrayLet.enumerated()&#123; print(item)&#125;var arraySort = [1,3,5,6,7]//获取数组中的最大值//swift2.2//arraySort.maxElement()//swift3.0arraySort.max()//获取数组中的最小值//swift2.2//arraySort.minElement()//swift3.0arraySort.min()//从大到小排序//swift2.2//arraySort = arraySort.sort(&gt;)//swift3.0arraySort = arraySort.sorted(isOrderedBefore: &gt;)//从小到大排序//swift2.2//arraySort = arraySort.sort(&lt;)//swift3.0arraySort = arraySort.sorted(isOrderedBefore: &lt;) 二、Set集合中的更改Set集合中的修改示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//创建set集合var set1:Set&lt;Int&gt; = [1,2,3,4]//进行下标的移动//获取某个下标后一个元素//swlft2.2//set1[set1.startIndex.successor()]//swift3.0set1[set1.index(after: set1.startIndex)]//获取某个下标后几位的元素//swift2.2//set1[set1.startIndex.advancedBy(3)]//swift3.0set1[set1.index(set1.startIndex, offsetBy: 3)]//获取集合中的最大值//swift2.2//set1.maxElement()//swift3.0set1.max()//获取集合中的最小值//swift2.2//set1.minElement()//swift3.0set1.min()//移除集合中某个位置的元素//swift2.2//set1.removeAtIndex(set1.indexOf(3)!)//swift3.0set1.remove(at: set1.index(of: 3)!)var set3:Set&lt;Int&gt; = [1,2,3,4]var set4:Set&lt;Int&gt; = [1,2,5,6]//返回交集 &#123;1，2&#125;//swift2.2//var setInter = set3.intersect(set4)//swift3.0var setInter = set3.intersection(set4)//返回交集的补集&#123;3，4，5，6&#125;//swift2.2//var setEx = set3.exclusiveOr(set4)//swift3.0var setEx = set3.symmetricDifference(set4)var set5:Set = [1,2]var set6:Set = [2,3]var set7:Set = [1,2,3]var set8:Set = [1,2,3]//判断是否是某个集合的子集 set5是set7的子集 返回ture//swift2.2//set5.isSubsetOf(set7)//swift3.0set5.isSubset(of: set7)//判断是否是某个集合的超集 set7是set5的超集 返回ture//swift2.2//set7.isSupersetOf(set5)//swift3.0set7.isSuperset(of: set5)//判断是否是某个集合的真子集 set5是set7的真子集 返回ture//swift2.2//set5.isStrictSubsetOf(set7)//swift3.0set5.isStrictSubset(of: set7)//判断是否是某个集合的真超集 set7不是set8的真超集 返回false//swift2.2//set7.isStrictSupersetOf(set8)//swift3.0set7.isStrictSuperset(of: set8) 三、Dictionary字典中的更改Dictionary字典中修改示例如下： 12345//通过键删除某个键值对//swift2.2//dic1.removeValueForKey(1)//swift3.0dic1.removeValue(forKey: 1) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化","slug":"225Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化","date":"2016-06-15T16:00:00.000Z","updated":"2021-07-08T11:38:11.668Z","comments":true,"path":"2016/06/16/225Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化/","link":"","permalink":"http://huishao.cc/2016/06/16/225Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化/","excerpt":"","text":"Swift3.0带来的变化汇总系列一——字符串与基本运算符中的变化一、引言Apple与今年6月13日正式发布了Swift3.0的第一个预览版本，并且相应推出了Xcode8的第一个bate版本。开发者已经可以在Xcode8bate版上来体验Swift3.0的新特性。首先，Swift3.0确实带来了很大改变，许多Swift中的结构体API都进行了更新，例如String，Array等，Swift3.0版本将许多类Objective-C风格的API都更换成了Swift风格的，其目的使开发者可以使用Swift更加惬意有趣的编程。本系列博客，是我观看WWDC视频中介绍的内容以及Swift3.0的开发者帮助文档整理总结而来，在期间，我也参考对比了Swift2.2中的实现方式，希望可以帮助需要的朋友尽快熟悉和上手Swift3.0。 二、String类中的API变化除了Swift版的Cocoa框架中的API有了大范围的修改外，Swift的一些核心库也有了很大的改动。 Swift3.0中的字符串类型String在方法API上更加简洁，其中变动较大的是与下标相关的方法，列举如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var string = \"Hello-Swift\"//获取某个下标后一个下标对应的字符 char=\"e\"//swift2.2//var char = string[startIndex.successor()]//swift3.0var char = string[string.index(after: startIndex)]//获取某个下标前一个下标对应的字符 char2 = \"t\"//swift2.2//var char2 = string[endIndex.predecessor()]//swift3.0var char2 = string[string.index(before: string.endIndex)]//通过范围获取字符串中的一个子串 Hello//swift2.2//var subString = string[startIndex...startIndex.advancedBy(4)]//swift3.0var subString = string[startIndex...string.index(startIndex, offsetBy: 4)]//swift2.2//var subString2 = string[endIndex.advancedBy(-5)...endIndex.predecessor()]//swift3.0var subString2 = string[string.index(endIndex, offsetBy: -5)..&lt;endIndex]//获取某个子串在父串中的范围//swift2.2//var range = string.rangeOfString(\"Hello\")//swift3.0var range = string.range(of: \"Hello\")//追加字符串操作 此时string = \"Hello-Swift! Hello-World\"//swift2.2//string.appendContentsOf(\" Hello-World\")//swift3.0string.append(\" Hello-World\")//在指定位置插入一个字符 此时string = \"Hello-Swift!~ Hello-World\"//swift2.2//string.insert(\"~\", atIndex: string.startIndex.advancedBy(12))//swift3.0string.insert(\"~\", at: string.index(string.startIndex, offsetBy: 12))//在指定位置插入一组字符 此时string = \"Hello-Swift!~~~~ Hello-World\"//swift2.2//string.insertContentsOf([\"~\",\"~\",\"~\"], at: string.startIndex.advancedBy(12))//swift3.0string.insert(contentsOf: [\"~\",\"~\",\"~\"], at: string.index(string.startIndex, offsetBy: 12))//在指定范围替换一个字符串 此时string = \"Hi-Swift!~~~~ Hello-World\"//swift2.2//string.replaceRange(string.startIndex...string.startIndex.advancedBy(4), with: \"Hi\")//swift3.0string.replaceSubrange(string.startIndex...string.index(string.startIndex, offsetBy: 4), with: \"Hi\")//在指定位置删除一个字符 此时string = \"Hi-Swift!~~~~ Hello-Worl\"//swift2.2//string.removeAtIndex(string.endIndex.predecessor())//swift3.0string.remove(at: string.index(before:string.endIndex))//删除指定范围的字符 此时string = \"Swift!~~~~ Hello-Worl\"//swift2.2//string.removeRange(string.startIndex...string.startIndex.advancedBy(2))//swift3.0string.removeSubrange(string.startIndex...string.index(string.startIndex, offsetBy: 2))var string2 = \"My name is Jaki\"//全部转换为大写//swift2.2//string2 = string2.uppercaseString//swift3.0string2 = string2.uppercased()//全部转换为小写//swift2.2//string2 = string2.lowercaseString//swift3.0string2 = string2.lowercased() 需要注意，在Swift3.0中Range结构体被划分成了两种类型，Range和ClosedRange，分别用来描述左闭右开区间和闭区间，对应到运算符为0..&lt;10和0…10。 从上面的示例代码中可以看出，String类型中的很多方法命名进行了Swift风格的简化，改动较大的一个点是关于下标index的改变，移除了两个Index下标移动的方法，使用String类型的index()方法来进行下标的移动操作，编程更加安全。 三.基础运算符中的改变Swift3.0中的基础运算符并无太大改动，只是移除了取余运算符的浮点数取余功能，取余运算符可以进行浮点运算本是Swift独有的一个特点，3.0版本的改变后，Swift中的&quot;%&quot;运算符功能将与Objective-C与C语言中的取余运算符保持一致。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解二十三——高级运算符","slug":"224Swift专题讲解二十三——高级运算符","date":"2016-05-30T16:00:00.000Z","updated":"2021-07-08T11:37:24.119Z","comments":true,"path":"2016/05/31/224Swift专题讲解二十三——高级运算符/","link":"","permalink":"http://huishao.cc/2016/05/31/224Swift专题讲解二十三——高级运算符/","excerpt":"","text":"Swift专题讲解二十三——高级运算符一、引言除了前边博客中介绍的基本运算符外，Swift中还支持更多高级运算符，也支持开发者进行运算符的自定义。Swift中的算符运算符有一个特点，其不会产生溢出，如果有操作产生溢出，程序会直接抛出异常。如果开发者在开发中需要有溢出操作，需要使用溢出操作符来实现。 二、位运算符Swift支持C语言中的全部位运算符，示例如下： 1234567891011121314//二进制数据8 实际上a = 00001000 8位var a:UInt8 = 0b1000//使用~ 进行按位取反运算 a = 0b11110111 247a = ~a//使用&amp; 进行按位与运算 a = 0b11110000 240a = 0b11110000&amp;a//使用|进行按位或运算 a=0b11111111 255a = 0b11111111|a//使用^进行按位异或运算 a = 0b00001111 15a = 0b11110000^a//使用&lt;&lt;进行按位左移运算 a = 0b00011110 30a = a&lt;&lt;1//使用&gt;&gt;进行按位右移运算 a = 0b00001111a = a&gt;&gt;1 Swift中还提供了一种检查机制，当存在溢出操作时，程序会抛出异常，这样可以是开发者编写的代码更加安全，如果开发者真的需要使用溢出操作，Swift中还额外提供了支持溢出操作的运算符： 123456//a = 255 + 1 这样的运算会报错 &amp;+ 为溢出加运算符 计算后a=0a = 255 &amp;+ 1//&amp;- 为溢出减运算符 计算后 a = 255a = a &amp;- 1//&amp;* 为溢出乘运算符a = a &amp;* 2 三、重载运算符运算符的重载是为原有的运算符增加新的功能，开发者可以自定义一些运算符函数来实现对具体类和结构体运算的功能，示例如下： 12345678910111213class Circle &#123; //圆心 var point:(p1:Float,p2:Float) //半径 var r:Float init(point:(Float,Float),r:Float)&#123; self.point = point self.r = r &#125;&#125;func + (c1:Circle,c2:Circle) -&gt; Circle &#123; return Circle(point: c1.point, r: c1.r+c2.r)&#125; 上面代码演示的例子中重载了中缀运算符，即运算符是出现在两个操作数和中间的，还可以进行前缀运算符与后缀运算符的重载，使用prefix与postfix即可。示例如下： 123prefix func + (c:Circle) -&gt; Circle &#123; return Circle(point: c.point, r: c.r*2)&#125; 复合运算符也可以支持重载，需要注意的是，复合运算符的参数必须是inout修饰的，因为复合运算符会直接操作参数值： 123func += (inout c1:Circle,c2:Circle) &#123; c1 = Circle(point: c1.point, r: c1.r+c2.r)&#125; 等价运算符也可以用来重载，通常用来进行比较操作，示例如下： 123456func == (c1:Circle,c2:Circle) -&gt; Bool &#123; return (c1.point==c2.point &amp;&amp; c1.r==c2.r)&#125;func != (c1:Circle,c2:Circle) -&gt; Bool &#123; return ((c1.point != c2.point) || (c1.r != c2.r))&#125; 四、自定义运算符Swift中除了可以对一些已经存在的运算符进行重载操作外，开发者还可以自定义一些运算符，在自定义运算符时，必须指定运算符是前缀、中缀或是后缀，示例如下： 1234567//定义一个中缀运算符+!+ operator关键字用于定义运算符infix operator +!+&#123;&#125;//进行运算符的实现func +!+ (param:Int,param2:Int)-&gt;Int&#123; return (param+param2)*param2&#125;var b = 5 +!+ 5 还有一点需要注意，在进行自定义运算符时，开发者也可以为其设置结合性与优先级，结合性由associativity关键字定义，可选left，right，none，优先级的默认值为100，由precedence关键字指定，示例如下： 1234567//定义一个中缀运算符+!+infix operator +!+&#123;associativity left precedence 140&#125;//进行运算符的实现func +!+ (param:Int,param2:Int)-&gt;Int&#123; return (param+param2)*param2&#125;var b = 5 +!+ 5 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解二十二——泛型","slug":"223Swift专题讲解二十二——泛型","date":"2016-05-29T16:00:00.000Z","updated":"2021-07-08T11:36:39.591Z","comments":true,"path":"2016/05/30/223Swift专题讲解二十二——泛型/","link":"","permalink":"http://huishao.cc/2016/05/30/223Swift专题讲解二十二——泛型/","excerpt":"","text":"Swift专题讲解二十二——泛型一、以泛型为参数的函数泛型是Swift语言强大的核心，泛型是对类型的抽象，使用泛型开发者可以更加灵活方便的表达代码意图。我们知道，有参函数的参数必须有一个明确的参数类型，有些时候开发者会遇到这样一种情况，编写一个函数用于交换两个变量的值，由于变量有类型之分，实现相同的功能，可能需要重载成多个函数来实现，这大大浪费了开发成本，使用泛型，可以完美的解决这个问题，示例代码如下： 12345678func exchange&lt;T&gt;(inout param1:T,inout param2:T)&#123; let tmp = param1 param1 = param2 param2 = tmp&#125;var p1 = \"15\"var p2 = \"40\"exchange(&amp;p1, param2: &amp;p2) 上面的方法可以实现对任意相同类型变量的交换，函数参数中使用泛型，需要在函数名后的&lt;&gt;中定义参数占位符，如有多个参数占位符，用逗号隔开即可。 二、泛型在类型中的应用泛型除了可以作为函数的参数、返回值外，在定义类型时，灵活应用泛型也可以解决很多十分棘手的问题，例如实现一个栈结构的集合类型，示例代码如下： 1234567891011121314151617struct Stack&lt;ItemType&gt; &#123; var items:[ItemType] = [] mutating func push(param:ItemType) &#123; self.items.append(param) &#125; mutating func pop()-&gt;ItemType&#123; return self.items.removeLast() &#125;&#125;//整型栈var obj1 = Stack&lt;Int&gt;()obj1.push(1)obj1.pop()//字符串栈var obj2 = Stack&lt;String&gt;()obj2.push(\"HS\")obj2.pop() 在对使用了泛型的类型进行扩展时，不需要在使用&lt;&gt;进行泛型的定义，直接使用原定义的泛型占位符即可，示例如下： 12345extension Stack&#123; func getArray() -&gt; [ItemType] &#123; return items &#125;&#125; 有时候，开发者需要对泛型进行一些约束，例如只允许此泛型是继承自某个类或者实现了某个协议，示例代码如下： 12345678910111213class MyClass &#123; &#125;//只有MyClass的子类可以进行Stack栈的创建struct Stack&lt;ItemType:MyClass&gt; &#123; var items:[ItemType] = [] mutating func push(param:ItemType) &#123; self.items.append(param) &#125; mutating func pop()-&gt;ItemType&#123; return self.items.removeLast() &#125;&#125; 在协议中，可以使用另一种方式来进行泛型编程，使用associatedtype关键字可以进行类型关联，示例如下： 123456789protocol MyProtocol &#123; //实现协议时才指定类型 associatedtype ItemType var param:ItemType &#123;get set&#125;&#125;class MyClass:MyProtocol &#123; //由于Swift可以自动识别类型 这是MyProtocol中的ItemType为Int var param: Int = 0&#125; 三、泛型与where子句的结合使用使用where子句可以对泛型进行更加严格约束，使其符合开发者需要的逻辑，示例如下： 123456789101112//T和C都要遵守整型协议class MyClassTwo&lt;T,C where T:IntegerType,C:IntegerType&gt; &#123; var param1:T var param2:C init(param1:T,param2:C)&#123; self.param1=param1 self.param2=param2 &#125;&#125;var obj3 = MyClassTwo(param1: 1, param2: 1) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解二十——扩展","slug":"221Swift专题讲解二十——扩展","date":"2016-05-28T16:00:00.000Z","updated":"2021-07-08T11:34:51.557Z","comments":true,"path":"2016/05/29/221Swift专题讲解二十——扩展/","link":"","permalink":"http://huishao.cc/2016/05/29/221Swift专题讲解二十——扩展/","excerpt":"","text":"Swift专题讲解二十——扩展一、简介Swift中的扩展与Objective-C中的类别功能相似，扩展可以为一个已有的类、结构体、枚举或者协议添加新的属性或方法，与Objective-C的类别不同的是，Swift中的扩展没有名称。 Swift中的扩展支持如下功能： 1.添加计算属性 2.定义实例方法和类型方法 3.定义新的构造方法 4.定义下标方法 5.定义嵌套类型 6.使一个已有的类遵守协议 7.对协议进行扩展添加新的方法 二、使用扩展添加计算属性使用extension来声明扩展，示例代码如下： 1234567891011121314151617//创建一个类 有两个属性class MyClass &#123; var name:String var age:Int init()&#123; name = \"HS\" age = 24 &#125;&#125;//为MyClass类扩展一个计算属性extension MyClass &#123; var nameAndAge:String&#123; return \"\\(name)\"+\"\\(age)\" &#125;&#125;var obj = MyClass()obj.nameAndAge 三、使用扩展添加构造方法需要注意的是，扩展不能为类添加指定构造方法，只可以为其添加便利构造方法，示例代码如下： 1234567891011121314151617//创建一个类 有两个属性class MyClass &#123; var name:String var age:Int init()&#123; name = \"HS\" age = 24 &#125;&#125;extension MyClass&#123; convenience init(name:String,age:Int)&#123; self.init() self.name=name self.age=age &#125;&#125;var obj2 = MyClass(name: \"ZYH\", age: 24) 四、使用扩展添加实例方法与类型方法扩展可以为一个类型添加实例方法与类型方法，示例如下： 1234567891011121314151617181920212223//创建一个类 有两个属性class MyClass &#123; var name:String var age:Int init()&#123; name = \"HS\" age = 24 &#125;&#125;extension MyClass&#123; func logName() -&gt; String &#123; print(name) return name &#125; class func logClassName()&#123; print(\"MyClass\") &#125;&#125;var obj3 = MyClass()obj3.logName()MyClass.logClassName() 对于值类型的扩展，可以使用可变方法来修改实例本身，示例如下： 12345678910extension Int&#123; //修改本身需要使用nutating mutating func change() &#123; self = self*self &#125;&#125;var count = 3count.change()//打印9print(count) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解二十一——协议","slug":"222Swift专题讲解二十一——协议","date":"2016-05-28T16:00:00.000Z","updated":"2021-07-08T11:35:53.571Z","comments":true,"path":"2016/05/29/222Swift专题讲解二十一——协议/","link":"","permalink":"http://huishao.cc/2016/05/29/222Swift专题讲解二十一——协议/","excerpt":"","text":"Swift专题讲解二十一——协议一、引言协议约定了一些属性与方法，其作用类似Java中的抽象类，Swift中类型通过遵守协议来实现一些约定的属性和方法。Swift中的协议使用protocol关键字来声明。Swift中的协议还有一个十分有意思的特性，协议可以通过扩展来实现一些方法和附加功能。 二、在协议中定义属性和方法协议中定义的属性只约定名称和类型，在具体类型的实现中，其可以是存储属性也可以是计算属性，协议中还需要指定属性是可读的还是可读可写的。示例代码如下： 12345678910111213141516171819202122232425262728protocol MyPortocol &#123; //定义实例属性 //可读的 var name:String&#123;get&#125; //可读可写的 var age:Int&#123;set get&#125; //可读的 var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125;&#125;class MyClass: MyPortocol &#123; var name: String var age: Int var nameAndAge: String&#123; get&#123; return \"\\(name)\"+\"\\(age)\" &#125; &#125; static var className: String&#123; get&#123; return \"MyClass\" &#125; &#125; init()&#123; name = \"HS\" age = 24 &#125;&#125; 有一点需要注意，协议中的可读并不是只读，协议中的属性约定成可读可写，则在实现时，这个属性必须是可读可写的，但是如果协议中约定成可读的，则此属性可以是只读的也可以是可读可写的，看具体的实现。 协议中约定的方法可以是实例方法也可以是类型方法，示例如下： 123456789101112131415161718protocol MyPortocol &#123; func logName() static func logClassName()&#125;class MyClass: MyPortocol &#123; var name: String var age: Int init()&#123; name = \"HS\" age = 24 &#125; func logName() &#123; print(name) &#125; static func logClassName() &#123; print(className) &#125;&#125; 同样，协议中也可以对构造方法进行定义约定。 三、协议的特点协议中虽然没有任何属性和方法的实现，但是其仍然可以当做类型来使用，在函数参数、返回值中应用广泛，示例如下： 12345678910111213protocol MyPortocol &#123; //定义实例属性 var name:String&#123;get&#125; var age:Int&#123;set get&#125; var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125; func logName() static func logClassName()&#125;//将协议类型作为参数func test(param:MyPortocol) &#123; param.logName()&#125; 协议作为类型这种用法另一个应用点是在集合类型中，协议可以作为所有遵守此协议的集合类型。 协议可以像其他类型一样进行继承，子协议将自动拥有父协议约定的属性和方法。协议也可以通过class关键字来定义只有类可以进行遵守，示例如下： 12345678910111213protocol MyPortocol &#123; //定义实例属性 var name:String&#123;get&#125; var age:Int&#123;set get&#125; var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125; func logName() static func logClassName()&#125;//只有类可以继承此协议protocol MySubPortocol:class,MyPortocol &#123; &#125; 协议既然可以像其他类型一样进行使用，当然它也可以使用is，as?，as!进行检查和转换，关于is，as的更多用法可以查看Swift关于类型转换的内容。 协议也可定义其中的属性或方法为可选的，即遵守此协议的类可以实现也可以不实现可选的属性和方法，然而，声明为可选的需要此协议为@objc类型的，示例如下： 12345678910@objc protocol MyPortocol &#123; //定义实例属性 var name:String&#123;get&#125; var age:Int&#123;set get&#125; var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125; func logName() //可选实现 optional static func logClassName()&#125; Swift中的协议还有一个十分重要的特性，其可以通过扩展来进行属性、方法以及下标的实现。这对于一些通用类的方法十分方便，这相当于所有继承此协议的类都默认实现了这样的方法，示例如下： 1234567891011121314protocol MyPortocol &#123; //定义实例属性 var name:String&#123;get&#125; var age:Int&#123;set get&#125; var nameAndAge:String&#123;get&#125; static var className:String&#123;get&#125; func logName() static func logClassName()&#125;extension MyPortocol&#123; var name:String&#123; return \"HS\" &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十九——类型转换","slug":"220Swift专题讲解十九——类型转换","date":"2016-05-26T16:00:00.000Z","updated":"2021-07-08T09:48:29.358Z","comments":true,"path":"2016/05/27/220Swift专题讲解十九——类型转换/","link":"","permalink":"http://huishao.cc/2016/05/27/220Swift专题讲解十九——类型转换/","excerpt":"","text":"Swift专题讲解十九——类型转换一、类型检查与转换在Objective-C和Java中，任何类型实例都可以通过强转使编译器认为它是另一种类型的实例，这么做其实是将所有的安全检查工作都交给了开发者自己来做。先比之下，Swift中的Optional类型转换就会比较安全与可靠。 Swift中使用is关键字来进行类型的检查，其会返回一个布尔值true或者false来表明检查是否成立，示例如下： 1234var str = \"HS\"if str is String &#123; print(str)&#125; Swift中有向上兼容与向下转换的特性，就是说，一个父类类型的集合可以接收子类的实例，同样，在使用这些实例变量时可以将其向下转换为子类类型，示例如下： 1234567891011121314151617181920212223242526272829303132333435//自定义一个类及其子类class MyClass &#123; var name:String?&#125;class MySubClassOne: MyClass &#123; var count:Int?&#125;class MySubClassTwo: MyClass &#123; var isBiger:Bool?&#125;//创建3个实例var obj1 = MyClass()obj1.name = \"HS\"var obj2 = MySubClassOne()obj2.count = 100var obj3 = MySubClassTwo()obj3.isBiger=true//将实例存放在其公共父类类型的数组集合中var array:[MyClass] = [obj1,obj2,obj3]//进行遍历for var i in 0..&lt;array.count &#123; var obj = array[i] if obj is MySubClassOne &#123; print((obj as! MySubClassOne).count!) continue &#125; if obj is MySubClassTwo &#123; print((obj as! MySubClassTwo).isBiger!) continue &#125; if obj is MyClass &#123; print(obj.name!) &#125;&#125; 有一点需要注意，在进行类型转换时，可以使用as!或者as?来进行，as!是一种强制转换方法，它在开发者确定类型无误是使用，如果用as!转换的类型有误，则会出现运行时错误。as?是Optional类型转换，如果转换失败，则会返回nil。 二、Any和AnyObject类型在Objective-C中，常常使用id来表示引用类型的泛型，Swift中的AnyObject与之类似。示例如下： 123456789101112131415//进行遍历for var i in 0..&lt;array.count &#123; var obj = array[i] if obj is MySubClassOne &#123; print((obj as! MySubClassOne).count!) continue &#125; if obj is MySubClassTwo &#123; print((obj as! MySubClassTwo).isBiger!) continue &#125; if obj is MyClass &#123; print((obj as! MyClass).name!) &#125;&#125; Any类型则比AnyOject类型更加强大，其可以混合值类型和引用类型一起工作，示例如下： 1var anyArray:[Any] = [100,\"HS\",obj1,obj2,false,(1.1),obj3,&#123;()-&gt;() in print(\"Closures\")&#125;] 上面示例的数组中包含了整型，字符串类型，引用类型，布尔类型和闭包。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十八——异常处理","slug":"219Swift专题讲解十八——异常处理","date":"2016-05-25T16:00:00.000Z","updated":"2021-07-08T09:47:48.593Z","comments":true,"path":"2016/05/26/219Swift专题讲解十八——异常处理/","link":"","permalink":"http://huishao.cc/2016/05/26/219Swift专题讲解十八——异常处理/","excerpt":"","text":"Swift专题讲解十八——异常处理一、异常的抛出与传递代码的运行很多时候并不会完全按照程序员的设想进行，编写代码时进行可控的异常处理机制是十分必要的。通常，对于一个特定的操作，程序员可以定义一个继承自ErrorType的枚举来进行异常类型的描述，使用throw关键字来进行异常的抛出，示例代码如下： 12345678//定义一个自定义的错误类型enum MyError:ErrorType &#123; case DesTroyError case NormalError case SimpleError&#125;//进行异常的抛出throw MyError.NormalError 函数可以进行错误的传递，需要使用throws关键字来声明这个函数可能会抛出错误，如果不如此声明，则函数内部抛出的错误只能在函数内部解决，throws关键字标记的函数内部抛出的错误会被传递到调用函数的地方，开发者可以在调用函数的地方捕获到错误描述来做相应处理，示例如下： 123func MyFunc()throws -&gt; Void &#123; throw MyError.NormalError&#125; 对于可能抛出异常的函数调用，开发者要么在调用函数的地方捕获处理这些异常，要么使用try关键字将异常继续抛出去，等待下一层捕获者处理。异常的处理后面会介绍，继续抛出异常示例如下： 1try MyFunc() 二、异常的处理除了将错误继续向上抛出之外，Swift还提供了3种处理异常的方式。 1.使用do-catch语句来捕获异常开发者可以使用do-catch语句来捕获异常，通过异常类型的判断来分别做处理，示例代码如下: 123456789101112do&#123; try MyFunc()&#125;catch MyError.DesTroyError&#123;//将打印error1 print(\"error1\")&#125;catch MyError.NormalError&#123; print(\"error2\")&#125;catch MyError.SimpleError&#123; print(\"error3\")&#125;catch&#123;//如果上面所有的catch都没有捕获 会走这个异常捕获判断 print(\"all\")&#125; 2.将异常映射为Optional值处理异常抛出的第2中方式是使用try?将异常映射为Optional值，可以简单理解为，对一个可能抛出异常的函数的调用，如果有异常抛出，则返回值为nil，如果没有，则函数顺利执行，返回值为其原返回值，示例如下: 12//将返回niltry? MyFunc() 注意：返回值为Void并非为nil，结合if-let语句可以编写十分飘逸的代码，示例如下： 12345if let _=try?MyFunc() &#123; print(\"success\")&#125;else&#123; print(\"fail\")&#125; 3.终止异常传递有时候开发者可以保证一个可能抛出异常的函数绝对不会抛出异常，这时开发者可以使用try!的方式来终止异常的传递，但是这样做有一定风险，如果这个函数真的抛出了异常，则会产生运行时错误。示例如下： 1try! MyFunc() 三、延时执行语句对于某些释放资源类的操作，开发者总是希望其离开当前代码块时被执行，然后一个复杂流程结构可能会因异常抛出，return，break这些方式被终止，因此，Swift中提供了defer语句来进行延时执行一些操作，defer中的语句总是会在当前代码块将要结束时才执行，无论它是以哪种方式结束的，示例如下： 1234567891011121314//执行此函数将打印/* Care finish */func MyFunc()throws -&gt; Void &#123; defer&#123; print(\"finish\") &#125; print(\"Care\") throw MyError.DesTroyError &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十七——Optional链","slug":"218Swift专题讲解十七——Optional链","date":"2016-05-23T16:00:00.000Z","updated":"2021-07-08T09:46:59.058Z","comments":true,"path":"2016/05/24/218Swift专题讲解十七——Optional链/","link":"","permalink":"http://huishao.cc/2016/05/24/218Swift专题讲解十七——Optional链/","excerpt":"","text":"Swift专题讲解十七——Optional链Swift中的Optional值有这样的特性，当对其进行可选拆包时，即使用?进行Optional类型值的取值时，如果Optional值不为nil，则会返回原始类型的数据值，如果为nil，则会返回nil。因此，当使用?对Optional拆包后进行方法、属性或者下标的调用时，如果有值，则会成功相应调用，如果没有值，则会调用失败，返回nil。 注意：使用!则会进行强制拆包，这时如果Optional值为nil，则会出现运行时错误，因此开发者在使用!进行强制拆包时，必须确认Optional类型值不为nil。 当对可选值进行可选拆包并调用其属性或方法后，无论原属性或者方法返回值是什么类型的，都会被包装成Optional值类型。当使用?对一个Optional值进行拆包并调用其方法时，方法的返回值一会被包装为Optional类型，示例如下： 12345678910111213class Myclass &#123; var cls:MyClassTwo? &#125;class MyClassTwo &#123; func run() -&gt; String &#123; return \"run\" &#125;&#125;let obj:Myclass = Myclass()//将返回nilobj.cls?.run() 在进行Optional链调用的时候，会遵守如下一些特性： 1.如果进行?拆包Optional值的属性或者方法返回值原来为非Optional值，则会包装成Optional值。 2.如果进行?拆包Optional值的属性或者方法返回值原来为Optional值，则依然会返回Optional值，并且并不会进行Optional值类型的嵌套。 3.由于使用Optional值?可选拆包时会将其属性和方法的返回值都包装成Optional类型的，因此使用?可以进行Optional链式调用，这其间，有一个环节调用失败，整个链都会返回nil。示例如下： 123let obj:Myclass = Myclass()//将返回nil(obj.cls?.run())?.startIndex 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"iOS进度指示器——NSProgress","slug":"217iOS进度指示器——NSProgress","date":"2016-05-21T16:00:00.000Z","updated":"2021-07-08T09:46:13.427Z","comments":true,"path":"2016/05/22/217iOS进度指示器——NSProgress/","link":"","permalink":"http://huishao.cc/2016/05/22/217iOS进度指示器——NSProgress/","excerpt":"","text":"iOS进度指示器——NSProgress一、引言在iOS7之前，系统一直没有提供一个完整的框架来描述任务进度相关的功能。这使得在开发中进行耗时任务进度的监听将什么麻烦，在iOS7之后，系统提供了NSProgress类来专门报告任务进度。 二、创建单任务进度监听器单任务进度的监听是NSProgress最简单的一种运用场景，我们来用定时器模拟一个耗时任务，示例代码如下： 123456789101112131415161718192021222324252627282930@interface ViewController ()&#123; NSProgress * progress;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //这个方法将创建任务进度管理对象 UnitCount是一个基于UI上的完整任务的单元数 progress = [NSProgress progressWithTotalUnitCount:10]; NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(task) userInfo:nil repeats:YES]; //对任务进度对象的完成比例进行监听 [progress addObserver:self forKeyPath:@\"fractionCompleted\" options:NSKeyValueObservingOptionNew context:nil];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; NSLog(@\"进度= %f\",progress.fractionCompleted);&#125;-(void)task&#123; //完成任务单元数+1 if (progress.completedUnitCount&lt;progress.totalUnitCount) &#123; progress.completedUnitCount +=1; &#125; &#125; 上面的示例代码中，fractionCompleted属性为0-1之间的浮点值，为任务的完成比例。NSProgress对象中还有两个字符串类型的属性，这两个属性将进度信息转化成固定的格式： 1234//显示完后比例 如：10% completed@property (null_resettable, copy) NSString *localizedDescription;//完成数量 如：1 of 10@property (null_resettable, copy) NSString *localizedAdditionalDescription; 三、创建多任务进度监听器上面演示了只有一个任务时的进度监听方法，实际上，在开发中，一个任务中往往又有许多子任务，NSProgress是以树状的结构进行设计的，其支持子任务的嵌套，示例如下： 1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //这个方法将创建任务进度管理对象 UnitCount是一个基于UI上的完整任务的单元数 progress = [NSProgress progressWithTotalUnitCount:10]; //对任务进度对象的完成比例进行监听 [progress addObserver:self forKeyPath:@\"fractionCompleted\" options:NSKeyValueObservingOptionNew context:nil]; //向下分支出一个子任务 子任务进度总数为5个单元 即当子任务完成时 父progerss对象进度走5个单元 [progress becomeCurrentWithPendingUnitCount:5]; [self subTaskOne]; [progress resignCurrent]; //向下分出第2个子任务 [progress becomeCurrentWithPendingUnitCount:5]; [self subTaskOne]; [progress resignCurrent];&#125;-(void)subTaskOne&#123; //子任务总共有10个单元 NSProgress * sub =[NSProgress progressWithTotalUnitCount:10]; int i=0; while (i&lt;10) &#123; i++; sub.completedUnitCount++; &#125;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; NSLog(@\"= %@\",progress.localizedAdditionalDescription);&#125; NSProgress的这种树状设计模式乍看起来确实有些令人费解，有一点需要注意，becomeCurrentWithPendingUnitCount:方法的意义是将此NSProgress对象注册为当前线程任务的根进度管理对象，resignCurrent方法为取消注册，这两个方法必须成对出现，当一个NSProgress对象被注册为当前线程的根节点时，后面使用类方法 progressWithTotalUnitCount:创建的NSProgress对象都默认作为子节点添加。 四、iOS9之后进行多任务进度监听的新设计方法正如上面的例子所演示，注册根节点的方式可读性很差，代码结构也不太清晰，可能Apple的工程师们也觉得如此，在iOS9之后，NSProgress类中又添加了一些方法，通过这些方法可以更加清晰的表达进度指示器之间的层级结构，示例代码如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //这个方法将创建任务进度管理对象 UnitCount是一个基于UI上的完整任务的单元数 progress = [NSProgress progressWithTotalUnitCount:10]; //对任务进度对象的完成比例进行监听 [progress addObserver:self forKeyPath:@\"fractionCompleted\" options:NSKeyValueObservingOptionNew context:nil]; //创建子节点 NSProgress * sub = [NSProgress progressWithTotalUnitCount:10 parent:progress pendingUnitCount:5]; NSProgress * sub2 = [NSProgress progressWithTotalUnitCount:10 parent:progress pendingUnitCount:5]; for (int i=0; i&lt;10; i++) &#123; sub.completedUnitCount ++; sub2.completedUnitCount ++; &#125;&#125; 如上面代码所示，代码结构变得更加清晰，可操作性也更强了。 五、一点小总结123456789101112131415161718192021222324252627282930313233//获取当前线程的进度管理对象根节点//注意：当有NSProgress对象调用了becomeCurrentWithPendingUnitCount:方法后，这个方法才能获取到+ (nullable NSProgress *)currentProgress;//创建一个NSProgress对象，需要传入进度的单元数量+ (NSProgress *)progressWithTotalUnitCount:(int64_t)unitCount;//和上一个方法功能相似 iOS9之后的新方法+ (NSProgress *)discreteProgressWithTotalUnitCount:(int64_t)unitCount;//iOS9之后的新方法 创建某个进度指示器节点的子节点+ (NSProgress *)progressWithTotalUnitCount:(int64_t)unitCount parent:(NSProgress *)parent pendingUnitCount:(int64_t)portionOfParentTotalUnitCount;//NSProgress实例的初始化方法 自父节点参数可以为nil- (instancetype)initWithParent:(nullable NSProgress *)parentProgressOrNil userInfo:(nullable NSDictionary *)userInfoOrNil;//注册为当前线程根节点- (void)becomeCurrentWithPendingUnitCount:(int64_t)unitCount;//取消注册 与注册方法必须同步出现- (void)resignCurrent;//iOS9新方法 向一个节点中添加一个子节点- (void)addChild:(NSProgress *)child withPendingUnitCount:(int64_t)inUnitCount;//进度单元总数@property int64_t totalUnitCount;//已完成的进度单元数@property int64_t completedUnitCount;//是否可取消@property (getter=isCancellable) BOOL cancellable;//是否可暂停@property (getter=isPausable) BOOL pausable;//进度比例 0-1之间@property (readonly) double fractionCompleted;//取消- (void)cancel;//暂停- (void)pause;//恢复- (void)resume 六、关于NSProgress对象的用户配置字典在NSProgress对象的用户字典中可以设置一些特定的键值来进行显示模式的设置，示例如下： 123456789101112131415161718192021222324252627//设置剩余时间 会影响localizedAdditionalDescription的值/*例如：0 of 10 — About 10 seconds remaining*/[progress setUserInfoObject:@10 forKey:NSProgressEstimatedTimeRemainingKey];//设置完成速度信息 会影响localizedAdditionalDescription的值/*例如：Zero KB of 10 bytes (15 bytes/sec)*/[progress setUserInfoObject:@15 forKey:NSProgressThroughputKey];/*下面这些键值的生效 必须将NSProgress对象的kind属性设置为 NSProgressKindFileNSProgressFileOperationKindKey键对应的是提示文字类型 会影响localizedDescription的值NSProgressFileOperationKindKey可选的对应值如下：NSProgressFileOperationKindDownloading： 显示Downloading files…NSProgressFileOperationKindDecompressingAfterDownloading： 显示Decompressing files…NSProgressFileOperationKindReceiving： 显示Receiving files…NSProgressFileOperationKindCopying： 显示Copying files…*/ [progress setUserInfoObject:NSProgressFileOperationKindDownloading forKey:NSProgressFileOperationKindKey];/*NSProgressFileTotalCountKey键设置显示的文件总数 例如：Copying 100 files…*/ [progress setUserInfoObject:@100 forKey:NSProgressFileTotalCountKey];//设置已完成的数量[progress setUserInfoObject:@1 forKey:NSProgressFileCompletedCountKey]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Swift专题讲解十六——ARC在Swift中的应用","slug":"216Swift专题讲解十六——ARC在Swift中的应用","date":"2016-05-18T16:00:00.000Z","updated":"2021-07-08T09:45:15.374Z","comments":true,"path":"2016/05/19/216Swift专题讲解十六——ARC在Swift中的应用/","link":"","permalink":"http://huishao.cc/2016/05/19/216Swift专题讲解十六——ARC在Swift中的应用/","excerpt":"","text":"Swift专题讲解十六——ARC在Swift中的应用一、引言ARC（自动引用计数）是Objective-C和Swift中用于解决内存管理问题的方案。在学习Objective-C编程时经常会学习到一个关于ARC的例子：在一个公用的图书馆中，每次进入一人就将卡插入，走的时候将自己的卡拔出拿走。图书馆系统会判定只要有卡插入，就将图书馆的灯打开，当所有卡都被取走后，将图书馆的灯关掉。这个例子对应于Objective-C中的对象声明周期管理十分贴切。每当一个对象增加一个引用时，其引用计数会加1，当一个引用被取消时，对象的引用计数减1，当引用计数减为0时，说明此对象将不再有任何引用，对象会被释放掉，让出内存。Swift也采用同样的方式进行内存管理。 注意：在Swift中只有引用类型有自动引用计数，结构体、枚举这类值类型是没有引用计数的。关于引用计数的示例代码如下： 123456789101112class MyClass &#123; deinit&#123; print(&quot;MyClass deinit&quot;) &#125;&#125;var cls1:MyClass? = MyClass()var cls2:MyClass? = cls1var cls3:MyClass? = cls2cls2 = nilcls1 = nil//执行下面代码后才会打印“MyClass deinit”cls3 = nil 二、循环引用的处理方法在开发中，开发者一不小心就会写出产生循环引用的代码，在上面的示例中可以看出，除非实例的引用全部解除，否则实例将不会调用析构方法，内存不会被释放，如果在写代码时，A引用了B，同样B也引用了A，那么实际上现在A和B的引用计数都是2，将A和B都置为nil后，A和B实例依然保有1个引用计数，都不会被释放，实例如下： 12345678910111213141516171819class MyClassOne &#123; var cls:MyClassTwo? deinit&#123; print(\"ClassOne deinit\") &#125;&#125;class MyClassTwo &#123; var cls:MyClassOne? deinit&#123; print(\"ClassTwo deinit\") &#125;&#125;var obj1:MyClassOne? = MyClassOne()var obj2:MyClassTwo? = MyClassTwo()obj1?.cls = obj2obj2?.cls = obj1obj1=nilobj2=nil//没有打印析构函数的调用信息 对于上面的情况，可以将属性声明称weak类型来防止这种循环引用，weak的作用在于只是弱引用实例，原实例的引用计数并不会加1，示例如下： 1234567891011121314151617181920//关于弱引用的演示class MyClassThree&#123; weak var cls:MyClassFour? deinit&#123; print(\"ClassThree deinit\") &#125;&#125;class MyClassFour &#123; var cls:MyClassThree? deinit&#123; print(\"ClassFour deinit\") &#125;&#125;var obj3:MyClassThree? = MyClassThree()var obj4:MyClassFour? = MyClassFour()obj3?.cls = obj4obj4?.cls = obj3obj4=nil//此时obj3中的cls也为nilobj3?.cls 若引用的实例被释放后，其在另一个实例中的引用也将被置为nil，所以weak只能用于optional类型的属性，然而在开发中还有一种情况，某个类必须保有另一个类的示例，这个实例不能为nil，但是这个属性又不能影响其原始实例的释放，这种情况也会造成循环引用，示例如下： 123456789101112131415161718192021class MyClassFive&#123; var cls:MyClassSix init(param:MyClassSix)&#123; cls = param &#125; deinit&#123; print(\"ClassFive deinit\") &#125;&#125;class MyClassSix&#123; var cls:MyClassFive? deinit&#123; print(\"ClassSix deinit\") &#125;&#125;var obj6:MyClassSix? = MyClassSix()var obj5:MyClassFive? = MyClassFive(param: obj6!)obj6?.cls = obj5obj5=nilobj6=nil//没有打印任何信息 上面的示例也会造成循环引用，然而MyClassFive类中的cls属性为常量不可为nil，不可使用weak弱引用来做Swift中又提供了一个关键字unowned无主引用来处理这样的问题，示例如下： 1234567891011121314151617181920class MyClassFive&#123; unowned var cls:MyClassSix init(param:MyClassSix)&#123; cls = param &#125; deinit&#123; print(\"ClassFive deinit\") &#125;&#125;class MyClassSix&#123; var cls:MyClassFive? deinit&#123; print(\"ClassSix deinit\") &#125;&#125;var obj6:MyClassSix? = MyClassSix()var obj5:MyClassFive? = MyClassFive(param: obj6!)obj6?.cls = obj5obj5=nilobj6=nil 关于弱引用和无主引用，其区别主要是在于： 1.弱引用用于解决Optional值的引起的循环引用。 2.无主引用用于解决非Optional值引起的循环引用。 3.个人以为，弱引用可用下图表示： 4.无主引用可用如下图表示： 若将上面的代码修改如下，程序会直接崩溃： 1234567891011121314151617181920class MyClassFive&#123; unowned var cls:MyClassSix init(param:MyClassSix)&#123; cls = param &#125; deinit&#123; print(\"ClassFive deinit\") &#125;&#125;class MyClassSix&#123; var cls:MyClassFive? deinit&#123; print(\"ClassSix deinit\") &#125;&#125;var obj6:MyClassSix? = MyClassSix()var obj5:MyClassFive? = MyClassFive(param: obj6!)obj6?.cls = obj5obj6=nilobj5?.cls 上面所举的例子满足了两种情况，一种是两类实例引用的属性都是Optional值的时候使用weak来解决循环引用，一种是两类实例有一个为非Optional值的时候使用unowned来解决循环引用，然而还有第三种情况，两类实例引用的属性都为非Optional值的时候，可以使用无主引用与隐式拆包结合的方式来解决，这也是无主引用最大的应用之处，示例如下： 1234567891011121314151617181920class MyClassSeven&#123; unowned var cls:MyClassEight init(param:MyClassEight)&#123; cls = param &#125; deinit&#123; print(\"ClassSeven deinit\") &#125;&#125;class MyClassEight&#123; var cls:MyClassSeven! init()&#123; cls = MyClassSeven(param:self) &#125; deinit&#123; print(\"ClassEight deinit\") &#125;&#125;var obj7:MyClassEight? = MyClassEight()obj7=nil 除了在两个类实例间会产生循环引用，在闭包中，也可能出现循环引用，当某个类中包含一个闭包属性，同时这个闭包属性中又使用了类实例，则会产生循环引用，示例如下： 1234567891011121314class MyClassNine &#123; var name:String = \"HS\" lazy var closure:()-&gt;Void = &#123; //闭包中使用引用值会使引用+1 print(self.name) &#125; deinit&#123; print(\"ClassNine deinit\") &#125;&#125;var obj9:MyClassNine? = MyClassNine()obj9?.closure()obj9=nil//不会打印析构信息 Swift中提供了闭包的捕获列表来对引用类型进行弱引用或者无主引用的转换： 12345678910111213class MyClassNine &#123; var name:String = \"HS\" lazy var closure:()-&gt;Void = &#123; [unowned self]()-&gt;Void in print(self.name) &#125; deinit&#123; print(\"ClassNine deinit\") &#125;&#125;var obj9:MyClassNine? = MyClassNine()obj9?.closure()obj9=nil 捕获列表以中括号标识，多个捕获参数则使用逗号分隔。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十五——类型构造","slug":"215Swift专题讲解十五——类型构造","date":"2016-05-18T16:00:00.000Z","updated":"2021-07-08T09:44:25.573Z","comments":true,"path":"2016/05/19/215Swift专题讲解十五——类型构造/","link":"","permalink":"http://huishao.cc/2016/05/19/215Swift专题讲解十五——类型构造/","excerpt":"","text":"Swift专题讲解十五——类型构造一、引言构造是类、结构体、枚举在实例化中必须执行的过程，在构造过程中，类、结构体必须完成其中存储属性的构造。Swift中的构造通过构造方法来完成，和Objective-C中的init初始化系列方法不同，Swift中的构造方法并不会也无需返回值，它的任务即是完成实例化过程。 二、属性的构造类和结构体的存储属性必须在实例化完成前被构造完成，因此，有两种方式来这么做： 1.类或者结构体中声明存储属性时直接为其设置默认值。 2.在类或者结构体的构造方法中对存储属性进行构造。 这里有一点需要注意：在存储属性设置默认值或者在构造方法中进行构造时，并不会触发属性监听器willSet、didSet方法。示例代码如下： 1234567891011121314class MyClass &#123; var count:Int=0&#123; willSet&#123; print(&quot;willset&quot;) &#125; &#125; var name:String init()&#123; //必须进行构造或者设置值 count=5 count=6 name = &quot;HS&quot; &#125;&#125; init()方法为不带参数的构造方法，所有构造方法都需要用init()来标识，开发者可以使用函数重载的方式来创建不同的构造方法。官方推荐，如果一个类的大多实例的某个存储属性都需要相同的值，强烈推荐开发者设置此存储属性的默认值，这样可以很好的应用Swift语言的类型推断功能并且可以使代码结构更加紧凑。 如果一个属性在逻辑上是允许为nil的，则开发者可以将其声明称Optional值类型，在进行类的实例化时，Optional类型的属性如果没有赋值会被自动赋值为nil。 注意，常量也需要在构造完成之前进行赋值，一旦赋值或构造完成，常量将不能被修改。 三、构造方法首先，如果类或者结构体中的所有存储属性都有默认值，那个如果开发者不提供构造方法，Swift也会自动生成一个默认构造方法，无参的init()，在进行类型的实例化时，将默认构造所有存储属性都是默认值的实例。示例如下： 1234567class MyClassTwo &#123; var count = 10 var name = &quot;HS&quot;&#125;//默认的init()构造方法var obj = MyClassTwo()print(obj.count,obj.name) 结构体会比较特殊，就算没有为其存储属性设置初值，它也会自动生成构造方法，这个构造方法中会自带所有没有赋默认值的属性名作为参数，示例如下： 12345struct Shape &#123; var center:(Int,Int) var name:String&#125;var shape = Shape(center: (1,1), name: &quot;circle&quot;) 还有一点需要注意，对于值类型(结构体，枚举)，如果开发者自定义了一个构造方法，则默认的构造方法将会失效，这样设计是为了安全性考虑，防止误用到系统的默认构造方法。并且，对于值类型(结构体，枚举)的构造方法，是支持嵌套调用的，示例如下： 123456789101112struct Shape &#123; var center:(Int,Int) var name:String init() &#123; center = (0,0) name = &quot;HS&quot; &#125; init(param:String)&#123; self.init() &#125;&#125;var shape = Shape(param: &quot;&quot;) 四、类的Designated构造方法与Convenience构造方法在前面的一篇博客中，我曾经专门讨论过Swift中的构造方法，博客地址如下，可供参考： Swift中的构造方法解析：http://my.oschina.net/u/2340880/blog/660134。 Designated构造方法也被称为指定构造方法，它是类的核心构造方法，指定构造方法将完成类中所有需要构造或赋值过程。如果一个类继承于另一个类而来，则指定构造方法需要调用父类的构造方法来完成父类中属性的初始。Convenience工作方法也被称为便利构造方法，其主要作为辅助的构造方法存在，便利构造方法需要调用类中的指定构造方法来完成构造，从这一点看，实际上类是通过便利构造方法来实现类似值类型的构造方法的嵌套使用。指定构造方法不需要多余关键字来修饰，其默认就是Designated类型的，便利构造方法需要使用convenience关键字类修饰，示例如下： 12345678910111213class MyClassTwo &#123; var count = 10 var name = \"HS\" init(name:String)&#123; self.name = name &#125; convenience init(count:Int)&#123; self.init(name:\"HS\") self.count = count &#125;&#125;var obj = MyClassTwo(count:5)print(obj.count,obj.name) 类的构造方法需要遵守下面3条规则： 1.指定构造方法必须调用其父类的指定构造方法。 2.便利构造方法必须调用同类中的其他构造方法。 3.便利构造方法调用到最上层必须调用一个指定构造方法。 语言文档中提供如下示例图来结束指定构造方法和便利构造方法的关系： 五、构造方法的安全特性Swift是一种十分注重类型安全的语言，这种语言特性的优势在于类在实例化后，所有的属性都是开发者明确可控的。Swift的编译器在类的构造方法中会进行4中安全性检查： 检查1：指定构造器中必须完成所有存储属性的赋值后才能调用父类的指定构造方法，示例如下： 1234567class MyClassThree: MyClassTwo &#123; var param:Int init()&#123; param = 100 super.init(name: \"HS\") &#125;&#125; 检查2：子类如果要自定义父类中存储属性的值，必须要调用父类的构造方法之后设置，示例如下： 123456789class MyClassThree: MyClassTwo &#123; var param:Int init()&#123; param = 100 super.init(name: \"HS\") //重设继承父类属性的name值 self.name = \"New\" &#125;&#125; 检查3：如果便利构造方法中需要重新设置某些属性的值，必须在调用指定构造方法之后设置，否则会被覆盖。 检查4：在完成父类构造方法之前，不能使用self来引用属性。 六、构造方法的继承Swift和Objective-C有很大不同，其构造方法不会被子类无条件的继承。Swift中类的构造方法的继承遵守下面两个原则： 1.如果子类没有定义任何的指定构造方法，则子类会默认继承父类所有的指定构造方法。 2.如果子类中提供了父类所有指定构造方法，无论是覆写的还是继承的，则子类会默认继承下来父类的便利构造方法。 上面两个原则可能有些难以理解，第1个原则实际上也说明子类如果定义了自己的指定构造方法，或者覆写了父类的某个指定构造方法，则子类不再继承父类所有的指定构造方法。第2个原则可以这样理解：因为所有便利构造方法最终都要调用到指定构造方法，所以只要子类中有提供这个便利构造方法需要调用的指定构造方法，这个便利构造方法就会被继承。 重写父类的指定构造方法需要使用override关键字，但是，便利构造方法并不存在重写的概念，因为其必须调用本类的其他构造方法，因此无论子类中定义的便利构造方法与父类是否相同，都是子类独立的便利构造方法。 七、可失败构造方法在开发中还会遇到一种情况，某些构造方法需要传入一些参数，当参数不符合要求时，此构造过程可能会失败，这时，开发者可以使用可失败的构造方法来进行类型的构造，例如在类中创建可失败的构造方法示例示例如下： 12345678910111213141516class MyClassThree: MyClassTwo &#123; var param:Int init()&#123; param = 100 super.init(name: \"HS\") //重设继承父类属性的name值 self.name = \"New\" &#125; init?(suc:Bool)&#123; guard(suc)else&#123; return nil &#125; param=1 super.init(name: \"1\") &#125;&#125; 八、必要构造方法如果某些构造方法是类与其子类都必须实现的，则可以使用required关键字来将其修饰为必要的构造方法，子类必须继承或者覆写父类的必要构造方法，示例如下： 12345678910111213141516class MyClassThree: MyClassTwo &#123; var param:Int required init()&#123; param = 100 super.init(name: \"HS\") //重设继承父类属性的name值 self.name = \"New\" &#125; init?(suc:Bool)&#123; guard(suc)else&#123; return nil &#125; param=1 super.init(name: \"1\") &#125;&#125; 还有一点需要注意，如果某些属性的值设置十分复杂，开发者可以使用闭包的方式来为属性设置初始值，示例如下： 12345678910111213141516171819class MyClassThree: MyClassTwo &#123; //注意 闭包的后面必须加()，否则会将param当成一个闭包属性来处理 var param:Int = &#123; return 6*6+6 &#125;() required init()&#123; param = 100 super.init(name: \"HS\") //重设继承父类属性的name值 self.name = \"New\" &#125; init?(suc:Bool)&#123; guard(suc)else&#123; return nil &#125; param=1 super.init(name: \"1\") &#125;&#125; 九、析构方法当类实例将要被释放时，系统会自动调用类的析构方法，析构方法deinit()没有参数和返回值，并且只有类有析构方法，开发者可以在其中进行一些资源的释放操作，当var类型变量被赋值为nil时，实例会被释放。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift专题讲解十四——继承","slug":"214Swift专题讲解十四——继承","date":"2016-05-17T16:00:00.000Z","updated":"2021-07-08T09:43:35.492Z","comments":true,"path":"2016/05/18/214Swift专题讲解十四——继承/","link":"","permalink":"http://huishao.cc/2016/05/18/214Swift专题讲解十四——继承/","excerpt":"","text":"Swift专题讲解十四——继承一、引言Swift中，一个类可以从另一个类继承方法、属性、下标及其他特性。当一个类继承于另一个类时，这个类被称为子类，所继承的类被称为父类。在Swift中，继承是类区别于其他类型的主要特征。子类除了可以调用父类的属性，下标，方法外，其也可以对父类的属性，下标，方法进行覆写。 二、定义一个基类不继承于任何类的类被称为基类，示例如下： 123456class Shape &#123; var center:(Double,Double) init()&#123; center = (0,0) &#125;&#125; 上面代码定义了一个图形类，其中定义了一个中心点，任何图形都会有中心点，所以把其作为基类属性。 三、定义一个子类图形基类可以派生出许多图形子类，例如矩形，圆形等，示例代码如下： 12345678class Circle: Shape &#123; var Radio:Double = 0&#125;class Rect: Shape &#123; var size:(Double,Double)=(0,0)&#125;var circle = Circle()circle.center = (1,1) 可以看到，Circle类从父类中继承到了center属性。默认子类也会继承父类的构造方法，如果子类需要实现自己的构造方法，可以对父类的方法进行覆写，使用override关键字： 1234567class Rect: Shape &#123; var size:(Double,Double)=(0,0) override init()&#123; super.init() super.center = (1,1) &#125;&#125; 通过super关键字可以调用父类的属性和方法，同样，也可以使用override关键字来对属性进行get和set的覆写。同样也可以重写属性的观察期willset和didset。 四、final关键字在开发中很多情况下为了安全考虑，有些方法和属性是不允许子类进行覆写的，使用final声明这些属性，方法或者下标可以起到这样的作用。示例如下： 123456class Shape &#123; final var center:(Double,Double) init()&#123; center = (0,0) &#125;&#125; 如果想将某个类设置为不可继承的，可以将此类使用final关键字修饰，示例如下： 123456final class Shape &#123; final var center:(Double,Double) init()&#123; center = (0,0) &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题十二——方法","slug":"212Swift讲解专题十二——方法","date":"2016-05-16T16:00:00.000Z","updated":"2021-07-08T09:42:14.711Z","comments":true,"path":"2016/05/17/212Swift讲解专题十二——方法/","link":"","permalink":"http://huishao.cc/2016/05/17/212Swift讲解专题十二——方法/","excerpt":"","text":"Swift讲解专题十二——方法一、引言方法只是一个术语，其实就是将函数与特定的类型结合，类、结构体、枚举都可以定义方法，方法又分为实例方法和类型方法，类型方法类似于Objective-C中的类方法。Swift和Objective-C的一大不同是，Objective-C只有在类中可以定义方法。 二、实例方法基础实例方法的语法和函数完全一致，其和具体类型的实例所关联，实例方法在调用时由类型的实例点语法进行调用来完成一些功能模块。示例如下： 12345678910class Math &#123; //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; return param1+param2 &#125;&#125;//创建类型实例var obj = Math()//调用方法进行计算obj.add(5, param2: 5) 与Objective-C类似，Swift中每一个类的实例中都隐藏含有一个self属性，self属性就是实例本身，开发者可以在实例方法中使用self来调用属性或者其他实例方法，示例如下： 1234567891011class Math &#123; //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; return param1+param2 &#125; func mul(param1:Double,param2:Double) -&gt; Double &#123; //使用self调用实例方法 self.add(param1, param2: param2) return param1*param2 &#125;&#125; 然而，Swift并不要求开发者必须写self，默认情况下，开发者可以直接省略self来调用属性和方法： 1234567891011class Math &#123; //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; return param1+param2 &#125; func mul(param1:Double,param2:Double) -&gt; Double &#123; //使用self调用实例方法 add(param1, param2: param2) return param1*param2 &#125;&#125; 有一种情况需要注意，对于属性的调用，如果方法中的参数名和类实例的属性名相同，则必须使用self来调用类的实例属性，防止歧义的产生： 12345678910111213class Math &#123; var param1 = 10.0 //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; //这里将使用param1=10，如果不加self 将使用参数中的param1 return self.param1+param2 &#125; func mul(param1:Double,param2:Double) -&gt; Double &#123; //使用self调用实例方法 add(param1, param2: param2) return param1*param2 &#125;&#125; 三、在实例方法中修改值类型的值首先需要清楚一个概念，Swift中有两种类型，值类型和引用类型，具体在类、结构体、枚举一节中有相关介绍，这里需要注意的是，对于值类型，即结构体和枚举，其并不能直接在实例方法中修改实例属性的值，Swift中提供了另一种方式，如果真有如此的需求，开发者可以使用mutating关键字将实例方法声明成可变的，实际上，如果在可变的实例方法中修改了值类型属性的值，是会创建一个新的实例来代替原来的实例的，示例如下： 123456789101112struct Point &#123; var x:Double var y:Double mutating func move(x:Double,y:Double) &#123; self.x+=x self.y+=y &#125;&#125;var point = Point(x: 1, y: 1)print(point)point.move(3, y: 3)print(point) 在值类型实例的可变方法中修改属性的值，实际上就是创建了一个新的实例，上面的写法和下面的写法原理是一样的： 1234567struct Point &#123; var x:Double var y:Double mutating func move(x:Double,y:Double) &#123; self = Point(x: self.x+x,y: self.y+y) &#125;&#125; 四、类型方法正如实例方法是通过类型的实例来进行调用的，类型方法是通过类型直接来调用的，相比于实例方法，类型方法中的self指当前类型，同样开发者可以使用self来区别类型属性和类型方法中的参数。使用Static关键字来进行类型方法的创建： 1234567891011struct Point &#123; var x:Double var y:Double mutating func move(x:Double,y:Double) &#123; self = Point(x: self.x+x,y: self.y+y) &#125; static func name()&#123; print(&quot;Point&quot;) &#125;&#125;Point.name() 如果是在类中创建类型方法，若此方法可以被子类进行重写，则应该使用class关键字来创建，示例如下： 1234567891011121314151617class Math &#123; var param1 = 10.0 //完成加法功能的实例方法 func add(param1:Double,param2:Double)-&gt;Double&#123; //这里将使用param1=10，如果不加self 将使用参数中的param1 return self.param1+param2 &#125; func mul(param1:Double,param2:Double) -&gt; Double &#123; //使用self调用实例方法 add(param1, param2: param2) return param1*param2 &#125; class func name()&#123; print(&quot;Math&quot;) &#125;&#125;Math.name() 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题十三——下标访问","slug":"213Swift讲解专题十三——下标访问","date":"2016-05-16T16:00:00.000Z","updated":"2021-07-08T09:42:52.248Z","comments":true,"path":"2016/05/17/213Swift讲解专题十三——下标访问/","link":"","permalink":"http://huishao.cc/2016/05/17/213Swift讲解专题十三——下标访问/","excerpt":"","text":"Swift讲解专题十三——下标访问一、引言在以前的博客中，讨论过在Objective-C中，通过下标的方式访问自定义数据模型的方法。Objective-C中主要是通过实现一系列方法来使自定义的数据类型支持下标的访问方式，博客地址如下： 在Objective-C中使用下标访问自定义数据模型：http://my.oschina.net/u/2340880/blog/632294。 Swift中的Array，Dictionary类型可以通过下标或者键值的方式来进行数据的访问，实际上在Swift的语法中，下标可以定义在类、结构体、枚举中。开发者可以通过下标的方式来对属性进行访问而不用使用专门的存取方法。并且定义的下标不限于一维，开发者可以定义多维的下标来满足需求。 二、下标的语法结构下标使用subscript来定义，其有些类似于方法，参数和返回值分别作为下标入参和通过下标所取的值。但是在subscript实现部分，又十分类似于计算属性，其需要实现一个get块和可选实现一个set块，get块用于使用下标取值，set块用于使用下标设置值，因此，subscript结构更像是计算属性和方法的混合体，示例如下： 12345678910111213class MyClass &#123; var array=[1,1,1,1,1] subscript(param1:Int)-&gt;Int&#123; set&#123; array[param1] = newValue &#125; get&#123; return array[param1] &#125; &#125;&#125;var obj = MyClass()obj[0] = 3 开发者可以只编写get块来实现只读的下标访问。对于多维下标的访问方式，只需修改subscript中的参数个数即可，示例如下： 12345678910111213class MyClass &#123; var array=[1,1,1,1,1] subscript(param1:Int,param2:Int)-&gt;Int&#123; set&#123; array[param1] = newValue &#125; get&#123; return array[param1] &#125; &#125;&#125;var obj = MyClass()obj[0,1] = 3 三、下标的特性Swift中的下标可以自定参数个数和参数类型，返回数据的类型开发者也可以进行自定义。但是有一点需要注意，下标的参数不能设置默认值，也不能设置为in-out类型。多维下标常用语行列数据的访问，示例如下： 1234567891011121314151617class SectionAndRow &#123; var array:Array&lt;Array&lt;Int&gt;&gt; = [ [1,2] ,[3,4] ,[5,6] ,[7,8] ] subscript(section:Int,row:Int)-&gt;Int&#123; get&#123; let temp = array[section] return temp[row] &#125; &#125; &#125;var data = SectionAndRow()//通过二维下标取值data[1,1] 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题十一——属性","slug":"211Swift讲解专题十一——属性","date":"2016-05-15T16:00:00.000Z","updated":"2021-07-08T09:41:26.953Z","comments":true,"path":"2016/05/16/211Swift讲解专题十一——属性/","link":"","permalink":"http://huishao.cc/2016/05/16/211Swift讲解专题十一——属性/","excerpt":"","text":"Swift讲解专题十一——属性一、引言属性将值与类，结构体，枚举进行关联。Swift中的属性分为存储属性和计算属性两种，存储属性用于存储一个值，其只能用于类与结构体，计算属性用于计算一个值，其可以用于类，结构体和枚举。 二、存储属性存储属性使用变量或者常量来存储一个值，在声明存储属性时，可以为其设置一个默认值，也可以在构造示例是进行值的设置，属性可以通过点语法来访问，结构体的存储属性示例代码如下： 1234567struct MyStruct &#123; var property1 = 1 var property2:Int&#125;var obj = MyStruct(property1: 1, property2: 2)//通过点语法进行属性的访问print(obj.property1,obj.property2) 如上结构体，如果有属性被声明成let常量，则此属性不能够被修改。还有一点需要注意，如果在创建结构体的实例时，使用的是let进行创建，则即便结构体中的属性是变量也不可进行修改。这和类有很大区别。 还有一类存储属性叫做延时存储属性，可以设想一下这样的情形，类的某些属性可能并不是在每次类实例后都会用到，并且有些属性的构造可能会消耗大量的时间，这时一个比较聪明的设计便是在类进行实例化时，这类属性并不被构造，当次类的实例使用到这个属性时，这个属性才被构造出来，这样的属性被称为延时存储属性，使用lazy关键字来声明，示例如下： 1234567891011121314//第一个类class MyClass1 &#123; init()&#123; print(&quot;MyClass1类被构造&quot;) &#125;&#125;class MyClass2 &#123; //声明为延时存储属性 lazy var body = MyClass1()&#125;//在构造MyClass2时 并不会进行body属性的构造 不会有打印信息var obj2 = MyClass2()//执行下面代码后 会有打印信息 使用body属性使得body被构造obj2.body 注意，如果在多个线程中对延时构造属性进行使用，不能保证其只被构造一次。 三、计算属性简单的理解，计算属性并不是独立的用于存储值的属性，开发者甚至可以将其理解为一个计算方法，其主要用于通过计算来获取或者设置其他存储属性的值。示例如下： 123456789101112131415161718192021struct Circle &#123; //圆心 var center:(Double,Double) //半径 var r:Double //周长 将其作为计算属性 var l:Double&#123; get&#123; //计算圆的周长 return 2.0*r*M_PI &#125; set&#123; //通过周长重新计算半径 默认传入的参数名为newValue r = newValue/(M_PI*2) &#125; &#125;&#125;var circle = Circle(center: (0,0), r: 2)print(circle.l)circle.l=24print(circle.r) 通过上面的演示代码可以了解，l属性并非是一个新的属性，只是通过r属性来计算出l，或者通过l来反推出r，其中有一点需要注意，计算属性中可以创建两个代码块set和get，set代码块是可选的，其中会默认生成一个newValue参数来传递外界传进来的数据，get代码块是必须要实现的，当然也可以只实现get代码块，这时这个属性将是只读的计算属性，只可以获取，不能够设置。还有一点需要注意，开发者也可以在set代码块后面自定义一个参数名来接收外界传入的参数，示例如下： 1234567891011121314151617struct Circle &#123; //圆心 var center:(Double,Double) //半径 var r:Double //周长 将其作为计算属性 var l:Double&#123; get&#123; //计算圆的周长 return 2.0*r*M_PI &#125; set(newL)&#123; //通过周长重新计算半径 默认传入的参数名为newValue r = newL/(M_PI*2) &#125; &#125;&#125; 只读的计算属性可以进行进一步的简写，因为没有了set代码块，所以关键字get和括号也可以给省略掉，不会产生歧义，示例如下： 1234567struct Point &#123; var x:Double var y:Double var center:(Double,Double)&#123; return (x/2,y/2) &#125;&#125; 四、属性监听器Swift中的计算属性中的get和set方法和Objective-C中的get和set方法其实并非是一回事，Objective-C提供set和get方法可以让开发者在属性将要获取或者设置的时候来进行一些自定义的操作，这部分的开发需求在Swift中通过属性监听器来实现。 属性监听器有willSet和didSet两种，willSet在属性值将要变化时执行，didSet在属性值已经变化时执行，并且其中会传入变化前后的值。示例如下： 123456789101112131415161718192021struct Point &#123; var x:Double var y:Double&#123; willSet&#123; print(&quot;将要进行值的更新设置,新的值是:&quot;,newValue) &#125; didSet&#123; print(&quot;已经进行值得更新设置,旧的值是:&quot;,oldValue) &#125; &#125; var center:(Double,Double)&#123; return (x/2,y/2) &#125;&#125;var point = Point(x: 3, y: 3)//将打印/* 将要进行值的更新设置,新的值是: 4.0 已经进行值得更新设置,旧的值是: 3.0 */point.y=4 willSet中默认会生成一个命名为newValue的参数，didSet中会默认生成一个命名为oldValue的参数，也可以自定义这些参数的命名，示例如下： 1234567891011121314struct Point &#123; var x:Double var y:Double&#123; willSet(new)&#123; print(&quot;将要进行值的更新设置,新的值是:&quot;,new) &#125; didSet(old)&#123; print(&quot;已经进行值得更新设置,旧的值是:&quot;,old) &#125; &#125; var center:(Double,Double)&#123; return (x/2,y/2) &#125;&#125; 五、实例属性与类型属性实例属性是针对与一个类型的实例，类型属性则是直接针对与类型。 每对类型进行一次实例化，其实例都有一套独立的实例属性，而类型属性则是类的所有实例所共用的，在Objective-C中，通常使用全局的属性来实现这样的效果，在Swift中，使用static关键字来声明类型属性，示例如下： 12345678910111213141516171819202122struct Point &#123; //类型存储属性 static var name:String = &quot;Point&quot; //类型计算属性 static var subName:String&#123; return &quot;sub&quot;+name &#125; var x:Double var y:Double&#123; willSet(new)&#123; print(&quot;将要进行值的更新设置,新的值是:&quot;,new) &#125; didSet(old)&#123; print(&quot;已经进行值得更新设置,旧的值是:&quot;,old) &#125; &#125; var center:(Double,Double)&#123; return (x/2,y/2) &#125;&#125;//类型属性 通过类型点语法来获取print(Point.name,Point.subName) 注意，有一种特殊的情况是针对于类的类型计算属性，如果其需要子类进行继承重写，需要将static关键字，换成class关键字，示例如下： 12345678910class SomeClass &#123; static var storedTypeProperty = &quot;Some value.&quot; static var computedTypeProperty: Int &#123; return 27 &#125; //支持子类进行重写的计算属性 class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题十——类与结构体","slug":"210Swift讲解专题十——类与结构体","date":"2016-05-15T16:00:00.000Z","updated":"2021-07-08T09:40:37.024Z","comments":true,"path":"2016/05/16/210Swift讲解专题十——类与结构体/","link":"","permalink":"http://huishao.cc/2016/05/16/210Swift讲解专题十——类与结构体/","excerpt":"","text":"Swift讲解专题十——类与结构体一、引言Swift中的类与结构体十分相似，和Objective-C不同的是，Swift中的结构体不仅可以定义属性，也可以像类一样为其定义方法。 Swift中的类与结构体有如下相似点： 1.定义属性来存储值。 2.定义函数来提供功能。 3.通过定义下标语法使用下标的方式取值。 4.定义构造方法来对其进行初始化。 5.通过扩展来在原始基础上添加功能。 6.通过协议来定义实现标准。 当然类和结构体也有许多不同点，下面这些功能是类独有的，结构体没有： 1.通过继承来创建类的子类。 2.在运行时允许对类的实例进行类型的检查和解释。 3.析构方法可以释放被类引用的资源。 4.通过引用计数允许一个类实例的多处引用。 当开发者在代码中传递这些实例时，结构体总是被复制，而类则是被引用。这是结构体和类的最本质区别。 二、类与结构体的定义类与结构体在定义语法上相似，示例代码如下： 1234567891011121314class MyClass &#123; var name = &quot;HS&quot; var age = 25&#125;struct MyStruct &#123; var param1:Int var param2:String&#125;//创建类的实例var obj1 = MyClass()//创建结构体的实例 所有结构体会默认生成一个逐个设置属性的构造方法 而类不会var obj2 = MyStruct(param1: 1,param2: &quot;1&quot;)//可以通过点语法来获取类或者结构体中的属性值print(obj1.age,obj2.param1) 通过实例间的传递，可以证明Swift中类被引用于结构体被复制这样的特点，示例如下： 123456789//将类实例传递给另一个变量var obj3 = obj1//将结构体实例传递给另一个变量var obj4 = obj2//修改变量的值obj3.name = &quot;NewHS&quot;obj4.param1 = 2//将 打印 NewHS 1 //说明类是被引用的 结构体则被赋值print(obj1.name,obj2.param1) 注意：在实例传递时同样采用复制原理的还有枚举类型。 由于类是通过引用来进行传递，Swift中还提供了一种运算符用来比较两个实例变量或常量是否指向同一个引用，示例如下： 12345if obj1===obj3&#123; print(&quot;same refer&quot;)&#125;else if obj1 !== obj3 &#123; print(&quot;not same refer&quot;)&#125; 实际上，===与!==运算符比较的是指针内容。 三、类和结构体的选择由于类和结构体有着不同的传递机制，因此其也适用于不同的开发任务，下面这些情况下，官方推荐开发者使用结构体来创建数据类型： 1.该数据类型封装少量的简单数据值。 2.该类型数据来传递时，应该被复制。 3.该类型中定义的数据类型在传递时也应该被赋值。 4.不需要通过继承另一个数据类型而来。 除了上面列举的一些情况，其它情况下，都推荐开发者使用类来描述数据，这也是开发中最后常用的手段。 扩展：在Swift中，Array，String，Dictionary这些类型都是采用的结构体的方式来实现，并不是采用引用的方式，NSString，NSArray，NSDictionary这些Objective-C的类是采用引用的方式实现的，因此在Swift中，String，Array，Dictionary在传递时总是被赋值。然而官方文档中还有一句话十分有意思： The description above refers to the “copying” of strings, arrays, and dictionaries. The behavior you see in your code will always be as if a copy took place. However, Swift only performs an actual copy behind the scenes when it is absolutely necessary to do so. Swift manages all value copying to ensure optimal performance, and you should not avoid assignment to try to preempt this optimization. 大致意思是，在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题九——枚举","slug":"209Swift讲解专题九——枚举","date":"2016-05-14T16:00:00.000Z","updated":"2021-07-08T09:39:52.797Z","comments":true,"path":"2016/05/15/209Swift讲解专题九——枚举/","link":"","permalink":"http://huishao.cc/2016/05/15/209Swift讲解专题九——枚举/","excerpt":"","text":"Swift讲解专题九——枚举一、引言在Objective-C语言中，没有实际上是整型数据，Swift中的枚举则更加灵活，开发者可以不为其分配值类型把枚举作为独立的类型来使用，也可以为其分配值，可以是字符，字符串，整型或者浮点型数据。 二、枚举语法Swift中enum关键字来进行枚举的创建，使用case来创建每一个枚举值，示例如下： 123456789101112//创建姓氏枚举,和Objective-C不同，Swift枚举不会默认分配值enum Surname &#123; case 张 case 王 case 李 case 赵&#125;//创建一个枚举类型的变量var myName = Surname.张//如果可以自动推断出类型 则枚举类型可以省略myName = .李var myName2:Surname = .王 同样可以将枚举值都写在同一个case中，使用逗号分隔： 123enum Planet &#123; case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125; 枚举经常会和Switch语句结合使用，示例如下： 12345678910switch myName &#123;case .张: print(&quot;姓氏张&quot;)case .王: print(&quot;姓氏王&quot;)case .李: print(&quot;姓氏李&quot;)case .赵: print(&quot;姓氏赵&quot;)&#125; 三、枚举的相关值Swift中的枚举有一个很有意思的特点，其可以设置一些相关值，通过相关值，开发者可以从公用的枚举值中获取到传递的额外相关值，示例如下： 12345678910111213141516171819202122enum Number &#123; case one(count:Int) case two(count:Int) case three(count:Int) case four(count:Int)&#125;var num = Number.one(count: 5)switch num &#123; //获取num的相关值case Number.one(let count): print(count)default: print(num)&#125;//如果一个枚举值所有的相关中都是常量，let关键字也可以提取到括号外面switch num &#123; //获取num的相关值case let Number.one(count): print(count)default: print(num)&#125; 有了相关值这样的句法，大大的增加了枚举的灵活性，例如一个形状枚举，可能的枚举值有矩形，圆形等，矩形的枚举值就可以提供宽高的相关值，圆形的枚举值就可以提供半径的相关值，是开发更加灵活。 四、枚举的原始值原始值也可以理解为为枚举设置一个具体类型，示例如下： 1234567enum Char:String &#123; case a = &quot;A&quot; case b = &quot;B&quot; case c = &quot;C&quot;&#125;//”A“var char = Char.a.rawValue 注意，如果枚举是Int类型的，则类似于Objective-C，枚举的原始值会从第一个开始之后依次递增： 1234567enum Char:Int&#123; case a = 0 case b case c&#125;//1var char = Char.b.rawValue 同样可以通过原始值的方式来进行枚举对象的创建，示例如下： 123456789enum Char:Int&#123; case a = 0 case b case c&#125;//1var char = Char.b.rawValue//bvar char2 = Char(rawValue:1) 在通过原始值进行枚举对象创建的时候，有可能创建失败，例如传入的原始值并不存在，这时会返回Optional值nil。 四、递归枚举递归枚举是Swift枚举中一个难于理解的地方，实际上也并非十分难于理解，开发者只要明白枚举的实质，递归枚举就很好理解。首先，递归是一种算法，可以简单理解为自己调用自己，而枚举实际上并不是函数，它并不执行某项运算，它只是表达一个数据或者说他也可以表达一种表达式，示例如下： 123456enum Expression &#123; //表示加 case add //表示减 case mul&#125; 前面有提到过相关值的概念，因此，对于上述例子，可以为add和mul枚举值添加两个相关值作为参数。 123456enum Expression &#123; //表示加 case add(Int,Int) //表示减 case mul(Int,Int)&#125; 如此，如下的写法实际上就可以代表一个5+5的表达式： 1var exp = Expression.add(5, 5) 还是需要强调一点，这个exp只是表达了5+5这样一个约定的表达式，它并没有真正进行5+5的运算。现在问题就来了，使用如上的枚举，怎样来表达类似(5+5)*5这样的复合表达式呢？可以使用递归枚举来实现，即将(5+5)作为枚举值得相关值再次创建枚举，改造如下： 123456789101112enum Expression &#123; //单值数据 case num(Int) //表示加 indirect为递归枚举关键字 indirect case add(Expression,Expression) //表示减 indirect case mul(Expression,Expression)&#125;var exp1 = Expression.num(5)var exp2 = Expression.num(5)var exp3 = Expression.add(exp1, exp2)var exp4 = Expression.mul(exp1, exp3) 上面exp4实际上就表达了(5+5)*5这样一个过程，注意递归的枚举值必须加上indirect关键字来声明。处理递归枚举最好的方式是通过递归函数，示例如下： 12345678910111213141516func expFunc(param:Expression) -&gt; Int &#123; //进行枚举判断 switch param &#123; //如果是单独数字 直接返回 case .num(let p): return p //如果是加法 则进行递归加 case .add(let one, let two): return expFunc(one)+expFunc(two) //如果是乘法 则进行递归乘 case .mul(let one, let two): return expFunc(one)*expFunc(two) &#125;&#125;//50expFunc(exp4) 如果枚举中所有的case都是可递归的，可以将整个枚举声明为可递归的： 12345678indirect enum Expression &#123; //单值数据 case num(Int) //表示加 indirect为递归枚举关键字 case add(Expression,Expression) //表示减 case mul(Expression,Expression)&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题八——闭包","slug":"208Swift讲解专题八——闭包","date":"2016-05-13T16:00:00.000Z","updated":"2021-07-08T09:39:09.047Z","comments":true,"path":"2016/05/14/208Swift讲解专题八——闭包/","link":"","permalink":"http://huishao.cc/2016/05/14/208Swift讲解专题八——闭包/","excerpt":"","text":"Swift讲解专题八——闭包一、引言Swift中的闭包是有一定功能的代码块，这十分类似于Objective-C中的block语法。Swift中的闭包语法风格十分简洁，其作用和函数的作用相似。 二、从一个系统函数看闭包Swift标准函数库中提供了一个sort排序函数，对于已经元素类型的数组，调用sort函数会进行重新排序并返回新的排序后的数组。这个sort函数可以接收一个返回值为Bool类型的闭包，来确定第一个元素是否排在第二个元素前面。代码示例如下： 123456789101112var array = [3,21,5,2,64]func func1(param1:Int,param2:Int) -&gt; Bool &#123; return param1&gt;param2&#125;//通过传入函数的方式//array = [64,21,5,3,2]array = array.sort(func1)//通过闭包的方式//array = [2,3,5,21,64]array = array.sort(&#123;(param:Int,param2:Int)-&gt;Bool in return param&lt;param2 &#125;) Swift语言有一个很显著的特点就是简洁，可以通过上下文推断出类型的情况一般开发都可以将类型的书写省略，这也是Swift语言设计的一个思路，由于闭包是作为函数的参数传入函数中的，因为函数参数的类型是确定，因此闭包的类型是可以被编译器推断出来的，开发者也可以将闭包的参数类型和返回值省略，上面的代码可以简写如下： 12//将闭包的参数类型和返回值都省略array = array.sort(&#123;(p1,p2) in return p1&gt;p2&#125;) 实际上，如果闭包中的函数体只有一行代码，可以将return关键字也省略，这时会隐式的返回此行代码的值，如下： 1array = array.sort(&#123;(p1,p2) in p1&gt;p2&#125;) 看到上面的表达式，是不是有点小震惊，闭包表达式竟然可以简写成这样！然而，你还是小看的Swift开发团队，后面的语法规则会让你明白什么是简洁的极致。可以看到上面的代码实现还是有3部分：参数和返回值，闭包关键字，函数体。参数和返回值即是参数列表，p1，p2，虽然省略了参数类型和返回值类型，但这部分的模块还在，闭包关键字即是in，它用来表示下面将是闭包的函数体，p1&gt;p2即是函数体，只是这里省略了return关键字。闭包中既然参数类型和返回值类型编译器都可以自己推断出来，那么参数的数量编辑器也是可以自行推断的，因此，参数列表实际上也是多余的，闭包中会自动生成一些参数名称，和实际的参数数量向对应，例如上面sort函数中的闭包有两个参数，系统会自动生成$0和$1这两个参数名，开发者可以直接使用，因为参数列表都会省略了，那么也不再需要闭包关键字in来分隔参数列表与函数体，这时，闭包的写法实际上变成了如下的模样： 1array = array.sort(&#123;$0&lt;$1&#125;) 你没有看错，加上左右的大括号，一共7个字符，完成了一个排序算法。除了Swift，我不知道是否还有第二种语言可以做到。抛开闭包不说，Swift中还有一种语法，其可以定义类型的运算符方法，例如String类型可以通过=，&lt;，&gt;来进行比较，实际上是String类中实现了这些运算符方法，在某种意义上说，一个运算符即类似与一个函数，那么好了，sort函数中需要传入的方法对于某些类型来说实际上只是需要一个运算符，示例如下： 1array = array.sort(&gt;) 这次你可以真的震惊了，完成排序新算法只需要一个字符，不折不扣的一个字符。 三、Swift中闭包的更多特点Swift中的闭包还有一个有趣的特点，首先闭包是作为参数传入另一个函数中的，因此常规的写法是将闭包的大括号写在函数的参数列表小括号中，如果闭包中的代码很多，这时在代码结构上来看会变得并不太清晰，为了解决这个问题，Swift中这样规定：如果这个闭包参数是函数的最后一个参数，开发者可以将其拉出小括号，在函数尾部实现闭包代码，示例如下： 12345678//闭包结尾func func2(param1:Int,param2:()-&gt;Void)-&gt;Void&#123; param2() print(&quot;调用了func2函数&quot;)&#125;func2(0)&#123; print(&quot;闭包中的内容&quot;)&#125; 如果一个函数中只有一个参数，且这个参数是一个闭包，那么开发者使用闭包结尾这种写法，完全可以将函数的参数列表小括号也省略掉，示例如下： 1234567func func3(param:()-&gt;Void)-&gt;Void&#123; param() print(&quot;调用了func3函数&quot;)&#125;func3&#123; print(&quot;闭包中的内容&quot;)&#125; Swift中还有一个闭包逃逸的概念，这个很好理解，当闭包作为参数传递进函数时，如果这个闭包只在函数中被使用，则开发者可以将这个闭包声明成非逃逸的，即告诉系统当此函数结束后，这个闭包的声明周期也将结束，这样做的好处是可以提高代码性能，将闭包声明称非逃逸的类型使用@noescape关键字，示例如下： 1234567func func3(@noescape param:()-&gt;Void)-&gt;Void&#123; param() print(&quot;调用了func3函数&quot;)&#125;func3&#123; print(&quot;闭包中的内容&quot;)&#125; 逃逸的闭包常用于异步的操作，例如这个闭包是异步处理一个网络请求，只有当请求结束后，闭包的声明周期才结束。非逃逸的闭包还有一个有趣的特点，在其内部如果需要使用self这个关键字，self可以被省略。 闭包也可以被自动的生成，这种闭包被称为自动闭包，自动闭包可以自动将表达式封装成闭包，开发者不需要再写闭包的大括号格式，自动闭包不接收参数，返回值为其中表达式的值。示例如下： 1234567891011121314151617181920212223242526272829//自动闭包演示var list = [1,2,3,4,5,6]//创建一个显式闭包let closures = &#123; list.removeFirst() list.append(7)&#125;//将打印[1,2,3,4,5,6]print(list)//执行闭包closures()//将打印[2,3,4,5,6,7]print(list)func func4(closure:()-&gt;Void) -&gt; Void &#123; //执行显式的闭包 closures()&#125;func func5(@autoclosure auto:()-&gt;Void) -&gt; Void &#123; //执行自动闭包 auto()&#125;//显式闭包 需要大括号func4(closures)//将打印[3,4,5,6,7,7]print(list)//将表达式自动生成闭包func5(list.append(8))//将打印[3,4,5,6,7,7,8]print(list) 自动闭包默认是非逃逸的，如果要使用逃逸的闭包，需要手动声明，如下： 1234func func5(@autoclosure(escaping) auto:()-&gt;Void) -&gt; Void &#123; //执行自动闭包 auto()&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题七——函数","slug":"207Swift讲解专题七——函数","date":"2016-05-12T16:00:00.000Z","updated":"2021-07-08T09:38:02.985Z","comments":true,"path":"2016/05/13/207Swift讲解专题七——函数/","link":"","permalink":"http://huishao.cc/2016/05/13/207Swift讲解专题七——函数/","excerpt":"","text":"Swift讲解专题七——函数一、引言函数是有特定功能的代码段，函数会有一个特定的名称调用时来使用。Swift提供了十分灵活的方式来创建与调用函数。事实上在Swift，每个函数都是一种类型，这种类型由参数和返回值来决定。Swift和Objective-C的一大区别就在于Swift中的函数可以进行嵌套。 二、函数的创建与调用函数通过函数名，参数和返回值来定义，参数和返回值决定一个函数的类型，在调用函数时，使用函数名来进行调用，示例如下： 1234567//传入一个名字 打印并将其返回func printName(name:String) -&gt; String &#123; print(name) return name&#125;//进行函数的调用printName(&quot;HS&quot;) 也可以创建没有参数的函数： 1234func onePuseTwo()-&gt;Int &#123; return 1+2&#125;onePuseTwo() 同样也可以创建没有返回值的函数： 1234func sayHello()&#123; print(&quot;Hello&quot;)&#125;sayHello() 上面介绍的函数类型都比较常见，对于多返回值的函数，在Objective-C中十分难处理，开发者通常会采用字典、数组等集合方式或者干脆使用block回调，在Swift中，可以使用元组作为函数的返回值，示例如下： 1234func tuples()-&gt;(Int,String)&#123; return (1,&quot;1&quot;)&#125;tuples() 也可以是函数返回一个Optional类型的值，支持返回nil，示例如下： 12345678func func1(param:Int)-&gt;Int? &#123; guard(param&gt;0)else&#123; return nil &#125; return param&#125;func1(0)func1(1) 在函数的参数名前，开发者还可以再为其添加一个参数名称作为外部参数名，示例如下： 12345678910func func1(count param:Int ,count2 param2:Int)-&gt;Int? &#123; //内部依然使用param guard(param&gt;0)else&#123; return nil &#125; return param&#125;//外部调用使用countfunc1(count: 0,count2: 0)func1(count: 1,count2: 1) 其实Swift函数中的参数列表有这样一个特点，除了第一个参数外，之后的参数都默认添加一个一个和内部名称相同的外部名称，如果开发者不想使用这个外部名称，使用_符号设置，示例如下： 12345678910func func2(param:Int,param2:Int,param3:Int) &#123; &#125;//有外部名称func2(0, param2: 0, param3: 0)func func3(param:Int,_ param2:Int,_ param3:Int) &#123; &#125;//没有外部名称func3(0, 0, 0) Swift也支持开发者为函数的参数创建一个默认值，如果函数的某个参数有设置默认值，则开发者在调用时可以省略此参数，示例如下： 1234func func4(param:Int=1,param2:Int=2,param3:Int) &#123; print(param,param2,param3)&#125;func4(3,param3:3) 还有一种情形在Objective-C中也很处理，对于参数数量不定的函数，在前面章节介绍过，Objective-C一般会使用list指针来完成，在Swift中编写这样的函数十分简单，示例如下： 123456func func5(param:Int...) &#123; for index in param &#123; print(index) &#125;&#125;func5(1,2,3,4) Swift中参数默认是常量，在函数中是不能修改外部传入参数的值得，如果有需求，需要将参数声明成inout类型，示例如下： 1234567func func6(inout param:Int) &#123; param = 10&#125;var count = 1//实际上传入的是参数地址func6(&amp;count)print(count) 三、函数类型函数是一种特殊的数据类型，每一个函数属于一种数据类型，示例如下： 12345func func7(a:Int,_ b:Int)-&gt;Int&#123; return a+b&#125;var addFunc:(Int,Int)-&gt;Int = func7addFunc(1,2) 函数也可以作为参数传入另一个函数，这十分类似于Objective-C中的block语法，示例如下： 1234567891011121314func func7(a:Int,_ b:Int)-&gt;Int&#123; return a+b&#125;var addFunc:(Int,Int)-&gt;Int = func7addFunc(1,2)func func8(param:Int,param2:Int,param3:(Int,Int)-&gt;Int) -&gt; Int &#123; return param3(param,param2)&#125;//传入函数func8(1, param2: 2, param3: addFunc)//闭包的方式func8(2, param2: 2, param3:&#123; (a:Int,b:Int) -&gt; Int in return a*b &#125;) 一个人函数也可以作为另一个函数的返回值，示例如下： 123456789func func9()-&gt;(Int)-&gt;Int&#123; //Swift支持嵌套函数 func tmp(a:Int)-&gt;Int&#123; return a*a &#125; return tmp&#125;var myFunc = func9()myFunc(3) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题六——流程控制","slug":"206Swift讲解专题六——流程控制","date":"2016-05-11T16:00:00.000Z","updated":"2021-07-08T09:37:09.416Z","comments":true,"path":"2016/05/12/206Swift讲解专题六——流程控制/","link":"","permalink":"http://huishao.cc/2016/05/12/206Swift讲解专题六——流程控制/","excerpt":"","text":"Swift讲解专题六——流程控制一、引言一种编程语言的强大与否，很大程度上取决于其提供的程序流程控制方案，就如使用汇编语言实现复杂的程序流程是一件痛苦的事情。Swift中提供了许多强大的流程控制语句，例如快速遍历for-in，while循环，repeat-while循环，switch选择等，需要注意的是，在Swift2.2中，for(a;b;c)循环已经被弃用掉，并且Swift中的Switch语句也更加强大，可以处理任意数据类型。 二、for-in循环配合范围运算符，for-in循环可以用来执行确定次数的循环，示例如下： 12345678for index in 1...5 &#123; print(index)&#125;//如果不需要获取循环中每次的循环次数 可以使用如下方式var sum=0;for _ in 1...3 &#123; sum += 1&#125; for-in循环也通常会用来遍历数组，字典，集合等，示例如下： 123456789101112var collection1:Array = [1,2,3,4]var collection2:Dictionary = [1:1,2:2,3:4,4:4]var collection3:Set = [1,2,3,4]for obj in collection1 &#123; print(obj)&#125;for (key , value) in collection2 &#123; print(key,value)&#125;for obj in collection3 &#123; print(obj)&#125; 三、while循环while语句进行循环操作，直到循环条件为false为止，这类型的循环通常适用于循环次数不定的循环需求，while循环提供两种语法格式，示例如下： 12345678910var i=0//当i不小于10时跳出循环while i&lt;10 &#123; print(&quot;while&quot;,i) i+=1&#125;//先进行一次操作 在判断循环条件repeat &#123; print(&quot;repeat while&quot;)&#125; while i&lt;10 四、if语句if语句是程序开发中最常用的语句之一，通过if将判断一个条件是否成立来进行程序的流程控制，if语句通常会和else语句结合进行使用，示例如下： 12345678var c:Intif 1&gt;2 &#123; c=1&#125;else if 1&lt;0 &#123; c=2&#125;else&#123; c=3&#125; 五、Switch语句Switch语句作为开关选择语句，用来处理一组值的分支选择，Swift中的Switch语句格外强大，相比于Objective-C，Swift中的Switch语句每个case后不需要使用break进行手动中断，当代码匹配到一个case后语句将自行中断。用法示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var charac:Character = &quot;b&quot;//使用switch语句进行字符分支判断switch charac &#123;case &quot;a&quot;: print(&quot;chara is a&quot;)case &quot;b&quot;: print(&quot;chara is b&quot;)case &quot;c&quot;: print(&quot;chara is c&quot;)default ://default用于处理其他额外情况 print(&quot;no charac&quot;)&#125;//同一个case中可以包含多个分支switch charac &#123;case &quot;a&quot;,&quot;b&quot;,&quot;c&quot; : print(&quot;chara is word&quot;)case &quot;1&quot;,&quot;2&quot;,&quot;3&quot; : print(&quot;chara is num&quot;)default : print(&quot;no charac&quot;)&#125;//在case中也可以使用一个范围var num = 3switch num &#123;case 1...3 : print(&quot;1&lt;=num&lt;=3&quot;)case 4 : print(&quot;chara is num&quot;)default : print(&quot;no charac&quot;)&#125;//使用Switch语句进行元组的匹配var tuple = (0,0)switch tuple &#123;case (0,1): print(&quot;Sure&quot;) //也可以只对元组中的某个元素进行匹配case (_,1): print(&quot;Sim&quot;) //也可以对元组中的元素进行范围匹配case(0...3,0...3): print(&quot;SIM&quot;)default: print(&quot;&quot;)&#125;//进行数据绑定switch tuple &#123;case (let a,1): print(a)case (let b,0): print(b) //let(a,b) 与 (let a,let b)意义相同case let(a,b): print(a,b)default: print(&quot;&quot;)&#125;//对于进行了数据绑定的Switch语句 可以使用where关键字来进行条件判断switch tuple &#123;case (let a,1): print(a)case (let b,0): print(b)//let(a,b) 与 (let a,let b)意义相同case let(a,b) where a==b: print(a,b)default: print(&quot;&quot;)&#125; 六、跳转语句Swift中提供了5种跳转语句，continue，break，fallthrough，return，throw。 continue：跳出到循环起始位置，直接开始下次循环。 break：break如果在循环语句中则是直接中断循环，跳出，若是在Switch结构中，则立即跳出Switch结构。 fallthrough语句需要和switch语句配合使用，在case中使用fallthrough，则会继续执行下一个case，需要注意，在下一个case中有进行数据绑定的，不可以使用fallthrough，示例如下： 12345678910111213141516var tuple = (0,0)switch tuple &#123;case (0,0): print(&quot;Sure&quot;) //fallthrough会继续执行下面的case fallthrough //也可以只对元组中的某个元素进行匹配case (_,0): print(&quot;Sim&quot;) fallthrough //也可以对元组中的元素进行范围匹配case(0...3,0...3): print(&quot;SIM&quot;)default: print(&quot;&quot;)&#125; return：return语句直接从函数中返回。 throw：throw用于抛出异常。 Swift还支持另一种语法，可以为while循环设置一个tip标签，使用break和continue等关键字来进行流程的控制，示例如下： 1234567891011var tmp = 0;tip:while tmp&lt;10 &#123; print(&quot;ccc&quot;) tmp+=1 switch tmp &#123; case 3: break tip default: break &#125;&#125; Swift2.0之后，提供了一种新的语法，guard-else，这也被称作守护语句，只有当条件不满足时，才执行else后面的代码，示例如下： 12345678910var name = &quot;HS&quot;func nameChange(name:String) &#123; guard name==&quot;HS&quot; else&#123; print(name) return &#125; print(&quot;name is HS&quot;)&#125;nameChange(name) 在开发中，函数中常常会需要检查传入的参数是否符合标准，guard-else语句就是为这种需求所生，正如其名，它用于守护函数执行的精确度。 七、系统版本检查使用如下示例代码进行系统支持版本的检查： 123if #available(iOS 9, *)&#123; print(&quot;iOS 9&quot;)&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift讲解专题五——集合类型","slug":"205Swift讲解专题五——集合类型","date":"2016-05-10T16:00:00.000Z","updated":"2021-07-08T09:36:23.669Z","comments":true,"path":"2016/05/11/205Swift讲解专题五——集合类型/","link":"","permalink":"http://huishao.cc/2016/05/11/205Swift讲解专题五——集合类型/","excerpt":"","text":"Swift讲解专题五——集合类型一、引言Swift中提供了3种集合类型，Array数据类型，Set集合类型，Dictionary字典类型。Array用于存放一组有序的数据，数据角标从0开始一次递增；Set用于存放一组无序的数据，数据不可以重复；Dictionary也用于存放一组无序的数据，只是其是按照键值对的方式存储，键值必须唯一。这里借用官方文档中的一张图来表示3种集合类型的特点： 二、Array类型Array通常也被称为数组，Swift是一种类型安全语言，其中的Array类型也必须确定其元素的类型，声明数组类型有两种方法，示例如下： 123456//将数组声明为Int类型值集合的数组var array1:[Int]var array2:Array&lt;Int&gt;//创建空数组array1 = []array2 = Array() 数组对象如果通过var变量也接收，则其为可变的数组，可以通过append方法来追加元素，示例如下： 12//向数组中追加元素array1.append(3) 在创建数组时，也可以对数组进行初始化，示例如下： 123456//创建数组[0,0,0]var array3 = [Double](count: 3, repeatedValue: 0)//创建数组[2.5,2.5,2.5]var array4 = Array(count: 3, repeatedValue: 2.5)//数组可以使用+号直接进行追加 [0,0,0,2.5,2.5,2.5]var array5 = array3+array4 Swift中提供了许多访问和修改数组的方法，示例代码如下： 1234567891011121314151617181920212223242526//获取数组中元素个数array5.count//判断数组是否为空array5.isEmpty//通过下标访问数组中的元素array5[1]//通过下标修改数组元素array5[1]=2//修改数据中的一组数据array5[0...3] = [1,1,1,1]//向数组中某个位置插入一个数据array5.insert(3, atIndex: 1)//移除数组某个角标处的元素array5.removeAtIndex(1)//移除数组的最后一个元素array5.removeLast()//移除数组第一个元素array5.removeFirst()//遍历整个数组for item in array5 &#123; print(item)&#125;//遍历数组枚举for (index,item) in array5.enumerate() &#123; print(index,item)&#125; 三、Set类型Set类型集合不关注元素的顺序，但是其可以保证其中元素的唯一性。和Array类型一样，Set类型来声明时也需要确定其内元素的类型，示例如下： 1var set1:Set&lt;Character&gt; = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;] 下面示例代码演示对集合进行操作： 12345678910111213141516171819202122var set1:Set&lt;Character&gt; = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]var set2:Set&lt;Character&gt; = [&quot;e&quot;,&quot;f&quot;,&quot;g&quot;]//向集合中插入元素set1.insert(&quot;z&quot;)//获取集合中元素个数set1.count//判断集合是否为空set1.isEmpty//将集合中的某个元素移除set1.remove(&quot;a&quot;)//移除集合中的所有元素set1.removeAll()//判断集合中是否包含某个元素set2.contains(&quot;e&quot;)//遍历集合for item in set2 &#123; print(item)&#125;//进行从小到大的排序遍历for item in set2.sort() &#123; print(item)&#125; Set也支持进行一些集合的数学运算，例如交集，并集，补集等，下面一张图演示了Set进行集合运算的一些特性： intersect()方法返回两个集合的交集。 exclusiveOr()方法用于返回两个集合交集的补集。 union()方法用于返回两个集合的并集。 subtract()方法用于返回第二个集合的补集。 示例代码如下： 12345678910var set3:Set&lt;Int&gt; = [1,2,3,4]var set4:Set&lt;Int&gt; = [1,2,5,6]//返回交集 &#123;1，2&#125;var setInter = set3.intersect(set4)//返回交集的补集&#123;3，4，5，6&#125;var setEx = set3.exclusiveOr(set4)//返回并集&#123;1，2，3，4，5，6&#125;var setUni = set3.union(set4)//返回第二个集合的补集&#123;3，4&#125;var setSub = set3.subtract(set4) 使用比较运算符==可以比较两个Set集合是否相等，当两个Set集合中所有元素都相等时，这两个集合才相等。下面代码显示了与子集相关的运算： 123456789101112var set5:Set = [1,2]var set6:Set = [2,3]var set7:Set = [1,2,3]var set8:Set = [1,2,3]//判断是否是某个集合的子集 set5是set7的子集 返回tureset5.isSubsetOf(set7)//判断是否是某个集合的超集 set7是set5的超集 返回tureset7.isSupersetOf(set5)//判断是否是某个集合的真子集 set5是set7的真子集 返回tureset5.isStrictSubsetOf(set7)//判断是否是某个集合的真超集 set7不是set8的真超集 返回falseset7.isStrictSupersetOf(set8) 四、Dictionary类型Swift中的Dictionary在声明时必须明确键的类型和值的类型，示例如下： 12var dic:Dictionary&lt;Int,String&gt;var dic2:[Int:String] = [1:&quot;one&quot;,2:&quot;Two&quot;] 访问与操作Dictionary的方法，代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940var dic2:[Int:String] = [1:&quot;One&quot;,2:&quot;Two&quot;,3:&quot;Three&quot;,4:&quot;Four&quot;]//获取字典键值对个数dic2.count//判断字典是否为空dic2.isEmpty//通过键获取值dic2[1]//通过键修改值dic2[1] = &quot;First&quot;//添加键值dic2[0] = &quot;Zero&quot;//updateValue 方法将更新一个键值 如果此键存在 则更新键值 并且将旧的键值返回 如果此键不存在 则添加键值 返回nil 其返回的为一个Optional类型值 可以使用if let进行处理dic2.updateValue(&quot;9&quot;, forKey: 1)//使用if let 处理updateValue的返回值if let oldValue = dic2.updateValue(&quot;One&quot;, forKey: 1) &#123; print(&quot;Old Value is \\(oldValue)&quot;)&#125;//通过键值获取的数据也将是有个Optional类型的值 也可以使用if letif let value = dic2[1] &#123; print(&quot;The Value is \\(value)&quot;)&#125;//移除某个键值对dic2[9]=nildic2.removeValueForKey(9)//对字典进行遍历for (key,value) in dic2 &#123; print(key,value)&#125;//遍历所有键for key in dic2.keys &#123; print(key)&#125;//遍历所有值for value in dic2.values &#123; print(value)&#125;//进行从小到大的排序遍历for key in dic2.keys.sort() &#123; print(key)&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift解读专题四——字符串与字符","slug":"204Swift解读专题四——字符串与字符","date":"2016-05-09T16:00:00.000Z","updated":"2021-07-08T09:34:07.930Z","comments":true,"path":"2016/05/10/204Swift解读专题四——字符串与字符/","link":"","permalink":"http://huishao.cc/2016/05/10/204Swift解读专题四——字符串与字符/","excerpt":"","text":"Swift解读专题四——字符串与字符一、引言Swift中提供了String类型与Characters类型来处理字符串和字符数据，Swift中的String类型除了提供了许多方便开发者使用的方法外，还可以与Foundation框架的NSString类进行转换，使用起来十分方便。 二、String基础在Swift中，使用双引号来定义字符串，开发者可以通过如下代码来创建一个字符串常量： 1let str = &quot;Hello, playground&quot; 可以通过下面两种方式来创建空字符串： 12let str1 = &quot;&quot;let str2 = String() 调用isEmpty方法可以判断某个字符串是否为空字符串，这个方法将返回一个Bool值，可以直接用于if语句： 123if str1.isEmpty &#123; print(&quot;this String Object is Empty&quot;)&#125; 不像Objective-C有NSString与NSMutableString的区别，在Swift中，如果需要创建可变的字符串，只需用变量来接收： 12var str3 = &quot;Hello&quot;str3 += &quot; &quot;+&quot;World&quot;//str3 = Hello World String也可以使用插值的方法来构造新的字符串，使用\\()的方式来将插值的表达式写在小括号内，示例如下： 12let multiplier = 3let message = &quot;\\(multiplier) times 2.5 is \\(Double(multiplier) * 2.5)&quot;//3 times 2.5 is 7.5 获取字符串的长度使用如下代码： 1str3.characters.count Swift中的String可以直接使用==运算符来进行比较，示例如下： 123let comStr1 = &quot;one two&quot;let comStr2 = &quot;one two&quot;comStr1==comStr2//true 下面示例的代码，用来检验字符串是否包含前缀与后缀： 123let tmp3 = &quot;thank you&quot;tmp3.hasPrefix(&quot;thank&quot;)//truetmp3.hasSuffix(&quot;you&quot;)//true 三、Character的使用Character为Swift中的字符类型，在for-in循环中，可以将字符串中所有的字符进行遍历： 123for chara in str3.characters &#123; print(chara)&#125; 也可以创建单独的字符类型量值，示例如下： 12let char1 = &quot;🐶&quot;var cgar2 = &quot;HS&quot; 事实上，Sting字符串也可以通过Character字符数组进行初始化： 12let chars:[Character] = [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]let str4 = String(chars) 向字符串中追加字符使用如下方法： 123var str5 = &quot;&quot;let ca:Character = &quot;a&quot;str5.append(ca) 四、字符串中的特殊字符字符串中的特殊字符主要指转义字符，Swift中的转义字符列举如下： 12345678&quot;\\0&quot;//&quot;&quot; 空白符&quot;\\\\&quot;//&quot;\\&quot;反斜杠符号&quot;\\t&quot;//&quot; &quot;制表符&quot;\\n&quot;//换行符&quot;\\r&quot;//回车符&quot;\\&apos;&quot;//&quot;&apos;&quot;单引号&quot;\\&quot;&quot;//&quot;&quot;&quot;双引号&quot;\\u&#123;24&#125;&quot;//&quot;$&quot;unicode字符 五、关于字符串下标在Swift中，字符串也可以通过下标的方式来访问其中字符，并且提供了相关方法来方便的移动下标，示例代码如下： 1234567891011121314151617let tmp = &quot;Hello Swift&quot;//获取字符开始的下标值 0let indexStart = tmp.startIndex//获取某个下标后一个字符的下标 1let next = indexStart.successor()//获取最后一个字符的下标值 注意有\\0的存在 let indexEnd = tmp.endIndex//获取某个下标前一个字符的下标let pre = indexEnd.predecessor()//通过下标获取字符串中的字符 tvar c = tmp[pre]//进行下标移动 ovar c2 = tmp[indexStart.advancedBy(4)]//通过遍历下标来遍历字符 H e l l o S w i f tfor index in tmp.characters.indices &#123; print(&quot;\\(tmp[index]) &quot;, terminator: &quot;&quot;)&#125; 六、在字符串中插入和移除字符使用insert函数来向字符串中插入一个字符，示例如下： 12var tmp2 = &quot;Hello&quot;tmp2.insert(&quot;!&quot;, atIndex: tmp2.endIndex) 注意，上面示例代码中的insert函数只能用于插入一个字符，如果需要插入一组字符，需要使用如下方法： 1tmp2.insertContentsOf(&quot; Swift&quot;.characters, at: tmp2.endIndex) 使用removeAtIndex函数来移除字符串中的一个字符，示例如下： 1tmp2.removeAtIndex(tmp2.endIndex.predecessor()) 如果要移除一组字符，主要通过Range来实现，示例如下： 12let range = tmp2.endIndex.advancedBy(-4)..&lt;tmp2.endIndextmp2.removeRange(range) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift解读专题三——基础运算符","slug":"203Swift解读专题三——基础运算符","date":"2016-05-08T16:00:00.000Z","updated":"2021-07-08T09:33:15.571Z","comments":true,"path":"2016/05/09/203Swift解读专题三——基础运算符/","link":"","permalink":"http://huishao.cc/2016/05/09/203Swift解读专题三——基础运算符/","excerpt":"","text":"Swift解读专题三——基础运算符一、引言运算符是编程语言不可缺少的一个部分，Swift中除了支持C中的运算符外，还提供了一些更加强大的运算符功能，例如取余符%可以用来计算浮点数，另外新增了两种范围运算符。Swift中有3类运算符: 1.一元运算符 运算符作用于一个操作数，可以出现在操作数前或者操作数后。 2.二元运算符 运算符作用于两个操作数，出现在两个操作数中间。 3.三元运算符 运算符作用于三个操作数间。 二、赋值运算符赋值运算符用=符号表示，用于初始化或者更新一个量值，示例如下： 1234//将字符串“hello world” 赋值给变量strvar str = &quot;Hello, world&quot;//更新变量str的值str = &quot;new value&quot; 如果赋值运算符的右边是一个元组，其也可以将元组进行分解赋值，示例如下： 12//对元组进行分解赋值var (x,y) = (1,2) 与C与Objective-C不同，Swift的中赋值运算符并不会返回一个值，很多初学者在进行if语句的使用时，经常会犯的一个错误就是将赋值运算符当做等于运算符来使用，这些错误在Swift语言中都将被避免，因为如果在if语句的判断条件中使用的是赋值运算符，编译器将会直接抛出错误。 三、算术运算符Swift中支持的基础的算数运算符有7种，加(+)、减(-)、乘(*)、除(/)、取余(%)、正号(+)、负号(-)。Sring类型的数据是支持通过+运算符来进行拼接的，示例如下： 1var newStr = &quot;hello&quot;+&quot;world&quot; Swift中的%运算符比Objective-C更加强大，其除了支持整数的取余操作外，还可以支持浮点数的取余操作，示例如下： 1234var value1 = 10%3 //余数1var value2 = -10%3 //余数-1var value3 = 10%4.5 //余数1var value4 = -10%4.5 //余数-1 对于正号和负号操作符也被称为一元加操作符与一元减操作符，一元减操作符会改变数据的正负性，一元加操作符只会返回数值本身，并没有做任何操作，示例如下： 123var tmp = -3;+tmp//-3-tmp//3 四、复合赋值运算符Swift中提供了将一个算术运算符与赋值运算符结合使用的复合赋值功能，示例如下： 12345tmp+=3 //tmp = tmp +3tmp-=3 //tmp = tmp -3tmp*=3 //tmp = tmp *3tmp/=3 //tmp = tmp /3tmp%=3 //tmp = tmp %3 五、比较运算符Swift支持Objective-C中所有的比较运算符，比较运算符将会返回一个Bool类型的值： 1234561==2 //等于比较1&lt;2 //小于比较1&gt;2 //大于比较1 != 2 //不等于比较1&lt;=2 //小于等于比较1&gt;=2 //大于等于比较 除了上面列举出的6种比较运算符外，Swift中还提供了两个特殊的比较运算符===和!==，这两个比较运算符用于比较引用是否相同。 Swift中的元组也可以进行比较，但是其有两个前提需要注意： 1.元组中元素的个数相同且对应位置的元素类型相同。 2.元组中的元素可以进行比较操作。 当元组进行比较时，按元素顺序进行逐个比较，直道某个元素比较出结果后作为元组的比较结果。 12(1,&quot;123&quot;)&gt;(0,&quot;234&quot;) //true(1,&quot;123&quot;)&gt;(1,&quot;456&quot;) //false 三元运算符可以理解为一个简写的if else 语句，示例如下： 1var a = 1&gt;2 ? 1:2 //如果1&gt;2成立 a=1 a=2 六、空聚合运算符空聚合运算符也是Swift语言中独有的一个运算符，其设计的思路是基于更加方便的使用Optional值的目的。对于Optional类型的值，开发者一般会需要使用?进行可选拆包或者!进行强制拆包来获取其原始值，空聚合运算符??提供了更加使用的方式，示例如下： 123456var Op1:String?var Op2:String? = &quot;123&quot;//这个表达式将返回Op2 其意义是 如果Op1不为nil，则对其进行强制拆包 将值返回，如果为nil，则返回Op2var realStr = Op1 ?? Op2//上面的表达式和下面这个表达式意义相同Op1 != nil ? Op1! : Op2 七、区间运算符Swift中还提供了区间运算符，在for-in循环中，区间运算符会被经常使用到，示例如下： 12345678//a...b为闭区间写法for index in 0...3 &#123; print(index)&#125;//a..&lt;b为左闭右开区间for index in 0..&lt;3 &#123; print(index)&#125; 八、逻辑运算符Swift中支持与&amp;&amp;、或||、非!三种逻辑运算符，逻辑运算符只能操作Bool值，示例如下： 12345var one = truevar two = falseone&amp;&amp;two //falseone||two //true!one //false 逻辑运算符在复合使用时，最好使用小括号进行模块分隔，增强可读性。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift解读专题二——基本类型","slug":"202Swift解读专题二——基本类型","date":"2016-05-07T16:00:00.000Z","updated":"2021-07-08T09:32:25.073Z","comments":true,"path":"2016/05/08/202Swift解读专题二——基本类型/","link":"","permalink":"http://huishao.cc/2016/05/08/202Swift解读专题二——基本类型/","excerpt":"","text":"Swift解读专题二——基本类型一、常量和变量Swift语言的常量和变量在使用之前，必须被定义。常量用于处理程序中只在初始化时设置的量值，之后不能进行赋值改变，变量用于处理程序中可以进行改变的量值。分别用let和var来声明常量和变量，示例如下： 12var varValue = 1let letValue = 10 Swift语法也支持在一行中声明多个量值，示例如下： 1var a=1,b=2.9,c=&quot;string&quot; 在声明量值时，编译器会根据第一次赋值的类型来推断出变量的类型，一旦量值的类型被推断，则不能够进行更改，开发者也可以手动注释量值的类型，示例如下： 1var a:Int=1,b:Float=2.9,c:String=&quot;string&quot; 在一行中声明多了变量并且没有提供初始值时，为最后一个变量注释的变量类型也会应用于本行中的所有变量，示例如下： 1var one,two,three:Int 官方文档建议，在实际应用中，注释量值的类型是十分少用的，一般都会为其赋值初始值后让编译器自行推断。 量值的命名可以包含Unicode字符和数字，需要注意，是不能以数字作为量值名称的开头的。空格，数学符号，制表符，箭头等符号也不可以使用。示例如下： 12345678//中文符作变量名var 珲少 = &quot;me&quot;//表情符作为变量名var 😄 = &quot;开心&quot;//含有数字的变量名var one2three = &quot;123&quot;//含有下划线的变量名var _d_s = &quot;C++&quot; 注意：如果使用Swift中的保留关键字作为量值的名，需要加上左右个加上`符号包围，除非特殊情况，否则不要使用这种方式命名量值，示例如下： 1var `let` = &quot;c&quot; 使用print()方法可以进行量值的打印，在字符串中使用\\()格式可以插入变量，示例如下： 12var _d_s = &quot;C++&quot;print(&quot;123\\(_d_s)&quot;) 二、关于注释与编写结构Swift语言可以使用//进行单行注释和/**/进行多行注释，除此之外，Swift语言还支持多行注释的嵌套，示例如下： 123456789101112//我是单行注释/* 我是多行注释 我是多行注释 我是多行注释 *//* 嵌套注释 /* 嵌套注释 */ */ 使用Swift在编写代码时，以行为每句代码的分隔，当然，开发者也可以将多句代码写在一行中，但是需要以分号进行分隔。示例如下： 1var tmp = 3;print(tmp) 三、整型与浮点型Swift中提供8位、16位、32位、64位类型的整型，整型数组不包含小数，包含负整数，0和正整数。在Swift语言中，整型是由结构体定义的，可以调用max和min方法获取对应位数的最大值和最小值，示例如下： 12345678var maxInt8 = Int8.max //127var mimInt8 = Int8.min //-128var maxInt16 = Int16.max //32767var minInt16 = Int16.min //-32768var maxInt32 = Int32.max //2147483647var minInt32 = Int32.min //-2147483648var maxInt64 = Int64.max //9223372036854775807var minInt64 = Int64.min //-9223372036854775808 Int类型的值在不同位数的系统会有不同的结果，在32位系统上，Int与Int32相同，在64位系统上，Int与Int64相同。 Swift语言也提供了无符号整型，示例如下： 1234var maxUInt8 = UInt8.max //255var maxUInt16 = UInt16.max //65535var maxUInt32 = UInt32.max //4294967295var maxUInt64 = UInt64.max //18446744073709551615 UInt类型在32位系统为UInt32，在64位系统为UInt64。 浮点型用于创建小数，Swift提供了两种类型的浮点型，Float对应32位的浮点值，Double对应64位的浮点值。 在定义整型或浮点型数据时，可以通过添加前缀的方式来指定其进制类型，示例如下： 1234var type_10 = 17; //十进制的17var type_2 = 0b10001 //二进制的17var type_8 = 0o21 //八进制的17var type_16 = 0x11 //16进制的17 对于科学计数法，在Swift中使用e和p来标识，在十进制中使用e代表10的n次方，在十六进制中，使用p代表2的n次方，示例如下： 12var sum = 1.25e3 //1.25*10^3 = 1250var sun2 = 0x1p3 //1*2^3 = 8 Swift中还有一个非常有意思的特性，无论是整型还是浮点型，都可以在数前使用0进行填充，并且可以使用下划线进行可读性分隔，是代码看起来更加清晰，这些都不会改变原数据值，示例如下： 123var num1 = 001.23var num2 = 1_000var num3 = 1_000.1_001 开发者也可以使用typealias关键字来为某个数据类型添加一个别名，示例如下： 1typealias MyType = Int 四、布尔类型在Objective-C中，BOOL值实际上是无符号的整型数据，其约定0为NO，非0都为YES。在Swift中，Bool被作为一种独立的数据类型，提供true和false两种值。示例如下： 1var boolVale:Bool = true 五、元组元组是Swift语言十分重要的一个特点，它允许开发者将任意个不同类型的数据组合成一个数据类型，这也是Swift语言的一个强大之处。例如如下示例代码可以创建一个元组： 1var tuples:(param1:Int,param2:Float,param3:String,param4:Bool) = (3,3.14,&quot;圆周率&quot;,true) tuples就是一个类型为(param1:Int,parame:Float,param3:String,param4:Bool)类型的元组。取元组数据的对应值有两种方式，一种是使用数据参数名称，一种是直接使用数据的角标，示例如下： 12345678910//通过参数名取元组中的数据var tuplesInt = tuples.param1;var tuplesFloat = tuples.param2;var tuplesString = tuples.param3;var tuplesBool = tuples.param4;//通过角标取元组中的数据var tuplesInt2 = tuples.0;var tuplesFloat2 = tuples.1;var tuplesString2 = tuples.2;var tuplesBool2 = tuples.3; 开发者也可以将元组分解成单独的常量进行访问，示例如下： 12let (fir,sec,thr,four) = tuplesprint(fir,sec,thr,four) 有时候，某个元组中的所有数据开发者并不一定都需要使用，开发者可以选择只提取元组中所需要的值，示例如下： 12let (fir,_,thr,_) = tuplesprint(fir,thr) 开发文档提示，元组只适合临时的简单组合数据，并不适合处理复杂的数据逻辑，对复杂数据逻辑的处理更提倡使用类。 六、Optionals值Optional也是一种具体的数据类型，其寄附与其他数据类型上，其只有两个值： 1.如果有值，则它为具体的值。 2.如果没有值，则它为nil。 对于习惯了Objective-C语言设计风格的开发者来说，Optional的概念可能有些难于理解，通过一个例子就很好理解，示例代码如下： 12let tmp = 123let tmp2 = Int(&quot;123&quot;) 上面创建的两个常量tmp和tmp2虽然值都是123，然而其并不是相同的类型，tmp是严格的Int类型值，tmp2是基于Int类型的Optional值，他们在使用时，Optional值需要使用!进行拆包操作，示例如下： 123let tmp = 123let tmp2 = Int(&quot;123&quot;)let tmp3 = tmp + tmp2! 有时候，Int()构造方法并不一定能构造成功，这时tmp2是会为nil值的，示例如下： 1let tmp2 = Int(&quot;a&quot;) 将普通类型声明为Optional类型，只需在类型名后添加?符号即可，示例如下： 1let optionalValue:Int? = 1 Swift中的nil与Objective-C中的nil意义并不相同，在Objective-C中，nil代表指针指向一个不存在的对象，Swift中的nil并不是指针，它是一种抽象类型的值，在Swift不只对象的Optional类型可以设置为nil，任何数据类型的Optional类型都可以设置为nil。 Optional值经常会和if条件语句一起使用，用来判断某个值是否被初始化了，示例如下： 123if optionalValue != nil &#123; print(optionalValue)&#125; Swift还提供了if let语法进行Optional值得绑定，示例如下： 1234//如果optionalValue值不为nil，则会将拆包后的值赋值给tipif let tip=optionalValue &#123; print(tip)&#125; 开发者还可以在一个绑定语句后进行多个Optional值的绑定，并使用where进行条件判断，示例如下： 12345let optionalValue:Int? = 1let optionalValue2:Int? = 2if let tip=optionalValue,tip2=optionalValue2 where tip&lt;tip2&#123; print(tip,&quot;&lt;&quot;,tip2)&#125; 七、异常处理Swift中也有一套十分强大的异常处理系统。在编写函数时，如果这个函数可能抛出异常，则需要加上throw关键字，并且在函数中也是使用throw关键字来进行异常的抛出。示例如下： 123456789101112131415161718192021222324252627//异常的捕获 自定义的异常必须继承与ErrorType类enum MyErrorType:ErrorType &#123; case CanNotZero case Other&#125;//可能抛出异常的函数func ErrorTest() throws &#123; let a=0; if a==0 &#123; throw MyErrorType.CanNotZero &#125;&#125;//进行异常捕获do &#123; //使用try进行可能抛异常函数的执行 try ErrorTest() //没有错误执行的代码块 //catch加错误类型 为捕获相应的异常&#125;catch MyErrorType.Other &#123; //抛异常后执行的代码块 print(&quot;MyErrorType.Other&quot;)&#125;catch MyErrorType.CanNotZero &#123; print(&quot;MyErrorType.CanNotZero&quot;)&#125;catch&#123; //如果不写捕获的异常类型 则会捕获所有异常 并且传入一个error异常参数 print(error)&#125; 八、断言在Objective-C中，使用Assert相关的宏来进行断言处理，在Swift中也同样有断言的相关操作，断言可以帮助开发者为某种情况添加一个异常中断，为开发者提供调试信息。断言会要求提供一个条件进行判断，当条件为真时，程序继续运行，如果条件为假，则程序会断开，示例如下： 12let age = -3assert(age&gt;0, &quot;age must be bigger than zero&quot;) 官方文档为开发者提供了几种断言使用的场景，参考如下： 1.对于索引过小或过大的检查。 2.当无效的参数传递进函数时。 3.对于一个可能为nil的值，当为nil时后续代码无法工作时。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"Swift解读专题一——Swift2.2语言预览","slug":"201Swift解读专题一——Swift2.2语言预览","date":"2016-05-04T16:00:00.000Z","updated":"2021-07-08T09:31:16.632Z","comments":true,"path":"2016/05/05/201Swift解读专题一——Swift2.2语言预览/","link":"","permalink":"http://huishao.cc/2016/05/05/201Swift解读专题一——Swift2.2语言预览/","excerpt":"","text":"专题一——Swift2.2语言预览一、引言本系列专题是我通过阅读Swift2.2语言开发文档，翻译总结加上自己的理解整理而成。其中大部分结构和内容都来自开发文档，有疏漏和错误之处，还望更多朋友指出，共同交流进步，我的QQ：316045346。 二、从HelloWorld开始在学习很多编程语言时，都是从HelloWorld入门，下面代码就是一个完整的HelloWorld程序： 1print(&quot;Hello, World!&quot;) 分析上面代码，可以发现Swift语言的3个十分明显的特点： 1.开发者不需要引入输入输出相关的函数库。 2.在编写代码时，不需要在语句的结尾处添加分号。 3.全局的代码就是程序的入口，不需要类似C系语言的main()方法来作为程序入口。 三、常量与变量常量和变量是编程语言中最基础的两类数据类型，常量可以理解为为某个值起一个特定的名字，常量通常提供给开发者用于某些只赋值一次但却在程序中多处使用的量值。变量也可以进行多次修改。分别使用let和var创建常量和变量。例如： 123let letValue = 4var varValue = 8varValue = 16 开发者在进行常量和变量的创建时，并不需要制定类型，编译器与根据第一次赋值的类型来推断出常量或者变量的类型，然而这并不是说Swift语言不严格要求变量或常量的类型，一旦编译器推断了值的类型，之后开发者若要修改变量，则必须严格遵守既定的变量类型，否则编译器会报错。 如果开发者第一次对变量或常量进行的赋值不能够使编译器正确的推断出常量或变量的类型，开发者也可以通过冒号后跟类型的方式来强制定义变量或常量的类型，如下： 12var varValue:Float = 8varValue = 16.0 在Swift语言中，不存在隐式转换的概念，这也是Swift语言更加安全的特性之一，这样的设计可以保证变量在任何时候类型都被明确的指定。在进行类型转换时，可以通过类实例化的方式进行，示例如下： 1234//Float值转成IntletValue+Int(varValue)//Int转为FloatFloat(letValue)+varValue 对于在字符串中使用其他类型的变量，Swift语言提供了一种更加便捷的写法，使用\\()的方式来转换，小括号内为变量的名称，例如： 123var strValue = &quot;Hello&quot;//Hello16.0strValue+&quot;\\(varValue)&quot; 四、数组与字典数组与字典是最常用的两种数据集合，在Swift语言中，使用\\[\\]来创建数组或字典，示例如下： 12var array = [1,2,3]var dic = [1:&quot;one&quot;,2:&quot;two&quot;,3:&quot;three&quot;] 同Int，Float类型的数据一样，数组和字典在第一次赋值时，也会根据赋值的类型来推断出变量类型，开发者同样也可以强制指定，如下： 12var array:[Int] = [1,2,3]var dic:[Int:String] = [1:&quot;one&quot;,2:&quot;two&quot;,3:&quot;three&quot;] Swift允许创建或者重新赋值为空的数据或者字典，但是这有一个前提条件，被赋值为空的数据或字典必须是类型确定的，示例如下： 1234567891011121314//这样写会报错//var errorArray = []//创建空的数据集合//方式一var array:[Int] = []var dic:[Int:String] = [:]//方式二var array2 = [Int]()var dic2 = [Int:String]()//方式三var array3 = [1]var dic3 = [1:&quot;1&quot;]array3 = []dic3 = [:] 五、optional类型的值在理解optional类型的值之前，我们可以先来看一段C代码： 123456int a=1;if(a)&#123; &#125;else&#123; &#125; 上面这段代码对于C语言来说完全没有问题，当a为非0值时，就代表条件为真，在Swift语言中则不同，if选择语句中的条件必须为Bool类型的值，因此，对于某些可以为空的值，Swift中提供了optional类型，这种类型相当于对其他实际类型进行了包装，如果有值，则他拆包后为相应类型的值，如果没有值，则为空值nil。示例如下： 1234var optionalString: String? = &quot;Hello&quot;if optionalString == nil &#123; &#125; 在Swift中，当if与let共同使用时，将会构成一种更加奇特的语法方式，这种方式对于处理optional类型的值十分方便，示例如下： 12345678910/* if let 后面赋值为optional类型的值有这样的效果 如果optional的值不为nil 则会走if条件为真的语句块并且将optional变量的值赋值给let常量 可以在if为真的语句块中使用 如果optional的值为nil 则会走else语句块 并且name常量被释放 不能再else块中使用*/if let name=optionalName &#123; greeting = &quot;Hello, \\(name)&quot;&#125;else&#123; print(greeting)&#125; 除了if let语法外，还有一种方式可以用来处理optional类型的值，示例如下： 12var greeting = &quot;Hello!&quot;greeting = &quot;Hello&quot; + (optionalString ?? &quot;&quot;) ??运算符用来为optional类型的值设置一个默认值，如果optional值为nil，则会使用后面设置的默认值来代替。 Swift语言的switch语句相比于C系的语言要强大的多，其不只可以用于判断整型，其可以处理任意类型的数据，同样，它也不只限于比较是否相等的运算，其可以支持各种负责运算，示例如下： 1234567891011let vegetable = &quot;red pepper&quot;switch vegetable &#123;case &quot;celery&quot;: print(&quot;Add some raisins and make ants on a log.&quot;)case &quot;cucumber&quot;, &quot;watercress&quot;: print(&quot;That would make a good tea sandwich.&quot;)case let x where x.hasSuffix(&quot;pepper&quot;): print(&quot;Is it a spicy \\(x)?&quot;)default: print(&quot;Everything tastes good in soup.&quot;)&#125; 如果匹配上了一个case，程序会结束switch选择，各个case之间是互斥的。 六、循环语句Swift2.2中，弃用了for i；param;param{}格式的循环语句，提供给开发者使用的循环语句主要有3种。 1.for in语句 for in语句多用于快速遍历字典，示例如下： 123456789101112131415let interestingNumbers = [ &quot;Prime&quot;: [2, 3, 5, 7, 11, 13], &quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8], &quot;Square&quot;: [1, 4, 9, 16, 25],]var largest = 0for (kind, numbers) in interestingNumbers &#123; for number in numbers &#123; //找出最大值 if number &gt; largest &#123; largest = number &#125; &#125;&#125;print(largest) 在for in循环中可以使用一个索引来指定循环次数，通过这种方式可以实现有序的遍历操作，示例如下： 123for i in 0..&lt;10 &#123; print(i)&#125; 2.while语句 while语句用于条件循环，直到不再满足某个条件为止，示例如下： 12345var n = 2while n &lt; 100 &#123; n = n * 2&#125;print(n) 3.repeat {}while语句 repeat{}while语句与C语言中的do{}while作用相同，保证至少循环一次。示例如下： 12345var m = 2repeat &#123; m = m * 2&#125; while m &lt; 100print(m) 七、函数与闭包Swift中的函数使用关键字func来标识，格式如下： func name(param1,param2…)-&gt;returnValue{} 示例代码如下： 12345func add(param1:Int,param2:Int) -&gt; Int &#123; return param1+param2&#125;//下面表达式将返回8add(5, param2: 3) 我比较了Swift语言与Objective-C、Java语言的函数特点： Objective-C实际上并没有函数重载的概念，不同参数的函数实际上拥有不同的函数名，Objective-C的风格将参数名嵌套进函数名中，这样有一个好处，开发者可以通过函数名明确的知道此函数的用途以及每个参数的意义，当然也有其局限性，Objective-C的函数大多十分冗长，不够简洁。 Java不同参的函数采用重载的方式，这样的效果是，相同的函数名，参入不同的参数则会执行不同的操作，是不同的两个方法，这样的有点是使代码十分简洁，然而对开发者来说并不友好，开发者在开发时不能便捷的看出每个参数的意义和用法。 个人见解，Swift对函数的设计综合了上面两种语言的有事，参数列表与函数名分离，简化了函数，同时，参数列表中保留了每个参数的名称，使开发者在调用函数时更加直观。 在Objective-C中，如果需要某个函数返回一组值，开发者通常会需要使用字典或者数组，这样做有一个问题，在调用此函数时，返回值的意义十分模糊，开发者需要明确的知道其中数据的顺序与意义。Swift中可以采用返回元组的方式来处理一组返回值，示例如下： 1234567891011121314151617181920212223//返回一组数据的函数func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) &#123; var min = scores[0] var max = scores[0] var sum = 0 for score in scores &#123; if score &gt; max &#123; max = score &#125; else if score &lt; min &#123; min = score &#125; sum += score &#125; return (min, max, sum)&#125;//元组数据let statistics = calculateStatistics([5, 3, 100, 3, 9])//通过名称取元组中的最大值print(statistics.max)//通过角标取元组中的最小值print(statistics.0) 对于可变参数个数的函数，在Objective-C中，开发者大多会采用va_list指针的方式实现，示例如下： 12345678910-(void)myLog:(NSString *)str,...&#123;//省略参数的写法 va_list list;//创建一个列表指针对象 va_start(list, str);//进行列表的初始化，str为省略前的第一个参数，及...之前的那个参数 NSString * temStr = str; while (temStr!=nil) &#123;//如果不是nil，则继续取值 NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*);//返回取到的值，并且让指针指向下一个参数的地址 &#125; va_end(list);//关闭列表指针&#125; 在Swift语言中，实现这样的函数要简单的多，通过…来进行参数的省略，并且将这些省略的函数包装为数组传入函数内部，示例如下： 12345678910func sumOf(numbers: Int...) -&gt; Int &#123; var sum = 0 //多参被包装为数组 for number in numbers &#123; sum += number &#125; return sum&#125;sumOf()sumOf(42, 597, 12) 与Java类似，Swift中的函数也支持嵌套操作，嵌套内部的函数可以使用外部的变量，示例如下： 1234567891011func returnFifteen() -&gt; Int &#123; var y = 10 //嵌套函数 func add() &#123; y += 5 &#125; //调用 add() return y&#125;returnFifteen() 由于函数也是一种特殊的数据类型，函数也可以作为返回值，示例如下： 12345678func makeIncrementer() -&gt; ((Int) -&gt; Int) &#123; func addOne(number: Int) -&gt; Int &#123; return 1 + number &#125; return addOne&#125;var increment:((Int)-&gt;Int) = makeIncrementer()increment(7) 一个函数也可以作为另一个函数的参数来使用，示例如下： 123456789//参数中有函数func func1(param1:Int,param2:(count:Int)-&gt;Void) &#123; param2(count: param1+1)&#125;func tmpFunc(count:Int) -&gt; Void &#123; print(count)&#125;//将函数作为参数传入func1(3, param2: tmpFunc) 与Objective-C中的block对应，Swift中有闭包的概念来创建一个代码块，可以理解为闭包为没有名字的函数，使用{()in }格式来创建闭包，示例代码如下： 12var f:(count:Int)-&gt;Void = &#123;(Count) in print(132) &#125;f(count:0) 通过这种写法，开发者在将函数作为参数传递时，无需再创建中间函数，示例如下： 123456789//参数中有函数func func1(param1:Int,param2:(count:Int)-&gt;Void,param3:(count:Int)-&gt;Void) &#123; param2(count: param1+1)&#125;func1(3, param2: &#123; (count) in print(count) &#125;, param3: &#123; (count) in print(count)&#125;) 还有一种更加简单的闭包书写方法，如果闭包类型是确定的，全完可以省略小括号中的参数名称与闭包格式in，使用角标来获取参数，示例如下： 123456//优化前var f:(a:Int,b:Int)-&gt;Bool = &#123;(a,b) in return a&gt;b&#125;f(a: 3,b: 4)//优化后var f:(a:Int,b:Int)-&gt;Bool = &#123;$0&gt;$1&#125;f(a: 3,b: 4) 八、类与属性Swift中使用class关键字来定义类，类内部可以声明与定义一些属性与方法，类的实例对象可以通过点语法来调用类的属性和方法，示例如下： 1234567891011class MyClass &#123; var count = 100 let name = &quot;珲少&quot; func run() &#123; print(&quot;run 100 miter&quot;) &#125;&#125;var obj = MyClass()let count = obj.countlet name = obj.nameobj.run() 类名加括号用于创建类的实例对象，可以通过重写init方法来重写类的默认构造方法，如果这个类有继承的父类，则需要遵守如下3条规则： 1.必须先将子类的属性初始化完成。 2.调用父类的构造方法。 3.修改父类需要修改的属性。 在Swift中同样也有set和get方法，只是这里的set和get方法与Objective-C中的set和get方法有很大的不同，Objective-C中的get和set方法是截获了属性和存取过程，在其中加入额外的其他操作，Swift中的set和get方法原理上将属性的存取与其他逻辑操作进行了分离，抽象出了一种计算属性，示例如下： 12345678910111213141516171819class MyClass &#123; var count:Int //实际上并不存在privateCount属性 通过pricatecount来操作count的值 var privateCount:Int&#123; get&#123; return count; &#125; set &#123; count=newValue+100 &#125; &#125; let name = &quot;珲少&quot; func run() &#123; print(&quot;run 100 miter&quot;) &#125; init()&#123; count=200 &#125;&#125; Swift采用这样的设计思路也有其一定的优化道理，我比较了一下，给大家举一个最简单的例子，在使用Objective-C进行iOS开发时，经常会遇到这样的情况，某个控件中有一个UILabel控件，开发者在不想将控件暴漏在.h文件中的情况下经常会声明一个NSString类型的变量，重写此变量的set方法来完成对UILabel控件的赋值，仔细想来，实际上声明的这个NSString变量完全是多余的，它只是为了用来做中间值得传递，Swift的set和get方法就在这里进行了优化。另外，在set方法中会自动生成一个命名为newValue的变量作为传递进来的值，开发者也可以自定义这个变量的名称，在set后加小括号即可，示例如下： 12345678var privateCount:Int&#123; get&#123; return count; &#125; set(myValue) &#123; count=myValue+100 &#125; &#125; Swift中也提供了监听属性赋值过程的方法，其使用的是willSet与didSet机制，示例如下： 12345678910111213141516171819class MyClass &#123; var count:Int&#123; //赋值前执行(除了第一次初始赋值) 将要赋值的值以newValue传入 willSet&#123; print(&quot;will set \\(newValue)&quot;) &#125; //赋值后执行(除了第一次初始赋值) 原来的值以oldValue传入 didSet&#123; print(&quot;did set \\(oldValue)&quot;) &#125; &#125; let name = &quot;珲少&quot; func run() &#123; print(&quot;run 100 miter&quot;) &#125; init()&#123; count=200 &#125;&#125; 九、枚举和结构体Swift中的枚举和C与Objective-C有很大的差别，在Swift中，枚举也被作为一种数据类型来处理，其中可以添加函数方法。最基本的枚举用法如下所示： 12345678//枚举可以多个case并列 也可以写在一个case中以逗号分隔enum MyEnum &#123; case one case tew case three case Fir,Sec,Thr&#125;var em = MyEnum.one 如果变量是类型确定的枚举，在赋值时可以省略枚举名，示例如下： 1var em:MyEnum = .one Swift中的枚举还有一个原始值的概念，要使用原始值，必须在创建枚举类型时设置原始值的类型，示例如下： 1234567enum MyEnum:Int &#123; case one=1 case tew case three case Fir,Sec,Thr&#125;var em = MyEnum.one.rawValue 如果原始值是Int类型，则默认从0开始依次递增，开发者也可以手动设置每个枚举值的原始值。同样，也支持使用原始值来创建枚举实例，如下： 1var em = MyEnum(rawValue:1) 通过原始值实例的枚举对象实际上回返回一个optional类型的值，如果传入的原始值参数不能匹配到任何一个枚举case，则可以使用if let结构进行判断处理。 在枚举中封装方法示例如下： 12345678910111213141516enum MyEnum:Int &#123; case one case tew case three case Fir,Sec,Thr func des() &#123; switch self &#123; case .one: print(&quot;one&quot;) default: print(&quot;else&quot;) &#125; &#125;&#125;var em = MyEnum(rawValue:1)em?.des() Swift中的枚举也可以添加附加值，在switch语句中取到对应的枚举类型后，可以获取开发者设置的附加值进行逻辑处理，示例如下： 1234567891011121314151617181920212223enum MyEnum &#123;//为这个类型天啊及一组附加值 case one(String,Int) case tew case three case Fir,Sec,Thr func des() &#123; switch self &#123; case .one: print(&quot;one&quot;) default: print(&quot;else&quot;) &#125; &#125;&#125;var em = MyEnum.one(&quot;第一个元素&quot;, 1)switch em &#123;//前面的let指定附加值为常量 或者用var指定为变量，括号内为附加值参数名case let .one(param1, param2): print(&quot;One param is \\(param1) and two param is \\(param2).&quot;)default: print(&quot;else&quot;)&#125; Swift中使用struct关键字来进行结构体的创建，结构体的功能和类相似，支持属性与方法，但不同的是，结构体在传递时会被赋值，类的实例则会以引用的方式传递。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}],"tags":[],"keywords":[{"name":"Swift语法专题","slug":"Swift语法专题","permalink":"http://huishao.cc/categories/Swift语法专题/"}]},{"title":"iOS头部渐变的表格视图设计","slug":"200iOS头部渐变的表格视图设计","date":"2016-04-25T16:00:00.000Z","updated":"2021-07-08T02:27:34.606Z","comments":true,"path":"2016/04/26/200iOS头部渐变的表格视图设计/","link":"","permalink":"http://huishao.cc/2016/04/26/200iOS头部渐变的表格视图设计/","excerpt":"","text":"iOS头部渐变的表格视图设计今天再来给大家带来一个开发中常用到的视图控制器，在很多应用中，可能都会遇到这样的一个需求：表视图控制器最上方有一个头图控件，当表格视图滑动在顶部时，导航栏透明，当表格视图逐渐向下滑动时，导航栏渐渐出现，并且在滑动期间，头图会展示相关的渐变动画效果。以前经常会遇到这样的需求，但从没有整理与封装完善，这次将其封装成完整的控件，无论有无导航，都可以很好的支持，方便以后使用也提供给需要的朋友。 在设计控件之前，我们应该先编写控件的头文件，头文件中将控件需要的属性和方法列举，之后再按定义好的接口一步步的来实现控件的编写设计，这样可以结构清晰，并且不会显得无从下手，控件的头文件设计如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//// YHBaseHeaderAnimatedViewController.h// YHBaseFoundationTest//// Created by vip on 16/4/26.// Copyright © 2016年 jaki.zhang. All rights reserved./* * 这个视图控制器创建出带缩放头图效果的视图控制器 * tip： * 1.这个视图控制器如果是被导航push出来的 则内部会使用假导航进行渐隐模拟 * 2.这个视图控制器如果是被present出来的 则不会出现假导航栏 * 3.这个视图控制器中自带一个TableView 设置TableView的头图不会影响原动画效果 * */#import &lt;UIKit/UIKit.h&gt;/** * 这个枚举设置头图动画滑动的速度等级 */typedef enum &#123; YHBaseHeaderAnimatedLevelSlow, YHBaseHeaderAnimatedLevelNormal, YHBaseHeaderAnimatedLevelFast&#125;YHBaseHeaderAnimatedLevel;@interface YHBaseHeaderAnimatedViewController : UIViewController&lt;UITableViewDataSource,UITableViewDelegate&gt;@property(nonatomic,strong,readonly)UITableView * tableView;/** * 设置动画头图图片 */@property(nonatomic,strong)UIView * animatedHeaderView;/** * 设置TableView的头视图 * * 注意：设置tableView的头视图不能够在使用tableHeatherView方法 要使用这个属性设置 * */@property(nonatomic,strong)UIView * tableHeaderView;/** * 设置动画头图高度 * * 这个属性如果不设置或者设置为0 则默认会使用设置的image图片比例 * */@property(nonatomic,assign)CGFloat headerHeight;/** * * 设置动画滑动速率 */@property(nonatomic,assign)YHBaseHeaderAnimatedLevel animatedlevel;/** * * 设置头图可方法的最大scrollView偏移量 默认为40 * */@property(nonatomic,assign)CGFloat maxScrollOffset;/** * 设置是否带渐隐效果 * */@property(nonatomic,assign)BOOL alphaAnimated;/** * 设置最小渐变到的alpha渐隐值 &lt;0 &gt;1之间 默认为0.5 * */@property(nonatomic,assign)CGFloat minAlpha;/** * * 是否显示毛玻璃模糊效果 * */@property(nonatomic,assign)BOOL bluerAnimated;/** * * 设置最大小模糊度 默认为1 * */@property(nonatomic,assign)CGFloat maxBluer;/** * 设置导航栏颜色 默认白色 * */@property(nonatomic,strong)UIColor * naviColor;/** * 设置导航左侧按钮数组 如果不设置 会自动带一个返回按钮 * */@property(nonatomic,strong)NSArray * leftBarButtons;/** * 设置导航左侧按钮数组 如果不设置 会自动带一个返回按钮 * */@property(nonatomic,strong)NSArray * rightBarButtons;/** * 这个方法在修改了头图相关属性后 需要调用刷新 * * 注意：如果重新设置了TableView的tableheaderView属性 也需要调用这个方法刷新 * */-(void)reloadAnimatedView;@end 在设计这个控件时，我主要考虑两个需要优化的地方，第一是这个控制器在不同的场景下可能会有不同的结构，例如在导航结构中被push出来或者通过模态跳转被present出来，我在这个控件的实现时做了兼容，实际上无论有无导航，控件内部都没有使用系统的导航栏，而是模拟实现了一个自定义的导航栏来与系统的导航无缝衔接。 .m文件中实现的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#import &quot;YHBaseHeaderAnimatedViewController.h&quot;@interface YHBaseHeaderAnimatedViewController ()&#123; //承载视图 UIView * _privteBGHeaderView; //宽高比例 CGFloat _privteRate; //原始宽高 CGFloat _privteOriWidth; CGFloat _privteOriHeught; UIVisualEffectView * _blurView; UINavigationBar * _naviBar;&#125;@end@implementation YHBaseHeaderAnimatedViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.edgesForExtendedLayout = UIRectEdgeNone; _tableView = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain]; [self.view addSubview:_tableView]; _tableView.delegate=self; _tableView.dataSource=self; [self YHCreatView]; // Do any additional setup after loading the view.&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;//对导航进行处理-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; if (self.navigationController) &#123; [self.navigationController setNavigationBarHidden:YES animated:YES]; [self showNavigationBar]; &#125;&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; if (self.navigationController) &#123; [self.navigationController setNavigationBarHidden:NO animated:YES]; &#125;&#125;-(void)showNavigationBar&#123; if (_naviBar==nil) &#123; _naviBar = [[UINavigationBar alloc]init]; [self.view addSubview:_naviBar]; _naviBar.frame = CGRectMake(0, 0, self.view.frame.size.width, 64); [_naviBar setBackgroundImage:[UIImage imageNamed:@&quot;clear&quot;] forBarMetrics:UIBarMetricsDefault]; [_naviBar setShadowImage:[UIImage imageNamed:@&quot;clear&quot;]]; _naviBar.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0]; UINavigationItem * item = [[UINavigationItem alloc]initWithTitle:self.title]; _naviBar.items = @[item]; item.leftBarButtonItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;返回&quot; style:UIBarButtonItemStyleDone target:self action:@selector(popToLast)]; &#125; if (self.animatedHeaderView==nil) &#123; _naviBar.hidden=YES; &#125;else&#123; _naviBar.hidden=NO; &#125;&#125;-(void)popToLast&#123; [self.navigationController popViewControllerAnimated:YES];&#125;-(void)YHCreatView&#123; if (self.maxScrollOffset==0) &#123; self.maxScrollOffset=40; &#125; if (self.minAlpha==0) &#123; self.minAlpha = 0.5; &#125; if (self.maxBluer==0) &#123; self.maxBluer = 1; &#125; _privteBGHeaderView = [[UIView alloc]init]; _privteBGHeaderView.backgroundColor = [UIColor clearColor]; self.tableView.backgroundColor = [UIColor clearColor]; _blurView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]]; [self reloadAnimatedView];&#125;-(void)reloadAnimatedView&#123; CGFloat viewH=0; CGFloat aniH=0; for (UIView * view in _privteBGHeaderView.subviews) &#123; [view removeFromSuperview]; &#125; if (self.tableHeaderView) &#123; viewH = viewH+self.tableHeaderView.bounds.size.height; [_privteBGHeaderView addSubview:self.tableHeaderView]; &#125; if (self.animatedHeaderView) &#123; _privteRate = self.animatedHeaderView.frame.size.width/self.animatedHeaderView.frame.size.height; [self.animatedHeaderView addSubview:_blurView]; _blurView.frame= self.animatedHeaderView.bounds; _blurView.alpha=0; _privteOriWidth = self.animatedHeaderView.frame.size.width; _privteOriHeught = self.animatedHeaderView.frame.size.height; if (self.headerHeight!=0) &#123; viewH+=self.headerHeight; aniH = self.headerHeight; &#125;else&#123; viewH+=self.view.frame.size.width/self.animatedHeaderView.bounds.size.width*self.animatedHeaderView.frame.size.height; aniH = self.animatedHeaderView.bounds.size.height; &#125; [self.view insertSubview:self.animatedHeaderView atIndex:0]; &#125; self.tableHeaderView.frame=CGRectMake(0, aniH, self.tableHeaderView.frame.size.width, self.tableHeaderView.frame.size.height); _privteBGHeaderView.frame=CGRectMake(0, 0, self.view.frame.size.width, viewH); self.tableView.tableHeaderView = _privteBGHeaderView;&#125;-(void)setAnimatedHeaderView:(UIView *)animatedHeaderView&#123; if (animatedHeaderView==nil) &#123; if (_animatedHeaderView) &#123; [_animatedHeaderView removeFromSuperview]; &#125; &#125; _animatedHeaderView = animatedHeaderView; &#125;-(void)setMinAlpha:(CGFloat)minAlpha&#123; if (minAlpha&lt;=0) &#123; minAlpha=0.001; &#125; if (minAlpha&gt;=1) &#123; minAlpha=0.999; &#125; _minAlpha=minAlpha;&#125;-(void)setMaxBluer:(CGFloat)maxBluer&#123; if (maxBluer&lt;=0) &#123; maxBluer = 0.001; &#125; if (maxBluer&gt;=1) &#123; maxBluer = 0.999; &#125; _maxBluer = maxBluer;&#125;-(void)setNaviColor:(UIColor *)naviColor&#123; _naviColor = naviColor; _naviBar.backgroundColor = naviColor;&#125;-(void)setLeftBarButtons:(NSArray *)leftBarButtons&#123; _naviBar.topItem.leftBarButtonItems = leftBarButtons; _leftBarButtons = leftBarButtons;&#125;-(void)setRightBarButtons:(NSArray *)rightBarButtons&#123; _naviBar.topItem.rightBarButtonItems = rightBarButtons; _rightBarButtons = rightBarButtons;&#125;-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (self.animatedHeaderView==nil) &#123; return; &#125; if (self.tableView==scrollView) &#123; //获取到偏移量 默认两倍 CGFloat offset = scrollView.contentOffset.y*2; //如果小于0 则进行形变拉伸操作 if (offset&lt;=0) &#123; if (offset&lt;-self.maxScrollOffset*2) &#123; &#125;else&#123; CGFloat height = _privteOriHeught+abs((int)offset); CGFloat width = height*_privteRate; self.animatedHeaderView.frame = CGRectMake(self.view.frame.size.width/2-width/2, offset/2, width, height); &#125; if (_naviBar) &#123; if (_naviBar.shadowImage==nil) &#123; [_naviBar setShadowImage:[UIImage imageNamed:@&quot;clear&quot;]]; &#125; &#125; &#125;else&#123; //如果大于零 进行推出操作 if (self.animatedlevel==YHBaseHeaderAnimatedLevelSlow) &#123; //慢速 self.animatedHeaderView.frame = CGRectMake(0, -offset/8, self.animatedHeaderView.frame.size.width, self.animatedHeaderView.frame.size.height); &#125;else if(self.animatedlevel==YHBaseHeaderAnimatedLevelFast)&#123; //快速 self.animatedHeaderView.frame = CGRectMake(0, -offset/2, self.animatedHeaderView.frame.size.width, self.animatedHeaderView.frame.size.height); &#125;else&#123; //正常 self.animatedHeaderView.frame = CGRectMake(0, -offset/4, self.animatedHeaderView.frame.size.width, self.animatedHeaderView.frame.size.height); &#125; //进行渐隐动画处理 CGFloat tmp = offset/2/_privteOriHeught; if (self.alphaAnimated) &#123; self.animatedHeaderView.alpha = 1-(1-self.minAlpha)*tmp; &#125; //进行模糊动画 if (self.bluerAnimated) &#123; _blurView.alpha = self.maxBluer*tmp; &#125; //进行导航显示 if (_naviBar) &#123; _naviBar.backgroundColor = [_naviBar.backgroundColor colorWithAlphaComponent:tmp]; if (_naviBar.shadowImage) &#123; [_naviBar setShadowImage:nil]; &#125; &#125; &#125; &#125;&#125;@end 在使用时，创建一个视图控制器继承于它，在其viewDidLoad方法中进行一些简单的设置即可，如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //设置头图 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 200)]; imageView.image = [UIImage imageNamed:@&quot;image&quot;]; self.animatedHeaderView = imageView; //设置tableView的头视图 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 30)]; label.backgroundColor = [UIColor purpleColor]; label.textColor = [UIColor whiteColor]; label.textAlignment =NSTextAlignmentCenter; label.text = @&quot;下面进行功能演示&quot;; self.tableHeaderView = label; [self reloadAnimatedView];&#125; 我写了一个完整的演示Demo，Demo中有完整的功能演示，需要的朋友可以自行下载：http://pan.baidu.com/s/1c1VKT00。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"配合LLDB调试器进行iOS代码调试","slug":"199配合LLDB调试器进行iOS代码调试","date":"2016-04-23T16:00:00.000Z","updated":"2021-07-08T02:26:37.528Z","comments":true,"path":"2016/04/24/199配合LLDB调试器进行iOS代码调试/","link":"","permalink":"http://huishao.cc/2016/04/24/199配合LLDB调试器进行iOS代码调试/","excerpt":"","text":"配合LLDB调试器进行iOS代码调试在一款完整iOS移动应用的开发中，代码的调试和编写占着同等重要的地位。Xcode默认使用LLDB作为代码调试器，LLDB功能丰富且强大，恰当的使用它，可以帮助开发者事半功倍的完成代码调试的工作。 1.expression代码执行指令关于LLDB调试器，最常用的指令应该是p与po了，开发者常用这两个命令来进行对象的打印操作，p会打印出对象地址和类型，po则会额外打印出对象的值得内容，实际上，这两个命令都是expression相关命令的简写。expression命令也并非简单的打印命令，实际上它是一个执行代码命令，执行后将返回值进行打印，这个命令有一个十分强大的特点，它可以真实改变程序运行中变量的值。例如在如下代码中的int c = a+b 一行添加一个断点，运行工程。 1234 int a = 0; int b = 1; int c = a+b; NSLog(@&quot;%d&quot;,c); 如果开发者不进行任何认为操作，此时打印出的值应该是1，为了测试，可以在调试区输入如下命令： 1(lldb) expression a=1 此后跳过断点继续运行程序，可以看到打印的结果如下，c变成2。 123(lldb) expression a=1(int) $0 = 12016-04-24 11:39:40.213 BreakPointTest[1010:79065] 2 通过上面的演示，我们发现使用LLDB调试代码十分方便的一个特点，当我们知道程序某个地方可能会出现问题，为了找到解决方法，不使用LLDB时我们可能需要在代码中添加大量的打印函数，并且多次尝试修改源代码才能解决问题，如果使用LLDB的expression命令，我们不仅不需要添加额外的打印代码，也不需要直接修改源代码，在调试区进行多次调试，直到找到正确的修改方法后再对源代码修改一次即可。 2.frame代码堆栈块信息相关指令当Xcode进入断点调试或者遇到异常程序崩溃时，在Xcode左侧的导航区都会将程序运行中的相关堆栈块信息列举出来，例如使用如下测试代码，在text方法中的int c = a+b 一行添加一个断点。 12345678910111213141516171819#import &quot;ViewController.h&quot;@interface ViewController ()&#123; int ab;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; ab = 1; [self test]; &#125;-(void)test&#123; int a = 0; int b = 1; int c = a+b; NSLog(@&quot;%d&quot;,c);&#125;@end 当程序运行到断点处断开时，Xcode左侧的堆栈块如下图所示： 从图中可以看出，程序当前处于激活状态的线程有5个，程序目前断在线程1中的test方法堆栈块中，使用frame info指令可以打印当前堆栈块的信息，示例如下： 12(lldb) frame infoframe #0: 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39 在打印的信息中，会有所在的文件名称和函数名称及堆栈块标号和内存地址。 在实际代码调试过程中，程序运行的回溯是一个重要的方法，例如上面的代码例子，虽然现在断点断在test方法中，开发者可能需要在viewDidLoad方法中进行相关调试，例如上面viewDidLoad方法中有一个变量ab，如果想查看ab变量的值，我们就需要将当前选中调试的堆栈块选择为viewDidLoad方法所在的堆栈块，从Xcode左侧导航区可以看到，viewDidLoad方法堆栈块的标号为1，执行如下LLDB指令即可切换： 12345678(lldb) frame select 1frame #1: 0x00000001024978cb BreakPointTest`-[ViewController viewDidLoad](self=0x00007fcd5b413320, _cmd=&quot;viewDidLoad&quot;) + 91 at ViewController.m:31 28 int a = 0; 29 int b = 1; 30 int c = a+b;-&gt; 31 NSLog(@&quot;%d&quot;,c); 32 &#125; 33 @end 从打印信息可以看到，现在选中的调试堆栈块已经切换到viewDidLoad方法，再使用expression指令时就可以操作这个方法中的相关变量了。 在使用LLDB工具前，遇到这样的情况，我往往会采用打多个断点，一步步追溯代码的运行过程并检查过程中变量的值是否正确，调试起来并不十分方便，如果不小心错过了某个断点，又要重新开始，通过选择调试的frame堆栈块可以十分方便的解决这个问题。 与frame相关的还有一个指令十分有用，下面的指令可以打印出当前堆栈块中所有对象的内容： 123456(lldb) frame variable(ViewController *) self = 0x00007fcd5b413320(SEL) _cmd = &quot;test&quot;(int) a = 0(int) b = 1(int) c = 0 variable后面也可以添加参数名来打印特定对象的内容： 12(lldb) frame variable a(int) a = 0 3.thread线程操作相关指令上面提到过，程序运行中会有多个激活的线程，每个线程中又有许多堆栈块，frame相关指令用于综合调试各个堆栈块，thread指令则是用于综合调试各个线程。首先Xcode左侧导航区为我们列出的线程堆栈块并不是当前线程中的所有堆栈块，使用如下命令可以打印出当前线程的所有堆栈块： 123456789101112131415161718192021222324(lldb) thread backtrace* thread #1: tid = 0x152f8, 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 * frame #0: 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39 frame #1: 0x00000001024978cb BreakPointTest`-[ViewController viewDidLoad](self=0x00007fcd5b413320, _cmd=&quot;viewDidLoad&quot;) + 91 at ViewController.m:31 frame #2: 0x0000000103475984 UIKit`-[UIViewController loadViewIfRequired] + 1198 frame #3: 0x0000000103475cd3 UIKit`-[UIViewController view] + 27 frame #4: 0x000000010334bfb4 UIKit`-[UIWindow addRootViewControllerViewIfPossible] + 61 frame #5: 0x000000010334c69d UIKit`-[UIWindow _setHidden:forced:] + 282 frame #6: 0x000000010335e180 UIKit`-[UIWindow makeKeyAndVisible] + 42 frame #7: 0x00000001032d2ed9 UIKit`-[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 4131 frame #8: 0x00000001032d9568 UIKit`-[UIApplication _runWithMainScene:transitionContext:completion:] + 1769 frame #9: 0x00000001032d6714 UIKit`-[UIApplication workspaceDidEndTransaction:] + 188 frame #10: 0x0000000105d438c8 FrontBoardServices`__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 24 frame #11: 0x0000000105d43741 FrontBoardServices`-[FBSSerialQueue _performNext] + 178 frame #12: 0x0000000105d43aca FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + 45 frame #13: 0x0000000102e4a301 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17 frame #14: 0x0000000102e4022c CoreFoundation`__CFRunLoopDoSources0 + 556 frame #15: 0x0000000102e3f6e3 CoreFoundation`__CFRunLoopRun + 867 frame #16: 0x0000000102e3f0f8 CoreFoundation`CFRunLoopRunSpecific + 488 frame #17: 0x00000001032d5f21 UIKit`-[UIApplication _run] + 402 frame #18: 0x00000001032daf09 UIKit`UIApplicationMain + 171 frame #19: 0x0000000102497c3f BreakPointTest`main(argc=1, argv=0x00007fff5d768668) + 111 at main.m:14 frame #20: 0x00000001056fe92d libdyld.dylib`start + 1 frame #21: 0x00000001056fe92d libdyld.dylib`start + 1 thread list指令则可以打印出当前所有激活的线程，如下： 1234567(lldb) thread listProcess 1049 stopped* thread #1: tid = 0x152f8, 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 thread #2: tid = 0x1531b, 0x0000000105a43ee2 libsystem_kernel.dylib`kevent64 + 10, queue = &apos;com.apple.libdispatch-manager&apos; thread #3: tid = 0x1531c, 0x0000000105a435e2 libsystem_kernel.dylib`__workq_kernreturn + 10 thread #4: tid = 0x15324, 0x0000000105a435e2 libsystem_kernel.dylib`__workq_kernreturn + 10 thread #5: tid = 0x15328, 0x0000000105a435e2 libsystem_kernel.dylib`__workq_kernreturn + 10 thread info可以打印出当前选中调试的线程的信息： 12(lldb) thread infothread #1: tid = 0x152f8, 0x0000000102497905 BreakPointTest`-[ViewController test](self=0x00007fcd5b413320, _cmd=&quot;test&quot;) + 37 at ViewController.m:39, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 同样也可以使用thread select指令来切换选中调试的线程： 1(lldb) thread select 2 thread continue指令用于继续执行当前的线程： 1234(lldb) thread continue2016-04-24 12:29:54.562 BreakPointTest[1049:86776] 1Resuming thread 0x152f8 in process 1049Process 1049 resuming 4.disassemble代码反汇编相关指令disassemble相关指令用于输出某段程序的汇编代码，执行disassemble指令将会反汇编当前函数： 12345678910111213141516171819BreakPointTest`-[ViewController test]: 0x10aab7940 &lt;+0&gt;: pushq %rbp 0x10aab7941 &lt;+1&gt;: movq %rsp, %rbp 0x10aab7944 &lt;+4&gt;: subq $0x20, %rsp 0x10aab7948 &lt;+8&gt;: leaq 0x1711(%rip), %rax ; @&quot;%d&quot; 0x10aab794f &lt;+15&gt;: movq %rdi, -0x8(%rbp) 0x10aab7953 &lt;+19&gt;: movq %rsi, -0x10(%rbp) 0x10aab7957 &lt;+23&gt;: movl $0x0, -0x14(%rbp) 0x10aab795e &lt;+30&gt;: movl $0x1, -0x18(%rbp)-&gt; 0x10aab7965 &lt;+37&gt;: movl -0x14(%rbp), %ecx 0x10aab7968 &lt;+40&gt;: addl -0x18(%rbp), %ecx 0x10aab796b &lt;+43&gt;: movl %ecx, -0x1c(%rbp) 0x10aab796e &lt;+46&gt;: movl -0x1c(%rbp), %esi 0x10aab7971 &lt;+49&gt;: movq %rax, %rdi 0x10aab7974 &lt;+52&gt;: movb $0x0, %al 0x10aab7976 &lt;+54&gt;: callq 0x10aab7c80 ; symbol stub for: NSLog 0x10aab797b &lt;+59&gt;: addq $0x20, %rsp 0x10aab797f &lt;+63&gt;: popq %rbp 0x10aab7980 &lt;+64&gt;: retq 使用disassemble -b则会输出带字节信息的汇编代码： 1234567891011121314151617181920(lldb) disassemble -bBreakPointTest`-[ViewController test]: 0x10aab7940 &lt;+0&gt;: 55 pushq %rbp 0x10aab7941 &lt;+1&gt;: 48 89 e5 movq %rsp, %rbp 0x10aab7944 &lt;+4&gt;: 48 83 ec 20 subq $0x20, %rsp 0x10aab7948 &lt;+8&gt;: 48 8d 05 11 17 00 00 leaq 0x1711(%rip), %rax ; @&quot;%d&quot; 0x10aab794f &lt;+15&gt;: 48 89 7d f8 movq %rdi, -0x8(%rbp) 0x10aab7953 &lt;+19&gt;: 48 89 75 f0 movq %rsi, -0x10(%rbp) 0x10aab7957 &lt;+23&gt;: c7 45 ec 00 00 00 00 movl $0x0, -0x14(%rbp) 0x10aab795e &lt;+30&gt;: c7 45 e8 01 00 00 00 movl $0x1, -0x18(%rbp)-&gt; 0x10aab7965 &lt;+37&gt;: 8b 4d ec movl -0x14(%rbp), %ecx 0x10aab7968 &lt;+40&gt;: 03 4d e8 addl -0x18(%rbp), %ecx 0x10aab796b &lt;+43&gt;: 89 4d e4 movl %ecx, -0x1c(%rbp) 0x10aab796e &lt;+46&gt;: 8b 75 e4 movl -0x1c(%rbp), %esi 0x10aab7971 &lt;+49&gt;: 48 89 c7 movq %rax, %rdi 0x10aab7974 &lt;+52&gt;: b0 00 movb $0x0, %al 0x10aab7976 &lt;+54&gt;: e8 05 03 00 00 callq 0x10aab7c80 ; symbol stub for: NSLog 0x10aab797b &lt;+59&gt;: 48 83 c4 20 addq $0x20, %rsp 0x10aab797f &lt;+63&gt;: 5d popq %rbp 0x10aab7980 &lt;+64&gt;: c3 retq 使用disassemble -c 指令可以设置输出汇编代码的行数，如下： 1234567(lldb) disassemble -c 5BreakPointTest`-[ViewController test]: 0x10aab7940 &lt;+0&gt;: pushq %rbp 0x10aab7941 &lt;+1&gt;: movq %rsp, %rbp 0x10aab7944 &lt;+4&gt;: subq $0x20, %rsp 0x10aab7948 &lt;+8&gt;: leaq 0x1711(%rip), %rax ; @&quot;%d&quot; 0x10aab794f &lt;+15&gt;: movq %rdi, -0x8(%rbp) 使用disassemble -l只输出当前断点处汇编代码： 123456BreakPointTest`-[ViewController test] + 37 at ViewController.m:30 29 int b = 1;-&gt; 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c);BreakPointTest`-[ViewController test]:-&gt; 0x10aab7965 &lt;+37&gt;: movl -0x14(%rbp), %ecx 使用disassemble -m混合显示汇编代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556(lldb) disassemble -mBreakPointTest`-[ViewController test] at ViewController.m:27 26 &#125; 27 -(void)test&#123; 28 int a = 0;BreakPointTest`-[ViewController test]: 0x10aab7940 &lt;+0&gt;: pushq %rbp 0x10aab7941 &lt;+1&gt;: movq %rsp, %rbp 0x10aab7944 &lt;+4&gt;: subq $0x20, %rsp 0x10aab7948 &lt;+8&gt;: leaq 0x1711(%rip), %rax ; @&quot;%d&quot; 0x10aab794f &lt;+15&gt;: movq %rdi, -0x8(%rbp) 0x10aab7953 &lt;+19&gt;: movq %rsi, -0x10(%rbp)BreakPointTest`-[ViewController test] + 23 at ViewController.m:28 27 -(void)test&#123; 28 int a = 0; 29 int b = 1; 0x10aab7957 &lt;+23&gt;: movl $0x0, -0x14(%rbp)BreakPointTest`-[ViewController test] + 30 at ViewController.m:29 28 int a = 0; 29 int b = 1; 30 int c = a+b; 0x10aab795e &lt;+30&gt;: movl $0x1, -0x18(%rbp)BreakPointTest`-[ViewController test] + 37 at ViewController.m:30 29 int b = 1;-&gt; 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c);-&gt; 0x10aab7965 &lt;+37&gt;: movl -0x14(%rbp), %ecxBreakPointTest`-[ViewController test] + 40 at ViewController.m:30 29 int b = 1; 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c); 0x10aab7968 &lt;+40&gt;: addl -0x18(%rbp), %ecxBreakPointTest`-[ViewController test] + 43 at ViewController.m:30 29 int b = 1; 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c); 0x10aab796b &lt;+43&gt;: movl %ecx, -0x1c(%rbp)BreakPointTest`-[ViewController test] + 46 at ViewController.m:31 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c); 32 &#125; 0x10aab796e &lt;+46&gt;: movl -0x1c(%rbp), %esiBreakPointTest`-[ViewController test] + 49 at ViewController.m:31 30 int c = a+b; 31 NSLog(@&quot;%d&quot;,c); 32 &#125; 0x10aab7971 &lt;+49&gt;: movq %rax, %rdi 0x10aab7974 &lt;+52&gt;: movb $0x0, %al 0x10aab7976 &lt;+54&gt;: callq 0x10aab7c80 ; symbol stub for: NSLogBreakPointTest`-[ViewController test] + 59 at ViewController.m:32 31 NSLog(@&quot;%d&quot;,c); 32 &#125; 33 @end 0x10aab797b &lt;+59&gt;: addq $0x20, %rsp 0x10aab797f &lt;+63&gt;: popq %rbp 0x10aab7980 &lt;+64&gt;: retq 使用disassemble -p进行当前行的汇编代码输出： 123456(lldb) disassemble -pBreakPointTest`-[ViewController test]:-&gt; 0x10aab7965 &lt;+37&gt;: movl -0x14(%rbp), %ecx 0x10aab7968 &lt;+40&gt;: addl -0x18(%rbp), %ecx 0x10aab796b &lt;+43&gt;: movl %ecx, -0x1c(%rbp) 0x10aab796e &lt;+46&gt;: movl -0x1c(%rbp), %esi 5.其他LLDB常用指令bt指令用于打印当前线程所有堆栈块信息： 123456789101112131415161718192021222324(lldb) bt* thread #1: tid = 0x19f11, 0x000000010aab7965 BreakPointTest`-[ViewController test](self=0x00007fee9c11e330, _cmd=&quot;test&quot;) + 37 at ViewController.m:30, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 2.1 * frame #0: 0x000000010aab7965 BreakPointTest`-[ViewController test](self=0x00007fee9c11e330, _cmd=&quot;test&quot;) + 37 at ViewController.m:30 frame #1: 0x000000010aab792b BreakPointTest`-[ViewController viewDidLoad](self=0x00007fee9c11e330, _cmd=&quot;viewDidLoad&quot;) + 91 at ViewController.m:22 frame #2: 0x000000010ba95984 UIKit`-[UIViewController loadViewIfRequired] + 1198 frame #3: 0x000000010ba95cd3 UIKit`-[UIViewController view] + 27 frame #4: 0x000000010b96bfb4 UIKit`-[UIWindow addRootViewControllerViewIfPossible] + 61 frame #5: 0x000000010b96c69d UIKit`-[UIWindow _setHidden:forced:] + 282 frame #6: 0x000000010b97e180 UIKit`-[UIWindow makeKeyAndVisible] + 42 frame #7: 0x000000010b8f2ed9 UIKit`-[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 4131 frame #8: 0x000000010b8f9568 UIKit`-[UIApplication _runWithMainScene:transitionContext:completion:] + 1769 frame #9: 0x000000010b8f6714 UIKit`-[UIApplication workspaceDidEndTransaction:] + 188 frame #10: 0x000000010e3638c8 FrontBoardServices`__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 24 frame #11: 0x000000010e363741 FrontBoardServices`-[FBSSerialQueue _performNext] + 178 frame #12: 0x000000010e363aca FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + 45 frame #13: 0x000000010b46a301 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17 frame #14: 0x000000010b46022c CoreFoundation`__CFRunLoopDoSources0 + 556 frame #15: 0x000000010b45f6e3 CoreFoundation`__CFRunLoopRun + 867 frame #16: 0x000000010b45f0f8 CoreFoundation`CFRunLoopRunSpecific + 488 frame #17: 0x000000010b8f5f21 UIKit`-[UIApplication _run] + 402 frame #18: 0x000000010b8faf09 UIKit`UIApplicationMain + 171 frame #19: 0x000000010aab7c5f BreakPointTest`main(argc=1, argv=0x00007fff55148668) + 111 at main.m:14 frame #20: 0x000000010dd1e92d libdyld.dylib`start + 1 frame #21: 0x000000010dd1e92d libdyld.dylib`start + 1 c指令**继续运行线程和process continue**效果一样。 call指令**运行一个表达式，**和 expression 效果一样。 detach指令**结束当前调试的线程。** di指令**反汇编当前函数与disassemble**相同。 exit指令**退出lldb调试器。** finish指令**完成当前堆栈块的调试，**程序会继续运行。 n指令**进行单步调试，与next**作用一样。 p指令**与expression作用一样。** print指令用于变量的打印。 r指令**重新运行应用程序。** quit指令结束调试。 bugreport指令用于创建堆栈信息报告。 command history指令用于打印LLDB调试命令记录。 help指令用于查询LLDB相关调试指令的用法。 apropo指令用于查询某些包含某些关键字的指令。 version指令用于查询LLDB调试器的版本，如下： 12(lldb) versionlldb-350.0.21.3 image list命令用于打印工程中所有用到的库文件。 image相关指令还有一个十分有用的命令，image lookup --address可以查询某个内存地址的内容，如下： 123(lldb) image lookup --address 0x000000010373e885 Address: CoreFoundation[0x00000000000f4885] (CoreFoundation.__TEXT.__text + 996309) Summary: CoreFoundation`-[__NSArray0 objectAtIndex:] + 101 image lookup --type用于查询某种类型中包含的属性，如下： 123456789101112131415161718192021222324(lldb) image lookup --type UILabelBest match found in /Users/vip/Library/Developer/Xcode/DerivedData/BreakPointTest-cearqrjqbntqcnfgiqzpxhyadewi/Build/Products/Debug-iphonesimulator/BreakPointTest.app/BreakPointTest:id = &#123;0x000082c1&#125;, name = &quot;UILabel&quot;, byte-size = 8, decl = UILabel.h:18, compiler_type = &quot;@interface UILabel : UIView@property ( getter = text,setter = setText:,readwrite,copy,nonatomic ) NSString * text;@property ( getter = font,setter = setFont:,readwrite,nonatomic ) UIFont * font;@property ( getter = textColor,setter = setTextColor:,readwrite,nonatomic ) UIColor * textColor;@property ( getter = shadowColor,setter = setShadowColor:,readwrite,nonatomic ) UIColor * shadowColor;@property ( getter = shadowOffset,setter = setShadowOffset:,assign,readwrite,nonatomic ) CGSize shadowOffset;@property ( getter = textAlignment,setter = setTextAlignment:,assign,readwrite,nonatomic ) NSTextAlignment textAlignment;@property ( getter = lineBreakMode,setter = setLineBreakMode:,assign,readwrite,nonatomic ) NSLineBreakMode lineBreakMode;@property ( getter = attributedText,setter = setAttributedText:,readwrite,copy,nonatomic ) NSAttributedString * attributedText;@property ( getter = highlightedTextColor,setter = setHighlightedTextColor:,readwrite,nonatomic ) UIColor * highlightedTextColor;@property ( getter = isHighlighted,setter = setHighlighted:,assign,readwrite,nonatomic ) BOOL highlighted;@property ( getter = isUserInteractionEnabled,setter = setUserInteractionEnabled:,assign,readwrite,nonatomic ) BOOL userInteractionEnabled;@property ( getter = isEnabled,setter = setEnabled:,assign,readwrite,nonatomic ) BOOL enabled;@property ( getter = numberOfLines,setter = setNumberOfLines:,assign,readwrite,nonatomic ) NSInteger numberOfLines;@property ( getter = adjustsFontSizeToFitWidth,setter = setAdjustsFontSizeToFitWidth:,assign,readwrite,nonatomic ) BOOL adjustsFontSizeToFitWidth;@property ( getter = baselineAdjustment,setter = setBaselineAdjustment:,assign,readwrite,nonatomic ) UIBaselineAdjustment baselineAdjustment;@property ( getter = minimumScaleFactor,setter = setMinimumScaleFactor:,assign,readwrite,nonatomic ) CGFloat minimumScaleFactor;@property ( getter = allowsDefaultTighteningForTruncation,setter = setAllowsDefaultTighteningForTruncation:,assign,readwrite,nonatomic ) BOOL allowsDefaultTighteningForTruncation;@property ( getter = preferredMaxLayoutWidth,setter = setPreferredMaxLayoutWidth:,assign,readwrite,nonatomic ) CGFloat preferredMaxLayoutWidth;@property ( getter = minimumFontSize,setter = setMinimumFontSize:,assign,readwrite,nonatomic ) CGFloat minimumFontSize;@property ( getter = adjustsLetterSpacingToFitWidth,setter = setAdjustsLetterSpacingToFitWidth:,assign,readwrite,nonatomic ) BOOL adjustsLetterSpacingToFitWidth;@end&quot; x指令可以读取某段内存的二进制数据： 123(lldb) x 0x000000010373e8850x10373e885: 66 66 2e 0f 1f 84 00 00 00 00 00 55 48 89 e5 48 ff.........UH..H0x10373e895: 8d 3d 6d f2 28 00 e8 c0 d9 f0 ff 48 89 05 c1 58 .=m.(......H...X LLDB的用法和技巧还有很多，它可以大大提高我们调试代码的效率，有疏漏和错误之处，还望与志同道合的朋友共同学习进步。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"带动画渐进效果与颜色渐变的圆弧进度控件设计","slug":"198带动画渐进效果与颜色渐变的圆弧进度控件设计","date":"2016-04-15T16:00:00.000Z","updated":"2021-07-08T02:24:31.406Z","comments":true,"path":"2016/04/16/198带动画渐进效果与颜色渐变的圆弧进度控件设计/","link":"","permalink":"http://huishao.cc/2016/04/16/198带动画渐进效果与颜色渐变的圆弧进度控件设计/","excerpt":"","text":"带动画渐进效果与颜色渐变的圆弧进度控件设计今天帮朋友写了一个小巧的圆弧进度控件，控件十分简单，主要设计思路采用CAShapeLayer来创建控件圆弧形状，使用CAGradientLayer来进行颜色渐变的渲染，两者结合来创建出颜色渐变的圆弧进度条控件，关于进度动画采用CoreAnimation动画处理。控件进行了简洁的封装，提供了面向使用的接口，需要的朋友可以自取，Demo地址如下： http://pan.baidu.com/s/1gfqDbtp。 控件中主要提供了，改变进度条渐变颜色，圆弧进度条宽度，带动画效果的改变进度，改变进度百分比字体颜色等方法。效果是例如如下： 改变字体颜色 改变进度 改变进度条颜色 改变进度条宽度 控件接口的设计： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &lt;UIKit/UIKit.h&gt;@interface YHBaseCircleView : UIView//==============下面三个渐变色必须全部设置 否则效果可能与预期不同================///** *设置圆弧渐变色的起始色 */@property(nonatomic,strong)UIColor * minLineColor;/** *设置圆弧渐变色的中间色 */@property(nonatomic,strong)UIColor * midLineColor;/** *设置圆弧渐变色的终止色 */@property(nonatomic,strong)UIColor * maxLineColor;/** *设置圆弧背景色 */@property(nonatomic,strong)UIColor * lineTintColor;/** *设置进度 */@property(nonatomic,assign)CGFloat progress;/** *设置线的宽度 max = 20 min = 0.5 */@property(nonatomic,assign)CGFloat lineWidth;/** *设置是否显示百分比标签 */@property(nonatomic,assign)BOOL showTipLabel;/** *设置百分比标签进度颜色 */@property(nonatomic,strong)UIColor * textColor;/** * @brief 设置进度 * * @param progress 进度 取值0-1 * * @param animated 是否显示动画 * */-(void)setProgress:(CGFloat)progress animated:(BOOL)animated;@end 实现方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#import &quot;YHBaseCircleView.h&quot;@implementation YHBaseCircleView&#123; //进度控件内容尺寸 float _contentWidth; float _contentHeight; //形状layer CAShapeLayer * _shapeLayer; //颜色渐变layer CAGradientLayer * _gradLayerR; CAGradientLayer * _gradLayerL; CALayer * _gradLayer; //内容layer CAShapeLayer * _contentLayer; UILabel * _tipLabel; //专门用来更新label NSTimer * _timer; float _oldProgress; //进度新旧进度值 int old; int new;&#125;-(void)awakeFromNib&#123; [self reloadView];&#125;-(instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self reloadView]; &#125; return self;&#125;-(void)reloadView&#123; self.backgroundColor = [UIColor clearColor]; //取设置的frame的最小长或款作为内容区域 _contentWidth = _contentHeight = CGRectGetWidth(self.frame)&gt;CGRectGetHeight(self.frame)?CGRectGetHeight(self.frame):CGRectGetWidth(self.frame); //创建内容layer _contentLayer = [CAShapeLayer layer]; _contentLayer.bounds = CGRectMake(0, 0, _contentWidth, _contentHeight); _contentLayer.position = CGPointMake(_contentWidth/2, _contentHeight/2); _contentLayer.backgroundColor = [UIColor clearColor].CGColor; //进行边界描绘 默认线宽为4px UIBezierPath * pathT = [UIBezierPath bezierPathWithArcCenter:_contentLayer.position radius:_contentWidth/2-2 startAngle:-M_PI_2 endAngle:M_PI_2*3 clockwise:YES]; _contentLayer.path = pathT.CGPath; //默认填充颜色为白色 _contentLayer.fillColor = [UIColor whiteColor].CGColor; _contentLayer.lineWidth = 4; _contentLayer.strokeColor = [UIColor grayColor].CGColor; [self.layer addSublayer:_contentLayer]; _shapeLayer = [CAShapeLayer layer]; _shapeLayer.bounds = CGRectMake(0, 0, _contentWidth, _contentHeight); _shapeLayer.position = CGPointMake(_contentWidth/2, _contentHeight/2); _shapeLayer.backgroundColor = [UIColor clearColor].CGColor;// _shapeLayer.lineCap = kCALineCapRound; //进行边界描绘 默认线宽为4px UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:_shapeLayer.position radius:_contentWidth/2-2 startAngle:-M_PI_2 endAngle:M_PI_2*3 clockwise:YES]; _shapeLayer.path = path.CGPath; _shapeLayer.fillColor = [UIColor clearColor].CGColor; _shapeLayer.lineWidth = 4; _shapeLayer.strokeColor = [UIColor redColor].CGColor; //默认黄转橙转红的边界线 分别由两个gradLayer进行控制 _gradLayer = [CALayer layer]; _gradLayer.bounds = _contentLayer.bounds; _gradLayer.position = _contentLayer.position; _gradLayer.backgroundColor = [UIColor clearColor].CGColor; _gradLayerL = [CAGradientLayer layer]; _gradLayerL.bounds = CGRectMake(0, 0, _contentWidth/2, _contentHeight); _gradLayerL.locations = @[@0.6]; [_gradLayerL setColors:@[(id)[UIColor redColor].CGColor,(id)[UIColor orangeColor].CGColor]]; _gradLayerL.position = CGPointMake(_gradLayerL.bounds.size.width/2, _gradLayerL.bounds.size.height/2); [_gradLayer addSublayer:_gradLayerL]; _gradLayerR = [CAGradientLayer layer]; _gradLayerR.locations = @[@0.6]; _gradLayerR.bounds = CGRectMake(_contentWidth/2, 0, _contentWidth/2, _contentHeight); [_gradLayerR setColors:@[(id)[UIColor yellowColor].CGColor,(id)[UIColor orangeColor].CGColor]]; _gradLayerR.position = CGPointMake(_gradLayerR.bounds.size.width/2+_contentWidth/2, _gradLayerR.bounds.size.height/2); [_gradLayer addSublayer:_gradLayerR]; [_gradLayer setMask:_shapeLayer]; [_contentLayer addSublayer:_gradLayer]; //setter方法初始化 _minLineColor = [UIColor yellowColor]; _midLineColor = [UIColor orangeColor]; _maxLineColor = [UIColor redColor]; _lineTintColor = [UIColor grayColor]; _progress = 1; _lineWidth = 4; _lineTintColor = [UIColor grayColor]; _textColor = [UIColor orangeColor]; _oldProgress = 1; //创建tiplabel [self creatTipLabel]; _timer = [NSTimer scheduledTimerWithTimeInterval:1/60.0 target:self selector:@selector(updateLabel) userInfo:nil repeats:YES]; _timer.fireDate = [NSDate distantFuture]; &#125;-(void)removeFromSuperview&#123; _timer.fireDate = [NSDate distantFuture]; [_timer invalidate]; _timer =nil; [super removeFromSuperview];&#125;-(void)updateLabel&#123; if (old&lt;new) &#123; old++; NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%d%%&quot;,old]]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:22] range:NSMakeRange(0, attri.length-1)]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(attri.length-1, 1)]; [attri addAttribute:NSForegroundColorAttributeName value:_textColor range:NSMakeRange(0, attri.length)]; _tipLabel.attributedText = attri; &#125;else if (old&gt;new)&#123; old--; NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%d%%&quot;,old]]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:22] range:NSMakeRange(0, attri.length-1)]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(attri.length-1, 1)]; [attri addAttribute:NSForegroundColorAttributeName value:_textColor range:NSMakeRange(0, attri.length)]; _tipLabel.attributedText = attri; &#125;else&#123; _timer.fireDate = [NSDate distantFuture]; &#125;&#125;-(void)setMinLineColor:(UIColor *)minLineColor&#123; _minLineColor = minLineColor; [_gradLayerR setColors:@[(id)_minLineColor.CGColor,(id)_midLineColor.CGColor]]; [_gradLayerL setColors:@[(id)_maxLineColor.CGColor,(id)_midLineColor.CGColor]];&#125;-(void)setMidLineColor:(UIColor *)midLineColor&#123; _midLineColor = midLineColor; [_gradLayerR setColors:@[(id)_minLineColor.CGColor,(id)_midLineColor.CGColor]]; [_gradLayerL setColors:@[(id)_maxLineColor.CGColor,(id)_midLineColor.CGColor]];&#125;-(void)setMaxLineColor:(UIColor *)maxLineColor&#123; _maxLineColor = maxLineColor; [_gradLayerR setColors:@[(id)_minLineColor.CGColor,(id)_midLineColor.CGColor]]; [_gradLayerL setColors:@[(id)_maxLineColor.CGColor,(id)_midLineColor.CGColor]];&#125;-(void)setTintColor:(UIColor *)tintColor&#123; _lineTintColor = tintColor; _contentLayer.strokeColor = tintColor.CGColor;&#125;-(void)setProgress:(CGFloat)progress&#123; _oldProgress = _progress; _progress=progress; _shapeLayer.strokeStart = 0; _shapeLayer.strokeEnd = progress&gt;1?1:progress; NSMutableAttributedString * attri ; if (progress==1) &#123; attri = [[NSMutableAttributedString alloc]initWithString:@&quot;100%&quot;]; &#125;else&#123; attri = [[NSMutableAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;%2d%%&quot;,(int)(progress*100)]]; &#125; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:22] range:NSMakeRange(0, attri.length-1)]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(attri.length-1, 1)]; [attri addAttribute:NSForegroundColorAttributeName value:_textColor range:NSMakeRange(0, attri.length)]; _tipLabel.attributedText = attri;&#125;-(void)setProgress:(CGFloat)progress animated:(BOOL)animated&#123; _oldProgress = _progress; _progress = progress; old = (int)(_oldProgress*100); new = (int)(_progress*100); CABasicAnimation * ani = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;]; ani.toValue = progress&gt;1?@1:@(progress); ani.duration = 0.3; ani.delegate=self; ani.fillMode=kCAFillModeForwards; ani.removedOnCompletion=NO; [_shapeLayer addAnimation:ani forKey:nil]; _timer.fireDate = [NSDate distantPast]; &#125;- (void)dealloc&#123; &#125;-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123; if (flag) &#123; [_shapeLayer removeAllAnimations]; _shapeLayer.strokeEnd = _progress&gt;1?1:_progress; &#125;&#125;-(void)setLineWidth:(CGFloat)lineWidth&#123; if (lineWidth&lt;0.5) &#123; lineWidth=0.5; &#125; if (lineWidth&gt;20) &#123; lineWidth = 20; &#125; _lineWidth = lineWidth; UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:_shapeLayer.position radius:_contentWidth/2-lineWidth/2 startAngle:-M_PI_2 endAngle:M_PI_2*3 clockwise:YES]; _shapeLayer.path = path.CGPath; _shapeLayer.fillColor = [UIColor clearColor].CGColor; _shapeLayer.lineWidth = lineWidth; _shapeLayer.strokeColor = [UIColor redColor].CGColor; [_gradLayer setMask:_shapeLayer]; UIBezierPath * pathT = [UIBezierPath bezierPathWithArcCenter:_contentLayer.position radius:_contentWidth/2-lineWidth/2 startAngle:-M_PI_2 endAngle:M_PI_2*3 clockwise:YES]; _contentLayer.path = pathT.CGPath; _contentLayer.lineWidth = lineWidth;&#125;-(void)setTextColor:(UIColor *)textColor&#123; _textColor = textColor; NSMutableAttributedString * attr = [[NSMutableAttributedString alloc]initWithAttributedString:_tipLabel.attributedText]; [attr addAttribute:NSForegroundColorAttributeName value:textColor range:NSMakeRange(0, attr.length)]; _tipLabel.attributedText = attr;&#125;-(void)creatTipLabel&#123; _tipLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, sqrt(2)/2*(_contentWidth-_lineWidth*2), sqrt(2)/2*(_contentWidth-_lineWidth*2))]; _tipLabel.center = CGPointMake(self.frame.size.width/2, self.frame.size.height/2); _tipLabel.backgroundColor = [UIColor clearColor]; _tipLabel.textAlignment = NSTextAlignmentCenter; NSMutableAttributedString * attri = [[NSMutableAttributedString alloc]initWithString:@&quot;100%&quot;]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:22] range:NSMakeRange(0, 3)]; [attri addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15] range:NSMakeRange(3, 1)]; [attri addAttribute:NSForegroundColorAttributeName value:[UIColor orangeColor] range:NSMakeRange(0, 4)]; _tipLabel.attributedText = attri; [self addSubview:_tipLabel];&#125;@end 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Swift中构造方法的解析","slug":"197Swift中构造方法的解析","date":"2016-04-14T16:00:00.000Z","updated":"2021-07-08T02:23:33.101Z","comments":true,"path":"2016/04/15/197Swift中构造方法的解析/","link":"","permalink":"http://huishao.cc/2016/04/15/197Swift中构造方法的解析/","excerpt":"","text":"Swift中构造方法的解析一、引言构造方法是一个类创建对象最先也是必须调用的方法，在Objective-C中，开发者更习惯称这类方法为初始化方法。在Objective-C中的初始化方法与普通函数相比除了要以init抬头外并无太严格的分界，而在Swift语言体系中，构造方法与普通的方法分界十分严格，从格式写法上就有不同，普通方法函数要以func声明，构造方法统一为init命名，不需要func关键字声明，不同的构造方法采用方法重载的方式创建。 二、构造方法的复写与重载在Objective-C中，不同的初始化方法就是不同的函数，这便不存在方法重载的概念。Swift中要创建自定义的构造方法，需要开发者对init构造方法进行重载操作。任何一个自定义的类，只要其有父类，除了可以继承下来父类已有的构造方法外，还可以复写父类的构造方法，使其适用于自身。和Objective-C类似，复写父类的构造方法时，要在其中调用父类的构造方法，重载可以理解为一种特殊的复写父类构造方法，因此在重载的构造方法中也要调用父类的构造方法。 创建一个继承于NSObject的类，复写构造方法，代码示例如下： 12345678910111213141516171819202122232425class ClassOne: NSObject &#123; //声明一个本类特有的常量 var tip:Int //复写父类的构造方法 需要用override关键字 override init() &#123; //构造方法中要对所有成员常量完成创建 tip = 1; //在创建完所有成员常量后 调用父类构造方法 super.init() &#125; //重载构造方法1 init(one:Int)&#123; tip=one super.init() &#125; //重载构造方法2 使用convenience关键字进行修饰 convenience init(two:String) &#123; //使用convenience关键字进行修饰的构造方法要调用本类的构造方法进行 self.init(one: two.characters.count) &#125; //重载构造方法3 使用required关键字进行修饰 使用required关键字进行修饰的构造方法子类必须继承或复写 required init(three:Float) &#123; tip=10 super.init() &#125; 上面示例代码中，不带参数的init()方法为复写父类的方法，因此需要使用关键字override来修饰。重载构造方法1带一个Int类型的 参数，父类中并没有这个构造方法，但是在其实现中，依然需要调用父类中的某个构造方法完成。构造方法2是一个带String类型参数的构造方法，其用convenience关键字为构造方法的一个修饰关键字，后面会介绍。构造方法3为一个带Float类型参数的构造方法，但其使用required关键字进行了修饰，使用required关键字进行修饰的构造方法子类必须继承或者复写。构造方法1，2，3都是对init()构造方法的一种重载，但却是3中类型全然不同的构造方法。 三、Designated构造方法与Convenience构造方法Swift中的构造方法分为Designated构造方法与Convenience构造方法两类，Designated构造方法也被称为指定构造方法，Convenience构造方法也被称为方便构造方法。Designated构造方法不加任何修饰关键字，Convenience构造方法需要使用Convenience关键字进行修饰。可以这样理解，Convenience类型的构造方法是为了方便使用从Designated构造方法中分支出来的构造方法，官方文档中有如下描述： 1.子类Designated构造方法中必须调用父类的Designated构造方法。 2.Convenience构造方法中必须调用当前类的构造方法。 3.Convenience构造方法归根结底要调用到Designated构造方法。 官方文档的一张图可以清晰的描述上述关系： 四、构造方法的继承关系关于子类继承父类的构造方法有这样几个特性： 1.如果子类没有复写任何父类的构造方法，则默认子类将继承所有父类的构造方法，包括Designated构造方法与Convenience构造方法。 2.如果子类复写了父类某一构造方法，则子类默认不在继承所有父类的构造方法，对于Designated类型的构造方法，子类复写了哪些，哪些才能够被使用，对于Convenienve类型的构造方法，子类复写的其调用的Designated构造方法后会被自动继承。 3.如果父类中的构造方法是required修饰的，则子类必须进行继承或复写。 曾经有朋友和我抱怨，Objective-C中的继承是一种十分不人性，它强制子类继承所有父类的方法与属性无论子类是否需要，分析上面的一些规则可以发现，Swift与Objective-C相比，在构造方法方面语法会更加严格，这样做在编程上更加安全。在Objective-C中，子类将被强制继承所有父类的初始化方法，这样开发者在使用时常常会出现疑惑，有时一个子类往往有特定的初始化方法，仅仅通过父类的初始化方法不能够正确的完成初始化，在编程时，往往需要特殊注释来提示开发者。Swift设定的这些构造方法原则可以将无关的父类构造方法剔除在外，在编程时更加严格安全，减少疑惑与不可控因素。 五、构造方法的实现原则无论Designated类型的构造方法还是Convenience类型的构造方法，只要其有父类，最终都要实现父类的Designated构造方法。Swift语言要求，在构造方法中要完成所有成员常量或者变量的构造或赋值(optional值除外)。在对成员常量或变量进行构造赋值时，要在调用父类的初始化方法之前，这里还有一点需要注意，父类的成员属性也会被子类继承，如果要在子类复写的父类方法中对继承来的父类成员属性进行重新构造或赋值，则必须在调用父类构造方法之后，例如创建ClassTwo类继承于ClassOne，复写方法如下： 123456789101112131415161718class ClassTwo: ClassOne &#123; //子类自己的属性 let tipTwo:Int override init() &#123; //调用父类构造方法前进行自己属性的构造 tipTwo = 1 //调用父类构造方法 super.init() //对从父类继承来的属性进行重构造 tip = 1000; &#125; required init(three: Float) &#123; fatalError(&quot;init(three:) has not been implemented&quot;) &#125; &#125; Swift语言这种强制化得构造规则，能够保证一个类在完成构造时，其内部的所有属性都构造完成。在使用Objective-C进行开发时，很多初学者都可能会遇到这样一种情况，完成了某个类的初始化，但向类的属性进行赋值时却没有成功，因为Objective-C中并没有这样的语法，在类初始化成功后，其属性是否初始化了完全取决于开发者，Swift优化了这一设计。 综上可以了解，Swift语言虽然更加严格，却将更多本来需要开发者注意的地方交由了编译器，实际上是减轻了开发者的负担。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"Mac修改主机host地址","slug":"195Mac修改主机host地址","date":"2016-04-12T16:00:00.000Z","updated":"2021-07-08T02:21:42.898Z","comments":true,"path":"2016/04/13/195Mac修改主机host地址/","link":"","permalink":"http://huishao.cc/2016/04/13/195Mac修改主机host地址/","excerpt":"","text":"Mac修改主机host地址在终端键入如下命令： 1vim /etc/hosts 如果提示没有操作权限，使用如下命令： 1sudo vim /etc/hosts 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"Mac系统Git生成ssh公钥","slug":"196Mac系统Git生成ssh公钥","date":"2016-04-12T16:00:00.000Z","updated":"2021-07-08T02:22:29.269Z","comments":true,"path":"2016/04/13/196Mac系统Git生成ssh公钥/","link":"","permalink":"http://huishao.cc/2016/04/13/196Mac系统Git生成ssh公钥/","excerpt":"","text":"Mac系统Git生成ssh公钥在使用Git仓库进行代码管理时，新的电脑上往往需要生成ssh公钥进行匹配，Mac系统生成Git公钥过程如下： 1.检查本机是否已有公钥 在终端中输入如下命令： 1$ cd ~/.ssh 2.如果电脑中有以前遗留的密钥，将其删除掉 使用如下命令： 123$ mkdir key_backup$ cp id_rsa* key_backup$ rm id_rsa* 3.生成新的公钥 终端中输入如下命令 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 之后终端会提示几次密码设置，如果设置了密码，在向Git仓库进行代码交互操作时需要键入密码，也可以全部回车带过，表示不需要密码。 4.向Git仓库中导入公钥 在.ssh文件夹下使用ls命令查看所有文件，可以看到生成了一个id_rsa.pub的文件，使用vi工具打开它，将其内容复制出来，在Git仓库中新建公钥，复制上去即可。例如github中导入密钥过程如下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法","slug":"194Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法","date":"2016-04-11T16:00:00.000Z","updated":"2021-07-08T02:20:53.556Z","comments":true,"path":"2016/04/12/194Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法/","link":"","permalink":"http://huishao.cc/2016/04/12/194Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法/","excerpt":"","text":"Xcode关于警告AutomaticPreferredMaxLayoutWidth的消除方法 在iOS开发中，如果使用到了storyboard与xib文件并且使用autolayout进行自动布局，有时会报出Automatic Preferred Max Layout Width before iOS8.0的警告。工程中如果兼容的iOS版本为iOS8.0一下，并且使用了多行UILabel控件，往往在autolayout自动布局时会出现上述警告，上述警告的主要原因是在iOS8.0后系统会自动计算多行UILabel控件的理想换行宽度，iOS8以下则不会，需要开发者手动设置一个确定的值。 解决方案如下，找到xib或storyboard中的多行UILabel控件，勾选Explicit属性，设置为一个固定的值，例如0。如下图所示： 之后上述警告即可消除，事实上，使用了autolayout后，这个属性并没有任何效果，仅仅为了消除警告，直接设置为0即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"iOS剪切板UIPasteboard开发应用解析","slug":"192iOS剪切板UIPasteboard开发应用解析","date":"2016-04-05T16:00:00.000Z","updated":"2021-07-07T08:23:33.287Z","comments":true,"path":"2016/04/06/192iOS剪切板UIPasteboard开发应用解析/","link":"","permalink":"http://huishao.cc/2016/04/06/192iOS剪切板UIPasteboard开发应用解析/","excerpt":"","text":"iOS剪切板UIPasteboard开发应用解析一、自带剪切板操作的原生UI控件 在iOS的UI系统中，有3个控件自带剪切板操作，分别是UITextField、UITextView与UIWebView。在这些控件的文字交互处进行长按手势可以在屏幕视图上唤出系统的剪切板控件，用户可以进行复制、粘贴，剪切等操作，其效果分别如下图所示。 UITextField的文字操作 UITextView的文字操作 UIWebView的文字操作 二、系统的剪切板管理类UIPasteboard 实际上，当用户通过上面的空间进行复制、剪切等操作时，被选中的内容会被存放到系统的剪切板中，并且这个剪切板并不只能存放字符串数据，其还可以进行图片数据与网址URL数据的存放。这个剪切板就是UIPasteboard类，开发者也可以直接通过它来操作数据进行应用内或应用间传值。 UIPasteboard类有3个初始化方法，如下： 123456//获取系统级别的剪切板+ (UIPasteboard *)generalPasteboard;//获取一个自定义的剪切板 name参数为此剪切板的名称 create参数用于设置当这个剪切板不存在时 是否进行创建+ (nullable UIPasteboard *)pasteboardWithName:(NSString *)pasteboardName create:(BOOL)create;//获取一个应用内可用的剪切板+ (UIPasteboard *)pasteboardWithUniqueName; 上面3个初始化方法，分别获取或创建3个级别不同的剪切板，系统级别的剪切板在整个设备中共享，即是应用程序被删掉，其向系统级的剪切板中写入的数据依然在。自定义的剪切板通过一个特定的名称字符串进行创建，它在应用程序内或者同一开发者开发的其他应用程序中可以进行数据共享。第3个方法创建的剪切板等价为使用第2个方法创建的剪切板，只是其名称字符串为nil，它通常用于当前应用内部。 注意：使用第3个方法创建的剪切板默认是不进行数据持久化的，及当应用程序退出后，剪切板中内容将别抹去。若要实现持久化，需要设置persistent属性为YES。 UIPasteboard中常用方法及属性如下： 12345678//剪切板的名称@property(readonly,nonatomic) NSString *name;//根据名称删除一个剪切板+ (void)removePasteboardWithName:(NSString *)pasteboardName;//是否进行持久化@property(getter=isPersistent,nonatomic) BOOL persistent;//此剪切板的改变次数 系统级别的剪切板只有当设备重新启动时 这个值才会清零@property(readonly,nonatomic) NSInteger changeCount; 下面这些方法用于设置与获取剪切板中的数据： 最新一组数据对象的存取： 123456789101112//获取剪切板中最新数据的类型- (NSArray&lt;NSString *&gt; *)pasteboardTypes;//获取剪切板中最新数据对象是否包含某一类型的数据- (BOOL)containsPasteboardTypes:(NSArray&lt;NSString *&gt; *)pasteboardTypes;//将剪切板中最新数据对象某一类型的数据取出- (nullable NSData *)dataForPasteboardType:(NSString *)pasteboardType;//将剪切板中最新数据对象某一类型的值取出- (nullable id)valueForPasteboardType:(NSString *)pasteboardType;//为剪切板中最新数据对应的某一数据类型设置值- (void)setValue:(id)value forPasteboardType:(NSString *)pasteboardType;//为剪切板中最新数据对应的某一数据类型设置数据- (void)setData:(NSData *)data forPasteboardType:(NSString *)pasteboardType; 多组数据对象的存取： 12345678910111213141516//数据组数@property(readonly,nonatomic) NSInteger numberOfItems;//获取一组数据对象包含的数据类型- (nullable NSArray *)pasteboardTypesForItemSet:(nullable NSIndexSet*)itemSet;//获取一组数据对象中是否包含某些数据类型- (BOOL)containsPasteboardTypes:(NSArray&lt;NSString *&gt; *)pasteboardTypes inItemSet:(nullable NSIndexSet *)itemSet;//根据数据类型获取一组数据对象- (nullable NSIndexSet *)itemSetWithPasteboardTypes:(NSArray *)pasteboardTypes;//根据数据类型获取一组数据的值- (nullable NSArray *)valuesForPasteboardType:(NSString *)pasteboardType inItemSet:(nullable NSIndexSet *)itemSet;//根据数据类型获取一组数据的NSData数据- (nullable NSArray *)dataForPasteboardType:(NSString *)pasteboardType inItemSet:(nullable NSIndexSet *)itemSet;//所有数据对象@property(nonatomic,copy) NSArray *items;//添加一组数据对象- (void)addItems:(NSArray&lt;NSDictionary&lt;NSString *, id&gt; *&gt; *)items; 上面方法中很多需要传入数据类型参数，这些参数是系统定义好的一些字符窜，如下： 12345678//所有字符串类型数据的类型定义字符串数组UIKIT_EXTERN NSArray&lt;NSString *&gt; *UIPasteboardTypeListString;//所有URL类型数据的类型定义字符串数组UIKIT_EXTERN NSArray&lt;NSString *&gt; *UIPasteboardTypeListURL;//所有图片数据的类型定义字符串数据UIKIT_EXTERN NSArray&lt;NSString *&gt; *UIPasteboardTypeListImage;//所有颜色数据的类型定义字符串数组UIKIT_EXTERN NSArray&lt;NSString *&gt; *UIPasteboardTypeListColor; 相比于上面两组方法，下面这些方法更加面向对象，在开发中使用更加方便与快捷： 12345678910111213141516//获取或设置剪切板中的字符串数据@property(nullable,nonatomic,copy) NSString *string;//获取或设置剪切板中的字符串数组@property(nullable,nonatomic,copy) NSArray&lt;NSString *&gt; *strings;//获取或设置剪切板中的URL数据@property(nullable,nonatomic,copy) NSURL *URL;//获取或设置剪切板中的URL数组@property(nullable,nonatomic,copy) NSArray&lt;NSURL *&gt; *URLs;//获取或s何止剪切板中的图片数据@property(nullable,nonatomic,copy) UIImage *image;//获取或设置剪切板中的图片数组@property(nullable,nonatomic,copy) NSArray&lt;UIImage *&gt; *images;//获取或设置剪切板中的颜色数据@property(nullable,nonatomic,copy) UIColor *color;//获取或设置剪切板中的颜色数组@property(nullable,nonatomic,copy) NSArray&lt;UIColor *&gt; *colors; 对剪切板的某些操作会触发如下通知： 12345678//剪切板内容发生变化时发送的通知UIKIT_EXTERN NSString *const UIPasteboardChangedNotification;//剪切板数据类型键值增加时发送的通知UIKIT_EXTERN NSString *const UIPasteboardChangedTypesAddedKey;//剪切板数据类型键值移除时发送的通知UIKIT_EXTERN NSString *const UIPasteboardChangedTypesRemovedKey;//剪切板被删除时发送的通知UIKIT_EXTERN NSString *const UIPasteboardRemovedNotification; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS系统菜单控制器UIMenuController使用简介","slug":"193iOS系统菜单控制器UIMenuController使用简介","date":"2016-04-05T16:00:00.000Z","updated":"2021-07-07T08:24:46.452Z","comments":true,"path":"2016/04/06/193iOS系统菜单控制器UIMenuController使用简介/","link":"","permalink":"http://huishao.cc/2016/04/06/193iOS系统菜单控制器UIMenuController使用简介/","excerpt":"","text":"iOS系统菜单控制器UIMenuController使用简介一、引言 在许多iOS应用中，当用户进行某文字或图片区域的长按操作时，都会弹出一个系统菜单控件，用户可以通过操作菜单控件上的按钮进行数据的复制、剪切、粘贴等操作。系统原生的某些控件已经支持了对UIMenuController的唤出操作，然而并不是所有控件都支持，开发者可以通过自定义UIMenuController来更加灵活的使用菜单控件，在前面博客中有介绍iOS剪切板相关知识，地址如下： iOS剪切板UIPasteboard使用简介：http://my.oschina.net/u/2340880/blog/653228。 二、UIMenuController的使用 UIMenuController的展现需要基于一个View视图，其交互则需要基于其所在View视图的Responder。举例来说，如果一个UIMenuController展现在当前ViewController的View上，则此UIMenuController的交互逻辑交由当前的ViewController进行管理。 在界面展示出UIMenuController需要3个条件： 1.当前的Responder处于第一响应。 2.UIMenuController对象调用menuVisible方法。 3.当前的Responder实现了如下两个方法： 12345678//是否可以成为第一相应-(BOOL)canBecomeFirstResponder&#123; return YES;&#125;//是否可以接收某些菜单的某些交互操作-(BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; return YES;&#125; 实现了上面的两个方法，使用如下的代码可以唤出UIMenuController控件： 12345 [self becomeFirstResponder]; //设置菜单显示的位置 frame设置其文职 inView设置其所在的视图 [[UIMenuController sharedMenuController] setTargetRect:frame inView:self.view]; //将菜单控件设置为可见 [UIMenuController sharedMenuController].menuVisible = YES; 在执行了上面的代码后，系统第一次调用canperformAction:withSender:方法会进行是否显示菜单栏的检测，如果返回为NO，则不能显示菜单栏，如果返回为YES，之后系统会多次调用canPerformAction:withSender:方法，用于检测当前Responder对象是否实现了菜单栏上某个选项的触发方法，如果实现了，菜单栏上面的相应按钮会显示，否则不会显示。开发者可以在这个方法中通过判断action来确定菜单控件中显示的按钮种类。系统默认为开发者提供了一系列的菜单按钮，例如要显示剪切和赋值操作的菜单按钮，示例代码如下： 123456-(BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if (action == @selector(cut:)||action == @selector(copy:)) &#123; return YES; &#125; return NO;&#125; 效果如下图所示： 系统默认支持提供的按钮触发方法列举如下： 12345678910111213141516//剪切按钮的方法- (void)cut:(nullable id)sender NS_AVAILABLE_IOS(3_0);//复制按钮的方法- (void)copy:(nullable id)sender NS_AVAILABLE_IOS(3_0);//粘贴按钮的方法- (void)paste:(nullable id)sender NS_AVAILABLE_IOS(3_0);//选择按钮的方法- (void)select:(nullable id)sender NS_AVAILABLE_IOS(3_0);//全选按钮的方法- (void)selectAll:(nullable id)sender NS_AVAILABLE_IOS(3_0);//删除按钮的方法- (void)delete:(nullable id)sender NS_AVAILABLE_IOS(3_2);//改变书写模式为从左向右按钮触发的方法- (void)makeTextWritingDirectionLeftToRight:(nullable id)sender NS_AVAILABLE_IOS(5_0);//改变书写模式为从右向左按钮触发的方法- (void)makeTextWritingDirectionRightToLeft:(nullable id)sender NS_AVAILABLE_IOS(5_0); 上面所列举的方法声明在UIResponder头文件中，实际上，除了上面的方法，关于UIMenuController上面的按钮，系统中还有许多私有方法，列举如下： 12345678910111213141516171819202122232425262728293031323334//替换按钮- (void)_promptForReplace:(id)arg1&#123; NSLog(@&quot;promptForReplace&quot;);&#125;//简体繁体转换按钮-(void)_transliterateChinese:(id)sender&#123; NSLog(@&quot;transliterateChinese&quot;);&#125;//文字风格按钮-(void)_showTextStyleOptions:(id)sender&#123; NSLog(@&quot;showTextStyleOptions&quot;);&#125;//定义按钮-(void)_define:(id)sender&#123; NSLog(@&quot;define&quot;);&#125;-(void)_addShortcut:(id)sender&#123; NSLog(@&quot;addShortcut&quot;);&#125;-(void)_accessibilitySpeak:(id)sender&#123; NSLog(@&quot;accessibilitySpeak&quot;);&#125;//语言选择按钮-(void)_accessibilitySpeakLanguageSelection:(id)sender&#123; NSLog(@&quot;accessibilitySpeakLanguageSelection&quot;);&#125;//暂停发音按钮-(void)_accessibilityPauseSpeaking:(id)sender&#123; NSLog(@&quot;accessibilityPauseSpeaking&quot;);&#125;//分享按钮-(void)_share:(id)sender&#123; NSLog(@&quot;share&quot;);&#125; 在实际开发中，开发这完全不需要使用这些私有的方法，UIMenuItem类提供给开发者进行自定义菜单按钮与触发方法，示例如下： 12345[self becomeFirstResponder]; UIMenuItem * item = [[UIMenuItem alloc]initWithTitle:@&quot;自定义&quot; action:@selector(newFunc)]; [[UIMenuController sharedMenuController] setTargetRect:[sender frame] inView:self.view]; [UIMenuController sharedMenuController].menuItems = @[item]; [UIMenuController sharedMenuController].menuVisible = YES; 123456789101112-(BOOL)canBecomeFirstResponder&#123; return YES;&#125;-(BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if (action == @selector(newFunc)) &#123; return YES; &#125; return NO;&#125;-(void)newFunc&#123; NSLog(@&quot;自定义方法&quot;);&#125; 效果如下图所示： UIMenuController还有如下的属性用来设置其显示的位置： 1234567891011121314151617//显示的位置@property(nonatomic) UIMenuControllerArrowDirection arrowDirection;//枚举如下：/*typedef NS_ENUM(NSInteger, UIMenuControllerArrowDirection) &#123; //默认 基于当前屏幕状态 UIMenuControllerArrowDefault, // up or down based on screen location //箭头在上的显示模式 UIMenuControllerArrowUp NS_ENUM_AVAILABLE_IOS(3_2), //箭头在下的显示模式 UIMenuControllerArrowDown NS_ENUM_AVAILABLE_IOS(3_2), //箭头在左的显示模式 UIMenuControllerArrowLeft NS_ENUM_AVAILABLE_IOS(3_2), //箭头在右的显示模式 UIMenuControllerArrowRight NS_ENUM_AVAILABLE_IOS(3_2),&#125;;*/ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中动态更新补丁策略JSPatch运用基础二","slug":"191iOS中动态更新补丁策略JSPatch运用基础二","date":"2016-03-29T16:00:00.000Z","updated":"2021-07-07T08:20:16.520Z","comments":true,"path":"2016/03/30/191iOS中动态更新补丁策略JSPatch运用基础二/","link":"","permalink":"http://huishao.cc/2016/03/30/191iOS中动态更新补丁策略JSPatch运用基础二/","excerpt":"","text":"iOS中动态更新补丁策略JSPatch运用基础二一、引言上篇博客中介绍了iOS开发中JSPatch引擎进行动态热修复的一些基础功能，其中包括向Objective-C类中添加类方法与成员方法、添加临时成员变量，使用JavaScript调用原生的Objective-C属性和方法等。本篇博客将基于上一篇继续介绍Objective-C中的一些特殊数据类型在JavaScript文件中的使用方法，博客中大部分内容扩展自JSPatch开源git的wiki：[https://github.com/bang590/JSPatch](https://github.com/bang590/JSPatch)。 iOS中动态更新补丁策略JSPatch运用基础一：http://my.oschina.net/u/2340880/blog/646688。 二、JavaScript与Objective-C交互的几种常用类型1.结构体在Objective-C代码中，我们经常会使用到结构体，JSPatch中原生支持的结构体有如下几种：CGPoint，CGSize，CGRect，NSRange。并且这几种结构体在进行界面操作时也会经常使用到。 对于CGRect类型，JavaScript使用如下代码创建： 12 var view = require(&apos;UIView&apos;).alloc().init() view.setFrame(&#123;x:100,y:100,width:100,height:100&#125;) 对于CGPoint类型，JavaScript使用如下代码创建： 1 view.setCenter(&#123;x:200,y:200&#125;) 对于CGSize类型，JavaScript使用如下代码创建： 12 var size = &#123;width:200,height:200&#125; view.setFrame(&#123;x:100,y:100,width:size.width,height:size.height&#125;) 对于NSRange类型，JavaScript使用如下代码创建： 1 var range = &#123;location: 0, length: 1&#125; 2.选择器Selector对于Objective-C中的方法选择器Selector，在JavaScript中使用字符串的形式创建，例如： 1self.performSelector_withObject(&quot;func:&quot;, 1) 3.关于空对象在JavaScript中，null与undefined都对应于Objective-C中的nil，Objective-C中的NSNull空对象，在JavaScript中使用nsnull来代替。 4.在Objective-C与JavaScript中进行block的交互 在JavaScript与Objective-C进行block交互有两种方式，一种是在JavaScript文件中调用Objective-C中的block，一种是将JavaScript文件中的函数块作为block参数传递给Objective-C。 在JavaScript文件中使用Objective-C中的block十分简单，因为JavaScript中没有block的概念，Objective-C会被自动转换为函数，示例如下： Objective-C： 123456789typedef void(^block)(NSString * str);@interface ViewController ()@end@implementation ViewController-(block)getBlock&#123; block block = ^(NSString * str)&#123;NSLog(@&quot;%@&quot;,str);&#125;; return block;&#125;@end JavaScript： 123456defineClass(&quot;ViewController&quot;, &#123; viewDidAppear: function(animated) &#123; var func = self.getBlock() func(&quot;123&quot;) &#125; &#125;) 在JavaScript文件中将func作为参数block传递给Objective-C就复杂一些，需要使用block()方法进行包装，例如： Objective-C： 12345678@interface ViewController ()@end@implementation ViewController-(void)run:(void(^)(NSString * str))block&#123; block(@&quot;123&quot;);&#125;@end JavaScript： 123456defineClass(&quot;ViewController&quot;, &#123; viewDidAppear: function(animated) &#123; //run 方法中需要传入一个block self.run(block(&quot;NSString*&quot;,function(str)&#123;console.log(str)&#125;)) &#125; &#125;) 在使用block()方法对JavaScript中的Func进行包装时，block(param1,param2)有两个参数，第1个参数设置func中的参数类型，如果有多个参数，使用逗号分割；第2个参数为func函数体。 注意：在block()包装的func中不可以使用self指针，如果需要使用self，需要在block外进行临时变量的转换，示例如下： 1234567891011defineClass(&quot;ViewController&quot;, &#123; viewDidAppear: function(animated) &#123; //run 方法中需要传入一个block var slf = self self.run(block(&quot;NSString*&quot;, function(str)&#123; console.log(str) slf.log(str) &#125;)) &#125; &#125;) 在JavaScript中分别使用\\_\\_weak()与\\_\\_strong来声明弱引用与强引用对象，例如： 12 var slf = __weak(self) var stgSef = __strong(self) 5.关于GCD与枚举在JSPatch中，可以使用如下JavaScript代码来调用GCD方法： 123456789101112//阻塞当前线程一定时间dispatch_after(1.0, function()&#123; &#125;)//为主线程添加异步任务dispatch_async_main(function()&#123; &#125;)//为主线程添加同步任务dispatch_sync_main(function()&#123; &#125;)//向全局队列中添加任务dispatch_async_global_queue(function()&#123; &#125;) JSPatch中不可以直接使用Objective-C中定义的枚举，但是可以用其枚举的真实值进行传递。例如： 12//UIControlEventTouchUpInside的值是1&lt;&lt;6btn.addTarget_action_forControlEvents(self, &quot;handleBtn&quot;, 1&lt;&lt;6); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}],"tags":[],"keywords":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}]},{"title":"iOS中动态更新补丁策略JSPatch运用基础一","slug":"190iOS中动态更新补丁策略JSPatch运用基础一","date":"2016-03-23T16:00:00.000Z","updated":"2021-07-06T07:15:26.932Z","comments":true,"path":"2016/03/24/190iOS中动态更新补丁策略JSPatch运用基础一/","link":"","permalink":"http://huishao.cc/2016/03/24/190iOS中动态更新补丁策略JSPatch运用基础一/","excerpt":"","text":"iOS中动态更新补丁策略JSPatch运用基础JSPatch是GitHub上一个开源的框架，其可以通过Objective-C的run-time机制动态的使用JavaScript调用与替换项目中的Objective-C属性与方法。其框架小巧，代码简洁，并且通过系统的JavaScriptCore框架与Objective-C进行交互，这使其在安全性和审核风险上都有很强的优势。Git源码地址：[https://github.com/bang590/JSPatch](https://github.com/bang590/JSPatch)。 一、从一个官方的小demo看起通过cocoapods将JSPath集成进一个Xcode工程中，在AppDelegate类的中编写如下代码： 123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; //开始初始化引擎 [JPEngine startEngine]; //读取js文件 NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;demo&quot; ofType:@&quot;js&quot;]; NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; //运行js文件 [JPEngine evaluateScript:script]; self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds]; self.window.rootViewController = [[ViewController alloc]init]; [self.window addSubview:[self genView]]; [self.window makeKeyAndVisible]; return YES;&#125;- (UIView *)genView&#123; UIView * view= [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 320)]; view.backgroundColor = [UIColor redColor]; return view;&#125; 在工程中添加一个js文件，编写如下： 123456789101112131415 require(&apos;UIView, UIColor, UILabel&apos;) //要替换函数的类 defineClass(&apos;AppDelegate&apos;, &#123; //替换函数 //要替换函数的名称 genView: function() &#123; var view = self.ORIGgenView(); view.setBackgroundColor(UIColor.greenColor()) var label = UILabel.alloc().initWithFrame(view.frame()); label.setText(&quot;JSPatch&quot;); label.setTextAlignment(1); view.addSubview(label); return view; &#125; &#125;); 运行工程，可以看到genView方法被替换成了js文件中的方法，原本红色的视图被修改成了绿色。 二、使用JavaScript代码向Objective-C中修改或添加方法JSPatch引擎中支持3中方式进行JavaScript代码的调用，分别是使用JavaScript字符串进行代码运行，读取本地的JavaScript文件进行代码运行和获取网络的JavaScript文件进行代码运行。例如，如果想要通过JavaScript代码在项目中弹出一个警告框，在Objective-C代码中插入如下代码： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // ‘\\’符用于进行换行 [JPEngine evaluateScript:@&quot;\\ var alertView = require(&apos;UIAlertView&apos;).alloc().init();\\ alertView.setTitle(&apos;Alert&apos;);\\ alertView.setMessage(&apos;AlertView from js&apos;); \\ alertView.addButtonWithTitle(&apos;OK&apos;);\\ alertView.show(); \\ &quot;];&#125; 开发者也可以动态在Objective-C类文件中添加方法，例如在ViewController类中编写如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; [JPEngine startEngine]; NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;demo&quot; ofType:@&quot;js&quot;]; NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; [self performSelectorOnMainThread:@selector(creatView) withObject:nil waitUntilDone:nil];&#125; JavaScript文件代码如下： 12345678910111213 require(&apos;UIView, UIColor, UILabel&apos;) defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method creatView: function() &#123; var view = UIView.alloc().initWithFrame(&#123;x:20, y:20, width:100, height:100&#125;); view.setBackgroundColor(UIColor.greenColor()); var label = UILabel.alloc().initWithFrame(&#123;x:0, y:0, width:100, height:100&#125;); label.setText(&quot;JSPatch&quot;); label.setTextAlignment(1); view.addSubview(label); self.view().addSubview(view) &#125; &#125;); 除了上面的代码，在ViewController.m文件中没有编写任何其他的方法，运行工程，可以看到程序并没有崩溃，ViewController执行了creatView方法。 通过上面的示例，我们发现使用JSPatch可以做一些十分有趣的事。对于iOS应用来说，通过官方渠道AppStore进行应用程序的发布要通过人工审核，有时这个审核周期会非常长，如果在开发者在编写代码时留下了一些小漏洞，应用一旦上线，若要修改掉这个bug就十分艰难了。有了JSPatch，我们可以想象，如果可以定位到线上应用有问题的方法，使用JS文件来修改掉这个方法，这将是多么cool的一件事，事实上，JSPatch的主要用途也是可以实现线上应用极小问题的hotfix。 三、JavaScript与Objective-C交互的基础方法要使用JSPatch来进行Objective-C风格的方法编写，需要遵守一些JavaScript与Objective-C交互的规则。 1.在JavaScript文件中使用Objective-C类 在编写JavaScript代码时如果需要用到Objective-C的类，必须先对这个类进行require引用，例如，如果需要使用UIView这个类，需要在使用前进行如下引用： 1require(&apos;UIView&apos;) 同样也可以一次对多个Objective-C类进行引用： 1require(&apos;UIView, UIColor, UILabel&apos;) 还有一种更加简便的写法，直接在使用的时候对其进行引用： 1require(&apos;UIView&apos;).alloc().init() 2.在JavaScript文件中进行Objective-C方法的调用在进行Objective-C方法的调用时，分为两种，一种是调用类方法，一种是调用类的对象方法。 调用类方法：通过类名打点的方式来调用类方法，格式类似如下，括号内为参数传递： 1UIColor.redColor() 调用实例方法：通过对象打点的方式调用类的实例方法，格式如下，括号内为参数传递： 1view.addSubview(label) 对于Objective-C中的多参数方法，转化为JavaScript将参数分割的位置以_进行分割，参数全部放入后面的括号中，以逗号分割，示例如下： 1view.setBackgroundColor(UIColor.colorWithRed_green_blue_alpha(0,0.5,0.5,1)) 对于Objective-C类的属性变量，在JavaScript中只能使用getter与setter方法来访问，示例如下： 1label.setText(&quot;JSPatch&quot;) 提示：如果原Objective-C的方法中已经包含了_符号，则在JavaScript中使用__代替。 3.在JavaScript中操作与修改Objective-C类JSPatch的最大应用是在应用运行时动态的操作和修改类。 重写或者添加类的方法： 在JavaScript中使用defineClass来定义和修改类中的方法，其编写格式如下所示： 123456/*classDeclaration:要添加或者重写方法的类名 字符串 如果此类不存在 则会创建新的类instanceMethods:要添加或者重写的实例方法 &#123;&#125;classMethods:要添加或者重写的类方法 &#123;&#125;*/defineClass(classDeclaration, instanceMethods, classMethods) 示例如下: 123456789101112131415defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method newFunc: function() &#123; //编写实例方法 self.view().setBackgroundColor(UIColor.redColor()) &#125; &#125;,&#123; myLoad:function()&#123; //编写类方法 &#125; &#125; ) 如果在重写了类中的方法后要调用原方法，需要使用ORIG前缀，示例如下： 123456789defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.ORIGviewDidLoad() &#125; &#125; ) 对于Objective-C中super关键字调用的方法，在JavaScript中可以使用self.super()来调用，例如： 123456789defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.super().viewDidLoad() &#125; &#125; ) 同样JSPatch也可以为类添加临时属性，用于在方法间参数传递，使用set_Prop_forKey()来添加属性，使用getProp()来获取属性，注意，JSPatch添加的属性不能使用Objective-C的setter与getter方法访问，如下： 1234567891011121314defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.super().viewDidLoad() self.setProp_forKey(&quot;JSPatch&quot;, &quot;data&quot;) &#125;, touchesBegan_withEvent(id,touch)&#123; self.getProp(&quot;data&quot;) self.view().setBackgroundColor(UIColor.redColor()) &#125; &#125; ) 关于为类添加协议的遵守，和Objective-C中遵守协议的方式一致，如下： 1234567891011121314151617defineClass(&quot;ViewController2: UIViewController &lt;UIAlertViewDelegate&gt;&quot;, &#123; viewDidAppear: function(animated) &#123; var alertView = require(&apos;UIAlertView&apos;) .alloc() .initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles( &quot;Alert&quot;, &quot;content&quot;, self, &quot;OK&quot;, null ) alertView.show() &#125;, alertView_clickedButtonAtIndex:function(alertView, buttonIndex) &#123; console.log(&apos;clicked index &apos; + buttonIndex) &#125; &#125;) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}],"tags":[],"keywords":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}]},{"title":"设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框","slug":"189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框","date":"2016-03-22T16:00:00.000Z","updated":"2021-07-06T07:14:19.973Z","comments":true,"path":"2016/03/23/189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框/","link":"","permalink":"http://huishao.cc/2016/03/23/189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框/","excerpt":"","text":"设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框文本输入框是多数与社交相关的app中不可或缺的一个控件，这些文本输入框应该具备如下的功能： 1.在键盘为弹起时，输入框悬浮在界面底部。 2.当键盘弹起时，输入框位置上移至键盘上方，并且动画应与键盘同步。 3.当输入的文字超出一行时，输入框应想用的进行高度扩展。 4.当输入框的高度达到某一极限值时，输入框高度不应继续扩展，文字区域应该支持滑动。 使用autolayout布局技术加上对键盘的相关监听，可以十分方便的实现上述效果。首先在xib文件中进行相关约束的添加，如下图： 将需要的属性与约束对象关联到文件中： 12345678910//整体文本控件的高度 @IBOutlet weak var textViewHeight: NSLayoutConstraint! //文本控件中的文字输入控件UITestView的高度 @IBOutlet weak var textFieldHeight: NSLayoutConstraint! //文本控件中文字输入控件 @IBOutlet weak var ourTextField: UITextView! //文本控件与父视图底部的约束距离 @IBOutlet weak var textViewBottom: NSLayoutConstraint! //文本控件 @IBOutlet weak var ourTextView: UIView! 在初始化方法中进行通知的注册和代理的设置： 123 NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector(&quot;keyboardWillShow:&quot;), name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector(&quot;keyboardWillHidden:&quot;), name: UIKeyboardWillHideNotification, object: nil) ourTextField.delegate=self 实现通知的监听方法如下： 123456789101112131415161718192021222324252627282930 //键盘将要展示时触发的方法 func keyboardWillShow(noti:NSNotification)&#123; //获取通知信息 let info:Dictionary = noti.userInfo! //获取信息中的键盘尺寸和位置信息 let value:NSValue = info[UIKeyboardFrameBeginUserInfoKey] as! NSValue //获取键盘动画的时间信息 let value2:NSValue = info[UIKeyboardAnimationDurationUserInfoKey] as! NSValue let keyboardSize = value.CGRectValue() let height = keyboardSize.height var time:NSTimeInterval=0 value2.getValue(&amp;time) //重设约束 textViewBottom.constant = height //动画展示 UIView.animateWithDuration(time) &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125; &#125; //键盘将要隐藏时触发的方法 func keyboardWillHidden(noti:NSNotification)&#123; let info:Dictionary = noti.userInfo! let value2:NSValue = info[UIKeyboardAnimationDurationUserInfoKey] as! NSValue var time:NSTimeInterval=0 value2.getValue(&amp;time) textViewBottom.constant = 0 UIView.animateWithDuration(time) &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125; &#125; 监听的键盘状态发送的通知中，会传递进来许多键盘信息，可取的键值如下： 12345678910@available(iOS 3.2, *)public let UIKeyboardFrameBeginUserInfoKey: String //键盘的初始位置尺寸 为CGRect类型的NSValue值@available(iOS 3.2, *)public let UIKeyboardFrameEndUserInfoKey: String // 键盘的末位位置尺寸 为CGRect类型的NSValue值@available(iOS 3.0, *)public let UIKeyboardAnimationDurationUserInfoKey: String // 键盘动画时间 double类型的NSValue@available(iOS 3.0, *)public let UIKeyboardAnimationCurveUserInfoKey: String // 键盘动画效果 (UIViewAnimationCurve)枚举类型的NSNumber值@available(iOS 9.0, *)public let UIKeyboardIsLocalUserInfoKey: String //与多任务相关 判断键盘是否属于当前应用 iOS9后可用 可以监听的与键盘相关信息的通知有如下几种： 12345678public let UIKeyboardWillShowNotification: String//键盘将要出现public let UIKeyboardDidShowNotification: String//键盘已经出现public let UIKeyboardWillHideNotification: String//键盘将要隐藏public let UIKeyboardDidHideNotification: String//键盘已经隐藏@available(iOS 5.0, *)public let UIKeyboardWillChangeFrameNotification: String//键盘frame将要改变@available(iOS 5.0, *)public let UIKeyboardDidChangeFrameNotification: String//键盘frame已经改变 还需要实现当输入框文字长度改变时的回调方法如下： 123456789101112131415161718192021222324func textViewDidChange(textView: UITextView) &#123; let height = textView.contentSize.height if height &lt;= 37 &#123; textFieldHeight.constant = 37 textViewHeight.constant = 53 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) return //临界值 &#125;else if height&lt;100 &#123; textFieldHeight.constant = height textViewHeight.constant = height+16 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) &#125;else&#123; textFieldHeight.constant = 100 textViewHeight.constant = 116 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) &#125; &#125; 上面代码是实现可自适应高度和位置的文本输入框控件的核心代码，效果图下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法","slug":"188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法","date":"2016-03-20T16:00:00.000Z","updated":"2021-07-06T07:13:07.367Z","comments":true,"path":"2016/03/21/188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法/","link":"","permalink":"http://huishao.cc/2016/03/21/188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法/","excerpt":"","text":"iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法一、引言上一篇博客我们介绍了在开发一款蓝牙对战五子棋游戏中核心的蓝牙通讯框架的设计与编写，本篇博客将来完成独立的棋盘逻辑与胜负判定算法。上篇博客地址如下： 五子棋游戏中和核心通讯类设计：http://my.oschina.net/u/2340880/blog/644432。 二、棋盘中独立棋格的设计我们知道，五子棋游戏的棋盘是由横纵交叉的两组平行线组成，每一个横纵线的交点即是棋盘上可以落子的点。因此，在设计棋盘前，我们可以先来设计创建棋盘上每一个独立的落子点，这里称之为棋格，在iOS中，可以使用UIButton类来进行棋格的设计。 创建一个类，命名为TipButton作为棋格类，实现其头文件如下： TipButton.h 1234567891011#import &lt;UIKit/UIKit.h&gt;@interface TipButton : UIButton//标记此瓦片是否已经落子 0 空 1 己方落子 2 敌方落子@property(nonatomic,assign)int hasChess;//落子 BOOL类型的参数 决定是己方还是敌方-(void)dropChess:(BOOL)isMine;//设置白子或者黑子@property(nonatomic,assign)BOOL isWhite;//瓦片编号@property(nonatomic,assign)int index;@end 实现.m文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &quot;TipButton.h&quot;@implementation TipButton- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self creatView]; &#125; return self;&#125;-(void)creatView&#123; //创建横竖两条线 UIView * line1 = [[UIView alloc]initWithFrame:CGRectMake(self.frame.size.width/2-0.25, 0, 0.5, self.frame.size.height)]; line1.backgroundColor = [UIColor grayColor]; [self addSubview:line1]; UIView * line2 = [[UIView alloc]initWithFrame:CGRectMake(0, self.frame.size.height/2-0.25, self.frame.size.width, 0.5)]; line2.backgroundColor = [UIColor grayColor]; [self addSubview:line2];&#125;-(void)dropChess:(BOOL)isMine&#123; UIView * view = [[UIView alloc]initWithFrame:CGRectMake(self.frame.size.width/2-5, self.frame.size.height/2-5, 10, 10)]; view.layer.masksToBounds = YES; view.layer.cornerRadius = 5; UIColor * myColor; UIColor * otherColor; if (_isWhite) &#123; myColor = [UIColor whiteColor]; otherColor = [UIColor blackColor]; &#125;else&#123; myColor = [UIColor blackColor]; otherColor = [UIColor whiteColor]; &#125; if (isMine) &#123; view.backgroundColor = myColor; self.hasChess = 1; &#125;else&#123; view.backgroundColor = otherColor; self.hasChess = 2; &#125; [self addSubview:view]; &#125;@end 三、游戏棋盘的设计创建一个继承于UIView的类，作为五子棋游戏的棋盘，命名为GameView实现如下： GameView.h 1234567891011121314#import &lt;UIKit/UIKit.h&gt;#import &quot;TipButton.h&quot;#import &quot;BlueToothTool.h&quot;//用于处理用户下子后的逻辑@protocol GameViewDelegate&lt;NSObject&gt;-(void)gameViewClick:(NSString *)index;@end@interface GameView : UIView&lt;UIAlertViewDelegate&gt;//存放所有棋格@property(nonatomic,strong)NSMutableArray&lt;TipButton *&gt; * tipArray;@property(nonatomic,weak)id&lt;GameViewDelegate&gt;delegate;//进行下子-(void)setTipIndex:(int)index;@end GameView.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391#import &quot;GameView.h&quot;@implementation GameView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _tipArray = [[NSMutableArray alloc]init]; [self creatView]; &#125; return self;&#125;//创建表格视图 横16 竖20-(void)creatView&#123; self.layer.borderColor = [UIColor colorWithRed:222/255.0 green:222/255.0 blue:222/255.0 alpha:1].CGColor; self.layer.borderWidth = 0.5; CGFloat width = self.frame.size.width/12; CGFloat height = self.frame.size.height/20; //排列布局 for (int i=0; i&lt;240; i++) &#123; TipButton * btn = [[TipButton alloc]initWithFrame:CGRectMake(width*(i%12), height*(i/12), width, height)]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.isWhite = NO; btn.index=i; [self addSubview:btn]; [_tipArray addObject:btn]; &#125;&#125;-(void)click:(TipButton *)btn&#123; if (btn.hasChess==0) &#123; //下子 [btn dropChess:YES]; //进行胜负判定 [self cheak]; [self.delegate gameViewClick:[NSString stringWithFormat:@&quot;%d&quot;,btn.index]]; &#125;&#125;//进行胜负判定-(void)cheak&#123; //判定己方是否胜利 if ([self cheakMine]) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;您胜利啦&quot; message:@&quot;&quot; delegate:self cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show]; &#125; //判断对方是否胜利 if ([self cheakOther]) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;您失败了&quot; message:@&quot;&quot; delegate:self cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show]; &#125;&#125;-(void)setTipIndex:(int)index&#123; //下子 for (TipButton * btn in _tipArray) &#123; if (btn.index==index) &#123; [btn dropChess:NO]; [self cheak]; &#125; &#125;&#125;-(BOOL)cheakOther&#123; //遍历所有棋子 for (int i=0; i&lt;_tipArray.count; i++) &#123; TipButton * tip = _tipArray[i]; //获取是否是己方棋子 if (tip.hasChess==2) &#123; //进行五子判定逻辑 //横向 if ( [self cheak1HasMineOrOther:NO index:i]) &#123; return YES; &#125; //左上到右下的对角线 if ( [self cheak2HasMineOrOther:NO index:i]) &#123; return YES; &#125; //纵向 if ( [self cheak3HasMineOrOther:NO index:i]) &#123; return YES; &#125; //右上到左下的对角线 if ( [self cheak4HasMineOrOther:NO index:i]) &#123; return YES; &#125; &#125; &#125; return NO;&#125;-(BOOL)cheakMine&#123; //遍历所有棋子 for (int i=0; i&lt;_tipArray.count; i++) &#123; TipButton * tip = _tipArray[i]; //获取是否是己方棋子 if (tip.hasChess==1) &#123; //进行五子判定逻辑 //横向 if ( [self cheak1HasMineOrOther:YES index:i]) &#123; return YES; &#125; //左上到右下的对角线 if ( [self cheak2HasMineOrOther:YES index:i]) &#123; return YES; &#125; //纵向 if ( [self cheak3HasMineOrOther:YES index:i]) &#123; return YES; &#125; //右上到左下的对角线 if ( [self cheak4HasMineOrOther:YES index:i]) &#123; return YES; &#125; &#125; &#125; return NO;&#125;-(BOOL)cheak1HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //左侧右侧同时进行可以增加效率 //左侧 count = count +[self algorithmic1:index param:mineOrOther num:4]; //右侧 count = count +[self algorithmic2:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak2HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //左上右下同时进行可以增加效率 //左上 count = count +[self algorithmic3:index param:mineOrOther num:4]; //右下 count = count +[self algorithmic4:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak3HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //纵向 //向上 count = count +[self algorithmic5:index param:mineOrOther num:4]; //向下 count = count +[self algorithmic6:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak4HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //纵向 //向上 count = count +[self algorithmic7:index param:mineOrOther num:4]; //向下 count = count +[self algorithmic8:index param:mineOrOther num:4]; NSLog(@&quot;%d&quot;,count); if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;/* 左侧递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic1:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左侧有子 if (index-tem&gt;=0) &#123; //左侧无换行 if(((index-tem)%12)!=11)&#123; if (_tipArray[index-tem].hasChess==param) &#123; return [self algorithmic1:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;/* 右侧递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic2:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //右侧有子 if (index+tem&lt;240) &#123; //右侧无换行 if(((index+tem)%12)!=11)&#123; if (_tipArray[index+tem].hasChess==param) &#123; return [self algorithmic2:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;/* 左上递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic3:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index-(tem*12)-tem)&gt;=0) &#123; //右侧无换行 if(((index-(tem*12)-tem)%12)!=11)&#123; if (_tipArray[(index-(tem*12)-tem)].hasChess==param) &#123; return [self algorithmic3:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic4:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index+(tem*12)+tem)&lt;240) &#123; //右侧无换行 if(((index+(tem*12)+tem)%12)!=0)&#123; if (_tipArray[(index+(tem*12)+tem)].hasChess==param) &#123; return [self algorithmic4:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic5:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //上有子 if ((index-(tem*12))&gt;=0) &#123; if (_tipArray[(index-(tem*12))].hasChess==param) &#123; return [self algorithmic5:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic6:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //上有子 if ((index+(tem*12))&lt;240) &#123; if (_tipArray[(index+(tem*12))].hasChess==param) &#123; return [self algorithmic6:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic7:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index-(tem*12)+tem)&gt;=0) &#123; //右侧无换行 if(((index-(tem*12)+tem)%12)!=0)&#123; if (_tipArray[(index-(tem*12)+tem)].hasChess==param) &#123; return [self algorithmic7:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic8:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index+(tem*12)-tem)&lt;240) &#123; //右侧无换行 if(((index+(tem*12)-tem)%12)!=11)&#123; if (_tipArray[(index+(tem*12)-tem)].hasChess==param) &#123; return [self algorithmic8:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; [[BlueToothTool sharedManager]disConnect]; [(UIViewController *)[self.superview nextResponder] dismissViewControllerAnimated:YES completion:nil];&#125;@end 关于胜负判定的算法逻辑，这里采用了向各个方向进行递归查找的方式，这里有一点需要主要，在4个方向进行递归查找时，理论上每个方向只需要单面递归即可，但是代码中采用了双面递归在进行累加的方式，这样的设计可以遍历更少的棋子判定出胜负情况。 四、整合通讯与游戏逻辑 创建一个继承于UIViewController的类作为游戏视图控制器，实现如下： GameViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#import &quot;GameViewController.h&quot;#import &quot;GameView.h&quot;#import &quot;BlueToothTool.h&quot;@interface GameViewController ()&lt;BlueToothToolDelegate,GameViewDelegate&gt;&#123; UIView * _bgView; UILabel * _tipLabel; GameView * _view;&#125;@end@implementation GameViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor brownColor]; //创建游戏视图 _view = [[GameView alloc]initWithFrame:CGRectMake(20, 40, (self.view.frame.size.width-40), (self.view.frame.size.width-40)/12*20)]; _view.delegate=self; [self.view addSubview:_view]; //创建背景视图 _bgView = [[UIView alloc]initWithFrame:self.view.frame]; _bgView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.1]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeSystem]; btn.frame = CGRectMake(self.view.frame.size.width/2-50, 150, 100, 30); UIButton * btn2 = [UIButton buttonWithType:UIButtonTypeSystem]; btn2.frame = CGRectMake(self.view.frame.size.width/2-50, 250, 100, 30); [btn setTitle:@&quot;创建游戏&quot; forState:UIControlStateNormal]; [btn2 setTitle:@&quot;扫描附近游戏&quot; forState:UIControlStateNormal]; btn.backgroundColor = [UIColor orangeColor]; btn2.backgroundColor = [UIColor orangeColor]; [btn addTarget:self action:@selector(creatGame) forControlEvents:UIControlEventTouchUpInside]; [btn2 addTarget:self action:@selector(searchGame) forControlEvents:UIControlEventTouchUpInside]; [_bgView addSubview:btn]; [_bgView addSubview:btn2]; [self.view addSubview:_bgView]; //设置蓝牙通讯类代理 [BlueToothTool sharedManager].delegate=self; //创建提示标签 _tipLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width,40)]; [self.view addSubview:_tipLabel]; _tipLabel.textAlignment = NSTextAlignmentCenter;&#125;-(void)creatGame&#123; [[BlueToothTool sharedManager]setUpGame:@&quot;&quot; block:^(BOOL first) &#123; [_bgView removeFromSuperview]; if (first) &#123; _tipLabel.text = @&quot;请您下子&quot;; //进行发送下子信息 &#125;else&#123; _tipLabel.text = @&quot;请等待对方下子&quot;; self.view.userInteractionEnabled = NO; [self gameViewClick:@&quot;-1&quot;]; &#125; &#125;];&#125;-(void)searchGame&#123; [[BlueToothTool sharedManager]searchGame];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;-(void)getData:(NSString *)data&#123; if (_bgView.superview) &#123; [_bgView removeFromSuperview]; &#125; if ([data integerValue]==-1) &#123; _tipLabel.text = @&quot;请您下子&quot;; self.view.userInteractionEnabled = YES; return; &#125; _tipLabel.text = @&quot;请您下子&quot;; [_view setTipIndex:[data intValue]]; self.view.userInteractionEnabled = YES;&#125;-(void)gameViewClick:(NSString *)index&#123; _tipLabel.text = @&quot;请等待对方下子&quot;; [[BlueToothTool sharedManager]writeData:index]; self.view.userInteractionEnabled = NO;&#125;@end 游戏运行的主要界面如下图所示： 附录：游戏的源码已经放在git上，时间比较仓促，只用了一下午来写，其中还有许多细节与bug没有进行调整，有需要的可以作为参考： git地址：https://github.com/ZYHshao/BlueGame。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计","slug":"187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计","date":"2016-03-20T16:00:00.000Z","updated":"2021-07-06T07:12:16.245Z","comments":true,"path":"2016/03/21/187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计/","link":"","permalink":"http://huishao.cc/2016/03/21/187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计/","excerpt":"","text":"iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计一、引言本系列博客将系统的介绍一款蓝牙对战五子棋的开发思路与过程，其中的核心部分有两个，一部分是蓝牙通讯中对战双方信息交互框架的设计与开发，一部分是五子棋游戏中棋盘逻辑与胜负判定的算法实现。本篇博客将介绍游戏中蓝牙通讯类的设计思路 二、设计通讯类的核心想法 在前篇的一篇博客中，我们有详细的介绍iOS中蓝牙4.0技术的应用与系统框架CoorBluetooth.framework中提供的编程接口的用法。博客地址如下，如果读者需要更详细的了解iOS中蓝牙技术的使用，可以先阅读这篇博客： iOS开发之蓝牙通讯：http://my.oschina.net/u/2340880/blog/548127。 在使用蓝牙进行应用间通讯交互时，必须有一方作为中心设备，有一方作为外围设备。举一个简单的例子，通过手机蓝牙可以和刷卡设备、打印机等进行信息交互，这里的刷卡设备、打印机就充当着外围设备的角色，手机就充当着中心设备的角色。在中心设备与外围设备间，外设负责向周围广播广告告知其他设备自己的存在，中心设备接收到外设广播的广告后可以选择目标设备进行连接，当然，外设的广播的广告中会携带一些身份信息供中心设备进行识别。一旦中心设备与外设建立连接，中心设备变可以使用外设提供的服务，一个外设可以提供多个服务，例如一款蓝牙打印机外设可能会提供两种服务，一种服务向中心设备发送约定信息，告知中心设备支持的打印格式，一种服务获取中心设备的数据来进行打印服务。服务是中心设备与外设机型通讯的功能标识，然而具体的通讯媒介则是由服务中的特征值来完成的，一个服务也可以提供多个特征值。可以这样理解，特征值是两设备进行蓝牙通讯的最小通讯单元，是读写数据的载体。 上面简单介绍了在蓝牙通讯中的一些基本流程与相关概念，应用于游戏中略微有一些区别，首先我们这款游戏应该具备既可以作为中心设备也可以作为外设的能力，因此，我们需要将中心设备的通讯模式与外设的通讯模式都集成与游戏的通讯框架中。游戏的双方要建立连接应该有如下几个过程： 1.有一方建立游戏，作为房主。 2.由一方作为游戏的加入者，扫描附近的游戏。 3.外设提供的服务中应该至少有两个特征值，一个用于己方下子后通知对方设备，一个用于监听对方设备的下子操作。 由上面分析可知，游戏中的房主正是充当蓝牙通讯中的外设，它将广播广告告知周围设备自己的存在。而游戏中的加入者则是充当着蓝牙通讯中的中心设备，扫描到周围的游戏房间后进行连接加入，开始游戏。 三、游戏中蓝牙通讯类的设计 创建一个命名为BlueToothTool的工具类，作为游戏的蓝牙通讯类，编写其头文件如下： BlueToothTool.h 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;CoreBluetooth/CoreBluetooth.h&gt;//这个代理用于处理接收到对方设备发送来的数据后的回调@protocol BlueToothToolDelegate &lt;NSObject&gt;//获取对方数据-(void)getData:(NSString *)data;@end@interface BlueToothTool : NSObject&lt;CBPeripheralManagerDelegate,CBCentralManagerDelegate,CBPeripheralDelegate,UIAlertViewDelegate&gt;//代理@property(nonatomic,weak)id&lt;BlueToothToolDelegate&gt;delegate;//标记是否是游戏中的房主@property(nonatomic,assign)BOOL isCentral;/** *获取单例对象的方法 */+(instancetype)sharedManager;/* *作为游戏的房主建立游戏房间 */-(void)setUpGame:(NSString *)name block:(void(^)(BOOL first))finish;/* *作为游戏的加入者查找附近的游戏 */-(void)searchGame;/** *断块连接 */-(void)disConnect;/* *进行写数据操作 */-(void)writeData:(NSString *)data;@end 实现BlueToothTool.m文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274#import &quot;BlueToothTool.h&quot;@implementation BlueToothTool&#123; //外设管理中心 CBPeripheralManager * _peripheralManager; //外设提供的服务 CBMutableService * _ser; //服务提供的读特征值 CBMutableCharacteristic * _readChara; //服务提供的写特征值 CBMutableCharacteristic * _writeChara; //等待对方加入的提示视图 UIView * _waitOtherView; //正在扫描附近游戏的提示视图 UIView * _searchGameView; //设备中心管理对象 CBCentralManager * _centerManger; //要连接的外设 CBPeripheral * _peripheral; //要交互的外设属性 CBCharacteristic * _centerReadChara; CBCharacteristic * _centerWriteChara; //开始游戏后的回调 告知先手与后手信息 void(^block)(BOOL first);&#125;//实现单例方法+(instancetype)sharedManager&#123; static BlueToothTool *tool = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; tool = [[self alloc] init]; &#125;); return tool;&#125;//实现创建游戏的方法-(void)setUpGame:(NSString *)name block:(void (^)(BOOL))finish&#123; block = [finish copy]; if (_peripheralManager==nil) &#123; //初始化服务 _ser= [[CBMutableService alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;] primary:YES]; //初始化特征 _readChara = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;] properties:CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable]; _writeChara = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00068&quot;] properties:CBCharacteristicPropertyWriteWithoutResponse value:nil permissions:CBAttributePermissionsWriteable]; //向服务中添加特征 _ser.characteristics = @[_readChara,_writeChara]; _peripheralManager = [[CBPeripheralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)]; &#125; //设置为房主 _isCentral=YES; //开始广播广告 [_peripheralManager startAdvertising:@&#123;CBAdvertisementDataLocalNameKey:@&quot;WUZIGame&quot;&#125;];&#125;//外设检测蓝牙状态-(void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral&#123; //判断是否可用 if (peripheral.state==CBPeripheralManagerStatePoweredOn) &#123; //添加服务 [_peripheralManager addService:_ser]; //开始广播广告 [_peripheralManager startAdvertising:@&#123;CBAdvertisementDataLocalNameKey:@&quot;WUZIGame&quot;&#125;]; &#125;else&#123; //弹提示框 dispatch_async(dispatch_get_main_queue(), ^&#123; [self showAlert]; &#125;); &#125;&#125;//开始放广告的回调-(void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error&#123; if (_waitOtherView==nil) &#123; _waitOtherView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; dispatch_async(dispatch_get_main_queue(), ^&#123; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;等待附近玩家加入&quot;; [_waitOtherView addSubview:label]; _waitOtherView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [[[UIApplication sharedApplication].delegate window]addSubview:_waitOtherView]; &#125;); &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_waitOtherView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_waitOtherView]; &#125;); &#125;&#125;//添加服务后回调的方法-(void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error&#123; if (error) &#123; NSLog(@&quot;添加服务失败&quot;); &#125; NSLog(@&quot;添加服务成功&quot;);&#125;//中心设备订阅特征值时回调-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic&#123; [_peripheralManager stopAdvertising]; if (_isCentral) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;&quot; message:@&quot;请选择先手后手&quot; delegate:self cancelButtonTitle:@&quot;我先手&quot; otherButtonTitles:@&quot;我后手&quot;, nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [_waitOtherView removeFromSuperview]; [alert show]; &#125;); &#125;&#125;//收到写消息后的回调-(void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.delegate getData:[[NSString alloc]initWithData:requests.firstObject.value encoding:NSUTF8StringEncoding]]; &#125;);&#125;//弹提示框的方法-(void)showAlert&#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;温馨提示&quot; message:@&quot;请确保您的蓝牙可用&quot; delegate:nil cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show];&#125;//===============================================================作为游戏加入这实现的方法========//搜索周围游戏-(void)searchGame&#123; if (_centerManger==nil) &#123; _centerManger = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)]; &#125;else&#123; [_centerManger scanForPeripheralsWithServices:nil options:nil]; if (_searchGameView==nil) &#123; _searchGameView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;正在扫加入描附近游戏&quot;; _searchGameView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [_searchGameView addSubview:label]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;else&#123; [_searchGameView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125; &#125; //设置为游戏加入方 _isCentral = NO;&#125;//设备硬件检测状态回调的方法 可用后开始扫描设备-(void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; if (_centerManger.state==CBCentralManagerStatePoweredOn) &#123; [_centerManger scanForPeripheralsWithServices:nil options:nil]; if (_searchGameView==nil) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; _searchGameView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;正在扫加入描附近游戏&quot;; _searchGameView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [_searchGameView addSubview:label]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;); &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_searchGameView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;); &#125; &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self showAlert]; &#125;); &#125;&#125;//发现外设后调用的方法-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; //获取设备的名称 或者广告中的相应字段来配对 NSString * name = [advertisementData objectForKey:CBAdvertisementDataLocalNameKey]; if ([name isEqualToString:@&quot;WUZIGame&quot;]) &#123; //保存此设备 _peripheral = peripheral; //进行连接 [_centerManger connectPeripheral:peripheral options:@&#123;CBConnectPeripheralOptionNotifyOnConnectionKey:@YES&#125;]; &#125;&#125;//连接外设成功的回调-(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; NSLog(@&quot;连接成功&quot;); //设置代理与搜索外设中的服务 [peripheral setDelegate:self]; [peripheral discoverServices:nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [_searchGameView removeFromSuperview]; &#125;);&#125;//连接断开-(void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@&quot;连接断开&quot;); [_centerManger connectPeripheral:peripheral options:@&#123;CBConnectPeripheralOptionNotifyOnConnectionKey:@YES&#125;];&#125;//发现服务后回调的方法-(void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; for (CBService *service in peripheral.services) &#123; //发现服务 比较服务的UUID if ([service.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;]]) &#123; NSLog(@&quot;Service found with UUID: %@&quot;, service.UUID); //查找服务中的特征值 [peripheral discoverCharacteristics:nil forService:service]; break; &#125; &#125;&#125;//开发服务中的特征值后回调的方法-(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; for (CBCharacteristic *characteristic in service.characteristics) &#123; //发现特征 比较特征值得UUID 来获取所需要的 if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;]]) &#123; //保存特征值 _centerReadChara = characteristic; //监听特征值 [_peripheral setNotifyValue:YES forCharacteristic:_centerReadChara]; &#125; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00068&quot;]]) &#123; //保存特征值 _centerWriteChara = characteristic; &#125; &#125;&#125;//所监听的特征值更新时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; //更新接收到的数据 NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:characteristic.value encoding:NSUTF8StringEncoding]); //要在主线程中刷新 dispatch_async(dispatch_get_main_queue(), ^&#123; [self.delegate getData:[[NSString alloc]initWithData:characteristic.value encoding:NSUTF8StringEncoding]]; &#125;);&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; //告诉开发者先后手信息 if (buttonIndex==0) &#123; if (_isCentral) &#123; block(1); &#125;else&#123; block(0); &#125; &#125;else&#123; if (_isCentral) &#123; block(0); &#125;else&#123; block(1); &#125; &#125;&#125;//断开连接-(void)disConnect&#123; if (!_isCentral) &#123; [_centerManger cancelPeripheralConnection:_peripheral]; [_peripheral setNotifyValue:NO forCharacteristic:_centerReadChara]; &#125;&#125;//写数据-(void)writeData:(NSString *)data&#123; if (_isCentral) &#123; [_peripheralManager updateValue:[data dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:_readChara onSubscribedCentrals:nil]; &#125;else&#123; [_peripheral writeValue:[data dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:_centerWriteChara type:CBCharacteristicWriteWithoutResponse]; &#125;&#125;@end 附录：游戏的源码已经放在git上，时间比较仓促，只用了一下午来写，其中还有许多细节与bug没有进行调整，有需要的可以作为参考： git地址：https://github.com/ZYHshao/BlueGame。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS音频播放器锁屏歌词显示与性能优化","slug":"186iOS音频播放器锁屏歌词显示与性能优化","date":"2016-03-12T16:00:00.000Z","updated":"2021-07-06T07:11:10.155Z","comments":true,"path":"2016/03/13/186iOS音频播放器锁屏歌词显示与性能优化/","link":"","permalink":"http://huishao.cc/2016/03/13/186iOS音频播放器锁屏歌词显示与性能优化/","excerpt":"","text":"iOS音频播放器锁屏歌词显示与性能优化一、引言前边有博客探讨了有关iOS开发中音频播放的技术与进行后台音频播放并在后台与用户进行交互的方法，本篇将探讨一种在锁屏界面同步显示歌词歌词的方法，并在应用性能上进行一些处理。前边博客地址如下： iOS音频开发AVAudioPlayer的应用：http://my.oschina.net/u/2340880/blog/420129。 iOS后台音频开发与交互技术：http://my.oschina.net/u/2340880/blog/420183。 二、在锁屏界面同步显示歌词 我们知道，在音频后台播放时，锁屏界面的信息是由MPNowPlayingInfoCenter来设置的，其中的歌曲信息字典可以设置类似歌曲封面，艺术家，歌曲名，歌曲时间等。然而，对于MPNowPlayingInfoCenter中可以由开发者掌握的接口十分有限，若要在锁屏界面同步的显示歌曲歌词，一个比较简单的方法是不停的将当前歌词与封面进行图片合成，之后刷新锁屏界面的图片。下面代码是根据解析好的LRC歌词数据进行图片合成的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//这个方法通过传入的LRC歌词数据进行图片的合成 array参数为每行lrc歌词数据集合 index为当前需要播放的lrc歌词行数-(void)setCurretLRCArray:(NSArray *)array index:(int)index&#123; //LRCItem是歌词模型 里面的lrc方法获取歌词文字字符串 NSString * lineLRC = [(LRCItem *)array[index] lrc]; //提高性能 进行判断 当前显示的歌词有无变化 如果没变化 不进行后续操作 if ([_lrcLabel.text isEqualToString:lineLRC]) &#123; return; &#125; _lrcLabel.text = lineLRC; //将歌词整理成整齐数据 //进行行数设置 NSMutableString * lrcStr = [[NSMutableString alloc]init]; if (index&lt;_lines/2) &#123; //前面用\\n补齐 int offset = (int)_lines/2-index; for (int j=0; j&lt;offset; j++) &#123; [lrcStr appendFormat:@&quot;\\n&quot;]; &#125; for (int j=0; j&lt;_lines-offset; j++) &#123; [lrcStr appendFormat:@&quot;%@\\n&quot;,[(LRCItem *)array[j] lrc]]; &#125; &#125; else if (array.count-1-index&lt;_lines/2) &#123; //后面用\\n补齐 int offset = (int)_lines/2-(int)(array.count-index-1); for (int j=index-(_lines/2); j&lt;array.count; j++) &#123; [lrcStr appendFormat:@&quot;%@\\n&quot;,[(LRCItem *)array[j] lrc]]; &#125; for (int j=0; j&lt;offset; j++) &#123; [lrcStr appendFormat:@&quot;\\n&quot;]; &#125; &#125;else &#123; for (int j=0; j&lt;_lines; j++) &#123; [lrcStr appendString:[(LRCItem *)array[index-_lines/2+j] lrc]]; [lrcStr appendString:@&quot;\\n&quot;]; &#125; &#125; //将当前显示的歌词部分高亮 NSMutableAttributedString * attriStr = [[NSMutableAttributedString alloc]initWithString:lrcStr]; NSRange range = [lrcStr rangeOfString:[array[index] lrc]]; [attriStr setAttributes:@&#123;NSForegroundColorAttributeName:[UIColor greenColor]&#125; range:range]; _lrcView.attributedText = attriStr; _lrcIMGLabel.attributedText = attriStr; //进行截屏 if (!_lrcIMGbg) &#123; _lrcIMGbg = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)]; _lrcIMGbg.image = [UIImage imageNamed:@&quot;BG.jpeg&quot;]; [_lrcIMGbg addSubview:_lrcIMGLabel]; &#125; //获取添加了歌词数据的背景图 UIGraphicsBeginImageContext(_lrcIMGbg.frame.size); CGContextRef context = UIGraphicsGetCurrentContext(); [_lrcIMGbg.layer renderInContext:context]; UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); _lrcImage = [img copy];&#125; 锁屏歌词的显示效果如下： 三、应用性能的优化 从功能上来说，通过一直合成刷新锁屏界面的封面图是可行的，然而在使用中我发现，不停和合成图片和刷新操作将使设备非常耗电，如果可以完成下面的优化，则可以大大提高应用的性能： 1.应用在前台时不进行后台锁屏界面的刷新操作。 2.应用在后台时不进行前台歌词信息、歌曲信息的相应更新。 3.当屏幕变黑关闭时，停止所有刷新操作。 4.当屏幕从新被点亮时，进行后台信息刷新。 上面4点需求，前两点十分容易搞定，在AppDelegate中有如下的方法可以监听应用程序前台与后台的切换： 123456789//应用进入后台时调用- (void)applicationWillResignActive:(UIApplication *)application &#123; //发送通知 [[NSNotificationCenter defaultCenter]postNotificationName:@&quot;goBack&quot; object:nil];&#125;//应用进入前台时调用- (void)applicationDidBecomeActive:(UIApplication *)application &#123; [[NSNotificationCenter defaultCenter]postNotificationName:@&quot;goForward&quot; object:nil];&#125; 在相应的类中监听这两个通知即可以做到刷新模式的切换。 对于上面需求的第3点与第4点，Foundation框架中没有提供公开的方法来监听屏幕设备的点亮状态，但是可以通过notify\\_register\\_dispath()方法来监听。使用示例代码如下： 123456789101112#import &lt;notify.h&gt; //在定时器中使用如下代码实时监听屏幕状态 uint64_t locked; __block int token = 0; notify_register_dispatch(&quot;com.apple.springboard.hasBlankedScreen&quot;,&amp;token,dispatch_get_main_queue(),^(int t)&#123; &#125;); notify_get_state(token, &amp;locked); //如果屏幕变暗 直接不走更新方法 lock为1则为变暗关闭状态 0则为点亮状态 if (locked) &#123; return; &#125; 通过上面优化的代码，性能将会强很多。 由于前面博客已经详细的介绍了音频开发与后台交互的内容，这篇博客主要探讨了锁屏歌词相关的开发思路与优化方向，提供的示例代码都是片段，并不完整，经过优化的音频播放器源码在如下git地址上，需要的朋友可以作为参考： 同步显示锁屏歌词的音乐播放器：https://github.com/ZYHshao/MyPlayer。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C中通过下标的方式访问自定义数据模型中属性","slug":"185Objective-C中通过下标的方式访问自定义数据模型中属性","date":"2016-03-06T16:00:00.000Z","updated":"2021-07-06T07:10:13.899Z","comments":true,"path":"2016/03/07/185Objective-C中通过下标的方式访问自定义数据模型中属性/","link":"","permalink":"http://huishao.cc/2016/03/07/185Objective-C中通过下标的方式访问自定义数据模型中属性/","excerpt":"","text":"Objective-C中通过下标的方式访问自定义数据模型中属性在Objective-C中，可以通过下标来访问数组中的元素，如果数组是NSMutableArray类型的可变数组，则还可以通过下标来对数组中的元素进行赋值操作。例如： 1234 NSMutableArray * array = [[NSMutableArray alloc]init]; array[0] = @&quot;one&quot;; NSString * str = array[0]; NSLog(@&quot;%@&quot;,str); 对于Objective-C中的字典对象，可以通过键值下标的方式来进行访问，例如： 123 NSMutableDictionary * dic = [[NSMutableDictionary alloc]init]; dic[@&quot;name&quot;] = @&quot;name&quot;; NSLog(@&quot;%@&quot;,dic[@&quot;name&quot;]); 对于开发者自定义的的数据结构，一般会采用getter与setter方法来对其属性进行访问，虽然官方文档上没有提及，实际上，可以通过实现一些方法，来使自定义的数据模型支持使用下标来进行访问。 创建一个数据模型类，使其继承自NSObject，如下： MyModel.h 12@interface MyModel : NSObject@end MyModel.m 123456789101112131415161718192021222324@implementation MyModel&#123; NSString * _index0; NSString * _index1; NSString * _value;&#125;//通过下标获取属性值-(id) objectAtIndexedSubscript:(NSUInteger)idx &#123; return [self valueForKey:[NSString stringWithFormat:@&quot;_index%lu&quot;,idx]];&#125;//通过下标设置属性值- (void)setObject:(id)anObject atIndexedSubscript:(NSUInteger)index&#123; [self setValue:anObject forKey:[NSString stringWithFormat:@&quot;_index%lu&quot;,index]];&#125;//通过键值下标获取属性-(id) objectForKeyedSubscript:(id)key &#123; return [self valueForKey:key];&#125;//通过键值下标设置属性- (void)setObject:(id)object forKeyedSubscript:(id &lt; NSCopying &gt;)aKey&#123; [self setValue:object forKey:aKey];&#125;@end 使用如下代码进行测试： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; id model = [[MyModel alloc]init]; model[@&quot;_value&quot;] = @&quot;name&quot;; model[0] = @&quot;one&quot;; model[1] = @&quot;two&quot;; NSLog(@&quot;%@,%@,%@&quot;,model[0],model[1],model[@&quot;_value&quot;]);&#125; 这里有一点需要注意，若使用下标访问属性这种方法，必须将model声明为id类型，否则会影响编译。 在打印信息的可以看到，模型数据的设置和获取都没有问题，这种方法可以完全解放.h文件，如上所示，我们在数据模型的.h文件中一行代码都没有编写即可完成与MyModel模型数据的交互。然而其也有很大的弊端，代码的易调试和可读性都大大的降低，因此，没有特殊需求，一般不要使用这种方式来构建模型。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS翻页视图控制器UIPageViewController的应用","slug":"184iOS翻页视图控制器UIPageViewController的应用","date":"2016-03-02T16:00:00.000Z","updated":"2021-07-06T07:09:12.561Z","comments":true,"path":"2016/03/03/184iOS翻页视图控制器UIPageViewController的应用/","link":"","permalink":"http://huishao.cc/2016/03/03/184iOS翻页视图控制器UIPageViewController的应用/","excerpt":"","text":"iOS翻页视图控制器UIPageViewController的应用一、引言UIPageViewController是iOS中少见的动画视图控制器之一，通过它既可以创建类似UIScrollView与UIPageControl结合的滚屏视图，也可以创建类似图书效果的炫酷翻页视图。UIPageViewController类似一个视图容器，其中每个具体的视图由各自的ViewController进行维护管理，UIPageViewController只进行协调与动画布置。下图可以很好的展现出UIPageViewControlelr的使用结构： 上图中，UIPageViewControllerDataSource协议为UIPageViewController提供数据支持，DataSource协议提供的数据来自各个ViewContoller自行维护，UIPageViewControllerDelegate中的回调可以对翻页动作，屏幕旋转动作等进行监听。UIPageViewController把从DataSource中获取到的视图数据渲染给View用于当前视图控制器的展示。 二、创建一个UIPageViewController首先新建一个类作为翻页视图控制器中具体每一页视图的控制器，使其继承于UIViewController： ModelViewController.h 12345#import &lt;UIKit/UIKit.h&gt;@interface ModelViewController : UIViewController+(ModelViewController *)creatWithIndex:(int)index;@property(nonatomic,strong)UILabel * indexLabel;@end ModelViewController.m 1234567891011121314151617#import &quot;ModelViewController.h&quot;@interface ModelViewController ()@end@implementation ModelViewController+(ModelViewController *)creatWithIndex:(int)index&#123; ModelViewController * con = [[ModelViewController alloc]init]; con.indexLabel = [[UILabel alloc]initWithFrame:CGRectMake(110, 200, 100, 30)]; con.indexLabel.text = [NSString stringWithFormat:@&quot;第%d页&quot;,index]; [con.view addSubview:con.indexLabel]; return con;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.view.backgroundColor = [UIColor redColor];&#125;@end 在工程模板自带的ViewController.m文件中实现如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#import &quot;ViewController.h&quot;#import &quot;ModelViewController.h&quot;//遵守协议@interface ViewController ()&lt;UIPageViewControllerDataSource,UIPageViewControllerDelegate&gt;&#123; //翻页视图控制器对象 UIPageViewController * _pageViewControl; //数据源数组 NSMutableArray * _dataArray;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //进行初始化 _pageViewControl = [[UIPageViewController alloc]initWithTransitionStyle:UIPageViewControllerTransitionStyleScroll navigationOrientation:UIPageViewControllerNavigationOrientationHorizontal options:@&#123;UIPageViewControllerOptionSpineLocationKey:@0,UIPageViewControllerOptionInterPageSpacingKey:@10&#125;]; self.view.backgroundColor = [UIColor greenColor]; //设置翻页视图的尺寸 _pageViewControl.view.bounds=self.view.bounds; //设置数据源与代理 _pageViewControl.dataSource=self; _pageViewControl.delegate=self; //创建初始界面 ModelViewController * model = [ModelViewController creatWithIndex:1]; //设置初始界面 [_pageViewControl setViewControllers:@[model] direction:UIPageViewControllerNavigationDirectionReverse animated:YES completion:nil]; //设置是否双面展示 _pageViewControl.doubleSided = NO; _dataArray = [[NSMutableArray alloc]init]; [_dataArray addObject:model]; [self.view addSubview:_pageViewControl.view];&#125;//翻页控制器进行向前翻页动作 这个数据源方法返回的视图控制器为要显示视图的视图控制器- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerBeforeViewController:(UIViewController *)viewController&#123; int index = (int)[_dataArray indexOfObject:viewController]; if (index==0) &#123; return nil; &#125;else&#123; return _dataArray[index-1]; &#125;&#125;//翻页控制器进行向后翻页动作 这个数据源方法返回的视图控制器为要显示视图的视图控制器- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerAfterViewController:(UIViewController *)viewController&#123; int index = (int)[_dataArray indexOfObject:viewController]; if (index==9) &#123; return nil; &#125;else&#123; if (_dataArray.count-1&gt;=(index+1)) &#123; return _dataArray[index+1]; &#125;else&#123; ModelViewController * model = [ModelViewController creatWithIndex:index+2]; [_dataArray addObject:model]; return model; &#125; &#125;&#125;//屏幕旋转触发的代理方法- (UIPageViewControllerSpineLocation) pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation&#123; return UIPageViewControllerSpineLocationMin;&#125;//设置分页控制器的分页数- (NSInteger)presentationCountForPageViewController:(UIPageViewController *)pageViewController &#123; return 10;&#125;//设置初始的分页点- (NSInteger)presentationIndexForPageViewController:(UIPageViewController *)pageViewController&#123; return 0;&#125;@end 上面创建了最简单的翻页视图控制器示例，效果如下图： 三、UIPageViewController中方法使用解析12//创建翻页视图控制器对象- (instancetype)initWithTransitionStyle:(UIPageViewControllerTransitionStyle)style navigationOrientation:(UIPageViewControllerNavigationOrientation)navigationOrientation options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 上面方法用于创建视图控制器对象，其中UIPageViewControllerTransitionStyle参数设置翻页控制器的风格，枚举如下： 1234typedef NS_ENUM(NSInteger, UIPageViewControllerTransitionStyle) &#123; UIPageViewControllerTransitionStylePageCurl = 0, //类似于书本翻页效果 UIPageViewControllerTransitionStyleScroll = 1 // 类似于ScrollView的滑动效果&#125;; 如果设置为UIPageViewControllerTransitionStyleCurl，翻页效果如下图所示： 上面初始化方法中的UIPageViewControllerNavigationOrientation属性设置翻页的方向，枚举如下： 1234typedef NS_ENUM(NSInteger, UIPageViewControllerNavigationOrientation) &#123; UIPageViewControllerNavigationOrientationHorizontal = 0,//水平翻页 UIPageViewControllerNavigationOrientationVertical = 1//竖直翻页&#125;; options参数用于设置翻页视图控制器的配置字典，其可以设置的配置键值如下： 1234//这个键需要设置为UIPageViewControllerOptionSpineLocationKey枚举值对应的NSNumber对象 设置翻页控制器的书轴 后面会介绍NSString * const UIPageViewControllerOptionSpineLocationKey;//这个键需要设置为NSNumber类型 设置每页视图的间距 用于滚动视图风格的NSString * const UIPageViewControllerOptionInterPageSpacingKey; 下面是UIPageViewController的一些常用属性与方法： 1234567891011121314//设置数据源@property (nullable, nonatomic, weak) id &lt;UIPageViewControllerDelegate&gt; delegate;//设置代理@property (nullable, nonatomic, weak) id &lt;UIPageViewControllerDataSource&gt; dataSource;//获取翻页风格@property (nonatomic, readonly) UIPageViewControllerTransitionStyle transitionStyle;//获取翻页方向@property (nonatomic, readonly) UIPageViewControllerNavigationOrientation navigationOrientation;//获取书轴类型@property (nonatomic, readonly) UIPageViewControllerSpineLocation spineLocation;//设置是否双面显示@property (nonatomic, getter=isDoubleSided) BOOL doubleSided;//设置要显示的视图控制器- (void)setViewControllers:(nullable NSArray&lt;UIViewController *&gt; *)viewControllers direction:(UIPageViewControllerNavigationDirection)direction animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion; 上面只有spineLocation属性有些难于理解，其枚举如下： 12345678910typedef NS_ENUM(NSInteger, UIPageViewControllerSpineLocation) &#123; //对于SCrollView类型的滑动效果 没有书轴 会返回下面这个枚举值 UIPageViewControllerSpineLocationNone = 0, //以左边或者上边为轴进行翻转 界面同一时间只显示一个View UIPageViewControllerSpineLocationMin = 1, //以中间为轴进行翻转 界面同时可以显示两个View UIPageViewControllerSpineLocationMid = 2, //以下边或者右边为轴进行翻转 界面同一时间只显示一个View UIPageViewControllerSpineLocationMax = 3 &#125;; 将上面的示例代码修改几个地方如下： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. _pageViewControl = [[UIPageViewController alloc]initWithTransitionStyle:UIPageViewControllerTransitionStylePageCurl navigationOrientation:UIPageViewControllerNavigationOrientationVertical options:@&#123;UIPageViewControllerOptionSpineLocationKey:@2,UIPageViewControllerOptionInterPageSpacingKey:@10&#125;]; self.view.backgroundColor = [UIColor greenColor]; _pageViewControl.view.bounds=self.view.bounds; _pageViewControl.dataSource=self; _pageViewControl.delegate=self; ModelViewController * model = [ModelViewController creatWithIndex:1]; ModelViewController * model2 = [ModelViewController creatWithIndex:2]; [_pageViewControl setViewControllers:@[model,model2] direction:UIPageViewControllerNavigationDirectionReverse animated:YES completion:nil]; _pageViewControl.doubleSided = YES; _dataArray = [[NSMutableArray alloc]init]; [_dataArray addObject:model]; [self.view addSubview:_pageViewControl.view];&#125;- (UIPageViewControllerSpineLocation) pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation&#123; return UIPageViewControllerSpineLocationMid;&#125; 运行效果如下图所示： 四、UIPageViewControllerDataSource中方法解析12345678//向前翻页展示的ViewController- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerBeforeViewController:(UIViewController *)viewController;//向后翻页展示的ViewController- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerAfterViewController:(UIViewController *)viewController;//设置分页控制器的分页点数- (NSInteger)presentationCountForPageViewController:(UIPageViewController *)pageViewController NS_AVAILABLE_IOS(6_0);//设置当前分页控制器所高亮的点- (NSInteger)presentationIndexForPageViewController:(UIPageViewController *)pageViewController NS_AVAILABLE_IOS(6_0); 五、UIPageViewControllerDelegate中方法解析123456//翻页视图控制器将要翻页时执行的方法- (void)pageViewController:(UIPageViewController *)pageViewController willTransitionToViewControllers:(NSArray&lt;UIViewController *&gt; *)pendingViewControllers NS_AVAILABLE_IOS(6_0);//翻页动画执行完成后回调的方法- (void)pageViewController:(UIPageViewController *)pageViewController didFinishAnimating:(BOOL)finished previousViewControllers:(NSArray&lt;UIViewController *&gt; *)previousViewControllers transitionCompleted:(BOOL)completed;//屏幕防线改变时回到的方法，可以通过返回值重设书轴类型枚举- (UIPageViewControllerSpineLocation)pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS网络编程之七——本地用户凭证Cookie的应用","slug":"183iOS网络编程之七——本地用户凭证Cookie的应用","date":"2016-02-29T16:00:00.000Z","updated":"2021-07-06T07:08:22.118Z","comments":true,"path":"2016/03/01/183iOS网络编程之七——本地用户凭证Cookie的应用/","link":"","permalink":"http://huishao.cc/2016/03/01/183iOS网络编程之七——本地用户凭证Cookie的应用/","excerpt":"","text":"iOS网络编程之七——本地用户凭证Cookie的应用一、何为CookieCookie是网站为了便是终端身份，保存在终端本地的用户凭证信息。Cookie中的字段与意义由服务端进行定义。例如，当用户在某个网站进行了登录操作后，服务端会将Cookie信息返回给终端，终端会将这些信息进行保存，在下一次再次访问这个网站时，终端会将保存的Cookie信息一并发送到服务端，服务端根据Cookie信息是否有效来判断此用户是否可以自动登录。 二、iOS中进行Cookie管理的两个类iOS中进行HTTP网络请求Cookie管理主要由两个类负责，一个类是NSHTTPCookieStorage类，一个是NSHTTPCookie类。 1.NSHTTPCookieStorageNSHTTPCookieStorage类采用单例的设计模式，其中管理着所有HTTP请求的Cookie信息，常用方法如下： 123456789101112131415161718192021222324//获取单例对象+ (NSHTTPCookieStorage *)sharedHTTPCookieStorage;//所有Cookie数据数组 其中存放NSHTTPCookie对象@property (nullable , readonly, copy) NSArray&lt;NSHTTPCookie *&gt; *cookies;//手动设置一条Cookie数据- (void)setCookie:(NSHTTPCookie *)cookie;//删除某条Cookie信息- (void)deleteCookie:(NSHTTPCookie *)cookie;//删除某个时间后的所有Cookie信息 iOS8后可用- (nullable NSArray&lt;NSHTTPCookie *&gt; *)cookiesForURL:(NSURL *)URL;//获取某个特定URL的所有Cookie数据- (void)removeCookiesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//为某个特定的URL设置Cookie- (void)setCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies forURL:(nullable NSURL *)URL mainDocumentURL:(nullable NSURL *)mainDocumentURL;//Cookie数据的接收协议/*枚举如下：typedef NS_ENUM(NSUInteger, NSHTTPCookieAcceptPolicy) &#123; NSHTTPCookieAcceptPolicyAlways,//接收所有Cookie信息 NSHTTPCookieAcceptPolicyNever,//不接收所有Cookie信息 NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain//只接收主文档域的Cookie信息&#125;;*/@property NSHTTPCookieAcceptPolicy cookieAcceptPolicy; 系统下面的两个通知与Cookie管理有关： 1234//Cookie数据的接收协议改变时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerAcceptPolicyChangedNotification;//管理的Cookie数据发生变化时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerCookiesChangedNotification; 2.NSHTTPCookieNSHTTPCookie是具体的HTTP请求Cookie数据对象，其中属性方法如下： 12345678910111213141516171819202122232425262728293031//下面两个方法用于对象的创建和初始化 都是通过字典进行键值设置- (nullable instancetype)initWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;+ (nullable NSHTTPCookie *)cookieWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;//返回Cookie数据中可用于添加HTTP头字段的字典+ (NSDictionary&lt;NSString *, NSString *&gt; *)requestHeaderFieldsWithCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies;//从指定的响应头和URL地址中解析出Cookie数据+ (NSArray&lt;NSHTTPCookie *&gt; *)cookiesWithResponseHeaderFields:(NSDictionary&lt;NSString *, NSString *&gt; *)headerFields forURL:(NSURL *)URL;//Cookie数据中的属性字典@property (nullable, readonly, copy) NSDictionary&lt;NSString *, id&gt; *properties;//请求响应的版本@property (readonly) NSUInteger version;//请求相应的名称@property (readonly, copy) NSString *name;//请求相应的值@property (readonly, copy) NSString *value;//过期时间@property (nullable, readonly, copy) NSDate *expiresDate;//请求的域名@property (readonly, copy) NSString *domain;//请求的路径@property (readonly, copy) NSString *path;//是否是安全传输@property (readonly, getter=isSecure) BOOL secure;//是否只发送HTTP的服务@property (readonly, getter=isHTTPOnly) BOOL HTTPOnly;//响应的文档@property (nullable, readonly, copy) NSString *comment;//相应的文档URL@property (nullable, readonly, copy) NSURL *commentURL;//服务端口列表@property (nullable, readonly, copy) NSArray&lt;NSNumber *&gt; *portList; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之六——数据缓存类NSURLCache使用解析","slug":"182iOS网络编程之六——数据缓存类NSURLCache使用解析","date":"2016-02-25T16:00:00.000Z","updated":"2021-07-06T07:07:32.331Z","comments":true,"path":"2016/02/26/182iOS网络编程之六——数据缓存类NSURLCache使用解析/","link":"","permalink":"http://huishao.cc/2016/02/26/182iOS网络编程之六——数据缓存类NSURLCache使用解析/","excerpt":"","text":"iOS网络编程之六——数据缓存类NSURLCache使用解析一、引言在前面博客中，介绍了NSURLRequest请求类的相关使用方法，其中有介绍关于请求返回数据的缓存策略，实际上，iOS中具体缓存操作的管理是由NSURLCache类来实现的。NSURLRequest类介绍的博客地址如下： iOS中NSURLRequest相关使用：http://my.oschina.net/u/2340880/blog/620225。 二、NSURLCache中方法与属性123456789101112131415161718192021222324252627282930//获取当前应用的缓存管理对象+ (NSURLCache *)sharedURLCache;//设置自定义的NSURLCache作为应用缓存管理对象+ (void)setSharedURLCache:(NSURLCache *)cache;//初始化一个应用缓存对象/*memoryCapacity 设置内存缓存容量diskCapacity 设置磁盘缓存容量path 磁盘缓存路径内容缓存会在应用程序退出后 清空 磁盘缓存不会*/- (instancetype)initWithMemoryCapacity:(NSUInteger)memoryCapacity diskCapacity:(NSUInteger)diskCapacity diskPath:(nullable NSString *)path;//获取某一请求的缓存- (nullable NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request;//给请求设置指定的缓存- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;//移除某个请求的缓存- (void)removeCachedResponseForRequest:(NSURLRequest *)request;//移除所有缓存数据- (void)removeAllCachedResponses;//移除某个时间起的缓存设置- (void)removeCachedResponsesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//内存缓存容量大小@property NSUInteger memoryCapacity;//磁盘缓存容量大小@property NSUInteger diskCapacity;//当前已用内存容量@property (readonly) NSUInteger currentMemoryUsage;//当前已用磁盘容量@property (readonly) NSUInteger currentDiskUsage; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS新的视频开发框架AVPlayerViewContoller与画中画技术","slug":"181iOS新的视频开发框架AVPlayerViewContoller与画中画技术","date":"2016-02-24T16:00:00.000Z","updated":"2021-07-06T07:06:46.470Z","comments":true,"path":"2016/02/25/181iOS新的视频开发框架AVPlayerViewContoller与画中画技术/","link":"","permalink":"http://huishao.cc/2016/02/25/181iOS新的视频开发框架AVPlayerViewContoller与画中画技术/","excerpt":"","text":"iOS新的视频开发框架AVPlayerViewContoller与画中画技术一、引言前面有一篇博客探讨了iOS中视频播放的开发相关类和方法，那篇博客中主要讲解的是MeidaPlayer框架中的MPMoviePlayerController类和MPMoviePlayerViewController类。在iOS8中，iOS开发框架中引入了一个新的视频框架AVKit，其中提供了视频开发类AVPlayerViewController用于在应用中嵌入播放视频的控件。在iOS8中，这两个框架中的视频播放功能并无太大差异，基本都可以满足开发者的需求。iOS9系统后，iPad Air正式开始支持多任务与画中画的分屏功能，所谓画中画，即是用户可以将当前播放的视频缩小放在屏幕上同时进行其他应用程序的使用。这个革命性的功能将极大的方便用户的使用。于此同时，在iOS9中，MPMoviePlayerController与MPMoviePlayerViewController类也被完全易用，开发者使用AVPlayerViewController可以十分方便的实现视频播放的功能并在一些型号的iPad上集成画中画的功能。 二、AVPlayerViewController的使用与其中方法属性解析使用AVPlayerViewController首先需要引入两个框架，如下： 12#import &lt;AVKit/AVKit.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt; 使用如下代码进行视频的播放： 12345 NSString * path = [[NSBundle mainBundle]pathForResource:@&quot;iphone&quot; ofType:@&quot;mp4&quot;]; NSURL *url = [NSURL fileURLWithPath:path]; AVPlayerViewController * play = [[AVPlayerViewController alloc]init]; play.player = [[AVPlayer alloc]initWithURL:url]; [self presentViewController:play animated:YES completion:nil]; 运行工程，可以看到如下图所示的视频播放界面： AVPlayerViewController中还有如下属性和方法提供给开发者使用： 1234567891011121314151617181920//是否显示视频播放控制控件@property (nonatomic) BOOL showsPlaybackControls;//设置视频播放界面的尺寸缩放选项/*可以设置的值及意义如下：AVLayerVideoGravityResizeAspect 不进行比例缩放 以宽高中长的一边充满为基准AVLayerVideoGravityResizeAspectFill 不进行比例缩放 以宽高中短的一边充满为基准AVLayerVideoGravityResize 进行缩放充满屏幕*/@property (nonatomic, copy) NSString *videoGravity;//获取是否已经准备好开始播放@property (nonatomic, readonly, getter = isReadyForDisplay) BOOL readyForDisplay;//获取视频播放界面的尺寸@property (nonatomic, readonly) CGRect videoBounds;//视频播放器的视图 自定义的控件可以添加在其上@property (nonatomic, readonly, nullable) UIView *contentOverlayView;//画中画代理 iOS9后可用@property (nonatomic, weak, nullable) id &lt;AVPlayerViewControllerDelegate&gt; delegate NS_AVAILABLE_IOS(9_0);//是否支持画中画 iOS9后可用 默认支持@property (nonatomic) BOOL allowsPictureInPicturePlayback NS_AVAILABLE_IOS(9_0); 三、画中画编程技术应用AVPlayerViewController是默认支持画中画操作的，如上图所示，视频的播放界面右下角出现一个画中画的按钮，点击这个按钮当前播放的视频界面会缩小显示在屏幕角落，这时点击Home键回到主界面，或者切换到其他应用程序，视频播放不会中断。如下图所示： 两指的捏合操作可以将缩小的视频播放窗口进行任意尺寸的放大，如果将视频窗口拖进屏幕的边界，视频窗口会被吸进边界，用户可以通过拖拽手势将其拉出，如下图： AVPlayerViewControllerDelegate中的方法可以对用户画中画的操作进行监听： 12345678910111213141516171819202122//将要开始画中画时调用的方法- (void)playerViewControllerWillStartPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//已经开始画中画时调用的方法- (void)playerViewControllerDidStartPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//开始画中画失败调用的方法- (void)playerViewController:(AVPlayerViewController *)playerViewController failedToStartPictureInPictureWithError:(NSError *)error&#123;&#125;//将要停止画中画时调用的方法- (void)playerViewControllerWillStopPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//已经停止画中画时调用的方法- (void)playerViewControllerDidStopPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//是否在开始画中画时自动将当前的播放界面dismiss掉 返回YES则自动dismiss 返回NO则不会自动dismiss- (BOOL)playerViewControllerShouldAutomaticallyDismissAtPictureInPictureStart:(AVPlayerViewController *)playerViewController&#123; return YES;&#125;//用户点击还原按钮 从画中画模式还原回app内嵌模式时调用的方法- (void)playerViewController:(AVPlayerViewController *)playerViewController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL restored))completionHandler&#123;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之五——请求回执类NSURLResponse属性简介","slug":"180iOS网络编程之五——请求回执类NSURLResponse属性简介","date":"2016-02-24T16:00:00.000Z","updated":"2021-07-06T07:05:44.967Z","comments":true,"path":"2016/02/25/180iOS网络编程之五——请求回执类NSURLResponse属性简介/","link":"","permalink":"http://huishao.cc/2016/02/25/180iOS网络编程之五——请求回执类NSURLResponse属性简介/","excerpt":"","text":"iOS网络编程之五——请求回执类NSURLResponse属性简介NSURLResponse类中存放请求的回执信息，在发送网络请求时，如果请求成功，首先会接收到服务端的回执信息，直接开始接收具体的返回数据。NSURLResponse对象中主要有以下属性： 12345678910//请求的URL地址@property (nullable, readonly, copy) NSURL *URL;//返回数据的数据类型@property (nullable, readonly, copy) NSString *MIMEType;//获取返回数据的内容长度@property (readonly) long long expectedContentLength;//获取返回数据的编码方式@property (nullable, readonly, copy) NSString *textEncodingName;//返回拼接的数据文件名 以url为名 数据没醒MIMEType为扩展名@property (nullable, readonly, copy) NSString *suggestedFilename; 对于HTTP请求，请求回执会被封装为NSHTTPURLResponse对象，其中除了有上面那些属性外，还有如下的扩展属性： 1234//请求的状态码@property (readonly) NSInteger statusCode;//请求头中所有的字段@property (readonly, copy) NSDictionary *allHeaderFields; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之四——请求类NSURLRequest使用详解","slug":"179iOS网络编程之四——请求类NSURLRequest使用详解","date":"2016-02-23T16:00:00.000Z","updated":"2021-07-06T07:04:51.574Z","comments":true,"path":"2016/02/24/179iOS网络编程之四——请求类NSURLRequest使用详解/","link":"","permalink":"http://huishao.cc/2016/02/24/179iOS网络编程之四——请求类NSURLRequest使用详解/","excerpt":"","text":"iOS网络编程之四——请求类NSURLRequest使用详解一、引言在前面几篇博客中，介绍了iOS开发中的网络编程相关内容并且介绍了常用了两个平行的网络框架NSURLSession和NSURLConnection。无论是NSURLSession类还是NSURLConnection类，其网络请求都是通过NSURLRequest类进行发起的，本篇博客将介绍NSURLRequest类的用法和其中请求属性的设置。 前几篇博客地址如下： 1.iOS网络框架介绍：http://my.oschina.net/u/2340880/blog/618460。 2.NSURLSesstion的使用：http://my.oschina.net/u/2340880/blog/618888。 3.NSURLConnection的使用：http://my.oschina.net/u/2340880/blog/618920。 二、NSURLRequest类中常用方法和属性总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//通过类方法创建默认的请求对象/*通过这种方式创建的请求对象 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s*/+ (instancetype)requestWithURL:(NSURL *)URL;//返回一个BOOL值 用于判断是否支持安全编码+ (BOOL)supportsSecureCoding;//请求对象的初始化方法 创建时设置缓存逻辑和超时时限+ (instancetype)requestWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval;//init方法进行对象的创建 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s- (instancetype)initWithURL:(NSURL *)URL;//init方法进行对象的创建- (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval;//只读属性 获取请求对象的URL@property (nullable, readonly, copy) NSURL *URL;//只读属性 缓存策略枚举/*NSURLRequestCachePolicy枚举如下：typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)&#123; //默认的缓存协议 NSURLRequestUseProtocolCachePolicy = 0, //无论有无本地缓存数据 都进行从新请求 NSURLRequestReloadIgnoringLocalCacheData = 1, //忽略本地和远程的缓存数据 未实现的策略 NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, //无论有无缓存数据 都进行从新请求 NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, //先检查缓存 如果没有缓存再进行请求 NSURLRequestReturnCacheDataElseLoad = 2, //类似离线模式，只读缓存 无论有无缓存都不进行请求 NSURLRequestReturnCacheDataDontLoad = 3, //未实现的策略 NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented&#125;;*/@property (readonly) NSURLRequestCachePolicy cachePolicy;//只读属性 获取请求的超时时限@property (readonly) NSTimeInterval timeoutInterval;//请求主文档地址 @property (nullable, readonly, copy) NSURL *mainDocumentURL;//获取网络请求的服务类型 枚举如下/*typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)&#123; NSURLNetworkServiceTypeDefault = 0, // Standard internet traffic NSURLNetworkServiceTypeVoIP = 1, // Voice over IP control traffic NSURLNetworkServiceTypeVideo = 2, // Video traffic NSURLNetworkServiceTypeBackground = 3, // Background traffic NSURLNetworkServiceTypeVoice = 4 // Voice data&#125;;*/@property (readonly) NSURLRequestNetworkServiceType networkServiceType;//获取是否允许使用服务商蜂窝网络@property (readonly) BOOL allowsCellularAccess; NSURLRequest请求类除了在初始化时可以设定一些属性，创建出来后则大部分属性都为只读的，无法设置与修改。另一个类NSMutableURLRequest可以更加灵活的设置请求的相关属性。 三、NSMutableURLRequest类中常用方法与属性总结123456789101112//设置请求的URL@property (nullable, copy) NSURL *URL;//设置请求的缓存策略@property NSURLRequestCachePolicy cachePolicy;//设置超时时间@property NSTimeInterval timeoutInterval;//请求主文档地址@property (nullable, copy) NSURL *mainDocumentURL;//设置网络服务类型@property NSURLRequestNetworkServiceType networkServiceType NS_AVAILABLE(10_7, 4_0);//设置是否允许使用服务商蜂窝网@property BOOL allowsCellularAccess NS_AVAILABLE(10_8, 6_0); 四、NSURLRequest请求对象与HTTP/HTTPS协议相关请求的属性设置一下属性的设置必须使用NSMutableURLRequest类，如果是NSURLRequest，则只可以读，不可以修改。 12345678910111213141516//设置HPPT请求方式 默认为“GET”@property (copy) NSString *HTTPMethod;//通过字典设置HTTP请求头的键值数据@property (nullable, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields;//设置http请求头中的字段值- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//向http请求头中添加一个字段- (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//设置http请求体 用于POST请求@property (nullable, copy) NSData *HTTPBody;//设置http请求体的输入流@property (nullable, retain) NSInputStream *HTTPBodyStream;//设置发送请求时是否发送cookie数据@property BOOL HTTPShouldHandleCookies;//设置请求时是否按顺序收发 默认禁用 在某些服务器中设为YES可以提高网络性能@property BOOL HTTPShouldUsePipelining; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS应用内跳转系统设置相关界面的方法","slug":"178iOS应用内跳转系统设置相关界面的方法","date":"2016-02-22T16:00:00.000Z","updated":"2021-07-06T07:04:07.525Z","comments":true,"path":"2016/02/23/178iOS应用内跳转系统设置相关界面的方法/","link":"","permalink":"http://huishao.cc/2016/02/23/178iOS应用内跳转系统设置相关界面的方法/","excerpt":"","text":"iOS应用内跳转系统设置相关界面的方法在iOS开发中，有时会有跳转系统设置界面的需求，例如提示用户打开蓝牙或者WIFI，提醒用户打开推送或者位置权限等。在iOS6之后，第三方应用需要跳转系统设置界面，需要在URL type中添加一个prefs值，如下图： 跳转系统设置根目录中的项目使用如下的方法： 123456789101112131415161718 _array = @[ @&#123;@&quot;系统设置&quot;:@&quot;prefs:root=INTERNET_TETHERING&quot;&#125;, @&#123;@&quot;WIFI设置&quot;:@&quot;prefs:root=WIFI&quot;&#125;, @&#123;@&quot;蓝牙设置&quot;:@&quot;prefs:root=Bluetooth&quot;&#125;, @&#123;@&quot;系统通知&quot;:@&quot;prefs:root=NOTIFICATIONS_ID&quot;&#125;, @&#123;@&quot;通用设置&quot;:@&quot;prefs:root=General&quot;&#125;, @&#123;@&quot;显示设置&quot;:@&quot;prefs:root=DISPLAY&amp;BRIGHTNESS&quot;&#125;, @&#123;@&quot;壁纸设置&quot;:@&quot;prefs:root=Wallpaper&quot;&#125;, @&#123;@&quot;声音设置&quot;:@&quot;prefs:root=Sounds&quot;&#125;, @&#123;@&quot;隐私设置&quot;:@&quot;prefs:root=privacy&quot;&#125;, @&#123;@&quot;APP Store&quot;:@&quot;prefs:root=STORE&quot;&#125;, @&#123;@&quot;Notes&quot;:@&quot;prefs:root=NOTES&quot;&#125;, @&#123;@&quot;Safari&quot;:@&quot;prefs:root=Safari&quot;&#125;, @&#123;@&quot;Music&quot;:@&quot;prefs:root=MUSIC&quot;&#125;, @&#123;@&quot;photo&quot;:@&quot;prefs:root=Photos&quot;&#125; ]; NSURL * url = [NSURL URLWithString:[_array[index] allValues].firstObject]; [[UIApplication sharedApplication]openURL:url]; 如果要跳转第三方应用的设置界面中，使用prefs:root=boundleId的方式，boundleId是第三方应用的boundleId。 如果需要继续向项目内层进行跳转，可以通过添加path路径的方式，如下： 1234567891011121314 _array = @[ @&#123;@&quot;关于本机&quot;:@&quot;prefs:root=General&amp;path=About&quot;&#125;, @&#123;@&quot;软件升级&quot;:@&quot;prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK&quot;&#125;, @&#123;@&quot;日期时间&quot;:@&quot;prefs:root=General&amp;path=DATE_AND_TIME&quot;&#125;, @&#123;@&quot;Accessibility&quot;:@&quot;prefs:root=General&amp;path=ACCESSIBILITY&quot;&#125;, @&#123;@&quot;键盘设置&quot;:@&quot;prefs:root=General&amp;path=Keyboard&quot;&#125;, @&#123;@&quot;VPN&quot;:@&quot;prefs:root=General&amp;path=VPN&quot;&#125;, @&#123;@&quot;壁纸设置&quot;:@&quot;prefs:root=Wallpaper&quot;&#125;, @&#123;@&quot;声音设置&quot;:@&quot;prefs:root=Sounds&quot;&#125;, @&#123;@&quot;隐私设置&quot;:@&quot;prefs:root=privacy&quot;&#125;, @&#123;@&quot;APP Store&quot;:@&quot;prefs:root=STORE&quot;&#125;, @&#123;@&quot;还原设置&quot;:@&quot;prefs:root=General&amp;path=Reset&quot;&#125;, @&#123;@&quot;应用通知&quot;:@&quot;prefs:root=NOTIFICATIONS_ID&amp;path=应用的boundleId&quot;&#125; ]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之三——NSURLConnection的简单使用","slug":"177iOS网络编程之三——NSURLConnection的简单使用","date":"2016-02-21T16:00:00.000Z","updated":"2021-07-06T07:03:17.566Z","comments":true,"path":"2016/02/22/177iOS网络编程之三——NSURLConnection的简单使用/","link":"","permalink":"http://huishao.cc/2016/02/22/177iOS网络编程之三——NSURLConnection的简单使用/","excerpt":"","text":"iOS网络编程之三——NSURLConnection的简单使用一、引言在iOS7后，NSURLSession基本代替了NSURLConnection进行网络开发，在iOS9后，NSURLConnection相关方法被完全的弃用，iOS系统有向下兼容的特性，尽管NSURLConnection已经被弃用，但在开发中，其方法依然可以被使用，并且如果需要兼容到很低版本的iOS系统，有时就必须使用NSURLConnection类了。 二、使用NSURLConnection进行同步请求对于网络请求分为同步和异步两种，同步是指在请求结果返回之前，程序代码会卡在请求处，之后的代码不会被执行，异步是指在发送请求之后，一边在子线程中接收返回数据，一边执行之后的代码，当返回数据接收完毕后，采用回调的方式通知主线程做处理。 使用如下方法进行NSURLConnection的同步请求： 12345 NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; NSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil]; NSLog(@&quot;%@&quot;,data); NSLog(@&quot;继续执行&quot;); 打印信息如下图所示，从中可以看出，当数据返回结束时才执行后面的代码： 三、使用NSURLConnection进行异步请求使用同步的方式进行请求有一个很大的弊端，在进行网络请求时，数据的返回往往需要一定时间，不可能瞬间完成，使用同步的方式将导致界面卡死，没有提示也不能交互任何用户操作，这样的话，很有可能会给用户程序卡死的假象。 NSURLConnection类提供两种方式进行异步请求操作。 1.使用block的方式进行异步请求使用如下代码进行block方式的异步请求，在block中会传入请求到的返回数据和数据信息等参数： 1234567 NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; //其中的queue参数决定block中的代码在哪个队列中执行 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; NSLog(@&quot;%@&quot;,data); &#125;]; NSLog(@&quot;继续执行&quot;); 2.使用代理回调的异步请求方式首先遵守协议与生命一个可变的NSData用于接收数据： 12345@interface ViewController ()&lt;NSURLConnectionDataDelegate&gt;&#123; NSMutableData * _data;&#125;@end 使用如下的代码进行请求： 1234 _data = [[NSMutableData alloc]init]; NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [NSURLConnection connectionWithRequest:request delegate:self]; 请求发出后，会一次调用如下代理方法进行请求过程的监听和数据的获取： 12345678910111213141516-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; //开始接收数据 [_data setLength:0];&#125;-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; //正在接收数据 [_data appendData:data];&#125;-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; //接收数据失败 NSLog(@&quot;%@&quot;,error);&#125;-(void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; //接收数据完成 NSLog(@&quot;%@&quot;,_data);&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之一——iOS网络框架简介","slug":"175iOS网络编程之一——iOS网络框架简介","date":"2016-02-21T16:00:00.000Z","updated":"2021-07-06T07:00:53.808Z","comments":true,"path":"2016/02/22/175iOS网络编程之一——iOS网络框架简介/","link":"","permalink":"http://huishao.cc/2016/02/22/175iOS网络编程之一——iOS网络框架简介/","excerpt":"","text":"iOS网络编程之一——iOS网络框架简介一、引言通过网络，一款应用才能够内容丰富，才能够完成用户操作与后台数据的交互。网络编程是移动应用或游戏开发开发中不可缺少的技术。iOS原生的网络框架也十分完善，其中涉及到的许多类和协议用于处理网络开发中的各种需求 二、URL加载框架iOS的URL加载系统包含许多类与协议，这些类和协议相互协作完成URL加载的信息配置，协议支持，身份验证，cookie和缓存等功能。APPLE开发文档中有如下图表示他们之间的关系： 关于URL加载系统，在iOS7之后，NSURLSession是首选的API框架，在iOS9中NSURLConnection相关的方法被弃用，如果需要兼容十分旧的版本，依然需要使用NSURLConnection。 三、一些辅助类1.NSURLRequestNSURLRequest类负责一个具体的网络请求，其内部封装一个请求路径NSURL对象。如果需要对请求参数进行配置，可以使用NSMutableURLRequest。 2.NSURLResponseNSURLResponse类封装了相应数据，相应数据包括两部分，一部分是返回数据的状态码，数据长度、编码等信息，另一部分是内容数据本身。 3.NSURLCredential、NSURLProtectionSpace、NSURLCredentialStorage、NSURLAuthenticatioChallenge一些访问请求需要证书或者身份凭证进行验证，上面4个类对请求凭证进行相关设置。 4.NSURLCache在应用程序的开发中，为了减小对网络的依赖，提高程序性能，常常会对一些非实时性的数据进行缓存处理，NSURLCache类用于管理NSURLRequest请求缓存。 5.NSHTTPCookieStorage、NSHTTPCookieNSHTTPCookieStorage与NSHTTPCookie用于持久化的存储HTTP请求的Cookie数据。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之二——NSURLSession的简单使用","slug":"176iOS网络编程之二——NSURLSession的简单使用","date":"2016-02-21T16:00:00.000Z","updated":"2021-07-06T07:01:57.767Z","comments":true,"path":"2016/02/22/176iOS网络编程之二——NSURLSession的简单使用/","link":"","permalink":"http://huishao.cc/2016/02/22/176iOS网络编程之二——NSURLSession的简单使用/","excerpt":"","text":"iOS网络编程之二——NSURLSession的简单使用一、NSURLSession简介在iOS7之后，NSURLSession作为系统推荐使用的HTTP请求框架，在进行前台请求的情况下，NSURLSession与NSURLConnection并无太大差异，对于后台的请求，NSURLSession更加灵活的优势就将展现无遗。 1.NSURLSession集合的类型NSURLSession类提供3中Session类型： Default类型：提供前台请求相关方法，支持配置缓存，身份凭证等。 Ephemeral类型：即时的请求类型，不使用缓存，身份凭证等。 Background：后台类型，支持在后台完成请求任务。 2.NSURLSession任务的类型在NSURLSession中添加的请求任务支持3中类型： 数据任务：使用NSData对象进行数据的发送和获取，一般用于短数据的任务。 下载任务：从文件下载数据，支持后台下载。 上传任务：以文件的形式上传数据，支持后台上传。 二、创建并配置NSURLSession通过NSURLSessionConfiguration类对象对NSURLSession进行配置与创建，创建和配NSURLSession的示例代码如下： 1234567891011 //默认类型的 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; //即时类型的 NSURLSessionConfiguration * ephemeralConfiguration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; //后台类型的 NSURLSessionConfiguration * backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;SessionId&quot;]; //创建并设置session NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration]; NSURLSession * ephemeralSession = [NSURLSession sessionWithConfiguration:ephemeralConfiguration]; NSURLSession * backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfiguration]; NSURLSessionConfiguration还可以配置如缓存，网络模式等参数 三、使用NSURLSession进行网络请求的两种方式NSURLSession有两种方式进行网络数据的请求，一种是通过block的方式获取网络数据，一种是通过代理回调的方式获取网络数据。通过block的方式进行请求代码如下： 123456789101112 //创建session配置对象 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; //创建请求对象 NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; //创建session对象 NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration]; //添加任务 NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;,data); &#125;]; //开始任务 [task resume]; 使用代理回调的方式进行请求需要遵守如下协议： 12@interface ViewController ()&lt;NSURLSessionDataDelegate&gt;@end 将请求代码修改如下： 123456 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration delegate:self delegateQueue:[NSOperationQueue mainQueue]]; NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request]; [task resume]; 实现代理方法如下： 12345678//开始接受数据-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSLog(@&quot;=======%@&quot;,data);&#125;//接受数据结束-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;完成：error%@&quot;,error);&#125; 四、进行后台下载任务NSURLSession最大的优势在于其后台下载的灵活性，使用如下的代码进行后台数据下载： 1234 NSURLSessionConfiguration * backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;com.zyprosoft.backgroundsession&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; NSURLSession * backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfiguration delegate:self delegateQueue:nil]; [[backgroundSession downloadTaskWithRequest:request]resume]; 在下面的回调方法中可以进行下载进度的监听： 1234- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; NSLog(@&quot;######&quot;);&#125; 如果在下载过程中点击Home键使应用程序进入后台，NSURLSession的相关代理方法将不再被回调，但是下载任务依然在进行，当后台下载完成后会与AppDelegate进行交互，会调用AppDelegate中的如下方法： 123-(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler&#123; NSLog(@&quot;1111&quot;);&#125; 之后应用程序在后台会调用NSURLSesstion代理的如下方法来通知下载结果： 12345678//此方法无论成功失败都会调用-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;完成：error%@&quot;,error);&#125;//此方法只有下载成功才会调用 文件放在location位置-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location&#123; &#125; 最后将调用NSURLSesstion的如下方法： 123456-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session&#123; NSLog(@&quot;All tasks are finished&quot;); &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列四——进行数据与页面的绑定","slug":"174iOS中CoreData数据管理系列四——进行数据与页面的绑定","date":"2016-01-31T16:00:00.000Z","updated":"2021-07-06T07:00:09.045Z","comments":true,"path":"2016/02/01/174iOS中CoreData数据管理系列四——进行数据与页面的绑定/","link":"","permalink":"http://huishao.cc/2016/02/01/174iOS中CoreData数据管理系列四——进行数据与页面的绑定/","excerpt":"","text":"iOS中CoreData数据管理系列四——进行数据与页面的绑定一、引言在上一篇博客中，我们讨论了CoreData框架中添加与查询数据的操作，事实上，在大多数情况下，这些数据都是由一个UITableView表视图进行展示的，因此，CoreData框架中还未开发者提供了一个类NSFetchedResultsController，这个类作为桥接，将视图与数据进行绑定。 添加与查询数据操作：http://my.oschina.net/u/2340880/blog/611430。 二、进行数据初始化NSFetchedResultsController的初始化需要一个查询请求和一个数据操作上下文。代码示例如下： 12345678910111213141516171819202122232425262728293031//遵守协议@interface ViewController ()&lt;NSFetchedResultsControllerDelegate&gt;&#123; //数据桥接对象 NSFetchedResultsController * _fecCon;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //进行初始化操作 NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; NSPersistentStoreCoordinator * psc = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:mom]; NSURL * path =[NSURL fileURLWithPath:[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]]; [psc addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:path options:nil error:nil]; NSManagedObjectContext * moc = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType]; [moc setPersistentStoreCoordinator:psc]; NSFetchRequest * request = [NSFetchRequest fetchRequestWithEntityName:@&quot;SchoolClass&quot;]; //设置数据排序 [request setSortDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@&quot;stuNum&quot; ascending:YES]]]; //进行数据桥接对象的初始化 _fecCon = [[NSFetchedResultsController alloc]initWithFetchRequest:request managedObjectContext:moc sectionNameKeyPath:nil cacheName:nil]; //设置代理 _fecCon.delegate=self; //进行数据查询 [_fecCon performFetch:nil];&#125;@end 用于初始化NSFecthedResultsController的数据请求对象必须设置一个排序规则。在initWithFetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:方法中，如果设置第三个参数，则会以第三个参数为键值进行数据的分区。当数据发生变化时，将通过代理进行方法的回调。 三、与UITableView进行数据绑定12345678910111213141516171819-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cellid&quot;]; if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;cellid&quot;]; &#125; //获取相应数据模型 SchoolClass * obj = [_fecCon objectAtIndexPath:indexPath]; cell.textLabel.text = obj.name; cell.detailTextLabel.text = [NSString stringWithFormat:@&quot;有%@人&quot;,obj.stuNum]; return cell;&#125;-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return [_fecCon sections].count;&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; id&lt;NSFetchedResultsSectionInfo&gt; info = [_fecCon sections][section]; return [info numberOfObjects]; &#125; 效果如下： 四、将数据变化映射到视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//数据将要改变时调用的方法- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller&#123; //开启tableView更新预处理 [[self tableView] beginUpdates];&#125;//分区数据改变时调用的方法- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;NSFetchedResultsSectionInfo&gt;)sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type&#123; //判断行为类型 switch(type) &#123; //插入新分区 case NSFetchedResultsChangeInsert: [[self tableView] insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; //删除分区 case NSFetchedResultsChangeDelete: [[self tableView] deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; //移动分区 case NSFetchedResultsChangeMove: //更新分区 case NSFetchedResultsChangeUpdate: break; &#125;&#125;//数据改变时回调的代理- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath&#123; switch(type) &#123; //插入数据 case NSFetchedResultsChangeInsert: [[self tableView] insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade]; break; //删除数据 case NSFetchedResultsChangeDelete: [[self tableView] deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; break; //更新数据 case NSFetchedResultsChangeUpdate: [self reloadData]; break; //移动数据 case NSFetchedResultsChangeMove: [[self tableView] deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; [[self tableView] insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade]; break; &#125;&#125;//数据更新结束调用的代理- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller&#123; [[self tableView] endUpdates];&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列三——添加与查询数据","slug":"173iOS中CoreData数据管理系列三——添加与查询数据","date":"2016-01-28T16:00:00.000Z","updated":"2021-07-06T06:59:11.149Z","comments":true,"path":"2016/01/29/173iOS中CoreData数据管理系列三——添加与查询数据/","link":"","permalink":"http://huishao.cc/2016/01/29/173iOS中CoreData数据管理系列三——添加与查询数据/","excerpt":"","text":"iOS中CoreData数据管理系列三——添加与查询数据一、引言在前两篇博客中，分别介绍了iOS中CoreData框架创建数据模型和CoreData框架中的三个核心类。博客地址如下： iOS中CoreData框架简介：http://my.oschina.net/u/2340880/blog/610488。 CoreData框架中三个核心的类：http://my.oschina.net/u/2340880/blog/610948。 本篇博客将综合使用三个核心的类，进行数据创建和查询的操作介绍。 二、建立数据对象类前面博客介绍的NSManagedObjectModel是数据管理模型，可以将其类比如数据库，NSManagedObjectModel中存放着数据库的结构信息。NSEntityDescription是实体描述对象，它可以类比如数据库中的表，NSEntityDescription存放的是表的结构信息。这些类都是一些抽象的结构类，并不存储实际每条数据的信息，具体的数据由NSManagedObject类来描述，我们一般会将实体类化继承于NSManagedObject。 Xocde工具提供了快捷的实体类化功能，还拿我们一开始创建的班级与学生实体来演示，点击.xcdatamodeld文件，点击Xcode工具上方导航栏的Editor标签，选择Creat NSManagedObject Subclass选项，在弹出的窗口中勾选要类化的实体，如下图： 这时，Xcode会自动为我们创建一个文件，这些文件中有各个类中属性的声明。 三、创建一条数据使用如下代码进行数据的创建： 12345678910111213141516171819202122232425262728293031323334 //读取数据模型文件 NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; //创建数据模型 NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; //创建持久化存储协调者 NSPersistentStoreCoordinator * psc = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:mom]; //数据库保存路径 NSURL * path =[NSURL fileURLWithPath:[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]]; //为持久化协调者添加一个数据接收栈 /* 可以支持的类型如下： NSString * const NSSQLiteStoreType;//sqlite NSString * const NSXMLStoreType;//XML NSString * const NSBinaryStoreType;//二进制 NSString * const NSInMemoryStoreType;//内存 */ [psc addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:path options:nil error:nil]; //创建数据管理上下文 NSManagedObjectContext * moc = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType]; //关联持久化协调者 [moc setPersistentStoreCoordinator:psc]; //创建数据对象 /* 数据对象的创建是通过实体名获取到的 */ SchoolClass * modelS = [NSEntityDescription insertNewObjectForEntityForName:@&quot;SchoolClass&quot; inManagedObjectContext:moc]; //对数据进行设置 modelS.name = @&quot;第一班&quot;; modelS.stuNum = @60; //进行存储 if ([moc save:nil]) &#123; NSLog(@&quot;新增成功&quot;); &#125; NSLog(@&quot;%@&quot;,[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]); 找到在打印出的路径，会发现里面多了一个sqlite文件，其中有一张表中添加进了一条数据。 四、查询数据CoreData中通过查询请求来对数据进行查询操作，查询请求由NSFetchRequest来进行管理和维护。 NSFetchRequest主要提供两个方面的查询服务： 1.提供范围查询的相关功能 2.提供查询结果返回类型与排序的相关功能 NSFetchRequest中常用方法如下： 12345678910111213141516171819202122//创建一个实体的查询请求 可以理解为在某个表中进行查询+ (instancetype)fetchRequestWithEntityName:(NSString*)entityName;//查询条件@property (nullable, nonatomic, strong) NSPredicate *predicate;//数据排序@property (nullable, nonatomic, strong) NSArray&lt;NSSortDescriptor *&gt; *sortDescriptors;//每次查询返回的数据条数@property (nonatomic) NSUInteger fetchLimit;//设置查询到数据的返回类型/*typedef NS_OPTIONS(NSUInteger, NSFetchRequestResultType) &#123; NSManagedObjectResultType = 0x00, NSManagedObjectIDResultType = 0x01, NSDictionaryResultType NS_ENUM_AVAILABLE(10_6,3_0) = 0x02, NSCountResultType NS_ENUM_AVAILABLE(10_6,3_0) = 0x04&#125;;*/@property (nonatomic) NSFetchRequestResultType resultType;//设置查询结果是否包含子实体@property (nonatomic) BOOL includesSubentities;//设置要查询的属性值@property (nullable, nonatomic, copy) NSArray *propertiesToFetch; 在SchoolClass实体中查询数据，使用如下的代码： 1234567 //创建一条查询请求 NSFetchRequest * request = [NSFetchRequest fetchRequestWithEntityName:@&quot;SchoolClass&quot;]; //设置条件为 stuNum=60的数据 [request setPredicate:[NSPredicate predicateWithFormat:@&quot;stuNum == 60&quot;]]; //进行查询操作 NSArray * res = [moc executeFetchRequest:request error:nil]; NSLog(@&quot;%@&quot;,[res.firstObject stuNum]); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列二——CoreData框架中三个重要的类","slug":"172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类","date":"2016-01-27T16:00:00.000Z","updated":"2021-07-06T06:58:10.678Z","comments":true,"path":"2016/01/28/172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类/","link":"","permalink":"http://huishao.cc/2016/01/28/172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类/","excerpt":"","text":"iOS中CoreData数据管理系列二——CoreData框架中三个重要的类一、引言在上一篇博客中，介绍了iOS中使用CoreData框架设计数据模型的相关步骤。CoreData框架中通过相关的类将数据——数据模型——开发者无缝的衔接起来。NSManagedObjectModel对应数据模型，即上篇博客中我们创建的.xcdatamodeld文件；NSPersistentStoreCoordinator相当于数据库与数据模型之间的桥接器，通过NSPersistentStoreCoordinator将数据模型存入数据库；NSManagedObjectContext是核心的数据管理类，开发者通过操作它来执行对数据的相关操作。 二、数据模型管理类NSManagedObjectModel通过NSManagedObjectModel，可以将创建的数据模型文件读取为模型管理类对象，使用如下方法： 1234 //获取.xcdatamodeld文件url NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; //读取文件 NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; 其中还有一些属性和方法进行数据模型的管理： 123456789101112131415161718//将多个数据模型管理文件进行合并+ (nullable NSManagedObjectModel *)mergedModelFromBundles:(nullable NSArray&lt;NSBundle *&gt; *)bundles; //将多个数据模型管理类对象进行合并 + (nullable NSManagedObjectModel *)modelByMergingModels:(nullable NSArray&lt;NSManagedObjectModel *&gt; *)models;//存放数据中所有实体模型的字典 字典中是实体名和实体描述对象@property (readonly, copy) NSDictionary&lt;NSString *, NSEntityDescription *&gt; *entitiesByName;//存放数据中所有实体描述对象@property (strong) NSArray&lt;NSEntityDescription *&gt; *entities;//返回所有可用的配置名称@property (readonly, strong) NSArray&lt;NSString *&gt; *configurations;//获取关联某个配置的所有实体- (nullable NSArray&lt;NSEntityDescription *&gt; *)entitiesForConfiguration:(nullable NSString *)configuration;//为某个实体关联配置- (void)setEntities:(NSArray&lt;NSEntityDescription *&gt; *)entities forConfiguration:(NSString *)configuration;//创建请求模板- (void)setFetchRequestTemplate:(nullable NSFetchRequest *)fetchRequestTemplate forName:(NSString *)name;//获取请求模板- (nullable NSFetchRequest *)fetchRequestTemplateForName:(NSString *)name; 关于实体描述对象NSEntityDescription： 实体类似于数据库中的表结构，例如上次我们创建的班级实体模型，一个实体模型中可以添加许多属性与关系，NSEntityDescription对象中存放这些信息，常用如下： 1234567891011121314151617181920212223242526//实体所在的模型管理对象@property (readonly, assign) NSManagedObjectModel *managedObjectModel;//实体所在的模型管理对象的名称@property (null_resettable, copy) NSString *managedObjectClassName;//实体名@property (nullable, copy) NSString *name;//设置是否是抽象实体@property (getter=isAbstract) BOOL abstract;//子类实体字典@property (readonly, copy) NSDictionary&lt;NSString *, NSEntityDescription *&gt; *subentitiesByName;//所有子类实体对象数组@property (strong) NSArray&lt;NSEntityDescription *&gt; *subentities;//父类实体@property (nullable, readonly, assign) NSEntityDescription *superentity;//所有属性字典@property (readonly, copy) NSDictionary&lt;NSString *, __kindof NSPropertyDescription *&gt; *propertiesByName;//所有属性数组 @property (strong) NSArray&lt;__kindof NSPropertyDescription *&gt; *properties;//所有常类型属性@property (readonly, copy) NSDictionary&lt;NSString *, NSAttributeDescription *&gt; *attributesByName;//所有关系@property (readonly, copy) NSDictionary&lt;NSString *, NSRelationshipDescription *&gt; *relationshipsByName;//某个实体类型的所有关系- (NSArray&lt;NSRelationshipDescription *&gt; *)relationshipsWithDestinationEntity:(NSEntityDescription *)entity;//判断是否是某种实体- (BOOL)isKindOfEntity:(NSEntityDescription *)entity; NSPropertyDescription类是数据模型属性的父类，NSAttributeDescription和NSRelationshipDescription都是继承于NSPropertyDescription类，NSAttributeDescription描述正常类型的属性，NSRelationshipDescription用于描述自定义类型的关系。 三、持久化存储协调者类NSPersistentStoreCoordinatorNSPersistentStoreCoordinator建立数据模型与本地文件或数据库之间的联系，通过它将本地数据读入内存或者将修改过的临时数据进行持久化的保存。其初始化与链接数据持久化接收对象方法如下： 123456//通过数据模型管理对象进行初始化- (instancetype)initWithManagedObjectModel:(NSManagedObjectModel *)model；//添加一个持久化的数据接收对象- (nullable __kindof NSPersistentStore *)addPersistentStoreWithType:(NSString *)storeType configuration:(nullable NSString *)configuration URL:(nullable NSURL *)storeURL options:(nullable NSDictionary *)options error:(NSError **)error;//移除一个持久化的数据接收对象- (BOOL)removePersistentStore:(NSPersistentStore *)store error:(NSError **)error; 四、数据对象管理上下文NSManagedObjectContextNSManagedObjectContext是进行数据管理的核心类，我们通过这个类来进行数据的增删改查等操作。其中常用方法如下： 1234567891011121314151617181920212223242526272829303132//初始化方法 通过一个并发类型进行初始化 参数枚举如下：/*typedef NS_ENUM(NSUInteger, NSManagedObjectContextConcurrencyType) &#123; NSPrivateQueueConcurrencyType = 0x01,//上下文对象与私有队列关联 NSMainQueueConcurrencyType = 0x02//上下文对象与主队列关联&#125;;*/- (instancetype)initWithConcurrencyType:(NSManagedObjectContextConcurrencyType)ct;//异步执行block- (void)performBlock:(void (^)())block;//同步执行block- (void)performBlockAndWait:(void (^)())block;//关联数据持久化对象@property (nullable, strong) NSPersistentStoreCoordinator *persistentStoreCoordinator;//是否有未提交的更改@property (nonatomic, readonly) BOOL hasChanges;//进行查询数据请求- (nullable NSArray *)executeFetchRequest:(NSFetchRequest *)request error:(NSError **)error;//进行查询数据条数请求- (NSUInteger) countForFetchRequest: (NSFetchRequest *)request error: (NSError **)error ; //插入元素- (void)insertObject:(NSManagedObject *)object;//删除元素- (void)deleteObject:(NSManagedObject *)object;//回滚一步操作- (void)undo;//清楚缓存- (void)reset;//还原数据- (void)rollback;//提交保存数据- (BOOL)save:(NSError **)error; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列一——初识CoreData","slug":"171iOS中CoreData数据管理系列一——初识CoreData","date":"2016-01-26T16:00:00.000Z","updated":"2021-07-06T06:56:40.291Z","comments":true,"path":"2016/01/27/171iOS中CoreData数据管理系列一——初识CoreData/","link":"","permalink":"http://huishao.cc/2016/01/27/171iOS中CoreData数据管理系列一——初识CoreData/","excerpt":"","text":"iOS中CoreData数据管理系列一——初识CoreData一、何为CoreDataCoreData是一个专门用来管理数据的框架，其在性能与书写方便上都有很大的优势，在数据库管理方面，apple强烈推荐开发者使用CoreData框架，在apple的官方文档中称，使用CoreData框架可以减少开发者50%——70%的代码量，这虽然有些夸张，但由此可见，CoreData的确十分强大。 二、设计数据模型在iOS开发中，时常使用SQL数据库对大量的表结构数据进行处理，但是SQL有一个十分明显的缺陷，对于常规数据模型的表，其处理起来是没问题的，例如一个班级表，其中每条数据中有班级名称，人数这样的属性，一个学生表，其中每条数据有学生的姓名，性别，年龄这样的属性。但是如果要在表与表之间建立联系，自定义对象与自定义对象之间产生从属关系，使用SQL处理起来就十分麻烦了，例如如果这个班级表中有一个班长的属性，这个属性是一个学生类型。关于iOS中SQL的使用相关博客，地址如下： Sqlite数据库相关知识：http://my.oschina.net/u/2340880/blog/600820 iOS中sqlite3框架的使用和封装：http://my.oschina.net/u/2340880/blog/601802 CoreData的一大优势即是其可以方便的在对象之间建立关系。 1.创建实体类型及其属性使用Xcode创建一个工程，在工程中新建一个文件，选择Core Data分类中的DataModel创建，如下图： 这时在Xcode的文件导航区会出现一个以xcdatamodeld为扩展名的文件，这个文件就是数据模型文件，点击Add Entity按钮添加一个实体类型，取名为SchoolClass，为这个类型添加两个属性，分别为名字name和学生数量stuNum，如下图: 2.对实体类型进行设置在Xcode右侧的工具栏中可以对实体类型进行一些设置，选中一个实体类型，如下图： Name设置实体类型的名称，Abstract Entity设置是否是抽象实体，如果勾选，则此实体不能被实例化，只能被继承，类似于抽象类，比如定义人为一个实体类型，在定义继承于人实体类型的老师、学生等来进行实例化。Parent Entity用来选择父类实体，Class用于设置对应的类的。 3.在实体对象之间建立关系再创建一个学生类实体Student，添加name和age两个属性。选中SchoolClass，在其中的Relationships模块中点击+号，来添加一个关系，如下图： 这时，SchoolClass实体类型中就有了一个Student类型的班长属性。如果切换一下编辑风格，可以更加清晰的看到实体类型之间的关系，如下图： 4.对属性和关系进行设置选中一个属性或者关系，在右侧的工具栏中可以对属性进行一些设置，如下图： name设置属性的名字，Optional类型代表可选，即在实例化对象时可以赋值也可以不赋值。Attribute设置属性的数据类型，Default Value设置数据的默认值。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中播放gif动态图的方式探讨","slug":"170iOS中播放gif动态图的方式探讨","date":"2016-01-23T16:00:00.000Z","updated":"2021-07-06T06:48:41.373Z","comments":true,"path":"2016/01/24/170iOS中播放gif动态图的方式探讨/","link":"","permalink":"http://huishao.cc/2016/01/24/170iOS中播放gif动态图的方式探讨/","excerpt":"","text":"iOS中播放gif动态图的方式探讨一、引言在iOS开发中，UIImageView类专门来负责图片数据的渲染，并且UIImageView也有帧动画的方法来播放一组图片，但是对于gif类型的数据，UIImageView中并没有现成的接口提供给开发者使用，在iOS中一般可以通过两种方式来播放gif动态图，一种方式是通过ImageIO框架中的方法将gif文件中的数据进行解析，再使用coreAnimation核心动画来播放gif动画，另一种方式计较简单，可以直接通过webView来渲染gif图。 二、为原生的UIImageView添加类别来支持gif动态图的播放 gif动态图文件中包含了一组图片及其信息，信息主要记录着每一帧图片播放的时间，我们如果获取到了gif文件中所有的图片同时又获取到每一帧图片播放的时间，就可以为UIImageView添加核心动画的方法来让其播放gif的内容了。 首先解析gif文件中的数据，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//要引入ImageIO库#import &lt;ImageIO/ImageIO.h&gt;//解析gif文件数据的方法 block中会将解析的数据传递出来-(void)getGifImageWithUrk:(NSURL *)url returnData:(void(^)(NSArray&lt;UIImage *&gt; * imageArray, NSArray&lt;NSNumber *&gt;*timeArray, CGFloat totalTime, NSArray&lt;NSNumber *&gt;* widths, NSArray&lt;NSNumber *&gt;* heights))dataBlock&#123; //通过文件的url来将gif文件读取为图片数据引用 CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)url, NULL); //获取gif文件中图片的个数 size_t count = CGImageSourceGetCount(source); //定义一个变量记录gif播放一轮的时间 float allTime=0; //存放所有图片 NSMutableArray * imageArray = [[NSMutableArray alloc]init]; //存放每一帧播放的时间 NSMutableArray * timeArray = [[NSMutableArray alloc]init]; //存放每张图片的宽度 （一般在一个gif文件中，所有图片尺寸都会一样） NSMutableArray * widthArray = [[NSMutableArray alloc]init]; //存放每张图片的高度 NSMutableArray * heightArray = [[NSMutableArray alloc]init]; //遍历 for (size_t i=0; i&lt;count; i++) &#123; CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL); [imageArray addObject:(__bridge UIImage *)(image)]; CGImageRelease(image); //获取图片信息 NSDictionary * info = (__bridge NSDictionary*)CGImageSourceCopyPropertiesAtIndex(source, i, NULL); CGFloat width = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelWidth] floatValue]; CGFloat height = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelHeight] floatValue]; [widthArray addObject:[NSNumber numberWithFloat:width]]; [heightArray addObject:[NSNumber numberWithFloat:height]]; NSDictionary * timeDic = [info objectForKey:(__bridge NSString *)kCGImagePropertyGIFDictionary]; CGFloat time = [[timeDic objectForKey:(__bridge NSString *)kCGImagePropertyGIFDelayTime]floatValue]; allTime+=time; [timeArray addObject:[NSNumber numberWithFloat:time]]; CFRelease(info); &#125; CFRelease(source); dataBlock(imageArray,timeArray,allTime,widthArray,heightArray);&#125; 为UIImageView添加一个设置gif图内容的方法： 1234567891011121314151617181920212223-(void)yh_setImage:(NSURL *)imageUrl&#123; __weak id __self = self; [self getGifImageWithUrk:imageUrl returnData:^(NSArray&lt;UIImage *&gt; *imageArray, NSArray&lt;NSNumber *&gt; *timeArray, CGFloat totalTime, NSArray&lt;NSNumber *&gt; *widths, NSArray&lt;NSNumber *&gt; *heights) &#123; //添加帧动画 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;contents&quot;]; NSMutableArray * times = [[NSMutableArray alloc]init]; float currentTime = 0; //设置每一帧的时间占比 for (int i=0; i&lt;imageArray.count; i++) &#123; [times addObject:[NSNumber numberWithFloat:currentTime/totalTime]]; currentTime+=[timeArray[i] floatValue]; &#125; [animation setKeyTimes:times]; [animation setValues:imageArray]; [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]]; //设置循环 animation.repeatCount= MAXFLOAT; //设置播放总时长 animation.duration = totalTime; //Layer层添加 [[(UIImageView *)__self layer]addAnimation:animation forKey:@&quot;gifAnimation&quot;]; &#125;];&#125; 使用代码示例如下： 1234 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0,0 , 320, 200)]; NSURL * url = [[NSURL alloc]initFileURLWithPath:[[NSBundle mainBundle] pathForResource:imageName ofType:nil]]; [imageView yh_setImage:url]; [self.view addSubview:imageView]; 三、使用UIWebView来加载gif动态图数据iOS中的UIWebView功能十分强大，可以通过UIWebView为载体，来展示gif图。并且这种方法也十分简单，代码如下： 12345678910 //读取gif数据 NSData *gifData = [NSData dataWithContentsOfURL:imageUrl]; UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)]; //取消回弹效果 webView.scrollView.bounces=NO; webView.backgroundColor = [UIColor clearColor]; //设置缩放模式 webView.scalesPageToFit = YES; //用webView加载数据 [webView loadData:gifData MIMEType:@&quot;image/gif&quot; textEncodingName:nil baseURL:nil]; 四、两种加载gif动态图方式的优劣经过测试，从加载速度上来说，通过UIImageView类别加载的方式更加快速，UIWebView的方式加载时间会稍长，但是从性能上来比较，WebView的方式性能更优，播放的gif动态图更加流畅。在开发中，可以根据需求，适当选择，例如虽然WebView加载的方式性能更好，但是在许多情况下，原生的UIImageView能够更加自由的让开发者进行扩展。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"使用iOS原生sqlite3框架对sqlite数据库进行操作","slug":"169使用iOS原生sqlite3框架对sqlite数据库进行操作","date":"2016-01-12T16:00:00.000Z","updated":"2021-07-06T06:46:38.149Z","comments":true,"path":"2016/01/13/169使用iOS原生sqlite3框架对sqlite数据库进行操作/","link":"","permalink":"http://huishao.cc/2016/01/13/169使用iOS原生sqlite3框架对sqlite数据库进行操作/","excerpt":"","text":"使用iOS原生sqlite3框架对sqlite数据库进行操作一、引言sqlite数据库是一种小型数据库，由于其小巧与简洁，在移动开发领域应用深广，sqlite数据库有一套完备的sqlite语句进行管理操作，一些常用的语句和可视化的开发工具在上篇博客中有介绍，地址如下： sqlite数据库常用语句及可视化工具介绍：http://my.oschina.net/u/2340880/blog/600820。 在iOS的原生开发框架中可以对sqlite数据库进行很好的支持，这个框架中采用C风格且通过指针移动进行数据的操作，使用起来有些不便，我们可以对一些数据库的常用操作进行一些面向对象的封装。 二、libsqlite3系统库中操作数据库的常用方法libsqlite3是对sqlite数据库进行操作的系统库，在使用前，我们需要先导入，点击Xcode的Build Phases标签，展开Link Binary With Libraries，点击+号，在弹出的窗口中搜索libsqlite3.0，将其导入进工程，过程如下图： 在需要操作sqlite数据的文件中导入如下头文件： 1#import &lt;sqlite3.h&gt; 数据库文件的操作是由一个sqlite3类型的指针操作管理的，如下方法进行数据库的打开： 12sqlite3 *sqlite；sqlite3_open(dataBaePath, &amp;sqlite) sqlite3_open方法返回一个int值，实际上，在使用libsqlite3框架中的大多方法时都会返回一个int值，这个int值代表着方法执行的相应结果状态，这些状态再sqlite3.h文件中通过宏来定义，列举如下： 1234567891011121314151617181920212223242526272829303132#define SQLITE_OK 0 //操作成功/* 以下是错误代码 */#define SQLITE_ERROR 1 /* SQL数据库错误或者丢失*/#define SQLITE_INTERNAL 2 /* SQL内部逻辑错误 */#define SQLITE_PERM 3 /* 没有访问权限 */#define SQLITE_ABORT 4 /* 回调请求终止 */#define SQLITE_BUSY 5 /* 数据库文件被锁定 */#define SQLITE_LOCKED 6 /* 数据库中有表被锁定 */#define SQLITE_NOMEM 7 /* 分配空间失败 */#define SQLITE_READONLY 8 /* 企图向只读属性的数据库中做写操作 */#define SQLITE_INTERRUPT 9 /* 通过sqlite3_interrupt()方法终止操作*/#define SQLITE_IOERR 10 /* 磁盘发生错误 */#define SQLITE_CORRUPT 11 /* 数据库磁盘格式不正确 */#define SQLITE_NOTFOUND 12 /* 调用位置操作码 */#define SQLITE_FULL 13 /* 由于数据库已满造成的添加数据失败 */#define SQLITE_CANTOPEN 14 /* 不法打开数据库文件 */#define SQLITE_PROTOCOL 15 /* 数据库锁协议错误 */#define SQLITE_EMPTY 16 /* 数据库为空 */#define SQLITE_SCHEMA 17 /* 数据库模式更改 */#define SQLITE_TOOBIG 18 /* 字符或者二进制数据超出长度 */#define SQLITE_CONSTRAINT 19 /* 违反协议终止 */#define SQLITE_MISMATCH 20 /* 数据类型不匹配 */#define SQLITE_MISUSE 21 /* 库使用不当 */#define SQLITE_NOLFS 22 /* 使用不支持的操作系统 */#define SQLITE_AUTH 23 /* 授权拒绝 */#define SQLITE_FORMAT 24 /* 辅助数据库格式错误 */#define SQLITE_RANGE 25 /* sqlite3_bind 第二个参数超出范围 */#define SQLITE_NOTADB 26 /* 打开不是数据库的文件 */#define SQLITE_NOTICE 27 /* 来自sqlite3_log()的通知 */#define SQLITE_WARNING 28 /* 来自sqlite3_log() 的警告*/#define SQLITE_ROW 100 /* sqlite3_step() 方法准备好了一行数据 */#define SQLITE_DONE 101 /* sqlite3_step() 已完成执行*/ 执行非查询类的语句，例如创建，添加，删除等操作，使用如下方法： 123char * err;sqlite3 *sql;sqlite3_exec(sql, sqlStr, NULL, NULL, &amp;err); sqlite3_exec方法中第一个参数为成功执行了打开数据库操作的sqlite3指针，第二个参数为要执行的sql语句，最后一个参数为错误信息字符串。 执行查询语句的方法比较复杂，通过如下方法: 123456789 sqlite3 * sqlite; sqlite3_stmt *stmt =nil; int code = sqlite3_prepare_v2(sqlite, sqlStr, -1, &amp;stmt, NULL); while (sqlite3_step(stmt)==SQLITE_ROW) &#123; char * cString =(char*)sqlite3_column_text(stmt, 0); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; NSNumber * value = [NSNumber numberWithLongLong:sqlite3_column_int64(stmt, 1)]; &#125; sqlite3_finalize(stmt); stmt是一个数据位置指针，标记查询到数库的数据位置，sqlite3_prepare_v2()方法进行数据库查询的准备工作，第一个参数为成功打开的数据库指针，第二个参数为要执行的查询语句，第三个参数为sqlite3_stmt指针的地址，这个方法也会返回一个int值，作为标记状态是否成功。 sqlite3_step方法对stmt指针进行移动，会逐行进行移动，这个方法会返回一个int值，如果和SQLITE_ROW宏对应，则表明有此行数据，可以通过while循环来对数据进行读取。 sqlite3_column_XXX()是取行中每一列的数据，根据数据类型的不同，sqlite3_column_XXX()有一系列对应的方法，这个方法中第一个参数是stmt指针，第二个参数为列序号。 sqlite3_finalize()方法对stmt指针进行关闭。 三、面向对象的sqlite数据库操作框架封装网上不乏有许多优秀的第三方sqlite数据库使用框架，FFDM就是其中之一，并且apple自带的coreData也十分优秀。这篇博客中所述内容并不全面，代码也并不十分完善健壮，封装出来的代码除了能够完成基本的数据库操作外，更多主要是对设计思路的示例。 1.面向对象的sqlite管理类的设计思路为了便于使用，在设计时，我们尽量将libsqlite3中的方法不暴漏在使用层，通过面向应用的接口来进行方法的设计，设计思路类图如下： 图中，文件管理中心对文件进行存取删改管理，不暴漏在外，数据库管理中心负责对数据库的创建，删除打开等操作，具体的数据操作由数据库操作对象来完成。 2.文件管理中心方法的编写文件管理中心主要负责对数据库文件的存取，可以实现如下方法： YHBaseCecheCenter.h 12345678910111213141516/** * @brief 获取数据库方法的地址 * * @return 地址字符串 * */-(NSString *)getDataBaseFilePath;/** * @brief 获取某个数据库的大小 * * @param name 数据库名称 * * @return 文件大小 单位M * */-(float)getSizeFromDataBaseName:(NSString *)name; YHBaseCecheCenter.m 123456789101112131415-(NSString *)getDataBaseFilePath&#123; return NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;&#125;-(float)getSizeFromDataBaseName:(NSString *)name&#123; NSString * path = [NSString stringWithFormat:@&quot;/%@/%@&quot;,NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject,name]; return [self fileSizeAtPath:path]/(1024.0*1024.0);&#125;//获取文件大小- (long long) fileSizeAtPath:(NSString*) filePath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath])&#123; return [[manager attributesOfItemAtPath:filePath error:nil] fileSize]; &#125; return 0;&#125; 在iOS系统中因为其沙盒结构的限制，数据库必须方法documents目录下才能正常打开使用。 3.数据库管理中心的设计数据库管理中心主要负责对数据库的宏观操作，采用类方法的设计模式，如下 YHBaseSQLiteManager.h 123456789101112131415161718192021222324252627282930/** * @brief 打开一个数据库 如果不存在则会创建 * * @param name 数据库名称 * * @return 数据库操作对象 如果创建失败会返回nil * */+(YHBaseSQLiteContext *)openSQLiteWithName:(NSString *)name;/** * @brief 获取数据库文件的大小 单位M * * @param dataBase 数据库上下文对象 * * @return 数据库文件大小 */+(float)getSizeOfDataBase:(YHBaseSQLiteContext *)dataBase;/** * @brief 获取数据库文件的大小 单位M * * @param dataBaseName 数据库名称 * * @return 数据库文件大小 */+(float)getSizeOfDataBaseName:(NSString *)dataBaseName;/** * @brief 删除所有数据库 * */+(void)removeDataBase; YHBaseSQLiteManager.m 12345678910111213141516171819202122+(YHBaseSQLiteContext *)openSQLiteWithName:(NSString *)name&#123; NSString * path = [[YHBaseCecheCenter sharedTheSingletion]getDataBaseFilePath]; YHBaseSQLiteContext * context = [[YHBaseSQLiteContext alloc]init]; context.name = name; BOOL success = [context openDataBaeWithName:[NSString stringWithFormat:@&quot;%@/%@&quot;,path,name]]; if (success) &#123; return context; &#125;else&#123; return nil; &#125;&#125;+(float)getSizeOfDataBase:(YHBaseSQLiteContext *)dataBase&#123; return [[YHBaseCecheCenter sharedTheSingletion]getSizeFromDataBaseName:dataBase.name];&#125;+(float)getSizeOfDataBaseName:(NSString *)dataBaseName&#123; return [[YHBaseCecheCenter sharedTheSingletion]getSizeFromDataBaseName:dataBaseName];&#125;+(void)removeDataBase&#123; NSString * path = [[YHBaseCecheCenter sharedTheSingletion]getDataBaseFilePath]; return [[YHBaseCecheCenter sharedTheSingletion]removeCacheFromPath:path];&#125; 4.数据库操作对象将操作数据库的核心方法封装在这个类中： YHBaseSQLiteContext.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** *操作的数据库名称 */@property(nonatomic,strong)NSString * name;/** *内含sqlite3 对象 */@property(nonatomic,assign)sqlite3 * sqlite3_db;/** * @brief 打开一个数据库 不存在则创建 * * @param path 数据库路径 * * @return 是否操作成功 */-(BOOL)openDataBaeWithName:(NSString *)path;/** * @brief 再数据库中创建一张表 如果已经存在 会返回错误信息 * * @param name 表的名称 * * @prarm dic 表中的键 其中字典中需传入 键名：类型 类型的宏定义在YHBaseSQLTypeHeader.h中 * * @param callBack 结果回调 */-(void)createTableWithName:(NSString *)name keysDictionary:(NSDictionary&lt;NSString*,NSString*&gt; *) dic callBack:(void (^)(YHBaseSQLError * error))complete;/** * @brief 向表中添加一条数据 * * @param dataDic 添加数据的键值对 * * @param name 插入表的名称 * * @complete 回调 */-(void)insertData:(NSDictionary&lt;NSString *,id&gt;*)dataDic intoTable:(NSString *)name callBack:(void (^)(YHBaseSQLError * error))complete;/** * @brief 向表中添加一个键 * * @param kName 添加的键 * * @prarm type 类型 * * @prarm tableName 表名称 * * @prarm complete 结果回调 */-(void)addKey:(NSString *)kName keyType:(NSString *)type intoTable:(NSString *)tableName callBack:(void(^)(YHBaseSQLError *error))complete;/** * @brief 修改数据 * * @param dataDic 新的键值 * * @param wlStr 条件字符串 一般通过主键找到对应数据修改 可以为nil * * @param complete 结果回调 */-(void)update:(NSDictionary&lt;NSString*,id&gt; *)dataDic inTable:(NSString *)tableName whileString:(NSString *)wlStr callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 删除数据 * * @param tableName 表名 * * @param wlStr 条件字符串 一般通过主键找到对应数据删除 可以为nil 不传这个参数将删除所有数据 * */-(void)deleteDataFromTable:(NSString *)tableName whereString:(NSString *)wlStr callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 删除一张表 * * @param tableName 表名 * */-(void)dropTable:(NSString *)tableName callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 查询数据 * * @param keys 要查询的键值 及其对应的数据类型 可以为nil则查询全部 * * @param tableName 表名 * * @param orderKey 进行排序的键值 可以为nil 则不排序 * * @param type 排序方式 在YHBaseSQLTypeHeader中有宏定义 * * @param wlstr 查询条件 同于查询单个数据 * * @param complete dataArray为查询到的数据 其内为字典 * */-(void)selectKeys:(NSArray&lt;NSDictionary *&gt; *)keys fromTable:(NSString*)tableName orderBy:(NSString *)orderKey orderType:(NSString *)type whileStr:(NSString *)wlstr callBack:(void(^)(NSArray&lt;NSDictionary *&gt; * dataArray,YHBaseSQLError * error))complete;/** * @brief 关闭数据库上下文操作 * 调用此方法后 这个context对象将不再有效 如果再需要使用 需要YHBaseSQLiteManager中的类方法再次返回 */-(void)closeContext; YHBaseSQLiteContext.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262-(BOOL)openDataBaeWithName:(NSString *)path&#123; if (sqlite3_open([path UTF8String], &amp;_sqlite3_db)!=SQLITE_OK) &#123; sqlite3_close(_sqlite3_db); _sqlite3_db=nil; return NO; &#125;else&#123; return YES; &#125;&#125;-(void)createTableWithName:(NSString *)name keysDictionary:(NSDictionary&lt;NSString *,NSString *&gt; *)dic callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * keys = [[NSMutableString alloc]init]; for (int i=0; i&lt;dic.allKeys.count; i++) &#123; NSString * key = dic.allKeys[i]; if (i&lt;dic.allKeys.count-1) &#123; [keys appendFormat:@&quot;%@ %@,&quot;,key,[dic objectForKey:key]]; &#125;else&#123; [keys appendFormat:@&quot;%@ %@&quot;,key,[dic objectForKey:key]]; &#125; &#125; NSString * sqlStr = [NSString stringWithFormat:@&quot;create table %@(%@)&quot;,name,keys]; [self runSQL:sqlStr callBack:^(YHBaseSQLError * error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)insertData:(NSDictionary&lt;NSString *,id&gt; *)dataDic intoTable:(NSString *)name callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * keys = [[NSMutableString alloc]init]; NSMutableString * values = [[NSMutableString alloc]init]; for (int i=0; i&lt;dataDic.allKeys.count; i++) &#123; NSString * key = dataDic.allKeys[i]; if (i&lt;dataDic.count-1) &#123; [keys appendFormat:@&quot;%@,&quot;,key]; [values appendFormat:@&quot;\\&quot;%@\\&quot;,&quot;,[dataDic objectForKey:key]]; &#125;else&#123; [keys appendFormat:@&quot;%@&quot;,key]; [values appendFormat:@&quot;\\&quot;%@\\&quot;&quot;,[dataDic objectForKey:key]]; &#125; &#125; NSString * sqlStr = [NSString stringWithFormat:@&quot;insert into %@(%@) values(%@)&quot;,name,keys,values]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)addKey:(NSString *)kName keyType:(NSString *)type intoTable:(NSString *)tableName callBack:(void (^)(YHBaseSQLError *))complete&#123; NSString * sqlStr = [NSString stringWithFormat:@&quot;alter table %@ add %@ %@&quot;,tableName,kName,type]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)update:(NSDictionary&lt;NSString *,id&gt; *)dataDic inTable:(NSString *)tableName whileString:(NSString *)wlStr callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;update %@ set &quot;,tableName]; for (int i=0; i&lt;dataDic.allKeys.count; i++) &#123; NSString * key = dataDic.allKeys[i]; if (i&lt;dataDic.allKeys.count-1) &#123; [sqlStr appendFormat:@&quot;%@=\\&quot;%@\\&quot;,&quot;,key,[dataDic objectForKey:key]]; &#125;else&#123; [sqlStr appendFormat:@&quot;%@=\\&quot;%@\\&quot;&quot;,key,[dataDic objectForKey:key]]; if (wlStr!=nil) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlStr]; &#125; &#125; &#125; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)deleteDataFromTable:(NSString *)tableName whereString:(NSString *)wlStr callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;delete from %@&quot;,tableName]; if (wlStr!=nil) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlStr]; &#125; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)dropTable:(NSString *)tableName callBack:(void (^)(YHBaseSQLError *))complete&#123; NSString * sqlStr = [NSString stringWithFormat:@&quot;drop table %@&quot;,tableName]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)selectKeys:(NSArray&lt;NSDictionary *&gt; *)keys fromTable:(NSString *)tableName orderBy:(NSString *)orderKey orderType:(NSString *)type whileStr:(NSString *)wlstr callBack:(void (^)(NSArray&lt;NSDictionary *&gt; *, YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;select&quot;]; if (keys==nil||keys.count==0) &#123; [sqlStr appendFormat:@&quot; * from %@&quot;,tableName]; &#125;else&#123; for (int i=0; i&lt;keys.count; i++) &#123; if (i&lt;keys.count-1) &#123; [sqlStr appendFormat:@&quot; %@,&quot;,keys[i].allKeys.firstObject]; &#125;else&#123; [sqlStr appendFormat:@&quot; %@ from %@&quot;,keys[i].allKeys.firstObject,tableName]; &#125; &#125; &#125; if (wlstr) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlstr]; &#125; if (orderKey) &#123; [sqlStr appendFormat:@&quot; order by %@&quot;,orderKey]; &#125; if (type) &#123; [sqlStr appendFormat:@&quot; %@&quot;,type]; &#125; NSMutableArray * keysArr = [[NSMutableArray alloc]init]; NSMutableArray * keysTypeArr = [[NSMutableArray alloc]init]; if (keys==nil||keys.count==0) &#123; NSArray&lt;NSDictionary *&gt; * tmpArr = [self getTheTableAllKeys:tableName]; for (int i=0; i&lt;tmpArr.count; i++) &#123; NSString * key = tmpArr[i].allKeys.firstObject; [keysArr addObject:key]; [keysTypeArr addObject:[tmpArr[i] objectForKey:key]]; &#125; &#125;else&#123; for (int i=0; i&lt;keys.count; i++) &#123; NSString * key = keys[i].allKeys.firstObject; [keysArr addObject:key]; [keysTypeArr addObject:[keys[i] objectForKey:key]]; &#125; &#125; [self runSelectSQL:sqlStr withKeys:keysArr withDataType:keysTypeArr callBack:^(NSArray&lt;NSDictionary *&gt; *dataArray, YHBaseSQLError *error) &#123; if (complete) &#123; complete(dataArray,error); &#125; &#125;]; &#125;-(void)closeContext&#123; sqlite3_close(_sqlite3_db); _sqlite3_db = nil;&#125;//内部方法 运行创建独立的非查询SQL语句-(void)runSQL:(NSString *)sql callBack:(void(^)(YHBaseSQLError * error))complete&#123; char * err; int code = sqlite3_exec(_sqlite3_db, [sql UTF8String], NULL, NULL, &amp;err); if (code!=SQLITE_OK) &#123; YHBaseSQLError * error = [[YHBaseSQLError alloc]init]; error.errorInfo = [NSString stringWithCString:err encoding:NSUTF8StringEncoding]; error.errorCode = code; complete(error); &#125;else&#123; complete(nil); &#125;&#125;//运行查询语句-(void)runSelectSQL:(NSString *)sql withKeys:(NSArray *)keys withDataType:(NSArray *)dataType callBack:(void(^)(NSArray&lt;NSDictionary *&gt; * dataArray, YHBaseSQLError * error))complete&#123; sqlite3_stmt *stmt =nil; int code = sqlite3_prepare_v2(_sqlite3_db, [sql UTF8String], -1, &amp;stmt, NULL); if (code!=SQLITE_OK) &#123; YHBaseSQLError * error = [[YHBaseSQLError alloc]init]; error.errorInfo = @&quot;查询失败&quot;; error.errorCode=code; complete(nil,error); &#125;else&#123; NSMutableArray * resultArray = [[NSMutableArray alloc]init]; while (sqlite3_step(stmt)==SQLITE_ROW) &#123; //数据类型的分别解析 NSMutableDictionary * dic = [[NSMutableDictionary alloc]init]; for (int i=0; i&lt;dataType.count; i++) &#123; NSString * type = dataType[i]; if ([type isEqualToString:YHBASE_SQL_DATATYPE_BINARY]) &#123; int length = sqlite3_column_bytes(stmt, i); const void *data = sqlite3_column_blob(stmt, i); NSData * value = [NSData dataWithBytes:data length:length]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_BLOB])&#123; int length = sqlite3_column_bytes(stmt, i); const void *data = sqlite3_column_blob(stmt, i); NSData * value = [NSData dataWithBytes:data length:length]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_BOOLEAN])&#123; NSNumber * value = [NSNumber numberWithInt:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_CURRENCY])&#123; NSNumber * value = [NSNumber numberWithLong:sqlite3_column_int64(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_DATE])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_DOUBLE])&#123; NSNumber * value = [NSNumber numberWithFloat:sqlite3_column_double(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_FLOAT])&#123; NSNumber * value = [NSNumber numberWithFloat:sqlite3_column_double(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_INTRGER])&#123; NSNumber * value = [NSNumber numberWithInt:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_REAL])&#123; NSNumber * value = [NSNumber numberWithDouble:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_SMALLINT])&#123; NSNumber * value = [NSNumber numberWithShort:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TEXT])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TIME])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TIMESTAMP])&#123; NSNumber * value = [NSNumber numberWithLongLong:sqlite3_column_int64(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_VARCHAR])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125; &#125; [resultArray addObject:dic]; &#125; sqlite3_finalize(stmt); stmt=nil; complete(resultArray,nil); &#125;&#125;//获取表中所有字段名和类型-(NSArray&lt;NSDictionary *&gt; *)getTheTableAllKeys:(NSString *)tableName&#123; NSMutableArray * array = [[NSMutableArray alloc]init]; NSString * getColumn = [NSString stringWithFormat:@&quot;PRAGMA table_info(%@)&quot;,tableName]; sqlite3_stmt *statement; sqlite3_prepare_v2(_sqlite3_db, [getColumn UTF8String], -1, &amp;statement, nil); while (sqlite3_step(statement) == SQLITE_ROW) &#123; char *nameData = (char *)sqlite3_column_text(statement, 1); NSString *columnName = [[NSString alloc] initWithUTF8String:nameData]; char *typeData = (char *)sqlite3_column_text(statement, 2); NSString *columntype = [NSString stringWithCString:typeData encoding:NSUTF8StringEncoding]; NSDictionary * dic = @&#123;columnName:columntype&#125;; [array addObject:dic]; &#125; sqlite3_finalize(statement); statement=nil; return array;&#125; 5.错误信息类可以将数据库操作中的异常抛出提示开发者YHBaseSQLError.h 12345678/** *异常的提示信息 */__PROPERTY_NO_STRONG__(NSString *, errorInfo);/** *异常的对应code码 */__PROPERTY_NO_ASSIGN__(NSInteger, errorCode); 还有一个头文件中定义了sqlite数据库支持的数据类型和排序宏定义： YHBaseSQLTypeHeader.h 1234567891011121314151617#define YHBASE_SQL_DATATYPE_SMALLINT @&quot;smallint&quot; //short#define YHBASE_SQL_DATATYPE_INTRGER @&quot;integer&quot; //int#define YHBASE_SQL_DATATYPE_REAL @&quot;real&quot; //实数#define YHBASE_SQL_DATATYPE_FLOAT @&quot;float&quot; //float#define YHBASE_SQL_DATATYPE_DOUBLE @&quot;double&quot; //double#define YHBASE_SQL_DATATYPE_CURRENCY @&quot;currency&quot; //long#define YHBASE_SQL_DATATYPE_VARCHAR @&quot;varchar&quot; //char#define YHBASE_SQL_DATATYPE_TEXT @&quot;text&quot; //string#define YHBASE_SQL_DATATYPE_BINARY @&quot;binary&quot; //二进制#define YHBASE_SQL_DATATYPE_BLOB @&quot;blob&quot; //长二进制#define YHBASE_SQL_DATATYPE_BOOLEAN @&quot;boolean&quot; //bool#define YHBASE_SQL_DATATYPE_DATE @&quot;date&quot; //日期#define YHBASE_SQL_DATATYPE_TIME @&quot;time&quot; //时间#define YHBASE_SQL_DATATYPE_TIMESTAMP @&quot;timestamp&quot;//时间戳#define YHBASE_SQL_ORDERTYPE_ASC @&quot;asc&quot; //升序#define YHBASE_SQL_ORDERTYPE_DESC @&quot;desc&quot; //降序 四、使用在使用时，直接调用context的相应方法操作数据库即可，例如： 12345678YHBaseSQLiteContext * context = [YHBaseSQLiteManager openSQLiteWithName:@&quot;testDataBase&quot;]; if (context) &#123; [context selectKeys:nil fromTable:@&quot;MySQL&quot; orderBy:@&quot;age&quot; orderType:YHBASE_SQL_ORDERTYPE_DESC whileStr:@&quot;age&gt;18&quot; callBack:^(NSArray&lt;NSDictionary *&gt; *dataArray, YHBaseSQLError *error) &#123; NSLog(@&quot;%@&quot;,dataArray); NSLog(@&quot;%@&quot;,error.errorInfo); [context closeContext]; &#125;]; &#125; 上面的代码将查询textDataBase数据库中MySQL表里所有age列大于18的数据，并按照age从小到大进行排序，数据结果在回调的dataArray中。 外：完整的代码在下面的git地址中，这个git项目是一个基础的开发框架，里面封装了许多开发和调试常用功能，代码不完善之处，希望多多交流，QQ316045346. git：https://github.com/ZYHshao/YHBaseFoundationTest。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用","slug":"168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用","date":"2016-01-10T16:00:00.000Z","updated":"2021-07-06T06:45:24.955Z","comments":true,"path":"2016/01/11/168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用/","link":"","permalink":"http://huishao.cc/2016/01/11/168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用/","excerpt":"","text":"SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用一、引言在移动开发中，通常会用到一些小型的数据库进行数据管理。SQLite是一款十分小巧便捷的数据库，在iOS开发中，原生框架也对其有很好的支持。 二、SQLite常用语句数据库存在的意义就在于其对数据的整合和管理，所以数据库的核心操作无非是对数据进行增，删，改，查得操作。 1.建立数据表语句一个数据库文件中可以由一些表组成，通过下面的语句在数据库文件中创建一张表： 1create table class(num integer PRIMARY KEY,name text NOT NULL DEFAULT &quot;1班&quot;,count integer CHECK(count&gt;10)) 上面的语句代码可以简化成如下的格式： create table 表名(参数名1 类型 修饰条件，参数名2，类型 修饰参数，···) sqlite中支持如下的类型： smallint 短整型 integer 整型 real 实数型 float 单精度浮点 double 双精度浮点 currency 长整型 varchar 字符型 text 字符串 binary 二进制数据 blob 二进制大对象 boolean 布尔类型 date 日期类型 time 时间类型 timestamp 时间戳类型 关于修饰条件，常用的有如下几种： PRIMARY KEY：将本参数这个为主键，主键的值必须唯一，可以作为数据的索引，例如编号。 NOT NULL ：标记本参数为非空属性。 UNIQUE：标记本参数的键值唯一，类似主键。 DEFAULT:设置本参数的默认值 CHECK：参数检查条件，例如上面代码，写入数据是count必须大于时才有效。 2.添加数据使用下面的语句来进行数据行的添加操作： 1insert into class(num,name,count) values(2,&quot;三年2班&quot;,58) 上面的语句代码可以简化成如下格式： insert into 表名(键1，键2，···) values(值1，值2，···) 使用下面的语句进行数据列的添加，即添加一个新的键： 1alter table class add new text alter table 表名 add 键名 键类型 3.修改数据使用如下语句来进行改操作： 1update class set num=3,name=&quot;新的班级&quot; where num=1 update 表名 set 键1=值1，键2=值2 where 条件 where后面添加修改数据的条件，例如上面代码修改num为1的班级的名字和mun值。 4.删除数据1delete from class where num=1 delete from 表名 where 条件 上面代码删除num为1的一条数据。 删除一张表适用下面的语句： 1drop table class drop table 表名 5.查询操作查询操作是数据库的核心功能，sqlite的许多查询命令可以快捷的完成复杂的查询功能。 查询表中某些键值： 1select num from class select 键名，键名··· from 表名 查询全部键值数据： 1select * from class select * from 表名 *是一个全通配符，代表不限个数任意字符 查询排序： 1select * from class order by count asc select 键名，键名，··· from 表名 order by 键名 排序方式 order by 后面写要进行排序的键名，排序方式有 asc升序 desc降序 查找数据条数与查找位置限制： 1select * from class limit 2 offset 0 select 键名 from 表名 limit 最大条数 offset 查询起始位置 条件查询： 1select * from class where num&gt;2 select 键名 from 表名 where 条件 查询数据条数： 1select count(*) from class select count(键名) from 表名 去重查询： 1select distinct num from class select distinct 键名 from 表名 三、MesaSQLite的简单使用MesaSQLite是一款可视化的SQLite数据库编辑软件，使用十分方便。如下地址是下载链接：[http://pan.baidu.com/s/1sjW6DC5](http://pan.baidu.com/s/1sjW6DC5)。 1.创建数据库文件打开MesaSQLite软件，在导航栏中选择File，选择弹出菜单中的New DataBase创建一个新的数据库文件，也可以选择Open Database打开一个数据库。 注意：默认创建的数据库文件为rdb格式，手动改成db格式即可。 2.创建表MesaSQLite有两种方式对数据库进行操作，一种是通过sql语句，一种是通过可视化的界面。在SQL Query工具窗口中，可以通过SQL语句对数据库进行操作，如下图： 或者在Structure工具窗口中进行可视化的创建： 3.查询操作对于数据的查询操作，同样可以通过SQL Query工具通过语句进行查询或者在Content窗口中填写查询条件进行查询，如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展","slug":"167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展","date":"2015-12-22T16:00:00.000Z","updated":"2021-07-06T06:44:22.553Z","comments":true,"path":"2015/12/23/167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展/","link":"","permalink":"http://huishao.cc/2015/12/23/167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展/","excerpt":"","text":"iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展一、引言iOS系统是一个十分注重用户体验的系统，在iOS系统中，用户交互的方案也十分多，然而要在label中的某部分字体中添加交互行为确实不容易的，如果使用其他类似Button的控件来模拟，文字的排版又将是一个解决十分困难的问题。这个问题的由来是项目中的一个界面中有一些广告位标签，而这些广告位的标签却是嵌在文本中的，当用户点击文字标签的位置时，会跳转到响应的广告页。 CoreText框架和一些第三方库可以解决这个问题，但直接使用CoreText十分复杂，第三方库多注重于富文本的排版，对类似文字超链接的支持亦不是特别简洁，我们可以借助一些第三方的东西进行针对性更强，更易用的封装。 RCLabel是一个第三方的将html字符串进行文本布局的工具，代码十分轻巧，并且其是基于CoreText框架的，其原生性和扩展性十分强。在以前的一篇博客中，我将RCLabel进行了一些改进，使其支持异步加载远程图片，并且提供了更加简洁的面向应用的方法，博客地址如下： 扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计:http://my.oschina.net/u/2340880/blog/499311 。 本篇博文，将在其基础上，完成设计一个可以支持文本超链接的文字视图。 二、视图类与模型类的设计RCLabel的核心之处在于将HTML文本转换为富文本布局视图，因此我们可以将要显示的文本编程html字符串，将其可以进行用户交互的部分进行html超链接关联，RCLabel就检测到我们点击的区域进行响应逻辑的回调。设计类如下： .h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243//文本与超链接地址关联的model类 后面会说@class YHBaseLinkingLabelModel;@protocol YHBaseLinkingLabelProtocol &lt;NSObject&gt;@optional/** *点击超链接后出发的代理方法 model中有链接地址和文字 */-(void)YHBaseLinkingLabelClickLinking:(YHBaseLinkingLabelModel *)model;/** *尺寸改变后出发的方法 */-(void)YHBaseLinkingLabelSizeChange:(CGSize)size;@end@interface YHBaseLinkingLabel : YHBaseView/** *文字数组 里面存放这文字对应的超链接对象 */@property(nonatomic,strong)NSArray&lt;YHBaseLinkingLabelModel *&gt; * textArray;@property(nonatomic,weak)id&lt;YHBaseLinkingLabelProtocol&gt;delegate;/** *设置文字颜色 */@property(nonatomic,strong)UIColor * textColor;/** *设置超链接文字颜色 */@property(nonatomic,strong)UIColor * linkColor;/** *设置字体大小 */@property(nonatomic,assign)NSUInteger fontSize;/** *设置超链接字体大小 */@property(nonatomic,assign)int linkingFontSize;/** *设置是否显示下划线 */@property(nonatomic,assign)BOOL isShowUnderLine;@end .m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124@interface YHBaseLinkingLabel()&lt;YHBaseHtmlViewProcotop&gt;@end@implementation YHBaseLinkingLabel&#123; //以前博客中 封装的显示HTML字符串富文本的视图 YHBaseHtmlView * _label;&#125;/*// 重载一些初始化方法- (instancetype)init&#123; self = [super init]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super initWithCoder:coder]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;//设置文本数组-(void)setTextArray:(NSArray&lt;YHBaseLinkingLabelModel *&gt; *)textArray&#123; _textArray = textArray; //进行html转换 NSString * htmlString = [self transLinkingDataToHtmlStr:textArray]; //进行布局 [_label reSetHtmlStr:htmlString]; &#125;-(void)setTextColor:(UIColor *)textColor&#123; _textColor = textColor; _label.fontColor = textColor;&#125;-(void)setLinkColor:(UIColor *)linkColor&#123; _linkColor = linkColor; _label.linkingColor = linkColor;&#125;-(void)setFontSize:(NSUInteger)fontSize&#123; _fontSize = fontSize; [_label setFontSize:(int)fontSize];&#125;-(void)setLinkingFontSize:(int)linkingFontSize&#123; _linkingFontSize = linkingFontSize; [_label setLinkingSize:linkingFontSize];&#125;-(void)setIsShowUnderLine:(BOOL)isShowUnderLine&#123; _isShowUnderLine = isShowUnderLine; [_label setShowUnderLine:isShowUnderLine];&#125;-(NSString *)transLinkingDataToHtmlStr:(NSArray&lt;YHBaseLinkingLabelModel *&gt; *)data&#123; NSMutableString * mutStr = [[NSMutableString alloc]init]; for (int i=0; i&lt;data.count; i++) &#123; //这个model中存放的是超链接部分的文字和对应的url YHBaseLinkingLabelModel * model = data[i]; if (!model.linking) &#123; [mutStr appendString:model.text]; &#125;else &#123; [mutStr appendString:@&quot;&lt;a href=&quot;]; [mutStr appendString:model.linking]; [mutStr appendString:@&quot;&gt;&quot;]; [mutStr appendString:model.text]; [mutStr appendString:@&quot;&lt;/a&gt;&quot;]; &#125; &#125; return mutStr;&#125;#pragma mark delegate//点击的回调-(void)YHBaseHtmlView:(YHBaseHtmlView *)htmlView ClickLink:(NSString *)url&#123; for (YHBaseLinkingLabelModel * model in _textArray) &#123; if ([model.linking isEqualToString:url]) &#123; if ([self.delegate respondsToSelector:@selector(YHBaseLinkingLabelClickLinking:)]) &#123; [self.delegate YHBaseLinkingLabelClickLinking:model]; return; &#125; &#125; &#125;&#125;//布局尺寸改变的回调-(void)YHBaseHtmlView:(YHBaseHtmlView *)htmlView SizeChanged:(CGSize)size&#123; if ([self.delegate respondsToSelector:@selector(YHBaseLinkingLabelSizeChange:)]) &#123; [self.delegate YHBaseLinkingLabelSizeChange:size]; &#125;&#125;@end 上面我们有用到一个YHBaseLinkingLabelModel类，这个类进行了链接与字符的映射，设计如下： 1234567891011@interface YHBaseLinkingLabelModel : YHBaseModel/** *文字内容 */@property(nonatomic,strong)NSString * text;/** *超链接地址 nil则为无 */@property(nonatomic,strong)NSString * linking;@end YHBaseHtmlView类是对RCLabel的一层封装，其中也对RCLabel进行了一些优化和改动，代码较多且在上篇博客中有介绍，这里不再多做解释了。 在ViewController中写如下代码进行使用： 12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. YHBaseLinkingLabel * label = [[YHBaseLinkingLabel alloc]initWithFrame:CGRectMake(100, 100, 200, 100)]; NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i=0; i&lt;6; i++) &#123; YHBaseLinkingLabelModel * model = [[YHBaseLinkingLabelModel alloc]init]; if (!(i%2)) &#123; model.text =[NSString stringWithFormat:@&quot;第%d个标签&quot;,i]; model.linking = [NSString stringWithFormat:@&quot;第%d个标签&quot;,i]; &#125;else&#123; model.text = @&quot;,不能点得文字,&quot;; &#125; [array addObject:model]; &#125; label.textColor = [UIColor blackColor]; label.linkColor = [UIColor purpleColor]; label.fontSize = 15; label.linkingFontSize = 17; label.isShowUnderLine=YES; label.delegate=self; label.textArray = array; [self.view addSubview:label]; &#125;-(void)YHBaseLinkingLabelClickLinking:(YHBaseLinkingLabelModel *)model&#123; NSLog(@&quot;%@&quot;,model.linking);&#125; 运行效果如下： 效果不错，并且十分简单易用，对吧。 我将这部分的相关代码集成进了以前写的一个项目开发框架中，git地址是：[https://github.com/ZYHshao/YHBaseFoundationTest](https://github.com/ZYHshao/YHBaseFoundationTest) 。总体看来，这个框架并不是干货，只是我开发中的一些积累，如果可以帮到你，择优而用，如果需要和我交流，QQ316045346，对视欢迎。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS开发之蓝牙通讯","slug":"166iOS开发之蓝牙通讯","date":"2015-12-19T16:00:00.000Z","updated":"2021-07-05T11:02:50.896Z","comments":true,"path":"2015/12/20/166iOS开发之蓝牙通讯/","link":"","permalink":"http://huishao.cc/2015/12/20/166iOS开发之蓝牙通讯/","excerpt":"","text":"iOS开发之蓝牙通讯一、引言蓝牙是设备近距离通信的一种方便手段，在iPhone引入蓝牙4.0后，设备之间的通讯变得更加简单。相关的蓝牙操作由专门的CoreBluetooth.framework进行统一管理。通过蓝牙进行通讯交互分为两方，一方为中心设备central，一方为外设peripheral，外设通过广播的方式向外发送信息，中心设备检索到外设发的广播信息，可以进行配对连接，进而进行数据交互。 二、中心设备CBCentralManagerCBCentralManager是管理中心设备的管理类，其中重要方法如下： 123456//设置中心设备代理@property(assign, nonatomic, nullable) id&lt;CBCentralManagerDelegate&gt; delegate;//中心设备当前状态@property(readonly) CBCentralManagerState state;//中心设备是否正在扫描@property(readonly) BOOL isScanning NS_AVAILABLE(NA, 9_0); 其中state是一个枚举，有关蓝牙是否可用的状态如下： 1234567891011121314typedef NS_ENUM(NSInteger, CBCentralManagerState) &#123; //状态未知 CBCentralManagerStateUnknown = 0, //连接断开 即将重置 CBCentralManagerStateResetting, //该平台不支持蓝牙 CBCentralManagerStateUnsupported, //未授权蓝牙使用 CBCentralManagerStateUnauthorized, //蓝牙关闭 CBCentralManagerStatePoweredOff, //蓝牙正常开启 CBCentralManagerStatePoweredOn,&#125;; 下面这些方法用于初始化管理中心： 1234567891011121314//初始化方法//设置的代理需要遵守CBCentralManagerDelegate协议//queue可以设置蓝牙扫描的线程 传入nil则为在主线程中进行- (instancetype)initWithDelegate:(nullable id&lt;CBCentralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue;//此方法同上 在options字典中用于进行一些管理中心的初始化属性设置//字典中支持的键值如下/*NSString * const CBCentralManagerOptionShowPowerAlertKey 对应一个NSNumber类型的bool值，用于设置是否在关闭蓝牙时弹出用户提示NSString * const CBCentralManagerOptionRestoreIdentifierKey 对应一个NSString对象，设置管理中心的标识符ID*/- (instancetype)initWithDelegate:(nullable id&lt;CBCentralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 1234//根据获取所有已知设备- (NSArray&lt;CBPeripheral *&gt; *)retrievePeripheralsWithIdentifiers:(NSArray&lt;NSUUID *&gt; *)identifiers;//根据服务id获取所有连接的设备- (NSArray&lt;CBPeripheral *&gt; *)retrieveConnectedPeripheralsWithServices:(NSArray&lt;CBUUID *&gt; *)serviceUUIDs; 在初始化管理中心完成后，会回调代理中的如下方法，我们必须实现如下方法： 12//这个方法中可以获取到管理中心的状态- (void)centralManagerDidUpdateState:(CBCentralManager *)central; 如果上面方法中管理中心状态为蓝牙可用，可以通过下面方法开启扫描外设： 12345678//serviceUUIDs用于扫描一个特点ID的外设 options用于设置一些扫描属性 键值如下/*//是否允许重复扫描 对应NSNumber的bool值，默认为NO，会自动去重NSString *const CBCentralManagerScanOptionAllowDuplicatesKey;//要扫描的设备UUID 数组 对应NSArrayNSString *const CBCentralManagerScanOptionSolicitedServiceUUIDsKey;*/- (void)scanForPeripheralsWithServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 12//停止扫描外设- (void)stopScan; 扫描的结果会在如下代理方法中回掉： 1234//peripheral 扫描到的外设//advertisementData是外设发送的广播数据//RSSI 是信号强度- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI; 扫描到外设后，通过下面方法可以连接一个外设： 123456789101112/*options中可以设置一些连接设备的初始属性键值如下//对应NSNumber的bool值，设置当外设连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnConnectionKey;//对应NSNumber的bool值，设置当外设断开连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnDisconnectionKey;//对应NSNumber的bool值，设置当外设暂停连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnNotificationKey;*/- (void)connectPeripheral:(CBPeripheral *)peripheral options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;//取消一个外设的连接- (void)cancelPeripheralConnection:(CBPeripheral *)peripheral; 调用过连接外设的方法后，会回掉如下代理方法： 123456//连接外设成功- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral;//连接外设失败- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error;//断开外设连接- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error; 当管理中心恢复时会调用如下代理： 12345678910//dict中会传入如下键值对/*//恢复连接的外设数组NSString *const CBCentralManagerRestoredStatePeripheralsKey;//恢复连接的服务UUID数组NSString *const CBCentralManagerRestoredStateScanServicesKey;//恢复连接的外设扫描属性字典数组NSString *const CBCentralManagerRestoredStateScanOptionsKey;*/- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict; 三、外设CBPeripheralManager从上面我们知道，中心设备是用来扫描周围的外设，两台设备的通讯中，必须有一个充当中心设备，一个充当外设，外设是由CBPeripheralManager进行管理，主要方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//设置外设管理中心代理@property(assign, nonatomic, nullable) id&lt;CBPeripheralManagerDelegate&gt; delegate;//外设状态 枚举如中心设备@property(readonly) CBPeripheralManagerState state;//是否正在发送广播@property(readonly) BOOL isAdvertising;//用户的授权状态+ (CBPeripheralManagerAuthorizationStatus)authorizationStatus;//初始化并设置代理 参数的具体含义与中心设备管理中心- (instancetype)initWithDelegate:(nullable id&lt;CBPeripheralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t);- (instancetype)initWithDelegate:(nullable id&lt;CBPeripheralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;//开始发送广播//advertisementData中可以发送的数据有约定 如下/*对应设置NSString类型的广播名NSString *const CBAdvertisementDataLocalNameKey;外设制造商的NSData数据NSString *const CBAdvertisementDataManufacturerDataKey;外设制造商的CBUUID数据NSString *const CBAdvertisementDataServiceDataKey;服务的UUID与其对应的服务数据字典数组NSString *const CBAdvertisementDataServiceUUIDsKey;附加服务的UUID数组NSString *const CBAdvertisementDataOverflowServiceUUIDsKey;外设的发送功率 NSNumber类型NSString *const CBAdvertisementDataTxPowerLevelKey;外设是否可以连接NSString *const CBAdvertisementDataIsConnectable;服务的UUID数组NSString *const CBAdvertisementDataSolicitedServiceUUIDsKey;*/- (void)startAdvertising:(nullable NSDictionary&lt;NSString *, id&gt; *)advertisementData;//停止发送广播- (void)stopAdvertising;//设置一个连接的具体central设备的延时 枚举如下/*typedef NS_ENUM(NSInteger, CBPeripheralManagerConnectionLatency) &#123; CBPeripheralManagerConnectionLatencyLow = 0, CBPeripheralManagerConnectionLatencyMedium, CBPeripheralManagerConnectionLatencyHigh&#125; NS_ENUM_AVAILABLE(NA, 6_0);*/- (void)setDesiredConnectionLatency:(CBPeripheralManagerConnectionLatency)latency forCentral:(CBCentral *)central;//添加一个服务- (void)addService:(CBMutableService *)service;//移除一个服务- (void)removeService:(CBMutableService *)service;//移除所有服务- (void)removeAllServices;//响应中心设备的读写请求- (void)respondToRequest:(CBATTRequest *)request withResult:(CBATTError)result;//更新一个连接中心设备的订阅特征值- (BOOL)updateValue:(NSData *)value forCharacteristic:(CBMutableCharacteristic *)characteristic onSubscribedCentrals:(nullable NSArray&lt;CBCentral *&gt; *)centrals; 外设代理的相关方法如下： 123456789101112131415161718//这个方法是必须实现的 状态可用后可以发送广播- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral;//连接回复时调用的方法 和centralManager类似- (void)peripheralManager:(CBPeripheralManager *)peripheral willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict;//开始发送广播时调用的方法- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(nullable NSError *)error;//添加服务调用的回调- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(nullable NSError *)error;//当一个central设备订阅一个特征值时调用的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic;//取消订阅一个特征值时调用的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic;//收到读请求时触发的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request;//收到写请求时触发的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests;//外设准备更新特征值时调用的方法- (void)peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)peripheral; 四、中心设备与外设对象CBCentral与CBPeripheral上面介绍了中心设备管理类与外设管理类，这些类用于将设备连接建立起来，器具的数据交换的服务和一些信息则是在对应的设备对象中。 1、中心设备 CBCentral属性与方法1234//设备UUID@property(readonly, nonatomic) NSUUID *identifier;//中心设备最大接收的数据长度@property(readonly, nonatomic) NSUInteger maximumUpdateValueLength; 2、外设CAPeripheral属性与方法外设对象要比中心对象复杂的多，当centralManager连接到外设后，需要通过外设对象的代理方法进行数据交互，其中主要方法属性如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//设置代理@property(assign, nonatomic, nullable) id&lt;CBPeripheralDelegate&gt; delegate;//外设name@property(retain, readonly, nullable) NSString *name;//信号强度@property(retain, readonly, nullable) NSNumber *RSSI NS_DEPRECATED(NA, NA, 5_0, 8_0);//外设状态/*typedef NS_ENUM(NSInteger, CBPeripheralState) &#123; CBPeripheralStateDisconnected = 0,//未连接 CBPeripheralStateConnecting,//正在链接 CBPeripheralStateConnected,//已经连接 CBPeripheralStateDisconnecting NS_AVAILABLE(NA, 9_0),//正在断开连接&#125; NS_AVAILABLE(NA, 7_0);*/@property(readonly) CBPeripheralState state;//所有的服务数组@property(retain, readonly, nullable) NSArray&lt;CBService *&gt; *services;//获取当前信号强度- (void)readRSSI;//根据服务UUID寻找服务对象- (void)discoverServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs;//在服务对象UUID数组中寻找特定服务- (void)discoverIncludedServices:(nullable NSArray&lt;CBUUID *&gt; *)includedServiceUUIDs forService:(CBService *)service;//在一个服务中寻找特征值- (void)discoverCharacteristics:(nullable NSArray&lt;CBUUID *&gt; *)characteristicUUIDs forService:(CBService *)service;//从一个特征中读取数据- (void)readValueForCharacteristic:(CBCharacteristic *)characteristic;//写数据的最大长度//type枚举如下/*typedef NS_ENUM(NSInteger, CBCharacteristicWriteType) &#123; CBCharacteristicWriteWithResponse = 0,//写数据并且接收成功与否回执 CBCharacteristicWriteWithoutResponse,//写数据不接收回执&#125;;*/- (NSUInteger)maximumWriteValueLengthForType:(CBCharacteristicWriteType)type NS_AVAILABLE(NA, 9_0);//向某个特征中写数据- (void)writeValue:(NSData *)data forCharacteristic:(CBCharacteristic *)characteristic type:(CBCharacteristicWriteType)type;//为制定的特征值设置监听通知- (void)setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic;//寻找特征值的描述- (void)discoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic;//读取特征的描述值- (void)readValueForDescriptor:(CBDescriptor *)descriptor;//写特征的描述值- (void)writeValue:(NSData *)data forDescriptor:(CBDescriptor *)descriptor; 外设的代理方法如下： 1234567891011121314151617181920212223242526//外设名称更改时回调的方法- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral NS_AVAILABLE(NA, 6_0);//外设服务变化时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray&lt;CBService *&gt; *)invalidatedServices NS_AVAILABLE(NA, 7_0);//信号强度改变时调用的方法- (void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(nullable NSError *)error NS_DEPRECATED(NA, NA, 5_0, 8_0);//读取信号强度回调的方法- (void)peripheral:(CBPeripheral *)peripheral didReadRSSI:(NSNumber *)RSSI error:(nullable NSError *)error NS_AVAILABLE(NA, 8_0);//发现服务时调用的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error;//在服务中发现子服务回调的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(nullable NSError *)error;//发现服务的特征值后回调的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error;//特征值更新时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error;//向特征值写数据时回调的方法 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //特征值的通知设置改变时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //发现特征值的描述信息触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //特征的描述值更新时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error; //写描述信息时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error; 五、服务对象CBService服务对象是用来管理外设提供的一些数据服务的，其中属性如下： 12345678//对应的外设@property(assign, readonly, nonatomic) CBPeripheral *peripheral;//是否是初等服务@property(readonly, nonatomic) BOOL isPrimary;//包含的自服务@property(retain, readonly, nullable) NSArray&lt;CBService *&gt; *includedServices;//服务中的特征值@property(retain, readonly, nullable) NSArray&lt;CBCharacteristic *&gt; *characteristics; 六、服务的特征值CBCharacteristic通过绑定服务中的特征值来进行数据的读写操作，其中属性如下： 1234567891011121314151617181920212223242526//对应的服务对象@property(assign, readonly, nonatomic) CBService *service;//特征值的属性 枚举如下/*typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123; CBCharacteristicPropertyBroadcast,//允许广播特征 CBCharacteristicPropertyRead,//可读属性 CBCharacteristicPropertyWriteWithoutResponse,//可写并且接收回执 CBCharacteristicPropertyWrite,//可写属性 CBCharacteristicPropertyNotify,//可通知属性 CBCharacteristicPropertyIndicate,//可展现的特征值 CBCharacteristicPropertyAuthenticatedSignedWrites,//允许签名的特征值写入 CBCharacteristicPropertyExtendedProperties, CBCharacteristicPropertyNotifyEncryptionRequired, CBCharacteristicPropertyIndicateEncryptionRequired&#125;;*/@property(readonly, nonatomic) CBCharacteristicProperties properties;//特征值的数据@property(retain, readonly, nullable) NSData *value;//特征值的描述@property(retain, readonly, nullable) NSArray&lt;CBDescriptor *&gt; *descriptors;//是否是当前广播的特征@property(readonly) BOOL isBroadcasted;//是否是正在通知的特征@property(readonly) BOOL isNotifying; 七、读写请求对象CBATTRequest服务对象是外设向中心设备提供的相关数据服务，获取到相应服务后，中心设备可以进行读写请求，读写对象属性如下： 123456//对应的中心设备@property(readonly, nonatomic) CBCentral *central;//对应的特征值@property(readonly, nonatomic) CBCharacteristic *characteristic;//读写数据值@property(readwrite, copy, nullable) NSData *value; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS获取和监测设备基本信息——UIDevice的使用","slug":"165iOS获取和监测设备基本信息——UIDevice的使用","date":"2015-12-17T16:00:00.000Z","updated":"2021-07-05T08:15:04.425Z","comments":true,"path":"2015/12/18/165iOS获取和监测设备基本信息——UIDevice的使用/","link":"","permalink":"http://huishao.cc/2015/12/18/165iOS获取和监测设备基本信息——UIDevice的使用/","excerpt":"","text":"iOS获取和监测设备基本信息——UIDevice的使用12345678910111213141516171819202122//获取当前设备单例+ (UIDevice *)currentDevice;//获取当前设备名称 @property(nonatomic,readonly,strong) NSString *name; // e.g. &quot;My iPhone&quot;//获取当前设备模式@property(nonatomic,readonly,strong) NSString *model; // e.g. @&quot;iPhone&quot;, @&quot;iPod touch&quot;//获取本地化的当前设备模式@property(nonatomic,readonly,strong) NSString *localizedModel; // localized version of model//获取系统名称@property(nonatomic,readonly,strong) NSString *systemName; // e.g. @&quot;iOS&quot;//获取系统版本@property(nonatomic,readonly,strong) NSString *systemVersion; // e.g. @&quot;4.0&quot;//获取设备方向@property(nonatomic,readonly) UIDeviceOrientation orientation; //获取设备UUID对象@property(nullable, nonatomic,readonly,strong) NSUUID *identifierForVendor;//是否开启监测电池状态 开启后 才可以正常获取电池状态@property(nonatomic,getter=isBatteryMonitoringEnabled) BOOL batteryMonitoringEnabled NS_AVAILABLE_IOS(3_0); // default is NO//获取电池状态@property(nonatomic,readonly) UIDeviceBatteryState batteryState NS_AVAILABLE_IOS(3_0); //获取电量@property(nonatomic,readonly) float batteryLevel NS_AVAILABLE_IOS(3_0); 设备方向的枚举如下： 123456789typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123; UIDeviceOrientationUnknown, UIDeviceOrientationPortrait, // home键在下 UIDeviceOrientationPortraitUpsideDown, // home键在上 UIDeviceOrientationLandscapeLeft, // home键在右 UIDeviceOrientationLandscapeRight, // home键在左 UIDeviceOrientationFaceUp, // 屏幕朝上 UIDeviceOrientationFaceDown // 屏幕朝下&#125;; 电池状态的枚举如下： 123456typedef NS_ENUM(NSInteger, UIDeviceBatteryState) &#123; UIDeviceBatteryStateUnknown, UIDeviceBatteryStateUnplugged, // 放电状态 UIDeviceBatteryStateCharging, // 充电未充满状态 UIDeviceBatteryStateFull, // 充电已充满&#125;; 下面的方法关于监测屏幕状态： 123456//获取是否开启屏幕状态更改通知@property(nonatomic,readonly,getter=isGeneratingDeviceOrientationNotifications) BOOL generatesDeviceOrientationNotifications;//开始监测通知- (void)beginGeneratingDeviceOrientationNotifications; //结束监测通知- (void)endGeneratingDeviceOrientationNotifications; 下面这两个放大与距离传感器应用相关，可参考：http://my.oschina.net/u/2340880/blog/544341. 123@property(nonatomic,getter=isProximityMonitoringEnabled) BOOL proximityMonitoringEnabled NS_AVAILABLE_IOS(3_0); //开启距离传感器//是否触发了距离传感器@property(nonatomic,readonly) BOOL proximityState 相关通知： 12345678//设备方向改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceOrientationDidChangeNotification;//电池状态改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceBatteryStateDidChangeNotification NS_AVAILABLE_IOS(3_0);//电量改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceBatteryLevelDidChangeNotification NS_AVAILABLE_IOS(3_0);//距离传感器状态改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceProximityStateDidChangeNotification NS_AVAILABLE_IOS(3_0); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——距离传感器的应用","slug":"164iOS传感器开发——距离传感器的应用","date":"2015-12-13T16:00:00.000Z","updated":"2021-07-05T08:14:17.222Z","comments":true,"path":"2015/12/14/164iOS传感器开发——距离传感器的应用/","link":"","permalink":"http://huishao.cc/2015/12/14/164iOS传感器开发——距离传感器的应用/","excerpt":"","text":"iOS传感器开发——距离传感器的应用iPhone手机中内置了距离传感器，位置在手机的听筒附近，当我们在打电话的时候靠近听筒，手机的屏幕会自动熄灭，这就靠距离传感器来控制。 在我们开发app时，如果需要，也可以调用距离传感器的一些接口方法。距离传感器的接口十分简单，主要通过通知中心来对距离的改变进行通知。 首先，我们需要开启距离传感器应用： 1[UIDevice currentDevice].proximityMonitoringEnabled=YES; 监听距离改变的通知： 1[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(notice) name:UIDeviceProximityStateDidChangeNotification object:nil]; 在回调方法中，我们可以通过下面这个属性来监听距离状态： 1234567-(void)notice&#123; if ([UIDevice currentDevice].proximityState) &#123; NSLog(@&quot;近距离&quot;); &#125;else&#123; NSLog(@&quot;远距离&quot;); &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用","slug":"163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用","date":"2015-12-12T16:00:00.000Z","updated":"2021-07-05T08:13:22.467Z","comments":true,"path":"2015/12/13/163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用/","link":"","permalink":"http://huishao.cc/2015/12/13/163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用/","excerpt":"","text":"iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用一、引言通过加速度传感器，螺旋仪传感器和磁力传感，我们可以获取到手机在当前三维空间中的形态，加速度传感器也被称作重力感应。在一些赛车游戏中可以广泛得到应用。在iOS5之前，iPhone支持的传感器有限，关于加速度传感器的管理用UIAccelerometer这个类负责，iOS5之后，有关设备空间信息的管理交由了CoreMotion这个框架，CoreMotion将多种传感器统一进行管理计算。 二、使用UIAccelerometer获取设备空间位置虽然在iOS5之后这个类被弃用了，但是和其他大多被弃用的方法类似，在新的iOS版本中，是兼容旧方法的，我们依然可以使用这个类来获取简单的设备空间信息。 我们主要使用到的类和代理方法如下： 1234567891011//设备信息对象类@interface UIAcceleration : NSObject//加速度传感器的时间戳@property(nonatomic,readonly) NSTimeInterval timestamp;//x方向值@property(nonatomic,readonly) UIAccelerationValue x;//y方向值@property(nonatomic,readonly) UIAccelerationValue y;//z方向值@property(nonatomic,readonly) UIAccelerationValue z;@end 上面的UIAccelerationValue就是double类型。 加速度传感器获取的属性是设备在三维空间的角度属性，借用下面这张图： 如果将设备这样立在桌面上，设备的三维坐标器如图，我们将设备已Z轴移动的时候，向右x为正，向左为负，其他两轴类似。 123456789//加速度管理类@interface UIAccelerometer : NSObject //获取单例对象+ (UIAccelerometer *)sharedAccelerometer;//刷新频率@property(nonatomic) NSTimeInterval updateInterval;//代理@property(nullable,nonatomic,weak) id&lt;UIAccelerometerDelegate&gt; delegate;@end UIAccelerometer是管理类，通过单例方法获取到实例对象。 123456@protocol UIAccelerometerDelegate&lt;NSObject&gt;@optional- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration NS_DEPRECATED_IOS(2_0, 5_0) __TVOS_PROHIBITED;@end 这个代理方法是刷新信息的回调，会以我们设置的帧率刷新。 举例代码如下： 123456789101112131415161718@interface ViewController ()&lt;UIAccelerometerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [UIAccelerometer sharedAccelerometer].delegate=self; [UIAccelerometer sharedAccelerometer].updateInterval=1/60.0;&#125;-(void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration&#123; NSLog(@&quot;\\n%f\\n%f\\n%f&quot;,acceleration.x,acceleration.y,acceleration.z); // NSLog(@&quot;%f&quot;,acceleration.timestamp);&#125;@end 三、CoreMotion框架的使用CoreMotion框架十分强大，它不仅将加速度传感器和螺旋仪传感器进行了统一配置和管理，还为我们封装了许多算法，我们可以直接获取到设备的运动状态信息。 1、CoreMotion负责处理的数据CoreMotion负责处理四种数据，一种是加速度数据，一种是螺旋仪数据，一种是磁感应数据，还有一种是前三种数据通过复杂运算得到的设备的运动数据。几个主要的类如下： CMAccelerommterData:设备的加速度数据 1234567891011121314typedef struct &#123; double x; double y; double z;&#125; CMAcceleration;@interface CMAccelerometerData : CMLogItem&#123;@private id _internal;&#125;//加速度的数据对象@property(readonly, nonatomic) CMAcceleration acceleration;@end CMGyroData:设备的螺旋仪数据 1234567891011121314typedef struct &#123; double x; double y; double z; &#125; CMRotationRate;@interface CMGyroData : CMLogItem&#123;@private id _internal;&#125;//螺旋仪数据对象@property(readonly, nonatomic) CMRotationRate rotationRate;@end CMMagnetometerData：磁感应信息 12345678910111213141516typedef struct &#123; double x; double y; double z;&#125; CMMagneticField;@interface CMMagnetometerData : CMLogItem&#123;@private id _internal;&#125;//磁力对象@property(readonly, nonatomic) CMMagneticField magneticField;@end CMDeviceMotion:设备的运动状态数据 123456789101112131415@interface CMDeviceMotion : CMLogItem&#123;@private id _internal;&#125;//设备的状态对象@property(readonly, nonatomic) CMAttitude *attitude;//设备的角速度@property(readonly, nonatomic) CMRotationRate rotationRate;//设备的重力加速度@property(readonly, nonatomic) CMAcceleration gravity;//用户嫁给设备的加速度 设备的总加速度为重力加速度叫上用户给的加速度@property(readonly, nonatomic) CMAcceleration userAcceleration;//设备的磁场矢量对象@property(readonly, nonatomic) CMCalibratedMagneticField magneticField NS_AVAILABLE(NA,5_0); 相比之前两个类，这个就比较复杂了，attitude对象中又封装了许多设备的状态属性： 12345678910111213141516@interface CMAttitude : NSObject &lt;NSCopying, NSSecureCoding&gt;&#123;@private id _internal;&#125;//设备的欧拉角roll@property(readonly, nonatomic) double roll;//设备的欧拉角pitch@property(readonly, nonatomic) double pitch;//设备的欧拉角yaw@property(readonly, nonatomic) double yaw;//设备状态的旋转矩阵@property(readonly, nonatomic) CMRotationMatrix rotationMatrix;//设备状态的四元数@property(readonly, nonatomic) CMQuaternion quaternion;@end 2、CoreMotion的使用CoreMotion有两种使用方式，一种是我们主动向manager索取数据，一种是通过回调让manager将数据传给回调给我们，这两种方式分别称作pull方式和push方式。 pull方式： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建管理对象 manager= [[CMMotionManager alloc]init]; //开启加速度更新 [manager startAccelerometerUpdates]; //开启螺旋仪更新 [manager startGyroUpdates]; //开启状态更新 [manager startMagnetometerUpdates]; //创建定时器 NSTimer * time = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(updata) userInfo:nil repeats:YES]; time.fireDate = [NSDate distantPast];&#125;-(void)updata&#123;//获取数据 NSLog(@&quot;%f,%f,%f\\n%f,%f,%f&quot;,manager.accelerometerData.acceleration.x,manager.accelerometerData.acceleration.y,manager.accelerometerData.acceleration.z,manager.gyroData.rotationRate.x,manager.gyroData.rotationRate.y,manager.gyroData.rotationRate.z); &#125; push方式： 123456 //创建管理对象 manager= [[CMMotionManager alloc]init]; //在当前线程中回调 [manager startAccelerometerUpdatesToQueue:[NSOperationQueue currentQueue] withHandler:^(CMAccelerometerData * _Nullable accelerometerData, NSError * _Nullable error) &#123; NSLog(@&quot;%f,%f,%f\\n%f,%f,%f&quot;,manager.accelerometerData.acceleration.x,manager.accelerometerData.acceleration.y,manager.accelerometerData.acceleration.z,manager.gyroData.rotationRate.x,manager.gyroData.rotationRate.y,manager.gyroData.rotationRate.z); &#125;]; 3、CoreMotion的更多属性和方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@interface CMMotionManager : NSObject&#123;@private id _internal;&#125;//设置加速度传感器更新帧率@property(assign, nonatomic) NSTimeInterval accelerometerUpdateInterval __TVOS_PROHIBITED;//加速度传感器是否可用@property(readonly, nonatomic, getter=isAccelerometerAvailable) BOOL accelerometerAvailable __TVOS_PROHIBITED;//加速度传感器是否激活@property(readonly, nonatomic, getter=isAccelerometerActive) BOOL accelerometerActive __TVOS_PROHIBITED;//加速度传感器数据对象@property(readonly, nullable) CMAccelerometerData *accelerometerData __TVOS_PROHIBITED;//pull方式开始更新加速度数据- (void)startAccelerometerUpdates __TVOS_PROHIBITED;//push方式更新加速度数据- (void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler __TVOS_PROHIBITED;//停止更新加速度数据- (void)stopAccelerometerUpdates __TVOS_PROHIBITED;//螺旋仪传感器刷新帧率@property(assign, nonatomic) NSTimeInterval gyroUpdateInterval __TVOS_PROHIBITED;//螺旋仪是否可用@property(readonly, nonatomic, getter=isGyroAvailable) BOOL gyroAvailable __TVOS_PROHIBITED;//螺旋仪是否激活@property(readonly, nonatomic, getter=isGyroActive) BOOL gyroActive __TVOS_PROHIBITED;//螺旋仪数据@property(readonly, nullable) CMGyroData *gyroData __TVOS_PROHIBITED;//pull方式开始更新螺旋仪- (void)startGyroUpdates __TVOS_PROHIBITED;//push方式开始更新螺旋仪- (void)startGyroUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMGyroHandler)handler __TVOS_PROHIBITED;//停止更新螺旋仪- (void)stopGyroUpdates __TVOS_PROHIBITED;//磁力传感更新帧率@property(assign, nonatomic) NSTimeInterval magnetometerUpdateInterval NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力传感器是否可用@property(readonly, nonatomic, getter=isMagnetometerAvailable) BOOL magnetometerAvailable NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力传感器是否激活@property(readonly, nonatomic, getter=isMagnetometerActive) BOOL magnetometerActive NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力状态数据@property(readonly, nullable) CMMagnetometerData *magnetometerData NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//pull方式更新设备磁力状态- (void)startMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//push方式更新设备磁力状态- (void)startMagnetometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMMagnetometerHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//停止更新设备状态- (void)stopMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备状态更新帧率@property(assign, nonatomic) NSTimeInterval deviceMotionUpdateInterval __TVOS_PROHIBITED;//参考器枚举+ (CMAttitudeReferenceFrame)availableAttitudeReferenceFrames NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;@property(readonly, nonatomic) CMAttitudeReferenceFrame attitudeReferenceFrame NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备运动信息是否可用@property(readonly, nonatomic, getter=isDeviceMotionAvailable) BOOL deviceMotionAvailable __TVOS_PROHIBITED;//设备运动信息是否激活@property(readonly, nonatomic, getter=isDeviceMotionActive) BOOL deviceMotionActive __TVOS_PROHIBITED;//设备运动信息对象@property(readonly, nullable) CMDeviceMotion *deviceMotion __TVOS_PROHIBITED;//pull方式开始刷新运动信息- (void)startDeviceMotionUpdates __TVOS_PROHIBITED;//push方式开始刷新运动信息- (void)startDeviceMotionUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler __TVOS_PROHIBITED;//使用某个参考系- (void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//push方式开始刷新设备运动信息- (void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame toQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//停止刷新设备运动信息- (void)stopDeviceMotionUpdates __TVOS_PROHIBITED; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——为APP添加手机密码、指纹进行安全验证","slug":"162iOS传感器开发——为APP添加手机密码、指纹进行安全验证","date":"2015-12-09T16:00:00.000Z","updated":"2021-07-05T08:12:25.574Z","comments":true,"path":"2015/12/10/162iOS传感器开发——为APP添加手机密码、指纹进行安全验证/","link":"","permalink":"http://huishao.cc/2015/12/10/162iOS传感器开发——为APP添加手机密码、指纹进行安全验证/","excerpt":"","text":"iOS传感器开发——为APP添加手机密码、指纹进行安全验证一、引言iPhone5s之后，iPhone硬件上已支持进行指纹识别的功能，相应的，一些新的api也可以应用于APP中，进行用户安全的验证。目前，开发者可以使用的安全验证方式有两种，一种是通过手机密码进行验证，一种是通过识别指纹进行验证。 二、为APP添加安全验证要使用安全验证的相关api，我们需要引入如下头文件： 1#import &lt;LocalAuthentication/LocalAuthentication.h&gt; 添加手机密码验证： 123456789101112131415 //创建安全验证对象 LAContext * con = [[LAContext alloc]init]; NSError * error; //判断是否支持密码验证 /** *LAPolicyDeviceOwnerAuthentication 手机密码的验证方式 *LAPolicyDeviceOwnerAuthenticationWithBiometrics 指纹的验证方式 */ BOOL can = [con canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:&amp;error]; if (can) &#123; [con evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:@&quot;验证信息&quot; reply:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@&quot;%d,%@&quot;,success,error); &#125;]; &#125; canEvaluatePolicy是用来判断是否支持手机密码验证的，如果没有设置手机密码，会返回NO，如果启用了，会出现如下界面： 密码验证的提示信息，我们可以自定义设置。 进行指纹验证： 12345678910LAContext * con = [[LAContext alloc]init]; NSError * error; BOOL can = [con canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]; NSLog(@&quot;%d&quot;,can); if (can) &#123; [con evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@&quot;验证指纹&quot; reply:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@&quot;%d,%@&quot;,success,error); &#125;]; &#125; 回调中的success用来判断是否验证成功： 通过这些验证方式，可以使用户的数据更加安全，在做敏感操作时，可以确保是手机的持有者。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之五——高级动画技巧","slug":"160iOS开发CoreAnimation解读之五——高级动画技巧","date":"2015-12-05T16:00:00.000Z","updated":"2021-07-05T08:10:41.632Z","comments":true,"path":"2015/12/06/160iOS开发CoreAnimation解读之五——高级动画技巧/","link":"","permalink":"http://huishao.cc/2015/12/06/160iOS开发CoreAnimation解读之五——高级动画技巧/","excerpt":"","text":"iOS开发CoreAnimation解读之五——高级动画技巧一、事务类CoreAnimation中还有一个非常重要的类：CATransaction事物类，这个可以同时设置多个layer层的动画效果。可以通过隐式和显式两种方式来进行动画操作。 二、CATransaction属性对layer层的属性操作，都会形成隐式动画，要使用隐式动画，需要关闭layer层的animation动画属性，使用下面的方法： 123//关闭animation动画效果，开启隐式动画+ (BOOL)disableActions;+ (void)setDisableActions:(BOOL)flag; CATransaction用类方式通过设置key-value来进行动画的属性设置： 12+ (nullable id)valueForKey:(NSString *)key;+ (void)setValue:(nullable id)anObject forKey:(NSString *)key; 支持的key值如下： 12345678//设置动画持续时间 NSString * const kCATransactionAnimationDuration; //设置停用animation类动画 NSString * const kCATransactionDisableActions; //设置动画时序效果 NSString * const kCATransactionAnimationTimingFunction; //设置动画完成后的回调 NSString * const kCATransactionCompletionBlock; 除了隐式的展示动画外，也可以显式的通过调用CATransaction的相关方法进行显示的提交动画： 123456789//动画开始+ (void)begin;//提交动画+ (void)commit;//立即进行动画渲染 一般不需调用+ (void)flush;//下面这两个方法用于动画事物的加锁与解锁 在多线程动画中，保证修改属性的安全+ (void)lock;+ (void)unlock; 示例如下： 1234 [CATransaction begin]; [CATransaction setValue:@1 forKey:kCATransactionAnimationDuration]; layer.backgroundColor = [UIColor blueColor].CGColor; [CATransaction commit]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之六——CATransform3D变换的应用","slug":"161iOS开发CoreAnimation解读之六——CATransform3D变换的应用","date":"2015-12-05T16:00:00.000Z","updated":"2021-07-05T08:11:32.943Z","comments":true,"path":"2015/12/06/161iOS开发CoreAnimation解读之六——CATransform3D变换的应用/","link":"","permalink":"http://huishao.cc/2015/12/06/161iOS开发CoreAnimation解读之六——CATransform3D变换的应用/","excerpt":"","text":"iOS开发CoreAnimation解读之五——CATransform3D变换的应用一、引言CATransform3D定义了一个变化矩阵，通过对矩阵参数的设置，我们可以改变layer的一些属性，这个属性的改变，可以产生动画的效果。首先，CATransform3D定义了一个4*4的矩阵，如下： 1234567struct CATransform3D&#123; CGFloat m11, m12, m13, m14; CGFloat m21, m22, m23, m24; CGFloat m31, m32, m33, m34; CGFloat m41, m42, m43, m44;&#125;; 从m11到m44定义的含义如下： m11：x轴方向进行缩放 m12：和m21一起决定z轴的旋转 m13:和m31一起决定y轴的旋转 m14: m21:和m12一起决定z轴的旋转 m22:y轴方向进行缩放 m23:和m32一起决定x轴的旋转 m24: m31:和m13一起决定y轴的旋转 m32:和m23一起决定x轴的旋转 m33:z轴方向进行缩放 m34:透视效果m34= -1/D，D越小，透视效果越明显，必须在有旋转效果的前提下，才会看到透视效果 m41:x轴方向进行平移 m42:y轴方向进行平移 m43:z轴方向进行平移 m44:初始为1 二、CATransform3D中的属性和方法12345678//初始化一个transform3D对象，不做任何变换const CATransform3D CATransform3DIdentity;//判断一个transform3D对象是否是初始化的对象bool CATransform3DIsIdentity (CATransform3D t);//比较两个transform3D对象是否相同bool CATransform3DEqualToTransform (CATransform3D a, CATransform3D b);//将两个 transform3D对象变换属性进行叠加，返回一个新的transform3D对象CATransform3D CATransform3DConcat (CATransform3D a, CATransform3D b); 1、平移变换1234//返回一个平移变换的transform3D对象 tx，ty，tz对应x，y，z轴的平移CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz);//在某个transform3D变换的基础上进行平移变换，t是上一个transform3D，其他参数同上CATransform3D CATransform3DTranslate (CATransform3D t, CGFloat tx, CGFloat ty, CGFloat tz); 例如： 123456789 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeTranslation(10, 200, 0); newImageView.layer.transform =trans; 效果如下： 2、缩放变换1234//x，y，z分别对应x轴，y轴，z轴的缩放比例CATransform3D CATransform3DMakeScale (CGFloat sx, CGFloat sy, CGFloat sz);//在一个transform3D变换的基础上进行缩放变换，其他参数同上CATransform3D CATransform3DScale (CATransform3D t, CGFloat sx, CGFloat sy, CGFloat sz); 例如： 123456789UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeScale(2, 1, 1); newImageView.layer.transform =trans; 效果如下： 3、旋转变换123456//angle参数是旋转的角度，为弧度制 0-2π//x，y，z决定了旋转围绕的中轴，取值为-1——1之间，例如（1，0，0）,则是绕x轴旋转（0.5，0.5，0），则是绕x轴与y轴中//间45度为轴旋转,依次进行计算CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);//在一个transform3D的基础上进行旋转变换，其他参数如上CATransform3D CATransform3DRotate (CATransform3D t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z); 例如： 123456789UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeRotation(M_PI/2, 0, 0, 1); newImageView.layer.transform =trans; 效果如下： 另外，当我们有垂直于z轴的旋转分量时，设置m34的值可以增加透视效果，也可以理解为景深效果，例如： 123456789101112 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; imageView.layer.transform = CATransform3DMakeRotation(M_PI/4, 0, 1, 0); [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DIdentity; trans.m34 = -1/100.0; trans = CATransform3DRotate(trans, M_PI/4, 0, 1, 0); newImageView.layer.transform =trans; 两个imageView都进行了y轴的旋转变换，第二个有透视效果，第一个没有，运行如下： 4、旋转翻转变换12//将一个旋转的效果进行翻转 CATransform3D CATransform3DInvert (CATransform3D t); 例如： 123456789101112 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; imageView.layer.transform = CATransform3DMakeRotation(M_PI/4, 0, 0, 1); [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeRotation(M_PI/4, 0, 0, 1); trans = CATransform3DInvert(trans); newImageView.layer.transform =trans; 效果如下： 5、CATransform3D与CGAffineTransform的转换CGAffineTransform是UIKit框架中一个用于变换的矩阵，其作用与CATransform类似，只是其可以直接作用于View，而不用作用于layer，这两个矩阵也可以进行转换，方法如下： 123456//将一个CGAffinrTransform转化为CATransform3DCATransform3D CATransform3DMakeAffineTransform (CGAffineTransform m);//判断一个CATransform3D是否可以转换为CAAffineTransformbool CATransform3DIsAffine (CATransform3D t);//将CATransform3D转换为CGAffineTransformCGAffineTransform CATransform3DGetAffineTransform (CATransform3D t); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之四——Layer层动画内容","slug":"159iOS开发CoreAnimation解读之四——Layer层动画内容","date":"2015-12-04T16:00:00.000Z","updated":"2021-07-05T08:09:40.544Z","comments":true,"path":"2015/12/05/159iOS开发CoreAnimation解读之四——Layer层动画内容/","link":"","permalink":"http://huishao.cc/2015/12/05/159iOS开发CoreAnimation解读之四——Layer层动画内容/","excerpt":"","text":"iOS开发CoreAnimation解读之四——Layer层动画内容一、引言通过前几篇博客的介绍，我们可以了解到layer层可以设置许多与控件UI相关的属性，并且对于iOS开发，UIView层的属性是会映射到CALayer的，因此，可以通过UIKit和CoreAnimation两个框架来设置控件的UI相关属性，当属性发生变化时，我们可以使其展示一个动画效果。 二、CAAnimation动画体系的介绍CAAnimation是CoreAnimation框架中执行动画对象的基类，下面有一张图，是我手画的，不太美观，但是可以将与CAAnimation相关的几个动画类的关系表达清楚： 从上图中可以看到，从CAAnimation中继承出三个子类，分别是用于创建属性动画的CAPropertyAnimation，创建转场动画的CATransition和创建组合动画的CAAnimationGroup。 我们就先从根类开始探讨。 1.CAAnimation属性和方法CAAnimation作为动画对象的基类，其中封装了动画的基础属性，如下： 12345678//通过类方法创建一个CAAnimation对象+ (instancetype)animation;//动画执行的时序模式@property(nullable, strong) CAMediaTimingFunction *timingFunction;//代理@property(nullable, strong) id delegate;//是否动画完成时将动画对象移除掉@property(getter=isRemovedOnCompletion) BOOL removedOnCompletion; timingFunction定义了动画执行的时序效果，CAMediaTimingFunction的创建方式如下： 1234567891011121314/*name参数决定的执行的效果，可选参数如下//线性执行 NSString * const kCAMediaTimingFunctionLinear; //淡入 在动画开始时 淡入效果 NSString * const kCAMediaTimingFunctionEaseIn; //淡出 在动画结束时 淡出效果 NSString * const kCAMediaTimingFunctionEaseOut; //淡入淡出 NSString * const kCAMediaTimingFunctionEaseInEaseOut; //默认效果 NSString * const kCAMediaTimingFunctionDefault;*/+ (instancetype)functionWithName:(NSString *)name; CAAnimation的代理方法入如下几个： 1234//动画开始时执行的回调- (void)animationDidStart:(CAAnimation *)anim;//动画结束后执行的回调- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; 2.CAPropertyAnimation属性与方法CAPropertyAnimation是继承于CAAnimation专门用来创建与属性相关的动画的类： 12345678910111213//创建对象 参数中的path就是我们要执行动画的属性//例如，如果传入@&quot;backgroundColor&quot; 当layer的背景颜色改变时，就会执行我们设置的动画+ (instancetype)animationWithKeyPath:(nullable NSString *)path;//这个属性确定动画执行的状态是否叠加在控件的原状态上//默认设置为NO，如果我们执行两次位置移动的动画，会从同一位置执行两次//如果设置为YES，则会在第一次执行的基础上执行第二次动画@property(getter=isAdditive) BOOL additive;//这个属性对重复执行的动画有效果//默认为NO，重复执行的动画每次都是从起始状态开始//如果设置为yes，则为此执行都会在上一次执行的基础上执行@property(getter=isCumulative) BOOL cumulative;//这个属性和transfron属性的动画执行相关@property(nullable, strong) CAValueFunction *valueFunction; 上面这些属性中，只有一个需要我们注意，valueFunction是专门为了transform动画而设置的，因为我们没有办法直接改变transform3D中的属性，通过这个参数，可以帮助我们直接操作transfrom3D属性变化产生动画效果，举例如下，一个绕Z轴旋转的动画： 123456789101112 //绕z轴旋转的动画 CABasicAnimation * ani = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;]; //从0度开始 ani.fromValue = @0; //旋转到180度 ani.toValue = [NSNumber numberWithFloat:M_PI]; //时间2S ani.duration = 2; //设置为z轴旋转 ani.valueFunction = [CAValueFunction functionWithName:kCAValueFunctionRotateZ]; //执行动画 [layer addAnimation:ani forKey:@&quot;&quot;]; 实际上，使用点的方式也是可以访问到相应属性的，如果不设置valueFunction，使用如下方法也是可以进行绕Z轴旋转的： 12345678910//绕z轴旋转的动画 CABasicAnimation * ani = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; //从0度开始 ani.fromValue = @0; //旋转到180度 ani.toValue = [NSNumber numberWithFloat:M_PI]; //时间2S ani.duration = 2; //执行动画 [layer addAnimation:ani forKey:@&quot;&quot;]; 3.CABasicAnimation属性CABasicAnimaton是CAPropertyAnimation分出来的一个子类，创建基础的属性变化动画，例如我们上面的示例代码，其中属性如下： 123@property(nullable, strong) id fromValue;@property(nullable, strong) id toValue;@property(nullable, strong) id byValue; 上面三个属性都是来确定动画的起始与结束位置，有如下的含义： fromValue和toValue不为空：动画的值由fromValue变化到toValue fromValue和byValue不为空：动画的值由fromValue变化到fromValue+byValue byValue和toValue不为空：动画的值由toValue-byValue变化到toValue 只有fromValue不为空：动画的值由fromValue变化到layer的当前状态值 只有toValue不为空：动画的值由layer当前的值变化到toValue 只有byValue不为空：动画的值由layer当前的值变化到layer当前的值+byValue 4.CAKeyframeAnimation关键帧动画CAKeyframeAnimation也是继承与CAPropertyAnimation的一个子类，其与CABasicAnimation的不同之处在于虽然其都是改变layer层属性的动画，但是CABasicAnimation只能设置初始与结束状态，这之间我们没办法控制，而CAKeyframeAnimation可以让我们设置一些关键帧再整个动画的过程中。属性方法如下： 1234567891011121314151617//关键帧的值数组 例如我们想让控件沿某个路径移动，这里面存放每个移动的点@property(nullable, copy) NSArray *values;//直接设置路径，作用域values类似@property(nullable) CGPathRef path;//设置每一帧执行的时间长短 这个的取值为0-1，代表占用时间的比例@property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes;//每一帧执行过程中的时序效果 上面有提过@property(nullable, copy) NSArray&lt;CAMediaTimingFunction *&gt; *timingFunctions;/*设置帧的中间值如何计算 NSString * const kCAAnimationLinear; NSString * const kCAAnimationDiscrete; NSString * const kCAAnimationPaced; NSString * const kCAAnimationCubic; NSString * const kCAAnimationCubicPaced;*/@property(copy) NSString *calculationMode; 示例如下： 1234 CAKeyframeAnimation * ani = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; ani.values = @[[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(120, 100)],[NSValue valueWithCGPoint:CGPointMake(120, 200)],[NSValue valueWithCGPoint:CGPointMake(200, 200)]]; ani.duration = 3; [layer addAnimation:ani forKey:@&quot;&quot;]; 5.CASpringAnimation阻尼动画通过CASpringAnimation，可以帮助开发者很轻松的创建出有弹簧效果的动画，主要属性如下： 12345678910//这个属性设置弹簧重物的质量 会影响惯性 必须大于0 默认为1@property CGFloat mass;//设置弹簧的刚度系数，必须大于0 默认为100 这个越大 则回弹越快@property CGFloat stiffness;//阻尼系数 默认为10 必须大于0 这个值越大 回弹的幅度越小@property CGFloat damping;//初始速度@property CGFloat initialVelocity;//获取动画停下来需要的时间@property(readonly) CFTimeInterval settlingDuration; 6.CATransition转场动画CATransition和CAPropertyAnimation的不同之处在于当layer层出现时，会产生动画效果，而并不是属性改变时，属性如下： 123456789101112131415161718192021222324/*设置动画类型//淡入 NSString * const kCATransitionFade; //移入 NSString * const kCATransitionMoveIn; //压入 NSString * const kCATransitionPush; //溶解 NSString * const kCATransitionReveal;*/@property(copy) NSString *type;/*设置动画的方向//从右侧进 NSString * const kCATransitionFromRight; //从左侧进 NSString * const kCATransitionFromLeft; //从上侧进 NSString * const kCATransitionFromTop; //从下侧进 NSString * const kCATransitionFromBottom;*/@property(nullable, copy) NSString *subtype; 其实，关于type定义的动画效果，出来官方定义的，我们还可以使用一些私有的参数，如下： 12345pageCurl 翻页rippleEffect 滴水效果suckEffect 收缩效果，如一块布被抽走cube 立方体效果oglFlip 上下翻转效果 例如： 1234 CATransition * ani = [CATransition animation]; ani.type = @&quot;pageCurl&quot;; ani.subtype = kCATransitionFromRight; [layer addAnimation:ani forKey:@&quot;&quot;]; 7.CAAnimationGroup动画组CAAnimationGroup本身并没有定义动画，他可以将我们上面提到的相关动画进行组合： 1@property(nullable, copy) NSArray&lt;CAAnimation *&gt; *animations; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS运用runtime全局修改UILabel的默认字体","slug":"158iOS运用runtime全局修改UILabel的默认字体","date":"2015-12-01T16:00:00.000Z","updated":"2021-07-05T08:08:43.463Z","comments":true,"path":"2015/12/02/158iOS运用runtime全局修改UILabel的默认字体/","link":"","permalink":"http://huishao.cc/2015/12/02/158iOS运用runtime全局修改UILabel的默认字体/","excerpt":"","text":"iOS运用runtime全局修改UILabel的默认字体一、需求背景介绍在项目比较成熟的基础上，遇到了这样一个需求，应用中需要引入新的字体，需要更换所有Label的默认字体，但是同时，对于一些特殊设置了字体的label又不需要更换。乍看起来，这个问题确实十分棘手，首先项目比较大，一个一个设置所有使用到的label的font工作量是巨大的，并且在许多动态展示的界面中，可能会漏掉一些label，产生bug。其次，项目中的label来源并不唯一，有用代码创建的，有xib和storyBoard中的，这也将浪费很大的精力。这种情况下，我们可能会有下面两种处理方式。 二、处理方式1、使用框架创建我们自己的BaseLabel类，在其中进行默认字体的设置，并且并不影响在使用过程中特殊设置字体的label，这种方式可以满足我们的需求，但是并不适于我们的场景，项目已经成熟，重建一个label基类，来让所有的UILabel都换成它的工作量不会比重新设置所有label字体的工作量小太多。但这也是有优势的，至少如果下次再换字体，我们就不用麻烦了。 2、使用runtime替换UILabel初始化方法这是最简单方便的方法，我们可以使用runtime机制替换掉UILabel的初始化方法，在其中对label的字体进行默认设置。因为Label可以从initWithFrame、init和nib文件三个来源初始化，所以我们需要将这三个初始化的方法都替换掉。 首先，我们创建一个UILabel的类别： 12345#import &lt;UIKit/UIKit.h&gt;@interface UILabel (YHBaseChangeDefaultFont)@end 在其中加入如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#import &quot;UILabel+YHBaseChangeDefaultFont.h&quot;#import &lt;objc/runtime.h&gt;@implementation UILabel (YHBaseChangeDefaultFont)/** *每个NSObject的子类都会调用下面这个方法 在这里将init方法进行替换，使用我们的新字体 *如果在程序中又特殊设置了字体 则特殊设置的字体不会受影响 但是不要在Label的init方法中设置字体 *从init和initWithFrame和nib文件的加载方法 都支持更换默认字体 */+(void)load&#123; //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); //替换三个方法 SEL originalSelector = @selector(init); SEL originalSelector2 = @selector(initWithFrame:); SEL originalSelector3 = @selector(awakeFromNib); SEL swizzledSelector = @selector(YHBaseInit); SEL swizzledSelector2 = @selector(YHBaseInitWithFrame:); SEL swizzledSelector3 = @selector(YHBaseAwakeFromNib); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method originalMethod2 = class_getInstanceMethod(class, originalSelector2); Method originalMethod3 = class_getInstanceMethod(class, originalSelector3); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); Method swizzledMethod2 = class_getInstanceMethod(class, swizzledSelector2); Method swizzledMethod3 = class_getInstanceMethod(class, swizzledSelector3); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); BOOL didAddMethod2 = class_addMethod(class, originalSelector2, method_getImplementation(swizzledMethod2), method_getTypeEncoding(swizzledMethod2)); BOOL didAddMethod3 = class_addMethod(class, originalSelector3, method_getImplementation(swizzledMethod3), method_getTypeEncoding(swizzledMethod3)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; if (didAddMethod2) &#123; class_replaceMethod(class, swizzledSelector2, method_getImplementation(originalMethod2), method_getTypeEncoding(originalMethod2)); &#125;else &#123; method_exchangeImplementations(originalMethod2, swizzledMethod2); &#125; if (didAddMethod3) &#123; class_replaceMethod(class, swizzledSelector3, method_getImplementation(originalMethod3), method_getTypeEncoding(originalMethod3)); &#125;else &#123; method_exchangeImplementations(originalMethod3, swizzledMethod3); &#125; &#125;); &#125;/** *在这些方法中将你的字体名字换进去 */- (instancetype)YHBaseInit&#123; id __self = [self YHBaseInit]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; return __self;&#125;-(instancetype)YHBaseInitWithFrame:(CGRect)rect&#123; id __self = [self YHBaseInitWithFrame:rect]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; return __self;&#125;-(void)YHBaseAwakeFromNib&#123; [self YHBaseAwakeFromNib]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; &#125;@end 在上面的方法中写入我们想要UILabel默认显示的字体，我们分别从init，initWithFrame和nib文件创建一个UILabel添加到视图上，不做任何其他的操作： 1234567UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 280, 30)]; label.text = @&quot;你是从initWithFrame来的label&quot;; UILabel * label2 = [[UILabel alloc]init]; label2.frame= CGRectMake(20, 200, 280, 30); label2.text = @&quot;你是从init来的label&quot;; [self.view addSubview:label]; [self.view addSubview:label2]; 运行效果如下，可以看出，字体全部换掉了： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之三——几种常用Layer的使用解析","slug":"157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析","date":"2015-11-30T16:00:00.000Z","updated":"2021-07-05T08:07:52.920Z","comments":true,"path":"2015/12/01/157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析/","link":"","permalink":"http://huishao.cc/2015/12/01/157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析/","excerpt":"","text":"iOS开发CoreAnimation解读之三——几种常用Layer的使用解析一、CAEmitterLayerCAEmitterLayer是CoreAnimation框架中的粒子发射层，在以前的一片博客中有详细的介绍和范例，这里不再重复，地址如下： 粒子效果的应用和火焰范例：http://my.oschina.net/u/2340880/blog/485095 二、CAGradientLayerCAGradientLayer是用于色彩梯度展示的layer图层，通过CAGradientLayer，我们可以很轻松的创建出有过渡效果的色彩图。其中属性如下： 1234567891011121314151617181920/*颜色数组，设置我们需要过的的颜色，必须是CGColor对象*/@property(nullable, copy) NSArray *colors;/*颜色开始进行过渡的位置这个数组中的元素是NSNumber类型，单调递增的，并且在0——1之间例如，如果我们设置两个颜色进行过渡，这个数组中写入0.5，则第一个颜色会在达到layer一半的时候开始向第二个颜色过渡*/@property(nullable, copy) NSArray&lt;NSNumber *&gt; *locations;/*下面两个参数用于设置渲染颜色的起点和终点 取值范围均为0——1默认起点为（0.5 ，0） 终点为（0.5 ，1）,颜色的过渡范围就是沿y轴从上向下*/@property CGPoint startPoint;@property CGPoint endPoint;/*渲染风格 iOS中只支持一种默认的kCAGradientLayerAxial，我们无需手动设置*/@property(copy) NSString *type; 用如下代码创建一个度过视图的效果： 12345678 CAGradientLayer * layer = [CAGradientLayer layer]; layer.colors = @[(id)[UIColor redColor].CGColor,(id)[UIColor blueColor].CGColor,(id)[UIColor greenColor].CGColor]; layer.locations = @[@0.1,@0.7,@1]; layer.bounds = CGRectMake(0, 0, 100, 100); layer.position = CGPointMake(100, 100); layer.startPoint = CGPointMake(0, 0); layer.endPoint = CGPointMake(1, 1); [self.view.layer addSublayer:layer]; 效果如下： 三、CAReplicatorLayerCAReplocatorLayer是拷贝视图容器，我们可以通过它，将其中的子layer进行拷贝，并进行一些差异处理，其中常用属性方法如下： 12345678910111213141516//拷贝的次数@property NSInteger instanceCount;//是否开启景深效果@property BOOL preservesDepth;//当CAReplicatorLayer的子Layer层进行动画的时候，拷贝的副本执行动画的延时@property CFTimeInterval instanceDelay;//拷贝副本的3D变换@property CATransform3D instanceTransform;//拷贝副本的颜色变换@property(nullable) CGColorRef instanceColor;//每个拷贝副本的颜色偏移参数@property float instanceRedOffset;@property float instanceGreenOffset;@property float instanceBlueOffset;//每个拷贝副本的透明度偏移参数@property float instanceAlphaOffset; 例如，通过拷贝一个色块，使其产生平移排列： 1234567891011121314 CAReplicatorLayer *reLayer = [CAReplicatorLayer layer]; reLayer.position = CGPointMake(0, 0); CALayer * layer= [CALayer layer]; [reLayer addSublayer:layer]; [self.view.layer addSublayer:reLayer]; layer.bounds = CGRectMake(0, 0, 20, 20); layer.position = CGPointMake(30, 100); layer.backgroundColor = [UIColor redColor].CGColor; //每个副本向右平移25px reLayer.instanceTransform=CATransform3DMakeTranslation(25, 0, 0); //如果进行动画，副本延时一秒执行 reLayer.instanceDelay = 1; //拷贝十个副本 reLayer.instanceCount = 10; 效果如下： 四、CAShapeLayerCAShapeLayer是图形layer层，我们可以自定义这个层的形状。先来看其中我们可以使用的属性和方法： 1@property(nullable) CGPathRef path; path属性为CAShapeLayer设置一个边界路径，例如我们可以创建一个三角形的路径通过如下代码： 12345678 CAShapeLayer * layer = [CAShapeLayer layer]; layer.position=CGPointMake(0,0); CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, 0, 100, 100); CGPathAddLineToPoint(path, 0, 300, 100); CGPathAddLineToPoint(path, 0, 200, 200); CGPathAddLineToPoint(path, 0, 100, 100); layer.path=path; 仅仅有路径，不能将我们想要的形状画出来，下面一些属性可以对图形的一些基础属性进行设置： 12345678910111213141516171819202122232425262728293031323334353637383940//设置图形的填充颜色@property(nullable) CGColorRef fillColor;/*设置图形的填充规则 选项如下：非零填充 NSString *const kCAFillRuleNonZero; 奇偶填充 NSString *const kCAFillRuleEvenOdd;*/@property(copy) NSString *fillRule;//设置线条颜色@property(nullable) CGColorRef strokeColor;//设置线条的起点与终点 0-1之间@property CGFloat strokeStart;@property CGFloat strokeEnd;//设置线条宽度@property CGFloat lineWidth;//设置两条线段相交时锐角斜面长度@property CGFloat miterLimit;/*设置线条首尾的外观可选参数如下无形状 NSString *const kCALineCapButt; 圆形 NSString *const kCALineCapRound; 方形 NSString *const kCALineCapSquare;*/@property(copy) NSString *lineCap;/*设置线段的链接方式棱角 NSString *const kCALineJoinMiter; 平滑 NSString *const kCALineJoinRound; 折线 NSString *const kCALineJoinBevel;*/@property(copy) NSString *lineJoin; 修改一下上面的代码，如下： 1234567891011121314151617CAShapeLayer * layer = [CAShapeLayer layer]; layer.position=CGPointMake(0,0); CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, 0, 100, 100); CGPathAddLineToPoint(path, 0, 300, 100); CGPathAddLineToPoint(path, 0, 200, 200); CGPathAddLineToPoint(path, 0, 100, 100); layer.path=path; layer.fillColor= [UIColor redColor].CGColor; layer.fillRule = kCAFillRuleEvenOdd; layer.strokeColor = [UIColor blueColor].CGColor; layer.strokeStart =0; layer.strokeEnd =0.5; layer.lineWidth = 5; layer.miterLimit = 1; layer.lineJoin = kCALineJoinMiter; [self.view.layer addSublayer:layer]; 效果如下： 除此之外，我们还可以设置边界的线条为虚线，通过下面两个属性： 1234567 //设置线段的宽度为5px 间距为10px /* 这个数组中还可以继续添加，会循环进行设置 例如 5 2 1 3 则第一条线段5px，间距2px，第二条线段1px 间距3px再开始第一条线段 */ layer.lineDashPattern = @[@05,@10]; //设置从哪个位置开始 layer.lineDashPhase =5; 如下： 五、CATextLayerCATextLayer可以进行文本的绘制，属性方法如下： 123456789101112131415161718192021222324252627282930//渲染的文字字符串@property(nullable, copy) id string;//设置字体@property(nullable) CFTypeRef font;//设置字号@property CGFloat fontSize;//设置文字颜色@property(nullable) CGColorRef foregroundColor;//是否换行@property(getter=isWrapped) BOOL wrapped;/*设置截断模式 NSString * const kCATruncationNone; 截断前部分 NSString * const kCATruncationStart; 截断后部分 NSString * const kCATruncationEnd; 截断中间 NSString * const kCATruncationMiddle;*/@property(copy) NSString *truncationMode;/*设置文字对齐模式 NSString * const kCAAlignmentNatural; NSString * const kCAAlignmentLeft; NSString * const kCAAlignmentRight; NSString * const kCAAlignmentCenter; NSString * const kCAAlignmentJustified;*/@property(copy) NSString *alignmentMode; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之二——对CALayer的分析","slug":"156iOS开发CoreAnimation解读之二——对CALayer的分析","date":"2015-11-25T16:00:00.000Z","updated":"2021-07-05T08:06:55.510Z","comments":true,"path":"2015/11/26/156iOS开发CoreAnimation解读之二——对CALayer的分析/","link":"","permalink":"http://huishao.cc/2015/11/26/156iOS开发CoreAnimation解读之二——对CALayer的分析/","excerpt":"","text":"iOS开发CoreAnimation解读之二——对CALayer的分析一、UIView中的CALayer属性1.Layer专门负责view的视图渲染每一个UIView的对象中都有一个layer这样的属性，并且layer会负责view中有关图形绘制的相关操作，例如我们设置view的背景颜色和设置layer的背景颜色都是有效的，并且，设置view的背景色依然是通过layer来展示的，我们可以写如下的测试代码： 1234567 UIView * view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; view.backgroundColor = [UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; view2.layer.backgroundColor = view.layer.backgroundColor; [self.view addSubview:view]; [self.view addSubview:view2]; 可以看出，我们设置view的backgroundColor属性其实起作用的也是layer的backgroundColor。 2.自定义view默认layer属性的类UIView是很多视图类的父类，根据功能不同，会分出UIImageView，UIScrollerView，UITableView等，CALayer也相似，其也可以根据功能分出许多子类，还可以根据我们的需求自定义一个Layer类。UIView其中的layer默认是CALyer类，我们也可以通过重写View中的如下方法来使其创建我们需要的layer类： 12+(Class)layerClass&#123;&#125; 例如我们自定义一个View类，在自定义一个Layer类，是的自定义的View默认创建的layer是自定义的layer： 在MyView中重写上述方法： 123+(Class)layerClass&#123; return [MyLayer class];&#125; 在MyLayer中进行一些自定义： 12345678- (instancetype)init&#123; self = [super init]; if (self) &#123; self.backgroundColor = [UIColor redColor].CGColor; &#125; return self;&#125; 之后我们使用这个MyView的对象时，layer层的背景色就是红色的了。 二、几种系统的Layer类前边说过，和UIView相似，CALayer也很据功能衍生出许多子类，系统系统给我们可以使用的有如下几种： 1.CAEmitterLayerCoreAnimation框架中的CAEmitterLayer是一个粒子发射器系统，负责粒子的创建和发射源属性。通过它，我们可以轻松创建出炫酷的粒子效果。 2.CAGradientLayerCAGradientLayer可以创建出色彩渐变的图层效果，如下： 3.CAEAGLLayerCAEAGLLayer可以通过OpenGL ES来进行界面的绘制。 4.CAReplicatorLayerCAReplicatorLayer是一个layer容器，会对其中的subLayer进行复制和属性偏移，通过它，可以创建出类似倒影的效果，也可以进行变换复制，如下： 5.CAScrollLayerCAScrollLayer可以支持其上管理的多个子层进行滑动，但是只能通过代码进行管理，不能进行用户点按触发。 6.CAShapeLayerCAShapeLayer可以让我们在layer层是直接绘制出自定义的形状。 7.CATextLayerCATextLayer可以通过字符串进行文字的绘制。 8.CATiledLayerCATiledLayer类似瓦片视图，可以将绘制分区域进行，常用于一张大的图片的分不分绘制。 9.CATransformLayerCATransformLayer用于构建一些3D效果的图层。 三、设置与调整Layer层的内容设置层的内容有下面三种方式： 1.可以通过设置CGImage为layer的内容。 2.可以通过代理方法来动态修改或者绘制层的内容。 3.通过自定义CALayer对象来创建层的内容。 当你设置了Layer的内容后，例如设置了一张图片，内容的尺寸不一定会刚好和layer的尺寸合适，我们可以对其位置的调整，使其达到我们想要的效果，contentsGravity属性决定了内容对齐与填充方式，它可以分为两个方面： 1.不改变内容的原始大小 这种模式中不会改变内容的原始大小，如果层的尺寸小于内容的尺寸，则内容会被切割，如果层的尺寸大于内容的尺寸，多出的部分将会显示层的背景颜色。下面的这些设置方式为这种模式： 123456789101112131415161718CA_EXTERN NSString * const kCAGravityCenter __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTop __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottom __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTopLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTopRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottomLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottomRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0); 每个参数对应的对其模式如下图： 2.改变内容的尺寸大小 这种模式设置的实际上是一种填充方式，参数如下： 123456CA_EXTERN NSString * const kCAGravityResize __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityResizeAspect __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityResizeAspectFill __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0); 四、CALayer的接口应用总结1、创建与初始化layer相关123456//通过类方法创建并初始化一个layer+ (instancetype)layer;//初始化方法- (instancetype)init;//通过一个layer创建一个副本- (instancetype)initWithLayer:(id)layer; 2、渲染层layer与模型层layer在CALayer中，有如下两个属性，他们都返回一个CALayer的对象： 1234//渲染层layer- (nullable id)presentationLayer;//模型层layer- (id)modelLayer; 对于presentationLayer，这个属性不一定总会返回一个实体对象，只有当进行动画或者其他渲染的操作时，这个属性会返回一个在当前屏幕上的layer，不且每一次执行，这个对象都会不同，它是原layer的一个副本presentationLayer的modelLayer就是其实体layer层。 对于modelLayer，它会返回当前的存储信息的Layer，也是当前的layer对象，始终唯一。 3.一些属性与方法1+ (nullable id)defaultValueForKey:(NSString *)key; 上面这个属性用于设置layer中默认属性的值，我们可以在子类中重写这个方法来改变默认创建的layer的一些属性，例如如下代码，我们创建出来的layer就默认有红色的背景颜色： 123456+(id)defaultValueForKey:(NSString *)key&#123; if ([key isEqualToString:@&quot;backgroundColor&quot;]) &#123; return (id)[UIColor redColor].CGColor; &#125; return [super defaultValueForKey:key];&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//这个方法也只使用在子类中重写，用于设置在某些属性改变时是否进行layer重绘+ (BOOL)needsDisplayForKey:(NSString *)key;//子类重写这个方法设置属性是否可以被归档- (BOOL)shouldArchiveValueForKey:(NSString *)key;/*********************************************///设置layer尺寸@property CGRect bounds;//设置layer位置@property CGPoint position;//设置其在父layer中的层次，默认为0，这个值越大，层次越靠上@property CGFloat zPosition;//锚点@property CGPoint anchorPoint;//在Z轴上的锚点位置 3D变换时会有很大影响@property CGFloat anchorPointZ;//进行3D变换@property CATransform3D transform;//获取和设置CGAffineTransform变换- (CGAffineTransform)affineTransform;- (void)setAffineTransform:(CGAffineTransform)m;//设置layer的frame@property CGRect frame;//设置是否隐藏@property(getter=isHidden) BOOL hidden;//每个layer层有两面，这个属性确定是否两面都显示@property(getter=isDoubleSided) BOOL doubleSided;//是否进行y轴的方向翻转@property(getter=isGeometryFlipped) BOOL geometryFlipped;//获取当前layer内容y轴方向是否被翻转了- (BOOL)contentsAreFlipped;//父layer视图@property(nullable, readonly) CALayer *superlayer;//从其父layer层上移除- (void)removeFromSuperlayer;//所有子layer数组@property(nullable, copy) NSArray&lt;CALayer *&gt; *sublayers;//添加一个字layer- (void)addSublayer:(CALayer *)layer;//插入一个子layer- (void)insertSublayer:(CALayer *)layer atIndex:(unsigned)idx;//将一个子layer插入到最下面- (void)insertSublayer:(CALayer *)layer below:(nullable CALayer *)sibling;//将一个子layer插入到最上面- (void)insertSublayer:(CALayer *)layer above:(nullable CALayer *)sibling;//替换一个子layer- (void)replaceSublayer:(CALayer *)layer with:(CALayer *)layer2;//对其子layer进行3D变换@property CATransform3D sublayerTransform;//遮罩层layer@property(nullable, strong) CALayer *mask;//舍否进行bounds的切割，在设置圆角属性时会设置为YES@property BOOL masksToBounds;//下面这些方法用于坐标转换- (CGPoint)convertPoint:(CGPoint)p fromLayer:(nullable CALayer *)l;- (CGPoint)convertPoint:(CGPoint)p toLayer:(nullable CALayer *)l;- (CGRect)convertRect:(CGRect)r fromLayer:(nullable CALayer *)l;- (CGRect)convertRect:(CGRect)r toLayer:(nullable CALayer *)l;//返回包含某一点的最上层的子layer- (nullable CALayer *)hitTest:(CGPoint)p;//返回layer的bounds内是否包含某一点- (BOOL)containsPoint:(CGPoint)p;//设置layer的内容，一般会设置为CGImage的对象@property(nullable, strong) id contents;//获取内容的rect尺寸@property CGRect contentsRect;//设置内容的填充和对其方式，具体上面有说@property(copy) NSString *contentsGravity;//设置内容的缩放@property CGFloat contentsScale; 下面这个属性和内容拉伸相关： 1@property CGRect contentsCenter; 这个属性确定一个矩形区域，当内容进行拉伸或者缩放的时候，这一部分的区域是会被形变的，例如默认设置为(0,0,1,1)，则整个内容区域都会参与形变。如果我们设置为(0.25,0.25,0.5,0.5),那么只有中间0.5*0.5比例宽高的区域会被拉伸，四周都不会。 下面这两个属性用来设置缩放或拉伸的模式： 12345678910111213//设置缩小的模式@property(copy) NSString *minificationFilter;//设置放大的模式@property(copy) NSString *magnificationFilter;//缩放因子@property float minificationFilterBias;//模式参数如下//临近插值NSString * const kCAFilterNearest;//线性拉伸NSString * const kCAFilterLinear;//瓦片复制拉伸NSString * const kCAFilterTrilinear; 1234567891011121314151617//设置内容是否完全不透明@property(getter=isOpaque) BOOL opaque;//重新加载绘制内容- (void)display;//设置内容为需要重新绘制- (void)setNeedsDisplay;//设置某一区域内容需要重新绘制- (void)setNeedsDisplayInRect:(CGRect)r;//获取是否需要重新绘制- (BOOL)needsDisplay;//如果需要，进行内容重绘- (void)displayIfNeeded;//这个属性设置为YES，当内容改变时会自动调用- (void)setNeedsDisplay函数@property BOOL needsDisplayOnBoundsChange;//绘制与读取内容- (void)drawInContext:(CGContextRef)ctx;- (void)renderInContext:(CGContextRef)ctx; 1234567891011121314151617181920//设置背景颜色@property(nullable) CGColorRef backgroundColor;//设置圆角半径@property CGFloat cornerRadius;//设置边框宽度@property CGFloat borderWidth;//设置边框颜色@property(nullable) CGColorRef borderColor;//设置透明度@property float opacity;//设置阴影颜色@property(nullable) CGColorRef shadowColor;//设置阴影透明度@property float shadowOpacity;//设置阴影偏移量@property CGSize shadowOffset;//设置阴影圆角半径@property CGFloat shadowRadius;//设置阴影路径@property(nullable) CGPathRef shadowPath; 12345678910//添加一个动画对象 key值起到id的作用，通过key值，可以取到这个动画对象- (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key;//移除所有动画对象- (void)removeAllAnimations;//移除某个动画对象- (void)removeAnimationForKey:(NSString *)key;//获取所有动画对象的key值- (nullable NSArray&lt;NSString *&gt; *)animationKeys;//通过key值获取动画对象- (nullable CAAnimation *)animationForKey:(NSString *)key; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程","slug":"155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程","date":"2015-11-24T16:00:00.000Z","updated":"2021-07-05T08:05:08.423Z","comments":true,"path":"2015/11/25/155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程/","link":"","permalink":"http://huishao.cc/2015/11/25/155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程/","excerpt":"","text":"iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程一、引言众所周知，绚丽动画效果是iOS系统的一大特点，通过UIView层封装的动画，基本已经可以满足我们应用开发的所有需求，但若需要更加自由的控制动画的展示，我们就需要使用CoreAnimation框架中的一些类与方法。这里先附上前几篇与动画相关的博客地址，这一系列，我们抽出其中的CoreAnimation框架来详细解读。 UIViewAnimation动画的使用：http://my.oschina.net/u/2340880/blog/484457 UIView动画执行的另一种方式：http://my.oschina.net/u/2340880/blog/484538 UIView转场动画：http://my.oschina.net/u/2340880/blog/484669 CoreAnimation隐式动画的应用：http://my.oschina.net/u/2340880/blog/484793 粒子效果的使用：http://my.oschina.net/u/2340880/blog/485095 二、初识CoreAnimationCoreAnimation框架是基于OpenGL与CoreGraphics图像处理框架的一个跨平台的动画框架。简单来说，它使帮助我们将图像读取成位图，通过硬件的处理，实现动画效果。文档中的一张图片十分形象的描述了CoreAnimation与UIKit框架的关系： 在CoreAnimation中，大部分的动画效果都是通过Layer层来实现的，通过CALayer，我们可以组织复杂的层级结构。 在CoreAnimation中，大多数的动画效果是添加在图层属性的变化上，例如，改变图层的位置，大小，颜色，圆角半径等。Layer层并不决定视图的展现，它只是存储了视图的几何属性状态。 三、锚点对几何属性的影响关于Layer层，我们需要了解一个有关锚点的概念，锚点决定了图层的绘制位置以及动画展示时其参照的点，锚点的取值范围为0-1，锚点有两个地方在应用中会有很大影响： 1.layer层的position参照点始终和锚点重合 通过position决定了layer所在的位置，在Layer中，虽然也有frame这样的属性，但我们很少使用，一般我们会使用bounds和position确定Layer层的大小和位置。 2.锚点决定进行动作的参照点 例如一个旋转动作，锚点决定了层旋转的中心点，对于放大缩小的动作，锚点决定了放大或者缩小参照的中心点。 可以来看下边一组图： 上面两个矩形，frame和bounds都是一样的，第一个矩形的锚点位置为(0.5,0.5)，第二个为(0,0), 因此，两个矩形的position点是不同的，第一个是(100,100),第二个是(40,60)。再看当产生动作时锚点的影响： 现在就很好理解了，锚点的不同直接影响了动作产生的参照点。 通过CALayer的如下属性，我们可以设置锚点，注意x，y的取值范围都是0~1，代表所占宽度和高度的比例： 1@property CGPoint anchorPoint; 四、Layer与View之间的关系Layer是专门用于辅助我们绘制图像的层，它使支持三维坐标系的绘制的，通过每个坐标点与转换矩阵的运算，来决定最后绘制的状态，并且，Layer可以更高帧率的绘制动画效果。然而Layer与View依然有很大不同，首先，我们不可能只通过Layer来开发应用程序，Layer并没有接收事件和处理用户交互的能力，这些依然需要View来完成，每一个View中，都有一个Layer的属性来辅助进行图形的绘制。并且Layer是可以层级嵌套的，开发中，我们可以根据需求灵活选择。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS9新特性——堆叠视图UIStackView","slug":"154iOS9新特性——堆叠视图UIStackView","date":"2015-11-16T16:00:00.000Z","updated":"2021-07-05T08:03:07.184Z","comments":true,"path":"2015/11/17/154iOS9新特性——堆叠视图UIStackView/","link":"","permalink":"http://huishao.cc/2015/11/17/154iOS9新特性——堆叠视图UIStackView/","excerpt":"","text":"iOS9新特性——堆叠视图UIStackView一、引言随着autolayout的推广开来，更多的app开始使用自动布局的方式来构建自己的UI系统，autolayout配合storyBoard和一些第三方的框架，对于创建约束来说，已经十分方便，但是对于一些动态的线性布局的视图，我们需要手动添加的约束不仅非常多，而且如果我们需要插入或者移除其中的一些UI元素的时候，我们又要做大量的修改约束的工作，UIStackView正好可以解决这样的问题。 二、在storyBoard上初识StackViewUIStackView是一个管理一组堆叠视图的控制器类视图，所谓堆叠视图时一种平铺式的线性布局方式，不可重叠，布局方向也不可交错，如果你做过watchOS的开发，你会发现，其实StackView与watchOS中的group十分能相似。 例如，我们如果需要一个如下效果的布局，在屏幕的中间摆放几个大小一致的色块，无论屏幕朝向如何，其位置都不会变化，并且可以向其中添加和移除色块的数量： 首先，我们在ViewController中拉入一个stackView： 将一些属性设置如下： Axis是设置布局的方向，有水平和垂直两种方式，一个StackView只能选择一种布局模式。 Alignment是选择其管理视图的对齐模式，我们这里选择充满。 Distribution是设置其管理视图的排列方式，我们选择等宽充满。 Spacing是设置视图之间的间距，设置为10. 之后有一点需要注意，stackView用于布局其内部管理的视图，对于它本身，我们还需要添加一些约束，将它约束在屏幕的中间。 我们向其中拖入任意数量的view，设置不同的颜色，就实现了我们想要的效果，并且可以随意动态删除和添加其中的view数量，不需要改变约束。 三、从代码学习UIStackView通过代码创建一个UIStackView也非常简单，首先，我们先通过代码实现上面的效果： 123456789101112131415161718 NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i =0 ; i&lt;5; i++) &#123; UIView * view = [[UIView alloc]init]; view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [array addObject:view]; &#125; UIStackView * stackView = [[UIStackView alloc]initWithArrangedSubviews:array]; [self.view addSubview:stackView]; [stackView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(self.view.mas_centerX); make.centerY.equalTo(self.view.mas_centerY); make.leading.equalTo(self.view.mas_leading).offset(20); make.trailing.equalTo(self.view.mas_trailing).offset(-20); make.size.height.equalTo(@100); &#125;]; stackView.axis = UILayoutConstraintAxisHorizontal; stackView.distribution = UIStackViewDistributionFillEqually; stackView.alignment = UIStackViewAlignmentFill; 效果图如下： 我们的布局没有问题，并且可以动态的改变其中view的个数，使用如下方法添加一个view： 123 UIView * newView = [[UIView alloc]init]; newView.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [stackView addArrangedSubview:newView]; 与之相对，我们可以使用下面的方法移除一个view： 12 UIView * view = [stackView arrangedSubviews].lastObject; [stackView removeArrangedSubview:view]; 特别注意：addArrangedSubview和addSubview有很大的区别，使用前者是将试图添加进StackView的布局管理，后者只是简单的加在试图的层级上，并不接受StackView的布局管理。 技巧：因为StackView继承于UIView，因此在布局改变的时候，我们可以使用UIView层的动画，如下： 12345 //在添加view的时候会有动画效果，移除的时候没有 [stackView addArrangedSubview:newView]; [UIView animateWithDuration:1 animations:^&#123; [stackView layoutIfNeeded]; &#125;]; 四、再来深入理解下UIStackView通过上面的介绍，我们已经基本了解了StackView的使用和特点，下面我们再来仔细介绍一下与其相关的属性和方法的使用，使我们能够更加得心应手。 有关被管理视图的添加与移除： 12345678910//初始化方法，通过数组传入被管理的视图- (instancetype)initWithArrangedSubviews:(NSArray&lt;__kindof UIView *&gt; *)views; //获取被管理的所有视图@property(nonatomic,readonly,copy) NSArray&lt;__kindof UIView *&gt; *arrangedSubviews;//添加一个视图进行管理- (void)addArrangedSubview:(UIView *)view;//移除一个被管理的视图- (void)removeArrangedSubview:(UIView *)view;//在指定位置插入一个被管理的视图- (void)insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex; 与StackView布局设置相关： 1.布局模式： 1@property(nonatomic) UILayoutConstraintAxis axis; 上面这个属性用于设置布局的模型，枚举如下： 1234567//stackView只有两种布局模式 水平和竖直typedef NS_ENUM(NSInteger, UILayoutConstraintAxis) &#123; //水平布局 UILayoutConstraintAxisHorizontal = 0, //竖直布局 UILayoutConstraintAxisVertical = 1&#125;; 2.对齐模式： 1@property(nonatomic) UIStackViewAlignment alignment; 这个属性用于设置控件的对其模式，枚举如下： 123456789101112131415161718typedef NS_ENUM(NSInteger, UIStackViewAlignment) &#123; //水平布局时为高度充满，竖直布局时为宽度充满 UIStackViewAlignmentFill, //前边对其 UIStackViewAlignmentLeading, //顶部对其 UIStackViewAlignmentTop = UIStackViewAlignmentLeading, //第一个控件文字的基线对其 水平布局有效 UIStackViewAlignmentFirstBaseline, //中心对其 UIStackViewAlignmentCenter, //后边对其 UIStackViewAlignmentTrailing, //底部对其 UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing, //基线对其，水平布局有效 UIStackViewAlignmentLastBaseline, &#125; NS_ENUM_AVAILABLE_IOS(9_0); 在上面的例子中，我们设置了对其方式为充满，这样的话，我们就不需要再做过多控件尺寸的约束，如果我们被管理的控件高度或者宽度不一，我们可以设置中心对其，这样的话，我们还需要为每个控件添加一个宽度或者高度的约束，如下： 12345678910111213141516171819202122 NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i =0 ; i&lt;5; i++) &#123; UIView * view = [[UIView alloc]init]; view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; float height = arc4random()%90+10; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo([NSNumber numberWithFloat:height]); &#125;]; [array addObject:view]; &#125; stackView = [[UIStackView alloc]initWithArrangedSubviews:array]; [self.view addSubview:stackView]; [stackView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(self.view.mas_centerX); make.centerY.equalTo(self.view.mas_centerY); make.leading.equalTo(self.view.mas_leading).offset(20); make.trailing.equalTo(self.view.mas_trailing).offset(-20); make.size.height.equalTo(@100); &#125;]; stackView.axis = UILayoutConstraintAxisHorizontal; stackView.distribution = UIStackViewDistributionFillEqually; stackView.alignment = UIStackViewAlignmentCenter; 效果如下： 这样，参差不齐的控件布局我们也可以轻松完成。 3.排列方式 1@property(nonatomic) UIStackViewDistribution distribution; 排列方式的枚举如下： 123456789101112typedef NS_ENUM(NSInteger, UIStackViewDistribution) &#123; //充满，当只有一个控件时可以使用 UIStackViewDistributionFill = 0, //平分充满，每个控件占据相同尺寸排列充满 UIStackViewDistributionFillEqually, //会优先按照约束的尺寸进行排列，如果没有充满，会拉伸最后一个排列的控件充满 UIStackViewDistributionFillProportionally, //等间距排列 UIStackViewDistributionEqualSpacing, //中心距离相等 UIStackViewDistributionEqualCentering,&#125; NS_ENUM_AVAILABLE_IOS(9_0); 注意，除了我们选择fill属性时不需约束控件视图的尺寸，其他都需要进行约束，例如如果我们选择等间距，我把改成如下代码： 123456 [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo([NSNumber numberWithFloat:height]); make.width.equalTo(@50); &#125;]; stackView.distribution = UIStackViewDistributionEqualSpacing; 效果如下： 4.其他 123456//设置最小间距@property(nonatomic) CGFloat spacing;//设置布局时是否参照基线@property(nonatomic,getter=isBaselineRelativeArrangement) BOOL baselineRelativeArrangement;//设置布局时是否以控件的LayoutMargins为标准，默认为NO，是以控件的bounds为标准@property(nonatomic,getter=isLayoutMarginsRelativeArrangement) BOOL layoutMarginsRelativeArrangement; 五、UIStackView的嵌套一个StackView不允许我们进行水平和竖直的交叉布局，但是我们可以通过嵌套的方式来实现复杂的布局效果，比如我们实现一个类似电影表标签，可以使用水平布局的StackView中嵌套一个竖直布局的StackView： 十分轻松就可以实现如下的效果： 看到了吧，通过StackView，我们没有添加过多的约束，使我们布局起来更加轻松了。如果你常常使用storyBoard进行开发，还有一个小技巧可以方便的将两个控件整合到一个StackView中，按住command，选中两个控件，之后点击右下角的如下图标，系统会自动帮我们生成一个StackView，将选中的两个控件整合进去，很酷吧！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发中标签控制器的使用——UITabBarController","slug":"153iOS开发中标签控制器的使用——UITabBarController","date":"2015-11-12T16:00:00.000Z","updated":"2021-07-05T08:02:08.233Z","comments":true,"path":"2015/11/13/153iOS开发中标签控制器的使用——UITabBarController/","link":"","permalink":"http://huishao.cc/2015/11/13/153iOS开发中标签控制器的使用——UITabBarController/","excerpt":"","text":"iOS开发中标签控制器的使用——UITabBarController一、引言与导航控制器相类似，标签控制器也是用于管理视图控制器的一个UI控件，在其内部封装了一个标签栏，与导航不同的是，导航的管理方式是纵向的，采用push与pop切换控制器，标签的管理是横向的，通过标签的切换来改变控制器，一般我们习惯将tabBar作为应用程序的根视图控制器，在其中添加导航，导航中在对ViewController进行管理。 二、创建一个标签控制器通过如下的步骤，我们可以很简便的创建一个TabBarController： 12345678910111213UITabBarController * tabBar= [[UITabBarController alloc]init]; NSMutableArray * controllerArray = [[NSMutableArray alloc]init]; for (int i=0; i&lt;4; i++) &#123; UIViewController * con = [[UIViewController alloc]init]; [con loadViewIfNeeded]; con.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; con.tabBarItem.image = [UIImage imageNamed:@&quot;btn_publish_face_a.png&quot;]; con.tabBarItem.title=[NSString stringWithFormat:@&quot;%d&quot;,i+1]; con.title = [NSString stringWithFormat:@&quot;%d&quot;,i+1]; [controllerArray addObject:con]; &#125; tabBar.viewControllers = controllerArray; [self presentViewController:tabBar animated:YES completion:nil]; 通过点击下面的标签按钮，可以很方便的切换控制器。如果我们的控制器数超过4个，系统会被我们创建一个more的导航，并且可以通过系统自带的编辑来调整控制器的顺序，如下： 三、UITabBarController的属性和方法123456789101112131415//管理的viewController数组@property(nullable, nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;- (void)setViewControllers:(NSArray&lt;__kindof UIViewController *&gt; * __nullable)viewControllers animated:(BOOL)animated;//选中的ViewControlle@property(nullable, nonatomic, assign) __kindof UIViewController *selectedViewController;//通过编号设置选中ViewController@property(nonatomic) NSUInteger selectedIndex;//当viewController大于4个时，获取&quot;更多&quot;标签的导航控制器@property(nonatomic, readonly) UINavigationController *moreNavigationController; //这个属性设置的是可以进行自定义排列顺序的视图控制器，如上面第二张图中的，默认是全部@property(nullable, nonatomic, copy) NSArray&lt;__kindof UIViewController *&gt; *customizableViewControllers;//标签控制器中分装的标签栏@property(nonatomic,readonly) UITabBar *tabBar NS_AVAILABLE_IOS(3_0);//代理@property(nullable, nonatomic,weak) id&lt;UITabBarControllerDelegate&gt; delegate; 四、关于标签栏TabBar通过自定义标签栏的一些属性，使我们可以更加灵活的使用tabBar。 1、UITabBar属性和方法设置标签： 1234@property(nullable,nonatomic,copy) NSArray&lt;UITabBarItem *&gt; *items; //设置选中的标签 @property(nullable,nonatomic,assign) UITabBarItem *selectedItem; - (void)setItems:(nullable NSArray&lt;UITabBarItem *&gt; *)items animated:(BOOL)animated; 设置自定义标签顺序： 123456//调用这个方法会弹出一个类似上面第二张截图的控制器，我们可以交换标签的布局顺序- (void)beginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //完成标签布局- (BOOL)endCustomizingAnimated:(BOOL)animated; //是否正在自定义标签布局- (BOOL)isCustomizing; 设置tabBar颜色相关： 1234//设置渲染颜色，会影响选中字体和图案的渲染@property(null_resettable, nonatomic,strong) UIColor *tintColor;//设置导航栏的颜色@property(nullable, nonatomic,strong) UIColor *barTintColor; 设置背景图案： 123456//设置导航栏背景图案@property(nullable, nonatomic,strong) UIImage *backgroundImage;//设置选中一个标签时，标签背后的选中提示图案 这个会出现在设置的item图案的后面@property(nullable, nonatomic,strong) UIImage *selectionIndicatorImage;//设置阴影的背景图案@property(nullable, nonatomic,strong) UIImage *shadowImage TabBar中标签的宏观属性： 123456789101112//设置标签item的位置模式@property(nonatomic) UITabBarItemPositioning itemPositioning;//枚举如下typedef NS_ENUM(NSInteger, UITabBarItemPositioning) &#123; UITabBarItemPositioningAutomatic,//自动 UITabBarItemPositioningFill,//充满 UITabBarItemPositioningCentered,//中心&#125; NS_ENUM_AVAILABLE_IOS(7_0);//设置item宽度@property(nonatomic) CGFloat itemWidth;//设置item间距@property(nonatomic) CGFloat itemSpacing; 与导航栏类似，也可以设置tabBar的风格和透明效果： 1234//风格 分黑白两种@property(nonatomic) UIBarStyle barStyle;//是否透明效果@property(nonatomic,getter=isTranslucent) BOOL translucent; 2、UITabBarDelegate123456789//选中标签时调用- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item;//将要开始编辑标签时- (void)tabBar:(UITabBar *)tabBar willBeginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //已经开始编辑标签时 - (void)tabBar:(UITabBar *)tabBar didBeginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //将要进入编辑状态时- (void)tabBar:(UITabBar *)tabBar willEndCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items changed:(BOOL)changed; //已经进入编辑状态时- (void)tabBar:(UITabBar *)tabBar didEndCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items changed:(BOOL)changed; 五、再看UITabBarItem和NavigationItem类似，标签栏上的item也可以自定义，一些方法如下。 初始化方法： 12345//通过标题和图案进行创建- (instancetype)initWithTitle:(nullable NSString *)title image:(nullable UIImage *)image tag:(NSInteger)tag;- (instancetype)initWithTitle:(nullable NSString *)title image:(nullable UIImage *)image selectedImage:(nullable UIImage *)selectedImage;//创建系统类型的- (instancetype)initWithTabBarSystemItem:(UITabBarSystemItem)systemItem tag:(NSInteger)tag; UITabBarSystemItem的枚举如下： 1234567891011121314typedef NS_ENUM(NSInteger, UITabBarSystemItem) &#123; UITabBarSystemItemMore,//更多图标 UITabBarSystemItemFavorites,//最爱图标 UITabBarSystemItemFeatured,//特征图标 UITabBarSystemItemTopRated,//高级图标 UITabBarSystemItemRecents,//最近图标 UITabBarSystemItemContacts,//联系人图标 UITabBarSystemItemHistory,//历史图标 UITabBarSystemItemBookmarks,//图书图标 UITabBarSystemItemSearch,//查找图标 UITabBarSystemItemDownloads,//下载图标 UITabBarSystemItemMostRecent,//记录图标 UITabBarSystemItemMostViewed,//全部查看图标&#125;; UITabBarItem常用属性： 12//设置选中图案@property(nullable, nonatomic,strong) UIImage *selectedImage; 下面这个属性可以设置item的头标文字： 1 con.tabBarItem.badgeValue = @&quot;1&quot;; 12//设置标题的位置偏移@property (nonatomic, readwrite, assign) UIOffset titlePositionAdjustment; 由于UITabBarItem是继承于UIBarItem，还有下面这个属性可以设置使用： 12345678910111213//标题@property(nullable, nonatomic,copy) NSString *title; //图案 @property(nullable, nonatomic,strong) UIImage *image; //横屏时的图案 @property(nullable, nonatomic,strong) UIImage *landscapeImagePhone;//图案位置偏移@property(nonatomic) UIEdgeInsets imageInsets; //横屏时的图案位置偏移@property(nonatomic) UIEdgeInsets landscapeImagePhoneInsets ;//设置和获取标题的字体属性- (void)setTitleTextAttributes:(nullable NSDictionary&lt;NSString *,id&gt; *)attributes forState:(UIControlState)state;- (nullable NSDictionary&lt;NSString *,id&gt; *)titleTextAttributesForState:(UIControlState)state; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS自定义的emoji表情键盘","slug":"152iOS自定义的emoji表情键盘","date":"2015-11-10T16:00:00.000Z","updated":"2021-07-05T07:59:54.443Z","comments":true,"path":"2015/11/11/152iOS自定义的emoji表情键盘/","link":"","permalink":"http://huishao.cc/2015/11/11/152iOS自定义的emoji表情键盘/","excerpt":"","text":"iOS自定义的表情键盘一、关于emoji表情随着iOS系统版本的升级，对原生emoji表情的支持也越来越丰富。emoji表情是unicode码中为表情符号设计的一组编码，当然，还有独立于unicode的另一套编码SBUnicode，在OS系统中，这两种编码都有很好的支持。UI系统会自动帮我们将编码转义成表情符号，例如用SBUnicode如下代码： 1234 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; label.font = [UIFont systemFontOfSize:25]; label.text = @&quot;\\uE056&quot;; [self.view addSubview:label]; 就会在屏幕上出现一个笑脸： 二、开发表情键盘的思路首先为了实现跨平台，无论iOS端，andorid端还是web端，都要有一个相同的标准，这个标准就可以是国际Unicode编码，我们的思路是将表情文字进行unicode编码后再进行传输，因此，有两中方式，一种是通过自定义一套表情切图，将其与unicode码一一对应，在转码的时候，我们一一遍历，转换成unicode后进行传输，这样的好处是我们可以保证所有平台所能使用的表情统一。在iOS端，可以有另一种方式，通过上面我们知道，通过SBUnicode码我们可以在客户端显示表情符号，并且这个码的排列是十分有规律的，通过这个特点，我们可以通过遍历SBUnicode码的范围进行表情的创建，省去的图片素材的麻烦。 iOS中可用的表情unicode范围是：0xE001~0xE05A,0xE101~0xE15A, 0xE201~0xE253,0xE401~0xE44C,0xE501~0xE537。 我们可以通过遍历的方法，将其都加入数据源数组中： 1234567891011int emojiRangeArray[10] = &#123;0xE001,0xE05A,0xE101,0xE15A,0xE201,0xE253,0xE401,0xE44C,0xE501,0xE537&#125;; for (int j = 0 ; j&lt;10 ; j+=2 ) &#123; int startIndex = emojiRangeArray[j]; int endIndex = emojiRangeArray[j+1]; for (int i = startIndex ; i&lt;= endIndex ; i++ ) &#123; //添加到数据源数组 [dataArray addObject:[NSString stringWithFormat:@&quot;%C&quot;, (unichar)i]]; &#125; &#125; 键盘的摆放，可以通过collectionView来做，十分方便： 1234567891011121314151617181920212223242526 //为了摆放分页控制器，创建一个背景view bgView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 200)]; //分页控制器 pageControlBottom = [[UIPageControl alloc]initWithFrame:CGRectMake(0, 170, [UIScreen mainScreen].bounds.size.width, 20)]; [bgView addSubview:pageControlBottom]; //collectionView布局 UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; //水平布局 layout.scrollDirection=UICollectionViewScrollDirectionHorizontal; //设置每个表情按钮的大小为30*30 layout.itemSize=CGSizeMake(30, 30); //计算每个分区的左右边距 float xOffset = (kscreenWidth-7*30-10*6)/2; //设置分区的内容偏移 layout.sectionInset=UIEdgeInsetsMake(10, xOffset, 10, xOffset); scrollView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 160) collectionViewLayout:layout]; //打开分页效果 scrollView.pagingEnabled = YES; //设置行列间距 layout.minimumLineSpacing=10; layout.minimumInteritemSpacing=5; scrollView.delegate=self; scrollView.dataSource=self; scrollView.backgroundColor = bgView.backgroundColor; [bgView addSubview:scrollView]; 在collectionView的回调方法中，处理如下： 1234567891011121314151617181920212223242526272829303132333435363738//每页28个表情-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; if (((dataArray.count/28)+(dataArray.count%28==0?0:1))!=section+1) &#123; return 28; &#125;else&#123; return dataArray.count-28*((dataArray.count/28)+(dataArray.count%28==0?0:1)-1); &#125; &#125;//返回页数-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return (dataArray.count/28)+(dataArray.count%28==0?0:1);&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;biaoqing&quot; forIndexPath:indexPath]; for (int i=cell.contentView.subviews.count; i&gt;0; i--) &#123; [cell.contentView.subviews[i-1] removeFromSuperview]; &#125; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; label.font = [UIFont systemFontOfSize:25]; label.text =dataArray[indexPath.row+indexPath.section*28] ; [cell.contentView addSubview:label]; return cell;&#125;-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSString * str = dataArray[indexPath.section*28+indexPath.row]; //这里手动将表情符号添加到textField上 &#125;//翻页后对分页控制器进行更新-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat contenOffset = scrollView.contentOffset.x; int page = contenOffset/scrollView.frame.size.width+((int)contenOffset%(int)scrollView.frame.size.width==0?0:1); pageControlBottom.currentPage = page;&#125; 三、切换系统键盘和自定义的表情键盘UITextField和UITextView都会有下面这个属性和方法： 12@property (nullable, readwrite, strong) UIView *inputView; - (void)reloadInputViews; inputView我们可以设置textView和textField成为第一响应时的弹出附件，如果我们不设置或者设置为nil，则会弹出系统键盘，reloadInputView方法可以使我们刷新这个附件视图，通过这两个，我们可以非常轻松的实现键盘的切换，比如我们在一个出发方法中如下处理： 1234567891011121314151617-(void)imageViewTap&#123; if (![_publishContent isFirstResponder]) &#123; return; &#125; if (isEmoji==NO) &#123; isEmoji=YES; //呼出表情 _textView.inputView=bgView; [_textView reloadInputViews]; &#125;else&#123; isEmoji=NO; _textView.inputView=nil; [_textView reloadInputViews]; &#125; &#125; 效果如下： 追注：测试上面的SBUnicode码在模拟器上可以正常显示，真机并不能识别，可以通过将表情符全部添加到一个plist文件中，通过文件读取来创建键盘的方式进行真机上的开发。plist文件地址如下： http://pan.baidu.com/s/1o6AdkBw 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列四——导航控制器UINavigationController","slug":"151iOS开发UINavigation系列四——导航控制器UINavigationController","date":"2015-11-09T16:00:00.000Z","updated":"2021-07-05T07:57:48.864Z","comments":true,"path":"2015/11/10/151iOS开发UINavigation系列四——导航控制器UINavigationController/","link":"","permalink":"http://huishao.cc/2015/11/10/151iOS开发UINavigation系列四——导航控制器UINavigationController/","excerpt":"","text":"iOS开发UINavigation系列四——导航控制器UINavigationController一、引言在前面的博客中，我么你介绍了UINavigationBar，UINavigationItem和UIToolBar，UINavigationController是将这些控件和UIViewController紧密的结合了起来，使用导航，我们的应用程序层次会更加分明，对controller的管理也更加方便。前几篇博客地址如下： UINavigationBar：http://my.oschina.net/u/2340880/blog/527706 UINavigationItem：http://my.oschina.net/u/2340880/blog/527781 UIToolBar：http://my.oschina.net/u/2340880/blog/528168 二、导航控制器的创建和controller的管理导航控制器是一个堆栈结构，只是其中管理的对象是controller，通过push与pop进行controller的切换，我们有两种方式可以创建导航控制器： 1234//通过一个自定义的导航栏和工具栏创建导航控制器- (instancetype)initWithNavigationBarClass:(nullable Class)navigationBarClass toolbarClass:(nullable Class)toolbarClass;//使用系统默认的导航栏和工具栏，通过一个根视图创建导航控制器- (instancetype)initWithRootViewController:(UIViewController *)rootViewController; 通过以下方法对视图控制器进行管理操作： 12345678910//设置管理的视图控制器- (void)setViewControllers:(NSArray&lt;UIViewController *&gt; *)viewControllers animated:(BOOL)animated;//压入新的视图控制器- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;//弹出一个视图控制器 返回的是pop的controller- (nullable UIViewController *)popViewControllerAnimated:(BOOL)animated;//弹出到某个视图控制器 返回所有pop的controller- (nullable NSArray&lt;__kindof UIViewController *&gt; *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated; //直接pop到根视图控制器，返回所有被pop的controller- (nullable NSArray&lt;__kindof UIViewController *&gt; *)popToRootViewControllerAnimated:(BOOL)animated; 三、导航控制器中的常用方法和属性1234//返回栈顶的controller@property(nullable, nonatomic,readonly,strong) UIViewController *topViewController; //返回显示的controller@property(nullable, nonatomic,readonly,strong) UIViewController *visibleViewController; 上面两个方法的区别在于，topViewController是返回被push出的最后一个controller，但是如果之后又有present进行莫泰跳转，visibleViewController会返回当前显示的controller。例如A-push-B-present-C，则topViewController会返回B，visibleViewController会返回C。 123456789101112131415//返回堆栈中所有的controller@property(nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;//设置隐藏导航栏@property(nonatomic,getter=isNavigationBarHidden) BOOL navigationBarHidden;- (void)setNavigationBarHidden:(BOOL)hidden animated:(BOOL)animated;//导航栏对象，只读属性@property(nonatomic,readonly) UINavigationBar *navigationBar;//隐藏状态栏@property(nonatomic,getter=isToolbarHidden) BOOL toolbarHidden NS_AVAILABLE_IOS(3_0);- (void)setToolbarHidden:(BOOL)hidden animated:(BOOL)animated;//状态栏对象@property(null_resettable,nonatomic,readonly) UIToolbar *toolbar;//导航中的返回手势对象//iOS7之后，在导航中右划会进行pop操作，设置这个的enable可以控制设置手势是否失效@property(nullable, nonatomic, readonly) UIGestureRecognizer *interactivePopGestureRecognizer; 四、iOS8后导航的新特性1234567891011121314//这个方法是为了iOS方法的命名统一，在导航中，其作用和push一样- (void)showViewController:(UIViewController *)vc sender:(nullable id)sender;//弹出键盘的时候隐藏导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsWhenKeyboardAppears;//屏幕滑动的时候隐藏导航栏，常用于tableView,上滑隐藏导航栏，下滑显示，带动画效果@property (nonatomic, readwrite, assign) BOOL hidesBarsOnSwipe;//滑动隐藏导航栏的手势@property (nonatomic, readonly, strong) UIPanGestureRecognizer *barHideOnSwipeGestureRecognizer;//横屏的时候隐藏导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsWhenVerticallyCompact;//敲击屏幕可以隐藏与显示导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsOnTap;//敲击屏幕的手势@property (nonatomic, readonly, assign) UITapGestureRecognizer *barHideOnTapGestureRecognizer; iOS8中增加的这些方法，不得不说着实在用户体验生进了一大步，从中也可以看出apple对于用户体验度的用心。 五、UINavigationDelegate导航控制器还提供了一些代理回调方法，如下： 1234567891011//视图将要展示时调用的方法- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated;//视图已经展示时调用的方法- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated;//设置方法设置导航控制器支持的设备方向- (UIInterfaceOrientationMask)navigationControllerSupportedInterfaceOrientations:(UINavigationController *)navigationController NS_AVAILABLE_IOS(7_0);//这个方法设置导航控制器的首选设备方向- (UIInterfaceOrientation)navigationControllerPreferredInterfaceOrientationForPresentation:(UINavigationController *)navigationController NS_AVAILABLE_IOS(7_0);//下面两个方法可以对导航的转场动画进行设置- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController;- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC ; 六、与UIViewController相关当一个controller被添加到导航中后，系统会为它分配一些属性，如下： 123456//当前controller对应的导航项@property(nonatomic,readonly,strong) UINavigationItem *navigationItem;//push的时候隐藏底部栏，如push后隐藏tabbar@property(nonatomic) BOOL hidesBottomBarWhenPushed;//管理它的导航控制器@property(nullable, nonatomic,readonly,strong) UINavigationController *navigationController; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列三——工具栏UIToolBar","slug":"150iOS开发UINavigation系列三——工具栏UIToolBar","date":"2015-11-08T16:00:00.000Z","updated":"2021-07-05T07:56:21.743Z","comments":true,"path":"2015/11/09/150iOS开发UINavigation系列三——工具栏UIToolBar/","link":"","permalink":"http://huishao.cc/2015/11/09/150iOS开发UINavigation系列三——工具栏UIToolBar/","excerpt":"","text":"iOS开发UINavigation系列三——工具栏UIToolBariOS中除了UINavinationBar之外，还有工具栏UIToolBar可以供我们使用，工具栏和导航栏十分类似，只是功能更加简单，工具栏中也有UIBarButtonItem按钮，在前两篇博客中，对导航栏和导航项都进行的讨论，地址如下： UINavigationBar：http://my.oschina.net/u/2340880/blog/527706 UINavigationItem:http://my.oschina.net/u/2340880/blog/527781 导航栏一般会出现在视图的头部，与之相对，工具栏一般会出现在视图的的底部，上面可以填充一些按钮，提供给用户一些操作。创建一个工具栏如下： 123 self.view.backgroundColor = [UIColor grayColor]; UIToolbar * tool = [[UIToolbar alloc]initWithFrame:CGRectMake(0, self.view.frame.size.height-40, 320, 40)]; [self.view addSubview:tool]; 下面是UIToolBar中的一些方法，其中大部分在UINavigationBar中都有涉及，这里只做简单的介绍： 1234567891011121314151617//工具栏的风格，和导航栏类似，有黑白两种@property(nonatomic) UIBarStyle barStyle; //设置工具栏上按钮数组@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *items; //设置工具栏是否透明@property(nonatomic,assign,getter=isTranslucent) BOOL translucent; //设置工具栏按钮- (void)setItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated; //设置item风格颜色@property(null_resettable, nonatomic,strong) UIColor *tintColor;//设置工具栏背景色@property(nullable, nonatomic,strong) UIColor *barTintColor;//设置工具栏背景和阴影图案- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;- (nullable UIImage *)backgroundImageForToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;- (void)setShadowImage:(nullable UIImage *)shadowImage forToolbarPosition:(UIBarPosition)topOrBottom;- (nullable UIImage *)shadowImageForToolbarPosition:(UIBarPosition)topOrBottom; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列一——导航栏UINavigtionBar","slug":"148iOS开发UINavigation系列一——导航栏UINavigtionBar","date":"2015-11-07T16:00:00.000Z","updated":"2021-07-05T07:53:24.699Z","comments":true,"path":"2015/11/08/148iOS开发UINavigation系列一——导航栏UINavigtionBar/","link":"","permalink":"http://huishao.cc/2015/11/08/148iOS开发UINavigation系列一——导航栏UINavigtionBar/","excerpt":"","text":"iOS开发UINavigation系列一——导航栏UINavigtionBar一、导航栏的使用在iOS开发中，我们通常会使用导航控制器，导航控制器中封装了一个UINavigationBar，实际上，我们也可以在不使用导航控制器的前提下，单独使用导航栏，在UINavigationBar中，也有许多我们可以定制的属性，用起来十分方便。 二、UINavigationBar的创建和风格类型导航栏继承于UIView，所以我们可以像创建普通视图那样创建导航栏，比如我们创建一个高度为80的导航栏，将其放在ViewController的头部，代码如下： 12UINavigationBar *bar = [[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 80)];[self.view addSubview:bar]; 效果如下： 我们也可以设置导航栏的风格属性，从iOS6之后，UINavigationBar默认为半透明的样式，从上面也可以看出，白色的导航栏下面透出些许背景的红色。导航栏的风格属性可以通过下面的属性来设置： 1@property(nonatomic,assign) UIBarStyle barStyle; UIBarStyle是一个枚举，其中大部分的样式都已弃用，有效果的只有如下两个： 1234typedef NS_ENUM(NSInteger, UIBarStyle) &#123; UIBarStyleDefault = 0,//默认 UIBarStyleBlack = 1,//黑色&#125; 默认的风格就是我们上面看到的白色的风格，黑色的风格效果瑞如下： 三、导航栏常用属性和方法从上面我们可以看到，iOS6后导航栏默认都是半透明的，我们可以通过下面的bool值来设置这个属性，设置为NO，则导航栏不透明，默认为YES： 1@property(nonatomic,assign,getter=isTranslucent) BOOL translucent; 下面一些方法用于设置NavigationBar及上面item的颜色相关属性： 1@property(null_resettable, nonatomic,strong) UIColor *tintColor; tintColor这个属性会影响到导航栏上左侧pop按钮的图案颜色和字体颜色，系统默认是如下颜色： 1@property(nullable, nonatomic,strong) UIColor *barTintColor; BarTintColor用于设置导航栏的背景色，这个属性被设置后，半透明的效果将失效： 12- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;- (nullable UIImage *)backgroundImageForBarMetrics:(UIBarMetrics)barMetrics; 上面两个方法用于设置和获取导航栏的背景图案，这里需要注意，默认背景图案是不做缩放处理的，所以我们使用的图片尺寸要和导航栏尺寸匹配，这里面还有一个UIBarMetrics参数，这个参数设置设备的状态，如下： 1234typedef NS_ENUM(NSInteger, UIBarMetrics) &#123; UIBarMetricsDefault,//正常竖屏状态 UIBarMetricsCompact,//横屏状态&#125;; 1234//设置导航栏的阴影图片@property(nullable, nonatomic,strong) UIImage *shadowImage;//设置导航栏的标题字体属性@property(nullable,nonatomic,copy) NSDictionary&lt;NSString *,id&gt; *titleTextAttributes; 标题字体属性会影响到导航栏的中间标题，如下： 1 bar.titleTextAttributes = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;; 我们也可以通过下面的属性设置导航栏标题的竖直位置偏移： 12- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics;- (CGFloat)titleVerticalPositionAdjustmentForBarMetrics:(UIBarMetrics)barMetrics; 还有一个细节，导航栏左侧pop按钮的图案默认是一个箭头，我们可以使用下面的方法修改： 12@property(nullable,nonatomic,strong) UIImage *backIndicatorImage;@property(nullable,nonatomic,strong) UIImage *backIndicatorTransitionMaskImage; 四、导航栏中item的push与pop操作UINavigationBar上面不只是简单的显示标题，它也将标题进行了堆栈的管理，每一个标题抽象为的对象在iOS系统中是UINavigationItem对象，我们可以通过push与pop操作管理item组。 123456789101112//向栈中添加一个item，上一个item会被推向导航栏的左侧，变为pop按钮，会有一个动画效果- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;//pop一个item- (nullable UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; //当前push到最上层的item@property(nullable, nonatomic,readonly,strong) UINavigationItem *topItem;//仅次于最上层的item，一般式被推向导航栏左侧的item@property(nullable, nonatomic,readonly,strong) UINavigationItem *backItem;//获取堆栈中所有item的数组@property(nullable,nonatomic,copy) NSArray&lt;UINavigationItem *&gt; *items;//设置一组item- (void)setItems:(nullable NSArray&lt;UINavigationItem *&gt; *)items animated:(BOOL)animated; 五、UINavigationBarDelegate在UINavigationBar中，还有如下一个属性： 1@property(nullable,nonatomic,weak) id&lt;UINavigationBarDelegate&gt; delegate; 通过代理，我们可以监控导航栏的一些push与pop操作： 12345678//item将要push的时候调用，返回NO，则不能push- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item; //item已经push后调用- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item; //item将要pop时调用，返回NO，不能pop - (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item; //item已经pop后调用 - (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列二——UINavigationItem","slug":"149iOS开发UINavigation系列二——UINavigationItem","date":"2015-11-07T16:00:00.000Z","updated":"2021-07-05T07:54:50.311Z","comments":true,"path":"2015/11/08/149iOS开发UINavigation系列二——UINavigationItem/","link":"","permalink":"http://huishao.cc/2015/11/08/149iOS开发UINavigation系列二——UINavigationItem/","excerpt":"","text":"iOS开发UINavigation系列二——UINavigationItem一、引言UINavigationItem是导航栏上用于管理导航项的类，在上一篇博客中，我们知道导航栏是通过push与pop的堆栈操作来对item进行管理的，同样，每一个Item自身也有许多属性可供我们进行自定制。这篇博客，主要讨论UINavigationItem的使用方法。 UINavigationBar：http://my.oschina.net/u/2340880/blog/527706。 二、来说说UINavigationItemItem，从英文上来理解，它可以解释为一个项目，因此，item不是一个简单的label标题，也不是一个简单的button按钮，它是导航栏中管理的一个项目的抽象。说起来有些难于理解，通过代码，我们就能很好的理解Item的意义。 首先，我们创建一个item，用UINavigationBar导航栏push出来： 123 UINavigationItem * item = [[UINavigationItem alloc]initWithTitle:@&quot;title&quot;]; UINavigationBar * bar = [[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 64)]; [bar pushNavigationItem:item animated:YES]; 我们可以看到，在导航栏上的中间，有title这样一个item： 除了创建一个标题item，我们也可以创建一个View类型的item： 123 UIView * view = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; view.backgroundColor = [UIColor brownColor]; item.titleView = view; 效果如下： 通过下面的属性，可以给这个Item添加一个说明文字，这段文字会显示在item的上方： 1item.prompt= @&quot;我是navigationItem的说明文字&quot;; 上面我们看到的这些，实际上只是一个item的一部分，item还有许多其他的附件，如果我们使导航栏再push出一个item，这时导航栏的左边会出现一个返回按钮，这个返回按钮实际上是数据第一个item的，我们做如下的设置： 12345 UINavigationItem * item = [[UINavigationItem alloc]initWithTitle:@&quot;title&quot;]; UINavigationItem * item2 = [[UINavigationItem alloc]initWithTitle:@&quot;title2&quot;]; item.backBarButtonItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;title1&quot; style:nil target:nil action:nil]; [bar pushNavigationItem:item animated:YES]; [bar pushNavigationItem:item2 animated:YES]; 可以看出，虽然当前push出来的item是item2，但是左边的返回按钮是属于item的。这里有一点需要注意，虽然backBarButtonItem的标题我们可以自定义，但是方法和其他属性我们都不能定制，是系统实现好的。 当然，我们也可以设置在push出来新的item的时候，隐藏前面的返回按钮，使用如下属性： 12@property(nonatomic,assign) BOOL hidesBackButton;- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated; 默认为NO，设置为YES将会隐藏返回按钮。 三、关于UIBarButtonItem一个UINavigationItem中，还可以包含许多BarButtonItem，BarButtonItem是一系列的按钮，会出现在导航栏的左侧或者右侧。例如： 12 UIBarButtonItem * button = [[UIBarButtonItem alloc]initWithTitle:@&quot;按钮&quot; style:UIBarButtonItemStyleDone target:self action:@selector(click)]; item.leftBarButtonItem = button; 这个barButtonItem是一个按钮，可以触发一个方法，这有时候对我们来说十分有用。但是有一个你一定发现了，如果继续push出来Item，原来的返回按钮不见了，是否隐藏返回按钮，由下面这个属性控制： 1item.leftItemsSupplementBackButton=YES; 我们也可以通过下面的方法设置右边的按钮，或者直接设置一组按钮： 123456789@property(nullable, nonatomic,strong) UIBarButtonItem *leftBarButtonItem;@property(nullable, nonatomic,strong) UIBarButtonItem *rightBarButtonItem;- (void)setLeftBarButtonItem:(nullable UIBarButtonItem *)item animated:(BOOL)animated;- (void)setRightBarButtonItem:(nullable UIBarButtonItem *)item animated:(BOOL)animated;@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *leftBarButtonItems;@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *rightBarButtonItems;- (void)setLeftBarButtonItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated;- (void)setRightBarButtonItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated; 四、再看UIBarButtonItem上面我们了解到了，一个NavigationItem基本上是有三大部分组成的，当前显示的部分，返回按钮部分，和ButtonItem部分，同样对于创建和设置UIBarButoonItem，也有很多方法供我们使用。 首先是创建与初始化的方法： 1- (instancetype)initWithTitle:(nullable NSString *)title style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action; 这个方法通过一个标题创建ButtonItem，其中style参数可以设置一个风格，枚举如下： 1234typedef NS_ENUM(NSInteger, UIBarButtonItemStyle) &#123; UIBarButtonItemStylePlain, UIBarButtonItemStyleDone,&#125;; 这两种风格差别并不大，如下是效果，Done风格的字体加粗一些： 我们因为可以通过一个图片来创建BarButtonItem： 12- (instancetype)initWithImage:(nullable UIImage *)image style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action;- (instancetype)initWithImage:(nullable UIImage *)image landscapeImagePhone:(nullable UIImage *)landscapeImagePhone style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action; 上面这两个方法中，第一个方法与使用文字创建的方法类似，第二个方法多了一个landscapeImagePhone的参数，这个参数可以设置设备横屏时的图片。 我们也可以使用自定义的View来创建BarButtonItem： 1- (instancetype)initWithCustomView:(UIView *)customView; 除了上面一些自定义的创建方法外，对于BarButtonItem这个对象，系统也封装好了许多原生的可以供我们使用，创建的时候使用如下方法： 1UIBarButtonItem * button = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemCamera target:self action:nil]; 上面的SystemItem是系统为我们做好的许多buttonItem的类型，枚举如下： 1234567891011121314151617181920212223242526typedef NS_ENUM(NSInteger, UIBarButtonSystemItem) &#123; UIBarButtonSystemItemDone,//显示完成 UIBarButtonSystemItemCancel,//显示取消 UIBarButtonSystemItemEdit, //显示编辑 UIBarButtonSystemItemSave, //显示保存 UIBarButtonSystemItemAdd,//显示加号 UIBarButtonSystemItemFlexibleSpace,//什么都不显示，占位一个空间位置 UIBarButtonSystemItemFixedSpace,//和上一个类似 UIBarButtonSystemItemCompose,//显示写入按钮 UIBarButtonSystemItemReply,//显示循环按钮 UIBarButtonSystemItemAction,//显示活动按钮 UIBarButtonSystemItemOrganize,//显示组合按钮 UIBarButtonSystemItemBookmarks,//显示图书按钮 UIBarButtonSystemItemSearch,//显示查找按钮 UIBarButtonSystemItemRefresh,//显示刷新按钮 UIBarButtonSystemItemStop,//显示停止按钮 UIBarButtonSystemItemCamera,//显示相机按钮 UIBarButtonSystemItemTrash,//显示移除按钮 UIBarButtonSystemItemPlay,//显示播放按钮 UIBarButtonSystemItemPause,//显示暂停按钮 UIBarButtonSystemItemRewind,//显示退后按钮 UIBarButtonSystemItemFastForward,//显示前进按钮 UIBarButtonSystemItemUndo,//显示消除按钮 UIBarButtonSystemItemRedo ,//显示重做按钮 UIBarButtonSystemItemPageCurl ,//在tool上有效&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用","slug":"147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用","date":"2015-11-05T16:00:00.000Z","updated":"2021-07-05T07:49:46.146Z","comments":true,"path":"2015/11/06/147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用/","link":"","permalink":"http://huishao.cc/2015/11/06/147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用/","excerpt":"","text":"iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用一、引言在iOS系统中，手势是进行用户交互的重要方式，通过UIGestureRecognizer类，我们可以轻松的创建出各种手势应用于app中。关于UIGestureRecognizer类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的一些讨论，在前面的博客中有提到： iOS事件响应控制：http://my.oschina.net/u/2340880/blog/396161。 二、手势的抽象类——UIGestureRecognizerUIGestureRecognizer将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用UIGestureRecognizer的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，UIGestureRecognizer中抽象出了哪些方法。 1、统一的初始化方法UIGestureRecognizer类为其子类准备好了一个统一的初始化方法，无论什么样的手势动作，其执行的结果都是一样的：触发一个方法，可以使用下面的方法进行统一的初始化： 1- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action; 当然，如果我们使用alloc-init的方式，也是可以的，下面的方法可以为手势添加触发的selector： 1- (void)addTarget:(id)target action:(SEL)action; 与之相对应的，我们也可以将一个selector从其手势对象上移除： 1- (void)removeTarget:(nullable id)target action:(nullable SEL)action; 上面两个方法是十分有意思的，因为addTarget方式的存在，iOS系统允许一个手势对象可以添加多个selector触发方法，并且触发的时候，所有添加的selector都会被执行，我们以点击手势示例如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)]; [ges addTarget:self action:@selector(haha)]; [self.view addGestureRecognizer:ges];&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;); &#125;-(void)haha&#123; NSLog(@&quot;haha&quot;);&#125; 运行后点击屏幕，打印如下，说明两个方法都触发了： 2、手势状态UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态: 1@property(nonatomic,readonly) UIGestureRecognizerState state; 枚举值如下： 123456789typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; UIGestureRecognizerStatePossible, // 默认的状态，这个时候的手势并没有具体的情形状态 UIGestureRecognizerStateBegan, // 手势开始被识别的状态 UIGestureRecognizerStateChanged, // 手势识别发生改变的状态 UIGestureRecognizerStateEnded, // 手势识别结束，将会执行触发的方法 UIGestureRecognizerStateCancelled, // 手势识别取消 UIGestureRecognizerStateFailed, // 识别失败，方法将不会被调用 UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded &#125;; 3、常用属性和方法123456789101112//设置代理，具体的协议后面会说@property(nullable,nonatomic,weak) id &lt;UIGestureRecognizerDelegate&gt; delegate; //设置手势是否有效@property(nonatomic, getter=isEnabled) BOOL enabled;//获取手势所在的view@property(nullable, nonatomic,readonly) UIView *view; //获取触发触摸的点- (CGPoint)locationInView:(nullable UIView*)view; //设置触摸点数- (NSUInteger)numberOfTouches; //获取某一个触摸点的触摸位置- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view; 下面的几个BOOL值的属性，对于手势触发的控制也十分重要： （1）1@property(nonatomic) BOOL cancelsTouchesInView; 上面的属性默认为YES，当这个属性设置为YES时，如果识别到了手势，系统将会发送touchesCancelled:withEvent:消息在其时间传递链上，终止触摸事件的传递，设置为NO，则不会终止事件的传递，举个例子来说，可能会更加清楚一些如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; UIPanGestureRecognizer * ges = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];; [self.view addGestureRecognizer:ges]; ges.cancelsTouchesInView=NO;&#125;-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;123&quot;);&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;);&#125; 上面我们使用了拖拽手势和touchesMoved两个触发方式，当我们把cancelTouchesInView设置为NO时，在屏幕上滑动，会发现两种方式都在触发，打印如下： 如果我们将cancelTouchesInView改为YES，当手势触发时，将取消触摸消息的触发： （2）1@property(nonatomic) BOOL delaysTouchesBegan; 通过上面的例子，我们知道，在一个手势触发之前，是会一并发消息给事件传递链的，delaysTouchesBgan属性用于控制这个消息的传递时机，默认这个属性为NO，此时在触摸开始的时候，就会发消息给事件传递链，如果我们设置为YES，在触摸没有被识别失败前，都不会给事件传递链发送消息。 （3）1@property(nonatomic) BOOL delaysTouchesEnded; 这个属性设置手势识别结束后，是立刻发送touchesEnded消息到事件传递链或者等待一个很短的时间后，如果没有接收到新的手势识别任务，再发送。 4、手势间的互斥处理有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如： 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];; //view.backgroundColor = [UIColor redColor]; //ges.delegate=self; [self.view addGestureRecognizer:ges]; UITapGestureRecognizer * ges2 = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click1:)];// ges2.delegate=self; [self.view addGestureRecognizer:ges2];&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;); &#125;-(void)click1:(UIGestureRecognizer *)ges1&#123; NSLog(@&quot;第二个手势的触发方法&quot;); &#125; 我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法： 1- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer; 这个方法中第一个参数是需要时效的手势，第二个是生效的手势。 三、UIGestureRecognizerDelegate前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下： 1234567891011//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;//下面这个两个方法也是用来控制手势的互斥执行的//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);//这个方法返回YES，第一个和第二个互斥时，第二个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0); 四、点击手势——UITapGestureRecognizer点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置： 1234//设置点击次数，默认为单击@property (nonatomic) NSUInteger numberOfTapsRequired; //设置同时点击的手指数@property (nonatomic) NSUInteger numberOfTouchesRequired; 五、捏合手势——UIPinchGestureRecognizer捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下： 1234//设置缩放比例@property (nonatomic) CGFloat scale; //设置捏合速度@property (nonatomic,readonly) CGFloat velocity; 六、拖拽手势——UIPanGestureRecognzer当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。 12345678910//设置触发拖拽的最少触摸点，默认为1@property (nonatomic) NSUInteger minimumNumberOfTouches; //设置触发拖拽的最多触摸点@property (nonatomic) NSUInteger maximumNumberOfTouches; //获取当前位置- (CGPoint)translationInView:(nullable UIView *)view; //设置当前位置- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;//设置拖拽速度- (CGPoint)velocityInView:(nullable UIView *)view; 七、滑动手势——UISwipeGestureRecognizer滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢。 1234567891011//设置触发滑动手势的触摸点数@property(nonatomic) NSUInteger numberOfTouchesRequired; //设置滑动方向@property(nonatomic) UISwipeGestureRecognizerDirection direction; //枚举如下typedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) &#123; UISwipeGestureRecognizerDirectionRight = 1 &lt;&lt; 0, UISwipeGestureRecognizerDirectionLeft = 1 &lt;&lt; 1, UISwipeGestureRecognizerDirectionUp = 1 &lt;&lt; 2, UISwipeGestureRecognizerDirectionDown = 1 &lt;&lt; 3&#125;; 八、旋转手势——UIRotationGestureRecognizer进行旋转动作时触发手势方法。 1234//设置旋转角度@property (nonatomic) CGFloat rotation;//设置旋转速度 @property (nonatomic,readonly) CGFloat velocity; 九、长按手势——UILongPressGestureRecognizer进行长按的时候触发的手势方法。 12345678//设置触发前的点击次数@property (nonatomic) NSUInteger numberOfTapsRequired; //设置触发的触摸点数@property (nonatomic) NSUInteger numberOfTouchesRequired; //设置最短的长按时间@property (nonatomic) CFTimeInterval minimumPressDuration; //设置在按触时时允许移动的最大距离 默认为10像素@property (nonatomic) CGFloat allowableMovement; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中UITableViewController自带的刷新控件","slug":"146iOS中UITableViewController自带的刷新控件","date":"2015-11-04T16:00:00.000Z","updated":"2021-07-05T07:47:23.177Z","comments":true,"path":"2015/11/05/146iOS中UITableViewController自带的刷新控件/","link":"","permalink":"http://huishao.cc/2015/11/05/146iOS中UITableViewController自带的刷新控件/","excerpt":"","text":"iOS中UITableViewController自带的刷新控件一、引言在iOS开发中，使用tableView的界面，大多会用到一个下拉刷新的的控件，第三方库中，我们一般会选择比较好用的MJRefresh，其实，在iOS6之后，系统为我们提供了一个原生的刷新控件，使用起来非常方便，只是制定性不强，如果我们没有复杂的需求，使用UIRefreshControl也是不错的一个选择。 二、UITableViewController相对于UIViewController，UITableViewController只是在内部为我们封装好了一个UITableView，并且遵守好了相关的协议，我们只需要在其中实现方法即可。UITableViewController更多的方面之处是在于下面的这个属性： 1@property (nonatomic) BOOL clearsSelectionOnViewWillAppear; 这是一个bool值，设置为yes后每当当前controller调用ViewWillAppare的时候，都会将cell的选中状态取消，这十分有用，我们在通过点击cell跳转界面后，pop回来不需要在手动修改cell的选中状态了。 除此之后，TableViewController中还封装了这样一个属性： 1@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl; 这个UIRefreshControl类是iOS6之后引入的一个简单的刷新控件，我们如果设置了它，在tableView下拉的时候，系统会提供给我们一个下拉刷新的效果。 三、UIRefreshControl这个类也十分简单，通过简单的设置可以展现一个小巧的刷新效果，但是制定性不强，其中主要属性如下： 1234567891011//获取刷新状态@property (nonatomic, readonly, getter=isRefreshing) BOOL refreshing;//设置控件颜色@property (null_resettable, nonatomic, strong) UIColor *tintColor;//设置控件文字@property (nullable, nonatomic, strong) NSAttributedString *attributedTitle UI_APPEARANCE_SELECTOR;// 手动开始刷新- (void)beginRefreshing NS_AVAILABLE_IOS(6_0);// 结束刷新- (void)endRefreshing NS_AVAILABLE_IOS(6_0); 需要注意的是，UIRefreshControl是继承于UIControl的，下拉唤醒刷新状态后，会触发UIControleEventValueChange事件，我们可以在其中进行刷新的数据逻辑操作。 例如： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; self.refreshControl = [[UIRefreshControl alloc]init]; self.refreshControl.tintColor = [UIColor greenColor]; self.refreshControl.attributedTitle = [[NSAttributedString alloc]initWithString:@&quot;下拉刷新了~~&quot;]; self.clearsSelectionOnViewWillAppear = YES; self.navigationItem.rightBarButtonItem = self.editButtonItem; [self.refreshControl addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged];&#125;-(void)change:(UIRefreshControl*)con&#123; self.refreshControl.attributedTitle = [[NSAttributedString alloc]initWithString:@&quot;开始刷新了~~&quot;];&#125; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之四——使用第三方库Masonry进行autolayout布局","slug":"145iOS界面布局之四——使用第三方库Masonry进行autolayout布局","date":"2015-11-01T16:00:00.000Z","updated":"2021-07-05T07:46:35.018Z","comments":true,"path":"2015/11/02/145iOS界面布局之四——使用第三方库Masonry进行autolayout布局/","link":"","permalink":"http://huishao.cc/2015/11/02/145iOS界面布局之四——使用第三方库Masonry进行autolayout布局/","excerpt":"","text":"iOS界面布局之四——使用第三方库Masonry进行autolayout布局一、引言在前面博客，我们讨论了使用iOS原生的框架代码来进行autolayout布局。在使用中，我们会发现，无论是代码量还是结构的清晰度，都十分不能让我们满意，在storyBoard中只需要几条线就可以搞定的事情，用代码缺要写冗余的一大堆。并且有些时候，故事版并不能解决所有问题，某些控件必须我们手写，这样的话，我们就不得不进行代码的autolayout布局，幸运的是，Masonry可以帮助我们轻松愉快的完成这一任务。 使用代码进行autolayout布局：http://my.oschina.net/u/2340880/blog 。 二、使用Masonry这里说的大部分内容均来自Masonry和官方gitHub，将其内容进行了翻译和解释，源地址如下：[https://github.com/SnapKit/Masonry](https://github.com/SnapKit/Masonry)。 1、布局的控件属性对照无论是用storyBoard还是代码，在设置控件之间layout关系的时候，我们都需要设置控件的位置属性。在下面的方法中，这个位置属性就是NSLayoutAttribute对象，他决定的控件对象的参照位置： 12345+(instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 在Masonry中，有一系列的属性与之成对应关系，对照如下： 2、3个方法让你玩转Masonry约束操作Masonry在UIView的类别中，有3个全局的操作约束的方法，通过他们我们可以自由的进行autolayout的设置。 添加约束： 1- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block; 这个方法用于我们在最开始时为控件设置的约束，在block中进行约束条件的设置，例如我们创建一个label，将其尺寸设置为50*50，放在屏幕中间，使用如下代码： 注意：在添加约束前，必须将视图添加到其父视图上。 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UILabel * label = [[UILabel alloc]init]; [self.view addSubview:label]; [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self.view); make.height.equalTo(@50); make.width.equalTo(@50); &#125;]; label.backgroundColor = [UIColor redColor];&#125; 效果如下： 更新约束： 当我们需要配合布局改变或者动画效果的时候，我们可能需要将已经添加的约束进行更新操作，使用如下的方法： 1234[label mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.width.equalTo(@100); &#125;]; 更新约束的作用在于更新已经添加的某些约束，并不会移除掉原有的约束，如果我们需要添加新的约束，可以使用下面的重设约束的方法。 重设约束： 123456[label mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view.mas_left).offset(10); make.top.equalTo(self.view.mas_top).offset(100); make.height.equalTo(@100); make.width.equalTo(@100); &#125;]; 3、约束值相关在添加具体约束的时候，我们不仅可以将约束值设置为绝对的相等关系，也可以设置一些值域的关系，在Masonry中，有如下三种： 123456//绝对相等- (MASConstraint * (^)(id attr))equalTo;//大于等于- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;//小于等于- (MASConstraint * (^)(id attr))lessThanOrEqualTo; 对于约束的优先级，使用如下几个量： 12345678//手动设置一个优先级参数- (MASConstraint * (^)(MASLayoutPriority priority))priority;//优先级低- (MASConstraint * (^)())priorityLow;//优先级中等- (MASConstraint * (^)())priorityMedium;//优先级高- (MASConstraint * (^)())priorityHigh; 写法如下： 123456[label mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view.mas_left).offset(10); make.top.equalTo(self.view.mas_top).offset(100); make.height.equalTo(@100).priority(1000); make.width.equalTo(@100).priorityHigh(); &#125;]; 三、Masonry设置约束的几个示例1、设置视图与其父视图的边距约束12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. label = [[UILabel alloc]init]; [self.view addSubview:label]; [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.view).insets(UIEdgeInsetsMake(20, 20, 20, 20)); &#125;]; label.backgroundColor = [UIColor redColor];&#125; 设置上下左右与其父视图边距为20px，效果如下： 2、约束控件的尺寸为固定值12345[label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@200); make.width.equalTo(@200); make.center.equalTo(self.view); &#125;]; 位置约束设置在了屏幕的中间，效果如下： 3、约束控件之间的尺寸123456789101112 [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.width.equalTo(label2); make.right.equalTo(label2.mas_left).offset(-100); make.leading.equalTo(self.view.mas_leading).offset(20); make.centerY.equalTo(self.view); &#125;]; [label2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.centerY.equalTo(label); make.trailing.equalTo(self.view.mas_trailing).offset(-20); &#125;]; 设置了两个label宽度一致，相距100px,分别距离左右边距20px，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS对UIViewController生命周期和属性方法的解析","slug":"144iOS对UIViewController生命周期和属性方法的解析","date":"2015-10-31T16:00:00.000Z","updated":"2021-07-05T07:45:25.659Z","comments":true,"path":"2015/11/01/144iOS对UIViewController生命周期和属性方法的解析/","link":"","permalink":"http://huishao.cc/2015/11/01/144iOS对UIViewController生命周期和属性方法的解析/","excerpt":"","text":"iOS对UIViewController生命周期和属性方法的解析一、引言作为MVC设计模式中的C，Controller一直扮演着项目开发中最重要的角色，它是视图和数据的桥梁，通过它的管理，将数据有条有理的展示在我们的View层上。iOS中的UIViewController是UIKit框架中最基本的一个类。从第一个UI视图到复杂完整项目，都离不开UIViewController作为基础。基于UIViewController的封装和扩展，也能够出色的完成各种复杂界面逻辑。这篇博客，旨在讨论UIViewController的生命周期和属性方法，在最基础的东西上，往往会得到意想不到的惊喜。 二、UIViewController的生命周期要了解UIViewController，先要弄清楚其生命周期。在面向对象的语言中，是对象，就一定要有生命周期，UIViewController也不例外，生命周期管理Controller的作用范围和时间，也管理其内对象的作用范围和时间。首先，UIViewController中与其生命周期有关的几个函数如下： 1234567891011121314151617181920212223242526//类的初始化方法+ (void)initialize;//对象初始化方法- (instancetype)init;//从归档初始化- (instancetype)initWithCoder:(NSCoder *)coder;//加载视图-(void)loadView;//将要加载视图- (void)viewDidLoad;//将要布局子视图-(void)viewWillLayoutSubviews;//已经布局子视图-(void)viewDidLayoutSubviews;//内存警告- (void)didReceiveMemoryWarning;//已经展示-(void)viewDidAppear:(BOOL)animated;//将要展示-(void)viewWillAppear:(BOOL)animated;//将要消失-(void)viewWillDisappear:(BOOL)animated;//已经消失-(void)viewDidDisappear:(BOOL)animated;//被释放-(void)dealloc; 上面这么多的函数，乍一看什么复杂，其实关系什么明朗，除了initialize,init和initWithCoder不是存在所有对象的声明周期中，其他函数都会在UIViewController的声明周期中有序的被调用。那么具体的调用顺序是怎样的呢，最好的办法是实践一下，通过编号打印，结果如下： 这是一个ViewController完整的声明周期，其实里面还有好多地方需要我们注意一下： 1：initialize函数并不会每次创建对象都调用，只有在这个类第一次创建对象时才会调用，做一些类的准备工作，再次创建这个类的对象，initalize方法将不会被调用，对于这个类的子类，如果实现了initialize方法，在这个子类第一次创建对象时会调用自己的initalize方法，之后不会调用，如果没有实现，那么它的父类将替它再次调用一下自己的initialize方法，以后创建也都不会再调用。因此，如果我们有一些和这个相关的全局变量，可以在这里进行初始化。 2：init方法和initCoder方法相似，只是被调用的环境不一样，如果用代码进行初始化，会调用init，从nib文件或者归档进行初始化，会调用initCoder。 3：loadView方法是开始加载视图的起始方法，除非手动调用，否则在ViewController的生命周期中没特殊情况只会被调用一次。 4：viewDidLoad方法是我们最常用的方法的，类中成员对象和变量的初始化我们都会放在这个方法中，在类创建后，无论视图的展现或消失，这个方法也是只会在将要布局时调用一次。 5：viewWillAppear：视图将要展现时会调用。 6：viewWillLayoutSubviews：在viewWillAppear后调用，将要对子视图进行布局。 7：viewDidLayoutSubviews：已经布局完成子视图。 8：viewDidAppare：视图完成显示时调用。 9：viewWillDisappear：视图将要消失时调用。 10：viewDidDisappear：视图已经消失时调用。 11：dealloc：controller被释放时调用。 注意：经过测试，从nib文件加载的controller，只要不释放，在每次viewWillAppare时都会调用layoutSubviews方法，有时甚至会在viewDidAppare后在调用一次layoutSubviews，而重点是从代码加载的则只会在开始调用一次，之后都不会，所以注意，在layoutSubviews中写相关的布局代码十分危险。 三、从storyBoard加载UIViewController实例的传值陷阱我们知道，当我们从StoryBoard中加载ViewController时，我们在Controller中拖拽的视图是可以被初始化的，这里面有一点需要我们注意，如果我们需要向controller中视图进行传值设置，通过以下方法得到的Controller中，视图还没有被初始化创建出来： 1 ViewController2 * viewController2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:@&quot;ViewController2&quot;]; 我们可以在ViewController2的storyBoard中拉一个label，然后关联到头文件中，如下打印，会发现我们得到controller时，里面的视图对象并没有进行创建: 123ViewController2 * viewController2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:@&quot;ViewController2&quot;]; NSLog(@&quot;%@&quot;,viewController2.label); [self presentViewController:viewController2 animated:YES completion:nil]; 打印如下： 可以想象，如果我们这时候需要对label进行一些属性设置，必然失败。有人提出可以在创建后，手动调以下loadView方法，我们试一下，结果如下： 可以看到，手动调用loadView后，label是被创建了出来，但是暴漏了一个更严重的问题，系统不在调用ViewDidLoad方法，这是十分有风险的，因为我们大部分的初始化代码都会放在这个方法里，所以手动调用loadView是一种错误的方法，apple文档声明对于loadView方法，我们从来都不要手动直接调用，那么我们如何实现创建后对成员对象进行传值设置呢，iOS9中增加了这样一个方法： 1- (void)loadViewIfNeeded NS_AVAILABLE_IOS(9_0); 这个方法十分有用，调用这个方法，会将视图创建出来，并且不会忽略viewDidLoad的调用。 在iOS9中，UIViewController还增加了下面一个布尔值的属性，可以同来判断controller的view是否已经加载完成： 1@property(nullable, nonatomic, readonly, strong) UIView *viewIfLoaded NS_AVAILABLE_IOS(9_0); 四、UIViewController与StroyBoard的相关相互方法对于ViewConroller，我们一般有两种方式创建，一种是用纯代码的方式，一种是与StoryBoard关联，在UIViewController中，有许多方法方便我们与StoryBoard进行交互联系。 1、ViewController直接在StoryBoard中进行跳转的传值在StoryBoard中进行界面跳转是十分方便的，我们在StoryBoard中拉入两个ViewController，在一个上面添加一个按钮，点住按钮按住control，将鼠标拉到第二个controller上，会出现如下的跳转选项： 我们选择一个后，就会在两个controller之间建立一个跳转连接。当我们运行点击按钮后，会自动从第一个controller跳转到第二个controller。在UIViewController中有如下方法可以对是否跳转进行控制： 1- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(6_0); 这个方法如果返回NO，自动跳转将不能进行，会被拒绝，需要注意的是，这个方法只会在自动的跳转时被调用，我们手动使用代码跳转StoryBoard中的连接关系时是不会被调用的，我们后面讨论。 在执行过上述方法后，如果返回YES，系统还会在执行如下一个方法，作为跳转前的准备，我们可以在这个方法中进行一些传值操作，这个方法无论使我们手动进行跳转还是storyboard中自动跳转，都会被执行： 1- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(nullable id)sender NS_AVAILABLE_IOS(5_0); sugur对象中封装了相关的ViewController，可以使用segue.destinationViewController获取。 segue在StoryBoard中除了用来自动正向跳转外，我们还可以进行反向的跳转，类似pop和dismiss方法，这种segue被称为unwind sugue。例如，我们有一个controller1和一个controllert2，要使用unwind segue从2返回1，我们需要在2中实现如下格式的方法： 123- (IBAction)unwindSegueToViewController:(UIStoryboardSegue *)segue &#123; NSLog(@&quot;unwindSegueToViewController&quot;);&#125; 这个方法中的返回值必须为IBAction，参数必须是UIStoryboardSegue，方法名我们可以自己定义，之后在StoryBoard中的ViewController1中的Exit选项中，我们会发现多了一个这样的方法： 我们可以把它连接到viewController2中的一个按钮上： 这样，当我们点击viewController2中的按钮时，就会返回到我们第一个ViewController1中了。 当然，在使用unwind segue方法时，也是会有一些回调帮助我们进行跳转前的设置和传值，UIViewController如下方法会在跳转前调用，返回NO，则不能进行跳转： 1234-(BOOL)canPerformUnwindSegueAction:(SEL)action fromViewController:(UIViewController *)fromViewController withSender:(id)sender&#123; NSLog(@&quot;canPerformUnwindSegueAction&quot;); return YES;&#125; 之后会执行我们自定义的unwindSegue方法，这个方法中我们可以什么都不写，模式是会进行跳转的。 2、使用代码跳转Storyboard中的controller我们除了在Storyboard中拉拉扯扯可以进行控制器的跳转外，我们也可以使用代码来跳转Storyboard中segue连接关系。 在Storyboard中两个控制器间建立一个segue联系，我们可以取一个名字： 在触发跳转的方法中，使用如下方法进行跳转，这里面的参数id就是我们取得segue的id： 1- (void)performSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(5_0); 下面三个属性我们可以获取controller的nib文件名，其storyBoard和其Bundle: 123@property(nullable, nonatomic, readonly, copy) NSString *nibName; @property(nullable, nonatomic, readonly, strong) NSBundle *nibBundle; @property(nullable, nonatomic, readonly, strong) UIStoryboard *storyboard NS_AVAILABLE_IOS(5_0); 五、UIViewController之间的一些从属关系这部分的内容和方法可能我们接触用到的并不多，但是在某些情况下，使用这些方法可以大大的方便某些逻辑。 1、parentViewControllerUIViewController里面封装了一个数组，可以存放其子ViewController，系统中使用的例子就是导航和tabBar这类的控制器，我们使用如下方法可以直接访问这些父的controller： 1@property(nullable,nonatomic,weak,readonly) UIViewController *parentViewController; 2、模态跳转中Controller的从属在我们进行控制器的跳转时，只要控制器没有被释放，我们都可以顺藤摸瓜的找到它，使用如下两个方法： 1234//其所present的contller，比如，A和B两个controller，A跳转到B，那么A的presentedViewController就是B@property(nullable, nonatomic,readonly) UIViewController *presentedViewController NS_AVAILABLE_IOS(5_0);//和上面的方法刚好相反，比如，A和B两个controller，A跳转到B，那么B的presentingViewController就是A@property(nullable, nonatomic,readonly) UIViewController *presentingViewController NS_AVAILABLE_IOS(5_0); 了解了上面方法我们可以知道，对于反向传值这样的问题，我们根本不需要代理，block，通知等这样的复杂手段，只需要获取跳转到它的Controller，直接设置即可。举个例子，我们需要在第二个界面消失后，改变第一个界面的颜色，在第二个controller中只需要下面的代码即可实现 ： 12 self.presentingViewController.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [self dismissViewControllerAnimated:YES completion:nil]; 六、UIViewController的模态跳转及动画特效单纯的UIViewController中，我们使用最多的是如下的两个方法，一个向前跳转，一个向后返回: 12- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0);- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0); 从方法中，我们可以看到，有animated这个参数，来选择是否有动画特效，默认的动画特效是像抽屉一样从手机屏幕的下方向上弹起，当然，这个效果我们可以进行设置，UIViewController有如下一个属性来设置动画特效： 1@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle NS_AVAILABLE_IOS(3_0); 注意，这个要设置的是将要跳转到的controller，枚举如下： 123456typedef NS_ENUM(NSInteger, UIModalTransitionStyle) &#123; UIModalTransitionStyleCoverVertical = 0,//默认的，从下向上覆盖 UIModalTransitionStyleFlipHorizontal ,//水平翻转 UIModalTransitionStyleCrossDissolve,//溶解 UIModalTransitionStylePartialCurl ,从下向上翻页&#125;; 除了跳转的效果，还有一个属性可以设置弹出的controler的填充效果，但是这个属性只在pad上有效，在iphone上无效，都是填充到整个屏幕： 12345678910111213@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle NS_AVAILABLE_IOS(3_2);//枚举如下typedef NS_ENUM(NSInteger, UIModalPresentationStyle) &#123; UIModalPresentationFullScreen = 0,//填充整个屏幕 UIModalPresentationPageSheet,//留下状态栏 UIModalPresentationFormSheet,//四周留下变暗的空白 UIModalPresentationCurrentContext ,//和跳转到它的控制器保持一致 UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),//自定义 UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0), UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0), UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED, UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1, &#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之三——纯代码的autoLayout及布局动画","slug":"143iOS界面布局之三——纯代码的autoLayout及布局动画","date":"2015-10-29T16:00:00.000Z","updated":"2021-07-05T05:59:11.854Z","comments":true,"path":"2015/10/30/143iOS界面布局之三——纯代码的autoLayout及布局动画/","link":"","permalink":"http://huishao.cc/2015/10/30/143iOS界面布局之三——纯代码的autoLayout及布局动画/","excerpt":"","text":"iOS界面布局之三——纯代码的autoLayout及布局动画一、引言关于界面布局，apple的策略已经趋于成熟，autolayout的优势在开发中也已经展现的淋漓尽致。除了使用storyBoard进行布局约束的拖拽，有时我们也需要在代码中进行autolayout的布局设置，Masonry库可以方便的创建约束属性，实际上，我们也没有必要再使用系统原生的代码来创建和设置约束，这篇博客只作为使用的方法备忘。前几篇布局介绍的链接如下： 使用autoresizing进行界面布局：http://my.oschina.net/u/2340880/blog/423357 初识autolayout布局模型：http://my.oschina.net/u/2340880/blog/423500 二、了解一个类用代码来做视图间的相关约束，那么就一定要将“约束”也进行对象化，在iOS6之后，引入了autolayout这个概念，相应的也增加了NSLayoutConstraint这个对象，这个对象就是专门用来进行约束布局的设置对象。通过这个对象，我们可以设置类似视图对象之间的间距，约束的宽高，比例等属性。创建NSLayoutConstraint对象的方法有两种，下面我们分别介绍： 1、使用Objective-C风格的方法创建约束对象所谓Objective-C风格的方法，就是通过原生枚举和一些属性设置来创建NSLayoutConstraint对象。使用NSLayoutConstraint类的如下方法： 1+(instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 先来介绍下方法中的参数都是什么意义，我们应该怎么用他们： view1：要添加约束的视图对象。 attr1：要约束的对象属性，这个就是一些枚举，如下： 123456789101112131415161718192021222324252627typedef NS_ENUM(NSInteger, NSLayoutAttribute) &#123; NSLayoutAttributeLeft = 1,//左 NSLayoutAttributeRight,//右 NSLayoutAttributeTop,//上 NSLayoutAttributeBottom,//下 NSLayoutAttributeLeading,//起始边，类似左，只在某些从右向左排列的语言中和NSLayoutAttributeLeft有大区别 NSLayoutAttributeTrailing,//结束边 NSLayoutAttributeWidth,//宽度 NSLayoutAttributeHeight,//高度 NSLayoutAttributeCenterX,//x中心 NSLayoutAttributeCenterY,//y中心 NSLayoutAttributeBaseline,//基线 NSLayoutAttributeLastBaseline = NSLayoutAttributeBaseline, NSLayoutAttributeFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0), //下面的属性是设置的边距 意义和上面类似 对应左，右等边距 NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeBottomMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeLeadingMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeTrailingMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeCenterXWithinMargins NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeCenterYWithinMargins NS_ENUM_AVAILABLE_IOS(8_0), //无，后面会说应用场景 NSLayoutAttributeNotAnAttribute = 0&#125;; relation：约束的选项，对应&lt;=,==,&gt;=这些，枚举如下： 12345typedef NS_ENUM(NSInteger, NSLayoutRelation) &#123; NSLayoutRelationLessThanOrEqual = -1,//&lt;= NSLayoutRelationEqual = 0,//== NSLayoutRelationGreaterThanOrEqual = 1,//&gt;=&#125;; view2:与之对应添加约束的视图对象，例如，如过我要设置view1的上边距离父视图的上边一定间距，这个view2就是view1的父视图，如果我要设置view1与另一个视图一定距离，这个view2就是另一个视图。 attr2：view2的要约束的属性，和attr1含义一样。 multiplie:约束的比例，比如view1的宽是view2的宽的两倍，这个multiplie就是2. C：这是具体的约束值 对于这些属性，文档上有这样的解释：view1.attr1 = view2.attr2 * multiplier + constant 例如，我们创建一个label，将它的宽高固定为100*100，位置放在屏幕的中央，我们可以使用如下的约束代码： 12345678910111213141516UILabel * label = [[UILabel alloc]init]; label.numberOfLines = 0; //使用代码布局 需要将这个属性设置为NO label.translatesAutoresizingMaskIntoConstraints = NO; label.backgroundColor = [UIColor redColor]; //创建x居中的约束 NSLayoutConstraint * constraintx = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1 constant:0]; //创建y居中的约束 NSLayoutConstraint * constrainty = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterY multiplier:1 constant:0]; //创建宽度约束 NSLayoutConstraint * constraintw = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:100]; //创建高度约束 NSLayoutConstraint * constrainth = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:100]; //添加约束之前，必须将视图加在父视图上 [self.view addSubview:label]; [self.view addConstraints:@[constraintx,constrainty,constrainth,constraintw]]; 效果如下： 可以发现，一个如此简单的约束方式，我们用这样的代码要写这么一大坨，麻烦而且不直观。于是，apple又提供给我们下面一种方式。 2.使用ASCLL字符创造艺术般的格式化字符串约束看到这个小标题是不是眼前一亮，这个标题不是我凭空想象出来的，apple的文档上就是这么写的。十分可爱，对吧。相对于NSLayoutConstraint中的创建方法如下： 1+ (NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(nullable NSDictionary&lt;NSString *,id&gt; *)metrics views:(NSDictionary&lt;NSString *, id&gt; *)views; 那么我们先来看，什么是格式化的字符串约束。 说到格式化的字符串约束，要先提一个东西VFL：visual format language——格式化约束语言，这又是什么鬼？确实，这个东西写出来第一眼看上去真的不知道是什么鬼，就比如要设置一个label，距离上边100，左边20，宽高都为100，代码如下： 12345678910 label.numberOfLines = 0; label.translatesAutoresizingMaskIntoConstraints = NO; label.backgroundColor = [UIColor redColor]; //label.text=@&quot;12332322132131233213213&quot;; [self.view addSubview:label]; NSArray * constraintArray = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-20-[label(100@1000)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(label)]; NSArray * constraintArray2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-100-[label(100)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(label)]; [self.view addConstraints:constraintArray]; [self.view addConstraints:constraintArray2]; 效果如下： 代码少了很多，对吧，但是中间那部分字符串什么玩意？下面我们来解释一下。 VFL语言我个人而言，他很类似于古代的象形文字(不知道是否apple的工程师从其中得到灵感)，对布局的约束设置是直观的用符号表达出来的，例如： 1H:|-20-[label(100@1000)] 前面的H代表是水平的布局还是垂直的布局，H代表水平，V表示垂直，|表示父视图的边沿，-20-表示距离20px，[]内是要布局摆放的视图对象名，()中是约束的尺寸，H下则为宽度，V下则为高度,@后面的数字代表优先级。 创建方法中的options参数，用来设置对齐模式，不需要可以写0： 1234567891011121314151617181920212223typedef NS_OPTIONS(NSUInteger, NSLayoutFormatOptions) &#123; NSLayoutFormatAlignAllLeft = (1 &lt;&lt; NSLayoutAttributeLeft), NSLayoutFormatAlignAllRight = (1 &lt;&lt; NSLayoutAttributeRight), NSLayoutFormatAlignAllTop = (1 &lt;&lt; NSLayoutAttributeTop), NSLayoutFormatAlignAllBottom = (1 &lt;&lt; NSLayoutAttributeBottom), NSLayoutFormatAlignAllLeading = (1 &lt;&lt; NSLayoutAttributeLeading), NSLayoutFormatAlignAllTrailing = (1 &lt;&lt; NSLayoutAttributeTrailing), NSLayoutFormatAlignAllCenterX = (1 &lt;&lt; NSLayoutAttributeCenterX), NSLayoutFormatAlignAllCenterY = (1 &lt;&lt; NSLayoutAttributeCenterY), NSLayoutFormatAlignAllBaseline = (1 &lt;&lt; NSLayoutAttributeBaseline), NSLayoutFormatAlignAllLastBaseline = NSLayoutFormatAlignAllBaseline, NSLayoutFormatAlignAllFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0) = (1 &lt;&lt; NSLayoutAttributeFirstBaseline), NSLayoutFormatAlignmentMask = 0xFFFF, /* choose only one of these three */ NSLayoutFormatDirectionLeadingToTrailing = 0 &lt;&lt; 16, // default NSLayoutFormatDirectionLeftToRight = 1 &lt;&lt; 16, NSLayoutFormatDirectionRightToLeft = 2 &lt;&lt; 16, NSLayoutFormatDirectionMask = 0x3 &lt;&lt; 16, &#125;; metrics参数是属性替换字典，例如我们上边用到的距离左边界20，如果这个20是一个变量width,我们可以将20的地方换成width，然后配置这个字典：@{@”width”:@20}，这样，在布局时，系统会把width换成20。 views是对象的映射字典，原理也是将字符串中的对象名label映射成真实的对象，NSDictionaryOfVariableBindings会帮我们生成这样的字典，我们只需要想对象传进去即可，如果要手动创建这字典，格式如下：@{@”label”：label}. 三、使用aotulayout设计一个聊天界面的输入框仔细观察QQ或者其他聊天工具的app上的输入框，会发现他非常智能，宽度会随着我们输入文字的行数进行自适应，并且这个宽度不是无限增大的，当我们文字多到一定行数，宽度会保持不变，文本框可以进行内容滑动，如果不用autolayout，这个功能会比较棘手一些，但是使用它，会发现这是如此的容易： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@interface ViewController ()&lt;UITextViewDelegate&gt;&#123; UITextView * textView ; NSArray * array1; NSArray * array2;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. textView = [[UITextView alloc]init]; textView.layer.borderColor = [[UIColor grayColor]CGColor]; textView.layer.borderWidth = 1; textView.translatesAutoresizingMaskIntoConstraints = NO; textView.delegate=self; [self.view addSubview:textView]; array1 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-100-[textView]-100-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; array2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-150-[textView(30)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; [self.view addConstraints:array1]; [self.view addConstraints:array2]; &#125;-(BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text&#123; //当文本高度大于textView的高度并且小于100时，更新约束 if (textView.contentSize.height&gt;textView.frame.size.height&amp;&amp;textView.contentSize.height&lt;100) &#123; float hight =textView.contentSize.height; //将以前的移除掉 [self.view removeConstraints:array1]; [self.view removeConstraints:array2]; array1 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-100-[textView]-100-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; array2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-150-[textView(hight)]&quot; options:0 metrics:@&#123;@&quot;hight&quot;:[NSNumber numberWithFloat:hight]&#125; views:NSDictionaryOfVariableBindings(textView)]; [self.view addConstraints:array1]; [self.view addConstraints:array2]; &#125; //更新约束 [self.view updateConstraintsIfNeeded]; return YES;&#125; 现在，当我们进行输入的时候，textView的高度可以自适应文字行数了。 四、通过动画改善更新约束时的效果这一点非常coll，上面我们已经实现了textView随文本的行数高度进行自适应，但是变化的效果十分生硬，还要apple的动画框架支持autolayout，把刚才调用更新约束的地方进行如下修改： 123[UIView animateWithDuration:1 animations:^&#123; [self.view layoutIfNeeded]; &#125;]; 试试看，变换的效果已经非常平滑了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列七——三维中的球型布局","slug":"142iOS流布局UICollectionView系列七——三维中的球型布局","date":"2015-10-28T16:00:00.000Z","updated":"2021-07-03T12:45:53.847Z","comments":true,"path":"2015/10/29/142iOS流布局UICollectionView系列七——三维中的球型布局/","link":"","permalink":"http://huishao.cc/2015/10/29/142iOS流布局UICollectionView系列七——三维中的球型布局/","excerpt":"","text":"iOS流布局UICollectionView系列七——三维中的球型布局一、引言通过6篇的博客，从平面上最简单的规则摆放的布局，到不规则的瀑布流布局，再到平面中的圆环布局，我们突破了线性布局的局限，在后面，我们将布局扩展到了空间，在Z轴上进行了平移，我们实现了一个类似UIPickerView的布局模型，其实我们还可以再进一步，类比于平面布局，picKerView只是线性排列布局在空间上的旋转与平移，这次，我们更加充分了利用一下空间的尺寸，来设计一个圆球的布局模型。以下是前几篇博客地址： 1.初识与简单实用UICollectionView：http://my.oschina.net/u/2340880/blog/522613 2.UICollectionView的代理方法：http://my.oschina.net/u/2340880/blog/522682 3.实用FlowLayout进行更灵活布局：http://my.oschina.net/u/2340880/blog/522748 4.自定义FlowLayout进行瀑布流布局：http://my.oschina.net/u/2340880/blog/522806 5.平面圆环布局的实现：http://my.oschina.net/u/2340880/blog/523064 6.将布局从平面应用到空间：http://my.oschina.net/u/2340880/blog/523341 二、将布局扩展为空间球型在viewController中先实现一些准备代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; //这里设置的偏移量是为了无缝进行循环的滚动，具体在上一篇博客中有解释 collect.contentOffset = CGPointMake(320, 400); [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;//我们返回30的标签-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 30;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; label.text = [NSString stringWithFormat:@&quot;%ld&quot;,(long)indexPath.row]; [cell.contentView addSubview:label]; return cell;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;//这里对滑动的contentOffset进行监控，实现循环滚动-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y&lt;200) &#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y+10*400); &#125;else if(scrollView.contentOffset.y&gt;11*400)&#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y-10*400); &#125; if (scrollView.contentOffset.x&lt;160) &#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x+10*320,scrollView.contentOffset.y); &#125;else if(scrollView.contentOffset.x&gt;11*320)&#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x-10*320,scrollView.contentOffset.y); &#125;&#125; 这里面的代码比较上一篇博客中的并没有什么大的改动，只是做了横坐标的兼容。 在我们的layout类中，将代码修改成如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-(void)prepareLayout&#123; [super prepareLayout]; &#125;//返回的滚动范围增加了对x轴的兼容-(CGSize)collectionViewContentSize&#123; return CGSizeMake( self.collectionView.frame.size.width*([self.collectionView numberOfItemsInSection:0]+2), self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2));&#125;-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES;&#125;-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //获取item的个数 int itemCounts = (int)[self.collectionView numberOfItemsInSection:0]; atti.center = CGPointMake(self.collectionView.frame.size.width/2+self.collectionView.contentOffset.x, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y); atti.size = CGSizeMake(30, 30); CATransform3D trans3D = CATransform3DIdentity; trans3D.m34 = -1/900.0; CGFloat radius = 15/tanf(M_PI*2/itemCounts/2); //根据偏移量 改变角度 //添加了一个x的偏移量 float offsety = self.collectionView.contentOffset.y; float offsetx = self.collectionView.contentOffset.x; //分别计算偏移的角度 float angleOffsety = offsety/self.collectionView.frame.size.height; float angleOffsetx = offsetx/self.collectionView.frame.size.width; CGFloat angle1 = (float)(indexPath.row+angleOffsety-1)/itemCounts*M_PI*2; //x，y的默认方向相反 CGFloat angle2 = (float)(indexPath.row-angleOffsetx-1)/itemCounts*M_PI*2; //这里我们进行四个方向的排列 if (indexPath.row%4==1) &#123; trans3D = CATransform3DRotate(trans3D, angle1, 1.0,0, 0); &#125;else if(indexPath.row%4==2)&#123; trans3D = CATransform3DRotate(trans3D, angle2, 0, 1, 0); &#125;else if(indexPath.row%4==3)&#123; trans3D = CATransform3DRotate(trans3D, angle1, 0.5,0.5, 0); &#125;else&#123; trans3D = CATransform3DRotate(trans3D, angle1, 0.5,-0.5,0); &#125; trans3D = CATransform3DTranslate(trans3D, 0, 0, radius); atti.transform3D = trans3D; return atti;&#125;-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray * attributes = [[NSMutableArray alloc]init]; //遍历设置每个item的布局属性 for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123; [attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]]; &#125; return attributes;&#125; 布局效果如下： 滑动屏幕，这个圆球是可以进行滚动的。 TIP：这里我们只平均分配了四个方向上的布局，如果item更加小也更加多，我们可以分配到更多的方向上，使球体更加充实。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列六——将布局从平面应用到空间","slug":"141iOS流布局UICollectionView系列六——将布局从平面应用到空间","date":"2015-10-27T16:00:00.000Z","updated":"2021-07-03T12:42:34.298Z","comments":true,"path":"2015/10/28/141iOS流布局UICollectionView系列六——将布局从平面应用到空间/","link":"","permalink":"http://huishao.cc/2015/10/28/141iOS流布局UICollectionView系列六——将布局从平面应用到空间/","excerpt":"","text":"iOS流布局UICollectionView系列六——将布局从平面应用到空间一、引言前面，我们将布局由线性的瀑布流布局扩展到了圆环布局，这使我们使用UICollectionView的布局思路大大迈进了一步，这次，我们玩的更加炫一些，想办法将布局应用的空间，你是否还记得，在管理布局的item的具体属性的类UICollectionViewLayoutAttributrs类中，有transform3D这个属性，通过这个属性的设置，我们真的可以在空间的坐标系中进行布局设计。iOS系统的控件中，也并非没有这样的先例，UIPickerView就是很好的一个实例，这篇博客，我们就通过使用UICollectionView实现一个类似系统的UIPickerView的布局视图，来体会UICollectionView在3D控件布局的魅力。系统的pickerView效果如下： 二、先来实现一个炫酷的滚轮空间布局万丈的高楼也是由一砖一瓦堆砌而成，在我们完全模拟系统pickerView前，我们应该先将视图的布局摆放这一问题解决。我们依然来创建一个类，继承于UICollectionViewLayout： 123@interface MyLayout : UICollectionViewLayout@end 对于.m文件的内容，前几篇博客中我们都是在prepareLayout中进行布局的静态设置，那是因为我们前几篇博客中的布局都是静态的，布局并不会随着我们的手势操作而发生太大的变化，因此我们全部在prepareLayout中一次配置完了。而我们这次要讨论的布局则不同，pickerView会随着我们手指的拖动而进行滚动，因此UICollectionView中的每一个item的布局是在不断变化的，所以这次，我们采用动态配置的方式，在layoutAttributesForItemAtIndexPath方法中进行每个item的布局属性设置。 至于layoutAttributesForItemAtIndexPath方法，它也是UICollectionViewLayout类中的方法，用于我们自定义时进行重写，至于为什么动态布局要在这里面配置item的布局属性，后面我们会了解到。 在编写我们的布局类之前，先做好准备工作，在viewController中，实现如下代码： 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 250, 80)]; label.text = [NSString stringWithFormat:@&quot;我是第%ld行&quot;,(long)indexPath.row]; [cell.contentView addSubview:label]; return cell;&#125; 上面我创建了10个Item，并且在每个Item上添加了一个标签，标写是第几行。 在我们自定义的布局类中重写layoutAttributesForElementsInRect，在其中返回我们的布局数组： 12345678-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray * attributes = [[NSMutableArray alloc]init]; //遍历设置每个item的布局属性 for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123; [attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]]; &#125; return attributes;&#125; 之后，在我们布局类中重写layoutAttributesForItemAtIndexPath方法： 12345678910111213-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; //创建一个item布局属性类 UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //获取item的个数 int itemCounts = (int)[self.collectionView numberOfItemsInSection:0]; //设置每个item的大小为260*100 atti.size = CGSizeMake(260, 100); /* 后边介绍的代码添加在这里 */ return atti;&#125; 上面的代码中，我们什么都没有做，下面我们一步步来实现3D的滚轮效果。 首先，我们先将所有的item的位置都设置为collectionView的中心： 1atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2); 这时，如果我们运行程序的话，所有item都将一层层贴在屏幕的中央，如下： 很丑对吧，之后我们来设置每个item的3D效果,在上面的布局方法中添加如下代码: 12345678910111213141516 //创建一个transform3D类 //CATransform3D是一个类似矩阵的结构体 //CATransform3DIdentity创建空得矩阵 CATransform3D trans3D = CATransform3DIdentity; //这个值设置的是透视度，影响视觉离投影平面的距离 trans3D.m34 = -1/900.0; //下面这些属性 后面会具体介绍 //这个是3D滚轮的半径 CGFloat radius = 50/tanf(M_PI*2/itemCounts/2); //计算每个item应该旋转的角度 CGFloat angle = (float)(indexPath.row)/itemCounts*M_PI*2; //这个方法返回一个新的CATransform3D对象，在原来的基础上进行旋转效果的追加 //第一个参数为旋转的弧度，后三个分别对应x，y，z轴，我们需要以x轴进行旋转 trans3D = CATransform3DRotate(trans3D, angle, 1.0, 0, 0); //进行设置 atti.transform3D = trans3D; 对于上面的radius属性，运用了一些简单的几何和三角函数的知识。如果我们将系统的pickerView沿着y轴旋转90°，你会发现侧面的它是一个规则的正多边形，这里的radius就是这个多边形中心到其边的垂直距离，也是内切圆的半径，所有的item拼成了一个正多边形，示例如下： 通过简单的数学知识，h/2弦对应的角的弧度为2*pi/(边数)/2，在根据三角函数相关知识可知，这个角的正切值为h/2/radius，这就是我们radius的由来。 对于angle属性，它是每一个item的x轴旋转度数，如果我们将所有item的中心都放在一点，通过旋转让它们散开如下图所示： 每个item旋转的弧度就是其索引/(2*pi)。 通过上面的设置，我们再运行代码，效果如下： 仔细观察我们可以发现，item以x中轴线进行了旋转平均布局，侧面的效果就是我们上面的简笔画那样，下面要进行我们的第三步了，将这个item，全部沿着其Z轴向前拉，就可以成为我们滚轮的效果，示例图如下： 我们继续在刚才的代码后面添加这行代码： 12 //这个方法也返回一个transform3D对象，追加平移效果，后面三个参数，对应平移的x，y，z轴，我们沿z轴平移 trans3D = CATransform3DTranslate(trans3D, 0, 0, radius); 再次运行，效果如下： 布局的效果我们已经完成了，离成功很近了对吧，只是现在的布局是静态的，我们不能滑动这个滚轮，我们还需要用动态滑动做一些处理。 三、让滚轮滑动起来 通过上面的努力，我们已经静态布局出了一个类似pickerView的滚轮，现在我们再来添加滑动滚动的效果 首先，我们需要给collectionView一个滑动的范围，我们以一屏collectionView的滑动距离来当做滚轮滚动一下的参照，我们在布局类中的如下方法中返回滑动区域： 123-(CGSize)collectionViewContentSize&#123; return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*[self.collectionView numberOfItemsInSection:0]);&#125; 这时我们的collectionView已经可以进行滑动，但是并不是我们想要的效果，滚轮并没有滚动，而是随着滑动出了屏幕，因此，我们需要在滑动的时候不停的动态布局，将滚轮始终固定在collectionView的中心，先需要在布局类中实现如下方法： 12345//返回yes，则一有变化就会刷新布局-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES; &#125; 将上面的布局的中心点设置加上一个动态的偏移量： 1 atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y); 现在在运行，会发现滚轮会随着滑动始终固定在中间，但是还是不如人意，滚轮并没有转动起来，我们还需要动态的设置每个item的旋转角度，这样连续看起来，滚轮就转了起来，在上面设置布局的方法中，我们在添加一些处理： 12345 //获取当前的偏移量 float offset = self.collectionView.contentOffset.y; //在角度设置上，添加一个偏移角度 float angleOffset = offset/self.collectionView.frame.size.height; CGFloat angle = (float)(indexPath.row+angleOffset)/itemCounts*M_PI*2; 再看看效果，没错，就是这么简单，滚轮已经转了起来。 四、让其循环滚动的逻辑我们再进一步，如果滚动可以循环，这个控件将更加炫酷，添加这样的逻辑也很简单，通过监测scrollView的偏移量，我们可以对齐进行处理，因为collectionView继承于scrollView，我们可以直接在ViewController中实现其代理方法，如下： 123456789-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //小于半屏 则放到最后一屏多半屏 if (scrollView.contentOffset.y&lt;200) &#123; scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y+10*400); //大于最后一屏多一屏 放回第一屏 &#125;else if(scrollView.contentOffset.y&gt;11*400)&#123; scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y-10*400); &#125;&#125; 因为咱们的环状布局，上面的逻辑刚好可以无缝对接，但是会有新的问题，一开始运行，滚轮就是出现在最后一个item的位置，而不是第一个，并且有些相关的地方，我们也需要一些适配： 在viewController中： 12//一开始将collectionView的偏移量设置为1屏的偏移量collect.contentOffset = CGPointMake(0, 400); 在layout类中： 1234//将滚动范围设置为(item总数+2)*每屏高度 -(CGSize)collectionViewContentSize&#123; return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2));&#125; 12//将计算的具体item角度向前递推一个CGFloat angle = (float)(indexPath.row+angleOffset-1)/itemCounts*M_PI*2; OK，我们终于大功告成了，可以发现，实现这样一个布局效果炫酷的控件，代码其实并没有多少，相比，数学逻辑要比编写代码本身困难，这十分类似数学中的几何问题，如果你弄清了逻辑，解决是分分钟的事，我们可以通过这样的一个思路，设计更多3D或者平面特效的布局方案，抽奖的转动圆盘，书本的翻页，甚至立体的标签云，UICollectionView都可以实现，这篇博客中的代码在下面的连接中，疏漏之处，欢迎指正！ http://pan.baidu.com/s/1jGCmbKM 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列五——圆环布局的实现","slug":"140iOS流布局UICollectionView系列五——圆环布局的实现","date":"2015-10-27T16:00:00.000Z","updated":"2021-07-03T12:41:16.436Z","comments":true,"path":"2015/10/28/140iOS流布局UICollectionView系列五——圆环布局的实现/","link":"","permalink":"http://huishao.cc/2015/10/28/140iOS流布局UICollectionView系列五——圆环布局的实现/","excerpt":"","text":"iOS流布局UICollectionView系列五——圆环布局的实现一、引言前边的几篇博客，我们了解了UICollectionView的基本用法以及一些扩展，在不定高的瀑布流布局中，我们发现，可以通过设置具体的布局属性类UICollectionViewLayoutAttributes来设置设置每个item的具体位置，我们可以再扩展一下，如果位置我们可以自由控制，那个布局我们也可以更加灵活，就比如创建一个如下的circleLayout： 这种布局方式在apple的官方文档中也有介绍，是UICollectionView的一个应用示例。 二、设计一个圆环布局接着我们以前的想法，依然时候随机颜色的色块来表达我们的item，先自定义一个layout类，这个类继承于UICollectionViewLayout，UICollectionLayout是一个布局抽象基类，我们要使用自定义的布局方式，必须将其子类化，可能你还记得，我们在进行瀑布流布局的时候使用过UICollectionViewFlowLayout类，这个类就是继承于UICollectionViewLayout类，系统为我们实现好的一个布局方案。 1234@interface MyLayout : UICollectionViewLayout//这个int值存储有多少个item@property(nonatomic,assign)int itemCount;@end 我们需要重写这个类的三个方法，来进行圆环布局的设置，首先是prepareLayout，为布局做一些准备工作，使用collectionViewContentSize来设置内容的区域大小，最后使用layoutAttributesForElementsInRect方法来返回我们的布局信息字典，这个前面瀑布流布局的思路是一样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@implementation MyLayout&#123; NSMutableArray * _attributeAttay;&#125;-(void)prepareLayout&#123; [super prepareLayout]; //获取item的个数 _itemCount = (int)[self.collectionView numberOfItemsInSection:0]; _attributeAttay = [[NSMutableArray alloc]init]; //先设定大圆的半径 取长和宽最短的 CGFloat radius = MIN(self.collectionView.frame.size.width, self.collectionView.frame.size.height)/2; //计算圆心位置 CGPoint center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2); //设置每个item的大小为50*50 则半径为25 for (int i=0; i&lt;_itemCount; i++) &#123; UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]; //设置item大小 attris.size = CGSizeMake(50, 50); //计算每个item的圆心位置 /* . . . . . r . . ......... */ //计算每个item中心的坐标 //算出的x y值还要减去item自身的半径大小 float x = center.x+cosf(2*M_PI/_itemCount*i)*(radius-25); float y = center.y+sinf(2*M_PI/_itemCount*i)*(radius-25); attris.center = CGPointMake(x, y); [_attributeAttay addObject:attris]; &#125; &#125;//设置内容区域的大小-(CGSize)collectionViewContentSize&#123; return self.collectionView.frame.size;&#125;//返回设置数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return _attributeAttay;&#125; 在viewController中代码如下： 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.layer.masksToBounds = YES; cell.layer.cornerRadius = 25; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 如上非常简单的一些逻辑控制，我们就实现哦圆环布局，随着item的多少，布局会自动调整，如果不是UICollectionView的功劳，实现这样的功能，我们可能要写上一阵子了^_^。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局","slug":"139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局","date":"2015-10-26T16:00:00.000Z","updated":"2021-07-03T12:40:20.507Z","comments":true,"path":"2015/10/27/139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局/","link":"","permalink":"http://huishao.cc/2015/10/27/139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局/","excerpt":"","text":"iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局一、引言前几篇博客从UICollectionView的基础应用到设置UICollectionViewFlowLayout更加灵活的进行布局，但都限制在系统为我们准备好的布局框架中，还是有一些局限性，例如，如果我要进行瀑布流似的不定高布局，前面的方法就很难满足我们的需求了，如下： 这种布局无疑在app的应用中更加广泛，商品的展示，书架书目的展示，都会倾向于采用这样的布局方式，当然，通过自定义FlowLayout，我们也很容易实现。 二、进行自定义瀑布流布局首先，我们新建一个文件继承于UICollectionViewFlowLayout： 1@interface MyLayout : UICollectionViewFlowLayout 为了演示的方面，这里我不错更多的封装，添加一个属性，直接让外界将item个数传递进来，我们把重心方法重写布局的方法上： 123@interface MyLayout : UICollectionViewFlowLayout@property(nonatomic,assign)int itemCount;@end 前面说过，UICollectionViewFlowLayout是一个专门用来管理collectionView布局的类，因此，collectionView在进行UI布局前，会通过这个类的对象获取相关的布局信息，FlowLayout类将这些布局信息全部存放在了一个数组中，数组中是UICollectionViewLayoutAttributes类，这个类是对item布局的具体设置，以后咱们在讨论这个类。总之，FlowLayout类将每个item的位置等布局信息放在一个数组中，在collectionView布局时，会调用FlowLayout类layoutAttributesForElementsInRect：方法来获取这个布局配置数组。因此，我们需要重写这个方法，返回我们自定义的配置数组，另外，FlowLayout类在进行布局之前，会调用prepareLayout方法，所以我们可以重写这个方法，在里面对我们的自定义配置数据进行一些设置。 简单来说，自定义一个FlowLayout布局类就是两个步骤： 1、设计好我们的布局配置数据 prepareLayout方法中 2、返回我们的配置数组 layoutAttributesForElementsInRect方法中 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@implementation MyLayout&#123; //这个数组就是我们自定义的布局配置数组 NSMutableArray * _attributeAttay;&#125;//数组的相关设置在这个方法中//布局前的准备会调用这个方法-(void)prepareLayout&#123; _attributeAttay = [[NSMutableArray alloc]init]; [super prepareLayout]; //演示方便 我们设置为静态的2列 //计算每一个item的宽度 float WIDTH = ([UIScreen mainScreen].bounds.size.width-self.sectionInset.left-self.sectionInset.right-self.minimumInteritemSpacing)/2; //定义数组保存每一列的高度 //这个数组的主要作用是保存每一列的总高度，这样在布局时，我们可以始终将下一个Item放在最短的列下面 CGFloat colHight[2]=&#123;self.sectionInset.top,self.sectionInset.bottom&#125;; //itemCount是外界传进来的item的个数 遍历来设置每一个item的布局 for (int i=0; i&lt;_itemCount; i++) &#123; //设置每个item的位置等相关属性 NSIndexPath *index = [NSIndexPath indexPathForItem:i inSection:0]; //创建一个布局属性类，通过indexPath来创建 UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:index]; //随机一个高度 在40——190之间 CGFloat hight = arc4random()%150+40; //哪一列高度小 则放到那一列下面 //标记最短的列 int width=0; if (colHight[0]&lt;colHight[1]) &#123; //将新的item高度加入到短的一列 colHight[0] = colHight[0]+hight+self.minimumLineSpacing; width=0; &#125;else&#123; colHight[1] = colHight[1]+hight+self.minimumLineSpacing; width=1; &#125; //设置item的位置 attris.frame = CGRectMake(self.sectionInset.left+(self.minimumInteritemSpacing+WIDTH)*width, colHight[width]-hight-self.minimumLineSpacing, WIDTH, hight); [_attributeAttay addObject:attris]; &#125; //设置itemSize来确保滑动范围的正确 这里是通过将所有的item高度平均化，计算出来的(以最高的列位标准) if (colHight[0]&gt;colHight[1]) &#123; self.itemSize = CGSizeMake(WIDTH, (colHight[0]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing); &#125;else&#123; self.itemSize = CGSizeMake(WIDTH, (colHight[1]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing); &#125; &#125;//这个方法中返回我们的布局数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return _attributeAttay;&#125;@end 自定义完成FlowLayout后，我们在ViewController中进行使用： 123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; layout.scrollDirection = UICollectionViewScrollDirectionVertical; layout.itemCount=100; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect]; &#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 100;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 运行效果就是我们引言中的截图。 三、UICollectionViewLayoutAttributes类中我们可以配置的属性通过上面的例子，我们可以了解，collectionView的item布局其实是LayoutAttributes类具体配置的，这个类可以配置的布局属性不止是frame这么简单，其中还有许多属性： 12345678910111213141516171819202122232425262728//配置item的布局位置@property (nonatomic) CGRect frame;//配置item的中心@property (nonatomic) CGPoint center;//配置item的尺寸@property (nonatomic) CGSize size;//配置item的3D效果@property (nonatomic) CATransform3D transform3D;//配置item的bounds@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);//配置item的旋转@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0);//配置item的alpha@property (nonatomic) CGFloat alpha;//配置item的z坐标@property (nonatomic) NSInteger zIndex; // default is 0//配置item的隐藏@property (nonatomic, getter=isHidden) BOOL hidden; //item的indexpath@property (nonatomic, strong) NSIndexPath *indexPath;//获取item的类型@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;@property (nonatomic, readonly, nullable) NSString *representedElementKind; //一些创建方法+ (instancetype)layoutAttributesForCellWithIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath *)indexPath; 通过上面的属性，可以布局出各式各样的炫酷效果，正如一句话：没有做不到，只有想不到。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列一——初识与简单使用UICollectionView image解决方法","slug":"136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView","date":"2015-10-26T16:00:00.000Z","updated":"2021-07-03T12:38:08.953Z","comments":true,"path":"2015/10/27/136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView/","link":"","permalink":"http://huishao.cc/2015/10/27/136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView/","excerpt":"","text":"iOS流布局UICollectionView系列一——初识与简单使用UICollectionView一、简介UICollectionView是iOS6之后引入的一个新的UI控件，它和UITableView有着诸多的相似之处，其中许多代理方法都十分类似。简单来说，UICollectionView是比UITbleView更加强大的一个UI控件，有如下几个方面： 1、支持水平和垂直两种方向的布局 2、通过layout配置方式进行布局 3、类似于TableView中的cell特性外，CollectionView中的Item大小和位置可以自由定义 4、通过layout布局回调的代理方法，可以动态的定制每个item的大小和collection的大体布局属性 5、更加强大一点，完全自定义一套layout布局方案，可以实现意想不到的效果 这篇博客，我们主要讨论CollectionView使用原生layout的方法和相关属性，其他特点和更强的制定化，会在后面的博客中介绍 二、先来实现一个最简单的九宫格类布局在了解UICollectionView的更多属性前，我们先来使用其进行一个最简单的流布局试试看，在controller的viewDidLoad中添加如下代码： 123456789101112131415 //创建一个layout布局类 UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; //设置布局方向为垂直流布局 layout.scrollDirection = UICollectionViewScrollDirectionVertical; //设置每个item的大小为100*100 layout.itemSize = CGSizeMake(100, 100); //创建collectionView 通过一个布局策略layout来创建 UICollectionView * collect = [[UICollectionView alloc]initWithFrame:self.view.frame collectionViewLayout:layout]; //代理设置 collect.delegate=self; collect.dataSource=self; //注册item类型 这里使用系统的类型 [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect]; 这里有一点需要注意，collectionView在完成代理回调前，必须注册一个cell，类似如下: 1[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; 这和tableView有些类似，又有些不同，因为tableView除了注册cell的方法外，还可以通过临时创建来做： 12345//tableView在从复用池中取cell的时候，有如下两种方法//使用这种方式如果复用池中无，是可以返回nil的，我们在临时创建即可- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;//6.0后使用如下的方法直接从注册的cell类获取创建，如果没有注册 会崩溃- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); 我们可以分析：因为UICollectionView是iOS6.0之前的新类，因此这里统一了从复用池中获取cell的方法，没有再提供可以返回nil的方式，并且在UICollectionView的回调代理中，只能使用从复用池中获取cell的方式进行cell的返回，其他方式会崩溃，例如： 1234567891011121314//这是正确的方法-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125;//这样做会崩溃-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;// UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];// cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UICollectionViewCell * cell = [[UICollectionViewCell alloc]init]; return cell;&#125; 上面错误的方式会崩溃，信息如下，让我们使用从复用池中取cell的方式： 上面的设置完成后，我们来实现如下几个代理方法： 这里与TableView的回调方式十分类似 1234567891011121314//返回分区个数-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;//返回每个分区的item个数-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;//返回每个item-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 效果如下： 同样，如果内容的大小超出一屏，和tableView类似是可以进行视图滑动的。 还有一点细节，我们在上面设置布局方式的时候设置了垂直布局： 123layout.scrollDirection = UICollectionViewScrollDirectionVertical;//这个是水平布局//layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; 这样系统会在一行充满后进行第二行的排列，如果设置为水平布局，则会在一列充满后，进行第二列的布局，这种方式也被称为流式布局 三、UICollectionView中的常用方法和属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//通过一个布局策略初识化CollectionView- (instancetype)initWithFrame:(CGRect)frame collectionViewLayout:(UICollectionViewLayout *)layout;//获取和设置collection的layout@property (nonatomic, strong) UICollectionViewLayout *collectionViewLayout;//数据源和代理@property (nonatomic, weak, nullable) id &lt;UICollectionViewDelegate&gt; delegate;@property (nonatomic, weak, nullable) id &lt;UICollectionViewDataSource&gt; dataSource;//从一个class或者xib文件进行cell(item)的注册- (void)registerClass:(nullable Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;//下面两个方法与上面相似，这里注册的是头视图或者尾视图的类//其中第二个参数是设置 头视图或者尾视图 系统为我们定义好了这两个字符串//UIKIT_EXTERN NSString *const UICollectionElementKindSectionHeader NS_AVAILABLE_IOS(6_0);//UIKIT_EXTERN NSString *const UICollectionElementKindSectionFooter NS_AVAILABLE_IOS(6_0);- (void)registerClass:(nullable Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier;//这两个方法是从复用池中取出cell或者头尾视图- (__kindof UICollectionViewCell *)dequeueReusableCellWithReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;- (__kindof UICollectionReusableView *)dequeueReusableSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;//设置是否允许选中 默认yes@property (nonatomic) BOOL allowsSelection;//设置是否允许多选 默认no@property (nonatomic) BOOL allowsMultipleSelection;//获取所有选中的item的位置信息- (nullable NSArray&lt;NSIndexPath *&gt; *)indexPathsForSelectedItems; //设置选中某一item，并使视图滑动到相应位置，scrollPosition是滑动位置的相关参数，如下：/*typedef NS_OPTIONS(NSUInteger, UICollectionViewScrollPosition) &#123; //无 UICollectionViewScrollPositionNone = 0, //垂直布局时使用的 对应上中下 UICollectionViewScrollPositionTop = 1 &lt;&lt; 0, UICollectionViewScrollPositionCenteredVertically = 1 &lt;&lt; 1, UICollectionViewScrollPositionBottom = 1 &lt;&lt; 2, //水平布局时使用的 对应左中右 UICollectionViewScrollPositionLeft = 1 &lt;&lt; 3, UICollectionViewScrollPositionCenteredHorizontally = 1 &lt;&lt; 4, UICollectionViewScrollPositionRight = 1 &lt;&lt; 5&#125;;*/- (void)selectItemAtIndexPath:(nullable NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UICollectionViewScrollPosition)scrollPosition;//将某一item取消选中- (void)deselectItemAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;//重新加载数据- (void)reloadData;//下面这两个方法，可以重新设置collection的布局，后面的方法多了一个布局完成后的回调，iOS7后可以用//使用这两个方法可以产生非常炫酷的动画效果- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated;- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);//下面这些方法更加强大，我们可以对布局更改后的动画进行设置//这个方法传入一个布局策略layout，系统会开始进行布局渲染，返回一个UICollectionViewTransitionLayout对象//这个UICollectionViewTransitionLayout对象管理动画的相关属性，我们可以进行设置- (UICollectionViewTransitionLayout *)startInteractiveTransitionToCollectionViewLayout:(UICollectionViewLayout *)layout completion:(nullable UICollectionViewLayoutInteractiveTransitionCompletion)completion NS_AVAILABLE_IOS(7_0);//准备好动画设置后，我们需要调用下面的方法进行布局动画的展示，之后会调用上面方法的block回调- (void)finishInteractiveTransition NS_AVAILABLE_IOS(7_0);//调用这个方法取消上面的布局动画设置，之后也会进行上面方法的block回调- (void)cancelInteractiveTransition NS_AVAILABLE_IOS(7_0);//获取分区数- (NSInteger)numberOfSections;//获取某一分区的item数- (NSInteger)numberOfItemsInSection:(NSInteger)section;//下面两个方法获取item或者头尾视图的layout属性，这个UICollectionViewLayoutAttributes对象//存放着布局的相关数据，可以用来做完全自定义布局，后面博客会介绍- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;//获取某一点所在的indexpath位置- (nullable NSIndexPath *)indexPathForItemAtPoint:(CGPoint)point;//获取某个cell所在的indexPath- (nullable NSIndexPath *)indexPathForCell:(UICollectionViewCell *)cell;//根据indexPath获取cell- (nullable UICollectionViewCell *)cellForItemAtIndexPath:(NSIndexPath *)indexPath;//获取所有可见cell的数组- (NSArray&lt;__kindof UICollectionViewCell *&gt; *)visibleCells;//获取所有可见cell的位置数组- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleItems;//下面三个方法是iOS9中新添加的方法，用于获取头尾视图- (UICollectionReusableView *)supplementaryViewForElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0);- (NSArray&lt;UICollectionReusableView *&gt; *)visibleSupplementaryViewsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleSupplementaryElementsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);//使视图滑动到某一位置，可以带动画效果- (void)scrollToItemAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UICollectionViewScrollPosition)scrollPosition animated:(BOOL)animated;//下面这些方法用于动态添加，删除，移动某些分区获取items- (void)insertSections:(NSIndexSet *)sections;- (void)deleteSections:(NSIndexSet *)sections;- (void)reloadSections:(NSIndexSet *)sections;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;- (void)insertItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)deleteItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)reloadItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)moveItemAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局","slug":"138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局","date":"2015-10-26T16:00:00.000Z","updated":"2021-07-03T12:39:40.831Z","comments":true,"path":"2015/10/27/138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局/","link":"","permalink":"http://huishao.cc/2015/10/27/138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局/","excerpt":"","text":"iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局一、引言前面的博客介绍了UICollectionView的相关方法和其协议中的方法，但对布局的管理类UICollectionViewFlowLayout没有着重探讨，这篇博客介绍关于布局的相关设置和属性方法。 UICollectionView的简单使用：http://my.oschina.net/u/2340880/blog/522613 UICollectionView相关协议方法：http://my.oschina.net/u/2340880/blog/522613 通过layout的设置，我们可以编写更加灵活的布局效果。 二、将九宫格式的布局进行升级在第一篇博客中，通过UICollectionView，我们很轻松的完成了一个九宫格的布局，但是如此中规中矩的布局方式，有时候并不能满足我们的需求，有时我们需要每一个Item展示不同的大小，代码如下： 123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init]; layout.scrollDirection = UICollectionViewScrollDirectionVertical; UICollectionView *collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; ; [self.view addSubview:collect]; &#125;//设置每个item的大小，双数的为50*50 单数的为100*100-(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; if (indexPath.row%2==0) &#123; return CGSizeMake(50, 50); &#125;else&#123; return CGSizeMake(100, 100); &#125;&#125;//代理相应方法-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 100;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 效果如下： 现在的布局效果是不是炫酷了许多。 三、UICollectionViewFlowLayout相关属性方法UICollectionViewFlowLayout是系统提供给我们一个封装好的流布局设置类，其中有一些布局属性我们可以进行设置： 设置行与行之间的间距最小距离 @property (nonatomic) CGFloat minimumLineSpacing; 设置列与列之间的间距最小距离 @property (nonatomic) CGFloat minimumInteritemSpacing; 设置每个item的大小 @property (nonatomic) CGSize itemSize; 设置每个Item的估计大小，一般不需要设置 @property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); 设置布局方向 @property (nonatomic) UICollectionViewScrollDirection scrollDirection; 这个UICollectionViewScrollDirection的枚举如下： 1234typedef NS_ENUM(NSInteger, UICollectionViewScrollDirection) &#123; UICollectionViewScrollDirectionVertical,//水平布局 UICollectionViewScrollDirectionHorizontal//垂直布局&#125;; 设置头视图尺寸大小 @property (nonatomic) CGSize headerReferenceSize; 设置尾视图尺寸大小 @property (nonatomic) CGSize footerReferenceSize; 设置分区的EdgeInset @property (nonatomic) UIEdgeInsets sectionInset; 这个属性可以设置分区的偏移量，例如我们在刚才的例子中添加如下设置： 1 layout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20); 效果如下，会看到分区的边界闪出了20像素 下面这两个方法设置分区的头视图和尾视图是否始终固定在屏幕上边和下边 @property (nonatomic) BOOL sectionHeadersPinToVisibleBounds NS_AVAILABLE_IOS(9_0); @property (nonatomic) BOOL sectionFootersPinToVisibleBounds NS_AVAILABLE_IOS(9_0); 四、动态的配置layout的相关属性UICollectionViewDelegateFlowLayout上面的方法在创建FlowLayout时静态的进行设置，如果我们需要动态的设置这些属性，就像我们例子中的，每个item的大小会有差异，我们可以通过代理来实现。 UICollectionViewDelegateFlowLayout是UICollectionViewDelegate的子协议，其中常用方法如下，我们只需要实现我们需要的即可： 动态设置每个Item的尺寸大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath; 动态设置每个分区的EdgeInsets - (UIEdgeInsets)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout insetForSectionAtIndex:(NSInteger)section; 动态设置每行的间距大小 - (CGFloat)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section; 动态设置每列的间距大小 - (CGFloat)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section; 动态设置某个分区头视图大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section; 动态设置某个分区尾视图大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列二——UICollectionView的代理方法","slug":"137iOS流布局UICollectionView系列二——UICollectionView的代理方法","date":"2015-10-26T16:00:00.000Z","updated":"2021-07-03T12:38:52.119Z","comments":true,"path":"2015/10/27/137iOS流布局UICollectionView系列二——UICollectionView的代理方法/","link":"","permalink":"http://huishao.cc/2015/10/27/137iOS流布局UICollectionView系列二——UICollectionView的代理方法/","excerpt":"","text":"iOS流布局UICollectionView系列二——UICollectionView的代理方法一、引言在上一篇博客中，介绍了最基本的UICollectionView的使用和其中我们常用的属性和方法，也介绍了瀑布流布局的过程与思路，这篇博客是上一篇的补充，来讨论关于UICollectionView的代理方法的使用。博客地址： UICollectionView的简介和简单使用：http://my.oschina.net/u/2340880/blog/522613 二、UICollectionViewDataSource协议这个协议主要用于collectionView相关数据的处理，包含方法如下： 首先，有两个方法是我们必须实现的： 设置每个分区的Item个数 - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section; 设置返回每个item的属性 - (UICollectionViewCell )collectionView:(UICollectionView )collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; 下面的方法是可选实现的： 虽然这个方法是可选的，一般我们都会去实现，设置分区数 - (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView; 对头视图或者尾视图进行设置 - (UICollectionReusableView )collectionView:(UICollectionView )collectionView viewForSupplementaryElementOfKind:(NSString )kind atIndexPath:(NSIndexPath )indexPath; 设置某个item是否可以被移动，返回NO则不能移动 - (BOOL)collectionView:(UICollectionView )collectionView canMoveItemAtIndexPath:(NSIndexPath )indexPath NS_AVAILABLE_IOS(9_0); 移动item的时候，会调用这个方法 - (void)collectionView:(UICollectionView )collectionView moveItemAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath； 三、UICollectionViewDelegate协议这个协议用来设置和处理collectionView的功能和一些逻辑，所有方法都是可选实现： 是否允许某个Item的高亮，返回NO，则不能进入高亮状态 - (BOOL)collectionView:(UICollectionView )collectionView shouldHighlightItemAtIndexPath:(NSIndexPath )indexPath; 当item高亮时触发的方法 - (void)collectionView:(UICollectionView )collectionView didHighlightItemAtIndexPath:(NSIndexPath )indexPath; 结束高亮状态时触发的方法 - (void)collectionView:(UICollectionView )collectionView didUnhighlightItemAtIndexPath:(NSIndexPath )indexPath; 是否可以选中某个Item，返回NO，则不能选中 - (BOOL)collectionView:(UICollectionView )collectionView shouldSelectItemAtIndexPath:(NSIndexPath )indexPath; 是否可以取消选中某个Item - (BOOL)collectionView:(UICollectionView )collectionView shouldDeselectItemAtIndexPath:(NSIndexPath )indexPath; 已经选中某个item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didSelectItemAtIndexPath:(NSIndexPath )indexPath; 取消选中某个Item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didDeselectItemAtIndexPath:(NSIndexPath )indexPath; 将要加载某个Item时调用的方法 - (void)collectionView:(UICollectionView )collectionView willDisplayCell:(UICollectionViewCell )cell forItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0); 将要加载头尾视图时调用的方法 - (void)collectionView:(UICollectionView )collectionView willDisplaySupplementaryView:(UICollectionReusableView )view forElementKind:(NSString )elementKind atIndexPath:(NSIndexPath )indexPath NS_AVAILABLE_IOS(8_0); 已经展示某个Item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didEndDisplayingCell:(UICollectionViewCell )cell forItemAtIndexPath:(NSIndexPath *)indexPath; 已经展示某个头尾视图时触发的方法 - (void)collectionView:(UICollectionView )collectionView didEndDisplayingSupplementaryView:(UICollectionReusableView )view forElementOfKind:(NSString )elementKind atIndexPath:(NSIndexPath )indexPath; 这个方法设置是否展示长按菜单 - (BOOL)collectionView:(UICollectionView )collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath )indexPath; 长按菜单中可以触发一下类复制粘贴的方法，效果如下： 这个方法用于设置要展示的菜单选项 - (BOOL)collectionView:(UICollectionView )collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath )indexPath withSender:(nullable id)sender; 这个方法用于实现点击菜单按钮后的触发方法,通过测试，只有copy，cut和paste三个方法可以使用 - (void)collectionView:(UICollectionView )collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath )indexPath withSender:(nullable id)sender; 通过下面的方式可以将点击按钮的方法名打印出来： 123-(void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender&#123; NSLog(@&quot;%@&quot;,NSStringFromSelector(action));&#125; collectionView进行重新布局时调用的方法 - (nonnull UICollectionViewTransitionLayout )collectionView:(UICollectionView )collectionView transitionLayoutForOldLayout:(UICollectionViewLayout )fromLayout newLayout:(UICollectionViewLayout )toLayout; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Xcode真机测试could not find developer disk image解决方法","slug":"135Xcode真机测试could not find developer disk image解决方法","date":"2015-10-24T16:00:00.000Z","updated":"2021-07-03T12:37:13.275Z","comments":true,"path":"2015/10/25/135Xcode真机测试could not find developer disk image解决方法/","link":"","permalink":"http://huishao.cc/2015/10/25/135Xcode真机测试could not find developer disk image解决方法/","excerpt":"","text":"Xcode真机测试could not find developer disk image解决方法在使用Xcode进行真机调试的时候，有时根据真机的系统不同，会出现could not find developer disk image 错误，这是由于真机系统过高或者过低，Xcode中没有匹配的配置包文件，我们可以通过这个路径进入配置包的存放目录： /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 里面有类似这样的一些文件夹，如果这些文件夹中没有包含我们真机的系统，则不能进行真机测试。但是我们可以通过将相应的配置包添加入这个文件夹来解决问题： 说了解决的方法，不提供文件，会让大家觉得坑爹，下面给大家一个链接，里面有从iOS4.2到9.1所有版本的配置包，大家各取所需，不用感谢我： http://pan.baidu.com/s/1qYIQWjE。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"watchOS中进行异步图片加载和缓存的策略","slug":"134watchOS中进行异步图片加载和缓存的策略","date":"2015-10-23T16:00:00.000Z","updated":"2021-07-03T12:33:30.631Z","comments":true,"path":"2015/10/24/134watchOS中进行异步图片加载和缓存的策略/","link":"","permalink":"http://huishao.cc/2015/10/24/134watchOS中进行异步图片加载和缓存的策略/","excerpt":"","text":"watchOS中进行异步图片加载和缓存的策略一、引言iWatch是智能手表的一次革命。iWatch的应用也将会越来越多，基于watch的一些特点，watchOS的开发者需要更加精益的把握watch的UI和性能。运用watchOS自带的缓存体系进行数据的缓存，是增强用户体验度的一种方式，这篇博客，介绍在watchOS中进行异步加载图片和缓存的方法，愿与志同道合的朋友，一起交流。 关于watchOS中的缓存框架，在这里：http://my.oschina.net/u/2340880/blog/519023 。 二、存储的命名规则在进行设计之前，我们应该先了解，watchOS的缓存容量为最大20M，因为有限，我们更应该认真的利用每一份空间，因此，缓存我们不仅可以存，在即将装满的时候，我们还要有办法从缓存中删去一些东西，让出空间，那么应该删除哪些东西了，我们应该都可以想到，当然是旧的了，把最早的缓存删掉，所以，在存的时候，我们要设计一种规则，可以保存存入的时间，并且不影响我寻找这个缓存文件。我的方法是通过格式化的命名： 1234567891011121314//这是一个规范缓存命名的方法func checkString(str:NSString)-&gt;NSString&#123; let result:NSMutableString=NSMutableString() //先将所有的非字母和数字剔除掉 for var i=0 ; i&lt;str.length ; i++ &#123; if (str.characterAtIndex(i)&gt;=48&amp;&amp;str.characterAtIndex(i)&lt;=57)||(str.characterAtIndex(i)&gt;=65&amp;&amp;str.characterAtIndex(i)&lt;=90)||(str.characterAtIndex(i)&gt;=97&amp;&amp;str.characterAtIndex(i)&lt;=122)&#123; result.appendFormat(&quot;%c&quot;,str.characterAtIndex(i)) &#125; &#125; //拼接上当前时间戳 let date:Double = NSDate().timeIntervalSince1970 result.appendFormat(&quot;?%.0f&quot;,date) return result&#125; 通过？符号将名称和时间戳进行了拼接。 二、进行异步加载图片和缓存这一步是如下的设计思路：通过图片url从缓存的路径中进行寻找，如果有，直接取出图片，如果没有，开启一个线程进行异步加载，完成后刷新主线程UI并将图片文件规范命名后进行缓存： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//进行存取缓存的操作//取出watchOS的缓存目录let imagedic:NSDictionary = WKInterfaceDevice().cachedImages as NSDictionary //取图片存储的名称 let imageUrl:NSMutableString=NSMutableString() //这里的url是外界传进来的图片地址url，进行去掉特殊字符 for var i=0 ; i&lt;url?.length ; i++ &#123; if (url?.characterAtIndex(i)&gt;=48&amp;&amp;url?.characterAtIndex(i)&lt;=57)||(url?.characterAtIndex(i)&gt;=65&amp;&amp;url?.characterAtIndex(i)&lt;=90)||(url?.characterAtIndex(i)&gt;=97&amp;&amp;url?.characterAtIndex(i)&lt;=122)&#123; imageUrl.appendFormat(&quot;%c&quot;,(url?.characterAtIndex(i))!) &#125; &#125; //查找缓存中是否有图片 //遍历watchOS的缓存目录 for var i=0 ; i&lt;imagedic.allKeys.count ; i++ &#123; //通过规定好的？进行分割 let str:NSArray = imagedic.allKeys[i].componentsSeparatedByString(&quot;?&quot;) if str[0].isEqualToString(imageUrl as String) &#123; //找到图片 view是要设置的interfaceImage view.setImageNamed(imagedic.allKeys[i] as? String) return; &#125; &#125; //设置缺省图片 这里是外界传进来的缺省图片，如果需要下载，先设置缺省图片 if defaultImage != nil &#123; view.setImageNamed(defaultImage as? String) &#125; //进行下载和存储 let dispath = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) //在新的线程中下载 dispatch_async(dispath, &#123; () -&gt; Void in let imgURL:NSURL = NSURL(string: url as! String)! let imageData:NSData? = NSData(contentsOfURL: imgURL) if imageData != nil &#123; //主线程中刷新 dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in view.setImageData(imageData!) &#125;) //写缓存 如果缓存满了 就删掉时间戳最早的一张缓存 //这个方法会返回bool值，判断是否存入成功 while !WKInterfaceDevice().addCachedImageWithData(imageData!, name: checkString(url!) as String) &#123; //如果存入失败，删去时间戳最早的缓存 var temp:NSString? //保存最早的缓存名称 var result:NSString? for var i=0 ; i&lt;imagedic.allKeys.count ; i++ &#123; let str:NSArray = imagedic.allKeys[i].componentsSeparatedByString(&quot;?&quot;) if temp == nil &#123; temp = str[1] as? NSString result = imagedic.allKeys[i] as! String break &#125; if str[1].doubleValue &lt; temp?.doubleValue &#123; //找到更早的缓存 temp = str[1] as? NSString result = imagedic.allKeys[i] as! String &#125; &#125; //删掉缓存 WKInterfaceDevice().removeCachedImageWithName(result as! String) &#125; &#125; &#125;) 上面的代码和注释，已经介绍了所有的思路，有错误之处或者更好的方式，还望多多指点。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门七——watchOS中通知的应用","slug":"131AppleWatch开发入门七——watchOS中通知的应用","date":"2015-10-18T16:00:00.000Z","updated":"2021-07-03T12:30:06.427Z","comments":true,"path":"2015/10/19/131AppleWatch开发入门七——watchOS中通知的应用/","link":"","permalink":"http://huishao.cc/2015/10/19/131AppleWatch开发入门七——watchOS中通知的应用/","excerpt":"","text":"AppleWatch开发入门七——watchOS中通知的应用一、引言在iOS系统中，支持的通知有两种类型：本地通知和远程通知。本地通知多用于计时类通知，远程的又称推送，多用于一些提示动态的提示信息。这里有相关通知的一些知识总结： 本地推送：http://my.oschina.net/u/2340880/blog/405491。 远程推送：http://my.oschina.net/u/2340880/blog/413584。 在watch中，通知是和iphone同步的，在iphone上的App收到通知的同时，会默认也推送到watch上，基于watch的穿戴性，对用户来说，它上面的通知信息将比iphone更加及时。 二、WatchOS通知概览首先，watch上的通知分为两部分：short-look和long-lock。简而言之，short-look，可以理解为一个简单的通知预览，它会将通知发起的APP和主要标题等信息展示给你，让你一目了然，当用户抬起手腕，查看这个通知一定时间，这个短通知就会转换为long-look通知。short-look的通知界面我们不能够自定义，系统为我们设计好了模样，如下： 长通知的界面我们是可以进行一定程度上的自定义的，并且可以添加按钮等逻辑操作。 long-look也分为两种界面，静态界面和动态界面。这个也好理解，静态界面是我们在写程序时就定义好的界面，在通知发送到watch上时，界面会自动匹配通知内容进行显示。动态的界面则是当收到通知时，会先执行我们相应的配置代码，之后在进行通知界面的展示。一个long-look界面大致如下： 在long-lock中，界面定义为三个部分，头部标题栏，自定义视图栏和按钮交互区。头部的标题栏我们不能自定义，它是一个半透明的上面有App图标和名字的横栏。其下面是我们可以自定义的区域，我们可以在storyBoard中拉入文本和图片。最下面是一些交互按钮，其名称等配置信息在推送的文件中定义。 三、如何在模拟器上模拟远程推送在watchOS模拟器上，Xcode为我们准备好了一种可以模拟测试推送的方式。如果我们创建项目时，选择了NotifacationScene,则Xcode会默认为我们创建一个apns文件： 这个文件就是模拟推送的相关配置文件，如果没有，我们也可以手动来创建： 文件中的内容格式如下： 12345678910111213141516171819&#123; &quot;aps&quot;: &#123; &quot;alert&quot;: &#123; &quot;body&quot;: &quot;通知&quot;, &quot;title&quot;: &quot;通知来了&quot; &#125;, &quot;category&quot;: &quot;myCategory&quot; &#125;, &quot;WatchKit Simulator Actions&quot;: [ &#123; &quot;title&quot;: &quot;First Button&quot;, &quot;identifier&quot;: &quot;firstButtonAction&quot; &#125; ], &quot;customKey&quot;: &quot;Use this file to define a testing payload for your notifications. The aps dictionary specifies the category, alert text and title. The WatchKit Simulator Actions array can provide info for one or more action buttons in addition to the standard Dismiss button. Any other top level keys are custom payload. If you have multiple such JSON files in your project, you&apos;ll be able to select them when choosing to debug the notification interface of your Watch App.&quot;&#125; 这是一些json格式的数据，其中alert是对推送内容的设置，body会显示在long-look的标题栏，title会显示在short-look的标题栏，Actions数组中是对按钮就行配置，每一个按钮可以设置一个标题和id，标题用于在推送界面显示，id用于处理点击按钮后触发的逻辑。 创建好这个，我们可以来试着测试一下推送的界面，选择推送工程，运行即可： 四、long-look的静态界面和动态界面上面提到过，long-look分为静态界面和动态界面两种，当我们在storyBoard中拉入一个Notification Interface Controller的时候，可以选择同时创建动态界面，勾选 Has Dynamic Interface： 这时，在storyBoard中是如下模样： 我们在创建一个文件，继承于WKUserNotificationInterfaceController，并将storyBoard中动态的的推送controller的class设置为我们创建的类： 注意，这里设置的是动态的Interface，也就是上面右边的controller。之后运行，你会发现效果并没有什么改变，那是因为系统默认会从静态界面加载推送界面，我们需要在NotifacationController代码中做一些操作： 1234567891011121314151617//在NotificationController中重写下面两个方法//这个用于本地推送override func didReceiveLocalNotification(localNotification: UILocalNotification, withCompletion completionHandler: ((WKUserNotificationInterfaceType) -&gt; Void)) &#123; //在这里做一些动态界面的加载操作，比如可以根据推送的数据 设置图片 文字等 //下面这个方法决定是加载静态的界面还是动态的界面 //Custom是加载动态界面 //default是加载静态界面 completionHandler(.Custom) &#125; //设个用于远程推送 和上面方法类似override func didReceiveRemoteNotification(remoteNotification: [NSObject : AnyObject], withCompletion completionHandler: ((WKUserNotificationInterfaceType) -&gt; Void)) &#123; completionHandler(.Custom) &#125; 五、触发推送点击事件首先，我们多配置几个点击按钮，在apns文件中如下配置： 1234567891011121314151617&quot;WatchKit Simulator Actions&quot;: [ &#123; &quot;title&quot;: &quot;第一&quot;, &quot;identifier&quot;: &quot;one&quot; &#125;, &#123; &quot;title&quot;: &quot;第二&quot;, &quot;identifier&quot;: &quot;two&quot; &#125;, &#123; &quot;title&quot;: &quot;第三&quot;, &quot;identifier&quot;: &quot;three&quot; &#125; ], 在我们watch App的InterfaceController中实现如下的方法： 12345678910//重写下面两个方法来响应点击事件//远程推送的方法override func handleActionWithIdentifier(identifier: String?, forRemoteNotification remoteNotification: [NSObject : AnyObject]) &#123; //通过我们配置的按钮id来区分点击的按钮 处理响应的逻辑 print(identifier) &#125;//本地推送的方法override func handleActionWithIdentifier(identifier: String?, forLocalNotification localNotification: UILocalNotification) &#123; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门九——Watch帧动画的实现","slug":"133AppleWatch开发入门九——Watch帧动画的实现","date":"2015-10-18T16:00:00.000Z","updated":"2021-07-03T12:31:44.420Z","comments":true,"path":"2015/10/19/133AppleWatch开发入门九——Watch帧动画的实现/","link":"","permalink":"http://huishao.cc/2015/10/19/133AppleWatch开发入门九——Watch帧动画的实现/","excerpt":"","text":"AppleWatch开发入门九——Watch帧动画的实现动画一直是iOS系统的一大亮点，CoreAnimation和粒子效果的支持，开发者可以很容易的做出效果炫酷的动画特效。在watchOS中，由于性能和屏幕尺寸的限制，对于动画，并没有强大的框架支持，但是这并不是说开发者就没办法在watch上添加动画的特效了。在watchOS中唯一可以让开发者用于动画操作的就是帧动画。 和iOS类似，watchOS中的真动画也是通过UIImage对象的合集来展示的。只是设置和用法略有不同。 首先，watchOS中帧动画的操作被单独封装成了一个协议，当然，WKInterfaceImage类是遵守了这个协议的： 12345678public protocol WKImageAnimatable : NSObjectProtocol &#123; //从默认帧开始播放动画 public func startAnimating() //播放一个指定范围的帧动画 NSRange是帧的范围，durtion是播放一遍的时间，repeatCount是重复播放次数，0为无限循环 public func startAnimatingWithImagesInRange(imageRange: NSRange, duration: NSTimeInterval, repeatCount: Int) //停止播放动画 public func stopAnimating()&#125; 创建帧动画的步骤与一些注意： 1、关联一个视图中的WKInterfaceImage对象 2、所有帧动画的图片帧必须有统一的格式：比如image1.png，image2.png等等 3、给WKInterfaceImage对象设置帧前缀： 1imageInterface.setImageNamed(&quot;image&quot;) 注意：这里使用的方法和设置图片的方法一样，但是参数有别，图片的设置需要完整的图片名，动画帧前缀的设置只要设置帧图片的前缀。 4、开始动画： 1 imageInterface.startAnimatingWithImagesInRange(NSRange(location: 1, length: 3), duration: 3, repeatCount: 0) 注意：素材帧必须放入watchKit App这个Target中，才可以使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门八——Watch中图片缓存的处理","slug":"132AppleWatch开发入门八——Watch中图片缓存的处理","date":"2015-10-18T16:00:00.000Z","updated":"2021-07-03T12:30:58.537Z","comments":true,"path":"2015/10/19/132AppleWatch开发入门八——Watch中图片缓存的处理/","link":"","permalink":"http://huishao.cc/2015/10/19/132AppleWatch开发入门八——Watch中图片缓存的处理/","excerpt":"","text":"AppleWatch开发入门八——Watch中图片缓存的处理由于iWatch在存储和性能上都和iPhone有着很大的差距，这就要求开发者对程序有更高的性能优化，下载与传输图像，在Watch操作中是一个非时的过程，因此，watchOS中为我们提供了一个缓存图片的框架，并且接口和使用都非常简单。 WatchOS中缓存图片的方法封装在WKInterfaceDevice这个类中，其中添加图片进入缓存的方法如下： 12345//添加一个UIImage对象进入缓存目录，设置name，当我们设置图片时，可以直接通过name进行设置public func addCachedImage(image: UIImage, name: String) -&gt; Bool//添加一个Data图片进入缓存目录，设置name，当我们设置图片时，可以直接通过name进行设置public func addCachedImageWithData(imageData: NSData, name: String) -&gt; Bool//上面两个方法的返回值用于判断缓存是否成功，因为watch缓存目录的大小有限，可能会失败 同样，我们也可以将已经缓存的图片数据删除掉： 1234 //根据name删除一个图片数据 public func removeCachedImageWithName(name: String) //删除缓存目录中所有的图片数据 public func removeAllCachedImages() 我们也可以通过下面的方法获取所有缓存图片的name值： 12//下面这个函数返回一个字典，string为缓存图片的name值，NSNumber为相应的图片大小，单位为bpublic var cachedImages: [String : NSNumber] &#123; get &#125; 注意：系统缓存目录的大小为20M，如果缓存失败，可以尝试删掉旧的缓存。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"iOS8统一的系统提示控件——UIAlertController","slug":"130iOS8统一的系统提示控件——UIAlertController","date":"2015-10-16T16:00:00.000Z","updated":"2021-07-03T12:29:15.019Z","comments":true,"path":"2015/10/17/130iOS8统一的系统提示控件——UIAlertController/","link":"","permalink":"http://huishao.cc/2015/10/17/130iOS8统一的系统提示控件——UIAlertController/","excerpt":"","text":"iOS8统一的系统提示控件——UIAlertController一、引言相信在iOS开发中，大家对UIAlertView和UIActionSheet一定不陌生，这两个控件在UI设计中发挥了很大的作用。然而如果你用过，你会发现这两个控件的设计思路有些繁琐，通过创建设置代理来进行界面的交互，将代码逻辑分割了，并且很容易形成冗余代码。在iOS8之后，系统吸引了UIAlertController这个类，整理了UIAlertView和UIActionSheet这两个控件，在iOS中，如果你扔使用UIAlertView和UIActionSheet，系统只是会提示你使用新的方法，iOS9中，这两个类被完全弃用，但这并不说明旧的代码将不能使用，旧的代码依然可以工作很好，但是会存在隐患，UIAlertController，不仅系统推荐，使用更加方便，结构也更加合理，作为开发者，使用新的警示控件，我们何乐而不为呢。这里有旧的代码的使用方法： UIAlertView使用：http://my.oschina.net/u/2340880/blog/408873。 UIActionSheet使用：http://my.oschina.net/u/2340880/blog/409907。 二、UIAlertController的使用从这个类的名字我们就可以看出，对于警示控件，设计的思路不再是View而是Controller。通过present和push进行呼出，而不是以前的show方法。另一个机制改变的地方是，其中按钮的触发方法不再通过代理处理，而是将按钮封装成了类:UIAlertAction。详细方法及使用如下： 12345 UIAlertController * con = [UIAlertController alertControllerWithTitle:@&quot;新的&quot; message:@&quot;看看样子&quot; preferredStyle:UIAlertControllerStyleAlert]; [con addAction:[UIAlertAction actionWithTitle:@&quot;仔细看&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; //按钮触发的方法 &#125;]]; [self presentViewController:con animated:YES completion:nil]; 上面的代码，会在屏幕上呼出警告框，如下： 初始化方法中的preferref参数是一个枚举，决定是提示框或者抽屉列表： 1234typedef NS_ENUM(NSInteger, UIAlertControllerStyle) &#123; UIAlertControllerStyleActionSheet = 0,//抽屉 UIAlertControllerStyleAlert//警告框&#125; 上面的addAction方法添加了一个封装了方法的按钮，UIAlertAction类的构造十分简单，如下： 12345678//初始化方法+ (instancetype)actionWithTitle:(nullable NSString *)title style:(UIAlertActionStyle)style handler:(void (^ __nullable)(UIAlertAction *action))handler;//获取标题@property (nullable, nonatomic, readonly) NSString *title;//获取风格@property (nonatomic, readonly) UIAlertActionStyle style;//设置是否有效@property (nonatomic, getter=isEnabled) BOOL enabled; AlertAction的风格是如下的枚举： 12345typedef NS_ENUM(NSInteger, UIAlertActionStyle) &#123; UIAlertActionStyleDefault = 0,//默认的风格 UIAlertActionStyleCancel,//取消按钮的风格 UIAlertActionStyleDestructive//警告的风格&#125; 风格效果如下： 三、UIAlertController其他属性和方法@property (nonatomic, readonly) NSArray *actions; 获取所有AlertAction @property (nonatomic, strong, nullable) UIAlertAction *preferredAction NS_AVAILABLE_IOS(9_0); iOS9后新增加的属性，可以使某个按钮更加突出，只能设置已经在actions数组中的AkertAction，会使设置的按钮更加显眼，如下： - (void)addTextFieldWithConfigurationHandler:(void (^ __nullable)(UITextField *textField))configurationHandler; 添加一个textField，以前的相关控件，虽然也可以添加textField，但是定制化能力非常差，这个新的方法中有一个configurationHandler代码块，可以将textField的相关设置代码放入这个代码块中，并且这个方法添加的textField个数不再限制于2个： 123456789 [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第1个&quot;; &#125;]; [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第2个&quot;; &#125;]; [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第3个&quot;; &#125;]; @property (nullable, nonatomic, readonly) NSArray *textFields; 获取所有textField的数组 @property (nullable, nonatomic, copy) NSString *title; 设置警示控件的标题 @property (nullable, nonatomic, copy) NSString *message; 设置警示控件的信息 @property (nonatomic, readonly) UIAlertControllerStyle preferredStyle; 获取警示控件的风格 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"AppleWatch开发入门六——Glance(预览)扩展的应用","slug":"129AppleWatch开发入门六——Glance(预览)扩展的应用","date":"2015-10-15T16:00:00.000Z","updated":"2021-07-03T12:28:10.990Z","comments":true,"path":"2015/10/16/129AppleWatch开发入门六——Glance(预览)扩展的应用/","link":"","permalink":"http://huishao.cc/2015/10/16/129AppleWatch开发入门六——Glance(预览)扩展的应用/","excerpt":"","text":"AppleWatch开发入门六——Glance(预览)扩展的应用一、简介Glance是watchOS中类似iOS的today插件一样的预览扩展。提供了Glance功能的WatchApp可以在手表主页上唤起Glance，展示app相关信息，然而这个扩展只能作为展示作用，并不能进行太多的交互，界面的布局也有很大的限制，因此，Glance的应用主要在于展示备忘信息等。特点如下： 1、扩展的样式布局我们并不能完全个性化，只能通过系统模板来布局。 2、扩展中不能添加交互功能，只能展示信息，点击界面间唤起WatchApp。 3、一个app只能享有一个Glance界面，并且是单屏的不可滑动。 二、创建一个Glance在我们创建WatchApp的时候，可以勾选创建Glance： 同样，如果这里没有勾选，我们也可以在storyBoard中拉入一个Glance界面： 可以发现，这里面的布局样式，我们不能做修改，只能使用系统提供的一些模板： 我们创建一个模板，可以将其中元素与文件关联，进行代码的动态设置。 在Xcode7中，在Scream中选择Glance项目，进行运行： 模拟器效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门四——Table视图的应用","slug":"127AppleWatch开发入门四——Table视图的应用","date":"2015-10-14T16:00:00.000Z","updated":"2021-07-03T12:25:54.796Z","comments":true,"path":"2015/10/15/127AppleWatch开发入门四——Table视图的应用/","link":"","permalink":"http://huishao.cc/2015/10/15/127AppleWatch开发入门四——Table视图的应用/","excerpt":"","text":"AppleWatch开发入门四——Table视图的应用一、Watch上的TableWatchOS中的TableView和iOS中的TableView还是有很大的区别，在开发之前，首先我们应该明白WatchOS中的Table有哪些局限性和特点。下面几点是我总结WatchOS中Table的特殊之处： 1、Table只有行的概念，没有分区的概念，没有头尾视图的概念。 2、可以通过创建多个Table，来实现分区的效果。 3、因为Watch上是通过Gruop进行布局适应的，所以没有行高等设置。 4、Table没有代理，所有行的数据都是采用静态配置的方式，后面会介绍。 5、点击Table中的行触发的方法，是通过重写Interface中的方法来实现的。 二、创建一个Table在storyBoard中拖入你的Table，如下： 在Table上拉两个label： 每一个Table中包含一个TableRowController，实际上我们Table上的控件都是通过这个TableRowController进行管理的，因此如果我们需要在代码中控制TableRow上的内容，我们需要创建一个文件作为Table的TableRowController： 将storyBoard中TableRowController的类修改为我们创建的类并指定一个identifier： 然后，我们将两个label关联到TableRowController中： 123456import WatchKitclass TableRowController: NSObject &#123; @IBOutlet var numberLabel: WKInterfaceLabel! @IBOutlet var titleLabel: WKInterfaceLabel!&#125; 将Table关联到interfaceController中： 12345class InterfaceControllerMain: WKInterfaceController &#123; @IBOutlet var Table: WKInterfaceTable!&#125; 下面，我们开始在interface中对Table做相关配置，首先我们可以先观察一下WKInterfaceTable中有哪些方法和属性： 1234567891011121314151617181920public class WKInterfaceTable : WKInterfaceObject &#123; //设置行的类型，数组中对应存放行的类型，数组元素的个数，就是行数 /* 通过这个方法，我们可以创建每一行样式都不同的table，行的类型 实际上就是我们刚才用到的TableRowController，我们可以进行自定义 */ public func setRowTypes(rowTypes: [String]) //设置行数和类型 用于创建单一行类型的table public func setNumberOfRows(numberOfRows: Int, withRowType rowType: String) // repeating row name //这个get方法获取行数，用于我们遍历table中的行，进行内容设置 public var numberOfRows: Int &#123; get &#125; //这个方法会返回某一行，我们可以获取到后进行内容设置 public func rowControllerAtIndex(index: Int) -&gt; AnyObject? //插入一行 public func insertRowsAtIndexes(rows: NSIndexSet, withRowType rowType: String) //删除一行 public func removeRowsAtIndexes(rows: NSIndexSet) //滑动到某一行 public func scrollToRowAtIndex(index: Int)&#125; 了解了上面的方法，可以看出，WatchOS的Table配置非常简单易用，例如我们如下配置： 1234567891011121314151617@IBOutlet var Table: WKInterfaceTable! override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) let dic:Dictionary&lt;String,String&gt; = [&quot;中国建设银行&quot;:&quot;￥1000&quot;,&quot;中国农业银行&quot;:&quot;￥5000&quot;,&quot;中国银行&quot;:&quot;20000&quot;,&quot;招商银行&quot;:&quot;￥401&quot;,&quot;中国邮政储蓄&quot;:&quot;1100&quot;] //设置行数与类型 Table.setNumberOfRows(dic.count, withRowType: &quot;TableRowController&quot;) //遍历进行设置 let titleArray:Array&lt;String&gt; = Array(dic.keys) for var i=0 ; i &lt; dic.count ; i++ &#123; let row:TableRowController = Table.rowControllerAtIndex(i) as! TableRowController row.titleLabel.setText(titleArray[i]) row.numberLabel.setText(dic[titleArray[i]]) row.numberLabel.setTextColor(UIColor.grayColor()) &#125; // Configure interface objects here. &#125; 这样一个展示银行卡余额的界面我们就创建完成了，效果如下： 三、关于Table的点击事件上面我们提到，Table没有所谓代理方法，点击row的时候，我们也是通过两种方式进行逻辑跳转的，一种是在storyBoard中，我们通过拉线跳转，这时如需传值，我们需在interface中实现如下方法： 1 public func contextForSegueWithIdentifier(segueIdentifier: String, inTable table: WKInterfaceTable, rowIndex: Int) -&gt; AnyObject? 另一种方式，我们可以重写实现InterfaceController中的如下方法，来处理Table的点击事件： 1public func table(table: WKInterfaceTable, didSelectRowAtIndex rowIndex: Int) 无论哪种方式，我们都可以通过参数table和rowIndex来确认点击的具体是那个table和哪一行，进行传值和处理我们的逻辑。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门五——菜单控件的使用","slug":"128AppleWatch开发入门五——菜单控件的使用","date":"2015-10-14T16:00:00.000Z","updated":"2021-07-03T12:26:47.796Z","comments":true,"path":"2015/10/15/128AppleWatch开发入门五——菜单控件的使用/","link":"","permalink":"http://huishao.cc/2015/10/15/128AppleWatch开发入门五——菜单控件的使用/","excerpt":"","text":"AppleWatch开发入门五——菜单控件的使用一、简介菜单也是WatchOS中一个重要的交互方式，限于Watch的屏幕尺寸，若将所有用户交互控件都紧密的排列进展示的UI中，那样难免会使用户操作困难，也会影响界面布局的简洁美观。因此，WatchOS的菜单机制是一层覆盖在屏幕上的交互界面，有如下的特点： 1、菜单是内置于InterfaceController中的，不需显式处理，只需对齐菜单项进行添加设置。 2、菜单最多可以容乃四个选项按钮。 3、通过重按可以呼出和隐藏菜单。 二、创建菜单的两种方式1、通过storyBoard创建在storyBoard中，我们可以将一个菜单控件拖入到interfaceController中： 在Menu中可以添加一些item，每个item都可以设置图片和文字： 图片的设置分为，自定义和系统两种，我们可以使用自己的图片作为菜单的图片，也可以使用系统为我们提供的一些图片，系统的图片参数是一个枚举，值如下： 12345678910111213141516171819public enum WKMenuItemIcon : Int &#123; case Accept // checkmark case Add // &apos;+&apos; case Block // circle w/ slash case Decline // &apos;x&apos; case Info // &apos;i&apos; case Maybe // &apos;?&apos; case More // &apos;...&apos; case Mute // speaker w/ slash case Pause // pause button case Play // play button case Repeat // looping arrows case Resume // circular arrow case Share // share icon case Shuffle // swapped arrows case Speaker // speaker icon case Trash // trash icon&#125; 这些枚举中提供了一些我们常用的功能图标。 菜单按钮的触发方法，我们可以通过拖拽Action的方式来添加，在Xcode7的模拟器中，我们使用command+shift+2可以切换到重按模式，模拟器效果如下： 2、通过代码来添加菜单选项前面提到过，菜单是内含于InterfaceController中的一个控件，在Interface中我们可以调用一些方法来添加菜单按钮，相关方法如下： 1234567 //添加一个菜单按钮，图片自定义 public func addMenuItemWithImage(image: UIImage, title: String, action: Selector) public func addMenuItemWithImageNamed(imageName: String, title: String, action: Selector) //添加一个系统图片的按钮 public func addMenuItemWithItemIcon(itemIcon: WKMenuItemIcon, title: String, action: Selector) //清除所有按钮 public func clearAllMenuItems() 示例代码如下： 1234567891011121314151617override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) self.addMenuItemWithItemIcon(WKMenuItemIcon.Share, title: &quot;分享&quot;, action:Selector(&quot;share&quot;)) self.addMenuItemWithItemIcon(WKMenuItemIcon.Decline, title: &quot;取消&quot;, action: Selector(&quot;cancle&quot;)) self.addMenuItemWithItemIcon(WKMenuItemIcon.Add, title: &quot;添加&quot;, action:Selector(&quot;add&quot;)) &#125; func share()&#123; print(&quot;分享&quot;) &#125; func add()&#123; print(&quot;add&quot;) &#125; func cancle()&#123; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门二——界面布局","slug":"125AppleWatch开发入门二——界面布局","date":"2015-10-13T16:00:00.000Z","updated":"2021-07-03T12:24:34.928Z","comments":true,"path":"2015/10/14/125AppleWatch开发入门二——界面布局/","link":"","permalink":"http://huishao.cc/2015/10/14/125AppleWatch开发入门二——界面布局/","excerpt":"","text":"AppleWatch开发入门二——界面布局一、简介在iphone开发中，最基本的布局方式是通过frame，将控件的位置和大小固定在屏幕上，后来，由于手机屏幕的尺寸有了略微变化，有了autoresizing的布局框架，我们可以设置子视图随父视图的改变做一些相应的变化，再后来，iphone的尺寸与分辨率也越来越多，适配各个屏幕也成为了iOS开发者遇到的新的问题，幸运的是，autolayout机制的出现，大大减小了开发者在适配方面的成本。以上提到的两种布局方式，在以前博客中有讨论： 使用autoresizing进行动态布局：http://my.oschina.net/u/2340880/blog/423357 使用autolayout进行动态布局：http://my.oschina.net/u/2340880/blog/423500 在watch的布局方式中，我们需要抛弃iphone里的思路，重新接受一套新的布局框架。 首先，watch的屏幕不大，目前只有38mm和42mm两个尺寸，我们不可能在这个有限的空间里做非常复杂的界面效果，因此，在界面开发中，应该遵循便于使用和一目了然的原则。watch上的布局方式采用的是一种平面堆放的方式，不再有frame，也不再有约束，控件的布局方式只是一个挨着一个的平面堆放，也不可重叠。但在watch中，提供了group这样一种布局方式，可以让我们在布局中体现自由与个性的方面。 二、最基础的堆放布局我们在不使用group的时候，watch的布局采用的是最基础的堆放方式，从上到下依次排开，例如，我们添加四个label，效果如下： 通过改变label的添加顺序，可以改变其上下位置： 这种方式的布局高度并没有限制，我们可以一直往下排列，在watch上，会出现滑动的效果： 三、使用Group进行复杂的界面布局通过上面的布局方式，我们只能进行纵向的排列布局，这并不能达到我们的需求，WatchKit中提供那一套布局的模型：Group。 可以这样理解，group就是将屏幕分成了几各分区，我们可以设置各个分区的排列方式，例如水平或者垂直，通过这样的思路，完成复杂的watch界面布局，例如下面的效果： 这样效果的一个界面，就是将在屏幕中添加了三个Group，最上面的Gorup设置为水平排列模式，在其中添加了两个按钮和一个分割线，中间一个Group是垂直排列模式，放入了一个选择器和一个按钮，最下面一个Group也是水平排列模式，放入了一个按钮和一个时间栏。 扩展：所谓GroupGroup在界面布局上，不仅可以起到分区屏幕的作用，其还可以设置一些属性来使布局更加漂亮。在storyBoard右侧的设置菜单中，我们可以对这些属性进行操作： Layout：设置布局模式，分为水平布局和垂直布局两种 insert：可以设置内容区域偏移量，通过这个属性，我们可以使其中填充的控件四周留白 Spacing：其中填充的控件的间距 BackGround：设置Group的背景图案 Mode：设置背景图案的填充方式 Animate：出现时带动画 color：设置Group的背景颜色 Radius：设置Group的圆角度 四、布局中控件的位置和尺寸设置在iphone中，我们使用frame或者约束来控制控件的位置和尺寸，在watch中则简单很多，尺寸和位置都是固定的模式，我们只需要做一些设置即可。 1、控件尺寸的控制对于控件的尺寸，有三种模式，控件的width和Height都是通过这三个模式设置的： Relative to Container：自身的尺寸是按照容器的尺寸比例设置的。例如设置为0.5的话，当前控件的尺寸就是容纳其Group的一半。 Size To Fit Content:自身的尺寸与自身内容相关，例如，label中字数的多少决定了label的尺寸。 Fixed：手动设置一个固定的值。 2、控件位置的控制因为watch的界面十分简洁，对于控件的位置设置，是通过水平和垂直两个维度来设置的，通过设置每个维度的属性来控制其在容纳它的Group中的位置： Horizontal：left（左），center（中心），right（右） Vertical：top（上），center（中心），bottom（下） 一点注意:关于图片素材，你可以发现，在Extension和App文件夹中各有一个Assets.xcasssets组，只有将素材放入APP文件夹下的这个组watch才能使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门三——代码交互与控制器生命周期","slug":"126AppleWatch开发入门三——代码交互与控制器生命周期","date":"2015-10-13T16:00:00.000Z","updated":"2021-07-03T12:25:13.911Z","comments":true,"path":"2015/10/14/126AppleWatch开发入门三——代码交互与控制器生命周期/","link":"","permalink":"http://huishao.cc/2015/10/14/126AppleWatch开发入门三——代码交互与控制器生命周期/","excerpt":"","text":"AppleWatch开发入门三——代码交互与控制器生命周期一、引言在前两篇博客中，讨论了关于watch开发中框架与界面布局相关，然而主要的逻辑，终究还是要通过代码来实现的，在我们创建了项目之后，就会生成InterfaceController这个文件，它就是我们storyBoard中的入口视图控制器。 二、代码交互与控制器声明周期storyBoard中的控件我们可以通过拖拽的方式关联到文件中，Action和Outlet两种关联方式基本可以达到我们修改控件和处理业务逻辑的需求。 WKInterfaceController类似于iOS中的ViewController，是watch中主要用于展示界面的controller，我们的控件也都是基于这个容器中显示。在模板中，系统为我们提供了三个函数，这三个函数体现了watch一个界面的声明周期，如下： 123456789101112131415 //这个函数在初始化界面时会触发，通过context可以实现界面的传值 override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) &#125; //这个函数在界面即将展现时触发 类似于iOS中的ViewWillApear override func willActivate() &#123; // This method is called when watch view controller is about to be visible to user super.willActivate() &#125; //这个函数在界面消失后触发，类似于iOS中的ViewDidDisAppear override func didDeactivate() &#123; // This method is called when watch view controller is no longer visible super.didDeactivate() &#125; 三、watch中的界面跳转与传值与iOS类似，watchOS的界面跳转也有两种方式：model和push。同样，我们也可以通过storyBoard或者代码来进行跳转。 1、通过代码跳转与传值我们创建两个InterfaceController，界面如下： 通过代码跳转，我们需要给第二个controller设置一个id标识符： 在按钮触发的方法中，如下跳转： 12345 @IBAction func `switch`(value: Bool) &#123; //这里的context是传值的上下文 //在awakeWithContext方法中会将这个值取到 pushControllerWithName(&quot;InterfaceControllerTwo&quot;, context: &quot;我是传的值&quot;) &#125; 2、在storyBoard中设置跳转关系我们也可以直接在storyBoard中设置界面的跳转，按住control，拖拽按钮到要跳转的controller，会出现push和model菜单，选择后，当我们触发按钮方法时，就会跳转： 通过这种方式进行的跳转，在执行跳转之前，会执行如下这个函数： 123override func contextForSegueWithIdentifier(segueIdentifier: String) -&gt; AnyObject? &#123; return &quot;我是值&quot; &#125; 这个设置的返回值就是context上下文传递的值。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门一——Watch的开发思路与应用框架","slug":"124AppleWatch开发入门一——Watch的开发思路与应用框架","date":"2015-10-12T16:00:00.000Z","updated":"2021-07-03T12:23:42.516Z","comments":true,"path":"2015/10/13/124AppleWatch开发入门一——Watch的开发思路与应用框架/","link":"","permalink":"http://huishao.cc/2015/10/13/124AppleWatch开发入门一——Watch的开发思路与应用框架/","excerpt":"","text":"AppleWatch开发入门一——Watch的开发思路与应用框架一、引言Apple Watch无疑是apple在智能手表领域的一次革命，如何在Watch上开发出实用且具有美感的应用，是iOS开发者们开始思考的一个问题，由于watch的随身性和快捷性，在某些方面，它有比iphone更加大的优势，要抓住watch的这些特点，开发出淋漓尽致的应用，就需要改变一些在iphone开发的思路，正如一句话：只有忘掉经验，才会有意想不到的突破。 这一系列博客，首先是总结我在公司watch项目开发中的一些经验，其次，还会加入一些我的理解和想法，如有错误，欢迎指正，如果对你有帮助，也欢迎撒花，😄。 二、开发前我们需要准备什么如果你没有开发过iphone，直接来做watch，我建议你不要这么做，不是不可以，而是目前所有的第三方应用都必须基于iphone的扩展，原生的watch应用，苹果目前还没有开放给开发者，因此实际上，我们在watch上可以做的事情十分有限，或许后续apple会开放更多接口，但是目前，我们必须放弃iphone开发的思路，从新开始。 1、watch应用的架构如上所说，完全脱离iphone的原生watch应用，我们目前还不能开发，所有第三方的watch应用必须基于一个iphone的host app。我们可以通过创建一个watch应用来观察一下，首先，在Xcode6.3后虽然支持watch的开发，但watch模拟器并不十分好用，Xcode7进行了优化，通过模拟器，基本可以完成我们的开发。用Xcode新建一个项目，之后我们在Xcode菜单中创建一个target： 选择apple Watch中的项目： 在如下的设置中，我们先将include Notification和Include Glance都勾选上，他们也是watch应用的一种表现方式，后面我们再说： 之后可以看到，我们的项目中会多了这样的几个文件夹： 我们只需要关注下结尾为Extension和App的这两个，从目录结构我们也可以看到，App文件夹中有Storyboard这个文件，Extension文件夹中主要是一些代码文件，这也正是我们需要了解的watch app的机制，实际运行与我们手表上的是App文件夹中的界面，而逻辑的代码实际上是运行在我们的手机中的，作为iphone App的扩展而存在，通过手机与手表的交互，来达到watch上的一些操作。 由此，我们可以理解，目前的第三方watch应用，watch类似于一个UI容器，通过与iphone的交互来达到一些逻辑和效果。 2、三种watch应用方式的用途在我们创建watch的扩展时，我们勾选了两个Scene，从字面我们也可以理解的差不多，这里加上我的理解，不是官方的解释： watch app：watch应用的主体，可以通过watch上的图标进入，可以与iphone进行交互与数据共享。 Notification：watch通知，会和iphone通知同步，包括本地的和远程的，这里和iphone不同在于有长通知和短通知的分别，在实际开发中，我们可以通过在后台添加参数来区分。在storyboard中的界面如下： Glance：预览界面，没有复杂的交互能力，也不能滑动，只能在单屏展示一些数据，点击后会进入主体watchApp中： 3、在模拟器上运行一个watch app选中我们的watch App工程，在Xcode7中运行如下： 如果你是以前版本的Xcode，可能需要在模拟器的Hardware中将其调出。 运行后，我们可以在watch模拟器上使用command+H来回到watch的主界面。 三、几点watch app的开发思路1、优秀的watch app无疑必须是简单，朴素，快捷而时效的。 2、watch上不能自定义手势，我们可以使用的只有滑动，点击和长按 3、必须改变iphone布局的思想，完全接受新的watch布局特点，进行创新 4、iphone的特点是界面的绚丽，watch则是简约 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"iOS在应用中添加自定义字体","slug":"123iOS在应用中添加自定义字体","date":"2015-10-09T16:00:00.000Z","updated":"2021-07-03T12:22:07.449Z","comments":true,"path":"2015/10/10/123iOS在应用中添加自定义字体/","link":"","permalink":"http://huishao.cc/2015/10/10/123iOS在应用中添加自定义字体/","excerpt":"","text":"iOS在应用中添加自定义字体一、在应用中添加自定义字体的步骤1、网上提供的字体库有很多，下载完成后，将其导入工程中，一般为ttf格式。 2、注意Build Phases中的Copy Bundle Resources中是否导入了文件： 3、在项目的info.plist文件中添加字体键值如下： 这个数组中可以添加多个元素，多个字体库。 4、这时实际上我们已经将字体添加进了工程中，但是在在使用这个字体时，字体的名字有时和文件名是不一样的，我们需要知道真实的字体名称，通常情况下，我们会讲所有字体名称打印出来： 12345 for (NSString * name in [UIFont familyNames]) &#123; for (NSString * fo in [UIFont fontNamesForFamilyName:name]) &#123; NSLog(@&quot;%@&quot;,fo); &#125; &#125; 5、找到我们需要的字体，如下使用即可： 1 UIFont * font = [UIFont fontWithName:@&quot;yuweij&quot; size:14]; 二、如何快速的找到新添加的字体名字如果你将所有字体都打印了出来，在其中找到新的字体名称是身份困难的，尤其是当这个字体的名称和文件名相差甚远的时候，这是一件非常痛苦的事情。 为了在以后使用自定义字体的时候不必一次一次的经历这样的痛苦，在Xcode6.3的环境下，我将所有的系统字体获取后写入了plist文件，将这个plist文件导入项目中，通过如下方法，可以只打印出新增加的字体： 12345678910111213141516171819 NSString *paths=[[NSBundle mainBundle]pathForResource:@&quot;font&quot; ofType:@&quot;plist&quot;]; //得到完整的文件名 NSDictionary * rootDic = [NSDictionary dictionaryWithContentsOfFile:paths]; //遍历当前所有字体 for (NSString * name in [UIFont familyNames]) &#123; NSArray * fontArray = [rootDic objectForKey:name]; BOOL tip = NO; for (NSString * fo in [UIFont fontNamesForFamilyName:name]) &#123; for (NSString * tmp in fontArray) &#123; if ([tmp isEqualToString:fo]) &#123; tip=YES; break; &#125; &#125; if (!tip) &#123; NSLog(@&quot;%@&quot;,fo); &#125; &#125; &#125; 如果你也需要，字体集plist文件的地址：https://github.com/ZYHshao/YHBaseFoundationTest/tree/master/YHBase/BaseSouce。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective—C语言的新魅力——Nullability、泛型集合与类型延拓","slug":"122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓","date":"2015-10-08T16:00:00.000Z","updated":"2021-07-03T12:21:11.317Z","comments":true,"path":"2015/10/09/122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓/","link":"","permalink":"http://huishao.cc/2015/10/09/122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓/","excerpt":"","text":"Objective—C语言的新魅力一、引言在Xcode7中，iOS9的SDK已经全面兼容了Objective-C的一些新特性和新功能。这些功能都只作用于编译期，对程序的运行并没有影响，因此，它可以很好的向下进行兼容，无缝的衔接低版本的iOS系统，那么这些特性有什么样的用处呢，作为开发者，我保证你一定会爱上他们，如果你可以将这些新特性都应用于你的开发，你的开发效率和代码质量，相比之前，会有一个很大的提升。 二、Nullability检测的支持在swift语言中，通过!和?可以将对象声明成Optional，用于在开发中标记这个对象是否可以为空。在OC中，以前是没有这样的功能的，因此我们在开发中会经常遇到因为某个函数应该返回实例而返回了空导致的崩溃。Nullability的主要用武之地，就是在这里，它可以起到提示开发者做是否为空得判断的提示。 打开Xcode7，系统的框架中已经支持了Nullability，如下： 12@property (nullable, nonatomic, readonly) ObjectType firstObject;@property (nullable, nonatomic, readonly) ObjectType lastObject; 这是NSArray中的两个属性，其中nullable关键字说明了这里可能返回空的值。 如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的，越是多人合作的项目，作用也越大。 例如： 123-(void)setValue:(NSNumber * _Nonnull )number&#123; &#125; 我们在调用函数时，如果传入了空值，编译器会给我们警告： 注意： 这一特性在Xcode6.3中就已经支持，但在Xcode7中又做了一些写法上的小改动，例如，在Xcode6.3中这样写： 123-(void)setValue:( nonnull NSNumber * )number&#123; &#125; 而在Xcode7中提倡我们使用第一种写法。 与之相关的几个关键字如下： 修饰参数 nonnull：不可为空 nullable: 可以为空 null_unspecified:不确定是否可以为空(极少情况) 在属性的声明中，还会有如下一个修饰符： null_resettable:set方法可以为nil，get方法不可返回nil 一点提示： 你可以发现，iOS9的SDK中已经完全兼容使用了这些特性，并且nonnull的使用会比nullable广泛的多，因此，系统提供了这样一对宏： #define NS_ASSUME_NONNULL_BEGIN _Pragma(“clang assume_nonnull begin”) #define NS_ASSUME_NONNULL_END _Pragma(“clang assume_nonnull end”) 我们在这对宏之间定义的变量都会加上nonnull的修饰符，只有我们特殊声明nullable的才需要手动写。 三、泛型集合的支持这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。还记得，在Xcode7之前，依然是为了方便多人开发，我经常会在框架中写这样的一个空得宏： 在开发时如下使用，做到提示伙伴我这个数组中是什么东西的作用： 12345@interface ViewController ()&#123; NSArray __TYPE__FIT_TO__CLASS(NSString) * array;&#125;@end 当然，所有这些都是我自己的自导自演，编译器并不会鸟我，我在这个数组中加其他的东西，它也不会介意，所有这些只是我和我的伙伴们约定的一种一厢情愿。所以，当我看到Xcode7中的集合类型时，我着实兴奋了一下。 1、有类型约定的集合在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下： 1 NSMutableArray&lt;NSString *&gt; *array = [[NSMutableArray alloc]init]; 声明了这样一个数组后，就好比我告诉了编译器，这个数组中的数据类型都是NSString*类型的，现在非常好，如果我这个数组中元素的方法，会出现如下的提示： 激动吧，使用点语法可以访问到数组中泛型的方法了，还有更加诱人的： 在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来。 同样，如果我们向这个数组中追加类型不匹配的元素，如下： 12 NSMutableArray&lt;NSString *&gt; *array = [[NSMutableArray alloc]init]; [array addObject:@1]; 编译器会给我们一个这样的警告： 2、关于一个类型通配符观察Xcode7中iOS系统的类，我们可以发现这么一个好玩的东西：ObjectType。它既不是一个类型，也不是关键字，然而却大量存在，如下是系统的NSMutableArray的头文件： 12345678910@interface NSMutableArray&lt;ObjectType&gt; : NSArray&lt;ObjectType&gt;- (void)addObject:(ObjectType)anObject;- (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;- (void)removeLastObject;- (void)removeObjectAtIndex:(NSUInteger)index;- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;- (instancetype)init NS_DESIGNATED_INITIALIZER;- (instancetype)initWithCapacity:(NSUInteger)numItems NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;@end 这个ObjectType其实只是一个类型标识符，它具体怎么写并不重要，只是系统中都约定使用了ObjectType，你也可以在自己的类中按自己的喜好来命名，这个东西有怎样的用处，我用文字描述不清楚，我们可以通过自己来定义一个集合类来理解： 创建一个类，继承于NSObject，我取名叫MyArray： 123456//这个类型通配符只能在interfave里使用，作用域为@interface到@end之间//这里我使用Type来做这个通配符@interface MyArray&lt;Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;-(void)addObject:(nonnull Type)obj;@end 实现如下： 123456789101112131415161718- (instancetype)init&#123; self = [super init]; if (self) &#123; _array = [[NSMutableArray alloc]init]; &#125; return self;&#125;-(void)addObject:(id)obj&#123; [_array addObject:obj];&#125;-(NSString *)description&#123; NSMutableString * str = [[NSMutableString alloc]init]; for (int i=0; i&lt;_array.count; i++) &#123; [str appendString:[NSString stringWithFormat:@&quot;%@\\n&quot;,_array[i]]]; &#125; return str;&#125; 我们在使用这个自定义的集合类型时，就会有和系统一样的效果了： 3、关于多参数的泛型集合多参数的泛型集合，有一个非常好的例子，就是NSDictionary，在Xcode7中我们可以这样写字典： 可以看到，字典键值的类型编译器为我们提示了出来，结合上面类型通配符的使用，对于多参的集合，将参数类型用“,”隔开即可。 4、协变性与逆变性因为有了泛型集合的概念，相比之前，我们的类型实际上更加复杂了，比如还拿我们自定义的集合类型来举例： 12 MyArray&lt;NSString *&gt; * array; MyArray&lt;NSMutableString *&gt;*muArray; array和muArray在编译器看来已经是不同的类型，如果我们强行转换，会报如下的警告： 因此，就有了逆变和协变这个概念： __covariant :子类型指针可以向父类型指针转换 __contravariant:父类型指针可以向子类型转换 上面的情况，我们将自定义的类做如下修改，就不会出现警告： 1234@interface MyArray&lt;__covariant Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;-(void)addObject:(nonnull Type)obj;@end 四、类型延拓符的应用在开发中，开发者经常会遇到这样的情况，例如通过tag获取某些UI控件时，viewWithTag方法通常会返回给我们一个UIView类型的指针，这就需要开发者手动的强转一下，十分麻烦。新增加的__kindof修饰符可以帮助我们解除这个烦恼。我们还从自定义的那个数组类开刀，对其添加一个属性： 12345@interface MyArray&lt;__covariant Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;@property(nonnull,strong,nonatomic)NSMutableArray&lt;UIView *&gt; * viewArray;-(void)addObject:(nonnull Type)obj;@end 创建一个自定义的数组对象，并向其中添加一个UIButton，我们会看到有如下一个警告： 这也是我们开发中常遇到的问题，对吧，以前需要强转。但是以后就不需要了，我们在声明这个数组时加上一个__kindof修饰符： 1@property(nonnull,strong,nonatomic)NSMutableArray&lt;__kindof UIView *&gt; * viewArray; 警告就消失了，很cool吧。 这个修饰符就是告诉编译器，这里可以返回UIView的子类指针。 五、结语虽然这些优点在swift中早有体现，但就我个人而言，我对OC的感情会更深一些，也更加愿意接受OC的改变和成长，大家都说swift的趋势势在必行，我只想说，swift很优秀，OC亦然。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS数据持久化之二——归档与设计可存储化的数据模型基类","slug":"121iOS数据持久化之二——归档与设计可存储化的数据模型基类","date":"2015-10-07T16:00:00.000Z","updated":"2021-07-03T12:19:50.756Z","comments":true,"path":"2015/10/08/121iOS数据持久化之二——归档与设计可存储化的数据模型基类/","link":"","permalink":"http://huishao.cc/2015/10/08/121iOS数据持久化之二——归档与设计可存储化的数据模型基类/","excerpt":"","text":"iOS数据持久化之二——归档与设计可存储化的数据模型基类一、引言在上一篇博客中，我们介绍了用plist文件进行数据持久化的方法。虽然简单易用，但随着开发的深入，你会发现，这种方式还是有很大的局限性。试想，如果我们可以将用户的登录返回信息模型，游戏中角色的属性信息模型进行直接的持久化存取，那是不是非常爽的事，幸运的是，我们可以通过归档，来设计一个这样的数据模型。 二、先来精通归档吧归档也是iOS提供给开发者的一种数据存储的方式，事实上，几乎所有的数据类型都可以通过归档来进行存取。其存储与读取的过程，主要封装在两个类中：NSKeyedArchiver和NSKeyedUnarchiver。 1、归档的原理归档是将一种或者多种数据类型进行序列化，解归档的过程就是将序列化的数据进行反序列化的解码，这里需要注意一点，归档的核心并非是数据的持久化处理，而是数据的序列化处理，持久化的处理依然是通过文件存取来实现的。因此，被归档的数据类型都必须遵守一个相同的协议，才能在这个协议的约束下进行正确的归档与解归档，这个协议就是NSCoding协议，我们可以先来看一下NSCoding中的内容： 123456@protocol NSCoding- (void)encodeWithCoder:(NSCoder *)aCoder;- (id)initWithCoder:(NSCoder *)aDecoder;@end 这个协议非常简单，一个init的归档方法，一个encode的解归档方法，NSCoder就是归档对象。原则上说，无论是什么数据类型的对象，系统的或者是我们自定义的，都可以通过实现这个协议中的方法来支持归档操作。 2、几种归档与解归档的应用（1）通过类方法来对rootKey进行归档这种方式，我个人理解，很类似于NSUserDefaults中的standardUserDefaults，只是后者是系统为我们创建的一个默认plist文件，而rootKey是系统为我们创建的一个默认的归档键值。说起来比较复杂，举个例子就十分清晰了： 12345678910111213 NSString *homeDictionary = NSHomeDirectory();//获取根目录 NSString *homePath = [homeDictionary stringByAppendingPathComponent:@&quot;atany.archiver&quot;];//添加储存的文件名 //方式一：通过data数据归档，在将数据写入文件 NSData *data= [NSKeyedArchiver archivedDataWithRootObject:@&quot;123&quot;]; [data writeToFile:homePath atomically:YES]; //方式二：直接写入文件 [NSKeyedArchiver archiveRootObject:@&quot;456&quot; toFile:homePath]; //方式一和方式二的效果完全一样 只是解归档的时候不同 //方式一的解归档:先获取data数据，在进行data数据的解归档 NSLog(@&quot;%@&quot;,[NSKeyedUnarchiver unarchiveObjectWithData:data]); //方式二的解归档：直接解文件中的归档 NSLog(@&quot;%@&quot;,[NSKeyedUnarchiver unarchiveObjectWithFile:homePath]); 上面的示例是对字符串类型进行的归档，是对单一的数据对象进行的归档，当然，这里的对象是支持数组、字典等集合的，但集合其中的对象，也必须全部支持归档操作。 （2）通过构造新的archiver对象，对多个对象进行归档除了上面的类方法，我们还可以自己构造一个归档对象，来对多种不同的对象进行归档： 123456789101112131415161718192021 NSString *homeDictionary = NSHomeDirectory();//获取根目录 NSString *homePath = [homeDictionary stringByAppendingPathComponent:@&quot;atany.archiver&quot;];//添加储存的文件名 //这里创建一个可变的data对象作为归档的容器 NSMutableData * data = [[NSMutableData alloc]init]; //创建一个归档对象，归档后写入data数据 NSKeyedArchiver * archiver = [[NSKeyedArchiver alloc]initForWritingWithMutableData:data]; //对下面的字符串和int值进行归档序列化 [archiver encodeObject:@&quot;jaki&quot; forKey:@&quot;name&quot;]; [archiver encodeInt:24 forKey:@&quot;age&quot;]; //写入data [archiver finishEncoding]; //写入文件 [data writeToFile:homePath atomically:YES]; //创建解归档的反序列化对象 NSKeyedUnarchiver * unarchiver = [[NSKeyedUnarchiver alloc]initForReadingWithData:data]; //进行反序列化 NSString * name = [unarchiver decodeObjectForKey:@&quot;name&quot;]; int age = [unarchiver decodeIntForKey:@&quot;age&quot;]; //打印信息 NSLog(@&quot;\\nname:%@\\nage:%d&quot;,name,age); 结果如下： （3）进行自定义对象的归档上面介绍中有提到，原则上，任何遵守了NSCoding协议的类都可以进行归档操作，那么对于我们自定义的对象，我们该如何来做呢？ 首先，我们新建一个类： 仿照上面的例子，我们写一个这样的类： 1234@interface MyObject : NSObject@property(nonatomic,strong)NSString * name;@property(nonatomic,assign)int age;@end 对其进行归档： 12345678 //进行归档 MyObject * obj = [[MyObject alloc]init]; obj.name = @&quot;jaki&quot;; obj.age = 24; NSData * data = [NSKeyedArchiver archivedDataWithRootObject:obj]; //进行解档 MyObject * obj2 = [NSKeyedUnarchiver unarchiveObjectWithData:data]; NSLog(@&quot;\\nname:%@\\nage:%d&quot;,obj2.name,obj2.age); 直接运行，程序会崩溃掉，打印如下： 可以看出，正是我们前边说过的，必须遵守归档协议的对象，才可以被归档，我们在MyObject类中实现如下两个方法： 12345678910111213141516//解档方法- (instancetype)initWithCoder:(NSCoder *)coder&#123; if (self=[super init]) &#123; _name = [coder decodeObjectForKey:@&quot;name&quot;]; _age = [coder decodeIntForKey:@&quot;age&quot;]; &#125; return self;&#125;//归档方法- (void)encodeWithCoder:(NSCoder *)coder&#123; [coder encodeObject:_name forKey:@&quot;name&quot;]; [coder encodeInt:_age forKey:@&quot;age&quot;];&#125; 添加了上面两个方法，我们自定义的对象就可以自由归档存取，并可以写入本地，非常cool吧。 三、设计可以归档存取的数据模型基类1、动机与初衷通过上面对归档的介绍，我们可以发现归档一个十分有潜力的应用：可以自由存取自定义的数据对象。这个特性的优势是毫无疑问的，除了可以使我们的数据用起来更加方便，无需多次解析数据外，安全性也更好。但是也带来了一个缺陷，每个类都需要实现NSCoding中的两个方法是十分繁琐的，并且类越复杂，这个步骤越繁琐，如果在之后的修改和优化中类做了改变，相应的方法也要做改变，这将增加很大的工作量并且埋下潜在bug的风险。 所以我们会想，能否设计一个这样的model基类，来使需要存储的model都继承于它，使我们的model不需要实现NSCoding方法的同时可以支持归档呢，通过runtime和OC语言特性的一些小技巧，我们是可以做到的。 2、基类模型的设计我们新建一个BaseModel类，核心方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//归档与解归档的方法- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super init]; if (self) &#123; //获取所有属性 NSArray * porpertyArray = [self getAllPropertys]; for (NSString * name in porpertyArray) &#123; //去掉属性名前面的_ NSString * key = [name substringFromIndex:1]; //约定好的键值对 c+key [self setValue:[coder decodeObjectForKey:[NSString stringWithFormat:@&quot;c%@&quot;,key]] forKey:key]; &#125; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder&#123; //获取所有属性 NSArray * porpertyArray = [self getAllPropertys]; for (NSString * name in porpertyArray) &#123; //去掉属性名前面的_ NSString * key = [name substringFromIndex:1]; //约定好的键值对 c+key [coder encodeObject:[self valueForKey:key] forKey:[NSString stringWithFormat:@&quot;c%@&quot;,key]]; &#125;&#125;//获取model所有属性-(NSArray *)getAllPropertys&#123; NSMutableArray * array = [[NSMutableArray alloc]init]; unsigned int * count = malloc(sizeof(unsigned int)); //调用runtime的方法 //Ivar：方法返回的对象内容对象，这里将返回一个Ivar类型的指针 //class_copyIvarList方法可以捕获到类的所有变量，将变量的数量存在一个unsigned int的指针中 Ivar * mem = class_copyIvarList([self class], count); //进行遍历 for (int i=0; i&lt; *count ; i++) &#123; //通过移动指针进行遍历 Ivar var = * (mem+i); //获取变量的名称 const char * name = ivar_getName(var); NSString * str = [NSString stringWithCString:name encoding:NSUTF8StringEncoding]; [array addObject:str]; &#125; //释放内存 free(count); //注意处理野指针 count=nil; return array;&#125; 通过这样的一个runtime机制，我们可以很方便的是新建的model继承于这个基类，无需其他处理直接支持归档，修改与优化都不受影响。 四、为志同道合的朋友分享这个model集成在了我的一个开源的开发框架中，当然，那里面也综合和许多许多这样方便开发者使用的功能，如果你感兴趣，可以在[https://github.com/ZYHshao/YHBaseFoundationTest](https://github.com/ZYHshao/YHBaseFoundationTest)上面看到。如果你发现了一些bug或者可以添加或者优化的地方，请务必告知我，十分你感谢。QQ：316045346 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS数据持久化之一——plist文件","slug":"120iOS数据持久化之一——plist文件","date":"2015-10-07T16:00:00.000Z","updated":"2021-07-02T06:54:46.547Z","comments":true,"path":"2015/10/08/120iOS数据持久化之一——plist文件/","link":"","permalink":"http://huishao.cc/2015/10/08/120iOS数据持久化之一——plist文件/","excerpt":"","text":"iOS数据持久化之一——plist文件iOS开发中，我们时常会将一些简单的数据进行持久化的存储，方便我们保存程序的一些配置和用户的一些数据，plist文件就是我们保存这些数据的最佳选择。 一、何为plistplist是一种文件格式，其内容规则是xml文件，后缀为.plist，因此，我们更习惯于成它问plist文件，在iOS开发中，这种文件常用来保存一些简单的配置数据，例如项目中的info.plist。 通过plist文件编辑器，我们可以很方便的查看和编辑层次清晰的plist文件。 二、通过操作plist文件进行数据持久化的几种方式1、操作系统为我们准备的用户配置文件——NSUserDefaults对于NSUserDefaults，具体用法和一些小技巧在以前的一篇博客中有详细的描述，一般的用户配置信息，我们都会选择通过这种方式来进行持久化，地址如下：[http://my.oschina.net/u/2340880/blog/411344](http://my.oschina.net/u/2340880/blog/411344)。 2、在项目包中手动创建一个plist文件，通过代码对其进行操作这种方式创建的plist文件非常自由且直观，我们可以创建多个根据功能进行分类存储，并且可以通过Xcode的可视化工具进行可视化的修改。 首先，我们新创建一个文件，在Resource中选择 Property List文件： 之后，我们通过Xcode，在其中添加一些数据： 通过代码，我们来获取这些数据： 1234 //获取myInfo文件地址 NSString * path = [[NSBundle mainBundle]pathForResource:@&quot;myInfo&quot; ofType:@&quot;plist&quot;]; NSMutableDictionary * dic =[NSMutableDictionary dictionaryWithContentsOfFile:path]; NSLog(@&quot;%@&quot;,dic); 打印结果如下： 这种方式添加的plist文件，我们只能在xcode中配置好，然后再程序中读取使用，但是不能在程序中修改这些数据，可以应用于一些固定的数据的存储，例如地图shu xing列表等。 3、在沙盒目录中创建和使用plist文件我们还可以通过代码在沙盒中创建我们自己的plist文件，进行数据的存储。同时可以支持add，delete，replace，find等操作。 123456789101112 //获取沙盒目录 NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString *plistPath1 = [paths objectAtIndex:0]; //得到完整的文件名 NSString *filename=[plistPath1 stringByAppendingPathComponent:@&quot;my.plist&quot;]; NSDictionary * dic = @&#123;@&quot;my&quot;:@&quot;haha&quot;&#125;; [dic writeToFile:filename atomically:YES]; //取数据 NSDictionary * getDic = [NSDictionary dictionaryWithContentsOfFile:filename]; NSLog(@&quot;%@&quot;,getDic); 打印如下： 这种方式无疑会更加安全，存取也更加自由。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS9系列专题6——iOS9其他适配注意点","slug":"119iOS9系列专题6——iOS9其他适配注意点","date":"2015-10-06T16:00:00.000Z","updated":"2021-07-02T06:53:41.264Z","comments":true,"path":"2015/10/07/119iOS9系列专题6——iOS9其他适配注意点/","link":"","permalink":"http://huishao.cc/2015/10/07/119iOS9系列专题6——iOS9其他适配注意点/","excerpt":"","text":"iOS9适配注意点一、后台定位类app适配点在iOS8中，APP的定位服务apple就做了一些修改，需要用户申请相应的权限，并在info.plist文件中添加对应的键值。具体的做法在这篇博客中有详细的讲解：[http://my.oschina.net/u/2340880/blog/414760](http://my.oschina.net/u/2340880/blog/414760)。 在iOS9系统中，定位服务的做法基本没有改变，对于前台的定位没有影响，但app中如果需要后台定位，那么还需要多做一些操作，例如： 123456789 manager = [[CLLocationManager alloc]init]; //申请后台定位权限 [manager requestAlwaysAuthorization]; manager.delegate=self; //======================================= //下面这个是iOS9中新增的方法 开启后台定位 manager.allowsBackgroundLocationUpdates = YES; //====================================== [manager startUpdatingLocation]; 通过上面简单的配置直接运行的话，程序会崩溃掉，还需要在plist文件中做一些配置，两种方式： 方式一：直接在plist文件中配置如下： 方式二：在项目中设置 打开background Models选项，勾选其中的Location updates。 二、安装不受信任的开发者应用我们知道，在Xcode7后，开发者可以不用花99dollars去购买开发者账号而可以在自己的iphone上进行测试。在安装这些应用时，iOS9系统不再向以前那样，再安装时提示一个信任的按钮，而是做如下的提示： 在设置中，选择描述文件： 之后选择开发者对应的appleId，选择信任即可： 三、BitCode的配置BitCode是app的一种中间形式，在iOS9系列专题的前几篇，有对其的简单介绍，举个例子，我们可以在提交app时提交app的bitcode形式，如此一来，apple会对我们的app进行二次优化，在用户下载时根据所需再进行编译打包。在Xocde7中，新建的项目是默认开启BitCode的，如果我们用Xcode7编译提交应用，这里有需要注意适配的地方。 如果要支持BitCode，需要保证所有的SDK都支持BitCode，如果要更新旧的SDK，只需要在Xcode7上开启BitCode重新制作一遍即可。 如果不能使所有SDK都支持BitCode，可以在项目中关闭BitCode，在building Setting中搜索BitCode，将enable设置为NO，如下： 四、URL Scheme白名单在iOS9中，apple引入了白名单这个概念，其好处是对app应用内安全进行了加强。在iOS9的适配中，如果我们用到canOpenURL这样的方法，则需要配置白名单。 首先，我们创建一个测试工程，什么都不用做，只需要添加一个URL Scheme： 在另一个工程中，我们写如下代码： 123 BOOL can= [[UIApplication sharedApplication]canOpenURL:[NSURL URLWithString:@&quot;TEST://&quot;]]; NSLog(@&quot;%d&quot;,can); [[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;TEST://&quot;]]; 在没有配置白名单之前，打印如下： 可以看到，bool值返回的是NO。虽然这样也可以跳转相应的APP，但是canOpenURL这个方法相当于失效了，我们不能用它来判断用户到底装没装这个app。 适配时，我们在plist文件中添加如下键值： 这时再次运行程序，canOpenURL的判断就会准确了。 注意：白名单添加上限为50个。 五、label默认字体不同产生的BUGiOS9的另一变化是label的默认字体产生了变化，我们打印iOS9中label的字体如下： iOS8中的label默认字体如下： 这两种字体的最大差异是字间距不同，例如如下一段代码： 12345 UILabel * label = [[UILabel alloc]init]; label.frame=CGRectMake(100, 100, 100, 30); [self.view addSubview:label]; label.backgroundColor= [UIColor redColor]; label.text=@&quot;1111111111111&quot;; 这段代码在iOS9上是刚好可以正常显示的，在iOS8上则不行，如下： iOS9： iOS8： 适配注意点： 1、可以通过动态计算来获取label的宽度，进行设置label的宽度 2、一个更简单的方法是通过设置一个确定的字体，来进行适配 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题四——APP传输安全","slug":"116iOS9系列专题四——APP传输安全","date":"2015-09-27T16:00:00.000Z","updated":"2021-07-02T06:48:21.752Z","comments":true,"path":"2015/09/28/116iOS9系列专题四——APP传输安全/","link":"","permalink":"http://huishao.cc/2015/09/28/116iOS9系列专题四——APP传输安全/","excerpt":"","text":"APP Transport Security——加密传输方式随着ios9的推出和Xcode的升级，apple将默认开发者使用https的传输方式，相比http的传输协议，这无疑会增加一些安全性，对于开发者而言，一下子将http协议全部升级为https协议，不是一件容易的事，我们可以通过Xcode的一些配置，使其支持http的传输协议。 如果在Xcode7上运行http协议的应用，会出现如下信息： 这个信息也很清晰，需要我们在info.plist文件中配置一些参数来支持http。 首先，在项目的Info.plist中加入NSAppTransportSecurity这个键，类型为Dictionary,在字典中添加一对键值，键为Boolen类型的NSAllowsArbitraryLoads，值为YES，如下： 这时再运行项目，就可以正常取到数据了。 几点注意： 1.总有朋友说plist文件中配置了依然没有效果，一开始我很奇怪，后来发现了原因，info.plist文件有两个，一个是正式项目中的，一个是测试项目中的，一定要配置在正式项目中。 2.可能Xcode的还有些缺陷，这些键值不能通过自动补全提示出来，需要我们无误的手打。 后续：Xcode7.1中已经支持自动补全的功能。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"Xcode多版本的dmg文件下载方式","slug":"117Xcode多版本的dmg文件下载方式","date":"2015-09-27T16:00:00.000Z","updated":"2021-07-02T06:49:15.605Z","comments":true,"path":"2015/09/28/117Xcode多版本的dmg文件下载方式/","link":"","permalink":"http://huishao.cc/2015/09/28/117Xcode多版本的dmg文件下载方式/","excerpt":"","text":"Xcode多版本的dmg文件下载方式在iOS开发中，有时我们想保有当前版本的Xcode的同时，体验新版本或者兼容旧版本，在apple官网上，是提供给我们下载地址的： 1.访问https://developer.apple.com。 2.选择Resources： 3.选择Xcode，点击download： 4.在网页下方点击additional tools，需要用appid登录： 之后会出现apple的工具列表，选择我们需要的下载即可： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"iOS9系列专题五——全新的联系人与联系人UI框架","slug":"118iOS9系列专题五——全新的联系人与联系人UI框架","date":"2015-09-27T16:00:00.000Z","updated":"2021-07-02T06:50:00.556Z","comments":true,"path":"2015/09/28/118iOS9系列专题五——全新的联系人与联系人UI框架/","link":"","permalink":"http://huishao.cc/2015/09/28/118iOS9系列专题五——全新的联系人与联系人UI框架/","excerpt":"","text":"iOS9全新的联系人相关框架——Contacts Framework一、引言在以前iOS开发中，涉及联系人相关的编程，代码都非常繁琐，并且框架的设计也不是Objective-C风格的，这使开发者用起来非常的难受。在iOS9中，apple终于解决了这个问题，全新的Contacts Framework将完全替代AddressBookFramework，AddressBookFramework也将成为历史被弃用。至于AddressBookFramework的相关api如何繁琐，在以前的博客中有记录，地址如下： 联系人信息相关编程：http://my.oschina.net/u/2340880/blog/407347。 联系人UI界面相关编程：http://my.oschina.net/u/2340880/blog/407973。 这一新的框架是iOS9新特性中十分受欢迎的一个。apple的Objective—C体系也更加完善与强大。 二、让我们来添加一个联系人新的框架的整体思路是通过配置与请求来管理联系人，这样做有一个非常大的好处，逻辑简单，代码层次清晰。如下，通过添加一个联系人来向大家做演示： 1、联系人对象：CNContact这个对象是用来配置联系人信息的，有可变的CNMutaleContact和CNContact，区别用来读取和创建联系人。CNContact对象中有许多属性，对应联系人的一些信息。 首先，创建CNMutableContact对象： 1 CNMutableContact * contact = [[CNMutableContact alloc]init]; 设置联系人头像： 1contact.imageData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;Icon-114.png&quot;]); 设置联系人姓名： 1234 //设置名字 contact.givenName = @&quot;jaki&quot;; //设置姓氏 contact.familyName = @&quot;zhang&quot;; 设置联系人邮箱： 123 CNLabeledValue *homeEmail = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:@&quot;316045346@qq.com&quot;]; CNLabeledValue *workEmail =[CNLabeledValue labeledValueWithLabel:CNLabelWork value:@&quot;316045346@qq.com&quot;]; contact.emailAddresses = @[homeEmail,workEmail]; 这里需要注意，emailAddresses属性是一个数组，数组中是才CNLabeledValue对象，CNLabeledValue对象主要用于创建一些联系人属性的键值对应，通过这些对应，系统会帮我们进行数据的格式化，例如CNLabelHome，就会将号码格式成家庭邮箱的格式，相应的其他键如下： 123456789101112131415//家庭CONTACTS_EXTERN NSString * const CNLabelHome NS_AVAILABLE(10_11, 9_0);//工作CONTACTS_EXTERN NSString * const CNLabelWork NS_AVAILABLE(10_11, 9_0);//其他CONTACTS_EXTERN NSString * const CNLabelOther NS_AVAILABLE(10_11, 9_0);// 邮箱地址CONTACTS_EXTERN NSString * const CNLabelEmailiCloud NS_AVAILABLE(10_11, 9_0);// url地址CONTACTS_EXTERN NSString * const CNLabelURLAddressHomePage NS_AVAILABLE(10_11, 9_0);// 日期CONTACTS_EXTERN NSString * const CNLabelDateAnniversary NS_AVAILABLE(10_11, 9_0); 设置联系人电话： 1contact.phoneNumbers = @[[CNLabeledValue labeledValueWithLabel:CNLabelPhoneNumberiPhone value:[CNPhoneNumber phoneNumberWithStringValue:@&quot;12344312321&quot;]]]; 联系人电话的配置方式和邮箱类似，键值如下： 1234567CONTACTS_EXTERN NSString * const CNLabelPhoneNumberiPhone NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberMobile NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberMain NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberHomeFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberWorkFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberOtherFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberPager NS_AVAILABLE(10_11, 9_0); 这里的CNPhoneNumber对象也是iOS9中的一个新的类，专门用来创建电话号码，之中方法如下： 12345678910@interface CNPhoneNumber : NSObject &lt;NSCopying, NSSecureCoding&gt;//通过类方法创建+ (instancetype)phoneNumberWithStringValue:(NSString *)stringValue;//通过初始化方法创建- (instancetype)initWithStringValue:(NSString *)string;@property (readonly, copy, NS_NONATOMIC_IOSONLY) NSString *stringValue;@end 设置联系人地址： 123456 CNMutablePostalAddress * homeAdress = [[CNMutablePostalAddress alloc]init]; homeAdress.street = @&quot;贝克街&quot;; homeAdress.city = @&quot;伦敦&quot;; homeAdress.state = @&quot;英国&quot;; homeAdress.postalCode = @&quot;221B&quot;; contact.postalAddresses = @[[CNLabeledValue labeledValueWithLabel:CNLabelHome value:homeAdress]]; 设置生日： 12345NSDateComponents * birthday = [[NSDateComponents alloc]init]; birthday.day=7; birthday.month=5; birthday.year=1992; contact.birthday=birthday; 2、创建添加联系人请求：CNSaveRequestCNSaveRequest是用于存储联系人的请求类，通过这个类，我们可以创建批量添加、修改或者删除联系人的请求，例如添加上面我们创建的联系人对象： 1234 //初始化方法 CNSaveRequest * saveRequest = [[CNSaveRequest alloc]init]; //添加联系人 [saveRequest addContact:contact toContainerWithIdentifier:nil]; 这个类中还有许多方便我们操作的方法： 123456789101112131415161718192021222324@interface CNSaveRequest : NSObject//添加一个联系人- (void)addContact:(CNMutableContact *)contact toContainerWithIdentifier:(nullable NSString *)identifier;//更新一个联系人- (void)updateContact:(CNMutableContact *)contact;//删除一个联系人- (void)deleteContact:(CNMutableContact *)contact;//添加一组联系人- (void)addGroup:(CNMutableGroup *)group toContainerWithIdentifier:(nullable NSString *)identifier;//更新一组联系人- (void)updateGroup:(CNMutableGroup *)group;//删除一组联系人- (void)deleteGroup:(CNMutableGroup *)group;//向组中添加子组- (void)addSubgroup:(CNGroup *)subgroup toGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA);//在组中删除子组- (void)removeSubgroup:(CNGroup *)subgroup fromGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA);//向组中添加成员- (void)addMember:(CNContact *)contact toGroup:(CNGroup *)group;//向组中移除成员- (void)removeMember:(CNContact *)contact fromGroup:(CNGroup *)group;@end 3、进行联系人的写入操作:CNContactStoreCNContactStore是一个用于存取联系人的上下文桥梁，现在，把我们创建的添加联系人的请求写入： 12 CNContactStore * store = [[CNContactStore alloc]init]; [store executeSaveRequest:saveRequest error:nil]; 在模拟器上运行程序，打开联系人，效果如下： 联系人界面： 联系人详情： 三、获取格式化的联系人信息iOS9中，ContactFramework也为开发者提供了非常方便的格式化信息的方法，还拿我们上面创建的联系人对象举例： 1、获取格式化的联系人姓名12 NSString * foematter =[CNContactFormatter stringFromContact:contact style:CNContactFormatterStyleFullName]; NSLog(@&quot;%@&quot;,foematter); 这个运行后会打印出jaki zhang，其中style风格枚举如下： 1234567typedef NS_ENUM(NSInteger, CNContactFormatterStyle)&#123; //获取全名 CNContactFormatterStyleFullName, //获取拼音全名 CNContactFormatterStylePhoneticFullName,&#125; NS_ENUM_AVAILABLE(10_11, 9_0); 2、获取格式化的联系人地址12 NSString * foematter =[CNPostalAddressFormatter stringFromPostalAddress:homeAdress style:CNPostalAddressFormatterStyleMailingAddress]; NSLog(@&quot;%@&quot;,foematter); 打印如下： 四、提取联系人在开发中，提取联系人的使用率要远远高于创建联系人，ContactFramework提取联系人的方式，类似于数据库的检索方式，通过配置条件，提取出我们需要的数据，例如： 12345 CNContactStore * stroe = [[CNContactStore alloc]init]; //检索条件，检索所有名字中有zhang的联系人 NSPredicate * predicate = [CNContact predicateForContactsMatchingName:@&quot;zhang&quot;]; //提取数据 NSArray * contacts = [stroe unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey] error:nil]; keysToFetch是设置提取联系人的哪些数据，如上则只提取出检索联系人的名字。 同样，也可以通过请求的方式来对联系人进行遍历： 12345 CNContactStore * stroe = [[CNContactStore alloc]init]; CNContactFetchRequest * request = [[CNContactFetchRequest alloc]initWithKeysToFetch:@[CNContactPhoneticFamilyNameKey]]; [stroe enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSLog(@&quot;%@&quot;,contact); &#125;]; 五、ContactFramework UI相关iOS9中，系统也为我们封装好了一套联系人的UI界面，用起来也十分方便，主要新增的controller有两个： CNContactPickerViewController：展示联系人列表的controller CNContactViewController：展示联系人详细信息的controller 示例如下： 弹出联系人列表： 12 CNContactPickerViewController * con = [[CNContactPickerViewController alloc]init]; [self presentViewController:con animated:YES completion:nil]; 效果如下： 联系人逻辑的相关处理主要在CNContactPickerDelegate中完成： 1234567//视图取消时 调用的方法- (void)contactPickerDidCancel:(CNContactPickerViewController *)picker;//选中与取消选中时调用的方法- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContact:(CNContact *)contact;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContactProperty:(CNContactProperty *)contactProperty;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContacts:(NSArray&lt;CNContact*&gt; *)contacts;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContactProperties:(NSArray&lt;CNContactProperty*&gt; *)contactProperties; CNContactViewController则是用来显示具体联系人的详细信息的，比如： 12 CNContactViewController * con = [CNContactViewController viewControllerForContact:contact]; [self presentViewController:con animated:YES completion:nil]; 相关代理回调函数如下： 123//将要展示联系人信息与已经展示联系人信息的回调- (BOOL)contactViewController:(CNContactViewController *)viewController shouldPerformDefaultActionForContactProperty:(CNContactProperty *)property;- (void)contactViewController:(CNContactViewController *)viewController didCompleteWithContact:(nullable CNContact *)contact; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题二——全新的搜索功能api","slug":"114iOS9系列专题二——全新的搜索功能api","date":"2015-09-26T16:00:00.000Z","updated":"2021-07-02T06:46:31.479Z","comments":true,"path":"2015/09/27/114iOS9系列专题二——全新的搜索功能api/","link":"","permalink":"http://huishao.cc/2015/09/27/114iOS9系列专题二——全新的搜索功能api/","excerpt":"","text":"更加智能的搜索方案——iOS9搜索功能新api一、引言iOS9中为我们提供了许多新的api，搜索功能的加强无疑是其中比较显眼的一个。首先，我们先设想一下：如果在你的app中定义一种标识符，在siri和搜索中，可以用过这个标识符搜索到你的app，是不是很棒？不，这还差得远，你可以定义任意的数据，使其在搜索和siri中可以快速检索到，这样的搜索功能是不是非常酷？不，还有更cool的，你甚至可以在你的网站中添加一些标志，使apple的爬虫可以检索到，那样，即使用户没有安装你的app，也可以在搜索中获取到相应的信息，这太强大了，对吧。 二、3种全新的搜索模式‍1、NSUserActivity‍我们可以在项目中使用相应的函数来添加一些用户的活跃元素，使我们可以在搜索中通过搜索这样的活跃元素展现我们的app。例如： 12345678910 //创建一个对象，这里的type用于区分搜索的类型 NSUserActivity *userActivity = [[NSUserActivity alloc] initWithActivityType: @&quot;myapp&quot;]; //显示的标题 userActivity.title = @&quot;我的app&quot;; // 搜索的关键字 userActivity.keywords = [NSSet setWithArray: @[@&quot;sea&quot;,@&quot;rch&quot;]]; // 支持Search userActivity.eligibleForSearch = YES; //提交设置 [userActivity becomeCurrent]; 在下面的函数中，我们可以处理用户点击搜索后的回调： 123456789101112- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:&#123; NSString *activityType = userActivity.activityType; if ([activityType isEqual: @&quot;myapp&quot;])&#123; // Handle restoration for values provided in userInfo // do something return YES; &#125; return NO; //处理回调&#125; TIP：这种方式添加的关键字搜索，必须创建全局变量，否则无法进行搜索: 2、CoreSpotlightCoreSpotlight是一种更加自由的搜索方式，可以通过添加类似item的模型，将app中的数据展示在搜索栏中，CoreSpotlight框架类似提供了一些增、删、改、查的操作，可是使我们自由的进行搜索属性的设置。 （1）认识3个类在iOS9中，新增加了3个类，通过对这三个类的操作与配合，我们可以轻易的在app中添加CoreSpotlight搜索的功能。 CSSearchableItemAttributeSet：设置类，这个类用于设置搜索标签里的icon，内容，图片等。主要用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//这个类的核心方法只有一个init方法，通过一个类型字符串进行创建，字符串用于在回调中区分@interface CSSearchableItemAttributeSet : NSObject &lt;NSCopying,NSSecureCoding&gt;- (instancetype)initWithItemContentType:(nonnull NSString *)itemContentType;@end//更多的属性设置在其扩展类中，例如：@interface CSSearchableItemAttributeSet (CSGeneral)//展示的名称@property(nullable, copy) NSString *displayName;//名称数组@property(nullable, copy) NSArray&lt;NSString*&gt; *alternateNames;//完整的路径@property(nullable, copy) NSString *path;//链接url@property(nullable, strong) NSURL *contentURL;//图片链接的url@property(nullable, strong) NSURL *thumbnailURL;//设置图片数据@property(nullable, copy) NSData *thumbnailData;//设置一个标识符@property(nullable, copy) NSString *relatedUniqueIdentifier;@property(nullable, strong) NSDate *metadataModificationDate;//内容类型@property(nullable, copy) NSString *contentType;@property(nullable, copy) NSArray&lt;NSString*&gt; *contentTypeTree;//搜索的关键字数组@property(nullable, copy) NSArray&lt;NSString*&gt; *keywords;//标题信息@property(nullable, copy) NSString *title;@end CSSearchableItem：搜索标签类，通过这个类，来创建响应的搜索标签。主要内容如下： 12345678910111213141516//这个类主要用于创建搜索的标签@interface CSSearchableItem : NSObject &lt;NSSecureCoding, NSCopying&gt;//init方法- (instancetype)initWithUniqueIdentifier:(nullable NSString *)uniqueIdentifier //Can be null, one will be generated domainIdentifier:(nullable NSString *)domainIdentifier attributeSet:(CSSearchableItemAttributeSet *)attributeSet;//相应 的属性@property (copy) NSString *uniqueIdentifier;@property (copy, nullable) NSString *domainIdentifier;@property (copy, null_resettable) NSDate * expirationDate;@property (strong) CSSearchableItemAttributeSet *attributeSet;@end CSSearchableIndex：这个类，我个人理解，类似一个manager的作用，通过它对标签进行增、删、改、查等操作： 123456789101112131415161718192021222324@interface CSSearchableIndex : NSObject@property (weak,nullable) id&lt;CSSearchableIndexDelegate&gt; indexDelegate;//判断设备是否支持+ (BOOL)isIndexingAvailable;//取系统的searchIndex管理者+ (instancetype)defaultSearchableIndex;//一般情况下，我们不需要重新创建对象- (instancetype)initWithName:(NSString *)name;- (instancetype)initWithName:(NSString *)name protectionClass:(nullable NSString *)protectionClass;//设置索引标签- (void)indexSearchableItems:(NSArray&lt;CSSearchableItem *&gt; *)items completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//删除指定id索引标签- (void)deleteSearchableItemsWithIdentifiers:(NSArray&lt;NSString *&gt; *)identifiers completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;- (void)deleteSearchableItemsWithDomainIdentifiers:(NSArray&lt;NSString *&gt; *)domainIdentifiers completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//删除所有索引标签- (void)deleteAllSearchableItemsWithCompletionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;@end （2）一个小例子下面，我们通过一个小例子来应用下CoreSpotlight的搜索功能。 首先，需要在项目中导入如下库： 实现如下代码： 12345678910 //进行标签设置 CSSearchableItemAttributeSet * itemSet = [[CSSearchableItemAttributeSet alloc]initWithItemContentType:@&quot;myApp&quot;]; itemSet.title = @&quot;我的APP&quot;; itemSet.keywords = @[@&quot;haha&quot;,@&quot;123&quot;]; itemSet.contentDescription = @&quot;这是搜索到得内容&quot;; itemSet.thumbnailData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;Icon-114.png&quot;]); CSSearchableItem * item = [[CSSearchableItem alloc]initWithUniqueIdentifier:@&quot;1&quot; domainIdentifier:@&quot;1&quot; attributeSet:itemSet]; [[CSSearchableIndex defaultSearchableIndex]indexSearchableItems:@[item] completionHandler:nil]; 我们在搜索中输入haha或者123效果如下： CoreSpotlight的搜索回调和NSUserActivaty一样，只是区分id的方式有所不同： 1234567891011- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:&#123; NSString *activityType = userActivity.activityType; //先取CSSearchableItemActionType if ([activityType isEqual: CSSearchableItemActionType]) &#123; NSString *uniqueIdentifier = [userActivity.userInfo objectForKey:CSSearchableItemActivityIdentifier]; // do something return YES; &#125; return NO;&#125; 3、Web Markup这个功能与我们app开发关系不大，但是对我app的推广却至关重要，这项技术可以让我们的app关联一个网站，apple通过爬虫来获取我们规定的一些标签值，无论用户是否安装了app，在搜索时，都可以展示出相关信息，因为这项功能主要关联前端技术，需要了解的可以参看：[App Search Programming Guide](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8)。 三、结语在我参考的许多相关文章中，都一致建议，iOS9的搜索功能固然强大，然而滥用会造成垃圾信息的泛滥，这样的结果一定会适得其反，作为开发者，我们需要将最合适，最简洁的信息推送到用户的面前。另外，文章有疏漏和错误之处，欢迎指正。 欢迎转载 请注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题三——应用瘦身","slug":"115iOS9系列专题三——应用瘦身","date":"2015-09-26T16:00:00.000Z","updated":"2021-07-02T06:47:35.408Z","comments":true,"path":"2015/09/27/115iOS9系列专题三——应用瘦身/","link":"","permalink":"http://huishao.cc/2015/09/27/115iOS9系列专题三——应用瘦身/","excerpt":"","text":"更小，更快——iOS9的App Thinningapple在iOS9中引入了一套新的app瘦身方案，通过一些优化策略，将尽可能的减小app安装包的体积。这部分的大多工作是由app store来完成，开发者并不需要付出太多额外的开销。这篇博客将这部分内容做了简单的介绍，详细信息在[App Thinning](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)。 App的瘦身策略主要包括三部分： 一、slicing这部分的主要原理是不同的设备下载安装不同的app包，各个app包副本中包含相应尺寸的素材。在xcode中，使用asset catalog管理素材文件，在我们提交应用市场后，会自动帮我们生成各个尺寸包得app副本。 二、BitCode字节码文件是app程序的一种中间形式，苹果会对包含字节码的app进行二次的优化，来进行相应的瘦身。 三、On-Demand Resources这是一种多级应用的设计思路，例如一个游戏，开发者可以将其分为一个大小各异的资源包，用户只需下载一个小的引导程序，在程序内加载相应资源包。这样，可以大大加快应用的安装速度。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题一——3D Touch","slug":"113iOS9系列专题一——3D Touch","date":"2015-09-25T16:00:00.000Z","updated":"2021-07-02T06:45:37.379Z","comments":true,"path":"2015/09/26/113iOS9系列专题一——3D Touch/","link":"","permalink":"http://huishao.cc/2015/09/26/113iOS9系列专题一——3D Touch/","excerpt":"","text":"新的触摸体验——iOS9的3D Touch一、引言在iphone6s问世之后，很多果粉都争先要体验3D Touch给用户带来的额外维度上的交互，这个设计之所以叫做3D Touch，其原理上是增加了一个压力的感触，通过区分轻按和重按来进行不同的用户交互。 二、在模拟器上学习和测试3D Touch3D Touch是一个很新颖的设计，可是苹果文档有言： With Xcode 7.0 you must develop on a device that supports 3D Touch. Simulator in Xcode 7.0 does not support 3D Touch. 看到这句话心是不是凉了一半，是的，xcode7是支持3D Touch开发的，可是模拟器并不支持这个手势，我们只能在真机上进行学习与测试，但是在IT的世界，从来都不缺拯救世界的人物，github上有人为我们提供了这样的一个插件，可以让我们在模拟器上进行3D Touch的效果测试： git地址：https://github.com/DeskConnect/SBShortcutMenuSimulator。 附.SBShortcutMenuSimulator的安装和使用其实安装和使用并不需要怎么介绍，git主页里介绍的很清楚，这里在记录一遍，其中只有一点需要注意，如果你像我一样，电脑中装有Xcode6和Xcode7两个版本，那个Xcode的编译路径，需要做一下修改。 安装： 在终端中一次运行如下指令： 123git clone https://github.com/DeskConnect/SBShortcutMenuSimulator.gitcd SBShortcutMenuSimulatormake 如果电脑中有多个Xcode版本，先做如下操作，如果只有Xcode7，则可以跳过 1sudo xcode-select -switch /Applications/Xcode2.app/Contents/Developer/ 注意：上面命令中，Xcode2.app是你电脑中Xcode的名字，这里如要特别注意，如果名字中有空格，需要修改一下，把空格去掉，否则会影响命令的执行。 之后在SBShortcutMenuSimulator的目录中执行如下操作： 12xcrun simctl spawn booted launchctl debug system/com.apple.SpringBoard --environment DYLD_INSERT_LIBRARIES=$PWD/SBShortcutMenuSimulator.dylibxcrun simctl spawn booted launchctl stop com.apple.SpringBoard 如果没有报错，我们可以通过向指定端口发送消息的方法来在模拟器上模拟3D Touch的效果： 1echo &apos;com.apple.mobilecal&apos; | nc 127.0.0.1 8000 其中，com.apple.mobilecal是应用的Bundle ID ，如果要测试我们的应用，将其改为我们应用的BundleID即可，上面的示例应用是系统日历，可以看到模拟器的效果如下： 三、3D Touch的主要应用文档给出的应用介绍主要有两块： 1.A user can now press your Home screen icon to immediately access functionality provided by your app. 2.Within your app, a user can now press views to see previews of additional content and gain accelerated access to features. 第一部分的应用是我们可以通过3D手势，在主屏幕上的应用Icon处，直接进入应用的响应功能模块。这个功能就例如我们上面的日历示例，会在Icon旁边出现一个菜单，点击菜单我们可以进入相应的功能单元。 我个人理解，这个功能，push消息功能加上iOS8推出的扩展today功能，这三个机制使iOS应用变得无比灵活方便，用户可以不需付出寻找的时间成本来快速使用自己需要的功能。 第二部分是对app的一个优化，用户可以通过3D Touch手势在view上来预览一些预加载信息，这样的设计可以使app更加简洁大方，交互性也更强。 四、3D Touch的三大模块在我们的app中使用3D Touch功能，主要分为以下三个模块： 1、Home Screen Quick Actions通过主屏幕的应用Icon，我们可以用3D Touch呼出一个菜单，进行快速定位应用功能模块相关功能的开发。如上面的日历。 2、peek and pop这个功能是一套全新的用户交互机制，在使用3D Touch时，ViewController中会有如下三个交互阶段： （1）提示用户这里有3D Touch的交互，会使交互控件周围模糊 （2）继续深按，会出现预览视图 （3）通过视图上的交互控件进行进一步交互 这个模块的设计可以在网址连接上进行网页的预览交互。 3.Force PropertiesiOS9为我们提供了一个新的交互参数:力度。我们可以检测某一交互的力度值，来做相应的交互处理。例如，我们可以通过力度来控制快进的快慢，音量增加的快慢等。 五、Home Screen Quick Action使用与相关api详解iOS9为我们提供了两种屏幕标签，分别是静态标签和动态标签。 1、静态标签静态标签是我们在项目的配置plist文件中配置的标签，在用户安装程序后就可以使用，并且排序会在动态标签的前面。 我们先来看静态标签的配置： 首先，在info.plist文件中添加如下键值（我在测试的时候，系统并没有提示，只能手打上去）： 先添加了一个UIApplicationShortcutItems的数组，这个数组中添加的元素就是对应的静态标签，在每个标签中我们需要添加一些设置的键值： 必填项（下面两个键值是必须设置的）： UIApplicationShortcutItemType 这个键值设置一个快捷通道类型的字符串 UIApplicationShortcutItemTitle 这个键值设置标签的标题 选填项（下面这些键值不是必须设置的）： UIApplicationShortcutItemSubtitle 设置标签的副标题 UIApplicationShortcutItemIconType 设置标签Icon类型 UIApplicationShortcutItemIconFile 设置标签的Icon文件 UIApplicationShortcutItemUserInfo 设置信息字典(用于传值) 我们如上截图设置后，运行程序，用我们前面的方法进行测试，效果如下： 2、动态标签动态标签是我们在程序中，通过代码添加的，与之相关的类，主要有三个： UIApplicationShortcutItem 创建3DTouch标签的类 UIMutableApplicationShortcutItem 创建可变的3DTouch标签的类 UIApplicationShortcutIcon 创建标签中图片Icon的类 因为这些类是iOS9中新增加的类，所以其api的复杂程度并不大，下面我们来对其中方法与属性进行简要讲解： 12345678910@interface UIApplicationShortcutItem : NSObject &lt;NSCopying, NSMutableCopying&gt;//下面是两个初始化方法 通过设置type，title等属性来创建一个标签，这里的icon是UIApplicationShortcutIcon对象，我们后面再说- (instancetype)initWithType:(NSString *)type localizedTitle:(NSString *)localizedTitle localizedSubtitle:(nullable NSString *)localizedSubtitle icon:(nullable UIApplicationShortcutIcon *)icon userInfo:(nullable NSDictionary *)userInfo NS_DESIGNATED_INITIALIZER;- (instancetype)initWithType:(NSString *)type localizedTitle:(NSString *)localizedTitle;//下面这是一些只读的属性，获取相应的属性值@property (nonatomic, copy, readonly) NSString *type;@property (nonatomic, copy, readonly) NSString *localizedTitle;@property (nullable, nonatomic, copy, readonly) NSString *localizedSubtitle;@property (nullable, nonatomic, copy, readonly) UIApplicationShortcutIcon *icon;@property (nullable, nonatomic, copy, readonly) NSDictionary&lt;NSString *, id &lt;NSSecureCoding&gt;&gt; *userInfo; 123456789//这个类继承于 UIApplicationShortcutItem，创建的标签可变@interface UIMutableApplicationShortcutItem : UIApplicationShortcutItem@property (nonatomic, copy) NSString *type;@property (nonatomic, copy) NSString *localizedTitle;@property (nullable, nonatomic, copy) NSString *localizedSubtitle;@property (nullable, nonatomic, copy) UIApplicationShortcutIcon *icon;@property (nullable, nonatomic, copy) NSDictionary&lt;NSString *, id &lt;NSSecureCoding&gt;&gt; *userInfo;@end 1234567//这个类创建标签中的icon@interface UIApplicationShortcutIcon : NSObject &lt;NSCopying&gt;//创建系统风格的icon+ (instancetype)iconWithType:(UIApplicationShortcutIconType)type;//创建自定义的图片icon+ (instancetype)iconWithTemplateImageName:(NSString *)templateImageName;@end 创建好标签后，将其添加如application的hortcutItems数组中即可，示例如下： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建 UIApplicationShortcutItem * item = [[UIApplicationShortcutItem alloc]initWithType:@&quot;two&quot; localizedTitle:@&quot;第二个标签&quot; localizedSubtitle:@&quot;看我哦&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypePlay] userInfo:nil]; 添加 [UIApplication sharedApplication].shortcutItems = @[item];&#125; 效果如下： 这里，将系统风格icon的枚举列举如下： 123456789typedef NS_ENUM(NSInteger, UIApplicationShortcutIconType) &#123; UIApplicationShortcutIconTypeCompose,//编辑的图标 UIApplicationShortcutIconTypePlay,//播放图标 UIApplicationShortcutIconTypePause,//暂停图标 UIApplicationShortcutIconTypeAdd,//添加图标 UIApplicationShortcutIconTypeLocation,//定位图标 UIApplicationShortcutIconTypeSearch,//搜索图标 UIApplicationShortcutIconTypeShare//分享图标&#125; NS_ENUM_AVAILABLE_IOS(9_0); 3、响应标签的行为类似推送，当我们点击标签进入应用程序时，也可以进行一些操作，我们可以看到，在applocation中增加了这样一个方法： - (void)application:(UIApplication )application performActionForShortcutItem:(UIApplicationShortcutItem )shortcutItem completionHandler:(void(^)(BOOL succeeded))completionHandler NS_AVAILABLE_IOS(9_0); 当我们通过标签进入app时，就会在appdelegate中调用这样一个回调，我们可以获取shortcutItem的信息进行相关逻辑操作。 这里有一点需要注意：我们在app的入口函数： - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions; 也需要进行一下判断，在launchOptions中有UIApplicationLaunchOptionsShortcutItemKey这样一个键，通过它，我们可以区别是否是从标签进入的app，如果是则处理结束逻辑后，返回NO，防止处理逻辑被反复回调。 几点注意： 1、快捷标签最多可以创建四个，包括静态的和动态的。 2、每个标签的题目和icon最多两行，多出的会用…省略 六、结语关于3DTouch在UIView中的预览功能和UITouch中新增加的力度属性的应用，因为不好演示，这里就不再总结，大家可以通过头文件中相应的类和属性来了解他们，最后，如有疏漏和错误之处，欢迎指正。 欢迎转载 请注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS中UISearchBar(搜索框)使用总结","slug":"112iOS中UISearchBar(搜索框)使用总结","date":"2015-09-21T16:00:00.000Z","updated":"2021-07-01T11:26:06.410Z","comments":true,"path":"2015/09/22/112iOS中UISearchBar(搜索框)使用总结/","link":"","permalink":"http://huishao.cc/2015/09/22/112iOS中UISearchBar(搜索框)使用总结/","excerpt":"","text":"iOS中UISearchBar(搜索框)使用总结初始化：UISearchBar继承于UIView，我们可以像创建View那样创建searchBar 12 UISearchBar * bar = [[UISearchBar alloc]initWithFrame:CGRectMake(20, 100, 250, 40)]; [self.view addSubview:bar]; @property(nonatomic) UIBarStyle barStyle; 这个属性可以设置searchBar的搜索框的风格，枚举如下： 1234567typedef NS_ENUM(NSInteger, UIBarStyle) &#123; UIBarStyleDefault = 0,//默认风格 白色搜索框，多出的背景为灰色 UIBarStyleBlack = 1,//黑色风格，黑色的搜索框 //下面两个枚举已经被禁用，作用和黑色风格一样 UIBarStyleBlackOpaque = 1, // Deprecated. Use UIBarStyleBlack UIBarStyleBlackTranslucent = 2, // Deprecated. Use UIBarStyleBlack and set the translucent property to YES&#125;; @property(nonatomic,copy) NSString *text; 设置搜索框中的文字 @property(nonatomic,copy) NSString *prompt; 这个属性的官方解释是在搜索框顶部显示一行文字，其实就是背景文字，上图说明： 12 bar.prompt = @&quot;搜索框&quot;; bar.text=@&quot;321111111111111111111111111&quot; 效果如下： @property(nonatomic,copy) NSString *placeholder; 和其他文本输入控件的placeholder相同，在输入文字时就会消失 @property(nonatomic) BOOL showsBookmarkButton; 是否在搜索框右侧显示一个图书的按钮，默认为NO，YES的效果如下： @property(nonatomic) BOOL showsCancelButton; 是否显示取消按钮，默认为NO，YES的效果如下： @property(nonatomic) BOOL showsSearchResultsButton; 是否显示搜索结果按钮，默认为NO，YES效果如下： @property(nonatomic, getter=isSearchResultsButtonSelected) BOOL searchResultsButtonSelected ; 设置搜索结果按钮的选中状态 - (void)setShowsCancelButton:(BOOL)showsCancelButton animated:(BOOL)animated; 设置显示取消按钮 @property(nonatomic,retain) UIColor *tintColor; 设置这个颜色值会影响搜索框中的光标的颜色 @property(nonatomic,retain) UIColor *barTintColor; 设置这个颜色会影响搜索框的背景颜色 @property (nonatomic) UISearchBarStyle searchBarStyle; 设置搜索框整体的风格，枚举如下： 12345typedef NS_ENUM(NSUInteger, UISearchBarStyle) &#123; UISearchBarStyleDefault, // currently UISearchBarStyleProminent UISearchBarStyleProminent, // 显示背景 UISearchBarStyleMinimal // 不显示背景&#125; NS_ENUM_AVAILABLE_IOS(7_0); @property(nonatomic,assign,getter=isTranslucent) BOOL translucent; 设置是否半透明 @property(nonatomic) BOOL showsScopeBar ; 是否显示搜索栏的附件选择按钮试图，要想显示这个试图，首先要将这个属性设置为YES，之后给按钮数组中添加按钮，使用下面这个属性： @property(nonatomic,copy) NSArray *scopeButtonTitles ； 设置选择按钮试图的按钮标题 @property(nonatomic) NSInteger selectedScopeButtonIndex; 设置一个默认的选中按钮 123 bar = [[UISearchBar alloc]initWithFrame:CGRectMake(20, 100, 250, 200)]; bar.showsScopeBar=YES; bar.scopeButtonTitles = @[@&quot;12&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;]; @property (nonatomic, readwrite, retain) UIView *inputAccessoryView; 键盘的附属试图 @property(nonatomic,retain) UIImage *backgroundImage; 设置搜索框的背景图案 @property(nonatomic,retain) UIImage *scopeBarBackgroundImage; 设置附属选择按钮视图的背景图案 - (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics ; - (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics 这一对方法可以设置和获取某个状态枚举下的搜索框的背景图案 - (void)setSearchFieldBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; - (UIImage *)searchFieldBackgroundImageForState:(UIControlState)state; 这一对方法用于设置和获取搜索框中TextField的背景图案 - (void)setImage:(UIImage *)iconImage forSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state ; - (UIImage *)imageForSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state ; 这一对方法用于获取和设置搜索栏icon图片的图案 - (void)setScopeBarButtonBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; - (UIImage *)scopeBarButtonBackgroundImageForState:(UIControlState)state; 这一对方法用于设置和获取搜索框的附加选择按钮视图的背景图案 - (void)setScopeBarButtonDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; - (UIImage *)scopeBarButtonDividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; 这一对方法用于获取和设置附加选择按钮视图中切换按钮的图案 - (void)setScopeBarButtonTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state; - (NSDictionary *)scopeBarButtonTitleTextAttributesForState:(UIControlState)state; 这一对方法用于设置和获取切换按钮标题文字的字体属性字典 @property(nonatomic) UIOffset searchFieldBackgroundPositionAdjustment; 搜索文字在搜索框中的位置偏移 @property(nonatomic) UIOffset searchTextPositionAdjustment; textfield在搜索框中的位置偏移 - (void)setPositionAdjustment:(UIOffset)adjustment forSearchBarIcon:(UISearchBarIcon)icon; - (UIOffset)positionAdjustmentForSearchBarIcon:(UISearchBarIcon)icon; 设置搜索栏中图片的位置偏移，图片的枚举如下： 123456typedef NS_ENUM(NSInteger, UISearchBarIcon) &#123; UISearchBarIconSearch, //搜索图标 UISearchBarIconClear, // 清除图标 UISearchBarIconBookmark, // 书本图标 UISearchBarIconResultsList, // 结果列表图标&#125;; 下面是搜索框控件的一些代理方法： - (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar; 将要开始编辑时的回调，返回为NO，则不能编辑 - (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar; 已经开始编辑时的回调 - (BOOL)searchBarShouldEndEditing:(UISearchBar *)searchBar; 将要结束编辑时的回调 - (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar; 已经结束编辑的回调 - (void)searchBar:(UISearchBar )searchBar textDidChange:(NSString )searchText; 编辑文字改变的回调 - (BOOL)searchBar:(UISearchBar )searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString )text ; 编辑文字改变前的回调，返回NO则不能加入新的编辑文字 - (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar; 搜索按钮点击的回调 - (void)searchBarBookmarkButtonClicked:(UISearchBar *)searchBar; 书本按钮点击的回调 - (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar; 取消按钮点击的回调 - (void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar; 搜索结果按钮点击的回调 - (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope; 搜索栏的附加试图中切换按钮触发的回调 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"mac端的优秀抓包工具——Charles使用","slug":"111mac端的优秀抓包工具——Charles使用","date":"2015-09-19T16:00:00.000Z","updated":"2021-07-01T11:20:23.087Z","comments":true,"path":"2015/09/20/111mac端的优秀抓包工具——Charles使用/","link":"","permalink":"http://huishao.cc/2015/09/20/111mac端的优秀抓包工具——Charles使用/","excerpt":"","text":"mac端的优秀抓包工具——Charles使用一、简介Charles是mac端的一款截取与分析网络请求的工具，在网络开发中使用其作分析，可以大大提高我们的开发效率。Charles是收费软件，一般可以试用三十天，但是可以通过相应的破解来获取服务（这里只做演示使用，希望大家购买正版软件）。Charles软件和破解包下载地址：[http://pan.baidu.com/s/1ySsUy](http://pan.baidu.com/s/1ySsUy)。 二、安装与使用下载好压缩包后，解压打开，将软件包拖入应用程序文件夹中，这时候一个原版的软件就可以让我们使用，只是有一个试用期，右键单击我们的Charles应用，显示包内容： 将如下文件夹中的jar包替换为我们破解文件夹中的jar包： 三、使用Charles在mac上进行抓包分析在软件安装完成后，我们已经可以在mac上截取一般的网络请求了，打开软件，将Proxy设置中的Mac OS X Proxy勾选，设置为网络代理，这时候如果发生网络请求，就可以被Charles截获到 如果我们需要截取SSL协议的网络请求，这时候我们还需要安装一个证书：http://yun.baidu.com/s/1o6J2Crg。注意将证书权限设置为始终信任。 抓获信息的界面如下： 软件的功能十分强大，Structure是将请求按域名排序，Sequence是将请求时间排序，下面的Request和Response分别为请求的数据包和返回的数据包，如果是json数据，还会自动帮我们解析格式。 注意：如果iOS模拟器上抓不到请求包，重启模拟器即可。 四、在移动设备上进行抓包导入证书的过程和在mac上一样，在移动设备上访问[http://yun.baidu.com/s/1o6J2Crg](http://yun.baidu.com/s/1o6J2Crg)。进行证书下载，安装： 在移动设备上截获网络请求，我们的移动设备必须和电脑在同一网段，在我们电脑的网络设置中查看IP地址，然后在移动设备上点击我们连接的电脑上的网络，在代理一栏中，选择手动，将我们刚才查看的ip地址填写在这里，并且设置一个端口号。 在Charles中的Proxy setting中如下勾选并配置端口号 我们在设备上再访问网络，请求包就可以被我们抓取到。 五、Charles的更多应用1、过滤网络请求有时候我们只想抓取某个主机的网络请求，我们可以设置过滤网络，在Proxy菜单中的Recording Setting中，我们选择include标签，可以在里面添加一个白名单，这样Charles就只截取在这个主机下的请求： 2、模拟限速网络很多时候，我们需要测试在网络不佳时应用请求的相关数据，我们可以模拟设置限速网络，在Proxy菜单中的Throttle Settings中将，Enable Throttling勾选，并可以在下面进行网路设置，only for selected host可以设置一个指定的主机访问进行限制网络。 3、修改网络信息，多次请求在测试接口时，有时候我们需要反复进行不同参数的接口请求，Charles也支持我们进行请求参数的修改和多次请求，在请求上点击右键，现则edit： 其中的参数，请求类型等我们都可以修改，之后点击execute进行重新请求 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}],"tags":[],"keywords":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}]},{"title":"工厂设计模式的探讨——iOS类簇的应用分析","slug":"110工厂设计模式的探讨——iOS类簇的应用分析","date":"2015-09-17T16:00:00.000Z","updated":"2021-07-01T11:18:02.308Z","comments":true,"path":"2015/09/18/110工厂设计模式的探讨——iOS类簇的应用分析/","link":"","permalink":"http://huishao.cc/2015/09/18/110工厂设计模式的探讨——iOS类簇的应用分析/","excerpt":"","text":"工厂设计模式的探讨——iOS类簇的应用分析一、何为设计模式什么是设计模式，先来看段度娘的话： 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 其实我们不需要这么专业，在我的理解，设计模式就是一种规范化的编程习惯，养成了这样的思想与习惯，对我们的代码，总是有好处了。 二、工厂设计模式首先，工厂设计模式是创建对象的一种设计模式，一个严格意义上的工厂设计模式应该是一个纯虚的构造方法。由子类进行具体对象的创建，我们可以这样理解：现在有一个珲少牌制造工厂，这个工厂可以制造多种交通工具，我大胆一些，假设它可以制造飞机，轮船。小汽车，公交车，出租出和自行车，那么，这些不同的车种虽然功能和大类别统一，但是他们的个体差异也是天地之别，就比如我飞机一小时可以飞5000公里，自行车拼死了劲也不一定能骑20公里。所以，如果珲少这个大工厂要生产他们，也不可能把他们放在一起生产。一个比较明智的决定是，开立分厂，比如珲少飞机工厂专门生产飞机，珲少自行车工厂专门生产自行车。 好了，如果将我们这种人类世界的思维运用于程序世界，那么我们可以通过工厂的这种思维方式来将一些大类抽象为工厂，通过定义接口或者说是定义虚函数来规范这个大工厂的生产规模和流程，由其子类来具体实现这些方法，也就是由一个个小的分厂来明确的生产我们需要的东西。这就是工厂设计模式的基本思路。 三、工厂的设计模式有什么用许多开发者或许并不在意设计模式这个东西，我们可能会想，我实现我的功能就可以了，你管我怎么设计呢。在这篇博客的开头就说到，在我理解中，设计模式就是一种编程习惯和规范，更是一种众多开发者摸索出来的经验，这就像农业上的套种间种和你随便种，哪一种效率高，收成好，不言而喻。那么在软件设计中，工厂模式的应用在哪呢？ 我们先来体验一下在iOS开发中，一些使用工厂设计模式的系统类为我们带来的便捷之处： 1、认识一个名词 类簇在iOS的Foundation框架中，类簇是一种常用的设计模式，他将一些相近的，私有的，具体的子类组合在一个实体的抽象类下面，我称这个抽象类为实体的，是因为和我们交互的接口承载者，就是这个抽象大类。我们平时常用的三大类，NSString,NSArray,NSDictionary都是类簇，我们通过他们创建的对象都是其子类对象的实例化，并不是他本身的实例化，我们还通过上面的例子来理解，我买了一辆珲少小汽车，这两汽车的生产实际是在珲少汽车工厂生产的，但是我个人会依然认为，这是珲少工厂出产的汽车。我们可以通过打印类名来验证： 12NSString * str = [[NSString alloc]initWithCString:&quot;2&quot; encoding:0]; NSLog(@&quot;%@&quot;,[str class]); 结果如下： 可以看到，真实的对象是NSString的子类__NSCFString进行实例化的。 2.这样设计的优势在哪如果你通过NSString的事例还是无法体会到类簇，也就是工厂设计模式的优势，那么下面这个例子你一定经常遇到:NSNumber。我们在创建数字对象的时候，通常会这样考虑，如果是int值，我需要一个IntNumber的类，float值，我需要一个FloatNumber类，如果foundation框架真这么设计的话，那么你现在就痛苦了，你不仅要记住好多这样相似的类，调用方法时也要相应的对象调其内的方法，这使开发者的开发变得更加繁琐，并且对于开发者来说，我并不需要知道具体我创建了什么类，我只是想让他完成既定的方法。说的更通俗一点，还是上面的制造工厂，使用者并不在乎具体这个交通工具是哪个地方生产出来的，只要它价钱和速度都是使用者预期的结果就好了。 3.工厂设计模式的应用通过上面的分析，我们大致可以总结出工厂这种设计模式的应用场景： （1）当一个类并不知道要创建的具体对象是什么，交由子类处理 （2）当一些类有相似的行为和结构，只是具体实现不同时，可以抽象出工厂 （3）使用者并不在乎具体类型，只在乎接口约定的行为，并且这种行为有个体差异 四、在iOS中模拟一个工厂同样是上面的例子，我们来用代码模拟一下： 首先，我们创建一个抽象的工程类，在其中创建一些私有的子类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &lt;Foundation/Foundation.h&gt;//交通工具的枚举typedef enum &#123;car,boat,airport,bycicle,bus,taxi&#125;ToolsName;//代理@protocol TransPortationDelegate &lt;NSObject&gt;-(void)toHome:(Class)class;@end//抽象工厂类@interface TramsPortationFactory : NSObject+(TramsPortationFactory*)buyTool:(ToolsName)tool;//共有的方法接口-(int)shouldPayMoney;-(void)run;@property(nonatomic,strong)id&lt;TransPortationDelegate&gt;delegate;@end//具体实现的子类@interface CarFactory : TramsPortationFactory@end@interface BoatFactory : TramsPortationFactory@end@interface AirportFactory : TramsPortationFactory@end@interface BycicleFactory : TramsPortationFactory@end@interface TaxiFactory : TramsPortationFactory@end@interface BusFactory : TramsPortationFactory@end 实现文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#import &quot;TramsPortationFactory.h&quot;@implementation TramsPortationFactory//实现的创建方法+(TramsPortationFactory*)buyTool:(ToolsName)tool&#123; switch (tool) &#123; case car: return [[CarFactory alloc]init]; break; case airport: return [[AirportFactory alloc]init]; break; case bycicle: return [[BycicleFactory alloc]init]; break; case boat: return [[BoatFactory alloc]init]; break; case taxi: return [[TaxiFactory alloc]init]; break; case bus: return [[BusFactory alloc]init]; break; default: break; &#125;&#125;-(int)shouldPayMoney&#123; return 0;&#125;-(void)run&#123; [self.delegate toHome:[self class]];&#125;@end//各自类实现具体的行为@implementation CarFactory-(int)shouldPayMoney&#123; return 50;&#125;-(void)run&#123; [super run]; NSLog(@&quot;car to home&quot;);&#125;@end@implementation AirportFactory-(int)shouldPayMoney&#123; return 1000;&#125;-(void)run&#123; [super run]; NSLog(@&quot;fly to home&quot;);&#125;@end@implementation BoatFactory-(int)shouldPayMoney&#123; return 300;&#125;-(void)run&#123; [super run]; NSLog(@&quot;boat to home&quot;);&#125;@end@implementation BusFactory-(int)shouldPayMoney&#123; return 10;&#125;-(void)run&#123; [super run]; NSLog(@&quot;bus to home&quot;);&#125;@end@implementation BycicleFactory-(int)shouldPayMoney&#123; return 0;&#125;-(void)run&#123; [super run]; NSLog(@&quot;run to home&quot;);&#125;@end@implementation TaxiFactory-(int)shouldPayMoney&#123; return 100;&#125;-(void)run&#123; [super run]; NSLog(@&quot;go to home&quot;);&#125;@end 这样，我们的一个生产工厂就完成了，在外面，我们只需要知道一个类，我们的抽象父类，就可以实现个子类的行为，示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; TramsPortationFactory * tool = [TramsPortationFactory buyTool:car]; tool.delegate=self; [tool run]; NSLog(@&quot;花了:%d钱&quot;,[tool shouldPayMoney]); TramsPortationFactory * tool2 = [TramsPortationFactory buyTool:airport]; tool2.delegate=self; [tool2 run]; NSLog(@&quot;花了:%d钱&quot;,[tool2 shouldPayMoney]); &#125;-(void)toHome:(Class)class&#123; NSLog(@&quot;%@&quot;,NSStringFromClass(class));&#125; 可以看到，对于开发者，我们并不知晓CarFactory类的存在，我们只需要通过TramsPortationFactory类，就能够操作各种交通工具，达到我们的需求。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}],"tags":[],"keywords":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}]},{"title":"iOS生成标准的注释工具——VVDocumenter","slug":"109iOS生成标准的注释工具——VVDocumenter","date":"2015-09-15T16:00:00.000Z","updated":"2021-07-01T11:16:00.753Z","comments":true,"path":"2015/09/16/109iOS生成标准的注释工具——VVDocumenter/","link":"","permalink":"http://huishao.cc/2015/09/16/109iOS生成标准的注释工具——VVDocumenter/","excerpt":"","text":"iOS生成标准的注释工具——VVDocumenter在程序开发中，我们免不了要写许多注释，方便帮别人也方便我们自己以后检查我们的代码。然而，写注释是一件十分浪费我们时间与精力的事，要写符合文档格式的注释，更是会消耗我们很多的功夫，幸运的是，VVDocumenter可以帮我们很大的忙。 gitHub地址：[https://github.com/onevcat/VVDocumenter-Xcode](https://github.com/onevcat/VVDocumenter-Xcode)。 安装与使用方法：下载github源码，使用xcode打开工程，运行一下，如果成功，插件就安装好了，这时，我们必须将xcode重新启动一下，才可以使用。 重启xcode，在任意一个地方输入///，即会自动出现如下的注释模板，参数部分已经由占位符写好 123456/** * &lt;#Description#&gt; * * @param data &lt;#data description#&gt; */- (void)updateWithData:(id)data; 是不是写注释变成了一件非常有趣的事，你还可以对其进行一些设置，在xcode-&gt;window菜单栏中，有VVDocumenter这个标签，里面可以对生成注释的模板进行一些设置，比如生成注释的快捷键，注释的对齐模式，注释显示创建者和时间等。例如如下设置就会生成这样的注释： 12345678/** * @author Elephant, 15-09-16 13:09:28 * * @brief &lt;#Description#&gt; * * @param data &lt;#data description#&gt; */ - (void)updateWithData:(id)data; 最后，推荐这款小插件给你，祝你写代码愉快O(∩_∩)O。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"我的女神——简洁实用的iOS代码调试框架","slug":"108我的女神——简洁实用的iOS代码调试框架","date":"2015-09-09T16:00:00.000Z","updated":"2021-07-01T11:14:20.096Z","comments":true,"path":"2015/09/10/108我的女神——简洁实用的iOS代码调试框架/","link":"","permalink":"http://huishao.cc/2015/09/10/108我的女神——简洁实用的iOS代码调试框架/","excerpt":"","text":"我的女神——简洁实用的iOS代码调试框架一、引言这篇博客的起源是接手了公司的一个已经完成的项目，来做代码优化，项目工程很大，并且引入了很多公司内部的SDK，要搞清楚公司内部的这套框架，的确不是件容易的事，并且由于这个项目是多人开发的，在调试阶段会打印出巨量的调试信息，使得浏览有用信息变的十分困难，更加恐怖的是，很多信息是SDK中的调试打印，将这些都进行注销是非常费劲甚至不可能的事，于是便有了这样一些需求：首先，我需要清楚了解各个controller之间的跳转关系，需要快速的弄清每个stroyBoard中各个controller的来龙去脉，其次，我想在不改变其他人的调试代码的情况下，屏蔽冗余的log信息，让我的调试数据更加清晰明了。于是我想到了如下的解决方案，同样，如果你有更好的方案或者你知道的优秀的解决办法，请告知我，十分感谢。 二、追踪程序的跳转路径这是一个很容易解决的问题，我们都知道，一个controller，如果要展现出来，一定会走生命周期中的viewWillAppear这个方法，我们只需要在这个方法中做些手脚就可以了，实现有两种思路，一种是采用工厂的设计模式，建立工厂类Controller，在其viewWillAppear中加入我们的调试代码，但这对于我的项目并不实用，首先我不确定所有controller都会继承于一个父类，其次，在我没有找到源头时，这些类已经在公司的framework中了，我根本没办法操作源码。而第二种方案就是runtime，对的，运行时的OC，没有不可能。关于runtime的详细说明，在[http://my.oschina.net/u/2340880/blog/489072](http://my.oschina.net/u/2340880/blog/489072)中有介绍。思路是我们可以写一个方法，替换掉系统的viewWillAppear，在其中加入我们的调试代码，这个方法就是Method Swizzing，代码设计如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//新建一个conreoller的类别#import &quot;UIViewController+YHBaseTest.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIViewController (YHBaseTest)+ (void)load &#123; //只执行一次的线程 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); //创建两个选择器 分别指向 系统的和我们要替换的函数 SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(YHBaseViewWillAppear:); //获取方法实例 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); //现将方法加入 BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); //进行方法替换 if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)YHBaseViewWillAppear:(BOOL)animated &#123;//这里是是我加的一个控制调试锁 后面会介绍 [self YHBaseViewWillAppear:animated]; YHBaseProcessLog(@&quot;YHBaseTest:ViewWillAppear: %@&quot;, self); &#125; 三、屏蔽冗余的log信息1、系统的NSLog是个什么玩意要战胜我们的敌人，首先应该了解我们的敌人，我们想要屏蔽NSLog的打印，先需要清楚NSLog到底是个什么玩意。 首先，NSLog的定义如下： 12FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2);FOUNDATION_EXPORT void NSLogv(NSString *format, va_list args) NS_FORMAT_FUNCTION(1,0); 这里面有两个函数，一个是使用多参的格式化字符串进行NSLog的打印，一个是通过参数指针进行打印。从这里我们可以看出，系统的NSLog是一个C风格的函数，所以，我们有思路了，我们可以通过定义一个NSLog宏来替换掉项目中所有的NSLog，如下： 12//...是省略参数的宏的写法，后面的__VA_ARGS__是系统定义好的一个宏，来声明不定参数#define NSLog(...) YHBaseTestLog(__VA_ARGS__) 2、实现我们自己的NSLog通过上面的方法，在没有动源码的情况下，我们已经可以替换掉程序中所有的打印，可能你会疑问，程序中怎么会允许我们有两个NSLog呢，其实这没什么神奇的，要知道宏是一种预编译的指令，所有这些操作是在代码编译之前完成的，实际上程序中已经将NSLog简单替换成了我们的函数调用，程序中只有一个NSLog，这就是宏的强大之处，狸猫换太子，不错吧。 下面我们来实现我们的这个函数，如下： 123456789101112//不要忘了在.h文件中声明void YHBaseTestLog(NSString *str,...)&#123;//参数列 va_list list; va_start(list, str); //这个地方是一个锁，后面会介绍 if (![YHBaseTestLock sharedTheSingletion]-&gt;_customLock) &#123; //进行打印 NSLogv(str, list); &#125; va_end(list);&#125; 这个函数中其实并没有做什么，加了一个锁的判断，仅此而已，核心的控制，就交给我们的锁吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//.h文件@interface YHBaseTestLock : NSObject&lt;YHSingletonProcotol&gt;&#123; @public BOOL _customLock; BOOL _precessLock;&#125;+(void)customLock;+(void)customUnLock;+(void)processLogLock;+(void)processLogUnLock;//.m//单例方法+(instancetype)sharedTheSingletion&#123; static YHBaseTestLock * sharedModel = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; sharedModel = [[YHBaseTestLock alloc] init]; &#125;); return sharedModel;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; //初始化 默认用户的打印都开起 _customLock=NO; //默认 我们加的controller的打印屏蔽 _precessLock=YES; &#125; return self;&#125;//响应的设置+(void)customLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_customLock=YES;&#125;+(void)customUnLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_customLock=NO;&#125;+(void)processLogLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_precessLock=YES;&#125;+(void)processLogUnLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_precessLock=NO;&#125; 四、看看我们的杰作吧做完上面的工作后，我们在appdelegate中如如下的简单配置： 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //将用户打印加锁 [YHBaseTestLock customLock]; //将流程打印解锁 [YHBaseTestLock processLogUnLock]; return YES;&#125; 我们做如下测试： 1234567891011121314@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSLog(@&quot;111111111111111111111111111111111111111111111111111111111111111&quot;); [YHBaseTestLock customUnLock]; NSLog(@&quot;这个是有用的信息:%@==%d&quot;,@&quot;看我哦&quot;,__LINE__); [YHBaseTestLock customLock]; NSLog(@&quot;32123213123214412312312&quot;);&#125; 我在viewController中的有用信息前后，打印了一些干扰信息，并且可以看到，这个NSLog的格式和系统的完全兼容，在打印有用信息前后解锁和加锁，结果如下： 可以看到，我们将没用的打印都屏蔽了，并且打印了程序的跳转流程。最重要的是，我们对源码一个字符都没有修改，同时不会影响与冲突其他人的开发。 这篇博客开头，我称之为我的女神，真心实感，这个方法帮了我很大的忙，在我了解项目的结构框架前，每次调试打印都在控制区滚出一片片的信息着实让我头晕脑胀，现在一清凉，精神也清爽不少，^_^。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS开发一款小巧简洁的日历控件","slug":"107iOS开发一款小巧简洁的日历控件","date":"2015-09-06T16:00:00.000Z","updated":"2021-07-01T11:09:06.101Z","comments":true,"path":"2015/09/07/107iOS开发一款小巧简洁的日历控件/","link":"","permalink":"http://huishao.cc/2015/09/07/107iOS开发一款小巧简洁的日历控件/","excerpt":"","text":"iOS开发一款小巧简洁的日历控件一、引言日 历是iOS开发中有时会用到的一个UI控件，网上开源的代码也很多，我浏览过一些，大致有两种模式，一种是日历的逻辑由开发者自己实现，通过计算闰年与平 年来确定月份天数，另外一种模式是通过NSDate这个时间类，来获取日历的信息。我个人认为后一种更加安全，代码性能也会更加优质，下面就是我用这种模 式实现的一个日历控件。 二、设计思路1、先来看下效果吧 2、我们需要实现的功能（1）每行7天，对应星期，列数为将当前月显示完全 （2）今日标红 （3）点击的日期背景填充 （4）提供特殊标记，用于标记计划日，节日等 （5）左右无限翻页，直到世界起源和末日 3、设计步骤（1）设计一个日历模型 1234567#import &quot;YHBaseModel.h&quot;@interface YHBaseDateModel : YHBaseModel@property(nonatomic,strong)NSString * year;@property(nonatomic,strong)NSString * month;@property(nonatomic,strong)NSString * day;@end （2）向系统的NSDate类中添加一些扩展方法，便于我们使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//头文件部分@interface NSDate (YHBaseCalendar)/** *获取当前月的天数 */- (NSUInteger)YHBaseNumberOfDaysInCurrentMonth;/** *获取本月第一天 */- (NSDate *)YHBaseFirstDayOfCurrentMonth;//下面这些方法用于获取各种整形的数据/** *确定某天是周几 */-(int)YHBaseWeekly;/** *年月日 时分秒 */-(int)getYear;-(int)getMonth;-(int)getDay;-(int)getHour;-(int)getMinute;-(int)getSecond;@end//实现部分@implementation NSDate (YHBaseCalendar)-(NSUInteger)YHBaseNumberOfDaysInCurrentMonth&#123; return [[NSCalendar currentCalendar] rangeOfUnit:NSDayCalendarUnit inUnit:NSMonthCalendarUnit forDate:self].length; &#125;- (NSDate *)YHBaseFirstDayOfCurrentMonth&#123; NSDate *startDate = nil; BOOL ok = [[NSCalendar currentCalendar] rangeOfUnit:NSMonthCalendarUnit startDate:&amp;startDate interval:NULL forDate:self]; NSAssert1(ok, @&quot;Failed to calculate the first day of the month based on %@&quot;, self); return startDate;&#125;-(int)YHBaseWeekly&#123; return (int)[[NSCalendar currentCalendar] ordinalityOfUnit:NSDayCalendarUnit inUnit:NSWeekCalendarUnit forDate:self];&#125;-(int)getYear&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.year;&#125;-(int)getMonth&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.month;&#125;-(int)getDay&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.day;&#125;-(int)getHour&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.hour;&#125;-(int)getMinute&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.minute;&#125;-(int)getSecond&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.second;&#125;@end （3）设计我们的UI控件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//头文件部分@interface YHBaseCalendarView : YHBaseView@property(nonatomic,strong)NSDate * currentDate;//标记数组 用于标记特殊日期 这个数组中存放的必须是YHBaseDateModel 对象@property(nonatomic,strong)NSArray * markArray;@property(nonatomic,weak)id&lt;YHBaseCalendarViewDelegate&gt; delegate;@end//实现部分@interface YHBaseCalendarView()&lt;UIScrollViewDelegate&gt;&#123; //星期 UIView * _headView; //日历的展示 UIView * _bodyViewL; UIView * _bodyViewM; UIView * _bodyViewR; //滑动功能的支持 UIScrollView * _scrollView; NSDate * _today; YHBaseDateModel * _selectModel;&#125;@end@implementation YHBaseCalendarView-(void)reloadView&#123; _currentDate = [NSDate date]; _today = [NSDate date]; _selectModel = [[YHBaseDateModel alloc]init]; _selectModel.year = [NSString stringWithFormat:@&quot;%d&quot;,[_today getYear]]; _selectModel.month =[NSString stringWithFormat:@&quot;%d&quot;,[_today getMonth]]; _selectModel.day = [NSString stringWithFormat:@&quot;%d&quot;,[_today getDay]]; _scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 30, self.frame.size.width, self.frame.size.height)]; _scrollView.contentSize = CGSizeMake(3*self.frame.size.width, 0); _scrollView.contentOffset = CGPointMake(self.frame.size.width, 0); _scrollView.pagingEnabled=YES; _scrollView.delegate=self; [self addSubview:_scrollView]; _bodyViewL = [[UIView alloc]initWithFrame:CGRectMake(0, 0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewL]; _bodyViewM = [[UIView alloc]initWithFrame:CGRectMake(_scrollView.frame.size.width,0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewM]; _bodyViewR = [[UIView alloc]initWithFrame:CGRectMake(_scrollView.frame.size.width*2, 0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewR]; //展示星期 _headView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, self.frame.size.width, 30)]; _headView.backgroundColor = [UIColor redColor]; NSArray * weekArray = @[@&quot;SUN&quot;,@&quot;MON&quot;,@&quot;TUES&quot;,@&quot;WED&quot;,@&quot;THUR&quot;,@&quot;FRI&quot;,@&quot;SAT&quot;]; for (int i=0; i&lt;7; i++) &#123; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(self.frame.size.width/7*i, 0, self.frame.size.width/7, 30)]; if (i!=0&amp;&amp;i!=6) &#123; label.backgroundColor = [UIColor redColor]; &#125;else&#123; label.backgroundColor = [UIColor purpleColor]; &#125; label.text=weekArray[i]; label.textAlignment = NSTextAlignmentCenter; label.layer.borderWidth=1; label.layer.borderColor = [[UIColor grayColor]CGColor]; label.font = [UIFont boldSystemFontOfSize:16]; label.layer.borderColor=[[UIColor grayColor] CGColor]; label.textColor = [UIColor whiteColor]; label.layer.borderWidth = 1; [_headView addSubview:label]; &#125; [self addSubview:_headView]; [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR];&#125;//核心的构造方法-(void)creatViewWithData:(id)data onView:(UIView *)bodyView&#123; NSDate * currentDate = (NSDate *)data; //获取当前月有多少天 int monthNum = (int)[currentDate YHBaseNumberOfDaysInCurrentMonth]; //获取第一天的日期 NSDate * firstDate = [currentDate YHBaseFirstDayOfCurrentMonth]; //确定这一天是周几 int weekday = [firstDate YHBaseWeekly]; //确定创建多少行 int weekRow=0; int tmp=monthNum; if (weekday!=7) &#123; weekRow++; tmp=monthNum-(7-weekday); &#125; weekRow += tmp/7; weekRow += (tmp%7)?1:0; //开始创建按钮 /** *这里的逻辑是有问题的，应该设计成cell的复用机制，而不应该重复耗性能的创建 有时间在优化 */#warning 可以优化哦 NSArray * array = [bodyView subviews]; for (UIView * v in array) &#123; [v removeFromSuperview]; &#125; int nextDate = 1; //行 for (int i=0; i&lt;weekRow; i++) &#123; //列 for (int j=0; j&lt;7; j++) &#123; //先进行上个月余天的创建 UIButton * btn; if (weekday!=7&amp;&amp;(i*7+j)&lt;weekday) &#123; //获取上个月有多少天 NSDate * preDate = [YHBaseDateTools getPreviousframDate:currentDate]; int preDays = (int)[preDate YHBaseNumberOfDaysInCurrentMonth]; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,preDays-weekday+j+1] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125;else if((i*7+j+1-(weekday==7?0:weekday))&lt;=monthNum)&#123; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,(i*7+j+1-(weekday==7?0:weekday))] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125;else&#123; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,nextDate++] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125; //将今天的日期标出 if ([currentDate getYear]==[_today getYear]&amp;&amp;[currentDate getMonth]==[_today getMonth]&amp;&amp;[btn.titleLabel.text intValue]==[_today getDay]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; &#125; //是否进行自定义标记 /** *if中的颜色比较 是为了让上月与下月的余日不产生bug */ if (_markArray!=nil) &#123; for (int i=0; i&lt;_markArray.count; i++) &#123; YHBaseDateModel * model = _markArray[i]; if ([currentDate getYear]==[model.year intValue]&amp;&amp;[currentDate getMonth]==[model.month intValue]&amp;&amp;[btn.titleLabel.text intValue]==[model.day intValue]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; btn.layer.borderColor = [[UIColor grayColor]CGColor]; btn.layer.borderWidth=1; &#125; &#125; &#125; //是否进行选中标记 if ([_selectModel.year intValue]==[currentDate getYear]&amp;&amp;[_selectModel.month intValue]==[currentDate getMonth]&amp;&amp;[_selectModel.day intValue]==[btn.titleLabel.text intValue]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; btn.backgroundColor = [UIColor cyanColor]; &#125; if (!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; //添加点击事件 [btn addTarget:self action:@selector(clickBtn:) forControlEvents:UIControlEventTouchUpInside]; &#125; &#125; &#125; &#125;//这个方法中进行重构-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.x==0) &#123;//向前翻页了 _currentDate = [YHBaseDateTools getPreviousframDate:_currentDate]; _scrollView.contentOffset=CGPointMake(scrollView.frame.size.width, 0); [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; &#125;else if (scrollView.contentOffset.x==scrollView.frame.size.width)&#123; &#125;else if (scrollView.contentOffset.x==scrollView.frame.size.width*2)&#123; _currentDate = [YHBaseDateTools getNextMonthframDate:_currentDate]; _scrollView.contentOffset=CGPointMake(scrollView.frame.size.width, 0); [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; &#125; scrollView.userInteractionEnabled=YES; if ([self.delegate respondsToSelector:@selector(YHBaseCalendarViewScrollEndToDate:)]) &#123; YHBaseDateModel * model = [[YHBaseDateModel alloc]init]; model.year = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getYear]]; model.month = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getMonth]]; model.day = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getDay]]; [self.delegate YHBaseCalendarViewScrollEndToDate:model]; &#125;&#125;-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; scrollView.userInteractionEnabled=NO;&#125;//点击事件-(void)clickBtn:(UIButton *)btn&#123; _selectModel.year = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getYear]]; _selectModel.month = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getMonth]]; _selectModel.day = btn.titleLabel.text; [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; if ([self.delegate respondsToSelector:@selector(YHBaseCalendarViewSelectAtDateModel:)]) &#123; [self.delegate YHBaseCalendarViewSelectAtDateModel:_selectModel]; &#125; &#125;@end （4）为用户交互设计的协议 1234@protocol YHBaseCalendarViewDelegate&lt;NSObject&gt;-(void)YHBaseCalendarViewSelectAtDateModel:(YHBaseDateModel *)dateModel;-(void)YHBaseCalendarViewScrollEndToDate:(YHBaseDateModel *)dateModel;@end 三、插个小广告控件的源码在[https://github.com/ZYHshao/YHBaseFoundationTest.git](https://github.com/ZYHshao/YHBaseFoundationTest.git)中，这是我封装的一套基于Cocoa与Foundation的更易用的开发框架，其中也对AFN，CRLabel，SDImage,MJRefresh进行了集成，有易用的下载框架，缓存框架，错误处理框架，皮肤管理框架等，也有支持加载HTML并且异步缓存图片的view，边下边播并做缓存的AVAudioPlayer，以及各种自定义性能很强的view控件，如用block创建的按钮，提示框以及对json和模型做相关映射的处理类，如果这些东西有帮到你，我很开心，如果你发现一些问题或者优化建议，请一定告知我，我将十分感激，QQ316045346 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C使用位运算设计可复选的枚举","slug":"106Objective-C使用位运算设计可复选的枚举","date":"2015-09-02T16:00:00.000Z","updated":"2021-07-01T11:08:01.742Z","comments":true,"path":"2015/09/03/106Objective-C使用位运算设计可复选的枚举/","link":"","permalink":"http://huishao.cc/2015/09/03/106Objective-C使用位运算设计可复选的枚举/","excerpt":"","text":"使用位运算设计可复选的枚举一、枚举使用的一个小例子在软件开发中，枚举是我们会经常会用到的一种编程方式，通过枚举，可以使我们的代码更具可读性与统一性。通常情况下，我们会通过typedef来定义一种枚举的类型来使用。例如： 12345typedef enum &#123; para1, para2, para3&#125;myEnum; 我们可以在函数的参数中来使用它： 123456789101112131415161718192021-(void)testEunm:(myEnum)para&#123; switch (para) &#123; case para1: &#123; NSLog(@&quot;para%d&quot;,1); &#125; break; case para2: &#123; NSLog(@&quot;para%d&quot;,2); &#125; break; case para3: &#123; NSLog(@&quot;para%d&quot;,3); &#125; break; default: break; &#125;&#125; 我们在调用调用这样的一个函数的时候，通过传入一个枚举类型，可以分流执行我们想要的操作。 二、枚举到底是个什么东西枚举并不是一种奇怪的类型，起实质是整型的另一个名字，如果没有附加的操作，枚举中的第一个参数默认就是整型0，之后依次递加，当然，我们也可以认为的控制这个数值，例如： 12345typedef enum &#123; para1=7, para2, para3=1000&#125;myEnum; 可以这么理解，我在传参的时候，传7和para1是完全一样的效果，但是后者明显更具可读性。 三、可复选的枚举属性如果熟悉iOS的开发，你会发现系统很多的枚举类型都是可以复选的，例如视图的拉伸模式，json的解析属性等等，这不仅使代码可读性优化，也更加简便了一些选项设置的代码。当我们理解了枚举就是整型之后，会发现其实很容易做到这一点： 首先，我们给定义的枚举参数设置一个有规律的值： 12345typedef enum &#123; para1=1&lt;&lt;1, para2=1&lt;&lt;2, para3=1&lt;&lt;3&#125;myEnum; &lt;&lt;符号是位运算中的左移运算符，将1进行1位，2位，3位的左移后，我们得到的二进制数如下： 123000100100100 现在我们有了一个大致思路了，用当前位的0和1来标识当前属性是否设置，如果有几个属性的复选，只需要将我们的相应枚举进行或的位运算，在取的时候检测相应位是否为1即可，这正是与运算可以做到的： 1234567891011-(void)testEunm:(myEnum)para&#123; if (para&amp;1&lt;&lt;1) &#123; NSLog(@&quot;para1&quot;); &#125; if (para&amp;1&lt;&lt;2) &#123; NSLog(@&quot;para2&quot;); &#125; if (para&amp;1&lt;&lt;3) &#123; NSLog(@&quot;para3&quot;); &#125;&#125; 我们通过如下方式调用： 1[self testEunm:para2|para3]; 打印结果如下： 这种位运算的枚举在官方sdk中被广泛使用，能够有效的简化代码和提高代码的可读性。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计","slug":"105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计","date":"2015-08-29T16:00:00.000Z","updated":"2021-07-01T07:33:15.989Z","comments":true,"path":"2015/08/30/105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计/","link":"","permalink":"http://huishao.cc/2015/08/30/105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计/","excerpt":"","text":"扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计在iOS开发中，图文混排一直都是UI编程的一个核心点，也有许多优秀的第三方引擎，其中很有名的一套图文混排的框架叫做DTCoreText。但是在前些日的做的一个项目中，我并没有采用这套框架，原因有二，一是这套框架体积非常大，而项目的需求其实并不太高；二是要在这套框架中修改一些东西，难度也非常大，我最终采用的是一个叫做RCLabel的第三方控件，经过一些简单的优化和完善，达到了项目的要求。 先来介绍一下我项目中的图文混排的需求：首先我从服务器中取到的数据是字符串，但是其中穿插图片的位置是一个HTML的图片标签，标签里的资源路径就是图片的请求地址。需要达到的要求是这些数据显示出来后，图片的位置要空出来，然后通过异步的网络请求获取图片的数据，再将图片插入文字中。 要自己实现一套这样的引擎确实会比较麻烦，幸运的是RCLabel可以完美的帮我们解析带有HTML标签的数据，进行图文混排，我们先来看一下这个东西怎么用，下面是我封装的一个展示html数据的view： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@interface YHBaseHtmlView()&lt;YHRTLabelImageDelegate&gt;&#123; //RCLabel对象 RCLabel * _rcLabel; //保存属性 用于异步加载完成后刷新 RTLabelComponentsStructure * _origenComponent; //含html标签的数据字符串 NSString * _srt;&#125;@end@implementation YHBaseHtmlView/*// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code&#125;*/- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super initWithCoder:coder]; if (self) &#123; //将rclabel初始化 _rcLabel = [[RCLabel alloc]init]; [self addSubview:_rcLabel]; &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _rcLabel = [[RCLabel alloc]initWithFrame:frame]; [self addSubview:_rcLabel]; &#125; return self;&#125;-(void)reSetHtmlStr:(NSString *)htmlStr&#123; _srt = htmlStr; //这个代理是我额外添加的 后面解释 _rcLabel.imageDelegate=self; //设置frame _rcLabel.frame=CGRectMake(0, 0, self.frame.size.width, 0); //设置属性 _origenComponent = [RCLabel extractTextStyle:htmlStr IsLocation:NO withRCLabel:_rcLabel]; _rcLabel.componentsAndPlainText = _origenComponent; //获取排版后的size CGSize size = [_rcLabel optimumSize]; //重新设置frame _rcLabel.frame=CGRectMake(0, 0, _rcLabel.frame.size.width, size.height); self.frame=CGRectMake(self.frame.origin.x, self.frame.origin.y, _rcLabel.frame.size.width, size.height);&#125;//这是我额外添加的代理方法的实现-(void)YHRTLabelImageSuccess:(RCLabel *)label&#123; _origenComponent = [RCLabel extractTextStyle:_srt IsLocation:NO withRCLabel:_rcLabel]; _rcLabel.componentsAndPlainText = _origenComponent; CGSize size = [_rcLabel optimumSize]; _rcLabel.frame=CGRectMake(0, 0, _rcLabel.frame.size.width, size.height); self.frame=_rcLabel.frame; if ([self.delegate respondsToSelector:@selector(YHBaseHtmlView:SizeChanged:)]) &#123; [self.delegate YHBaseHtmlView:self SizeChanged:self.frame.size]; &#125;&#125; RCLabel的用法很简单，总结来说只有三步： 1.初始化并设置frame 2.通过带html标签的数据进行属性的初始化 3.将属性进行set设置并重设视图frame RCLabel是很强大，并且代码很简练，但是其中处理图片的部分必须是本地的图片，即图片html标签中的路径必须是本地图片的名字，其内部是通过[UIImage ImageNamed:]这个方法进行图片的渲染的，所以要达到我们的需要，我们需要对其进行一些简单的扩展： 1、在属性设置方法中添加一个参数，来区分本地图片与网络图片： 12//我在这个方法中添加了location这个bool值，实际上rclabel这个参数也是我添加的，是为了后面代理使用的+ (RTLabelComponentsStructure*)extractTextStyle:(NSString*)dataimage IsLocation:(BOOL)location withRCLabel:(RCLabel *)rcLabel; 2、在实现方法中添加如下代码，因为原文件有1900多行，在其中弄清楚逻辑关系也确实费了我不小的力气，我这里只将我添加的代码贴过来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#warning 这里进行了兼容性处理 if (location) &#123; //本地图片的渲染 if (tempURL) &#123; UIImage *tempImg = [UIImage imageNamed:tempURL]; component.img = tempImg; &#125; &#125;else&#123;//这里做远程图片数据的处理 //这里我进行了缓存的操作，这个缓存中心是我封装的框架中的另一套东西，这里可以不用在意 //先读缓存 NSData * ceche = [[YHBaseCecheCenter sharedTheSingletion] readCecheFile:tempURL fromPath:YHBaseCecheImage]; if (ceche) &#123; UIImage * tempImg = [UIImage imageWithData:ceche]; component.img=tempImg; &#125;else&#123; //在分线程中进行图片数据的获取 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; if (tempURL) &#123; NSData * data = [YHBaseData getDataWithUrl:tempURL]; if (data) &#123; //获取完成后村缓存 //做缓存 [[YHBaseCecheCenter sharedTheSingletion]writeCecheFile:data withFileID:tempURL toPath:YHBaseCecheImage]; //赋值 回调代理 UIImage * tempImg = [UIImage imageWithData:data]; component.img=tempImg; //这里代理是我添加的，当图片下载完成后 通知视图重新排版 if ([[rcLabel imageDelegate]respondsToSelector:@selector(YHRTLabelImageSuccess:)]) &#123; //在主线程中执行回调 //这个地方要在主线程中执行，否则刷新会有延时 dispatch_async(dispatch_get_main_queue(), ^&#123; [[rcLabel imageDelegate] YHRTLabelImageSuccess:rcLabel]; &#125;); &#125; &#125; &#125;; &#125;); &#125; &#125; 通过如上简单的扩展，基本达到了项目中的需求，这里把我的一些想法和思路分享给大家，有更好的解决方案，或者同是开发爱好者，欢迎指点与交流，我的QQ是316045346。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS程序框架设计之皮肤切换功能","slug":"104iOS程序框架设计之皮肤切换功能","date":"2015-08-20T16:00:00.000Z","updated":"2021-07-01T07:30:50.086Z","comments":true,"path":"2015/08/21/104iOS程序框架设计之皮肤切换功能/","link":"","permalink":"http://huishao.cc/2015/08/21/104iOS程序框架设计之皮肤切换功能/","excerpt":"","text":"iOS程序框架设计之皮肤切换功能一、引言移动应用的开发中，有时我们会需要例如更换皮肤此类的功能，andorid采用xml配置UI的方式，这个问题或许还容易解决些，iOS的主要UI逻辑则是在代码中控制的，如果没有一个强大的框架方案，这个问题将变得非常棘手。网上也有很多诸如此类功能的优秀案例与框架，在这篇博客中，我与大家分享下我的解决方案，其中如果有不恰或者糟糕之处，希望与高人一起交流。 二、设计思路与框架首先我的设计思路是采用通知的方式，原理可以如下理解为以下几步： 1、在系统的通知中心注册一个通知 2、所有需要更改皮肤功能的controller作为这个通知的监听者 3、设计一个皮肤的model类 4、将controller中有关皮肤设置的属性从model中取 5、在切换皮肤前更改皮肤model 6、发送更改皮肤的通知 上面的6个步骤是这整个框架的基本逻辑，框架无非是将这些逻辑进行优化与封装。下面这张图很烂，但是思路很清晰： 首先最上面是我设计的一个切换主题的manager，我这里的设计有个缺陷，我将manager和主题配置相关的model混合在了一起，写的时候简单了些，可这给框架的逻辑上带来了混乱，所以我在图中使用曲线和虚椭圆将其分离，manager来控制切换model的属性，我们在controller中取model的属性进行配置，这个manager的逻辑位置是交互时间与通知中心的桥梁。manager中的核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//单例方法+(instancetype)sharedTheSingletion&#123; static YHTopicColorManager * sharedModel = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; sharedModel = [[YHTopicColorManager alloc] init]; &#125;); return sharedModel;&#125;//这个方法应该分离在model中，从本地读取当前的主题模式，更改后我们只需要更改本地数据 然后重新调用这个方法即可-(void)getTopicModel&#123; //从本地读取 int tp = [YHSASystemSettingManager sharedTheSingletion].topic; if (tp==0) &#123; //默认为白天主题 tp=dayTime; [YHSASystemSettingManager sharedTheSingletion].topic = tp; &#125; switch (tp) &#123; //这里是我定义的一些枚举，拿白天和夜间模式示范 case dayTime://白天模式 &#123; //这里面定义一些白天模式下 控件的颜色属性 也可以定义其他 _navColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _bgColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _btnColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _textColor=[UIColor colorWithRed:0 green:0 blue:0 alpha:1]; _btnTextColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _navTextColor= [UIColor whiteColor]; &#125; break; case nightTime://夜间模式 &#123; //这里面定义夜间模式下的相关控件的颜色属性 _navColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _bgColor=[UIColor colorWithRed:0 green:0 blue:0 alpha:1]; _btnColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _textColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _btnTextColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _navTextColor= [UIColor whiteColor]; &#125; break; default: break; &#125;&#125;//发送更改主题的消息+(void)postTopicChangeMessage&#123; [[NSNotificationCenter defaultCenter]postNotificationName:YHTopicChangeTopicNotication object:nil];&#125; 在manager调用通知中心发送通知后，我们要让所有需要改变主题的视图控制器都接收到通知，最简便的做法是，我们设计一个父类，让父类监听通知，所有需要有主题更改功能的控制器继承于它即可，这个father controller的核心代码如下： 1234567891011121314151617//移除监听-(void)dealloc&#123; [[NSNotificationCenter defaultCenter]removeObserver:self];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //添加监听主题更换的通知 [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(useYHTopicToCreatViewWithModel) name:YHTopicChangeTopicNotication object:nil]; //协议中的方法，加载主题 一会再说 [self useYHTopicToCreatViewWithModel];&#125;//子类实现如下方法-(void)useYHTopicToCreatViewWithModel&#123; &#125; 到目前，我们已经可以顺利接收到主题切换的通知，可是要所有子类都步伐一致的执行相同一个操作，我们可以通过一个协议来约定，这就是图中的主框架的protocol，这个协议中规定一个特定的方法，我们在父类中调用，子类中实现，当收到通知时，所有子类都将重新加载这个方法，如果我们将皮肤设置部分在这个方法中实现，那么正是我们想要的效果，所有皮肤设置都被重新加载了。协议如下： 12345678910111213/** *这里定义主题的风格 */typedef enum &#123; dayTime=1,//白天 nightTime//夜间&#125;YHTopicModel;@protocol YHTopicProcotol &lt;NSObject&gt;//所有可以更换主题的界面必须遵守这个协议调用并实现如下方法//将视图中控件的颜色摄住部分全部放在这个方法中@required-(void)useYHTopicToCreatViewWithModel;@end 这时，就剩下我们这套逻辑的最后一步了，我们只需要将控件的颜色设置写在子类的协议方法中，并且，这些设置的数据来源于model这个模型，整个体系就完成了，子类实现方法如下： 1234567891011121314151617-(void)useYHTopicToCreatViewWithModel&#123;//获取到模型 YHTopicColorManager * model = [YHTopicColorManager sharedTheSingletion]; //加载模型数据 [model getTopicModel]; //进行设置 self.view.backgroundColor = model.bgColor; _schoolLabel.textColor = model.textColor; _phoneLabel.textColor = model.textColor; _secertLabel.textColor = model.textColor; _reWriteSecretLabel.textColor = model.textColor; _questionLabel.textColor = model.textColor; _answerLabel.textColor = model.textColor; _registBtn.backgroundColor = model.btnColor; [_registBtn setTitleColor:model.btnTextColor forState:UIControlStateNormal]; &#125; 我简单写了一些界面，不论任何地方切换皮肤，所有界面效果都会改变： 切换夜间模式前： 开启夜间模式后： 三、补充自己的思路实现更换主题的一种方法，真诚的想与志同道合的朋友交流开发经验，如果你想批评，点拨，交流或者是借鉴我的代码，Q316045346随时欢迎。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"Xcode创建可复用的代码块","slug":"102Xcode创建可复用的代码块","date":"2015-08-12T16:00:00.000Z","updated":"2021-07-01T07:28:01.268Z","comments":true,"path":"2015/08/13/102Xcode创建可复用的代码块/","link":"","permalink":"http://huishao.cc/2015/08/13/102Xcode创建可复用的代码块/","excerpt":"","text":"Xcode创建可复用的代码块在各种程序开发中，编写代码的效率是非常重要的一个问题，各种优秀的编译器也都有相应的插件用于提高程序员的编码速度。在xcode中，可以通过定义代码块的方式将常用的一部分代码进行快捷呼出，首先xcode中为我们定义好了许多代码块，例如： 在使用这些代码模板时，我们只需要将其拖入我们的代码中，或者直接键入快捷键即可，十分的方便，当然，我们也可以将我们自己常用的代码块包装成模板，便于我们复用。 例如，我写如下的代码段： 1@property(nonatomic,copy)NSString * str; 将其选中，长按左键，直到鼠标变成箭头模样，然后将其拖入右下方的代码块模板区，会弹出如下设置菜单： title用来设置我们的代码块名称。 platform用来设置代码块可以使用的平台。 Language用来设置支持的编程语言。 completion用来设置快捷键入的快捷键，比如我们设置为pro 如果我们需要将其中的某些参数进行，替换，比如上面的NSString和str,我们想在编码时自定义他们，我们这样写： &lt;#NSString#&gt;*&lt;#str#&gt; 这时，界面就变成了如下这样： 我们点击Done后，在代码中输入pro会自动提示出这段代码段，变成方便了许多。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"iOS中RunLoop机制浅探","slug":"103iOS中RunLoop机制浅探","date":"2015-08-12T16:00:00.000Z","updated":"2021-07-01T07:29:41.399Z","comments":true,"path":"2015/08/13/103iOS中RunLoop机制浅探/","link":"","permalink":"http://huishao.cc/2015/08/13/103iOS中RunLoop机制浅探/","excerpt":"","text":"iOS中RunLoop机制浅探一、浅识RunLoopRunLoop这个家伙在iOS开发中，我们一直在用，却从未注意过他，甚至都不从见过他的面孔，那个这个神秘的家伙究竟是做什么的？首先，我们先来观察一下我们的程序运行机制。 无论是面向对象的语言或是面向过程的语言，代码的执行终究是面向过程的。线程也一样，一个线程从开始代码执行，到结束代码销毁。就像HELLO WORLD程序，打印出字符串后程序就结束了，那么，我们的app是如何实现如下这样的机制的呢：app从运行开始一直处于待命状态，接收到类似点击事件等用户交互后执行相应操作，完成后继续等待交互响应，直到我们将程序杀死。通过这个过程的分析，我们可能会猜到，我们执行的主线程一定是在一个死循环中，没有任务的时候进行休眠，接收到任务后被激活执行任务。现在我们可以理解了，这样一个管理线程执行任务的机制就是RunLoop机制，线程在执行中的休眠与激活就是由RunLoop对象进行管理的。 二、RunLoop与线程的关系上面我们说到，RunLoop是用来管理线程的，那么他们直接有着怎样的关系，又是怎样进行交互的呢。事实上，每一个线程中都有一个Runloop对象，可以通过具体方法获得。这里有一点需要我们注意，官方文档上描述，虽然每一个线程中都可以获取RunLoop对象，但是并不是每一个线程中都有这个实例对象，我们可以这样理解：如果我们不获取runloop，这个runloop就不存在，我们获取时，如果不存在，就会去创建。在主线程中，这个MainRunLoop是默认创建并运行激活的。 三、认识NSRunLoopNSRunLoop是Cocoa框架中的类，与之对应，在Core Fundation中是CFRunLoopRef类。这两者的区别是前者不是线程安全的，而后者是线程安全的。我们这里只来讨论NSRunLoop的属性和方法： + (NSRunLoop *)currentRunLoop; 获取当前线程的RunLoop：有则获取，无则创建 + (NSRunLoop *)mainRunLoop ; 获取主线程的RunLoop @property (readonly, copy) NSString *currentMode; 获取当前runloop的执行模式，两种模式如下： NSString * const NSDefaultRunLoopMode; 默认模式，接收大部分输入源的响应 NSString * const NSRunLoopCommonModes; 多种模式的集合 - (CFRunLoopRef)getCFRunLoop; 获取RunLoop的CFRunLoopRef对象 - (void)addTimer:(NSTimer )timer forMode:(NSString )mode; 将定时器添加到runloop中 - (void)addPort:(NSPort )aPort forMode:(NSString )mode; 添加输入源端口到runloop中，NSPort对象可以理解为详细的载体，会传递消息与其代理。 - (void)removePort:(NSPort )aPort forMode:(NSString )mode; 将某个输入源端口移除 - (NSDate )limitDateForMode:(NSString )mode; 获取下个响应时间 解释：例如定时器的执行，其并不是按时间的间隔进行调用方法，而是在定时器注册到runloop中后，runloop会设置一个一个的时间点进行调用，比如10，20，30。如果错过了某个时间点，定时器并不会延时调用，而是直接等待下一个时间点调用，所以定时器并不是精准的。 - (void)acceptInputForMode:(NSString )mode beforeDate:(NSDate )limitDate; 在某个时间期限前接收响应 - (void)run;开始运行 - (void)runUntilDate:(NSDate *)limitDate; 到某个时间点运行 - (BOOL)runMode:(NSString )mode beforeDate:(NSDate )limitDate; 在某个期限前运行 四、RunLoop的应用正如前面所说，我们一直在使用他，却很少见到他。并且，我们在大多数情况下，都不需要显式的创建或者启动RunLoop，有两种情况，我们却必须手动设置它： 1、在分线程中使用定时器定时器的实现便是基于runloop的，平时我们使用定时器你或许并没有对runloop做什么操作，那是因为主线程的runloop默认是开启运行的，如果我们在分线程中也需要重复执行某一动作，如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(time) userInfo:nil repeats:YES]; &#125;); &#125;-(void)time&#123; NSLog(@&quot;run&quot;);&#125; 你会发现，程序运行后并没有打印任何信息，方法并没有被调用，我们必须在线程中手动的执行如下代码： 1 [[NSRunLoop currentRunLoop] run]; 定时器才能正常工作。 2、当你在线程中使用如下方法时某些延时函数和选择器在分线程中的使用，我们也必须手动开启runloop，这些方法如下： @interface NSObject (NSDelayedPerforming) - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes; - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay; + (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(id)anArgument; + (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget; - (void)performSelector:(SEL)aSelector target:(id)target argument:(id)arg order:(NSUInteger)order modes:(NSArray *)modes; - (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target; 五、补充RunLoop更强大的地方在于对消息的监听，因为CFRunLoopRef的线程安全优势，我们通常会更多使用后者。 细心的你可能会发现，输入源被注册进Runloop中时会有方法进行remove，但是定时器却没有，但是定时器中的invalidate方法可以将其从runloop中移除，正如官方文档的说明：invalidate是重要也是唯一的可以将定时器从runloop的注销的方法，所以如果我们创建了定时器，就一定要在不使用时调用invalidate方法。我不知道apple为何将定时器的方法分离开来，可能的原因是让开发者更少的显式调用runloop的方法，你若是知道原因，恳请留言指导。 关于定时器的问题，在另一篇博客中有介绍：[http://my.oschina.net/u/2340880/blog/398598](http://my.oschina.net/u/2340880/blog/398598)。 学习使用 欢迎转载 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中制作可复用的框架Framework","slug":"101iOS中制作可复用的框架Framework","date":"2015-08-11T16:00:00.000Z","updated":"2021-07-01T07:27:21.399Z","comments":true,"path":"2015/08/12/101iOS中制作可复用的框架Framework/","link":"","permalink":"http://huishao.cc/2015/08/12/101iOS中制作可复用的框架Framework/","excerpt":"","text":"iOS中制作可复用的框架Framework在iOS开发中，我们时常会使用一些我们封装好的管理类，框架类，方法类等，我们在实现这些文件时，可能还会依赖一些第三方库或者系统库。如果每次我们复用这些代码时，都要将关联的这些东西进行导入，甚至还要进行arc和mrc的编译设置，会浪费我们很大的精力。除此之外，如果项目需要多人合作，你可能也并不希望你的源代码暴漏在所有人的面前，这个时候，我们就可以使用静态库或者动态库的方式来对我们的代码进行包装，便于复用。静态库的制作方法在一篇旧的博客中有描述：[http://my.oschina.net/u/2340880/blog/398887](http://my.oschina.net/u/2340880/blog/398887)。相比静态库文件，动态库的效率会更高且封装性更好，这里主要讨论动态库的制作。 xcode6后支持在xcode中制作动态库，并且过程也十分简单。 新建一个项目，选择framework： 之后我们在里面编写我们的代码，比如我们创建一个MyObject类： 123456789@interface MyObject : NSObject-(void)myLog;@end@implementation MyObject-(void)myLog&#123; NSLog(@&quot;framework&quot;);&#125;@end 和静态库类似，如果我们不做任何处理，打包出来的库文件只能在模拟器或者只能在真机上使用，为了方便我们调试，我们可以添加一个脚本命令，是的生成一个同时支持模拟器和真机的framework： 新建target： 选择Aggregate： 之后，我们在target的Build Phases中点击加号： 添加一个Run Script： 在里面添加如下的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556set -eset +u# Avoid recursively calling this script.if [[ $SF_MASTER_SCRIPT_RUNNING ]]thenexit 0fiset -uexport SF_MASTER_SCRIPT_RUNNING=1SF_TARGET_NAME=$&#123;PROJECT_NAME&#125;SF_EXECUTABLE_PATH=&quot;$&#123;SF_TARGET_NAME&#125;.framework/$&#123;SF_TARGET_NAME&#125;&quot;SF_WRAPPER_NAME=&quot;$&#123;SF_TARGET_NAME&#125;.framework&quot;if [[ &quot;$SDK_NAME&quot; =~ ([A-Za-z]+) ]]thenSF_SDK_PLATFORM=$&#123;BASH_REMATCH[1]&#125;elseecho &quot;Could not find platform name from SDK_NAME: $SDK_NAME&quot;exit 1fiif [[ &quot;$SDK_NAME&quot; =~ ([0-9]+.*$) ]]thenSF_SDK_VERSION=$&#123;BASH_REMATCH[1]&#125;elseecho &quot;Could not find sdk version from SDK_NAME: $SDK_NAME&quot;exit 1fiif [[ &quot;$SF_SDK_PLATFORM&quot; = &quot;iphoneos&quot; ]]thenSF_OTHER_PLATFORM=iphonesimulatorelseSF_OTHER_PLATFORM=iphoneosfiif [[ &quot;$BUILT_PRODUCTS_DIR&quot; =~ (.*)$SF_SDK_PLATFORM$ ]]thenSF_OTHER_BUILT_PRODUCTS_DIR=&quot;$&#123;BASH_REMATCH[1]&#125;$&#123;SF_OTHER_PLATFORM&#125;&quot;elseecho &quot;Could not find platform name from build products directory: $BUILT_PRODUCTS_DIR&quot;exit 1firm -rf buildProductsmkdir buildProducts# Build the other platform.xcrun xcodebuild -project &quot;$&#123;PROJECT_FILE_PATH&#125;&quot; -target &quot;$&#123;TARGET_NAME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION&#125;&quot; -sdk $&#123;SF_OTHER_PLATFORM&#125;$&#123;SF_SDK_VERSION&#125; BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION# Smash the two static libraries into one fat binary and store it in the .frameworkxcrun lipo -create &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework/$PRODUCT_NAME&quot; &quot;$&#123;SF_OTHER_BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework/$PRODUCT_NAME&quot; -output &quot;$&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME&quot;cp -rf $&#123;BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework $&#123;PROJECT_DIR&#125;/buildProductsmv $&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME $&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME.framework 接着，我们需要将给外界的接口文件暴露出来，将其移动到public下即可： 之后我们运行程序，需要注意的一点事，如果要支持64位，需要在编译选项中设置，如下： 到此时，我们的framework库文件就制作完成，在xcode的window-&gt;projects中选中我们的这个项目，点击进入文件夹的小箭头： 在build-&gt;product中便可以找到我们的framework文件，我们将其赋值出来即可以使用。 我们测试一下，新建一个工程，将刚才制作的静态库导入，如下加入头文件，调用方法，可以使用。 123#import &lt;MyFramework/MyObject.h&gt; MyObject * obj = [[MyObject alloc]init]; [obj myLog]; 两个技巧： 一、如果你运行程序出现类似Reason: image not found!的崩溃信息，可能的原因是动态库文件中的某些文件你的项目中已经包含了，在Build Phases中将required改成optional即可。 二、一个优秀且完整的框架可能会包含相当多的文件，包括框架自己的和其他第三方的，为了使用的方便，我们可以将头文件都导入一个的头文件中，这里有一个地方我们需要注意，我们直接在framework工程中添加的头文件是不会编译的，我的解决方案是通过建一个OC的类，在这个类中导入这个总的头文件，将这个类隐藏成私有的，就可以解决问题了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"iOS多线程开发之深入GCD","slug":"100iOS多线程开发之深入GCD","date":"2015-08-10T16:00:00.000Z","updated":"2021-07-01T07:22:45.752Z","comments":true,"path":"2015/08/11/100iOS多线程开发之深入GCD/","link":"","permalink":"http://huishao.cc/2015/08/11/100iOS多线程开发之深入GCD/","excerpt":"","text":"iOS多线程开发之深入GCD一、前言在以前的一些系列博客中，对iOS中线程的管理做了总结，其中涵盖了GCD的相关基础知识：[http://my.oschina.net/u/2340880/blog/417746](http://my.oschina.net/u/2340880/blog/417746)。那里面将GCD的线程管理能力，列队组能力，通过信号和消息控制程序流程的能力都有介绍，这里，我们继续深入GCD的功能，通过GCD来处理一些逻辑更加复杂的代码功能。 二、延时追加任务当我们在程序中处理延时任务的时候，我们一般会通过两种方式，一种是通过定时器进行延时执行，另外一种是通过如下的函数： - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay; 然而，如果我们需要在多线程中进行延时操作，上面两种方式会显得十分麻烦，并且徒增代码的复杂度。GCD为我们提供了一种方式： void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); 这个方法有三个参数，第一个参数延时的时间，第二个参数为将任务加入的队列，第三个block为要执行的任务。示例如下： 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;1233&quot;); &#125;); 这里通过dispatch_time来创建时间对象，将打印信息的方法在3S后加入主线程队列。需要注意的是，这里只是将任务延时加入队列，并不是执行，如果是加入同步队列中，则会进入等待状态。 三、数据存取的线程安全问题在进行多线程编程时，或许总会遇到一类问题，数据的竞争与线程的安全。这些问题如果我们通过程序手动来控制难度将会非常大。GCD同样为我们简单的解决了这样的问题。 首先，如果只是在读取数据，而不对数据做任何修改时，我们并不需要处理安全问题，可以让多个任务同时进行读取，可是如果要对数据进行写的操作，那么在同一时间，我们就必须只能有一个任务在写，GCD中有一个方法帮我们完美的解决了这个问题，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839//创建一个队列dispatch_queue_t queue = dispatch_queue_create(&quot;oneQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //几个任务同时读操作 dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read1:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read2:%d&quot;,i); &#125; &#125;); //此处进行写操作 /* 下面这个函数在加入队列时不会执行，会等待已经开始的异步执行全部完成后再执行，并且在执行时，会阻塞其他任务 执行完成后，其他任务重新进入异步执行 */ dispatch_barrier_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;write:%d&quot;,i); &#125; &#125;); //继续进行异步读操作 dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read3:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read4:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read5:%d&quot;,i); &#125; &#125;); 打印信息如下： 可以看出，读操作是异步进行的，写操作是等待后阻塞任务队列独立进行，结束后队列恢复异步执行读操作，这正是我们需要的效果。 四、GCD模式的单例通常情况下，我们的单例会是如下的样子： 1234567+(instancetype)shared&#123; static Auto * obj; if (obj==nil) &#123; obj = [[Auto alloc]init]; &#125; return obj;&#125; 这种通过读取静态变量的方式在大多数情况下是没问题的，可是并不能保证程序百分百的安全，因为在多线程的操作中，会有可能初始化多个对象，在GCD中，我们可以使用如下方式： 12345678910+(instancetype)shared&#123; static Auto * obj; //dispatch_once_t对象可以只保证执行一次 static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; obj = [[Auto alloc]init]; &#125;); return obj; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS视频功能模块的开发","slug":"99iOS视频功能模块的开发","date":"2015-08-09T16:00:00.000Z","updated":"2021-07-01T07:21:37.500Z","comments":true,"path":"2015/08/10/99iOS视频功能模块的开发/","link":"","permalink":"http://huishao.cc/2015/08/10/99iOS视频功能模块的开发/","excerpt":"","text":"iOS视频功能模块的开发一、使用MPMoviePlayerController进行视频播放MPMoviePlayerController是iOS中进行视频播放开发的一个控制类，里面涵盖了视频播放中大部分的需求功能，在使用这个框架时，需要导入头文件&lt;MediaPlayer/MediaPlayer.h&gt;。 1、初始化方法MPMoviePlayerController可以播放网络视频，也可以播放本地视频，通过不同的URL来进行初始化，例如本地视频的初始化如下： 123456//视频文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;mp4&quot;]; //视频URL NSURL *url = [NSURL fileURLWithPath:path]; //视频播放对象 MPMoviePlayerController * movie = [[MPMoviePlayerController alloc] initWithContentURL:url]; 初始化和完成相关配置后，我们需要将MPMoviePlayerController对象的View添加在我们需要的UI视图上，这个控制器只提供的控制的相关功能，外部的UI并没有为我们提供好。 2、相关属性与方法@property (nonatomic, copy) NSURL *contentURL; 视频文件的url地址 @property (nonatomic, readonly) UIView *view; 播放器view，在使用之前，必须设置frame大小，然后将其添加在我们的UI视图上 @property (nonatomic, readonly) UIView *backgroundView; 播放器背景颜色 @property (nonatomic, readonly) MPMoviePlaybackState playbackState; 播放器的当前播放状态，枚举定义如下： 12345678typedef NS_ENUM(NSInteger, MPMoviePlaybackState) &#123; MPMoviePlaybackStateStopped,//停止播放 MPMoviePlaybackStatePlaying,//正在播放 MPMoviePlaybackStatePaused,//暂停播放 MPMoviePlaybackStateInterrupted,//中断播放 MPMoviePlaybackStateSeekingForward,//快进 MPMoviePlaybackStateSeekingBackward//快退&#125;; @property (nonatomic, readonly) MPMovieLoadState loadState; 播放器的网络缓存状态，枚举定义如下： 123456typedef NS_OPTIONS(NSUInteger, MPMovieLoadState) &#123; MPMovieLoadStateUnknown = 0,//状态未知 MPMovieLoadStatePlayable = 1 &lt;&lt; 0,//缓存数据足够开始播放，但是视频并没有缓存完全 MPMovieLoadStatePlaythroughOK = 1 &lt;&lt; 1, //已经缓存完成，如果设置了自动播放，这时会自动播放 MPMovieLoadStateStalled = 1 &lt;&lt; 2, //数据缓存已经停止，播放将暂停&#125;; @property (nonatomic) MPMovieControlStyle controlStyle; 播放器风格，枚举如下: 1234567typedef NS_ENUM(NSInteger, MPMovieControlStyle) &#123; MPMovieControlStyleNone, // 无控制器 MPMovieControlStyleEmbedded, // 嵌入视频风格 MPMovieControlStyleFullscreen, // 全屏播放风格 MPMovieControlStyleDefault = MPMovieControlStyleEmbedded&#125;; @property (nonatomic) MPMovieRepeatMode repeatMode; 播放器的循环模式，枚举如下： 1234typedef NS_ENUM(NSInteger, MPMovieRepeatMode) &#123; MPMovieRepeatModeNone,//播放结束后不循环 MPMovieRepeatModeOne//循环&#125;; @property (nonatomic) BOOL shouldAutoplay; 是否开启自动播放 @property (nonatomic, getter=isFullscreen) BOOL fullscreen; 设置是否充满屏幕 - (void)setFullscreen:(BOOL)fullscreen animated:(BOOL)animated; 设置是否充满屏幕，带动画效果 @property (nonatomic) MPMovieScalingMode scalingMode; 设置播放器的填充方式，枚举定义如下： 123456typedef NS_ENUM(NSInteger, MPMovieScalingMode) &#123; MPMovieScalingModeNone, // 无缩放 MPMovieScalingModeAspectFit, // 适应大小模式 MPMovieScalingModeAspectFill, // 充满可视范围，可能会被裁剪 MPMovieScalingModeFill // 缩放到充满视图&#125;; @property (nonatomic, readonly) BOOL readyForDisplay NS_AVAILABLE_IOS(6_0); 返回YES说明数据栈已经缓存好数据，返回NO则没有缓存好 @property (nonatomic, readonly) MPMovieMediaTypeMask movieMediaTypes; 数据文件的格式，枚举如下： 12345typedef NS_OPTIONS(NSUInteger, MPMovieMediaTypeMask) &#123; MPMovieMediaTypeMaskNone = 0,//格式未知 MPMovieMediaTypeMaskVideo = 1 &lt;&lt; 0,//音频格式 MPMovieMediaTypeMaskAudio = 1 &lt;&lt; 1//视频格式&#125;; @property (nonatomic) MPMovieSourceType movieSourceType; 视频的数据类型，枚举如下： 12345typedef NS_ENUM(NSInteger, MPMovieSourceType) &#123; MPMovieSourceTypeUnknown,//类型未知 MPMovieSourceTypeFile, // 文件类型 MPMovieSourceTypeStreaming // 数据流&#125;; @property (nonatomic, readonly) NSTimeInterval duration; 视频文件的时长 @property (nonatomic, readonly) NSTimeInterval playableDuration; 缓存完成能够播放的时长 @property (nonatomic, readonly) CGSize naturalSize; 视频的原始大小 @property (nonatomic) NSTimeInterval initialPlaybackTime; 播放器开始播放的时间 @property (nonatomic) NSTimeInterval endPlaybackTime; 播放器结束播放的时间 @property (nonatomic) BOOL allowsAirPlay; 是否允许云端播放 - (void)requestThumbnailImagesAtTimes:(NSArray *)playbackTimes timeOption:(MPMovieTimeOption)optio; 获取视频某一些时间点的缩略图，参数枚举如下，生成缩略图的数据回调在后面的通知中详说： 1234typedef NS_ENUM(NSInteger, MPMovieTimeOption) &#123; MPMovieTimeOptionNearestKeyFrame,//使用最近的关键帧生成缩略图 MPMovieTimeOptionExact//使用精确的当前帧生成缩略图&#125;; 与播放控制相关的方法如下： 1234567891011121314151617181920//调用这个方法进行播放视频的准备工作- (void)prepareToPlay;//获取播放器的准备工作是否就绪@property(nonatomic, readonly) BOOL isPreparedToPlay;//调用此方法进行视频的播放- (void)play;//调用此方法进行视频播放的暂停操作- (void)pause;//调用此方法停止视频播放- (void)stop;//当前视频已播放的时间@property(nonatomic) NSTimeInterval currentPlaybackTime;//当前视频的播放速度@property(nonatomic) float currentPlaybackRate;//调用此方法进行快进操作- (void)beginSeekingForward;//调用此方法进行快退操作- (void)beginSeekingBackward;//调用此方法结束快进或者快退操作- (void)endSeeking; 3、系统相关通知MPMoviePlayerController的系统回调并没有采用代理的设计模式，而是采用的系统发通知，我们注册观察者，接收我们需要的通知。举例几种常用通知如下： NSString * const MPMoviePlayerScalingModeDidChangeNotification; 播放器缩放产生改变时发送的通知 NSString * const MPMoviePlayerPlaybackDidFinishNotification; 播放结束时发送的通知 NSString * const MPMoviePlayerPlaybackStateDidChangeNotification; 播放状态改变时发送的通知 NSString * const MPMoviePlayerLoadStateDidChangeNotification; 缓冲状态改变时发送的通知 NSString * const MPMoviePlayerNowPlayingMovieDidChangeNotification; 当前播放的视频改变时发送的通知 NSString * const MPMoviePlayerWillEnterFullscreenNotification; 将要进入全屏模式时发送的通知 NSString * const MPMoviePlayerDidEnterFullscreenNotification; 已经进入全屏时发送的通知 NSString * const MPMoviePlayerWillExitFullscreenNotification; 将要退出全屏时发送的通知 NSString * const MPMoviePlayerDidExitFullscreenNotification; 已经退出全屏时发送的通知 NSString * const MPMoviePlayerThumbnailImageRequestDidFinishNotification; 获取缩略图完成时发送的通知 二、MPMoviePlayerViewController视频视图控制器如果你很熟悉MVC，你可能会觉得MPMoviePlayerController的设计模式非常蹩脚，强行要求你将控制器的视图分离出来加在另外的UI上，徒增的代码逻辑的混乱，那么你想的没错，MPMoviePlayerViewController可能就是为了解决这个问题。 MPMoviePlayerViewController将视图封装在了一起，其中有一个成员对象是MPMoviePlayerController类型，类似C++中的has-a逻辑，我们只需要对MPMoviePlayerViewController进行的简单的初始化后，对其中MPMoviePlayerController进行其他配置，之后通过模态跳转切换控制器即可。 方法如下： - (instancetype)initWithContentURL:(NSURL *)contentURL; 初始化方法，和上面类似 @property (nonatomic, readonly) MPMoviePlayerController *moviePlayer; 播放器对象 - (void)presentMoviePlayerViewControllerAnimated:(MPMoviePlayerViewController *)moviePlayerViewController; - (void)dismissMoviePlayerViewControllerAnimated; viewController的模态跳转方法，也可以通过导航push与pop 代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface ViewController2 ()@property(nonatomic,strong)MPMoviePlayerController * movie;@property(nonatomic,strong)MPMoviePlayerViewController * viewController;@end@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self playMovie:@&quot;111&quot;];&#125;-(void)playMovie:(NSString *)fileName&#123; //视频文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;mp4&quot;]; //视频URL NSURL *url = [NSURL fileURLWithPath:path]; //视频播放对象 _viewController = [[MPMoviePlayerViewController alloc]initWithContentURL:url]; _movie=_viewController.moviePlayer; // 注册一个播放结束的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(myMovieFinishedCallback:) name:MPMoviePlayerPlaybackDidFinishNotification object:_movie]; _movie.fullscreen=YES;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_movie play]; [self presentViewController:_viewController animated:YES completion:nil];&#125;-(void)myMovieFinishedCallback:(NSNotification*)notify&#123; //视频播放对象 MPMoviePlayerController* theMovie = [notify object]; //销毁播放通知 [[NSNotificationCenter defaultCenter] removeObserver:self name:MPMoviePlayerPlaybackDidFinishNotification object:theMovie]; [theMovie.view removeFromSuperview]; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C中runtime机制的应用","slug":"98Objective-C中runtime机制的应用","date":"2015-08-06T16:00:00.000Z","updated":"2021-07-01T07:20:43.324Z","comments":true,"path":"2015/08/07/98Objective-C中runtime机制的应用/","link":"","permalink":"http://huishao.cc/2015/08/07/98Objective-C中runtime机制的应用/","excerpt":"","text":"Objective-C中runtime机制的应用一、初识runtimeObjective-C是一种动态语言，所谓动态语言，是在程序执行时动态的确定变量类型，执行变量类型对应的方法的。因此，在Object-C中常用字符串映射类的技巧来动态创建类对象。因为OC的动态语言特性，我们可以通过一些手段，在程序运行时动态的更改对象的变量甚至方法，这就是我们所说的runtime机制。 二、你还有什么办法操作这样的变量么？首先，我们先来看一个例子，这里有我创建的一个MyObject类： 1234567891011121314151617181920212223242526272829303132//.h===========================@interface MyObject : NSObject&#123; @private int privateOne; NSString * privateTow;;&#125;@end//=============================//.m===========================@interface MyObject()&#123; @private NSString * privateThree;&#125;@end@implementation MyObject- (instancetype)init&#123; self = [super init]; if (self) &#123; privateOne=1; privateTow=@&quot;Tow&quot;; privateThree=@&quot;Three&quot;; &#125; return self;&#125;-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;one=%d\\ntow=%@\\nthree=%@\\n&quot;,privateOne,privateTow,privateThree];&#125;@end//============================= 这个类是相当的安全，首先，在头文件中没有提供任何的方法接口，我们没有办法使用点语法做任何操作，privateOne和PrivateTow两个变量虽然声明在了头文件中，却是私有类型的，通过指针的方式我们虽然可以看到他们，却不能做任何读取修改的操作，xcode中的提示如下： 他会告诉我们，这是一个私有的变量，我们不能使用。对于privateThree，我们更是束手无策，不仅不能使用，我们甚至都看不到它的存在。那么对于这种情况，你有什么办法操作这些变量么？对，是时候展现真正的技术了：runtime! 三、通过runtime获取对象的变量列表要操作对象的变量，我们首先应该要捕获这些变量，让他们无处遁形。无论声明在头文件或是实现文件，无论类型是公开的还是私有的，只要声明了这个变量，系统就会为其分配空间，我们就可以通过runtime机制捕获到它，代码如下： 123456789101112131415161718192021222324252627282930313233343536#import &quot;ViewController.h&quot;#import &quot;MyObject.h&quot;//包含runtime头文件#import &lt;objc/runtime.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //我们先声明一个unsigned int型的指针，并为其分配内存 unsigned int * count = malloc(sizeof(unsigned int)); //调用runtime的方法 //Ivar：方法返回的对象内容对象，这里将返回一个Ivar类型的指针 //class_copyIvarList方法可以捕获到类的所有变量，将变量的数量存在一个unsigned int的指针中 Ivar * mem = class_copyIvarList([MyObject class], count); //进行遍历 for (int i=0; i&lt; *count ; i++) &#123; //通过移动指针进行遍历 Ivar var = * (mem+i); //获取变量的名称 const char * name = ivar_getName(var); //获取变量的类型 const char * type = ivar_getTypeEncoding(var); NSLog(@&quot;%s:%s\\n&quot;,name,type); &#125; //释放内存 free(count); //注意处理野指针 count=nil;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 打印结果如下，其中i表示int型： 是不是小吃惊了一下，无论变量在哪里，只要它在，就让它无处遁形。 四、让我找到你，就让我改变你！仅仅能够获得变量的类型和名字或许并没有什么卵用，没错，我们获取变量的目的不是为了观赏，而是为了操作它，这对runtime来说，也是小事一碟。代码如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; //获取变量 unsigned int count; Ivar * mem = class_copyIvarList([MyObject class],&amp;count); //创建对象 MyObject * obj = [[MyObject alloc]init]; NSLog(@&quot;before runtime operate:%@&quot;,obj); //进行变量的设置 object_setIvar(obj, mem[0],10); object_setIvar(obj, mem[1], @&quot;isTow&quot;); object_setIvar(obj, mem[2], @&quot;isThree&quot;); NSLog(@&quot;after runtime operate:%@&quot;,obj); &#125; Tip:在修改int型变量的时候，你或许会遇到一个问题，ARC下，编译器不允许你将int类型的值赋值给id，在buildset中将Objective-C Automatic Reference Counting修改为No即可。 打印效果如下： 可以看到，那些看似非常安全的变量被我们修改了。 五、让我看看你的方法吧变量通过runtime机制我们可以取到和改变值，那么我们再大胆一点，试试那些私有的方法，首先我们在MyObject类中添加一些方法，我们只实现，并不声明他们： 1234567891011121314151617181920212223242526@interface MyObject()&#123; @private NSString * privateThree;&#125;@end@implementation MyObject- (instancetype)init&#123; self = [super init]; if (self) &#123; privateOne=1; privateTow=@&quot;Tow&quot;; privateThree=@&quot;Three&quot;; &#125; return self;&#125;-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;one=%d\\ntow=%@\\nthree=%@\\n&quot;,privateOne,privateTow,privateThree];&#125;-(NSString *)method1&#123; return @&quot;method1&quot;;&#125;-(NSString *)method2&#123; return @&quot;method2&quot;;&#125; 这样的方法我们在外面是无法调用他们的，和操作变量的思路一样，我们先要捕获这些方法： 12345678 //获取所有成员方法 Method * mem = class_copyMethodList([MyObject class], &amp;count); //遍历 for(int i=0;i&lt;count;i++)&#123; SEL name = method_getName(mem[i]); NSString * method = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@\\n&quot;,method); &#125; 打印如下： 得到了这些方法名，我们大胆的调用即可： 12 MyObject * obj = [[MyObject alloc]init]; NSLog(@&quot;%@&quot;,[obj method1]); Tip:这里编译器不会给我们方法提示，放心大胆的调用即可。 六、动态的为类添加方法这个runtime机制最强大的部分要到了，试想，如果我们可以动态的向类中添加方法，那将是一件多么令人激动的事情，注意，这里是动态的添加，和类别的最大不同在于这种方式是运行时才决定是否添加方法的。 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; //添加一个新的方法，第三个参数是返回值的类型v是void,i是int，：是SEL，对象是@等 class_addMethod([MyObject class], @selector(method3), (IMP)logHAHA, &quot;v&quot;); unsigned int count = 0; Method * mem = class_copyMethodList([MyObject class], &amp;count); for(int i=0;i&lt;count;i++)&#123; SEL name = method_getName(mem[i]); NSString * method = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@\\n&quot;,method); &#125; MyObject * obj = [[MyObject alloc]init]; //运行这个方法 [obj performSelector:@selector(method3)]; &#125;//方法的实现void logHAHA()&#123; NSLog(@&quot;HAHA&quot;);&#125; 运行结果如下： 从前五行可以看出，方法已经加进去了，从最后一行可以看出，执行没有问题。 七、做点小手脚程序员总是得寸进尺的，现在，我们要做点事情，用我们的函数替换掉类中的函数： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; MyObject * obj = [[MyObject alloc]init]; //替换之前的方法 NSLog(@&quot;%@&quot;, [obj method1]); //替换 class_replaceMethod([MyObject class], @selector(method1), (IMP)logHAHA, &quot;v&quot;); [obj method1]; &#125;void logHAHA()&#123; NSLog(@&quot;HAHA&quot;);&#125; 打印如下： 这次够cool吧，通过这个方法，我们可以把系统的函数都搞乱套。当然，runtime还有许多很cool的方法： id object_copy(id obj, size_t size) 拷贝一个对象 id object_dispose(id obj) 释放一个对象 const char *object_getClassName(id obj) 获取对象的类名 ive void method_exchangeImplementations(Method m1, Method m2)交换两个方法的实现 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Cocos2d-x-v3中3D网格特效动画的应用","slug":"97Cocos2d-x-v3中3D网格特效动画的应用","date":"2015-08-05T16:00:00.000Z","updated":"2021-07-01T07:14:42.655Z","comments":true,"path":"2015/08/06/97Cocos2d-x-v3中3D网格特效动画的应用/","link":"","permalink":"http://huishao.cc/2015/08/06/97Cocos2d-x-v3中3D网格特效动画的应用/","excerpt":"","text":"Cocos2d-x-v3中3D网格特效动画的应用一、网格特效的使用原理基础的动作是对节点整体进行移动，变形等操作，网格特效的原理是将节点分割成多个尺寸相同的网格，根据改变每个网格块的属性使整体节点产生3D的效果。 二、网格特效的基本用法在cocos2d-x中，v3的版本新引入了一个类NodeGrid，专门用来包装网格的特效，示例如下： 12345678910111213141516 //获取屏幕尺寸 Size visibleSize = Director::getInstance()-&gt;getVisibleSize(); Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin(); //加载精灵 auto sprite = Sprite::create(&quot;HelloWorld.png&quot;); sprite-&gt;setPosition(Vec2(visibleSize.width/2+origin.x, visibleSize.height/2+origin.y)); //创建网格特效包装类 NodeGrid * nodeg = NodeGrid::create(); nodeg-&gt;setPosition(Vec2::ZERO); //添加播放特效的精灵 nodeg-&gt;addChild(sprite); this-&gt;addChild(nodeg); //参数的含义 分别是 执行时间，切分的网格大小，波浪次数，波浪大小 Waves3D * ani3d = Waves3D::create(2, Size(15, 15), 6, 4); //执行特效 nodeg-&gt;runAction(ani3d); 三、系统提供的网格特效static Waves3D* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude); 创建波浪3D效果，参数含义为：执行时间，网格尺寸，波浪次数，波浪大小 static FlipX3D* create(float duration); 以x为轴进行翻转 static FlipY3D* create(float duration); 以y为轴进行翻转 static Lens3D* create(float duration, const Size&amp; gridSize, const Vec2&amp; position, float radius); 创建镜头的3D效果，参数为：执行时间，网格大小，镜头中心，镜头半径 static Ripple3D* create(float duration, const Size&amp; gridSize, const Vec2&amp; position, float radius, unsigned int waves, float amplitude); 创建波纹特效，参数为：执行时间，网格大小，波纹中心，波纹半径，波纹计数，振幅 static Shaky3D* create(float initWithDuration, const Size&amp; gridSize, int range, bool shakeZ); 创建震动特效，参数为：执行时间，网格大小，震动范围，是否波动z轴 static Liquid* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude); 创建液体特效，参数为：执行时间，网格尺寸，流动次数，幅度 static Waves* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical); 创建平面波纹特效，参数为：执行时间，网格尺寸，波纹次数，波纹振幅，开关横向波纹，开关纵向波纹 static Twirl* create(float duration, const Size&amp; gridSize, Vec2 position, unsigned int twirls, float amplitude);创建扭曲旋转的特效，参数为：执行时间，网格尺寸，扭曲旋转中心，旋转次数，旋转幅度 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Cocos2d-x-v3动作体系","slug":"95Cocos2d-x-v3动作体系","date":"2015-08-04T16:00:00.000Z","updated":"2021-06-30T11:57:44.554Z","comments":true,"path":"2015/08/05/95Cocos2d-x-v3动作体系/","link":"","permalink":"http://huishao.cc/2015/08/05/95Cocos2d-x-v3动作体系/","excerpt":"","text":"Cocos2d-x-v3动作体系cocos2d-x-v3版本v2的版本有的很大的改动，最直观的是在一些函数的改动和类名的改动上，首先以CC开头的类，都不再使用CC。在我个人的理解上，原来的cocos2d-x是完全从iphone的框架cocos2d移植过来的，代码的风格和编程的思想都及类似于Object-C，除了语法是C++的外，其他就像是OC版的翻译，新的版本更好的体现了跨平台的特性，也更多的运用了C++的一些编码思想和语言特点，更易于各平台的开发者使用。这篇博客的主要内容，是总结cocos2d中行为动作的处理方法和相关函数。 一、瞬时动作 这类行为只能称为动作，不能称作动画，其执行是瞬时的，没有可是化的过程。 cocos2d中常用的瞬时动作有如下几种： FlipX：关于x轴做镜像变换。 FlipY：关于y轴做镜像变换。 Hide：隐藏。 Show：显示。 ToggleVisibility：切换隐藏和显示。 Place：将对象放置在某个位置。 二、延时动作延时动作就是动画，将动作的过程展现出来，cocos2d引擎中的几种延时动作如下： 1\\. MoveTo:将对象移动到某一位置，是绝对位置，移动后不会记录对象的原始位置，动作不能进行反转。例如： 12auto action = MoveTo::create(2, Vec2(100, 100));//2S时间移动到(100,100) label-&gt;runAction(action);//执行动作 2.MoveBy:将对象相对现在的位置移动某个距离，这个移动是相对对象当前位置的，可以反转。 3.JumpTo:和MoveTo类似，对象跳动到某一位置，例如： 1label-&gt;runAction(JumpTo::create(2, Vec2(100, 100), 30, 3));//对象在2S内跳三次，每次高度为30像素，跳到(100,100)点 4.JumpBy:和MoveBy类似。 5.BezierTo:以贝塞尔曲线的方式移动到某一位置，例如： 123456ccBezierConfig config; config.controlPoint_1=Vec2(300, 300); config.controlPoint_2=Vec2(200,200); config.endPosition=Vec2(100, 100);//设置两个中间点和一个终点 label-&gt;runAction(BezierTo::create(2, config));//2S时间通过贝塞尔曲线方式移动 6.BezierBy:以贝塞尔曲线的方式进行相对移动。 7.ScaleTo:相对原始大小缩放到某一尺度。 8.ScaleBy:相对目前大小进行缩放。 9.RotateTo:相对原始状态旋转到某一角度。 10.RotateBy：相对目前转台旋转某个角度。 11.Blink:闪烁动画。 12.TintTo：颜色转化到某一色值 13.TintBy:相对目前色值，颜色相对转变某一色值。 14.FadeTo:变暗到某一透明度 15.FadeIn:淡入动作 16.FadeOut：淡出动作 三、动作的组合方式 cocos2d中不仅为我们提供的各种动作方式，也为我们提供了相关的类用于管理这些动作： 1.动作序列Sequence：这个类可以创建一个动作序列，按序列中动作的顺序依次执行动作，如下： 12 Sequence * sq= Sequence::create(TintTo::create(2, Color3B(123, 123, 123)),RotateTo::create(2, 30), NULL); label-&gt;runAction(sq);//创建动作序列，使对象执行先变颜色，在旋转的动画 2.同步动作组Spawn：这个类和Sequence类似，只是他里面的动画会同时一起执行。 3.有限次的循环动作Repeat：这个类可以使某一动作循环执行数次，例如： 12Repeat * re = Repeat::create(RotateBy::create(2, 30), 5);//旋转5次30度 label-&gt;runAction(re); 4.无限次循环动作RepeatForever： 12RepeatForever * ref = RepeatForever::create(RotateBy::create(2, 30)); label-&gt;runAction(ref); 5.帧动画 cocos2d中同样提供了对帧动画的支持： 12345678910111213141516 //创建设置精灵 Sprite * spr = Sprite::create( &quot;CloseNormal.png&quot;); spr-&gt;setPosition(Vec2(100, 100)); //创建两帧精灵图片 SpriteFrame * frame1 = SpriteFrame::create(&quot;CloseNormal.png&quot;, Rect(0, 0, 50, 50)); SpriteFrame * frame2 = SpriteFrame::create(&quot;CloseSelected.png&quot;, Rect(0, 0, 50, 50)); Vector&lt;SpriteFrame *&gt; arr; arr.pushBack(frame1); arr.pushBack(frame2); //创建动画体 第一个参数是帧容器，第二个是每一帧的播放时间，第三个是循环次数 Animation * ani = Animation::createWithSpriteFrames(arr, 1, 1); //创建动作 Animate *ant = Animate::create(ani); RepeatForever * ref = RepeatForever::create(ant); spr-&gt;runAction(ref); this-&gt;addChild(spr); 6.反转动画 可以通过reverse方法获取动作的反转动作，例如： 12345auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/arial.ttf&quot;, 24); MoveBy * move = MoveBy::create(3, Vec2(100, 100)); Sequence * sq = Sequence::create(move,move-&gt;reverse(), NULL); label-&gt;runAction(sq); //label 会先相对移动(100,100)，再反移动回来 7.动作的速度控制 通过一些速度相关的类，cocos2d可以很轻松的创建出各种线性与非线性的动作。例如： 12345auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/arial.ttf&quot;, 24); MoveTo * move = MoveTo::create(3, Vec2(-200, -200)); EaseIn* an = EaseIn::create(move, 5); label-&gt;runAction(an);//label的运动会先慢后快，速度差为5倍 EaseIn:由慢变快，线性 EaseOut：由快变慢，线性 EaseInOut：由慢变快再由快变慢 EaseSineIn:由慢变快，正弦规律 EaseSineOut:由快变慢，正弦规律 EaseSineInOut：由慢变快再由快变慢，正弦规律 EaseExponentialIn:由慢变快,指数规律 EaseExponentialOut:由快变慢,指数规律 EaseExponentialInOut:由慢变快再由快变慢,指数规律 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Xcode中修改变量名、类名及字符串的替换操作","slug":"94Xcode中修改变量名、类名及字符串的替换操作","date":"2015-08-04T16:00:00.000Z","updated":"2021-06-30T11:27:50.184Z","comments":true,"path":"2015/08/05/94Xcode中修改变量名、类名及字符串的替换操作/","link":"","permalink":"http://huishao.cc/2015/08/05/94Xcode中修改变量名、类名及字符串的替换操作/","excerpt":"","text":"Xcode中修改变量名、类名及字符串的替换操作在做iOS开发代码优化的工作时，优化代码结构之前，我们应该先整理好工程的外貌，将文件和类的命名进行规范，在Xcode中为我们提供了方便而强大的名称修改功能。 第一步：修改类名 将鼠标点击放在类的名称上，选择Xcode工具栏中的edit-&gt;refactor-&gt;rename： 之后，将类名更改为我们需要的模式点击preview，记得将下面的关联文件勾选： Xcode会为我们检测出需要更改的地方，浏览无误后点击save。 第二步 修改相关字符串： 通过第一步，我们的类的文件名，类名都已经更改，但并不全面，因为某些注释，字符串动态创建类对象以及类函数创建类对象时的类名并没有更改，我们需要做这一步，将更改前的类名在Xcode左侧的搜索栏中搜索： ![](http://static.oschina.net/uploads/space/2015/0805/093235_ZPfC_2340880.png) 将Find改选为Replace： 这里面有四个选项，意义如下： Containing:检索出包涵检索条件的对象 Matching:检索出等于检索条件的对象 Start With：检索出以检索条件开头的对象 Ending with:检索出以检索条件结尾的对象 我们选择Matching，进行检索，将检索出来的地方进行Replace替换，通过这一步，我们可以替换代码中的注释，字符串，类方法以及xib和StoryBoard文件中关联的id，cell复用符等。 第三步：修改文件中变量名 在文件中，我们也可以通过command+F换出搜索框，将Find改选为Replace检索进行我们想要的变量替换。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"Cocos2d-x-v3场景切换","slug":"96Cocos2d-x-v3场景切换","date":"2015-08-04T16:00:00.000Z","updated":"2021-07-01T06:51:02.057Z","comments":true,"path":"2015/08/05/96Cocos2d-x-v3场景切换/","link":"","permalink":"http://huishao.cc/2015/08/05/96Cocos2d-x-v3场景切换/","excerpt":"","text":"Cocos2d-x-v3场景切换cocos2d中场景的切换采用的是包装的思想，通过创建一个专场效果类，将需要专场的场景进行包装。代码示例如下： 12 auto * scene = OtherScene::createScene();//创建一个场景 Director::getInstance()-&gt;replaceScene(TransitionFlipX::create(1, scene));//进行包装切换，第一个参数为切换时间，第二个为切换的场景 引擎为我们封装的特效有很多，函数方法如下： static TransitionRotoZoom create(float t, Scene scene); 旧的场景旋转缩小到中心点后再将新的场景旋转放大完成切换 static TransitionJumpZoom create(float t, Scene scene); 旧场景弹跳缩小移出，新场景弹跳方法完成切换 static TransitionMoveInL create(float t, Scene scene); 新的场景从左边切入(覆盖) static TransitionMoveInR create(float t, Scene scene); 新的场景从右边切入(覆盖) static TransitionMoveInT create(float t, Scene scene); 新的场景从上边切入(覆盖) static TransitionMoveInB create(float t, Scene scene); 新的场景从下边切入(覆盖) static TransitionSlideInL create(float t, Scene scene); 新的场景从左边推入 static TransitionSlideInR create(float t, Scene scene); 新的场景从右边推入 static TransitionSlideInT create(float t, Scene scene); 新的场景从上边推入 static TransitionSlideInB create(float t, Scene scene); 新的场景从下边推入 static TransitionShrinkGrow create(float t, Scene scene); 新的场景从后向前进行替换 static TransitionFlipX create(float t, Scene s, Orientation o); 场景以X为轴进行翻转切换，第三个参数为翻转的方向 static TransitionFlipY create(float t, Scene s, Orientation o); 场景以Y为轴进行翻转切换，第三个参数为翻转的方向 static TransitionFlipAngular create(float t, Scene s, Orientation o); 场景以对角线为轴进行翻转切换，第三个参数为翻转的方向 static TransitionZoomFlipX create(float t, Scene s, Orientation o); 场景以X轴进行翻转，带缩放效果 static TransitionZoomFlipY create(float t, Scene s, Orientation o); 场景以Y轴进行翻转，带缩放效果 static TransitionZoomFlipAngular create(float t, Scene s, Orientation o); 场景以对角线为轴进行翻转，带缩放效果 static TransitionFade create(float duration, Scene scene, const Color3B&amp; color); 场景以颜色过渡进行切换 static TransitionCrossFade create(float t, Scene scene); 场景淡出过渡切换 static TransitionTurnOffTiles create(float t, Scene scene); 场景瓦片溶解切换 static TransitionSplitCols create(float t, Scene scene); 场景纵向切割切换 static TransitionSplitRows create(float t, Scene scene); 场景横向切割切换 static TransitionFadeTR create(float t, Scene scene); 场景向右上角过滤切换 static TransitionFadeBL create(float t, Scene scene); 场景向左下角过滤切换 static TransitionFadeUp create(float t, Scene scene); 场景向上过滤切换 static TransitionFadeDown create(float t, Scene scene); 场景向下过滤切换 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Cocos2d-x-v3坐标体系","slug":"93Cocos2d-x-v3坐标体系","date":"2015-08-02T16:00:00.000Z","updated":"2021-06-30T11:25:57.887Z","comments":true,"path":"2015/08/03/93Cocos2d-x-v3坐标体系/","link":"","permalink":"http://huishao.cc/2015/08/03/93Cocos2d-x-v3坐标体系/","excerpt":"","text":"Cocos2d-x坐标体系cocos2d引擎是一款非常优秀的扩平台的游戏开发引擎，在apple游戏榜上，有很多排名靠前的游戏都是由他创造出来的，他也有一套十分方便的坐标体系。 一、UI坐标体系UI坐标体系相对于移动开发人员来说再熟悉不过了，在iOS系统中，它就是frame体系，即坐标(0,0)点位于屏幕的左上角，向右x增大，向下y增大。 二、OpenGL坐标体系OpenGL坐标系是cocos2d中使用的坐标系，它更接近于数学上的坐标系，即(0,0)点位于屏幕的左下角，往左x增大，往上y增大。这套坐标系统也更符合物理世界的逻辑，便于游戏的开发。当然，这并不是说cocos2d中所有的坐标都是采用这个体系标准的，在手指点击事件层，接收到点击坐标点的坐标就是采用UI坐标系表示的。 三、世界坐标系简单的理解，世界坐标系就是绝对坐标系，在cocos2d中，精灵的坐标是相对于其父视图而言的，是相对的坐标，世界坐标则是统一绝对的坐标，在项目中是固定的。 四、相对坐标系最常用的坐标体系，任何类设置的坐标都是相对于其父视图原点的坐标。 五、坐标系的转换由于UI坐标系与OpenGL坐标系的差异，在开发中，我们有时需要其两个标准的相互转化，cocos2d中也未我们提供了相应的方法： Vec2 Director::convertToGL(const Vec2&amp; uiPoint); 这个方法将UI坐标系转换为OpenGL坐标系。 Vec2 Director::convertToUI(const Vec2&amp; glPoint); 这个方法将OpenGL坐标系转换为UI坐标系。 Vec2 Node::convertToWorldSpace(const Vec2&amp; nodePoint) const; 这个方法将物体的相对坐标 Vec2 Node::convertToNodeSpace(const Vec2&amp; worldPoint) const; 这个方法将世界坐标转化为某一节点的相对坐标。 还有两个转化的方法与上面类似，只有一点不同，这两个方法参照的原点不是系统默认的，而是我们设置的节点的锚点： Vec2 Node::convertToNodeSpaceAR(const Vec2&amp; worldPoint) const; Vec2 Node::convertToWorldSpaceAR(const Vec2&amp; nodePoint) const; 六、锚点锚点的概念可以理解为参照点，其设置范围为0-1，系统默认的节点锚点为(0,0)。在UI坐标系中，(0,0)点就是节点的左上角，在OpenGL坐标系中，(0,0)点就是节点的左下角。例如，如果我将锚点设置为(0.5,0.5),则在UI和OpenGL坐标系中，(0,0)点都是节点的中心点。又如，我将锚点设置为(1,1)，则在UI坐标系中，原点为右下角，在OpenGL坐标系中，原点为右上角，锚点的用处就是更改参考点，在另一种情形下，锚点对程序也会产生很大的影响，就是当我们设置一个节点旋转或者缩放时，节点会以锚点位置为中心进行旋转或缩放。 cocos2d中通过下面方法分别来设置和获取锚点： void Sprite::setAnchorPoint(const Vec2&amp; anchor); 设置锚点 const Vec2&amp; Node::getAnchorPoint() const; 获取锚点 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"iOS8新特性扩展(Extension)应用之四——自定义键盘控件","slug":"92iOS8新特性扩展(Extension)应用之四——自定义键盘控件","date":"2015-07-30T16:00:00.000Z","updated":"2021-06-30T11:23:25.803Z","comments":true,"path":"2015/07/31/92iOS8新特性扩展(Extension)应用之四——自定义键盘控件/","link":"","permalink":"http://huishao.cc/2015/07/31/92iOS8新特性扩展(Extension)应用之四——自定义键盘控件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之四——自定义键盘控件iOS8系统的开放第三方键盘，使得用户在输入法的选择上更加自主灵活，也更加贴近不同语言的输入风格。这篇博客，将介绍如何开发一个第三方的键盘控件。 一、了解UIInputViewController类UIInputViewController是系统扩展支持键盘扩展的一个类，通过这个类，我们可以自定义一款我们自己的键盘提供给系统使用。 首先，我们先来看一下这个类中的一些属性和方法： @property (nonatomic, retain) UIInputView *inputView; 键盘的输入视图，我们可以自定义这个视图。 @property (nonatomic, readonly) NSObject *textDocumentProxy; 实现了UITextDocumentProxy协议的一个对象，后面会介绍这个协议。 @property (nonatomic, copy) NSString *primaryLanguage; 系统为我们准备了一些本地化的语言字符串 - (void)dismissKeyboard; 收键盘的方法 - (void)advanceToNextInputMode; 切换到下一输入法的方法 UITextDocumentProxy协议内容如下： 123456789@protocol UITextDocumentProxy &lt;UIKeyInput&gt;//输入的上一个字符@property (nonatomic, readonly) NSString *documentContextBeforeInput;//即将输入的一个字符@property (nonatomic, readonly) NSString *documentContextAfterInput;//将输入的字符移动到某一位置- (void)adjustTextPositionByCharacterOffset:(NSInteger)offset;@end 而UITextDocumentProxy这个协议继承与UIKeyInput协议，UIKeyInput协议中提供的两个方法用于输入字符和删除字符： - (void)insertText:(NSString *)text;- (void)deleteBackward; 二、创建一款最简单的数字输入键盘创建一个项目，作为宿主APP，接着我们File-&gt;new-&gt;target-&gt;customKeyBoard: 系统要求我们对键盘的布局要使用autolayout，并且只可以采用代码布局的方式，我们这里为了简单演示，将坐标写死： 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)viewDidLoad &#123; [super viewDidLoad]; // 设置数字键盘的UI //数字按钮布局 for (int i=0; i&lt;10; i++) &#123; UIButton * btn = [UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20+45*(i%3), 20+45*(i/3), 40, 40); btn.backgroundColor=[UIColor greenColor]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,i] forState:UIControlStateNormal]; btn.tag=101+i; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; &#125; //创建切换键盘按钮 UIButton * change = [UIButton buttonWithType:UIButtonTypeSystem]; change.frame=CGRectMake(200,20, 80, 40) ; NSLog(@&quot;%f,%f&quot;,self.view.frame.size.height,self.view.frame.size.width); [change setBackgroundColor:[UIColor blueColor]]; [change setTitle:@&quot;切换键盘&quot; forState:UIControlStateNormal]; [change addTarget:self action:@selector(change) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:change]; //创建删除按钮 UIButton * delete = [UIButton buttonWithType:UIButtonTypeSystem]; delete.frame=CGRectMake(200, 120, 80, 40); [delete setTitle:@&quot;delete&quot; forState:UIControlStateNormal]; [delete setBackgroundColor:[UIColor redColor]]; [delete addTarget:self action:@selector(delete) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:delete];&#125;//删除方法-(void)delete&#123; if (self.textDocumentProxy.documentContextBeforeInput) &#123; [self.textDocumentProxy deleteBackward]; &#125;&#125;//切换键盘方法-(void)change&#123; [self advanceToNextInputMode];&#125;//点击数字按钮 将相应数字输入-(void)click:(UIButton *)btn&#123; [self.textDocumentProxy insertText:[NSString stringWithFormat:@&quot;%ld&quot;,btn.tag-101]];&#125; 运行后，在使用之前，我们需要先加入这个键盘：在模拟器系统设置中general-&gt;keyboard-&gt;keyboards-&gt;addNowKeyboard 选中我们自定义的键盘，之后运行浏览器，切换到我们的键盘，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之三——照片编辑插件","slug":"91iOS8新特性扩展(Extension)应用之三——照片编辑插件","date":"2015-07-29T16:00:00.000Z","updated":"2021-06-30T11:20:59.694Z","comments":true,"path":"2015/07/30/91iOS8新特性扩展(Extension)应用之三——照片编辑插件/","link":"","permalink":"http://huishao.cc/2015/07/30/91iOS8新特性扩展(Extension)应用之三——照片编辑插件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之三——照片编辑插件 通过前几篇博客的介绍，我们了解到扩展给app提供的更加强大的交互能力，这种强大的交互能力另一方面体现在照片编辑插件的应用。 和通常一样，我们先创建一个工程，然后新建一个Target，选择photo editing： 从模板中，我们可以看到系统为我们创建了一个controller，这个controller就是用于处理照片的controller，其中方法如下： 123456789101112131415161718192021222324252627282930- (BOOL)canHandleAdjustmentData:(PHAdjustmentData *)adjustmentData &#123; // Inspect the adjustmentData to determine whether your extension can work with past edits. // (Typically, you use its formatIdentifier and formatVersion properties to do this.) return NO;&#125;//这个函数用于从系统相册获取到选中的照片，contentEditingInput对象中存有响应的数据类型和image对象- (void)startContentEditingWithInput:(PHContentEditingInput *)contentEditingInput placeholderImage:(UIImage *)placeholderImage &#123; //我们可以在这里将取到的数据进行展示等等 self.input = contentEditingInput;&#125;//结束编辑照片时的方法- (void)finishContentEditingWithCompletionHandler:(void (^)(PHContentEditingOutput *))completionHandler &#123; // Update UI to reflect that editing has finished and output is being rendered. // Render and provide output on a background queue. dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // Create editing output from the editing input. PHContentEditingOutput *output = [[PHContentEditingOutput alloc] initWithContentEditingInput:self.input]; //我们可以在这里将新的图片数据写入到输出流中 // output.adjustmentData = &lt;#new adjustment data#&gt;; // NSData *renderedJPEGData = &lt;#output JPEG#&gt;; // [renderedJPEGData writeToURL:output.renderedContentURL atomically:YES]; // Call completion handler to commit edit to Photos. completionHandler(output); // Clean up temporary files, etc. &#125;);&#125; 在当前扩展执行结束编辑之前，我们可以自由渲染我们得到的图片，例如添加相框，文字等等，输出时将渲染后的图片进行输出即可。 这里还有一个地方需要我们注意，此类扩展有一个功能，如果我们中途退出编辑，系统会为我们保存我们扩展的处理状态，为了区分多个类似功能的扩展，在输出数据的对象中有一个PHAdjustmentData类型的对象，这个对象专门用于负责版本的记录，这个对象中有如下两个属性用于区分版本： @property (readonly, copy) NSString *formatIdentifier; @property (readonly, copy) NSString *formatVersion; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之二——分享插件","slug":"90iOS8新特性扩展(Extension)应用之二——分享插件","date":"2015-07-29T16:00:00.000Z","updated":"2021-06-30T11:17:41.233Z","comments":true,"path":"2015/07/30/90iOS8新特性扩展(Extension)应用之二——分享插件/","link":"","permalink":"http://huishao.cc/2015/07/30/90iOS8新特性扩展(Extension)应用之二——分享插件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之二——分享插件 在上一篇博客中，介绍了iOS8新特性扩展功能之一的Today功能：[http://my.oschina.net/u/2340880/blog/485533](http://my.oschina.net/u/2340880/blog/485533)，这里我们再介绍一下分享的扩展功能。 在iOS8之前，除了一些主流的社交平台，例如苹果支持内容分享外，其他开发者的应用若要加入分享的功能，将会十分的复杂。在iOS8的新特性中，apple为我们准备了这样的扩展功能。 首先创建工程，在我们的工程中新建一个Target： 之后，模板中会为我们创建一个controller类，这个controller用于控制我们的分享插件，里面内容： 1234567891011121314151617181920@implementation ShareViewController//这个函数用于判断分享内容的可用性，我们在其中获取分享的内容进行检查- (BOOL)isContentValid &#123; // Do validation of contentText and/or NSExtensionContext attachments here return YES;&#125;//点击post按钮后出发的方法，我们可以在这里将分享的内容进行上传等操作- (void)didSelectPost &#123; // This is called after the user selects Post. Do the upload of contentText and/or NSExtensionContext attachments. // Inform the host that we&apos;re done, so it un-blocks its UI. Note: Alternatively you could call super&apos;s -didSelectPost, which will similarly complete the extension context. [self.extensionContext completeRequestReturningItems:@[] completionHandler:nil];&#125;//这里用于设置分享插件的附件按钮- (NSArray *)configurationItems &#123; // To add configuration options via table cells at the bottom of the sheet, return an array of SLComposeSheetConfigurationItem here. return @[];&#125;@end 除此之外，还有一些常用的属性： - (void)presentationAnimationDidFinish; 弹出视图动画结束后执行的方法 @property (readonly, NS_NONATOMIC_IOSONLY) NSString *contentText; 分享的内容文字 @property (copy, NS_NONATOMIC_IOSONLY) NSString *placeholder; 默认显示的提示文字 - (void)didSelectCancel; 取消按钮执行的方法 我们在代码中如下添加后运行： 1234567891011@implementation ShareViewController-(NSString *)placeholder&#123; return @&quot;提示文字&quot;;&#125;- (NSArray *)configurationItems &#123; // To add configuration options via table cells at the bottom of the sheet, return an array of SLComposeSheetConfigurationItem here. SLComposeSheetConfigurationItem * item =[[SLComposeSheetConfigurationItem alloc]init]; item.title=@&quot;地点&quot;; item.value=@&quot;城门&quot;; return @[item];&#125; 我们用系统的相册做测试，点击相片的分享按钮： 点击MORE，添加我们的扩展插件。 这时分享栏中多了一个我们的插件，点击效果如下： 还有一点我们需要了解，在这个扩展的plist文件中，有这样一个键：NSExtensionAttributes，里面有一个NSExtensionActivationRule的字典，其中可以设置一些键值，对分享插件的属性进行控制。 这些键的写法在官方文档中的介绍如下： 这些键的意义，文档中介绍的很清楚，我们可以根据需要进行设置。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之一——Today扩展","slug":"89iOS8新特性扩展(Extension)应用之一——Today扩展","date":"2015-07-29T16:00:00.000Z","updated":"2021-06-30T11:16:34.998Z","comments":true,"path":"2015/07/30/89iOS8新特性扩展(Extension)应用之一——Today扩展/","link":"","permalink":"http://huishao.cc/2015/07/30/89iOS8新特性扩展(Extension)应用之一——Today扩展/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之一——Today扩展一、理解扩展1、简介基于iOS系统的安全性考虑，其应用的数据存储是通过沙盒模式进行的，要实现应用之间的数据共享十分困难，功能共享就更加棘手。在iOS8系统中，apple为我们提供了一个革命性的功能：扩展。我们可以通过扩展来使app间数据甚至功能进行共享。 2、几种扩展模式（1）今日视图扩展:today这个扩展也被叫做 widget。该扩展可以将今日发生的简短消息放到消息中心的「今日」视图里。这个功能类似于安卓系统中的小控件，只是安卓的可以直接放在桌面上，更加自由。示例如下： （2）分享功能扩展该扩展允许应用向在线服务上传照片、链接或者其他文件。在以前版本中，我们若要实现分享功能，必须进行复杂的操作。 （3）个性操作通过这个功能，可以实现两个APP中共享一些内容，例如编辑文字中的图片，翻译网页中的文字。 （4）照片操作这个类型的扩展可以允许我们在ipone相机中拍摄的照片使用其他图片编辑软件进行编辑。 （5）文件分享该扩展可以让软件将文件保存在各种云存储服务商。 （6）自定义键盘允许用户使用第三方的键盘输入法。 二、ToDay扩展的创建扩展是一个独立的构成，和其有关的两个概念是宿主APP和主机APP，宿主APP是扩展存放的地方，与扩展可以实现资源共享，主机APP是扩展运行的程序，例如ToDay扩展有抽屉中的Today应用进行运行。要创建一个ToDay扩展，首先我们需要创建一个宿主APP： 新建一个工程： 选择xcode工具栏中的File-&gt;new-&gt;target 在Application Extension中有上面提到的6中扩展，我们选择Today。 这是我们的项目中会多了一个扩展的文件夹： 这个文件夹中有一个ViewController，我们可以在里面进行布局，还有一个plist文件，可是配置扩展的一些属性。 我们创建一个按钮： 123 UIButton * btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 30)]; [btn setTitle:@&quot;231&quot; forState:UIControlStateNormal]; [self.view addSubview:btn]; 之后我们运行这个扩展： xcode会让我们选择运行扩展的主机程序，因为这是一个today类型的扩展，我们选择Today： 运行后，在系统的通知抽屉中，就会出现我们的这个扩展： 同样，我们可以创建tableView，imageView以及其他复杂的视图效果，我们也可以编写很多逻辑功能，跳转APP等。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之五——炫酷的粒子效果","slug":"88iOS动画开发之五——炫酷的粒子效果","date":"2015-07-28T16:00:00.000Z","updated":"2021-06-30T11:15:00.406Z","comments":true,"path":"2015/07/29/88iOS动画开发之五——炫酷的粒子效果/","link":"","permalink":"http://huishao.cc/2015/07/29/88iOS动画开发之五——炫酷的粒子效果/","excerpt":"","text":"iOS动画开发之五——炫酷的粒子效果在上几篇博客中，我们对UIView层的动画以及iOS的核心动画做了介绍，基本已经可以满足iOS应用项目中所有的动画需求，如果你觉得那些都还不够炫酷，亦或是你灵光一现，想用UIKit框架写出一款炫酷的休闲游戏，那个有一个东西可以帮到你：iOS的粒子效果引擎。 一、粒子发射器iOS中的粒子效果有两部分组成，一部分为发射器，设置例子发射的宏观属性，另一部分是粒子单元，用于设置相应的粒子属性。粒子发射器是基于Layer层，没错，又是Layer，他的全名叫做： CAEmitterLayer。其中常用的属性如下： @property(copy) NSArray *emitterCells; 粒子单元数组，例如你在绘制火焰的效果时，你可以创建两个单元，一个单元负责烟雾，一个单元负责火苗。 @property float birthRate; 粒子的创建速率，默认为1/s。 @property float lifetime; 粒子的存活时间。默认为1S。 @property CGPoint emitterPosition; 发射器在xy平面的中心位置 @property CGFloat emitterZPosition; 发射器在Z平面的位置 @property CGSize emitterSize; 发射器的尺寸大小 @property CGFloat emitterDepth; 发射器的深度，在某些模式下会产生立体效果 @property(copy) NSString *emitterShape; 发射器的形状，这个参数的几个系统字符串如下： 123456789101112CA_EXTERN NSString * const kCAEmitterLayerPoint __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0); //点的形状，粒子从一个点发出CA_EXTERN NSString * const kCAEmitterLayerLine __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//线的形状，粒子从一条线发出CA_EXTERN NSString * const kCAEmitterLayerRectangle __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//矩形形状，粒子从一个矩形中发出CA_EXTERN NSString * const kCAEmitterLayerCuboid __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//立方体形状，会影响Z平面的效果CA_EXTERN NSString * const kCAEmitterLayerCircle __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//圆形，粒子会在圆形范围发射CA_EXTERN NSString * const kCAEmitterLayerSphere __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//球型 @property(copy) NSString *emitterMode; 发射器的发射模式，参数如下： 12345678CA_EXTERN NSString * const kCAEmitterLayerPoints __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器中发出CA_EXTERN NSString * const kCAEmitterLayerOutline __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器边缘发出CA_EXTERN NSString * const kCAEmitterLayerSurface __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器表面发出CA_EXTERN NSString * const kCAEmitterLayerVolume __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器中点发出 @property(copy) NSString *renderMode; 发射器渲染模式，参数如下： 12345678910CA_EXTERN NSString * const kCAEmitterLayerUnordered __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，粒子是无序出现的，多个发射源将混合CA_EXTERN NSString * const kCAEmitterLayerOldestFirst __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，声明久的粒子会被渲染在最上层CA_EXTERN NSString * const kCAEmitterLayerOldestLast __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，年轻的粒子会被渲染在最上层CA_EXTERN NSString * const kCAEmitterLayerBackToFront __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，粒子的渲染按照Z轴的前后顺序进行CA_EXTERN NSString * const kCAEmitterLayerAdditive __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式会进行粒子混合 @property BOOL preservesDepth; 是否开启三维空间效果 @property float velocity; 粒子的运动速度 @property float scale; 粒子的缩放大小 @property float spin; 粒子的旋转位置 @property unsigned int seed; 初始化随机的粒子种子 二、粒子单元设置好了粒子发射器，我们还需要初始化一些粒子单元，设置具体粒子的属性，我们使用到的类是CAEmitterCell这个类。 + (instancetype)emitterCell; 类方法创建发射单元 @property(copy) NSString *name; 设置发射单元的名称 @property(getter=isEnabled) BOOL enabled; 是否允许发射器渲染 @property float birthRate; 粒子的创建速率 @property float lifetime; 粒子的生存时间 @property float lifetimeRange; 粒子的生存时间容差 @property CGFloat emissionLatitude; 粒子在Z轴方向的发射角度 @property CGFloat emissionLongitude; 粒子在xy平面的发射角度 @property CGFloat emissionRange; 粒子发射角度的容差 @property CGFloat velocity; 粒子的速度 @property CGFloat velocityRange; 粒子速度的容差 @property CGFloat xAcceleration; @property CGFloat yAcceleration; @property CGFloat zAcceleration; x，y，z三个方向的加速度 @property CGFloat scale; @property CGFloat scaleRange; @property CGFloat scaleSpeed; 缩放大小，缩放容差和缩放速度 @property CGFloat spin; @property CGFloat spinRange; 旋转度与旋转容差 @property CGColorRef color; 粒子的颜色 @property float redRange; @property float greenRange; @property float blueRange; @property float alphaRange; 粒子在rgb三个色相上的容差和透明度的容差 @property float redSpeed; @property float greenSpeed; @property float blueSpeed; @property float alphaSpeed; 粒子在RGB三个色相上的变化速度和透明度的变化速度 @property(strong) id contents; 渲染粒子，可以设置为一个CGImage的对象 @property CGRect contentsRect; 渲染的范围 三、让我们来“火”一把通过上面的介绍，我们来应用这些创造一团火，代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@interface ViewController ()&#123; CAEmitterLayer * _fireEmitter;//发射器对象&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.view.backgroundColor=[UIColor blackColor]; //设置发射器 _fireEmitter=[[CAEmitterLayer alloc]init]; _fireEmitter.emitterPosition=CGPointMake(self.view.frame.size.width/2,self.view.frame.size.height-20); _fireEmitter.emitterSize=CGSizeMake(self.view.frame.size.width-100, 20); _fireEmitter.renderMode = kCAEmitterLayerAdditive; //发射单元 //火焰 CAEmitterCell * fire = [CAEmitterCell emitterCell]; fire.birthRate=800; fire.lifetime=2.0; fire.lifetimeRange=1.5; fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor]; fire.contents=(id)[[UIImage imageNamed:@&quot;Particles_fire.png&quot;]CGImage]; [fire setName:@&quot;fire&quot;]; fire.velocity=160; fire.velocityRange=80; fire.emissionLongitude=M_PI+M_PI_2; fire.emissionRange=M_PI_2; fire.scaleSpeed=0.3; fire.spin=0.2; //烟雾 CAEmitterCell * smoke = [CAEmitterCell emitterCell]; smoke.birthRate=400; smoke.lifetime=3.0; smoke.lifetimeRange=1.5; smoke.color=[[UIColor colorWithRed:1 green:1 blue:1 alpha:0.05]CGColor]; smoke.contents=(id)[[UIImage imageNamed:@&quot;Particles_fire.png&quot;]CGImage]; [fire setName:@&quot;smoke&quot;]; smoke.velocity=250; smoke.velocityRange=100; smoke.emissionLongitude=M_PI+M_PI_2; smoke.emissionRange=M_PI_2; _fireEmitter.emitterCells=[NSArray arrayWithObjects:smoke,fire,nil]; [self.view.layer addSublayer:_fireEmitter]; &#125; 效果如下： 看到效果了么？这次够炫酷了吧，改改其它属性，尽情的玩吧！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之四——核心动画编程(CoreAnimation)","slug":"87iOS动画开发之四——核心动画编程(CoreAnimation)","date":"2015-07-27T16:00:00.000Z","updated":"2021-06-30T11:13:16.770Z","comments":true,"path":"2015/07/28/87iOS动画开发之四——核心动画编程(CoreAnimation)/","link":"","permalink":"http://huishao.cc/2015/07/28/87iOS动画开发之四——核心动画编程(CoreAnimation)/","excerpt":"","text":"iOS动画开发之四——核心动画编程(CoreAnimation)一、引言前几篇博客详细介绍了有关UIView层的动画使用与相关的效果，然而这些动画是UIKit为我们封装好的核心动画层的方法，通过这些方法，我们可以用的更加简便，当然功能也十分强大，基本能达到我们项目的大多需求。但是如果你想更加自由的通过动画操作视图的属性，你就需要跳过UIKit的封装，使用CoreAnimation核心动画层的方法来实现动画。 二、开始前的准备1、认识一个的朋友在开始介绍核心动画的内容前，我们需要先搞明白一个东西：Layer。你可能很少听说他，可是他却无处不在，在iOS的UI开发中，任何一个View包括继承于UIView的子类上面都会有一个Layer，可以理解为Layer为单独的一层，专门负责视图的显示，而view除此之外更多负责触摸时间等逻辑处理。因此，iOS也将所有动画的操作都交给你Layer来负责。 2、Layer层可以做到的事Layer如此神秘，那他究竟可以做到哪些事？他确实可以做很多view做不了的事情. (1)设置view的圆角属性12345 view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; view.layer.masksToBounds=YES;//设置layer层的切割属性 view.layer.cornerRadius=10;//设置layer层的圆角半径 效果如下： (2)设置view的边框123456view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; CALayer *layer=view.layer; layer.borderWidth=10;//设置边框的宽度 layer.borderColor=[[UIColor magentaColor]CGColor];//设置边框的颜色 注意：因为CoreAnimation层是UI层的底层，所以这里的颜色为CGColor对象。 效果如下： (3)设置视图阴影12345678 view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; CALayer *layer=view.layer; layer.shadowOffset=CGSizeMake(30, 30);//设置阴影方向 layer.shadowColor=[[UIColor blackColor] CGColor];//设置阴影颜色 layer.shadowOpacity=0.5;//设置阴影透明度 layer.shadowRadius=10;//设置阴影圆角 效果如下： 这样的立体效果是否已经很酷了？NO，在加上动画才对。 三、CoreAnimation的使用1、基础属性相关的动画CABasicAnimationCABasicAnimation是核心动画中对属性操作需要用到了一个动画类，示例如下： 1234567 CALayer *layer=view.layer; CABasicAnimation * ani= [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];//创建对象，参数关键字为layer的属性 ani.duration=3;//设置执行时间 ani.repeatCount=1;//设置执行次数 ani.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];//设置线性效果 [layer addAnimation:ani forKey:@&quot;test&quot;];//添加动画 layer.opacity=0;//透明度改变时执行动画动作 通过上面的示例，我们可以发现，layer的属性都可以来进行动画动作，这样，我们对动画的操作就自由的很多。 2、关键帧动画CAKeyframeAnimation关键帧动画除了动画改变layer的属性外，可以设置几个关键帧点，通过这些点，可以实现路径更加负责的动画，例如： 12345CALayer *layer=view.layer; CAKeyframeAnimation * ani = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];//创建一个关键帧动画对象 ani.duration=3; ani.values=@[@1,@0,@1];//传入三个关键帧，动画会将试图先慢慢隐藏，再慢慢展现 [layer addAnimation:ani forKey:@&quot;test&quot;]; 类比如上代码，我们还可以通过关键帧让试图按照我们预定的路线移动，同时我们还可以设置两个数组，分别为keyTimes和timingFunctions。这两个数组中的值可以设置动画每一段的运动线性特征和每一段的运动时间比例。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之二——UIView动画执行的另一种方式","slug":"85iOS动画开发之二——UIView动画执行的另一种方式","date":"2015-07-27T16:00:00.000Z","updated":"2021-06-30T11:10:14.027Z","comments":true,"path":"2015/07/28/85iOS动画开发之二——UIView动画执行的另一种方式/","link":"","permalink":"http://huishao.cc/2015/07/28/85iOS动画开发之二——UIView动画执行的另一种方式/","excerpt":"","text":"iOS动画开发之二——UIView动画执行的另一种方式 上一篇博客中介绍了UIView的一些常用动画，通过block块，我们可以很方便简洁的创建出动画效果：[http://my.oschina.net/u/2340880/blog/484457](http://my.oschina.net/u/2340880/blog/484457)，这篇博客再介绍一种更加传统的执行UIView的动画的方法。 这种方式相比如block的方式，显得要麻烦一些，apple官方也推荐我们使用带block的创建动画的方式，我们可以将编程重心更多的放在动画逻辑的实现上。使用begin和commit方式主要分为三个步骤： 一、设置动画开始 1[UIView beginAnimations:@&quot;test&quot; context:nil]; 这个函数中的两个参数，第一个用于设置一个动画的标识id，通常第二个参数写为nil。 二、动画执行的参数设置 + (void)setAnimationDelegate:(id)delegate; 设置这个动画的代理，用于执行动画开始或者结束后的动作 + (void)setAnimationWillStartSelector:(SEL)selector; 设置动画开始时执行的回调 + (void)setAnimationDidStopSelector:(SEL)selector; 设置动画结束后执行的回调 + (void)setAnimationDuration:(NSTimeInterval)duration; 设置动画执行的时间 + (void)setAnimationDelay:(NSTimeInterval)delay; 设置延时执行的延时 + (void)setAnimationStartDate:(NSDate *)startDate; 给动画设置一个启示时间 + (void)setAnimationCurve:(UIViewAnimationCurve)curve; 设置动画播放的线性效果，UIViewAnimationCurve的枚举如下： 123456typedef NS_ENUM(NSInteger, UIViewAnimationCurve) &#123; UIViewAnimationCurveEaseInOut, // 淡入淡出 UIViewAnimationCurveEaseIn, // 淡入 UIViewAnimationCurveEaseOut, // 淡出 UIViewAnimationCurveLinear //线性&#125; + (void)setAnimationRepeatCount:(float)repeatCount; 设置动画循环播放次数 + (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses; 设置动画逆向执行 三、提交动画 + (void)commitAnimations; 例如： 1234567UIView * view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; [UIView beginAnimations:@&quot;test&quot; context:nil]; [UIView setAnimationDuration:3]; view.backgroundColor=[UIColor orangeColor]; [UIView commitAnimations];//执行commit后，动画即开始执行 一点建议：这种创建UIView动画的方式和上一篇博客中的block方式效果相同，然而效率并不高，写的代码也会繁琐冗长，在开发中，如果没有特殊的兼容要求，使用block的方式会更高效方便。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之三——UIView的转场切换","slug":"86iOS动画开发之三——UIView的转场切换","date":"2015-07-27T16:00:00.000Z","updated":"2021-06-30T11:12:12.076Z","comments":true,"path":"2015/07/28/86iOS动画开发之三——UIView的转场切换/","link":"","permalink":"http://huishao.cc/2015/07/28/86iOS动画开发之三——UIView的转场切换/","excerpt":"","text":"iOS动画开发之三——UIView的转场切换前两篇博客中，我们分别介绍了UIView动画的两种使用方式，分别为，带block的方式：[**http://my.oschina.net/u/2340880/blog/484457**](http://my.oschina.net/u/2340880/blog/484457) ,传统的属性配置的方式：[http://my.oschina.net/u/2340880/blog/484538](http://my.oschina.net/u/2340880/blog/484538)。通过UIView动画的类方法，我们可以十分方便的使View某些属性改变的同时拥有动画效果。这篇博客主要讨论View切换的动画操作。 两个方法： + (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 通过这个方法，我们可以重绘View视图，任何其子视图的改变或者其自身的改变都会触发转场动画的效果， 系统提供的转场效果在第一篇博客中已经介绍过。 这个方法常用于类似小说软件的翻页效果。 + (void)transitionFromView:(UIView )fromView toView:(UIView )toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion; 这个方法会作用于fromView的父视图，用于切换两个view，通过执行这个方法，会将formView从其父视图上移除，将toView重新粘在其父视图上，展现一个动画效果。 通过使用上述两个方法，你会发现某些效果会非常突兀，比如想要改变视图的颜色，它会在转场动画播放完成后，颜色突然的变化，要改善这一效果，我们需要设置options参数包含：UIViewAnimationOptionAllowAnimatedContent这个枚举。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之一——UIViewAnimation动画的使用","slug":"84iOS动画开发之一——UIViewAnimation动画的使用","date":"2015-07-26T16:00:00.000Z","updated":"2021-06-30T11:06:09.856Z","comments":true,"path":"2015/07/27/84iOS动画开发之一——UIViewAnimation动画的使用/","link":"","permalink":"http://huishao.cc/2015/07/27/84iOS动画开发之一——UIViewAnimation动画的使用/","excerpt":"","text":"iOS动画开发之一——UIViewAnimation动画的使用一、简介一款APP的成功与否，除了完善的功能外，用户体验也占有极大的比重，动画的合理运用，可以很好的增强用户体验。iOS开发中，常用的动画处理有UIView动画编程和核心动画编程，其中UIView动画使用简便，开发中应用十分广泛。这篇博客，主要讨论UIView的动画使用。 二、UIView动画的几个方法+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations; 这个是参数最少的一个方法，我们可以通过设置一个时间和block块来完成动画，时间参数是动画执行的时长，block块中为要执行的动画动作，具体可以执行那些动作，我们会在后面说。例如在1S内将view渐变透明： 123[UIView animateWithDuration:1 animations:^&#123; _myView.alpha=0; &#125;]; + (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数会带两个block块，用法和第一个函数相似，设置一个执行时间和一个执行动作，第二个block块中可以添加一个动画执行结束后的动作，作为补充，例如下面代码的效果，在1S内将view渐变为透明，动画结束后，view在瞬间变回不透明： 1234567[UIView animateWithDuration:1 animations:^&#123; _myView.alpha=0; &#125; completion:^(BOOL finished) &#123; if (finished) &#123; _myView.alpha=1; &#125; &#125;]; + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数除了上面的属性外，可以设置延时执行，同时可以设置一个动画效果参数，这个参数是个枚举，它可以影响动画的执行效果，后面会再总结。 + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数是iOS7之后的一个新函数，通过这个函数，我们可以方便的制作出效果炫酷的动画，这个函数的核心是两个阻尼参数，参数dampingRatio可以理解为弹簧效果的强弱，设置1则没有回弹效果，设置0则会剧烈的阻尼回弹。velocity参数用于设置弹簧的初始速度。 三、UIView动画可以操作的视图属性通过上面的介绍，我们了解了几个使用动画的函数，那么那些属性可以产生动画效果呢？ 官方文档告诉我们这些属性是可以通过上述方法进行动画的： 四、动画执行选项设置 在UIView执行动画的相关函数中，有UIViewAnimationOptions这个参数可以对动画的执行效果进行设置，这个枚举非常多，可分为三部分，如下： 123456789101112131415161718192021222324252627enum &#123; //这部分是基础属性的设置 UIViewAnimationOptionLayoutSubviews = 1 &lt;&lt; 0,//设置子视图随父视图展示动画 UIViewAnimationOptionAllowUserInteraction = 1 &lt;&lt; 1,//允许在动画执行时用户与其进行交互 UIViewAnimationOptionBeginFromCurrentState = 1 &lt;&lt; 2,//允许在动画执行时执行新的动画 UIViewAnimationOptionRepeat = 1 &lt;&lt; 3,//设置动画循环执行 UIViewAnimationOptionAutoreverse = 1 &lt;&lt; 4,//设置动画反向执行，必须和重复执行一起使用 UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt; 5,//强制动画使用内层动画的时间值 UIViewAnimationOptionOverrideInheritedCurve = 1 &lt;&lt; 6,//强制动画使用内层动画曲线值 UIViewAnimationOptionAllowAnimatedContent = 1 &lt;&lt; 7,//设置动画视图实时刷新 UIViewAnimationOptionShowHideTransitionViews = 1 &lt;&lt; 8,//设置视图切换时隐藏，而不是移除 UIViewAnimationOptionOverrideInheritedOptions = 1 &lt;&lt; 9,// //这部分属性设置动画播放的线性效果 UIViewAnimationOptionCurveEaseInOut = 0 &lt;&lt; 16,//淡入淡出 首末减速 UIViewAnimationOptionCurveEaseIn = 1 &lt;&lt; 16,//淡入 初始减速 UIViewAnimationOptionCurveEaseOut = 2 &lt;&lt; 16,//淡出 末尾减速 UIViewAnimationOptionCurveLinear = 3 &lt;&lt; 16,//线性 匀速执行 //这部分设置UIView切换效果 UIViewAnimationOptionTransitionNone = 0 &lt;&lt; 20, UIViewAnimationOptionTransitionFlipFromLeft = 1 &lt;&lt; 20,//从左边切入 UIViewAnimationOptionTransitionFlipFromRight = 2 &lt;&lt; 20,//从右边切入 UIViewAnimationOptionTransitionCurlUp = 3 &lt;&lt; 20,//从上面立体进入 UIViewAnimationOptionTransitionCurlDown = 4 &lt;&lt; 20,//从下面立体进入 UIViewAnimationOptionTransitionCrossDissolve = 5 &lt;&lt; 20,//溶解效果 UIViewAnimationOptionTransitionFlipFromTop = 6 &lt;&lt; 20,//从上面切入 UIViewAnimationOptionTransitionFlipFromBottom = 7 &lt;&lt; 20,//从下面切入&#125;; 提示：1，属性可以使用|进行多项合并。 2，这类的动画可以进行嵌套，其中有一点需要注意，内层动画的执行时间和曲线模式会默认继承外层动的，若要强制使用新的参数，使用如下的两个参数： 12UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt; 5,//强制动画使用内层动画的时间值 UIViewAnimationOptionOverrideInheritedCurve = 1 &lt;&lt; 6,//强制动画使用内层动画曲线值 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发技巧之查看模拟器沙盒文件","slug":"83iOS开发技巧之查看模拟器沙盒文件","date":"2015-07-18T16:00:00.000Z","updated":"2021-06-30T11:03:57.806Z","comments":true,"path":"2015/07/19/83iOS开发技巧之查看模拟器沙盒文件/","link":"","permalink":"http://huishao.cc/2015/07/19/83iOS开发技巧之查看模拟器沙盒文件/","excerpt":"","text":"iOS开发技巧之查看模拟器沙盒文件iOS开发中，在对数据库进行操作时，有时我们需要直观的查看数据库的内容，那么我们如何找到沙盒中的这个文件呢，步骤很简单： 1.点击Finder选项栏上的前往菜单： 2.选择前往文件夹选项： 前往的文件路径为：/Users/username/Library/Application Support/iPhone Simulator/ 其中username为当前mac电脑的用户名。 3.界面类似如下模样，选择一个版本的模拟器，应用的沙盒文件就在Applications中。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美十——用户交互元素","slug":"82标签之美十——用户交互元素","date":"2015-07-01T16:00:00.000Z","updated":"2021-06-30T11:02:01.459Z","comments":true,"path":"2015/07/02/82标签之美十——用户交互元素/","link":"","permalink":"http://huishao.cc/2015/07/02/82标签之美十——用户交互元素/","excerpt":"","text":"标签之美——用户交互元素任何一个网页都会提供用户交互的功能，包括账号密码的提交，留言板等用户信息的的获取。 一、用户交互表单的属性表单使用来创建。 1、跳转链接属性表单的跳转是在提交数据后跳转到指定的URL，使用action属性，如下： 12&lt;form action=&quot;http://&quot;&gt;&lt;/form&gt; 2、传递数据的方式表单跳转传递数据时可以设置一个传递方式，使用method可以设置方式为get或者post,delate,put： 12&lt;form action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;/form&gt; 3、表单名称表单可是设置一个名称，通过name属性来设置： 12&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;/form&gt; 二、输入表单输入表单使用创建，必须在表单元素中 123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input/&gt;&lt;/form&gt; 效果如下： 1、输入文本框输入表单有type属性可以用来设置类型： 123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;文本框&lt;input type=&quot;text&quot; name=&quot;文本框&quot;/&gt;&lt;!--name:表单名称--&gt;&lt;/form&gt; 效果如下： 2、密码输入框123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;密码框&lt;input type=&quot;password&quot; name=&quot;密码框&quot;/&gt;&lt;!--name:表单名称--&gt;&lt;/form&gt; 效果如下： 3、输入单选框设置type=radio可以创建单选框，单选框需要设置几个属性，同一系列的单选框必须有相同的name值，不相同的value值，可以通过添加checked键值来设置默认选中，示例如下： 12345&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;性别&quot; value=&quot;男&quot; checked/&gt;男&lt;br/&gt;&lt;input type=&quot;radio&quot; name=&quot;性别&quot; value=&quot;女&quot;/&gt;女&lt;/form&gt; 效果如下： 4、输入复选框和单选框相似，可以使用type=checkbox创建复选框: 1234567&lt;body&gt;&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;/form&gt; 效果如下： 5、提交按钮使用type=submit来创建提交按钮，value值为按钮显示的文字： 1234567&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 效果如下： 6、重置按钮123456&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;br/&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt; 效果如下： 点击重置按钮后，输入的内容会被重置。 7、图像按钮图像按钮和普通按钮的用法相似，设置type=image可以创建图像按钮，只是这个按钮多了一个src的属性用来设置图片的路径地址。 三、下拉列表通过和标签来设置下拉菜单和其中的选项，示例如下： 1234567&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;select name=&quot;下拉框&quot;&gt;&lt;option value=&quot;爱好&quot; selected&gt;HTML&lt;/option&gt;&lt;option value=&quot;爱好&quot;&gt;iOS&lt;/option&gt;&lt;option value=&quot;爱好&quot;&gt;android&lt;/option&gt;&lt;/select&gt;&lt;/form&gt; 效果如下： 四、文本输入框使用来设置文本输入框，属性rows和clos可以分别设置输入框的行数和列数，示例如下： 1234&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;textarea name=&quot;文本输入框&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt;&lt;/form&gt; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"Swift学习第二练——Swift项目时光电影","slug":"80Swift学习第二练——Swift项目时光电影","date":"2015-06-27T16:00:00.000Z","updated":"2021-06-30T10:59:21.664Z","comments":true,"path":"2015/06/28/80Swift学习第二练——Swift项目时光电影/","link":"","permalink":"http://huishao.cc/2015/06/28/80Swift学习第二练——Swift项目时光电影/","excerpt":"","text":"Swift学习第二练——Swift项目时光电影很早以前的一个OC的练习项目，用swift重新写了一遍，因为xcode版本的更新对swift的兼容度也在不断改变，此版本适用于xcode6.1。 这个项目中，用swift将iOS官方SDK中的HTTP进行了封装，使用了swift编写的异步加载网络图片的方法。练习了用swift操作界面布局，跳转界面等的方法。 下面是封装的下载类的核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private var httpConnection:NSURLConnection?class ZYHHttpRequset: NSObject,NSURLConnectionDataDelegate&#123; var requestUrl:String? var downloadData:NSMutableData=NSMutableData() var isDownloadSuccess:Bool? var delegate:ZYHHttpRequestDelegate? class func requestFormUrl(url:NSString)-&gt;ZYHHttpRequset&#123; var oldRequest:ZYHHttpRequset?=ZYHHttpRequestManager.sharedHttpRequestManager().requestForKey(url) if (oldRequest != nil)&#123; println(&quot;该任务存在&quot;) return oldRequest! &#125; //新建下载任务 var request:ZYHHttpRequset=ZYHHttpRequset() request.requestUrl=url request.startRequestUrl(url) ZYHHttpRequestManager.sharedHttpRequestManager().addTask(request, key: url) return request &#125; func stop()&#123; if httpConnection != nil &#123; httpConnection?.cancel() httpConnection = nil &#125; &#125; //开始下载请求 private func startRequestUrl(url:NSString)&#123; if httpConnection != nil &#123; httpConnection!.cancel() httpConnection==nil &#125; //创建连接对象 var request=NSURLRequest(URL: NSURL(string: url)!) httpConnection=NSURLConnection(request: request, delegate: self) &#125; //重写协议中的方法 func connection(connection: NSURLConnection, didReceiveResponse response: NSURLResponse) &#123; downloadData.length=0 &#125; func connection(connection: NSURLConnection, didReceiveData data: NSData) &#123; downloadData.appendData(data) &#125; func connectionDidFinishLoading(connection: NSURLConnection) &#123; isDownloadSuccess = true delegate!.ZYHHttpRequestSuccsee(self) ZYHHttpRequestManager.sharedHttpRequestManager().removeTaskFromUrl(self.requestUrl!) &#125; func connection(connection: NSURLConnection, didFailWithError error: NSError) &#123; println(&quot;加载失败&quot;) println(error) self.isDownloadSuccess=false ZYHHttpRequestManager.sharedHttpRequestManager().removeTaskFromUrl(self.requestUrl!) &#125; &#125;protocol ZYHHttpRequestDelegate&#123; func ZYHHttpRequestSuccsee(request:ZYHHttpRequset)&#125; 项目部分截图： github源码地址：https://github.com/ZYHshao/SwiftMovie 其中错误之处，欢迎指教，希望在交流中，不断进步！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"标签之美九——列表","slug":"81标签之美九——列表","date":"2015-06-27T16:00:00.000Z","updated":"2021-06-30T11:00:26.230Z","comments":true,"path":"2015/06/28/81标签之美九——列表/","link":"","permalink":"http://huishao.cc/2015/06/28/81标签之美九——列表/","excerpt":"","text":"标签之美——列表列表是网页排序中时常会用到的一个元素。 一、无序列表1、无序列表的标签无序列表使用来定义标签的开始和结束。使用来设置标签项，示例如下： 12345&lt;body&gt;&lt;ul&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 效果如下： 2、无序列表标签的样式标签的type属性可以设置其样式： 实心圆样式：disc这个样式就是默认的样式，效果如上图 空心圆样式：circle示例如下： 12345&lt;body&gt;&lt;ul type=&quot;circle&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 效果如下： 方块样式：square效果如下： 二、有序列表1、有序列表的标签有序列表的开始和结束使用来定义，同样使用来定义列表项，示例如下： 12345&lt;body&gt;&lt;ol type=&quot;square&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt; 效果如下： 2、有序列表的样式数字标号的样式：type=1这个样式为默认的样式，效果如上。 大写字母的标签：type=A效果如下： 小写字母样式：type=a 大写罗马数字样式：type=I 小写罗马数字样式：type=i 三、列表的嵌套列表可以进行嵌套，形式如下： 123456789&lt;body&gt;&lt;ol type=&quot;i&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;subTitle1&lt;/li&gt;&lt;li&gt;subTitle2&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS开发swift版异步加载网络图片(带缓存和缺省图片)","slug":"79iOS开发swift版异步加载网络图片(带缓存和缺省图片)","date":"2015-06-24T16:00:00.000Z","updated":"2021-06-30T10:01:36.971Z","comments":true,"path":"2015/06/25/79iOS开发swift版异步加载网络图片(带缓存和缺省图片)/","link":"","permalink":"http://huishao.cc/2015/06/25/79iOS开发swift版异步加载网络图片(带缓存和缺省图片)/","excerpt":"","text":"iOS开发之swift版异步加载网络图片与SDWebImage异步加载网络图片的功能相似，只是代码比较简单，功能没有SD的完善与强大，支持缺省添加图片，支持本地缓存。 异步加载图片的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 func setZYHWebImage(url:NSString?, defaultImage:NSString?, isCache:Bool)&#123; var ZYHImage:UIImage? if url == nil &#123; return &#125; //设置默认图片 if defaultImage != nil &#123; self.image=UIImage(named: defaultImage!) &#125; //是否进行缓存处理 if isCache &#123; //缓存管理类 var data:NSData?=ZYHWebImageChcheCenter.readCacheFromUrl(url!) if data != nil &#123; ZYHImage=UIImage(data: data!) self.image=ZYHImage &#125;else&#123; //获取异步线程 var dispath=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) dispatch_async(dispath, &#123; () -&gt; Void in var URL:NSURL = NSURL(string: url!)! var data:NSData?=NSData(contentsOfURL: URL) if data != nil &#123; ZYHImage=UIImage(data: data!) //写缓存 ZYHWebImageChcheCenter.writeCacheToUrl(url!, data: data!) //主线程中刷新UI dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in //刷新主UI self.image=ZYHImage &#125;) &#125; &#125;) &#125; &#125;else&#123; var dispath=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) dispatch_async(dispath, &#123; () -&gt; Void in var URL:NSURL = NSURL(string: url!)! var data:NSData?=NSData(contentsOfURL: URL) if data != nil &#123; ZYHImage=UIImage(data: data!) //写缓存 dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in //刷新主UI self.image=ZYHImage &#125;) &#125; &#125;) &#125; &#125; &#125; 缓存的处理这里采用的是写文件的方式，通过文件名来对缓存进行管理，这个框架还不完善，后面会加入缓存清除等功能。缓存的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class func readCacheFromUrl(url:NSString)-&gt;NSData?&#123; var data:NSData? var path:NSString=ZYHWebImageChcheCenter.getFullCachePathFromUrl(url) if NSFileManager.defaultManager().fileExistsAtPath(path) &#123; data=NSData.dataWithContentsOfMappedFile(path) as? NSData &#125; return data &#125; class func writeCacheToUrl(url:NSString, data:NSData)&#123; var path:NSString=ZYHWebImageChcheCenter.getFullCachePathFromUrl(url) println(data.writeToFile(path, atomically: true)) &#125; //设置缓存路径 class func getFullCachePathFromUrl(url:NSString)-&gt;NSString&#123; var chchePath=NSHomeDirectory().stringByAppendingString(&quot;/Library/Caches/MyCache&quot;) var fileManager:NSFileManager=NSFileManager.defaultManager() fileManager.fileExistsAtPath(chchePath) if !(fileManager.fileExistsAtPath(chchePath)) &#123; fileManager.createDirectoryAtPath(chchePath, withIntermediateDirectories: true, attributes: nil, error: nil) &#125; //进行字符串处理 var newURL:NSString newURL=ZYHWebImageChcheCenter.stringToZYHString(url) chchePath=chchePath.stringByAppendingFormat(&quot;/%@&quot;, newURL) return chchePath &#125; class func stringToZYHString(str:NSString)-&gt;NSString&#123; var newStr:NSMutableString=NSMutableString() for var i:NSInteger=0; i &lt; str.length; i++ &#123; var c:unichar=str.characterAtIndex(i) if (c&gt;=48&amp;&amp;c&lt;=57)||(c&gt;=65&amp;&amp;c&lt;=90)||(c&gt;=97&amp;&amp;c&lt;=122)&#123; newStr.appendFormat(&quot;%c&quot;, c) &#125; &#125; return newStr.copy() as NSString &#125; 框架的github地址，欢迎指正与扩展：https://github.com/ZYHshao/swift-ZYHWebImage 因xcode的版本不同，swift语言语法随环境时常会变化，此版本在6.1中可用，更高版本中需要修改少部分即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS中UIWebView的使用详解","slug":"78iOS中UIWebView的使用详解","date":"2015-06-22T16:00:00.000Z","updated":"2021-06-30T10:00:15.618Z","comments":true,"path":"2015/06/23/78iOS中UIWebView的使用详解/","link":"","permalink":"http://huishao.cc/2015/06/23/78iOS中UIWebView的使用详解/","excerpt":"","text":"iOS中UIWebView的使用详解一、初始化与三种加载方式UIWebView继承与UIView，因此，其初始化方法和一般的view一样，通过alloc和init进行初始化，其加载数据的方式有三种： 第一种： - (void)loadRequest:(NSURLRequest *)request; 这是加载网页最常用的一种方式，通过一个网页URL来进行加载，这个URL可以是远程的也可以是本地的，例如我加载百度的主页： 123 UIWebView * view = [[UIWebView alloc]initWithFrame:self.view.frame]; [view loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]]; [self.view addSubview:view]; 会得到如下的效果： 第二种： - (void)loadHTMLString:(NSString )string baseURL:(NSURL )baseURL; 这个方法需要将httml文件读取为字符串，其中baseURL是我们自己设置的一个路径，用于寻找html文件中引用的图片等素材。 第三种： - (void)loadData:(NSData )data MIMEType:(NSString )MIMEType textEncodingName:(NSString )textEncodingName baseURL:(NSURL )baseURL; 这个方式使用的比较少，但也更加自由，其中data是文件数据，MIMEType是文件类型，textEncodingName是编码类型，baseURL是素材资源路径。 二、一些常用的属性和变量@property (nonatomic, assign) id &lt;UIWebViewDelegate> delegate; 设置webView的代理 @property (nonatomic, readonly, retain) UIScrollView *scrollView; 内置的scrollView @property (nonatomic, readonly, retain) NSURLRequest *request; URL请求 - (void)reload; 重新加载数据 - (void)stopLoading; 停止加载数据 - (void)goBack; 返回上一级 - (void)goForward; 跳转下一级 @property (nonatomic, readonly, getter=canGoBack) BOOL canGoBack; 获取能否返回上一级 @property (nonatomic, readonly, getter=canGoForward) BOOL canGoForward; 获取能否跳转下一级 @property (nonatomic, readonly, getter=isLoading) BOOL loading; 获取是否正在加载数据 - (NSString )stringByEvaluatingJavaScriptFromString:(NSString )script; 通过javaScript操作web数据 @property (nonatomic) BOOL scalesPageToFit; 设置是否缩放到适合屏幕大小 @property (nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0); 设置某些数据变为链接形式，这个枚举可以设置如电话号，地址，邮箱等转化为链接 @property (nonatomic) BOOL allowsInlineMediaPlayback NS_AVAILABLE_IOS(4_0); 设置是否使用内联播放器播放视频 @property (nonatomic) BOOL mediaPlaybackRequiresUserAction NS_AVAILABLE_IOS(4_0); 设置视频是否自动播放 @property (nonatomic) BOOL mediaPlaybackAllowsAirPlay NS_AVAILABLE_IOS(5_0); 设置音频播放是否支持ari play功能 @property (nonatomic) BOOL suppressesIncrementalRendering NS_AVAILABLE_IOS(6_0); 设置是否将数据加载如内存后渲染界面 @property (nonatomic) BOOL keyboardDisplayRequiresUserAction NS_AVAILABLE_IOS(6_0); 设置用户交互模式 三、iOS7中的一些新特性下面这些属性是iOS7之后才有的，通过他们可以设置更加有趣的web体验 @property (nonatomic) UIWebPaginationMode paginationMode NS_AVAILABLE_IOS(7_0); 这个属性用来设置一种模式，当网页的大小超出view时，将网页以翻页的效果展示，枚举如下： 1234567typedef NS_ENUM(NSInteger, UIWebPaginationMode) &#123; UIWebPaginationModeUnpaginated,//不使用翻页效果 UIWebPaginationModeLeftToRight,//将网页超出部分分页，从左向右进行翻页 UIWebPaginationModeTopToBottom,//将网页超出部分分页，从上向下进行翻页 UIWebPaginationModeBottomToTop,//将网页超出部分分页，从下向上进行翻页 UIWebPaginationModeRightToLeft//将网页超出部分分页，从右向左进行翻页&#125;; @property (nonatomic) CGFloat pageLength NS_AVAILABLE_IOS(7_0); 设置每一页的长度 @property (nonatomic) CGFloat gapBetweenPages NS_AVAILABLE_IOS(7_0); 设置每一页的间距 @property (nonatomic, readonly) NSUInteger pageCount NS_AVAILABLE_IOS(7_0); 获取分页数 四、webView协议中的方法- (BOOL)webView:(UIWebView )webView shouldStartLoadWithRequest:(NSURLRequest )request navigationType:(UIWebViewNavigationType)navigationType; 准备加载内容时调用的方法，通过返回值来进行是否加载的设置 - (void)webViewDidStartLoad:(UIWebView *)webView; 开始加载时调用的方法 - (void)webViewDidFinishLoad:(UIWebView *)webView; 结束加载时调用的方法 - (void)webView:(UIWebView )webView didFailLoadWithError:(NSError )error; 加载失败时调用的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Swift学习第一练——用Swift实现的FlappyBird小游戏","slug":"77Swift学习第一练——用Swift实现的FlappyBird小游戏","date":"2015-06-10T16:00:00.000Z","updated":"2021-06-30T09:59:10.108Z","comments":true,"path":"2015/06/11/77Swift学习第一练——用Swift实现的FlappyBird小游戏/","link":"","permalink":"http://huishao.cc/2015/06/11/77Swift学习第一练——用Swift实现的FlappyBird小游戏/","excerpt":"","text":"用Swift实现的FlappyBird小游戏 伴随着apple公司对swift的推广态度深入，swift火的很快，并且swift精简便捷的语法和强大的功能，对于使用Object—C开发iOS的开发者来说，也有必要了解学习一下swift。这篇博客跳过swift干涩的语法，直接从一个小游戏项目开始使用swift，将其中收获总结如下： FlappyBird是前段时间很火的一款小游戏，通过手指点击屏幕平衡小鸟通过障碍。我是将以前OC版的项目拿来改成了swift，所以整体的思路还是OC的开发思路。 首先，我需要定义两个宏，一个用来模拟重力加速度G，一个用来便捷获取设备屏幕尺寸。因为这个游戏非常简单，开发起来也只需要几个小时，所以我们只需要在一个文件中写代码：viewController.swift。 swift中没有一般语言中的宏定义，但是可以通过定义常量的形式实现宏的效果： 123//用常量的形式代理OC中的宏定义let G:Float=9.8let SCREEN_SIZE = UIScreen.mainScreen().bounds 我们需要定义一些成员变量，如下： 12345678910class ViewController: UIViewController &#123; var timer:NSTimer?//背景移动的定时器 var i:Int=0//背景移动的速度 var timer2:NSTimer?//柱子和地面移动的定时器 var timer3:NSTimer?//小鸟移动的定时器 var bird:UIImageView? var t:Float=0.0//小鸟下落的速度 var isDowm:Bool=false//标记小鸟是否在下落 var isGameOver:Bool=false//标记是否游戏结束&#125; 对于？和！号的理解，网上概念很多，简单理解声明变量时如果不初始化系统是不会给变量赋nil的，会报错，？的作用就是告诉系统这里如果没有初始化就是nil。同理，在用这类变量的时候，也需要加上？解包，如果加！就是强制解包，可以理解为让系统认为这个变量一定不是nil。 对于UI的创建等部分函数和OC一样，只是调用的方式略有不同，后面会附上源码。 在控制小鸟下落的部分代码如下，其中有一点需要注意，在swift中没有隐式转换这个概念，比如你要使用int a + float b 你必须手动将int转为float:(Float)(a)+b 12345678910111213141516171819func birdMove()&#123; if !isDowm&#123; if bird?.frame.origin.y &lt; SCREEN_SIZE.height-100&#123; var rant:CGRect=bird!.frame rant.origin.y += (CGFloat)(G*(t*t/2)) bird?.frame=rant t+=0.025 &#125; &#125;else&#123; if t&lt;0.24&#123; var rant = bird?.frame rant?.origin.y -= 4.9-(CGFloat)(G*t*t/2) bird?.frame=rant! t+=0.025 &#125;else&#123; isDowm=false &#125; &#125; &#125; 游戏效果图如下： 我相信，实践是学习的必经途径，希望与志同道合的朋友，一起进步。 项目github地址：https://github.com/ZYHshao/swiftFlappyBird 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS选择器视图控件(UIPickerView)使用方法总结","slug":"76iOS选择器视图控件(UIPickerView)使用方法总结","date":"2015-06-09T16:00:00.000Z","updated":"2021-06-30T09:57:24.304Z","comments":true,"path":"2015/06/10/76iOS选择器视图控件(UIPickerView)使用方法总结/","link":"","permalink":"http://huishao.cc/2015/06/10/76iOS选择器视图控件(UIPickerView)使用方法总结/","excerpt":"","text":"iOS中UIPickerView使用总结UIPickerView是iOS中的原生选择器控件，使用方便，用法简单，效果漂亮。 @property(nonatomic,assign) id&lt;UIPickerViewDataSource> dataSource; @property(nonatomic,assign) id&lt;UIPickerViewDelegate> delegate; 设置数据源和代理 @property(nonatomic) BOOL showsSelectionIndicator; 是否显示选择框，在iOS7之后这个属性没有任何效果 @property(nonatomic,readonly) NSInteger numberOfComponents; 获取分区数 - (NSInteger)numberOfRowsInComponent:(NSInteger)component; 获取某一分区的行数 - (CGSize)rowSizeForComponent:(NSInteger)component; 获取某一分区行的尺寸 - (UIView *)viewForRow:(NSInteger)row forComponent:(NSInteger)component; 获取某一分区某一行的视图 - (void)reloadAllComponents; 重载所有分区 - (void)reloadComponent:(NSInteger)component; 重载某一分区 - (void)selectRow:(NSInteger)row inComponent:(NSInteger)component animated:(BOOL)animated; 设置选中某一分区某一行 - (NSInteger)selectedRowInComponent:(NSInteger)component; 返回某一分区选中的行 数据源代理中的方法： - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView; 设置分区数 - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component; 根据分区设置行数 代理中的方法： - (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component; 设置分区宽度 - (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component; 设置分区行高 - (NSString )pickerView:(UIPickerView )pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component; 设置某一行显示的标题 - (NSAttributedString )pickerView:(UIPickerView )pickerView attributedTitleForRow:(NSInteger)row forComponent:(NSInteger)component; 通过属性字符串设置某一行显示的标题 - (UIView )pickerView:(UIPickerView )pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view; 设置某一行显示的view视图 - (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component; 选中某一行时执行的回调 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UI之日期控件的使用（UIDatePicker）","slug":"75iOS开发UI之日期控件的使用（UIDatePicker）","date":"2015-06-08T16:00:00.000Z","updated":"2021-06-29T08:16:53.639Z","comments":true,"path":"2015/06/09/75iOS开发UI之日期控件的使用（UIDatePicker）/","link":"","permalink":"http://huishao.cc/2015/06/09/75iOS开发UI之日期控件的使用（UIDatePicker）/","excerpt":"","text":"iOS日期控件UIDatePicker用法总结@property (nonatomic) UIDatePickerMode datePickerMode; 设置控件模式，枚举如下： 123456typedef NS_ENUM(NSInteger, UIDatePickerMode) &#123; UIDatePickerModeTime, //时间模式，显示时分和上下午 UIDatePickerModeDate, //日期模式显示年月日 UIDatePickerModeDateAndTime, //时间和日期模式，显示月日星期，时分上下午 UIDatePickerModeCountDownTimer, //计时模式，显示时和分&#125;; @property (nonatomic, retain) NSLocale *locale; 设置本地化环境 @property (nonatomic, copy) NSCalendar *calendar; 设置日历 @property (nonatomic, retain) NSTimeZone *timeZone; 设置时区 @property (nonatomic, retain) NSDate *date; 设置当前时间 @property (nonatomic, retain) NSDate *minimumDate; 设置最小时间点 @property (nonatomic, retain) NSDate *maximumDate; 设置最大时间点 @property (nonatomic) NSTimeInterval countDownDuration; 只适用于计时模式，设置时间 @property (nonatomic) NSInteger minuteInterval;设置每一格的时间差 - (void)setDate:(NSDate *)date animated:(BOOL)animated; 设置到一个时间，有动画效果 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UIScrollView使用详解","slug":"74iOS开发UIScrollView使用详解","date":"2015-06-03T16:00:00.000Z","updated":"2021-06-29T08:13:08.130Z","comments":true,"path":"2015/06/04/74iOS开发UIScrollView使用详解/","link":"","permalink":"http://huishao.cc/2015/06/04/74iOS开发UIScrollView使用详解/","excerpt":"","text":"iOS开发UIScrollView使用详解一、ScrollView常用方法和属性@property(nonatomic)CGPoint contentOffset; 设置滚动的偏移量 @property(nonatomic)CGSize contentSize; 设置滑动区域 @property(nonatomic,assign) id delegate; 设置UIScrollView的代理 @property(nonatomic,getter=isDirectionalLockEnabled) BOOL directionalLockEnabled; 设置是否锁定，这个属性很有意思，默认为NO，当设置为YES时，你的滚动视图只能同一时间在一个方向上滚动，但是当你从对角线拖动时，是时刻在水平和竖直方向同时滚动的。 @property(nonatomic) BOOL bounces; 设置是否开启回弹效果 @property(nonatomic) BOOL alwaysBounceVertical; 是否开启垂直方向的回弹效果 @property(nonatomic) BOOL alwaysBounceHorizontal; 是否开启水平方向的回弹效果 @property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled; 是否开启翻页效果 @property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled; 设置是否可以滑动 @property(nonatomic) BOOL showsHorizontalScrollIndicator; 设置是否显示水平滑动条 @property(nonatomic) BOOL showsVerticalScrollIndicator; 设置是否显示竖直滑动条 @property(nonatomic) UIEdgeInsets scrollIndicatorInsets; 设置滑动条的位置 @property(nonatomic) UIScrollViewIndicatorStyle indicatorStyle; 设置滑动条风格，枚举如下： 12345typedef NS_ENUM(NSInteger, UIScrollViewIndicatorStyle) &#123; UIScrollViewIndicatorStyleDefault, //默认 UIScrollViewIndicatorStyleBlack, //黑色风格 UIScrollViewIndicatorStyleWhite //白色风格&#125;; @property(nonatomic) CGFloat decelerationRate; 设置滑动速度 - (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated; 设置滚动视图内容的偏移量，可以带动画效果 - (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated; 设置滚动视图滚动到某个可见区域，可以带动画效果 - (void)flashScrollIndicators; 显示一个短暂的滚动指示器 @property(nonatomic,readonly,getter=isTracking) BOOL tracking; 获取用户是否触及视图内容 @property(nonatomic,readonly,getter=isDragging) BOOL dragging; 获取用户是否开始拖动视图 @property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating; 获取视图是否开始减速（用户停止拖动但视图仍在滚动） @property(nonatomic) BOOL delaysContentTouches; 设置视图是否延迟处理触摸事件（会将消息传递给子视图） @property(nonatomic) BOOL canCancelContentTouches; 设置是否给子视图传递取消动作的消息（默认设置为YES，当scrollView触发事件的时候，其子视图不能触发，如果设置为NO，则子视图会继续触发事件） - (BOOL)touchesShouldBegin:(NSSet )touches withEvent:(UIEvent )event inContentView:(UIView *)view; - (BOOL)touchesShouldCancelInContentView:(UIView *)view; 重写这两个方法可以控制起子视图的事件响应 @property(nonatomic) CGFloat minimumZoomScale; 设置内容最小缩放比例 @property(nonatomic) CGFloat maximumZoomScale; 设置内容最大缩放比例 @property(nonatomic) CGFloat zoomScale; 设置缩放比例 - (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated; 设置缩放比例，可以带动画效果 - (void)zoomToRect:(CGRect)rect animated:(BOOL)animated; 设置缩放显示到某个区域，可以带动画效果 @property(nonatomic) BOOL bouncesZoom; 设置是否可以缩放回弹 @property(nonatomic,readonly,getter=isZooming) BOOL zooming; 获取是否正在缩放模式 @property(nonatomic,readonly,getter=isZoomBouncing) BOOL zoomBouncing; 获取是否当前的缩放比例超出设置的峰值 @property(nonatomic) BOOL scrollsToTop; 设置是否点击状态栏滚动到scrollView的最上端 @property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode; 设置键盘消失的模式，枚举如下： 12345typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) &#123; UIScrollViewKeyboardDismissModeNone, UIScrollViewKeyboardDismissModeOnDrag, //手指滑动视图键盘就会消失 UIScrollViewKeyboardDismissModeInteractive, //手指滑动视图后可以与键盘交互，上下滑动键盘会跟随手指上下移动&#125;; 二、ScrollViewDelegata中常用方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView; 视图已经开始滑动时触发的方法 - (void)scrollViewDidZoom:(UIScrollView *)scrollView; 视图已经开始缩放时触发的方法 - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView; 视图开始拖动时触发的方法 - (void)scrollViewWillEndDragging:(UIScrollView )scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint )targetContentOffset; - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; 视图拖动结束时触发的方法 - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; 视图开始减速时触发的方法 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; 视图减速结束时触发的方法 - (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; 视图动画结束时触发的方法，使用set方法设置偏移量后回触发 - (UIView )viewForZoomingInScrollView:(UIScrollView )scrollView; 返回进行缩放的视图 - (void)scrollViewWillBeginZooming:(UIScrollView )scrollView withView:(UIView )view; 视图内容将要开始缩放时触发的方法 - (void)scrollViewDidEndZooming:(UIScrollView )scrollView withView:(UIView )view atScale:(CGFloat)scale; 视图内容结束缩放时触发的方法 - (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; 返回yes，开启快捷滚动回顶端，将要滚动时调用 - (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; 视图快捷滚动回顶端开始动作时调用 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中UITextView方法解读","slug":"73iOS中UITextView方法解读","date":"2015-06-03T16:00:00.000Z","updated":"2021-06-29T08:06:24.440Z","comments":true,"path":"2015/06/04/73iOS中UITextView方法解读/","link":"","permalink":"http://huishao.cc/2015/06/04/73iOS中UITextView方法解读/","excerpt":"","text":"iOS中UITextView方法解读常用属性解读： @property(nonatomic,assign) id&lt;UITextViewDelegate> delegate; 设置代理属性 @property(nonatomic,copy) NSString *text; textView上的文本 @property(nonatomic,retain) UIFont *font; 设置文本字体 @property(nonatomic,retain) UIColor *textColor; 设置文本颜色 @property(nonatomic) NSTextAlignment textAlignment; 设置文本对齐模式 @property(nonatomic) NSRange selectedRange; 设置选中的文本范围(只有当textView是第一响应时才有效) @property(nonatomic,getter=isEditable) BOOL editable; 设置是否可以编辑 @property(nonatomic,getter=isSelectable) BOOL selectable; 设置是否可以选中 @property(nonatomic) UIDataDetectorTypes dataDetectorTypes; 这个属性可以将本文中的电话，邮件等变为链接，长按会调用响应响应的程序(textView必须为不可编辑状态)，属性的枚举如下： 12345678typedef NS_OPTIONS(NSUInteger, UIDataDetectorTypes) &#123; UIDataDetectorTypePhoneNumber = 1 &lt;&lt; 0, // 电话变为链接 UIDataDetectorTypeLink = 1 &lt;&lt; 1, // 网址变为链接 UIDataDetectorTypeAddress = 1 &lt;&lt; 2, // 地址变为链接 UIDataDetectorTypeCalendarEvent = 1 &lt;&lt; 3, // 日历变为链接 UIDataDetectorTypeNone = 0, // 无连接 UIDataDetectorTypeAll = NSUIntegerMax // 所有类型链接&#125;; @property(nonatomic) BOOL allowsEditingTextAttributes; 设置是否允许编辑属性字符串文本 @property(nonatomic,copy) NSAttributedString *attributedText; 设置属性字符串文本 @property(nonatomic,copy) NSDictionary *typingAttributes; 设置属性字符串文本属性字典 - (void)scrollRangeToVisible:(NSRange)range; 滚动textView使其显示在本一段文本 @property (readwrite, retain) UIView *inputView; 设置成为第一响应时弹出的视图，键盘视图 @property (readwrite, retain) UIView *inputAccessoryView; 设置成为第一响应时弹出的副视图，副键盘视图 @property(nonatomic) BOOL clearsOnInsertion; 设置是否显示删除按钮 UITextViewDelegate中的方法 - (BOOL)textViewShouldBeginEditing:(UITextView *)textView; 是否开始编辑 - (BOOL)textViewShouldEndEditing:(UITextView *)textView; 是否结束编辑 - (void)textViewDidBeginEditing:(UITextView *)textView; 开始编辑时触发的方法 - (void)textViewDidEndEditing:(UITextView *)textView; 结束编辑时触发的方法 - (BOOL)textView:(UITextView )textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString )text; 是否允许字符改变 - (void)textViewDidChange:(UITextView *)textView; 字符内容改变触发的方法 - (void)textViewDidChangeSelection:(UITextView *)textView; 选中内容改变触发的方法 - (BOOL)textView:(UITextView )textView shouldInteractWithURL:(NSURL )URL inRange:(NSRange)characterRange; 当文本中的URL进行链接时触发的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中UIImageView用法总结","slug":"72iOS中UIImageView用法总结","date":"2015-06-02T16:00:00.000Z","updated":"2021-06-29T08:04:47.244Z","comments":true,"path":"2015/06/03/72iOS中UIImageView用法总结/","link":"","permalink":"http://huishao.cc/2015/06/03/72iOS中UIImageView用法总结/","excerpt":"","text":"iOS中UIImageView用法总结- (instancetype)initWithImage:(UIImage *)image; 通过一个图片UIImage对象进行初始化 - (instancetype)initWithImage:(UIImage )image highlightedImage:(UIImage )highlightedImage; 通过一个正常状态下的图片和高亮状态下的图片初始化对象 @property(nonatomic,retain) UIImage *image; 设置正常状态下的图片 @property(nonatomic,retain) UIImage *highlightedImage; 设置高亮状态下的图片 @property(nonatomic,getter=isUserInteractionEnabled) BOOL userInteractionEnabled; 设置是否开启用户交互 @property(nonatomic,getter=isHighlighted) BOOL highlighted; 设置是否为高亮状态 @property(nonatomic,copy) NSArray *animationImages; 设置正常状态下的动画图片数组 @property(nonatomic,copy) NSArray *highlightedAnimationImages; 设置高亮状态下的动画图片数组 @property(nonatomic) NSTimeInterval animationDuration; 设置动画播放时长 默认频率为30帧每秒 @property(nonatomic) NSInteger animationRepeatCount; 设置动画循环播放次数 默认为无限循环 - (void)startAnimating; 开始播放帧动画 - (void)stopAnimating; 停止播放帧动画 - (BOOL)isAnimating; 是否正在播放动画 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"获取iOS应用的URL Schemes","slug":"71获取iOS应用的URL Schemes","date":"2015-06-01T16:00:00.000Z","updated":"2021-06-29T08:00:08.638Z","comments":true,"path":"2015/06/02/71获取iOS应用的URL Schemes/","link":"","permalink":"http://huishao.cc/2015/06/02/71获取iOS应用的URL Schemes/","excerpt":"","text":"获取任意App的系统配置文件这是一个小技巧，无需设备越狱，可以获取到任意App系统配置文件。 1、在mac上的AppStore商店搜索相应App。 2、下载获取此App。 3、打开iTunes，查看应用程序，选中相应的应用程序点击右键，选择在Finder中显示，然后解压ipa文件，得到一个文件夹。 4、进入文件夹，找到扩展名为app的文件，右键选择显示包内容。info.plist文件就在里面。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS系统关于URL Schemes的漏洞探究","slug":"70iOS系统关于URL Schemes的漏洞探究","date":"2015-06-01T16:00:00.000Z","updated":"2021-06-29T07:51:09.032Z","comments":true,"path":"2015/06/02/70iOS系统关于URL Schemes的漏洞探究/","link":"","permalink":"http://huishao.cc/2015/06/02/70iOS系统关于URL Schemes的漏洞探究/","excerpt":"","text":"iOS系统关于URL Schemes的漏洞探究一、何为URL Schemes我想这个东西的设计的目的是为了方便App之间的相互调用与通讯，你可以在自己的App中使用OpenURL方法来唤起其他的App。比如微信的URL Schemes是wiexin，我们新建一个工程，实现如下代码后运行程序： 1[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;weixin://]]; 这时你会发现，你的应用启动后很快就调起了微信的客户端。 二、由URL Schemes引发的漏洞的根源1、一个小问题引起的漏洞根源如上所说，通过URL Schemes可以在应用间相互唤起，而产生漏洞的根源在于这个URL并非是应用唯一的。apple并没有任何限制或者审核这个URL的任何措施，也就是说，如果两个App有着相同的URL Schemes，那么系统唤起的App可能并不是你想唤起的。 2、URL Schemes的优先级如何确定由于相同的URL Scheme可能同时被多个App使用，再如果这些App都安装在了同一个设备上，那么系统究竟会唤起哪一个呢？这个我也不能十分的确定，只有一点可以肯定：如果有和系统应用的URL Scheme相同，那么系统一定会唤起系统自己的应用，在这里系统的应用有着最高的优先级（苹果这里做的好像很不厚道，将自己的应用保护了起来，而把广大其他开发者的应用放在漏洞前置之不理）。如果没有和系统耦合的，那么系统会唤起哪一个App就看运气了。不过，这也不是无章可循，经过测试，优先级和App的Bundle identifier有关，更准确说和Bundle identifier的字母排序有关，如果精心设计这个id，我们就可以做到截获其他应用的URL。 3、这个漏洞会引发什么问题么？仅仅通过上面的叙述，你可能还看不出这个漏洞会引发什么样的后果。可是如果你仔细观察，你会发现，各种iPhone上的第三方调用，例如QQ音乐快捷登录，腾讯的各种游戏，甚至包括调用支付宝钱包的支付功能，都是通过这样的原理实现的。如果这些回调的数据被截获，那么就等于说登录信息，用户信息甚至支付订单信息都会暴漏在他人眼下，对于截获者来说，他可以用你的信息进行登录，可以替你完成支付，也可以盗取你登陆后的用户信息。 三、利用URL Scheme漏洞进行远程登录下面，就用一个实例来演示一下我如何通过一个伪装App登录天天炫斗账号。 天天炫斗是腾讯的一款十分火爆的格斗游戏，像其他腾讯游戏一样，支持QQ和微信登录，这里我拿微信登录为例。 首先，我们需要做一个伪装的App来截取用户的登录信息，新建一个项目，在plist文件中添加一个和天天炫斗微信登录相同的URL Scheme： 这里的wx63124814f356e266就是微信登录天天炫斗的URL Scheme，这里将Bundle id设置为A，使它有比天天炫斗更高的优先级。 在AppDelegate中添加如下代码： 1234-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; NSLog(@&quot;%@&quot;,url); return YES;&#125; 这个函数是在App被通过URL唤起时首先调用的函数，这里传入的URL就是用户的登录验证信息，我们可以在这里将这个信息发送回来。 将伪装好的程序跑一遍后，运行天天炫斗，然后使用微信登录，会发现在微信验证成功后跳转后并没有跳转回天天炫斗应用，而是跳转到了我们伪装的这个Demo。这时xcode调试区会打印出如下的信息： 之后，来开始做我们的侵入程序，这个其实更加简单，新建一个工程，只需要添加一行代码： 1[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;wx63124814f356e266://oauth?code=0118aa2f2b99d8a9e0e76a7176b2bd4E&amp;state=weixin&quot;]]; 这里的URL就是我们截获的带参的URL，在另一个装有天天炫斗的手机上跑这个程序（在同一个手机上测试的话要将刚才的伪装App删去，不然它也会将我们的侵入程序一起骗了）。会发现登录天天炫斗成功，角色信息完全一致。 同样的做法，还可以远程登录QQ音乐，天天飞车等等各种通过微信，QQ，微博快捷登录的应用。 四、要战胜你的敌人，必须要了解你的敌人不了解apple为什么一直不对URL Scheme做限制，或许需要或许不需要。但是这一点建议总是好的：在你的App使用快捷登录的时候，最好同时将设备号或者某个本地保存的标志绑定，防止恶意的第三方借此获取用户的信息。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS界面布局之二——初识autolayout布局模型","slug":"69iOS界面布局之二——初识autolayout布局模型","date":"2015-05-31T16:00:00.000Z","updated":"2021-06-29T07:50:01.480Z","comments":true,"path":"2015/06/01/69iOS界面布局之二——初识autolayout布局模型/","link":"","permalink":"http://huishao.cc/2015/06/01/69iOS界面布局之二——初识autolayout布局模型/","excerpt":"","text":"iOS界面布局之二——初识autolayout布局模型一、引言 在上一篇博客中介绍了传统的布局方式：autoresizing。随着iphone型号的越来越多，屏幕的标准也更加多样化，通过autoresizing已经不能满足开发的需求，而进行两套布局或者动态代码控制又大大增加了开发者的工作量，autolayout的出现拯救个这一切，它让动态布局变的十分简单便捷。 autoresizing介绍：[http://my.oschina.net/u/2340880/blog/423357](http://my.oschina.net/u/2340880/blog/423357)。 二、autolayout的设计思想正如storyboard的设计目的是为了让开发者将更多的精力投入到逻辑实现而不是界面布局一样。autolayout的设计思想是让开发者将布局上更多的精力放在控件关系上而不是坐标。我们只需要关心控件之间的摆放关系，而并不需要关心这是如何实现的。因此你使用autolayout进行布局时，就是在添加一个一个的约束。控件与控件之间的约束，控件与父视图之间的约束。 1、了解几种约束点击xcode的storyboard文件，在xcode的导航栏上点击Edito，然后选择Pin，可以看到如图，其中是可以添加的约束类型。 Width：对视图宽度的约束 Height：对视图高度的约束 Horizontal Spacing：对视图间水平距离的约束 Vertical Spacing：对视图间垂直距离的约束 Leading Space to Superview：与父视图左边界的约束 Trailing Space to Superview：与父视图右边界的约束 Top Space to Superview：与父视图上边界的约束 Bottom Space to Superview：与父视图下边界的约束 Widehs Equally：视图等宽约束 Heights Equally：视图等高约束 2、网上的一个很简单的约束例子了解了上面的几种约束，现在我们来实现一个效果，借用网上关于autolayout自动布局的一个小例子。我们在storyboard中拖入三个label，使它们如下效果： 然后我们将屏幕横过来，会发现这时的效果并不是我们想得到的结果： 在进行添加约束之前，我们先来理清这三个视图之间的关系，将上面两个视图编号为1.2，下面那个视图编号为3. （1）1和2的宽和高相等 （2）1距离父视图左边20px （3）2距离父视图右边20px （4）3距离父视图左边20px，右边20px （5）1和2水平间距20px （6）1与3垂直间距20px （7）1和2距离父视图上边距50px （8）3距离父视图下边距20px （9）3与1和2的高度一样 通过上面的约束，所有视图的位置都将被相对的固定，下面我们只需要按照顺序一一添加即可。 （1）选中1和2视图（按住cmd键可以多选），然后点击Editor-&gt;Pin之后选择Widehs Equally，重复上面的过程，选择Heights Equally。我们会看到如下的效果： 几点注意： *线是橙色代表警告，我们没有添加足够的约束来确定位置或者约束有矛盾。 *如果线的中间显示的不是等号，而是数字，则是因为视图1和2的尺寸设置的不等，约束有矛盾。 （2）选中1.重复上面步骤，选择Leading Space to Superview。这时1的左边又会增加一条线： 点击这条线，在右边的设置去将约束值设置为20： （3）重复上面步骤，选中视图2，添加Trailing Space to Superview约束。 （4）选中视图3，重复上面步骤。 （5）选中1和2，添加Horizontal Spacing，设置为20. （6）选中1和3，添加Vertical Spacing，设置为20. （7）为1和2分别添加Top Space to Superview约束。 （8）为3添加Bottom Space to Superview约束。 （9）选中1和3，添加Heights Equally约束。 上面的过程虽然繁琐，但是逻辑性十分清晰，这时你会发现所有的线都变成了蓝色，约束已经添加完整，我们再次运行后横屏，效果如下： 这就是我们想要的结果了。 3、自动布局的几种对其方式在xcode导航的Editor菜单中，还有一个子菜单，Align，这里面的选项可以为控件添加对其约束： Left Edges：控件左对齐 Right Edges：控件右对齐 Top Edges：控件上对齐 Bottom Edges：控件下对齐 Horizontal Centers：控件水平中心对齐 Vertical Centers：控件垂直水平对齐 Horizontal Center in Container：控件与其父视图水平中心对齐 Vertical Center in Container：控件与其父视图垂直中心对齐 三、几点小感悟到此为止，基本上已经可以使用autolayout自动布局解决复杂的布局需求了，但是切记，正式因为aotulayout的强大使它会隐藏更多的坑，下面是我的几点感悟，再次分享： 1、autolayout的精髓在于足够多的约束，autolayout之所以比autoresizing强大，就在于其布局的精确性，而精确性正是由约束来提供的。 2、切莫画蛇添足，矛盾的约束会使xcode晕掉，所以在添加约束前，我建议将试图间的布局关系先整理出来。 3、应该转变你的思路，如果你已经习惯了使用CGRect、Point等传统的坐标布局模式，那么你应该稍微转变一下，autolayout倡导的是一个相对的概念，你需要将更多的关注放在视图间的关系，比如A和B距离10，A和C右对齐等。具体的坐标会有autolayout帮你算。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之一——使用autoresizing进行动态布局","slug":"68iOS界面布局之一——使用autoresizing进行动态布局","date":"2015-05-31T16:00:00.000Z","updated":"2021-06-29T07:46:40.535Z","comments":true,"path":"2015/06/01/68iOS界面布局之一——使用autoresizing进行动态布局/","link":"","permalink":"http://huishao.cc/2015/06/01/68iOS界面布局之一——使用autoresizing进行动态布局/","excerpt":"","text":"iOS界面布局之一——使用autoresizing进行动态布局autoresizing是iOS中传统的界面自动布局方式，通过它，当父视图frame变换时，子视图会自动的做出相应的调整。 一、通过代码进行布局任何一个view都有autoresizingMask这个属性，通过这个属性可以设置当前view与其父视图的相对关系。我们先来看UIViewAutoresizing这个枚举： 123456789typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123; UIViewAutoresizingNone = 0,//默认 UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,//与父视图右边间距固定，左边可变 UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,//视图宽度可变 UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,//与父视图左边间距固定，右边可变 UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3,//与父视图下边间距固定，上边可变 UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4,//视图高度可变 UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5//与父视图上边间距固定，下边可变&#125;; 下面我们通过效果来看这些属性的作用： 先创建两个view，为了区分，设置不同的背景色： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(20, 40, 200, 200)]; view1.backgroundColor=[UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(10, 10, 100, 100)]; view2.backgroundColor=[UIColor greenColor]; [view1 addSubview:view2]; [self.view addSubview:view1];&#125; 设置view2的自动布局属性如下： 1 view2.autoresizingMask=UIViewAutoresizingFlexibleBottomMargin; 这时的效果如下： 改变view1的frame如下： 1UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(20, 40, 300, 300)]; 效果如下： 这时view2的下边距离相对父视图是可变的。 设置如下： 1 view2.autoresizingMask=UIViewAutoresizingFlexibleHeight; 效果如下： 可以看出，这时子视图的高度是随父视图变化而自动改变的。 如下设置： 1view2.autoresizingMask=UIViewAutoresizingFlexibleLeftMargin; 效果如下： 这时子视图的左边是随父视图变化而可变的。 同理，UIViewAutoresizingFlexibleRightMargin将使子视图右边与父视图的距离可变。 UIViewAutoresizingFlexibleTopMargin将使子视图上边与父视图距离可变。UIViewAutoresizingFlexibleWidth将使子视图的宽度可变。 注意：这些自动布局的属性是可以叠加的，比如保持视图与父视图边距不变，如下设置： 1view2.autoresizingMask=UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight; 效果如下： 二、nib文件中可视化设置自动布局在storyboard中我们可以更加轻松的进行autoresizing自动布局。在view设置栏中有autoresizing这个设置，点中相应的箭头，就是刚才我们探讨的设置选项。并且我们把鼠标放在这个上面的时候，右侧会自动为我们预览效果。 如果你觉得autoresizing很强大，那么你就太容易满足了，autoresizing可以满足大部分简单的自动布局需求，可是它有一个致命的缺陷，它只能设置子视图相对于父视图的变化，却不能精确这个变化的度是多少，因此对于复杂的精准的布局需求，它就力不从心了。但是有一个好消息告诉你，iOS6之后的autolayout自动布局方案，正是解决复杂布局的好帮手，我们在下一遍博客中再进行详细讨论。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发音频播放基础——AVAudioPlayer的应用","slug":"66iOS开发音频播放基础——AVAudioPlayer的应用","date":"2015-05-25T16:00:00.000Z","updated":"2021-06-29T07:04:17.883Z","comments":true,"path":"2015/05/26/66iOS开发音频播放基础——AVAudioPlayer的应用/","link":"","permalink":"http://huishao.cc/2015/05/26/66iOS开发音频播放基础——AVAudioPlayer的应用/","excerpt":"","text":"iOS音频开发——AVAudioPlayer应用AVAudioPlayer是系统提供给我们的一个音频播放类，在AVFoundation框架下，通过它，我们可以实现一个功能强大的音乐播放器。首先，在项目中我们需要导入AVFoundation这个框架。 一、AVAudioPlayer方法与属性详解初始化方法有两种，通过音频的路径或者音频data数据初始化player对象 12- (instancetype)initWithContentsOfURL:(NSURL *)url error:(NSError **)outError;- (instancetype)initWithData:(NSData *)data error:(NSError **)outError; 注意：支持的音频格式有:AAC,ALAC,HE-AAC,iLBC,IMA4,MP3. 准备播放音频，返回值标志是否解析成功，是否可以播放。 1- (BOOL)prepareToPlay; 开始播放音频 1- (BOOL)play; 在一段时间间隔后播放 1- (BOOL)playAtTime:(NSTimeInterval)time; 暂停播放，并且准备好继续播放 1- (void)pause; 停止播放，不再准备好继续播放 1- (void)stop; 获取是否正在播放 1@property(readonly, getter=isPlaying) BOOL playing; 获取当前音频声道数 1@property(readonly) NSUInteger numberOfChannels; 获取当前音频时长 1@property(readonly) NSTimeInterval duration; 获取创建时的音频路径 1@property(readonly) NSURL *url; 获取创建时的音频数据 1@property(readonly) NSData *data; 设置声道偏移量，0为中心，-1为只有左声道，1为只有右声道 1@property float pan; 设置音频音量，取值为0-1之间 1@property float volume; 设置是否可以改变播放速度 1@property BOOL enableRate; 注意:设置这个属性前必须先调用prepareToPlay这个方法。 设置播放速度，1为正常，0.5为一半速度，2.0为2倍速度 1@property float rate; 设置当前播放的时间点 1@property NSTimeInterval currentTime; 设置音频播放循环次数 1@property NSInteger numberOfLoops; 获取音频设置字典 1@property(readonly) NSDictionary *settings; 是否开启仪表计数功能 1@property(getter=isMeteringEnabled) BOOL meteringEnabled; 更新仪表计数的值 1- (void)updateMeters; 获取指定声道音频峰值 1- (float)peakPowerForChannel:(NSUInteger)channelNumber; 获取指定声道音频平均值 1- (float)averagePowerForChannel:(NSUInteger)channelNumber; 二、AVAudioPlayerDelegate方法详解音频播放结束后调用的函数 1- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag; 播放遇到错误时调用的函数 1- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError *)error; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS后台音频播放及锁屏界面显示音频信息用","slug":"67iOS后台音频播放及锁屏界面显示音频信息","date":"2015-05-25T16:00:00.000Z","updated":"2021-06-29T07:45:33.360Z","comments":true,"path":"2015/05/26/67iOS后台音频播放及锁屏界面显示音频信息/","link":"","permalink":"http://huishao.cc/2015/05/26/67iOS后台音频播放及锁屏界面显示音频信息/","excerpt":"","text":"iOS后台播放音乐及用户交互处理后台播放是任何一个音频软件都支持的功能，在上一篇博客中，详细介绍了使用AVAudioPlayer播放音频的方法，这篇博客将对后台的处理做介绍，关于播放与设置音频的博客地址：http://my.oschina.net/u/2340880/blog/420129。 一、设置后台播放iOS设置后台音频播放的步骤非常简单，首先需要在系统设置的plist文件中添加一个键Required background modes，值为App plays audio or streams audio/video using AirPlay，如下： 然后进行如下代码设置： 123 AVAudioSession *session = [AVAudioSession sharedInstance]; [session setActive:YES error:nil]; [session setCategory:AVAudioSessionCategoryPlayback error:nil]; 此时播放音频时我们点击HOME回到主页面，会发现音频不会停，已经实现后台播放的功能。 二、设置后台用户交互在appDelegate中，我们需要先注册响应后台控制： 1[[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; 然后在appDelegate中我们实现如下函数处理后台传递给我们的信息： 12345-(void)remoteControlReceivedWithEvent:(UIEvent *)event&#123; if (event.type==UIEventTypeRemoteControl) &#123; NSLog(@&quot;%ld&quot;,event.subtype); &#125;&#125; event中的subtype是操作类型，我们打开系统桌面抽屉，可以看到如下的控制键： subtype中的枚举便是点击这些控制键后传递给我们的消息，我们可以根据这些消息在app内做逻辑处理。枚举如下，其中只有100之后的在音频控制中对我们有效： 12345678910111213141516171819202122232425262728typedef NS_ENUM(NSInteger, UIEventSubtype) &#123; // available in iPhone OS 3.0 UIEventSubtypeNone = 0, // for UIEventTypeMotion, available in iPhone OS 3.0 UIEventSubtypeMotionShake = 1, //这之后的是我们需要关注的枚举信息 // for UIEventTypeRemoteControl, available in iOS 4.0 //点击播放按钮或者耳机线控中间那个按钮 UIEventSubtypeRemoteControlPlay = 100, //点击暂停按钮 UIEventSubtypeRemoteControlPause = 101, //点击停止按钮 UIEventSubtypeRemoteControlStop = 102, //点击播放与暂停开关按钮(iphone抽屉中使用这个) UIEventSubtypeRemoteControlTogglePlayPause = 103, //点击下一曲按钮或者耳机中间按钮两下 UIEventSubtypeRemoteControlNextTrack = 104, //点击上一曲按钮或者耳机中间按钮三下 UIEventSubtypeRemoteControlPreviousTrack = 105, //快退开始 点击耳机中间按钮三下不放开 UIEventSubtypeRemoteControlBeginSeekingBackward = 106, //快退结束 耳机快退控制松开后 UIEventSubtypeRemoteControlEndSeekingBackward = 107, //开始快进 耳机中间按钮两下不放开 UIEventSubtypeRemoteControlBeginSeekingForward = 108, //快进结束 耳机快进操作松开后 UIEventSubtypeRemoteControlEndSeekingForward = 109,&#125;; 三、设置后台信息显示及锁屏界面设置设置锁屏界面显示信息的原理是通过设置一个系统的字典，当音频开始播放时，系统会自动从这个字典中读取要显示的信息，如果需要动态显示，我们只需要不断更新这个字典即可。首先需要添加&lt;MediaPlayer/MediaPlayer.h&gt;这个头文件。 代码示例如下： 1234567891011121314151617 NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; //设置歌曲题目 [dict setObject:@&quot;题目&quot; forKey:MPMediaItemPropertyTitle]; //设置歌手名 [dict setObject:@&quot;歌手&quot; forKey:MPMediaItemPropertyArtist]; //设置专辑名 [dict setObject:@&quot;专辑&quot; forKey:MPMediaItemPropertyAlbumTitle]; //设置显示的图片 UIImage *newImage = [UIImage imageNamed:@&quot;43.png&quot;]; [dict setObject:[[MPMediaItemArtwork alloc] initWithImage:newImage] forKey:MPMediaItemPropertyArtwork]; //设置歌曲时长 [dict setObject:[NSNumber numberWithDouble:300] forKey:MPMediaItemPropertyPlaybackDuration]; //设置已经播放时长 [dict setObject:[NSNumber numberWithDouble:150] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; //更新字典 [[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:dict]; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美八——网页框架","slug":"65标签之美八——网页框架","date":"2015-05-24T16:00:00.000Z","updated":"2021-06-29T01:59:00.691Z","comments":true,"path":"2015/05/25/65标签之美八——网页框架/","link":"","permalink":"http://huishao.cc/2015/05/25/65标签之美八——网页框架/","excerpt":"","text":"标签之美——网页框架的应用一、框架集框架集用来设置框架的属性，修饰框架的总体效果。 1、框架宽度cols属性用来设置框架的宽度，示例如下： 12345678&lt;body&gt;&lt;frameset cols=&quot;30%,30%,30%,10%&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 其中属性设置的值可以是百分比，可以是固定值，*符号表示除了已经分配后的剩余空间。上面代码中每个html文件设置不同的背景颜色，效果如下： 2、框架高度使用rows属性可是设置框架的高度。其用法和cols属性类似，示例如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 注意：宽度和高度这两个属性，不能同时使用，只能二选一。 3、边框宽度可以通过border属性设置框架边框的宽度，如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot; border=&quot;10&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 4、边框颜色和其他属性类似，通过bordercolor可以设置边框的颜色。 5、设置是否显示边框通过设置frameborder可以显示和隐藏边框，其值可取0或者1。隐藏效果如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot; frameborder=&quot;0&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 二、框架框架和框架集是可以嵌套的。可以在一个框架中继续嵌套框架集。 1、设置框架大小不可调节使用的框架，默认当鼠标点击拉动时是可以调节大小的，可以设置nosize=”nosize”来设置不可调节。 2、设置框架的滚动条scrolling属性可以设置框架是否显示滚动条,可以设置yes或者no。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS多线程编程之三——GCD的应用","slug":"64iOS多线程编程之三——GCD的应用","date":"2015-05-20T16:00:00.000Z","updated":"2021-06-29T01:57:52.855Z","comments":true,"path":"2015/05/21/64iOS多线程编程之三——GCD的应用/","link":"","permalink":"http://huishao.cc/2015/05/21/64iOS多线程编程之三——GCD的应用/","excerpt":"","text":"iOS多线程编程之三——GCD的应用一、引言在软件开发中使用多线程可以大大的提升用户体验度，增加工作效率。iOS系统中提供了多种分线程编程的方法，在前两篇博客都有提及： NSThread类进行多线程编程：http://my.oschina.net/u/2340880/blog/416524。 NSOperation进行多线程操作编程：http://my.oschina.net/u/2340880/blog/416782。 上两个进行多线程编程的机制都是封装于Object-C的类与方法。这篇博客将讨论的Grand Central Dispatch(GCD)机制，则是基于C语言的，相比上面两种机制，GCD更加高效，并且线程有系统管理，会自动运用多核运算。因为这些优势，GCD是apple推荐我们使用的多线程解决方案。 二、GCD的调度机制GCD机制中一个很重要的概念是调度队列，我们对线程的操作实际上是由调度队列完成的。我们只需要将要执行的任务添加到合适的调度队列中即可。 1、调度队列的类型调度队列有三种类型： （1）主队列 其中的任务在主线程中执行，因为其会阻塞主线程，所以这是一个串行的队列。可以通过dispatch_get_main_queue()方法得到。 （2）全局并行队列 队列中任务的执行方式是严格按照先进先出的模式进行了。如果是串行的队列，则当一个任务结束后，才会开启另一个任务，如果是并行队列，则任务的开启顺序是和添加顺序一致的。系统为iOS应用自动创建了四个全局共享的并发队列。使用如下函数获得： dispatch_get_global_queue(long identifier, unsigned long flags); 其中第一个参数是这个队列的id，系统的四个全局队列默认的优先级不同，这个参数可填的定义如下： 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2//优先级最高的全局队列#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0//优先级中等的全局队列#define DISPATCH_QUEUE_PRIORITY_LOW (-2)//优先级低的全局队列#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN//后台的全局队列 优先级最低 这个函数的第二个参数，按照官方文档的说法是有待未来使用，现在我们都填0即可。 （3）自定义队列 上面的两种队列都是系统为我们创建好的，我们只需要获取到他们，将任务添加即可。当然，我们可可以创建我们自己的队列，包括串行的和并行的。使用如下方法创建： 1dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL); 其中，第一个参数是这个队列的名字，第二个参数决定创建的是串行的还是并行的队列。填写DISPATCH_QUEUE_SERIAL或者NULL创建串行队列，填写DISPATCH_QUEUE_CONCURRENT创建并行队列。 2、添加任务到队列中使用dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)函数或者dispatch_async(dispatch_queue_t queue, dispatch_block_t block)函数来同步或者异步的执行任务，示例如下： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; NSLog(@&quot;%@:1&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;%@:2&quot;,[NSThread currentThread]); &#125;);&#125; 打印结果如下： 可以看出第一个任务在主线程中执行，第二个在分线程中执行。 三、队列调度机制的更多技巧通过上面的演示，我们已经可以运用队列进行多线程的执行任务，但是GCD的强大之处远远不止如此。 1、使用队列组如果有这样三个任务，A与B是没有关系的，他们可以并行执行，C必须在A,B结束之后才能执行，当然，实现这样的逻辑并不困难，使用KVO就可以实现，但是使用队列组处理这样的逻辑，代码会更加清晰简单。 可以使用dispatch_group_create()创建一个队列组，使用如下函数将队列添加到队列组中： 123void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 队列组中的队列是异步执行的，示例如下： 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个队列组 dispatch_group_t group=dispatch_group_create(); 创建一个异步队列 dispatch_queue_t queue=dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); //阻塞线程直到队列任务完成 dispatch_group_wait(group,DISPATCH_TIME_FOREVER); for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;over:%d&quot;,i); &#125;&#125; 打印出来的信息如下： 可以看出，队列中的任务是异步执行的，并且等待队列组中队列任务全部执行后才执行后面的任务。这样的做法在实际应用中我们很少使用，通常我们会把后续的任务在放在异步中执行，做法如下： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个队列组 dispatch_group_t group=dispatch_group_create(); //创建一个队列 dispatch_queue_t queue=dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //添加队列任务到队列组 dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); //队列组任务执行完后执行的任务 dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;over:%d&quot;,i); &#125; &#125;); for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;Finish:%d&quot;,i); &#125; &#125; 打印信息如下： 可以看出GCD的强大了吧，复杂的任务逻辑关系因为GCD变得十分清晰简单。 2、循环机制一开始我们就提到，GCD相比NSOperation的优势在于多核心的应用，更深得挖掘出了硬件的性能。GCD在多核方面的一个明显的特点就是循环机制。 123 dispatch_apply(10, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t i) &#123; NSLog(@&quot;%@:%zu&quot;,[NSThread currentThread],i); &#125;); 打印结果如下： 可以看出，程序的运行效率又会高许多。 3、消息传递机制dispatch_source_t类型的对象可以用来传递和接受某个消息，然后执行block方法，示例如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个数据对象，DISPATCH_SOURCE_TYPE_DATA_ADD的含义表示数据变化时相加 dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue()); //创建接收数据变化的句柄 dispatch_source_set_event_handler(source, ^&#123; NSLog(@&quot;%lu&quot;,dispatch_source_get_data(source)); &#125;); //启动 dispatch_resume(source); //设置数据 dispatch_source_merge_data(source, 1); //这步执行完之后会执行打印方法&#125; 4、发送和等待信号GCD中还有一个重要的概念是信号量。它的用法法消息的传递有所类似，通过代码来解释： 1234567 //创建一个信号，其中的参数为信号的初始值 dispatch_semaphore_t singer = dispatch_semaphore_create(0); //发送信号，使信号量+1 dispatch_semaphore_signal(singer); //等待信号，当信号量大于0时执行后面的方法，否则等待，第二个参数为等待的超时时长，下面设置的为一直等待 dispatch_semaphore_wait(singer, DISPATCH_TIME_FOREVER); NSLog(@&quot;123&quot;); 通过发送信号，可以试信号量+1，每次执行过等待信号后，信号量会-1；如此，我们可以很方便的控制不同队列中方法的执行流程。 5、挂起和开启任务队列GCD还提供了暂停与开始任务的方法，使用 void dispatch_suspend(dispatch_object_t object); 可以将队列或者队列组进行暂时的挂起，使用 void dispatch_resume(dispatch_object_t object); 将队列或者队列组重新开启。 需要注意的是，暂停队列时，队列中正在执行的任务并不会被中断，会挂起未开启的任务。 四、关于内存管理GCD虽然是基于C语言封装的框架，使用了面向对象的思想。因此，它的内存管理是需要我们注意的，不论是ARC或者MRC，我们都应该手动去处理这些对象。还好，GCD的内存管理思路和Object—C是兼容的，我们使用dispatch_retain()和dispatch_release()来将引用对象的计数进行加减。这一点十分重要，切记切记。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美七——为网页添加音乐","slug":"63标签之美七——为网页添加音乐","date":"2015-05-19T16:00:00.000Z","updated":"2021-06-29T01:56:51.181Z","comments":true,"path":"2015/05/20/63标签之美七——为网页添加音乐/","link":"","permalink":"http://huishao.cc/2015/05/20/63标签之美七——为网页添加音乐/","excerpt":"","text":"标签之美——为网页添加音乐一、添加音乐为网页添加音乐可以使用这个标签。其用法和插入图片类似。 标签的几个属性设置如下： src：音频路径 autostart：可是设置为ture或者false，代表是否自动播放。 loop：设置是否循环播放 hidden：是否隐藏播放界面 二、插入背景音乐使用标签插入背景音乐，其中插入路径的写法和插入图片类似。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS多线程编程之二——NSOperation与NSOperationQueue","slug":"62iOS多线程编程之二——NSOperation与NSOperationQueue","date":"2015-05-18T16:00:00.000Z","updated":"2021-06-29T01:55:36.085Z","comments":true,"path":"2015/05/19/62iOS多线程编程之二——NSOperation与NSOperationQueue/","link":"","permalink":"http://huishao.cc/2015/05/19/62iOS多线程编程之二——NSOperation与NSOperationQueue/","excerpt":"","text":"iOS多线程编程之二——NSOperation与NSOperationQueue一、NSOperation解析NSOperation是基于Objective-C封装的一套管理与执行线程操作的类。这个类是一个抽象类，通常情况下，我们会使用NSInvocationOperation和NSBlockOperation这两个子类进行多线程的开发，当然我们也可以写继承于NSOperation的类，封装我们自己的操作类。 1、NSOperation抽象类中提供的逻辑方法操作开始执行 1- (void)start; 在子类中可以重写这个方法，实现执行的方法 1- (void)main; 取消执行 1- (void)cancel; 获取当操作状态的几个属性 12345@property (readonly, getter=isCancelled) BOOL cancelled;//当前操作是否取消执行@property (readonly, getter=isExecuting) BOOL executing;//当前操作是否正在执行@property (readonly, getter=isFinished) BOOL finished;//当前操作是否执行结束@property (readonly, getter=isAsynchronous) BOOL asynchronous;//当前操作是否在异步线程中@property (readonly, getter=isReady) BOOL ready;//当前操作是否已经准备好 阻塞当前线程直到操作完成 1- (void)waitUntilFinished; 设置在操作队列中的优先级 1@property NSOperationQueuePriority queuePriority; 其中NSOperationQueuePriority的枚举如下： 1234567typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L,//优先级很低 NSOperationQueuePriorityLow = -4L,//优先级低 NSOperationQueuePriorityNormal = 0,//优先级普通 NSOperationQueuePriorityHigh = 4,//优先级高 NSOperationQueuePriorityVeryHigh = 8//优先级非常高&#125;; 设置操作完成后的回调block 1@property (copy) void (^completionBlock)(void); 设置操作的优先级 1@property double threadPriority; 设置操作的名称 1@property (copy) NSString *name; 2、带block的操作类实例——NSBlockOperationNSBlockOperation是NSOperation的一个子类，其可以异步的执行多个block，当所有的block都完成时，这个操作才算完成。 初始化方法： 1+ (instancetype)blockOperationWithBlock:(void (^)(void))block; 在操作中添加block 1- (void)addExecutionBlock:(void (^)(void))block; 添加进去的block的数组 1@property (readonly, copy) NSArray *executionBlocks; 示例如下： 1234567891011NSBlockOperation * opera = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;]; [opera addExecutionBlock:^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;]; [opera start]; 打印情况如下，可以看出，两个block块的执行是异步的： 3、使用NSInvocationOperation调用方法根据选择器创建一个对象 1- (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(id)arg; 通过Invocation创建一个对象 1- (instancetype)initWithInvocation:(NSInvocation *)inv; 这个类执行的操作是与调用它的线程同步的，示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSInvocationOperation * operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(log) object:nil]; [operation start]; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;-(void)log&#123; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 通过打印结果可以看出其执行的同步性。 二、操作之间的依赖关系依赖关系和优先级的作用很像，却也不同。如果一个操作A依赖于另一个操作B，那么只有当B操作完成后，A操作才会执行。操作添加依赖的 添加一个依赖： 1- (void)addDependency:(NSOperation *)op; 删除一个依赖 1- (void)removeDependency:(NSOperation *)op; 原则上说，一个操作对象的依赖可以添加多个，并且当所有依赖都执行完成后才会执行这个操作。 三、NSOperationQueue操作队列NSOperationQueue是操作队列类，通过上面的介绍，我们已经可以理解操作，并且操作默认的执行方式是串行的，尽管NSBlockOperation中的block块间是并行执行的，但其和外部操作依然是串行的。如果将操作放入操作队列中，则默认为并行执行的。 示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSOperationQueue * queue = [[NSOperationQueue alloc]init]; NSInvocationOperation * op1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(log) object:nil]; [queue addOperation:op1]; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125;-(void)log&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 打印信息如下： 可以看出来，队列的操作是在一个新的线程中执行的，并且操作队列之中的操作也都是异步执行的。 在操作队列中添加一个操作任务： 1- (void)addOperation:(NSOperation *)op; 在队列中插入一组操作任务，后面的参数设置是否队列中得任务都执行完成后再执行这一组操作： 1- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 在队列中添加一个block操作 1- (void)addOperationWithBlock:(void (^)(void))block; 获取操作队列中的所有操作的数组 1@property (readonly, copy) NSArray *operations; 获取操作队列中操作的个数 1@property (readonly) NSUInteger operationCount; 设置队列最大并行操作数量 1@property NSInteger maxConcurrentOperationCount; 设置是否暂停队列任务执行 1@property (getter=isSuspended) BOOL suspended; 设置队列名字 1@property (copy) NSString *name; 设置队列的优先级别（iOS8后支持） 1@property NSQualityOfService qualityOfService; 取消队列中所有操作任务 1- (void)cancelAllOperations; 阻塞当前线程，直到队列中所有任务完成 1- (void)waitUntilAllOperationsAreFinished; 获取当前执行的队列 1+ (NSOperationQueue *)currentQueue; 获取主线程中的操作队列 1+ (NSOperationQueue *)mainQueue; 四、队列中操作的执行顺序法则1、决定于依赖关系，只有当这个操作的依赖全部执行完成后，它才会被执行。 2、影响于优先级，优先级高的会先执行。 如有疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS多线程编程之一——NSThread线程管理","slug":"61iOS多线程编程之一——NSThread线程管理","date":"2015-05-18T16:00:00.000Z","updated":"2021-06-28T12:09:56.310Z","comments":true,"path":"2015/05/19/61iOS多线程编程之一——NSThread线程管理/","link":"","permalink":"http://huishao.cc/2015/05/19/61iOS多线程编程之一——NSThread线程管理/","excerpt":"","text":"iOS多线程编程之一——NSThread线程管理NSTread是iOS中进行多线程开发的一个类，其结构逻辑清晰，使用十分方便，但其封装度和性能不高，线程周期，加锁等需要手动处理。 一、NSThread类方法总结获取当前线程 1+ (NSThread *)currentThread; 这个方法通过开启一个新的线程执行选择器方法 1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 线程用法示例如下： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [NSThread detachNewThreadSelector:@selector(log) toTarget:self withObject:nil]; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125;-(void)log&#123; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 运行后的打印信息： 可以清晰的看出来，新启的线程和主线程是异步的。 程序是否是多线程执行 1+ (BOOL)isMultiThreaded; 线程字典，我们可以为特殊的线程设置键值对 1@property (readonly, retain) NSMutableDictionary *threadDictionary; 线程在某个时间执行 1+ (void)sleepUntilDate:(NSDate *)date; 线程在等待一个时间间隔后执行 1+ (void)sleepForTimeInterval:(NSTimeInterval)ti; 结束线程 1+ (void)exit; 设置线程的优先级，取值的范围为0-1，1的优先级最高 12+ (double)threadPriority;+ (BOOL)setThreadPriority:(double)p; 这个属性是iOS8之后的新特性，将优先级更人性化的封装了起来 1@property NSQualityOfService qualityOfService; NSQualityOfService的枚举如下： 123456789101112typedef NS_ENUM(NSInteger, NSQualityOfService) &#123; //刷新UI级别的线程 NSQualityOfServiceUserInteractive = 0x21, //用户请求的无需精确的任务的线程，例如点击加载邮件 NSQualityOfServiceUserInitiated = 0x19, //周期性的任务线程，例如定时刷新 NSQualityOfServiceUtility = 0x11, //后台任务的线程 NSQualityOfServiceBackground = 0x09, //优先级未知的线程，优先级介于UserInteractive和Utility之间 NSQualityOfServiceDefault = -1&#125;; 判断是否是主线程 1+ (BOOL)isMainThread; 获取主线程 1+ (NSThread *)mainThread; 二、属性与成员方法总结初始化方法，选择器可以带一个参数 1- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 线程是否正在执行 1@property (readonly, getter=isExecuting) BOOL executing; 线程是否已经执行结束 1@property (readonly, getter=isFinished) BOOL finished; 线程是否已经取消执行 1@property (readonly, getter=isCancelled) BOOL cancelled; 三、隐式的通过NSThread进行多线程编程NSObject的一个类别中提供了支持多线程的方法，如下： 这个函数指定在主线程执行一个选择器，arg是参数，wait是是否立即执行，如果YES，则会阻塞当前主线程的任务，NO则会等待当前任务结束后执行。 1- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait; 这个函数指定在某个线程执行选择器 1- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; 指定在后台线程中执行选择器 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发进阶——使用导航和附近兴趣点检索","slug":"60iOS原生地图开发进阶——使用导航和附近兴趣点检索","date":"2015-05-17T16:00:00.000Z","updated":"2021-06-25T02:25:06.638Z","comments":true,"path":"2015/05/18/60iOS原生地图开发进阶——使用导航和附近兴趣点检索/","link":"","permalink":"http://huishao.cc/2015/05/18/60iOS原生地图开发进阶——使用导航和附近兴趣点检索/","excerpt":"","text":"iOS原生地图开发进阶——使用导航和附近兴趣点检索iOS中的mapKit框架对国际化的支持非常出色。在前些篇博客中，对这个地图框架的基础用法和标注与覆盖物的添加进行了详细的介绍，这篇博客将介绍两个更加实用的功能的开发：线路导航与兴趣点搜索。前几篇博客的链接如下： 地图基础用法详解：http://my.oschina.net/u/2340880/blog/415360。 添加大头针与自定义标注：http://my.oschina.net/u/2340880/blog/415441。 添加地图覆盖物：http://my.oschina.net/u/2340880/blog/415611。 一、线路导航1、从几个类的关系说起(1)MKPlacemark 一个地点信息类，如下： 1234567@interface MKPlacemark : CLPlacemark &lt;MKAnnotation&gt;//初始化方法，通过给定一个经纬度和地点信息字典- (instancetype)initWithCoordinate:(CLLocationCoordinate2D)coordinate addressDictionary:(NSDictionary *)addressDictionary;//国家编码@property (nonatomic, readonly) NSString *countryCode;@end (2)MKMapItem 地点节点类，包含此节点的许多地点信息，如下： 1234567891011121314151617@interface MKMapItem : NSObject//当前节点的地点信息对象@property (nonatomic, readonly) MKPlacemark *placemark;//是否是当前位置@property (nonatomic, readonly) BOOL isCurrentLocation;//节点名称@property (nonatomic, copy) NSString *name;//电话号码@property (nonatomic, copy) NSString *phoneNumber;//网址@property (nonatomic, strong) NSURL *url;//将当前位置创建为节点+ (MKMapItem *)mapItemForCurrentLocation;//由一个位置信息创建节点- (instancetype)initWithPlacemark:(MKPlacemark *)placemark;@end (3)MKDirectionsRequest 导航请求类 123456789@interface MKDirectionsRequest : NSObject//起点节点- (MKMapItem *)source NS_AVAILABLE(10_9, 6_0);- (void)setSource:(MKMapItem *)source NS_AVAILABLE(10_9, 7_0);//目的地节点- (MKMapItem *)destination NS_AVAILABLE(10_9, 6_0);- (void)setDestination:(MKMapItem *)destination NS_AVAILABLE(10_9, 7_0);@end 这个类还有一些扩展的设置属性： @property (nonatomic) MKDirectionsTransportType transportType; 设置路线检索类型，枚举如下： 12345typedef NS_OPTIONS(NSUInteger, MKDirectionsTransportType) &#123; MKDirectionsTransportTypeAutomobile = 1 &lt;&lt; 0,//适合驾车时导航 MKDirectionsTransportTypeWalking = 1 &lt;&lt; 1,//适合步行时导航 MKDirectionsTransportTypeAny = 0x0FFFFFFF//任何情况&#125;; @property (nonatomic) BOOL requestsAlternateRoutes; 设置是否搜索多条线路 @property (nonatomic, copy) NSDate *departureDate; 设置出发日期 @property (nonatomic, copy) NSDate *arrivalDate; 设置到达日期 （4）MKDirections 从apple服务器获取数据的连接类 123456789101112@interface MKDirections : NSObject//初始化方法- (instancetype)initWithRequest:(MKDirectionsRequest *)request NS_DESIGNATED_INITIALIZER;//开始计算线路信息- (void)calculateDirectionsWithCompletionHandler:(MKDirectionsHandler)completionHandler;//开始计算时间信息- (void)calculateETAWithCompletionHandler:(MKETAHandler)completionHandler;//取消- (void)cancel;//是否正在计算@property (nonatomic, readonly, getter=isCalculating) BOOL calculating;@end (5)MKDirectionsResponse 线路信息结果类 12345@interface MKDirectionsResponse : NSObject@property (nonatomic, readonly) MKMapItem *source;//起点@property (nonatomic, readonly) MKMapItem *destination;//终点@property (nonatomic, readonly) NSArray *routes; //线路规划数组@end (6)MKETResponse 时间信息结果类 123456@interface MKETAResponse : NSObject@property (nonatomic, readonly) MKMapItem *source;//起点@property (nonatomic, readonly) MKMapItem *destination;//终点@property (nonatomic, readonly) NSTimeInterval expectedTravelTime;//耗时@end (7)MKRoute 线路信息类，导航的线路结果是这个类型的对象 12345678910111213@interface MKRoute : NSObject@property (nonatomic, readonly) NSString *name; //线路名称@property (nonatomic, readonly) NSArray *advisoryNotices; //注意事项@property (nonatomic, readonly) CLLocationDistance distance; //距离@property (nonatomic, readonly) NSTimeInterval expectedTravelTime;//耗时@property (nonatomic, readonly) MKDirectionsTransportType transportType; //检索的类型@property (nonatomic, readonly) MKPolyline *polyline; // 线路覆盖物@property (nonatomic, readonly) NSArray *steps; // 线路详情数组@end （8）MKRouteStep 线路详情信息类，线路中每一步的信息都是这个类的对象 123456789101112@interface MKRouteStep : NSObject@property (nonatomic, readonly) NSString *instructions; // 节点信息@property (nonatomic, readonly) NSString *notice; // 注意事项@property (nonatomic, readonly) MKPolyline *polyline; //线路覆盖物@property (nonatomic, readonly) CLLocationDistance distance; // 距离@property (nonatomic, readonly) MKDirectionsTransportType transportType; // 导航类型@end 看到上面如此多的类，你可能会觉得一头雾水，那么不用着急，类虽然繁杂，但他们之间的逻辑非常清晰，下面就通过一个例子来进行线路导航。 2、进行线路导航12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667- (void)viewDidLoad &#123; [super viewDidLoad]; //地图初始化设置 mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(5, 5)); mapView.mapType=MKMapTypeStandard; mapView.delegate=self; [self.view addSubview:mapView]; //导航设置 CLLocationCoordinate2D fromcoor=CLLocationCoordinate2DMake(39.26, 116.3); CLLocationCoordinate2D tocoor = CLLocationCoordinate2DMake(33.33, 113.33); //创建出发点和目的点信息 MKPlacemark *fromPlace = [[MKPlacemark alloc] initWithCoordinate:fromcoor addressDictionary:nil]; MKPlacemark *toPlace = [[MKPlacemark alloc]initWithCoordinate:tocoor addressDictionary:nil]; //创建出发节点和目的地节点 MKMapItem * fromItem = [[MKMapItem alloc]initWithPlacemark:fromPlace]; MKMapItem * toItem = [[MKMapItem alloc]initWithPlacemark:toPlace]; //初始化导航搜索请求 MKDirectionsRequest *request = [[MKDirectionsRequest alloc]init]; request.source=fromItem; request.destination=toItem; request.requestsAlternateRoutes=YES; //初始化请求检索 MKDirections *directions = [[MKDirections alloc]initWithRequest:request]; //开始检索，结果会返回在block中 [directions calculateDirectionsWithCompletionHandler:^(MKDirectionsResponse *response, NSError *error) &#123; if (error) &#123; NSLog(@&quot;error:%@&quot;,error); &#125;else&#123; //提取导航线路结果中的一条线路 MKRoute *route =response.routes[0]; //将线路中的每一步详情提取出来 NSArray * stepArray = [NSArray arrayWithArray:route.steps]; //进行遍历 for (int i=0; i&lt;stepArray.count; i++) &#123; //线路的详情节点 MKRouteStep * step = stepArray[i]; //在此节点处添加一个大头针 MKPointAnnotation * point = [[MKPointAnnotation alloc]init]; point.coordinate=step.polyline.coordinate; point.title=step.instructions; point.subtitle=step.notice; [mapView addAnnotation:point]; //将此段线路添加到地图上 [mapView addOverlay:step.polyline]; &#125; &#125; &#125;]; &#125;//地图覆盖物的代理方法-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKPolylineRenderer *renderer = [[MKPolylineRenderer alloc] initWithPolyline:overlay]; renderer.strokeColor = [UIColor redColor]; renderer.lineWidth = 4.0; return renderer;&#125;//标注的代理方法-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; MKPinAnnotationView * view= [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;anno&quot;]; view.canShowCallout=YES; return view;&#125; 效果如下： 二、附近兴趣点检索兴趣点检索的逻辑和导航线路检索的逻辑相似，直接通过代码来演示： 1234567891011121314151617181920212223 //创建一个位置信息对象，第一个参数为经纬度，第二个为纬度检索范围，单位为米，第三个为经度检索范围，单位为米 MKCoordinateRegion region = MKCoordinateRegionMakeWithDistance(tocoor, 5000, 5000); //初始化一个检索请求对象 MKLocalSearchRequest * req = [[MKLocalSearchRequest alloc]init]; //设置检索参数 req.region=region; //兴趣点关键字 req.naturalLanguageQuery=@&quot;hotal&quot;; //初始化检索 MKLocalSearch * ser = [[MKLocalSearch alloc]initWithRequest:req]; //开始检索，结果返回在block中 [ser startWithCompletionHandler:^(MKLocalSearchResponse *response, NSError *error) &#123; //兴趣点节点数组 NSArray * array = [NSArray arrayWithArray:response.mapItems]; for (int i=0; i&lt;array.count; i++) &#123; MKMapItem * item=array[i]; MKPointAnnotation * point = [[MKPointAnnotation alloc]init]; point.title=item.name; point.subtitle=item.phoneNumber; point.coordinate=item.placemark.coordinate; [mapView addAnnotation:point]; &#125; &#125;]; 效果如下： 如果疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南再续——地图覆盖物的应用","slug":"59iOS原生地图开发指南再续——地图覆盖物的应用","date":"2015-05-15T16:00:00.000Z","updated":"2021-06-25T02:23:37.847Z","comments":true,"path":"2015/05/16/59iOS原生地图开发指南再续——地图覆盖物的应用/","link":"","permalink":"http://huishao.cc/2015/05/16/59iOS原生地图开发指南再续——地图覆盖物的应用/","excerpt":"","text":"iOS原生地图开发指南再续——地图覆盖物的应用一、引言在前两篇博客中，将iOS系统的地图框架MapKit中地图的设置与应用以及关于添加大头针和自定义大头针的相关操作做了详细的介绍。链接如下：http://my.oschina.net/u/2340880/blog/415360、http://my.oschina.net/u/2340880/blog/415441。这篇博客中将进一步讨论关于地图添加覆盖物的使用方法。 二、添加地图覆盖物的逻辑原理地图覆盖物其实就是在地图上画一些东西，例如路径，范围等等。添加地图覆盖物的逻辑原理其实和添加大头针很相似。首先所有可以成为覆盖物的对象必须遵守MKOverlay这个协议，通过 - (void)addOverlay:(id )overlay; 将覆盖物添加在地图上，然后地图会调用代理方法 -(MKOverlayRenderer )mapView:(MKMapView )mapView rendererForOverlay:(id)overlay; 对覆盖物进行绘制，我们可以在这个方法中设置覆盖物，例如线宽，颜色等，注意，必须实现这个方法，覆盖物才会显示。 1、添加折线覆盖物12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //初始化地图对象 MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; //设置地图 _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); //设置代理 _mapView.delegate=self; //下面是C的语法，创建一个结构体数组 CLLocationCoordinate2D *coor; coor = malloc(sizeof(CLLocationCoordinate2D)*5); for (int i=0; i&lt;5; i++) &#123; CLLocationCoordinate2D po = CLLocationCoordinate2DMake(33.23+i*0.01, 113.112); coor[i]=po; &#125; //创建一个折线对象 MKPolyline * line = [MKPolyline polylineWithCoordinates:coor count:5]; [_mapView addOverlay:line]; [self.view addSubview:_mapView];&#125;//覆盖物绘制的代理-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; //折线覆盖物提供类 MKPolylineRenderer * render = [[MKPolylineRenderer alloc]initWithPolyline:overlay]; //设置线宽 render.lineWidth=3; //设置颜色 render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 2、添加圆形覆盖物1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); _mapView.delegate=self; //创建圆形覆盖物对象 MKCircle * cirle = [MKCircle circleWithCenterCoordinate:CLLocationCoordinate2DMake(33.23, 113.122) radius:500]; [_mapView addOverlay:cirle]; [self.view addSubview:_mapView];&#125;-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKCircleRenderer * render=[[MKCircleRenderer alloc]initWithCircle:overlay]; render.lineWidth=3; //填充颜色 render.fillColor=[UIColor greenColor]; //线条颜色 render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 3、添加多边形覆盖物1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); _mapView.delegate=self; CLLocationCoordinate2D *coor; coor = malloc(sizeof(CLLocationCoordinate2D)*6); for (int i=0; i&lt;5; i++) &#123; CLLocationCoordinate2D po = CLLocationCoordinate2DMake(33.23+i*0.01, 113.112+((i/2==0)?0.01:-0.01)); coor[i]=po; &#125; coor[5]=CLLocationCoordinate2DMake(33.23, 113.112); MKPolygon * gon = [MKPolygon polygonWithCoordinates:coor count:6]; [_mapView addOverlay:gon]; [self.view addSubview:_mapView];&#125;-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKPolygonRenderer * render = [[MKPolygonRenderer alloc]initWithPolygon:overlay]; render.lineWidth=3; render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南","slug":"57iOS原生地图开发指南","date":"2015-05-14T16:00:00.000Z","updated":"2021-06-25T02:21:13.139Z","comments":true,"path":"2015/05/15/57iOS原生地图开发指南/","link":"","permalink":"http://huishao.cc/2015/05/15/57iOS原生地图开发指南/","excerpt":"","text":"iOS原生地图开发详解 在上一篇博客中:http://my.oschina.net/u/2340880/blog/414760。对iOS中的定位服务进行了详细的介绍与参数说明，在开发中，地位服务往往与地图框架结合使用，这篇博客主要对iOS官方的地图框架MapKit.framework进行介绍。 一、初始化地图视图与相关属性方法介绍1、初始化地图视图地图视图的展示依赖于MKMapView这个类，这个类继承于UIView，因此和其他View的使用方法类似。在我们需要展现地图的地方： 12345- (void)viewDidLoad &#123; [super viewDidLoad]; MKMapView * mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; [self.view addSubview:mapView];&#125; 运行发现，一张世界地图就在我们的设备上了，apple内置的地图数据是由高德提供的。 2、系统提供的三种地图样式可以通过MKMapView的mapType这个属性设置地图的模式： @property (nonatomic) MKMapType mapType; 枚举如下： 12345typedef NS_ENUM(NSUInteger, MKMapType) &#123; MKMapTypeStandard = 0,//标准式的行政地图(会显示城市，街道等) MKMapTypeSatellite,//标准的卫星地图 MKMapTypeHybrid//混合地图(在卫星图上显示街道等名称)&#125;; 3、设置地图的中心和比例尺在百度地图等第三方地图服务的SDK中，都会提供一个类似zoomLevel比例尺的属性。通过官方的API设置这个属性有些麻烦，但是也更加灵活。首先，设置地图的中心位置和比例尺是通过region这个属性实现的。region结构体如下： 1234typedef struct &#123; CLLocationCoordinate2D center;//地图中心的经纬度 MKCoordinateSpan span;//地图显示的经纬度范围&#125; MKCoordinateRegion; 这个结构体中包含了两个结构体，其中CLLocationCoordinate2D很好理解，就是简单的经纬度，解释如下： 1234typedef struct &#123; CLLocationDegrees latitude;//纬度，北纬为正，南纬为负 CLLocationDegrees longitude;//经度，东经为正，西经为负&#125; CLLocationCoordinate2D; MKCoordinateSpan这个结构体比较复杂，如下： 1234typedef struct &#123; CLLocationDegrees latitudeDelta;//纬度范围 CLLocationDegrees longitudeDelta;//经度范围&#125; MKCoordinateSpan; 这个结构体定义的应该是一个范围，因为北纬南纬加起来180°，所以纬度范围的取值应为0-180。同理，经度范围的取值范围为0-360。 通过上面的介绍，我们举个例子，将北京市设为地图的中心区域，并且比例设置为显示北京大小。通过百度，首先知道北京市界的地理坐标为：北纬39”26’至41”03’，东经115”25’至 117”30’。北京市区坐标为：北纬39.9”，东经116. 3”。代码如下： 1mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(1.8, 2.05)); 运行后可以看到，北京市基本上是在地图中心的，效果如下： 注意：MKCoordinateSpan的显示范围是取决于大的一边的，比如如果我们这样写： 1MKCoordinateSpanMake(1.8, 360); 最后依然会显示整个世界地图。 - (void)setRegion:(MKCoordinateRegion)region animated:(BOOL)animated; 这个方法可以在设置后给地图加上动画效果 @property (nonatomic) CLLocationCoordinate2D centerCoordinate; 设置地图的中心点位置 - (void)setCenterCoordinate:(CLLocationCoordinate2D)coordinate animated:(BOOL)animated; 设置地图的中心点位置，并附带动画效果 4、坐标转换方法- (CGPoint)convertCoordinate:(CLLocationCoordinate2D)coordinate toPointToView:(UIView *)view; 将经纬度转换为视图上的坐标 - (CLLocationCoordinate2D)convertPoint:(CGPoint)point toCoordinateFromView:(UIView *)view; 将视图上的坐标转换为经纬度 - (CGRect)convertRegion:(MKCoordinateRegion)region toRectToView:(UIView *)view; 将地理显示的区域转换为视图上的坐标区域 - (MKCoordinateRegion)convertRect:(CGRect)rect toRegionFromView:(UIView *)view;将视图上的坐标区域转换为地理区域 5、MKMapView常用方法和属性@property (nonatomic, getter=isZoomEnabled) BOOL zoomEnabled; 设置是否允许捏合手势进行地图缩放 @property (nonatomic, getter=isScrollEnabled) BOOL scrollEnabled; 设置是否允许滑动 @property (nonatomic, getter=isRotateEnabled) BOOL rotateEnabled; 设置是否允许旋转地图 @property (nonatomic, getter=isPitchEnabled) BOOL pitchEnabled; 设置是否支持3D效果 @property (nonatomic) BOOL showsPointsOfInterest; 设置是否显示兴趣点，例如学校，医院等 @property (nonatomic) BOOL showsBuildings; 设置是否显示建筑物轮廓，只在标准的地图中有效 @property (nonatomic) BOOL showsUserLocation; 是否显示用户位置 @property (nonatomic) MKUserTrackingMode userTrackingMode; - (void)setUserTrackingMode:(MKUserTrackingMode)mode animated:(BOOL)animated; 设置更新用户位置的模式,当显示用户位置设置为YES，这个方法也设置了后，地图框架为我们直接集成了定位，地图上就会显示我们的位置，模式的枚举如下： 12345typedef NS_ENUM(NSInteger, MKUserTrackingMode) &#123; MKUserTrackingModeNone = 0, // 不跟踪用户位置 MKUserTrackingModeFollow, // 跟踪用户位置 MKUserTrackingModeFollowWithHeading, // 当方向改变时跟踪用户位置&#125; @property (nonatomic, readonly) MKUserLocation *userLocation; 获取用户位置的标注 @property (nonatomic, readonly, getter=isUserLocationVisible) BOOL userLocationVisible; 获取用户位置是否可见 - (void)addAnnotation:(id )annotation; 在地图上添加一个标注 - (void)addAnnotations:(NSArray *)annotations;在地图上添加一组标注- (void)removeAnnotation:(id )annotation; 移除一个标注 - (void)removeAnnotations:(NSArray *)annotations; 移除一组标注 @property (nonatomic, readonly) NSArray *annotations; 获取所有标注数组 - (MKAnnotationView *)viewForAnnotation:(id )annotation; 获取标注的视图 - (MKAnnotationView )dequeueReusableAnnotationViewWithIdentifier:(NSString )identifier; 获取复用的标注 - (void)selectAnnotation:(id )annotation animated:(BOOL)animated; 选中一个标注 - (void)deselectAnnotation:(id )annotation animated:(BOOL)animated; 取消选中一个标注 @property (nonatomic, copy) NSArray *selectedAnnotations; 选中标注的数组 - (void)addOverlay:(id )overlay level:(MKOverlayLevel)level; 添加一个地图覆盖物，level是设置一个层级，枚举如下： 1234typedef NS_ENUM(NSInteger, MKOverlayLevel) &#123; MKOverlayLevelAboveRoads = 0, // 覆盖物位于道路之上 MKOverlayLevelAboveLabels//覆盖物位于标签之上&#125; - (void)addOverlays:(NSArray *)overlays level:(MKOverlayLevel)level; 添加一组地图覆盖物 - (void)removeOverlay:(id )overlay; 移除一个地图覆盖物 - (void)removeOverlays:(NSArray *)overlays; 移除一组地图覆盖物 - (void)insertOverlay:(id )overlay atIndex:(NSUInteger)index level:(MKOverlayLevel)level; 在索引处插入一个地图覆盖物 - (void)insertOverlay:(id )overlay aboveOverlay:(id )sibling; 将一个地图覆盖物插在到某个覆盖物之上 - (void)insertOverlay:(id )overlay belowOverlay:(id )sibling; 将一个地图覆盖物插入到某个覆盖物之下 - (void)exchangeOverlay:(id )overlay1 withOverlay:(id )overlay2; 替换一个地图覆盖物 @property (nonatomic, readonly) NSArray *overlays; 地图覆盖物数组 - (NSArray *)overlaysInLevel:(MKOverlayLevel)level; 层级属性下的东土覆盖物数组 二、MKMapViewDelegate相关方法解读- (void)mapView:(MKMapView *)mapView regionWillChangeAnimated:(BOOL)animated; 地图显示位置将要改变时调用的方法 - (void)mapView:(MKMapView *)mapView regionDidChangeAnimated:(BOOL)animated; 地图显示位置已经改变时调用的方法 - (void)mapViewWillStartLoadingMap:(MKMapView *)mapView; 地图将要加载时调用的方法 - (void)mapViewDidFinishLoadingMap:(MKMapView *)mapView; 地图加载完成时执行的方法 - (void)mapViewDidFailLoadingMap:(MKMapView )mapView withError:(NSError )error; 地图加载失败时执行的方法 - (MKAnnotationView )mapView:(MKMapView )mapView viewForAnnotation:(id )annotation; 渲染标注视图时调用的方法，可以通过这个方法自定义标注视图 - (void)mapView:(MKMapView )mapView didAddAnnotationViews:(NSArray )views; 标注添加完成后调用的方法 - (void)mapView:(MKMapView )mapView didSelectAnnotationView:(MKAnnotationView )view; 选中标注时调用的方法 - (void)mapView:(MKMapView )mapView didDeselectAnnotationView:(MKAnnotationView )view; 取消选中标注时调用的方法 - (void)mapViewWillStartLocatingUser:(MKMapView *)mapView; 将要开始定位用户位置时调用的方法 - (void)mapViewDidStopLocatingUser:(MKMapView *)mapView; 停止定位用户位置时调用的方法 - (void)mapView:(MKMapView )mapView didUpdateUserLocation:(MKUserLocation )userLocation; 更新用户位置时调用的方法 - (void)mapView:(MKMapView )mapView didFailToLocateUserWithError:(NSError )error; 更新用户位置失败时调用的方法 - (void)mapView:(MKMapView )mapView annotationView:(MKAnnotationView )view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState; 标注拖动状态改变调用的方法，MKAnnotationViewDragState的枚举如下： 1234567typedef NS_ENUM(NSUInteger, MKAnnotationViewDragState) &#123; MKAnnotationViewDragStateNone = 0, // 初始状态 MKAnnotationViewDragStateStarting, // 开始拖动时 MKAnnotationViewDragStateDragging, // 正在拖动 MKAnnotationViewDragStateCanceling, // 取消拖动 MKAnnotationViewDragStateEnding // 结束拖动&#125;; - (void)mapView:(MKMapView *)mapView didChangeUserTrackingMode:(MKUserTrackingMode)mode animated:(BOOL)animated; 定位用户位置模式改变时调用的方法 - (MKOverlayView )mapView:(MKMapView )mapView viewForOverlay:(id )overlay; 渲染覆盖物视图时调用的方法，可以自定义覆盖物视图 - (void)mapView:(MKMapView )mapView didAddOverlayViews:(NSArray )overlayViews; 添加完成覆盖物数组执行的方法 备注：在iOS9中，地图类型的枚举又添加了两种： 1234567typedef NS_ENUM(NSUInteger, MKMapType) &#123; MKMapTypeStandard = 0,//标准 MKMapTypeSatellite,//卫星 MKMapTypeHybrid,//混合 MKMapTypeSatelliteFlyover NS_ENUM_AVAILABLE(10_11, 9_0),//立体卫星 MKMapTypeHybridFlyover NS_ENUM_AVAILABLE(10_11, 9_0),//立体混合&#125; NS_ENUM_AVAILABLE(10_9, 3_0) __WATCHOS_PROHIBITED; 注：因篇幅限制，关于系统大头针和自定义标注的应用、地图覆盖物的应用将在下一篇博客中讨论。 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南续——大头针与自定义标注","slug":"58iOS原生地图开发指南续——大头针与自定义标注","date":"2015-05-14T16:00:00.000Z","updated":"2021-06-25T02:22:30.328Z","comments":true,"path":"2015/05/15/58iOS原生地图开发指南续——大头针与自定义标注/","link":"","permalink":"http://huishao.cc/2015/05/15/58iOS原生地图开发指南续——大头针与自定义标注/","excerpt":"","text":"iOS原生地图开发指南续——大头针与自定义标注在上一篇博客中http://my.oschina.net/u/2340880/blog/415360系统总结了iOS原生地图框架MapKit中主体地图的设置与应用。这篇是上一篇的一个后续，总结了系统的大头针视图以及自定义标注视图的方法。 一、先来认识一个协议MKAnnotation官方文档告诉我们，所有标注的类必须遵守这个协议。所以可以了解，标注这个概念在逻辑属性和视图上是分开的。先来看下这个协议声明了哪些方法： 123456789@protocol MKAnnotation &lt;NSObject&gt;@property (nonatomic, readonly) CLLocationCoordinate2D coordinate;//地理坐标位置@optional@property (nonatomic, readonly, copy) NSString *title;//标题@property (nonatomic, readonly, copy) NSString *subtitle;//副标题//拖动时调用- (void)setCoordinate:(CLLocationCoordinate2D)newCoordinate;@end 二、创建一个系统标注大头针123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化地图 mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; //设置代理 mapView.delegate=self; //设置位置 mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(1.8, 1)); mapView.mapType=MKMapTypeStandard; //初始化一个大头针类 MKPointAnnotation * ann = [[MKPointAnnotation alloc]init]; //设置大头针坐标 ann.coordinate=CLLocationCoordinate2DMake(39.26, 116.3); ann.title=@&quot;我&quot;; ann.subtitle=@&quot;看这里&quot;; [mapView addAnnotation:ann]; [self.view addSubview:mapView];&#125; 效果如下： 重绘大头针视图，大头针渲染时会调用地图代理的方法，我们可以重写这个方法进行大头针的重绘，来更改其颜色： 123456-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; //创建一个系统大头针对象 MKPinAnnotationView * view = [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;pin&quot;]; view.pinColor=MKPinAnnotationColorGreen;//设置颜色为绿色 return view;&#125; 效果如下： MKAnnotationView是标注的视图类，一会我们通过它来自定义我们自己的标注，先来看MKPinAnnotationView这个类，这个类继承于MKAnnotationView，是一个大头针视图类。这个类根简单，只有一下两个属性： @property (nonatomic) MKPinAnnotationColor pinColor; 设置大头针的颜色，枚举如下： 12345typedef NS_ENUM(NSUInteger, MKPinAnnotationColor) &#123; MKPinAnnotationColorRed = 0,//红色 MKPinAnnotationColorGreen,//绿色 MKPinAnnotationColorPurple//紫色&#125;; @property (nonatomic) BOOL animatesDrop; 设置添加时是否显示降落动画 三、自定义标注视图123456789101112131415161718-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; MKAnnotationView * view = [[MKAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;annotation&quot;]; //设置标注的图片 view.image=[UIImage imageNamed:@&quot;保温车0.png&quot;]; //点击显示图详情视图 必须MKPointAnnotation对象设置了标题和副标题 view.canShowCallout=YES; //创建了两个view UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 50, 50)]; view1.backgroundColor=[UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 50)]; view2.backgroundColor=[UIColor blueColor]; //设置左右辅助视图 view.leftCalloutAccessoryView=view1; view.rightCalloutAccessoryView=view2; //设置拖拽 可以通过点击不放进行拖拽 view.draggable=YES; return view;&#125; 效果如下： 四、标注视图类MKAnnotationView的其他常用属性解读@property (nonatomic) CGPoint centerOffset; 视图中心的偏移量 @property (nonatomic) CGPoint calloutOffset; 点击后弹出视图的偏移量 @property (nonatomic, getter=isEnabled) BOOL enabled; 设置是否有效 @property (nonatomic, getter=isHighlighted) BOOL highlighted; 是否高亮状态 @property (nonatomic) CGPoint leftCalloutOffset; 设置左辅助视图的偏移量 @property (nonatomic) CGPoint rightCalloutOffset; 设置右辅助视图的偏移量 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美六——滚动字幕的应用","slug":"56标签之美六——滚动字幕的应用","date":"2015-05-13T16:00:00.000Z","updated":"2021-06-25T02:20:03.143Z","comments":true,"path":"2015/05/14/56标签之美六——滚动字幕的应用/","link":"","permalink":"http://huishao.cc/2015/05/14/56标签之美六——滚动字幕的应用/","excerpt":"","text":"标签之美——滚动字幕的应用在网页中，我们经常可以看到一些滚动出现的字幕，按钮等内容。滚动字幕的应用会使网页的内容更加生动紧凑。 1、滚动标签 将滚动显示的文字放在这个标签内，就可以实现滚动字幕。这个标签有一个behavior属性，可以设置滚动方式： scroll：循环滚动，默认的滚动方式 slide：只滚动一次 alternate：左右来回滚动 2、设置字幕背景颜色 123&lt;body&gt;&lt;marquee behavior=&quot;alternate&quot; bgcolor=&quot;#F4070B&quot;&gt;这里是滚动字幕&lt;/marquee&gt;&lt;/body&gt; 3、设置字幕滚动方向：direction属性，可以设置的值有：left，right，up，down。分别表示从右向左滚动，从左向右滚动，从下向上滚动，从上向下滚动。 4、设置字幕的滚动速度 通过设置scrollamount属性来更改字幕的滚动速度，数值越大，速度越快。 5、设置字幕滚动时间间隔 scrolldelay可以来设置字幕的停顿时间间隔，单位是毫秒。效果和速度属性相似。 6、设置滚动次数 loop属性可以设置滚动次数，-1则为循环滚动。 7、设置鼠标滑过时停止滚动，移开时继续滚动： 123&lt;body&gt;&lt;marquee direction=&quot;down&quot; onMouseOver=&quot;this.stop()&quot; onMouseOut=&quot;this.start()&quot;&gt;这里是滚动字幕&lt;/marquee&gt;&lt;/body&gt; 滚动字幕也支持图片的滚动，将文字换位图片即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS定位服务的应用","slug":"55IOS定位服务的应用","date":"2015-05-13T16:00:00.000Z","updated":"2021-06-25T02:19:06.778Z","comments":true,"path":"2015/05/14/55IOS定位服务的应用/","link":"","permalink":"http://huishao.cc/2015/05/14/55IOS定位服务的应用/","excerpt":"","text":"iOS定位服务的应用一、授权的申请与设置在IOS8之后，IOS的定位服务做了优化，若要使用定位服务，必须先获取用户的授权。 首先需要在info.plist文件中添加一个键：NSLocationAlwaysUsageDescription或者NSLocationWhenInUseUsageDescription。其中NSLocationAlwaysUsageDescription是要始终使用定位服务，NSLocationWhenInUseUsageDescription是只在前台使用定位服务。 IOS8中CLLocationManager新增的两个新方法： - (void)requestAlwaysAuthorization; - (void)requestWhenInUseAuthorization; 这两个方法对应上面的两个键值，用于在代码中申请定位服务权限。 二、定位服务相关方法IOS的定位服务在CoreLocation.framework框架内，首先引入这个框架： 开启定位服务的代码非常简单，示例如下： 12345678910111213141516171819#import &quot;ViewController.h&quot;#import &lt;CoreLocation/CoreLocation.h&gt;@interface ViewController ()&lt;CLLocationManagerDelegate&gt;//定位服务的代理@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; CLLocationManager* manager = [[CLLocationManager alloc]init];//初始化一个定位管理对象 [manager requestWhenInUseAuthorization];//申请定位服务权限 manager.delegate=self;//设置代理 [manager startUpdatingLocation];//开启定位服务&#125;//定位位置改变后调用的函数-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations&#123; NSLog(@&quot;%@&quot;,locations);&#125;@end CLLocationManager相关方法解读： + (BOOL)locationServicesEnabled; 判断设备是否支持定位服务 + (BOOL)headingAvailable; 判断设备是否支持航向信息功能(海拔，速度，方向等传感器的支持) + (BOOL)significantLocationChangeMonitoringAvailable; 判断设备是否支持更新位置信息 + (BOOL)isMonitoringAvailableForClass:(Class)regionClass; 判断设备是否支持区域检测，regionClass是地图框架中的类。 + (BOOL)isRangingAvailabl; 判断设备是否支持蓝牙测距 + (CLAuthorizationStatus)authorizationStatus; 获得定位服务的授权状态，CLAuthorizationStatus的枚举如下： 1234567typedef NS_ENUM(int, CLAuthorizationStatus) &#123; kCLAuthorizationStatusNotDetermined = 0,//用户还没有做选择 kCLAuthorizationStatusRestricted,//应用拒接使用定位服务 kCLAuthorizationStatusDenied,//用户拒绝授权 kCLAuthorizationStatusAuthorizedAlways,//8.0后可用，始终授权位置服务 kCLAuthorizationStatusAuthorizedWhenInUse,//8.0后可用，只在前台授权位置服务&#125;; @property(assign, nonatomic) CLActivityType activityType; 这个属性用来设置位置更新的模式，枚举如下： 123456typedef NS_ENUM(NSInteger, CLActivityType) &#123; CLActivityTypeOther = 1,//未知模式，默认为此 CLActivityTypeAutomotiveNavigation, //车辆导航模式 CLActivityTypeFitness, //行人模式 CLActivityTypeOtherNavigation //其他交通工具模式&#125;; 模式的应用可以起到节省电量的作用，例如车辆导航模式，当汽车停止时，位置更新服务会暂停。 @property(assign, nonatomic) CLLocationDistance distanceFilter; 设置位置更新的敏感范围，单位为米。 @property(assign, nonatomic) CLLocationAccuracy desiredAccuracy; 设置定位服务的精确度，系统定义好的几个参数如下： kCLLocationAccuracyBestForNavigation;//导航最高精确kCLLocationAccuracyBest;//高精确kCLLocationAccuracyNearestTenMeters;//10米kCLLocationAccuracyHundredMeters;//百米kCLLocationAccuracyKilometer;//千米kCLLocationAccuracyThreeKilometers;//三公里 @property(assign, nonatomic) BOOL pausesLocationUpdatesAutomatically; 设置位置更新是否自动暂停 @property(readonly, nonatomic, copy) CLLocation *location; 最后一次更新的位置信息，只读属性 @property(assign, nonatomic) CLLocationDegrees headingFilter; 相关航向更新的敏感范围 @property(assign, nonatomic) CLDeviceOrientation headingOrientation; 定位航向时的参照方向默认为正北，枚举如下： 123456789typedef NS_ENUM(int, CLDeviceOrientation) &#123; CLDeviceOrientationUnknown = 0,//方向未知 CLDeviceOrientationPortrait,//纵向模式 CLDeviceOrientationPortraitUpsideDown,//纵向倒置模式 CLDeviceOrientationLandscapeLeft,//左向横向模式 CLDeviceOrientationLandscapeRight,//右向横向模式 CLDeviceOrientationFaceUp,//水平屏幕向上模式 CLDeviceOrientationFaceDown//水平屏幕下模式&#125;; @property(readonly, nonatomic, copy) CLHeading *heading; 最后一个定位得到的航向信息 - (void)startUpdatingLocation; 开启定位服务 - (void)stopUpdatingLocation; 停止定位服务 - (void)startUpdatingHeading; 开启航向地理信息服务 - (void)stopUpdatingHeading; 停止航向地理信息服务 三、定位服务代理的相关方法- (void)locationManager:(CLLocationManager )manager didUpdateLocations:(NSArray )locations； 位置更新后调用的方法，数组中是所有定位到的位置信息，最后一个是最新的。 - (void)locationManager:(CLLocationManager )manager didUpdateHeading:(CLHeading )newHeading； 航向信息更新后调用的方法 - (void)locationManager:(CLLocationManager )manager didFailWithError:(NSError )error; 定位异常时调用的方法 四、定位服务获取到的位置对象上面也提到，定位后返回的数组中存放的都是CLLocation对象，这里面有很详细的位置信息，属性如下： @property(readonly, nonatomic) CLLocationCoordinate2D coordinate; 经纬度属性，CLLocationCoordinate2D是一个结构体，如下： 1234typedef struct &#123; CLLocationDegrees latitude;//纬度 CLLocationDegrees longitude;//经度&#125; CLLocationCoordinate2D; @property(readonly, nonatomic) CLLocationDistance altitude; 海拔高度，浮点型 @property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy; 水平方向的容错半径 @property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy; 竖直方向的容错半径 @property(readonly, nonatomic) CLLocationDirection course; 设备前进的方向，取值范围为0-359.9，相对正北方向 @property(readonly, nonatomic) CLLocationSpeed speed; 速度，单位为m/s @property(readonly, nonatomic, copy) NSDate *timestamp; 定位时的时间戳 五、航标定位得到的航标信息对象CLHeading对象的属性信息： @property(readonly, nonatomic) CLLocationDirection magneticHeading; 设备朝向航标方向，0为北磁极。 @property(readonly, nonatomic) CLLocationDirection trueHeading; 设备朝向真实方向，0被地理上的北极 @property(readonly, nonatomic) CLLocationDirection headingAccuracy; 方向偏差 @property(readonly, nonatomic) CLHeadingComponentValue x; x轴的方向值 @property(readonly, nonatomic) CLHeadingComponentValue y; y轴方向值 @property(readonly, nonatomic) CLHeadingComponentValue z; z轴方向值 @property(readonly, nonatomic, copy) NSDate *timestamp; 方向定位时间戳 如有疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美五——网页表格的设计","slug":"54标签之美五——网页表格的设计","date":"2015-05-12T16:00:00.000Z","updated":"2021-06-25T02:16:52.682Z","comments":true,"path":"2015/05/13/54标签之美五——网页表格的设计/","link":"","permalink":"http://huishao.cc/2015/05/13/54标签之美五——网页表格的设计/","excerpt":"","text":"标签之美——网页表格的使用通过表格，可以使网页排版更加清晰，形式更加简洁漂亮。 一、表格布局中三个重要的标签1、：表格的开始和结束标签，行列的布局都在标签内。 2、行标签的开始和结束 3、列标签的开始和结束 行标签在列标签的外层，不能单独使用，其中必须至少有一列。示例如下： 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;!--为了便于观察，设置一个边框--&gt;&lt;tr&gt;&lt;td&gt;表格的内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 效果如下： 二、单元格设置的相关标签1、单元格表头 这个标签用来设置表格的表头，作用和列标签相似，只是字体是加黑的。 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 2、表格宽度属性和高度属性width,height 这两个属性可以设置在标签里，也可以设置在和中，作用域会不同。 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th width=&quot;200&quot;&gt;1&lt;/th&gt;&lt;th width=&quot;100&quot;&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 3、设置表格背景图片background 这个属性和尺寸属性用法一样，写在相应的标签里，就是相应的背景图案，设置的是图片的路径。 4、设置表格行列间距cellspacing 1234567&lt;body&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;20&quot;&gt;&lt;tr&gt;&lt;th width=&quot;200&quot;&gt;1&lt;/th&gt;&lt;th width=&quot;100&quot;&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 5、设置单元格内容偏移量 cellpadding 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 三、表格的边框属性和对齐模式灵活的应用边框，可以使表格看起来更加整洁有序。 1、边框宽度属性border 2、边框的颜色属性bordercolor 3、不显示外边框frame=”void” 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;void&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 4、设置frame=”hsides”则只显示上下外边框 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 5、设置frame=”vsides”则只显示左右外边框 6、单独显示边框的frame值分别为： 上：above 下：below 左：lhs 右：rhs 7、设置表格对齐模式： 水平对齐模式：align 表格的align属性可以设置对齐模式，center,left,right分别对应居中，左对齐，右对齐。 垂直对齐模式：valign 和水平对齐模式相似，这个属性的值为：middle，top，bottom对应了中间对齐，上对齐和下对齐。 四、表格行和列的操作1、行的合并：rowspan 12345678910&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;第一行&lt;/td&gt;&lt;td&gt;第一行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第二行&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 2、列的合并colspan 12345678910&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;第一列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 3、表格的标题标签 1234567891011&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot; &gt;&lt;caption&gt;标题&lt;/caption&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;第一列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"分分钟搞定IOS远程消息推送","slug":"53分分钟搞定IOS远程消息推送","date":"2015-05-11T16:00:00.000Z","updated":"2021-06-25T02:13:59.786Z","comments":true,"path":"2015/05/12/53分分钟搞定IOS远程消息推送/","link":"","permalink":"http://huishao.cc/2015/05/12/53分分钟搞定IOS远程消息推送/","excerpt":"","text":"分分钟搞定IOS远程消息推送一、引言IOS中消息的推送有两种方式，分别是本地推送和远程推送，本地推送在http://my.oschina.net/u/2340880/blog/405491这篇博客中有详细的介绍，这里主要讨论远程推送的流程与配置过程。 二、远程推送机制的原理1、从一张很火的图说起搜索IOS远程推送，你总能看到一张如下的流程示意图，因为这张图确实很火，所以我也将它引用在此： 这张图示意的很清晰，大致意思是这样：你的应用服务端将消息发送到apple的APNS服务器，APNS服务器将消息推送到指定的Iphone，最后由Iphone负责将消息推送至你的APP。在此先不说这个过程是如何实现的，仅仅看这个流程，你可能会觉得，在你们服务端和客户端之间增加了一个apple的APNS，不是增加开发者的负担么？其实结果恰恰相反，因为apple对推送的统一管理，使我们开发者的工作变得异常简单。 2、服务端如何连接到客户端的如果你是做android开发的，你一定非常了解长链接与心跳包。事实上，大部分的android应用的推送也确实是通过长链接来实现的。因为android系统的开放性，APP是很容易做到自启动和后台长链接的，而心跳验证，就是始终保证长链接属于接通状态，然后由服务端直接推送消息。如果IOS开发者也采用这种思路，就十分困难了，在IOS中想要保持一个APP服务始终不被系统杀死，我只能说太难了。通过上面的流程图，对比android的推送思路，我们很容易明白，IOS中其实也始终有一个长链接，那就是系统本身，这个长链接始终与APNS服务器相连，然后统一管理所有应用程序的推送。 3、这是IOS推送机制的优势？下面的这些，只是我个人的一些看法。系统并无优劣，优劣在于个人喜好。 1、因为推送的服务端是appleID的验证用户，推送可靠性会高。 2、所有推送消息由APNS统一管理，效率高。 3、在客户端只需系统维护一个长链接，节省了用户流量消耗和手机的性能消耗，并且提高了安全性，使得有恶意推送和流氓软件的几率降低。 三、分分钟让你的APP收到远程推送1、工欲善其事、必先利其器——创建推送证书(1)请求CSR文件 在MAC应用程序中找到钥匙串访问，打开它。 点击选项栏中的钥匙串访问中的证书助理： 选择从证书颁发机构申请证书: 填写电子邮件和名称，选择储存到磁盘，然后继续。 这时，我们存储的地方有了这样一个文件：CertificateSigningRequest.certSigningRequest。 (2)导出密钥文件 打开钥匙串，会发现多了一对密钥，名字就是上面你填写的常用名称。 我们选择专用密钥进行导出，然后设置一个我们自己的密码： 这时候我们又有了一个后缀名为.p12的文件。 (3)创建AppId 到https://developer.apple.com的member Center： 用你付过费的开发者appleID登陆后，选择Certificates: 如果你的项目已经创建了APP id，则可以不用重新创建，但是你创建的APP id必须要支持远程推送。如果还没有创建，点击加号，创建一个： 之后的界面中APP ID有两种类型：Explicit和Wildcard，分别是特殊的和通配的，我们需要推送功能，这个ID不能是通配的，所以我们选择第一个。 这里需要填的的Bundle ID必须和我们App中的一致： 在APP ID的服务设置中，将Push Notification勾选上，点击continue。 之后点击submit，最后点击Done。这时我们的APP IDs列表中会出现我们刚才创建的APP ID。 (4)创建证书 点击我们刚才创建的APP ID，你会看到Push Notification一行为未设定的。我们点击Edit。 在Push Notifications设置里是如下界面，development是开发证书，Production是产品证书，我们现在需要测试，所以用Development证书，上线时要使用Production证书。点击Create Certificate。 接着点击continue，如下界面会让我们选择一个CSR文件，我们第一步创建的文件在这里派上用场了，选择那个文件，点击Generate。 将创建好的证书下载到电脑中： 至此，我们已经有了三个文件了，分别是CSR文件，.p12文件，.cer文件。要将这三个文件放在同一个目录下。.cer文件分为测试和产品两个，需要哪个自行选择。写了这么多，我们的准备工作可算是做完了，不要灰心，其实你的推送工作基本上也就做完了。只是申请过程麻烦了一些，但工程的代码，我们几乎不用怎么配置。 2、兵马未动、粮草先行——服务端进行信息推送的设置(1)处理证书 打开终端cd到我们上面得到的三个文件所在的目录。 在终端执行如下命令： 1$ openssl x509 -in aps_development.cer -inform der -out PushCert.pem aps_development.cer是刚才生成的.cer文件的文件名。会在当前文件夹中生成一个pem文件，这是我们服务端对应的证书。 再执行如下命令： 1$ openssl pkcs12 -nocerts -out PushKey.pem -in key.p12 key.p12是上面生成的.p12文件的文件名。这时终端会让输入密码，这里的密码就是上面我们设置的密钥的密码。输入密码后回车，如果密码正确，会让我们输入新密码(一定切记)，输入两次后，终端会提示成功创建PushKey.pem文件。 最后一步，将我们生成的两个pem文件和成为一个： 1$ cat PushCert.pem PushKey.pem &gt; ck.pem (2)测试证书是否可用 在终端执行下面的命令： 1$ telnet gateway.sandbox.push.apple.com 2195 等一小会，如果终端显示下面的情形，则证书正常。 然后执行如下命令： 1openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert PushChatCert.pem -key PushKey.pem 输入密码后回车显示如下的结果则连接成功： 3、天涯海角、一步之遥——应用程序中的配置在我们项目的AppDelegate中添加如下代码： 12345678910111213141516171819202122- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;double version = [[UIDevice currentDevice].systemVersion doubleValue];//判定系统版本。if(version&gt;=8.0f)&#123; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:(UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound|UIRemoteNotificationTypeAlert) categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; &#125;else&#123; UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes]; &#125;&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; // 处理推送消息 NSLog(@&quot;userinfo:%@&quot;,userInfo); NSLog(@&quot;收到推送消息:%@&quot;,[[userInfo objectForKey:@&quot;aps&quot;] objectForKey:@&quot;alert&quot;]);&#125;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *) error &#123; NSLog(@&quot;Registfail%@&quot;,error);&#125;-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; NSLog(@&quot;%@&quot;,deviceToken);//这里的Token就是我们设备要告诉服务端的Token码&#125; 下面是网上搜的PHP服务端的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php//这里填写设备的Token码$deviceToken = &apos;74314cc9e8f747e2fa96c2c1585c830cdf994de6b453ce9fa1c09ba396b2f9e9&apos;;//这里是密钥密码$passphrase = &apos;abcabc&apos;;//推送的消息$message = &apos;这是一条推送消息&apos;;////////////////////////////////////////////////////////////////////////////////$ctx = stream_context_create();stream_context_set_option($ctx, &apos;ssl&apos;, &apos;local_cert&apos;, &apos;ck.pem&apos;);//ck文件stream_context_set_option($ctx, &apos;ssl&apos;, &apos;passphrase&apos;, $passphrase);// Open a connection to the APNS server$fp = stream_socket_client( &apos;ssl://gateway.sandbox.push.apple.com:2195&apos;, $err, $errstr, 60, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);if (!$fp) exit(&quot;Failed to connect: $err $errstr&quot; . PHP_EOL);echo &apos;Connected to APNS&apos; . PHP_EOL;// Create the payload body$body[&apos;aps&apos;] = array( &apos;alert&apos; =&gt; $message, &apos;sound&apos; =&gt; &apos;default&apos; );// Encode the payload as JSON$payload = json_encode($body);// Build the binary notification$msg = chr(0) . pack(&apos;n&apos;, 32) . pack(&apos;H*&apos;, $deviceToken) . pack(&apos;n&apos;, strlen($payload)) . $payload;// Send it to the server$result = fwrite($fp, $msg, strlen($msg));if (!$result) echo &apos;Message not delivered&apos; . PHP_EOL;else echo &apos;Message successfully delivered&apos; . PHP_EOL;// Close the connection to the serverfclose($fp); ?&gt; 把上面的PHP文件和我们的ck文件放在同一目录下。在终端的当前目录下，执行如下命令： 1$php push.php 如果我们的设备王略正常，就可收到推送的消息了： 四、几点注意1、如果终端发送信息时提示密钥不可访问之类的错误，请检查是否cd到了当前目录，如果还存在问题，将密钥部分从新生成一次。 2、注意PHP代码中的字符为英文字符。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美四——为网页添加绚丽多彩的图像","slug":"52标签之美四——为网页添加绚丽多彩的图像","date":"2015-05-10T16:00:00.000Z","updated":"2021-06-25T02:12:36.825Z","comments":true,"path":"2015/05/11/52标签之美四——为网页添加绚丽多彩的图像/","link":"","permalink":"http://huishao.cc/2015/05/11/52标签之美四——为网页添加绚丽多彩的图像/","excerpt":"","text":"标签之美——图像的使用一、设置网页背景图片12&lt;body background=&quot;1.jpg&quot;&gt;&lt;/body&gt; 这里图片路径的写法和本地超链接的写法是一样的，可以参考上一篇博客中关于本地路径的地方：http://my.oschina.net/u/2340880/blog/412934。 注意：如果图片大小不能充满网页，图片将会被复制平铺。 二、图片标签的应用是图片插入标签。其中图片路径的写法和超链接路径的写法一样。示例如下： 123&lt;body&gt;&lt;img src=&quot;2.png&quot;/&gt;&lt;/body&gt; 效果如下： 标签的alt属性可以为图片添加缺省文字，当图片不存在或者无法显示时，会有提示效果。示例如下： 123&lt;body&gt;&lt;img src=&quot;3.png&quot; alt=&quot;图片不存在&quot;/&gt;&lt;/body&gt; 设置图片的尺寸属性：width，height 123&lt;body&gt;&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;&lt;!--设置宽高为200像素--&gt;&lt;/body&gt; 三、图片的对齐模式align是图片标签的对齐属性，对齐模式有5种属性值，下面一一对其进行介绍： 1、bottom:底部对其1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;bottom&quot;/&gt;的图片 效果如下： 2、left:左部对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;left&quot;/&gt;的图片 3、right:右部对其1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;right&quot;/&gt;的图片 效果如下： 4、middle:居中对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;middle&quot;/&gt;的图片 效果如下： 5、top:上部对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;top&quot;/&gt;的图片 效果如下： 四、设置图片边框和边距通过border属性可以给图片添加边框。属性的值为边框的宽度。 1&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;top&quot; border=&quot;4&quot;/&gt; 效果如下，图片被加上了黑色的边框： 也可以给图片设置一个间距，间距的效果和透明的边框是一样的。 1这里是图片&lt;img src=&quot;1.png&quot; align=&quot;middle&quot; hspace=&quot;20&quot;&gt;内容 其中，hspace是设置水平边框的宽度，还有一个属性vspace是设置垂直边框的宽度，上面代码效果如下： 五、插入视频的相关操作插入视频的原理和图像是一样的，只是路径使用的时dynsrc，可以使用loop属性来设置循环次数，start属性来设置播放方式，这里，只将start属性说明一下，有两种方式，fileopen是网页加载就开始播放，mouseover是鼠标移动到视频位置后开始播放。 1&lt;img dynsrc=&quot;2.wmv&quot; start=&quot;fileopen&quot; loop=&quot;1&quot;&gt; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美三——超链接的嵌入","slug":"51标签之美三——超链接的嵌入","date":"2015-05-09T16:00:00.000Z","updated":"2021-06-25T02:11:41.747Z","comments":true,"path":"2015/05/10/51标签之美三——超链接的嵌入/","link":"","permalink":"http://huishao.cc/2015/05/10/51标签之美三——超链接的嵌入/","excerpt":"","text":"标签之美——超链接标签一、创建超链接通常的超链接有两种方式，一种是链接到另一个文件，另一种是链接到当前文件的某个位置。这两种方式都是通过标签来创建，其中href属性用来指定链接的目标地址。 1、链接到当前页面指定位置被链接的地方需要使用标签的name属性标记，示例如下： 1234&lt;a href=&quot;#last&quot;&gt;链接到本页最后&lt;/a&gt;&lt;!--创建一个超链接--&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=&quot;last&quot;&gt;最后&lt;/a&gt;&lt;!--链接的标记名--&gt;&lt;/body&gt; 2、链接到本地相对路径文件相对路径是以当前\b文件所在的路径为参考的。示例如下： 12345678&lt;body&gt;&lt;!--同级链接：所链接到得文件与当前文件在同一目录下，直接链接文件名即可--&gt;&lt;a href=&quot;nwe.html&quot;&gt;同级链接&lt;/a&gt;&lt;!--下级链接：所链接的文件在当前文件所在目录的子目录下--&gt;&lt;a href=&quot;thml/new.html&quot;&gt;下级链接&lt;/a&gt;&lt;!--上级链接：所链接文件在当前文件所在的上级目录--&gt;&lt;a href=&quot;../new.html&quot;&gt;上级链接&lt;/a&gt;&lt;/body&gt; 3、链接到网址URL这种方式通常会用在友情链接中。例如如下链接到百度： 123&lt;body&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/body&gt; 二、链接的打开方式标签中的target属性可以设置标签的打开方式，一共有四种方式，分别是_blank,_parent,_self,_top。 1、_blank打开方式会让浏览器在新的窗口中打开标签。 2、_parent打开方式在父窗口中打开，当前页面会被覆盖。 3、_self打开方式在当前窗口打开，当前窗口会被覆盖。 4、_top打开方式在最上层窗体中打开。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美二——文本标签","slug":"50标签之美二——文本标签","date":"2015-05-07T16:00:00.000Z","updated":"2021-06-24T11:32:33.037Z","comments":true,"path":"2015/05/08/50标签之美二——文本标签/","link":"","permalink":"http://huishao.cc/2015/05/08/50标签之美二——文本标签/","excerpt":"","text":"标签之美–HTML文本标签属性详解1、使用标题标签 是标题的开始和结束标签，html提供6级标题划分，示例如下： 123&lt;body&gt;&lt;!--设置背景为蓝色--&gt;&lt;h1&gt;这是一级标题&lt;/h1&gt;&lt;h2&gt;这是二级标题&lt;/h&gt;&lt;h6&gt;这是六级标题&lt;/h6&gt;&lt;/body&gt; 2、使用字体标签 用于定义字体，其中详细属性如下： 定义字体大小：size 例如设置其中文字字号为4。 设置字体：face 其中可以填写多个字体名称，浏览器会按顺序寻找。 3、使用文本布局标签 缩进标签，可以让内容布局更加清晰，效果如下： 1234&lt;body&gt;这是没有使用索引的内容&lt;br&gt;&lt;blockquote&gt;这里使用了标签的内容&lt;/blockquote&gt;&lt;/body&gt; 手动格式化布局标签这个标签可以不通过代码进行空格和换行的控制，而是直接将文本中的布局显示。效果如下： 1234&lt;body&gt;&lt;pre&gt;手动的空格 与换行这里是第二行&lt;/pre&gt;&lt;/body&gt; 内联标签，这个标签的作用是将对象内联与某些内容，比如将鼠标悬停时展现的内容，示例如下： 123&lt;body&gt;&lt;span title=&quot;看这里&quot;&gt;标题&lt;/span&gt;&lt;/body&gt; 4、使用字体属性标签 为字体加粗： 使用斜体： 添加下划线： 添加标注： 与下划线形式相同 添加删除标记： 与 添加上标： 添加下表： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS开发遇到的屏幕上下闪出黑边的解决方法","slug":"48iOS开发遇到的屏幕上下闪出黑边的解决方法","date":"2015-05-06T16:00:00.000Z","updated":"2021-06-24T11:30:43.274Z","comments":true,"path":"2015/05/07/48iOS开发遇到的屏幕上下闪出黑边的解决方法/","link":"","permalink":"http://huishao.cc/2015/05/07/48iOS开发遇到的屏幕上下闪出黑边的解决方法/","excerpt":"","text":"iOS开发遇到的屏幕上下闪出黑边的解决方法在IOS开发时，使用的时IOS的模拟器，程序中任何有关坐标的地方也是根据屏幕获取的，而在IOS7的系统上运行，却发现屏幕小了一截，上下各闪出一块黑色区域。后经过查找原因，解决方法如下: 项目的App Icon and Launch Images设置中，本来是这样的： 点击Use Asset Catalog，之后点击Migrate，设置界面如下图模样： 这时在IOS7上就能充满屏幕了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS有关内存管理的二三事","slug":"49iOS有关内存管理的二三事","date":"2015-05-06T16:00:00.000Z","updated":"2021-06-24T11:31:41.336Z","comments":true,"path":"2015/05/07/49iOS有关内存管理的二三事/","link":"","permalink":"http://huishao.cc/2015/05/07/49iOS有关内存管理的二三事/","excerpt":"","text":"iOS有关内存管理的二三事一、前引随着移动设备的内存越来越大，程序员也已经度过了为了那一两M的内存在系统的抽丝剥茧的年代，对于JAVA的开发者，对内存更是伸手即取，并且从不关心什么时候还回去。但是，程序的掌控度对程序员来说是至关重要的，任何语言的内存管理机制的初衷也是在有限的空间里完成最精致的逻辑。 二、Xcode工程设置ARCARC是xcode5中引入的自动引用计数，其原理与MRC是一样，只是系统帮助我们添加了retain和release。现在在xcode中新建的项目默认都是ARC的环境，我们可以通过设置其为MRC。 在BuildSettings中搜索ARC： 将下面的参数设置为NO，默认是YES。 这时项目工程的环境就变成了MRC。 三、项目中实现MRC和ARC混编现实中的许多旧的项目，还有一些比较老的第三方库，可能都是采用MRC环境编写的，我们在对其进行扩展或者做新项目的兼容的时候，可以在xcode中对其进行混编。 选择：target-&gt;build phases-&gt;compile sources 如果工程是ARC，要混编MRC的文件，我们选中compiler flags，后面设置为-fno-objc-arc 如果工程是MRC，要混编ARC文件，我们在后面设置-fobjc-arc 四、IOS内存管理机制基本原理无论你是只注重于代码逻辑，将内存交给ARC的新时代程序员，还是依然对apple的信任不足，依然事必躬亲的MRC古板程序员，我想你都应该了解IOS中内存管理的机制，尽管ARC机制很成熟也很可靠，可是依然会有很多应用存在循环应用，内存泄露等问题，要知道，ARC不是万能的，它仅仅只是帮你省去写一些繁琐的代码。 首先，在Object-C中创建对象返回的并不是对象本身，而是一个指针。比如我们使用alloc申请空间，会经常这样做： UIImage * image = [[UIImage alloc]init]; 这里，调用的alloc时，系统将给我们创建的类分配一块内存空间，并返回一个指向这个空间的指针。调用init时对对象进行初始化。如果此时，我们将image这个指针置为nil：image=nil;那样将造成内存泄露，系统分配给image的空间永远无法回收。所以，在我们不需要image这个对象时，我们会使用dealloc方法将其交还给系统：[image dealloc];然而这里，有将产生一个严重的问题，如果我们此时打印image的指针，会发现它现在成了一个危险东西，因为它指向的东西不存在了，而它却依然指向那个地方，这便是很多程序员的噩梦：野指针。为此，我们应该养成一个好习惯，不用的指针置为nil，所有对空指针进行的操作都被认为是安全的。 通过上面的理解，我们发现了一个非常麻烦的地方，我申请了一块内存空间，如果我将指针置空了而没有释放对象，则会内存泄露，如果我提前释放了对象，又很可能会有野指针的出现。并且如果有很多类都引用了这个对象，我甚至的不知道我应该什么时候释放它。因此，Object-C为我们引入了引用计数这种管理内存的方法，任何引用这个对象的地方，都应该让这个对象的引用计数加1。同样，任何不再需要这个对象的地方，也应该使它的引用计数减1，如此一来，对象内存便被统一的管理了起来。 五、内存管理的黄金法则引用计数内存管理的机制是对象的计数，每个对象至少会有一个引用者，如果没有了引用者，对象会被释放。 黄金法则： 1、当你使用alloc,new,copy,mutableCopy创建对象时，你才需要管理他们。 2、你可以使用retain给一个对象增加引用计数。 3、当你不再需要一个对象时，你必须调用release减少其引用计数。 4、你不能释放不属于你的对象的所有权。 上面就是黄金法则的所有内容，我译的可能不到位，总结为一点，也是至关重要的一点就是：谁创建了对象，谁释放掉对象。谁增加了引用计数，谁就在不用时减少计数。alloc，new，copy，mutableCopy，retain这些方法会使引用计数增加，release会使引用计数减少，当计数为0时，系统会调用dealloc释放内存。 六、自动释放池为了方便内存管理，避免我们频繁的调用release方法，Object-C中还为我们引用了一种机制：自动释放池。自动释放池的原理其实只是延时释放，它并没有帮我们做太多的工作。自动释放池的使用方式有两种： 1、MRC时： 123 NSAutoreleasePool * pool = [[NSAutoreleasePool alloc]init];//创建一个自动释放池，系统默认会为我们创建一个，我们也可以创建自己的。 UIImage * image = [[[UIImage alloc]init] autorelease];//在池内创建一些对象，会和最近的自动释放池匹配 [pool release];//这时自动释放池会向池子中的每一个对象发送release消息 2、ARC时： 123 @autoreleasepool &#123; UIImage * image = [[[UIImage alloc]init] autorelease]; &#125; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美一——HTML基础元素","slug":"47标签之美一——HTML基础元素","date":"2015-05-05T16:00:00.000Z","updated":"2021-06-24T11:29:30.670Z","comments":true,"path":"2015/05/06/47标签之美一——HTML基础元素/","link":"","permalink":"http://huishao.cc/2015/05/06/47标签之美一——HTML基础元素/","excerpt":"","text":"标签之美–HTML基础标签使用总结HTML是一种标记语言，因此，标签便是HTML的核心，一些基础标签的用法总结如下： 1、 任何HTML文件都会有这样一个标签，标记网页的开始和结束。 2、 头部标签中可以包含许多网页的头信息。 3、 这个标签包含在头部标签内，其内容就是网页显示的标题，比如： 12345&lt;html&gt;&lt;head&gt;&lt;title&gt;我的HTML网页&lt;/title&gt;&lt;/head&gt;&lt;/html&gt; 结果如下： 4、 这是一个设置标签，也叫元信息标签，用于记录和设置网页的一些属性。 其中：name属性可以用来设置关键字，简要内容，网页生成工具及网页的制作者和网页链接查询权限，分别对应的字段为：Keywords、Description、Generator、Author、Robots。 每一个name的属性，后面都要用contect进行解释。对于Robots属性，contect权限的说明如下： all:文件和链接都可以被检索 none:都不可以被检索 index:文件被检索 follow:页面上的链接被检索 noindex：文件不被检索，链接可以被查询 标签的另一个属性值为http-equiv，它将告诉浏览器一些重要的信息，例如编码信息： 1&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--告诉浏览器编码格式--&gt; 定时跳转网页： 1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5;url=http://www.baidu.com&quot;&gt;&lt;!--5S后将跳转到百度网页--&gt; 5、 顾名思义，网页的主体内容写在这个标签里。 下面这些标签都是在标签下的： 6、 段落标签，示例如下： 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;我的HTML网页&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是第一段&lt;/p&gt;&lt;p&gt;这是第二段&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 7、 换行标签，如下： 123&lt;body&gt;这是第一行&lt;br&gt;这是第二行&lt;/body&gt; 8、 水平分割线，示例如下： 123456789&lt;body&gt;这是第一行&lt;hr&gt;这是第二行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第三行&lt;hr width=&quot;200&quot;&gt;&lt;!--设置分割线的长度--&gt;这是第四行&lt;hr width=&quot;100&quot; align=&quot;left&quot;&gt;&lt;!--设置居左--&gt;&lt;/body&gt; 在设置分割线的颜色之前，我们先把HTML中颜色对应的代码总结如下： 123456789&lt;body&gt;这是第一行&lt;hr color=&quot;#0C2DEC&quot;&gt;这是第二行&lt;hr size=&quot;12&quot; color=&quot;#FF0000&quot;&gt;&lt;!--设置颜色--&gt;这是第三行&lt;hr width=&quot;200&quot; color=&quot;#730C0D&quot;&gt;这是第四行&lt;hr width=&quot;100&quot; align=&quot;left&quot; color=&quot;#158C4F&quot;&gt;&lt;/body&gt; 取消分割线阴影： 123456&lt;body&gt;这是第一行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第二行&lt;hr size=&quot;16&quot; noshade&gt;&lt;!--取消分割线阴影--&gt;&lt;/body&gt; 9、 注释标签，任何编程语言都会有注释语句，这个就无需多说了。形式如下： 10、设置网页背景色 标签中有一个属性，可以用来设置网页的背景颜色：bgcolor 123456&lt;body bgcolor=&quot;#002BF8&quot;&gt;&lt;!--设置背景为蓝色--&gt;这是第一行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第二行&lt;hr size=&quot;16&quot; noshade&gt;&lt;!--取消分割线阴影--&gt;&lt;/body&gt; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS通过NSUserDefaults实现简单的应用间数据传递","slug":"46iOS通过NSUserDefaults实现简单的应用间数据传递","date":"2015-05-05T16:00:00.000Z","updated":"2021-06-24T11:27:18.667Z","comments":true,"path":"2015/05/06/46iOS通过NSUserDefaults实现简单的应用间数据传递/","link":"","permalink":"http://huishao.cc/2015/05/06/46iOS通过NSUserDefaults实现简单的应用间数据传递/","excerpt":"","text":"iOS中NSUserDefaults详解NSUserDefaults是用于保存应用程序设置，应用信息等轻量级数据的的一个类，其本质是将数据写为plist文件的形式保存在本地。在IOS中，系统为每一个应用程序都默认创建了一个NSUserDefaults对象。 一、常用方法总结+ (NSUserDefaults *)standardUserDefaults; 获取系统默认创建的应用程序设置表 + (void)resetStandardUserDefaults; 这个方法用于将默认的UserDefaults释放掉，并在下次使用时创建一个新的对象，需要注意的是，调用这个方法后，对原UserDefaults单例进行的KVO监听将失效。 - (instancetype)initWithSuiteName:(NSString *)suitename; 这个方法创建一个新的域：根据名字可以创建一些不同的域，分别存储几套设置信息。 - (id)objectForKey:(NSString *)defaultName; - (void)setObject:(id)value forKey:(NSString *)defaultName; - (void)removeObjectForKey:(NSString *)defaultName; 上面三个方法是对对象存储进行的操作，分别是存储，获取和删除。 - (NSString )stringForKey:(NSString )defaultName; 获取字符串数据 - (NSArray )arrayForKey:(NSString )defaultName; 获取数组数据 - (NSDictionary )dictionaryForKey:(NSString )defaultName; 获取字典数据 - (NSData )dataForKey:(NSString )defaultName; 获取data数据 - (NSArray )stringArrayForKey:(NSString )defaultName; 获取字符串数组数据 - (NSInteger)integerForKey:(NSString *)defaultName; 获取整型数据 - (float)floatForKey:(NSString *)defaultName; 获取浮点型数据 - (double)doubleForKey:(NSString *)defaultName; 获取双精度浮点型数据 - (BOOL)boolForKey:(NSString *)defaultName; 获取布尔诗句 - (NSURL )URLForKey:(NSString )defaultName; 获取网址数据 下面是一些对应的set方法 - (void)setInteger:(NSInteger)value forKey:(NSString *)defaultName; - (void)setFloat:(float)value forKey:(NSString *)defaultName; - (void)setDouble:(double)value forKey:(NSString *)defaultName; - (void)setBool:(BOOL)value forKey:(NSString *)defaultName; - (void)setURL:(NSURL )url forKey:(NSString )defaultName; - (void)registerDefaults:(NSDictionary *)registrationDictionary; 这个方法可以通过字典对数据表进行赋值 - (void)addSuiteNamed:(NSString *)suiteName; 添加一个域 - (void)removeSuiteNamed:(NSString *)suiteName; 移除一个域 - (NSDictionary *)dictionaryRepresentation; 返回系统设置的信息，也是NSGlobalDomain域中的信息。 @property (readonly, copy) NSArray *volatileDomainNames; 返回一个数组，其中是所有不稳定域的名字 - (NSDictionary )volatileDomainForName:(NSString )domainName; 根据名字获取不稳定域中的数据 - (void)setVolatileDomain:(NSDictionary )domain forName:(NSString )domainName; 根据名字设置不稳定域 - (void)removeVolatileDomainForName:(NSString *)domainName; 根据名字移除不稳定域 - (NSDictionary )persistentDomainForName:(NSString )domainName; 根据名字获取稳定域的数据 - (void)setPersistentDomain:(NSDictionary )domain forName:(NSString )domainName; 根据名字设置稳定域 - (void)removePersistentDomainForName:(NSString *)domainName; 根据名字移除稳定域 - (BOOL)synchronize; 对象的同步方法，将内存中的数据写入磁盘。 - (BOOL)objectIsForcedForKey:(NSString *)key; 判断某个键值的数据是否存在 - (BOOL)objectIsForcedForKey:(NSString )key inDomain:(NSString )domain; 判断某个域中某个键值的数据是否存在 注：目前的iOS版本已经不能通过下面的方法在应用间进行传值！！！ 二、三个特殊的域及实现简单的应用间信息传递我们应该了解到，在IOS中，因为沙盒模式的存在，应用间是不允许互相访问数据与传值通信的。这样做的好处显而易见： 1、保证了数据的安全性 2、数据的管理更加简洁 3、当我们删除数据时，只需要将沙盒删除。 在某些需求下，我们可能会需要应用程序间的传值与通信，当然除了通过网络外，对于非常小的数据量，比如验证另一应用从程序是否登录，是否安装并且开启过一次，我们也可以通过NSUserDefaults的一个全局的数据表来实现。 NSUserDefaults的三个特殊的系统域如下： NSString * const NSGlobalDomain; 这个是一个系统级别的全局的域，存储这系统配置信息，我们可以通过它实现应用程序间传值 NSString * const NSArgumentDomain; 这个是在本应用程序内可访问的域，存储着应用程序的信息 NSString * const NSRegistrationDomain; 这个是存放临时数据的域 代码示例如下： 首先在第一个工程中，我们写如下代码运运行一下： 123456789 //获取全局的域 NSDictionary * dic = [[NSUserDefaults standardUserDefaults]persistentDomainForName:NSGlobalDomain]; NSMutableDictionary * temDic = [NSMutableDictionary dictionaryWithDictionary:dic]; [temDic setObject:@&quot;传递的值&quot; forKey:@&quot;应用1&quot;]; //重设 [[NSUserDefaults standardUserDefaults]setPersistentDomain:temDic forName:NSGlobalDomain]; //同步 [NSUserDefaults resetStandardUserDefaults]; NSLog(@&quot;%@&quot;,dic); 打印的结果是许多系统信息。 在第二个工程中，我们这样做： 12 NSDictionary * dic = [[NSUserDefaults standardUserDefaults]persistentDomainForName:NSGlobalDomain]; NSLog(@&quot;%@\\n--------------\\n%@=%@&quot;,dic,@&quot;应用1&quot;,[dic objectForKey:@&quot;应用1&quot;]); 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657582015-05-06 15:48:49.897 321[4100:186745] &#123; AppleITunesStoreItemKinds = ( newsstand, podcast, &quot;itunes-u&quot;, artist, booklet, document, eBook, software, &quot;software-update&quot;, &quot;podcast-episode&quot; ); AppleLanguages = ( en, fr, de, &quot;zh-Hans&quot;, &quot;zh-Hant&quot;, ja, nl, it, es, &quot;es-MX&quot;, ko, pt, &quot;pt-PT&quot;, da, fi, nb, sv, ru, pl, tr, uk, ar, hr, cs, el, he, ro, sk, th, id, ms, &quot;en-GB&quot;, &quot;en-AU&quot;, ca, hu, vi, hi ); AppleLocale = &quot;en_US&quot;; MSVLoggingMasterSwitchEnabledKey = 0; &quot;\\U5e94\\U75281&quot; = &quot;\\U4f20\\U9012\\U7684\\U503c&quot;;&#125;--------------应用1=传递的值 这样，我们就简单实现了应用程序间的传值，但是建议最好不要轻易操作系统的这个域。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中KVC与KVO的应用解析","slug":"45iOS中KVC与KVO的应用解析","date":"2015-05-04T16:00:00.000Z","updated":"2021-06-24T11:26:23.274Z","comments":true,"path":"2015/05/05/45iOS中KVC与KVO的应用解析/","link":"","permalink":"http://huishao.cc/2015/05/05/45iOS中KVC与KVO的应用解析/","excerpt":"","text":"iOS中KVC与KVO的应用解析一、NSKeyValueCoding（KVC）1、从一个小例子引入KVC键值编码是Object-C为我们提供的一种对成员变量赋值的方法。在探讨其方法之前，我们先来看一个小例子： 首先，创建一个数据模型model类： 12345678//.h文件#import &lt;Foundation/Foundation.h&gt;@interface Model : NSObject&#123; @public//将成员变量设置为公有的 以便其他文件有访问权限 NSString * str;&#125;@end 我们在其他文件中有两种方法str进行赋值和取值： 12345 Model * model = [[Model alloc]init]; model-&gt;str=@&quot;312&quot;;//普通方法赋值 [model setValue:@&quot;321&quot; forKey:@&quot;str&quot;];//kvc赋值 NSLog(@&quot;%@&quot;,model-&gt;str);//普通方法取值 NSLog(@&quot;%@&quot;,[model valueForKey:@&quot;str&quot;]);//kvc取值 同样的，对于用@property声明的变量，使用kvc的效果和使用点语法，setter，getter方法的效果是一样的。 2、KVC有关函数方法详解通过上面的例子，我们已经可以简单了解KVC是干什么的了，下面是一些常用方法。 + (BOOL)accessInstanceVariablesDirectly; 这个方法类似一个开关，默认返回为YES，表示支持KVC方式赋值，也可以在子类中将其重写，如果返回为NO，则再进行KVC会抛出异常。 - (id)valueForKey:(NSString *)key; 通过键取值 - (void)setValue:(id)value forKey:(NSString *)key; 通过字符串键给成员变量赋值 - (BOOL)validateValue:(inout id )ioValue forKey:(NSString )inKey error:(out NSError **)outError; 系统默认实现的方法，验证一个键值是否有效 - (NSMutableArray )mutableArrayValueForKey:(NSString )key; 将取到的值放入一个可变数组中 - (NSMutableOrderedSet )mutableOrderedSetValueForKey:(NSString )key NS_AVAILABLE(10_7, 5_0); 将取到的值放入可变的有序集合中 - (NSMutableSet )mutableSetValueForKey:(NSString )key; 将取到的值放入可变的集合中 - (id)valueForKeyPath:(NSString )keyPath;- (void)setValue:(id)value forKeyPath:(NSString )keyPath; 上面这两个方法分别是通过路径赋值与取值，数据结构类似地图，比如在model类中有一个成员变量model2，在Model2类中有一个字符串，我们可以通过如下的方式赋值取值 123456789101112131415161718192021//Model.h#import &quot;Model2.h&quot;@interface Model : NSObject&#123; @public NSString * str; Model2 * model2;&#125;//Model2.h@interface Model2 : NSObject&#123;@public NSString * str2;&#125;@end//其他文件 Model * model = [[Model alloc]init]; Model2 * model2 = [[Model2 alloc]init]; model-&gt;model2=model2; [model setValue:@&quot;123&quot; forKeyPath:@&quot;model2.str2&quot;]; NSLog(@&quot;%@&quot;,[model valueForKeyPath:@&quot;model2.str2&quot;]); - (NSMutableArray )mutableArrayValueForKeyPath:(NSString )keyPath;- (NSMutableOrderedSet )mutableOrderedSetValueForKeyPath:(NSString )keyPath NS_AVAILABLE(10_7, 5_0);- (NSMutableSet )mutableSetValueForKeyPath:(NSString )keyPath; 上面三个方法与前面类似，只是是从路径取值的。 - (id)valueForUndefinedKey:(NSString *)key; 这个方法可以获取没有提前定义的成员变量的值，比如运行时创建的，下面这个方法是给未定义的成员变量赋值 - (void)setValue:(id)value forUndefinedKey:(NSString *)key; 注意：这两个方法默认的实现会抛出异常，子类必须重写才能使用。 - (void)setNilValueForKey:(NSString *)key; 将成员变量置为nil - (NSDictionary )dictionaryWithValuesForKeys:(NSArray )keys; 根据键值获取键值对字典 - (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues; 通过字典对成员变量同意赋值，经常使用 二、NSKeyValueObservingCustomization（KVO）KVO是一种消息监听机制，可以在某个量发生变化的时候将消息传送给监听者，因此广泛用于传值，界面低耦合等逻辑中。KVO机制的核心是以下三个方法： - (void)addObserver:(NSObject )observer forKeyPath:(NSString )keyPath options:(NSKeyValueObservingOptions)options context:(void *)context; 使用这个方法注册一个监听者，参数解释如下： observer：监听者对象 keyPath：监听的参数 options：监听选项 context：参数传递 监听的选项枚举如下： 12345678typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123; NSKeyValueObservingOptionNew = 0x01,//回调的字典中存放新值 NSKeyValueObservingOptionOld = 0x02,//回调的字典中存放旧值 NSKeyValueObservingOptionInitial ,//值改变前进行回调 NSKeyValueObservingOptionPrior//改变前后都进行回调&#125;;//回调字典后面会解释 - (void)removeObserver:(NSObject )observer forKeyPath:(NSString )keyPath context:(void )context ;- (void)removeObserver:(NSObject )observer forKeyPath:(NSString *)keyPath; 这两个方法都是用来移除监听者 - (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary )change context:(void *)context; 这个方法是监听对象数据改变时回调的方法，change是一个字典，字典中根据监听的选项不同，存放不同的值（新或者旧）。context是传递的参数。 代码示例： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. model = [[Model alloc]init]; //添加监听者 [model addObserver:self forKeyPath:@&quot;str&quot; options:NSKeyValueObservingOptionNew context:@&quot;321&quot;]; [model setValue:@&quot;qw&quot; forKey:@&quot;str&quot;];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if ([keyPath isEqualToString:@&quot;str&quot;]) &#123; NSLog(@&quot;%@&quot;,context); &#125;&#125; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C中编写省略参数的多参函数","slug":"43Objective-C中编写省略参数的多参函数","date":"2015-05-03T16:00:00.000Z","updated":"2021-06-24T11:22:42.493Z","comments":true,"path":"2015/05/04/43Objective-C中编写省略参数的多参函数/","link":"","permalink":"http://huishao.cc/2015/05/04/43Objective-C中编写省略参数的多参函数/","excerpt":"","text":"Objective-C中编写省略参数的多参数函数引语：在Object-C中，我们会遇到很多像NSLog这样的函数，其中参数的个数不确定，由程序员自由控制，在初始化数组，字典等方面应用广泛，那么，这类的函数是如何实现的呢？我们怎么编写我们自己的省略参数的函数呢？当然，这不是唯一的多参函数的处理方法，你也可以通过一个字典或者数组传递参数。但C为我们提供的这样的一种机制，无疑是最方便的。 一、了解几个概念va_list C语言中定义的一个指针，用于指向当前的参数。 va_start(ap,param) 这个宏是初始化参数列表，其中第一个参数是va_list对象，第二个参数是参数列表的第一个参数。 va_arg(ap, type) 一个用于取出参数的宏，这个宏的第一个参数是va_list对象，第二个参数是要取出的参数类型。 va_end(ap) 这个宏用于关闭取参列表 二、多参函数的取参原理在编写我们自己的多参函数之前，明白函数的取参原理是十分重要的，首先，函数的参数是被放入我们内存的栈段的，而且放入的顺序是从后往前放入，比如如果一个函数参数如下： void func(int a,int b,int c,int d) 那么传递参数的时候参数d先入栈，接着是c、b、a。如此这样，在取参的时候，根据堆栈的取值原则，则取值顺序为a、b、c、d。所以在原理上，只要我们知道第一个参数的地址和每个参数的类型，我们就可以将参数都取出来。而上面介绍的几个宏，就是帮助我们做这些的。 三、声明与实现省略参数的多参函数“…”这个符号就是我们用来实现省略参数函数的符号。例如我们模拟实现一个log函数如下： 12345678910-(void)myLog:(NSString *)str,...&#123;//省略参数的写法 va_list list;//创建一个列表指针对象 va_start(list, str);//进行列表的初始化，str为省略前的第一个参数，及...之前的那个参数 NSString * temStr = str; while (temStr!=nil) &#123;//如果不是nil，则继续取值 NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*);//返回取到的值，并且让指针指向下一个参数的地址 &#125; va_end(list);//关闭列表指针&#125; 注意，调用时，我们必须在参数的最后加上nil这个判断结束的条件： 1[self myLog:@&quot;312&quot;,@&quot;321&quot;, nil];//必须有nil 四、一点补充细心的你可能发现了，这里的nil是我们在调用函数时手动加上的，可是系统的许多函数在我们调用时，系统直接帮我们加上了参数结尾的那个nil，例如 NSArray * array = [NSArray arrayWithObjects:(id), nil] 这是如何做到的呢？我们只需要在函数的声明里加上一个宏，就可以实现这个功能，修改如下： 12345678910-(void)myLog:(NSString *)str,...NS_REQUIRES_NIL_TERMINATION&#123;//这里加上一个宏 va_list list; va_start(list, str); NSString * temStr = str; while (temStr!=nil) &#123; NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*); &#125; va_end(list);&#125; 顾名思义，这个宏的作用就是在结束位置加上我们需要的nil。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UITableViewCell使用详解","slug":"44iOS UITableViewCell使用详解","date":"2015-05-03T16:00:00.000Z","updated":"2021-06-24T11:23:49.828Z","comments":true,"path":"2015/05/04/44iOS UITableViewCell使用详解/","link":"","permalink":"http://huishao.cc/2015/05/04/44iOS UITableViewCell使用详解/","excerpt":"","text":"iOS中UITableViewCell使用详解- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier; Cell的初始化方法，可以设置一个风格和标识符，风格的枚举如下： 123456typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123; UITableViewCellStyleDefault, // 默认风格，自带标题和一个图片视图，图片在左 UITableViewCellStyleValue1, // 只有标题和副标题 副标题在右边 UITableViewCellStyleValue2, // 只有标题和副标题，副标题在左边标题的下边 UITableViewCellStyleSubtitle // 自带图片视图和主副标题，主副标题都在左边，副标题在下&#125;; @property (nonatomic, readonly, retain) UIImageView *imageView; 图片视图，风格允许时才会创建 @property (nonatomic, readonly, retain) UILabel *textLabel; 标题标签 @property (nonatomic, readonly, retain) UILabel *detailTextLabel; 副标题标签 @property (nonatomic, readonly, retain) UIView *contentView; 容纳视图，任何cell的子视图都应该添加在这个上面 @property (nonatomic, retain) UIView *backgroundView; 背景视图 @property (nonatomic, retain) UIView *selectedBackgroundView; 选中状态下的背景视图 @property (nonatomic, retain) UIView *multipleSelectionBackgroundView; 多选选中时的背景视图 @property (nonatomic, readonly, copy) NSString *reuseIdentifier; cell的标识符 - (void)prepareForReuse; 当被重用的cell将要显示时，会调用这个方法，这个方法最大的用武之地是当你自定义的cell上面有图片时，如果产生了重用，图片可能会错乱（当图片来自异步下载时及其明显），这时我们可以重写这个方法把内容抹掉。 @property (nonatomic) UITableViewCellSelectionStyle selectionStyle; cell被选中时的风格，枚举如下： 123456typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123; UITableViewCellSelectionStyleNone,//无 UITableViewCellSelectionStyleBlue,//蓝色 UITableViewCellSelectionStyleGray,//灰色 UITableViewCellSelectionStyleDefault//默认 为蓝色&#125;; @property (nonatomic, getter=isSelected) BOOL selected; 设置cell是否选中状态 @property (nonatomic, getter=isHighlighted) BOOL highlighted; 设置cell是否高亮状态 - (void)setSelected:(BOOL)selected animated:(BOOL)animated; - (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated; 与上面的两个属性对应 @property (nonatomic, readonly) UITableViewCellEditingStyle editingStyle; 获取cell的编辑状态，枚举如下 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone,//无编辑 UITableViewCellEditingStyleDelete,//删除编辑 UITableViewCellEditingStyleInsert//插入编辑&#125;; @property (nonatomic) BOOL showsReorderControl; 设置是否显示cell自带的自动排序控件 注意：要让cell实现拖动排序的功能，除了上面设置为YES，还需实现代理中的如下方法： -(BOOL)tableView:(UITableView )tableView canMoveRowAtIndexPath:(NSIndexPath )indexPath{ return YES; } -(void)tableView:(UITableView )tableView moveRowAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{ } @property (nonatomic) BOOL shouldIndentWhileEditing; 设置编辑状态下是否显示缩进 @property (nonatomic) UITableViewCellAccessoryType accessoryType; 设置附件视图的风格(cell最右侧显示的视图) 枚举如下： 1234567typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123; UITableViewCellAccessoryNone, // 没有视图 UITableViewCellAccessoryDisclosureIndicator, // cell右侧显示一个灰色箭头 UITableViewCellAccessoryDetailDisclosureButton, // 显示详情符号和灰色箭头 UITableViewCellAccessoryCheckmark, // cell右侧显示蓝色对号 UITableViewCellAccessoryDetailButton // cell右侧显示一个详情符号&#125;; @property (nonatomic, retain) UIView *accessoryView; 附件视图 @property (nonatomic) UITableViewCellAccessoryType editingAccessoryType; cell编辑时的附件视图风格 @property (nonatomic, retain) UIView *editingAccessoryView; cell编辑时的附件视图 @property (nonatomic) NSInteger indentationLevel; 设置内容区域的缩进级别 @property (nonatomic) CGFloat indentationWidth; 设置每个级别的缩进宽度 @property (nonatomic) UIEdgeInsets separatorInset; 设置分割线的偏移量 @property (nonatomic, getter=isEditing) BOOL editing; - (void)setEditing:(BOOL)editing animated:(BOOL)animated; 设置是否编辑状态 @property(nonatomic, readonly) BOOL showingDeleteConfirmation; 返回是否目前正在显示删除按钮 - (void)willTransitionToState:(UITableViewCellStateMask)state; cell状态将要转换时调用的函数，可以在子类中重写 - (void)didTransitionToState:(UITableViewCellStateMask)state; cell状态已经转换时调用的函数，可以在子类中重写，状态枚举如下： 12345typedef NS_OPTIONS(NSUInteger, UITableViewCellStateMask) &#123; UITableViewCellStateDefaultMask = 0,//默认状态 UITableViewCellStateShowingEditControlMask = 1 &lt;&lt; 0,//编辑状态 UITableViewCellStateShowingDeleteConfirmationMask = 1 &lt;&lt; 1//确认删除状态&#125;; 注意：下面这些方法已经全部在IOS3.0后被废弃了，虽然还有效果，但是会被警告 @property (nonatomic, copy) NSString *text; 设置标题 @property (nonatomic, retain) UIFont *font; 设置字体 @property (nonatomic) NSTextAlignment textAlignment; 设置对其模式 @property (nonatomic) NSLineBreakMode lineBreakMode; 设置断行模式 @property (nonatomic, retain) UIColor *textColor; 设置字体颜色 @property (nonatomic, retain) UIColor *selectedTextColor; 设置选中状态下的字体颜色 @property (nonatomic, retain) UIImage *image; 设置图片 @property (nonatomic, retain) UIImage *selectedImage; 设置选中状态时的图片 @property (nonatomic) BOOL hidesAccessoryWhenEditing; 设置编辑的时候是否隐藏附件视图 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中UIActionSheet使用详解","slug":"42IOS中UIActionSheet使用详解","date":"2015-05-02T16:00:00.000Z","updated":"2021-06-24T09:20:29.141Z","comments":true,"path":"2015/05/03/42IOS中UIActionSheet使用详解/","link":"","permalink":"http://huishao.cc/2015/05/03/42IOS中UIActionSheet使用详解/","excerpt":"","text":"IOS中UIActionSheet使用方法详解一、初始化方法- (instancetype)initWithTitle:(NSString )title delegate:(id)delegate cancelButtonTitle:(NSString )cancelButtonTitle destructiveButtonTitle:(NSString )destructiveButtonTitle otherButtonTitles:(NSString )otherButtonTitles, …; 参数说明： title：视图标题 delegate：设置代理 cancelButtonTitle：取消按钮的标题 destructiveButtonTitle：特殊标记的按钮的标题 otherButtonTitles：其他按钮的标题 二、常用方法和属性介绍@property(nonatomic,copy) NSString *title; 设置标题 @property(nonatomic) UIActionSheetStyle actionSheetStyle; 设置风格，枚举如下： 123456typedef NS_ENUM(NSInteger, UIActionSheetStyle) &#123; UIActionSheetStyleAutomatic = -1, UIActionSheetStyleDefault = UIBarStyleDefault, UIActionSheetStyleBlackTranslucent = UIBarStyleBlackTranslucent, UIActionSheetStyleBlackOpaque = UIBarStyleBlackOpaque,&#125;; - (NSInteger)addButtonWithTitle:(NSString *)title; 添加一个按钮，会返回按钮的索引 - (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex; 获取按钮标题 @property(nonatomic,readonly) NSInteger numberOfButtons; 获取按钮数量 @property(nonatomic) NSInteger cancelButtonIndex; 设置取消按钮的索引值 @property(nonatomic) NSInteger destructiveButtonIndex; 设置特殊标记 @property(nonatomic,readonly,getter=isVisible) BOOL visible; 视图当前是否可见 下面是几种弹出方式，会根据风格不同展现不同的方式 - (void)showFromToolbar:(UIToolbar *)view; - (void)showFromTabBar:(UITabBar *)view; - (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated ; - (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated ; - (void)showInView:(UIView *)view; - (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; 使用代码将视图收回 三、UIActionSheet代理方法- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex; 点击按钮时触发的方法 - (void)willPresentActionSheet:(UIActionSheet *)actionSheet; 视图将要弹出时触发的方法 - (void)didPresentActionSheet:(UIActionSheet *)actionSheet; 视图已经弹出式触发的方法 - (void)actionSheet:(UIActionSheet *)actionSheet willDismissWithButtonIndex:(NSInteger)buttonIndex; 点击按钮后，视图将要收回时触发的方法 - (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex; 点击按钮后，视图已经收回时触发的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIAlertView（警告框）方法总结","slug":"41IOS UIAlertView（警告框）方法总结","date":"2015-04-30T16:00:00.000Z","updated":"2021-06-24T09:18:18.869Z","comments":true,"path":"2015/05/01/41IOS UIAlertView（警告框）方法总结/","link":"","permalink":"http://huishao.cc/2015/05/01/41IOS UIAlertView（警告框）方法总结/","excerpt":"","text":"IOS中UIAlertView(警告框)常用方法总结一、初始化方法- (instancetype)initWithTitle:(NSString )title message:(NSString )message delegate:(id //)delegate cancelButtonTitle:(NSString )cancelButtonTitle otherButtonTitles:(NSString )otherButtonTitles, …;这个方法通过设置一个标题，内容，代理和一些按钮的标题创建警告框，代码示例如下： 12 UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;我的警告框&quot; message:@&quot;这是一个警告框&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil]; [alert show]; 效果如下： 注意：如果按钮数超过两个，将会创建成如下样子： 如果按钮数量超出屏幕显示范围，则会创建类似tableView的效果。 二、属性与方法解析标题属性 @property(nonatomic,copy) NSString *title; 内容属性 @property(nonatomic,copy) NSString *message; 添加一个按钮，返回的是此按钮的索引值 - (NSInteger)addButtonWithTitle:(NSString *)title; 返回根据按钮索引按钮标题 - (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex; 获取按钮数量 @property(nonatomic,readonly) NSInteger numberOfButtons; 设置将某一个按钮设置为取消按钮 @property(nonatomic) NSInteger cancelButtonIndex; 返回其他类型按钮第一个的索引值 @property(nonatomic,readonly) NSInteger firstOtherButtonIndex; 警告框是否可见 @property(nonatomic,readonly,getter=isVisible) BOOL visible; 显现警告框 - (void)show; 代码模拟点击按钮消失触发方法 - (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; 设置警告框风格 @property(nonatomic,assign) UIAlertViewStyle alertViewStyle; 风格的枚举如下 123456typedef NS_ENUM(NSInteger, UIAlertViewStyle) &#123; UIAlertViewStyleDefault = 0,//默认风格 UIAlertViewStyleSecureTextInput,//密码输入框风格 UIAlertViewStylePlainTextInput,//普通输入框风格 UIAlertViewStyleLoginAndPasswordInput//账号密码框风格&#125;; 这个方法设置文本输入框的索引 - (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex; 三、UIAlertViewDelegate中的方法点击按钮时触发的方法 - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex; 将要展现警告框时触发的方法 - (void)willPresentAlertView:(UIAlertView *)alertView; 已经展现警告框时触发的方法 - (void)didPresentAlertView:(UIAlertView *)alertView; 警告框将要消失时触发的方法 - (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex; 警告框已经消失时触发的方法 - (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex; 设置是否允许第一个按钮不是取消按钮 - (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS调用系统通讯录","slug":"39iOS调用系统通讯录","date":"2015-04-28T16:00:00.000Z","updated":"2021-06-22T03:16:44.607Z","comments":true,"path":"2015/04/29/39iOS调用系统通讯录/","link":"","permalink":"http://huishao.cc/2015/04/29/39iOS调用系统通讯录/","excerpt":"","text":"iOS调用系统通讯录上一篇博客详细介绍了在IOS开发中，我们如何获取通讯录联系人的信息，即对其进行增删改查的操作：http://my.oschina.net/u/2340880/blog/407347。而在一些开发项目中，如果没有特殊需求，并且我们只是需要一些通讯录信息，并不做修改操作，我们完全可以采取另一种更加方便的方式，直接调用系统的通讯录。 首先，导入这个头文件： 1#import &lt;AddressBookUI/AddressBookUI.h&gt; 注意：需要在项目中链接如下两个库： 只需简单的几句代码，就可以弹出系统的通讯录界面： 123 ABPeoplePickerNavigationController * con = [[ABPeoplePickerNavigationController alloc]init]; con.peoplePickerDelegate=self; [self presentViewController:con animated:YES completion:nil]; 点击联系人后执行的方法，我们只需要实现下面的代理方法即可 123-(void)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person&#123; //person参数就是选择的联系人的引用 具体含义和数据获取，在上一篇博客中有详细介绍&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中调用系统拨打电话与发送短信","slug":"40IOS中调用系统拨打电话与发送短信","date":"2015-04-28T16:00:00.000Z","updated":"2021-06-24T03:04:55.230Z","comments":true,"path":"2015/04/29/40IOS中调用系统拨打电话与发送短信/","link":"","permalink":"http://huishao.cc/2015/04/29/40IOS中调用系统拨打电话与发送短信/","excerpt":"","text":"IOS中调用系统拨打电话发送短信一、调用打电话界面[[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@”tel://%@”,_phoneNumber]]]; 二、发送短消息界面调用系统的发送短信的界面，需要引入以下头文件： #import &lt;MessageUI/MessageUI.h&gt; 系统短信界面的调用很简单，只需下面几句代码： 12345 MFMessageComposeViewController * con = [[MFMessageComposeViewController alloc]init]; if ([MFMessageComposeViewController canSendText]) &#123; con.recipients=@[_phoneNumber];//电话数组 con.messageComposeDelegate=self; [self presentViewController:con animated:YES completion:nil]; 下面将MessageUI的一些常用方法总结如下： + (BOOL)canSendText 判断是否支持发送文字 + (BOOL)canSendSubject; 判断是否支持发送主题信息 + (BOOL)canSendAttachments; 判断是否支持发送附件 + (BOOL)isSupportedAttachmentUTI:(NSString *)uti; 判断是否支持统一标示附件 - (void)disableUserAttachments; 禁止发送附件 @property(nonatomic,copy) NSArray *recipients; 联系人数组，会显示在发送人列表里 @property(nonatomic,copy) NSString *body; 信息主体内容 @property(nonatomic,copy) NSString *subject; 信息标题 @property(nonatomic,copy, readonly) NSArray *attachments; 信息附件数组 只读的 里面是字典 - (BOOL)addAttachmentURL:(NSURL )attachmentURL withAlternateFilename:(NSString )alternateFilename; 根据URL路径和添加附件，返回YES表示添加成功 - (BOOL)addAttachmentData:(NSData )attachmentData typeIdentifier:(NSString )uti filename:(NSString *)filename; 根据Data数据添加附件 - (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result; MFMessageComposeViewControllerDelegate的代理方法，result会传回来一个结果，枚举如下： 12345678enum MessageComposeResult &#123; //取消发送 MessageComposeResultCancelled, //发送成功 MessageComposeResultSent, //发送失败 MessageComposeResultFailed&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS代码运行的磨刀石-预编译指令","slug":"37iOS代码运行的磨刀石-预编译指令","date":"2015-04-27T16:00:00.000Z","updated":"2021-06-21T08:37:21.077Z","comments":true,"path":"2015/04/28/37iOS代码运行的磨刀石-预编译指令/","link":"","permalink":"http://huishao.cc/2015/04/28/37iOS代码运行的磨刀石-预编译指令/","excerpt":"","text":"iOS中代码运行的磨刀石–预编译指令所谓预编译，就是程序代码在编译之前，开发工具为我们预先做的一些工作。不要小瞧这些指令，没有它们，我们的代码可能寸步难行。 一、文件包含相关预处理命令#include #include “header” C语言中使用的包含文件的指令””和&lt;&gt;的区别为，””是从当前目录开始寻找文件，&lt;&gt;是从系统库中寻找文件。这两个指令不能使头文件循环引入，也不能重复包含同一个头文件。 #import “header” #import 这两个指令和上面两个作用一样，只是更加智能，智能处理重复包含头文件的问题。 #include_next “header” #include_next 这两个指令是C中的指令，OC也支持，只是很少使用，它的作用是在找到名字匹配的头文件后跳过，寻找下一个相同名字的导入。 二、宏定义宏定义是开发中会经常用到的一个指令了，我们还会将许多简单的函数定义为宏，省去系统压栈的时间，提高代码效率。因为这篇博客的主题是预处理命令，所以宏的用法和高级用法就不再多写了，下次再讨论。 #define 参数1 参数2 定义一个简单的替换宏，不带参数，在预编译阶段，会把所有参数1的地方直接替换为参数2。 #define ADD(x) (x+x) 定义一个带参数的宏，类似带参函数的功能，但也是编译前做简单替换。 三、条件编译条件编译用于判断一个表达式是否成立，成立则进入条件编译。 方式一： #if 表达式 #else #endif 方式二： #if 表达式 #elif 表达式 #endif 方式三: #ifndef 如果没有定义一个宏进行编译 #ifdef 如果定义一个宏进行编译 四、错误，警告的预处理#error 错误 当程序检查到这里时会停止编译，这个命令的作用是在错误的地方禁止编译。 #warning 警告 这个命令并不会影响程序的编译和运行，但是会认为的在这里显示一条警告信息，提醒我们自己。 五、更改文件名和行号在OC中，有一个系统的定义的宏: __LINE__ 这个宏表示当前行的行号，可以打印。 #line number 改变当前行的行号，会影响下面所有的行 #line number “filename” 改变当前行号和编译后的文件名 六、编译器控制指令#pragma 参数 这个预编译指令是最复杂的，用于控制编译器的行为，一般我们开发应用APP是很少用到的，常用的有两种方式： #pragma mark - 信息 为代码加上标注 #pragma message(“信息”) 编译时提示信息 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS获取通讯录联系人信息","slug":"38iOS获取通讯录联系人信息","date":"2015-04-27T16:00:00.000Z","updated":"2021-06-21T08:41:05.248Z","comments":true,"path":"2015/04/28/38iOS获取通讯录联系人信息/","link":"","permalink":"http://huishao.cc/2015/04/28/38iOS获取通讯录联系人信息/","excerpt":"","text":"iOS获取系统通讯录联系人信息一、权限注册随着apple对用户隐私的越来越重视，IOS系统的权限设置也更加严格，在获取系统通讯录之前，我们必须获得用户的授权。权限申请代码示例如下： 12345678910111213141516171819202122232425262728293031 //这个变量用于记录授权是否成功，即用户是否允许我们访问通讯录 int __block tip=0; //声明一个通讯簿的引用 ABAddressBookRef addBook =nil; //因为在IOS6.0之后和之前的权限申请方式有所差别，这里做个判断 if ([[UIDevice currentDevice].systemVersion floatValue]&gt;=6.0) &#123; //创建通讯簿的引用 addBook=ABAddressBookCreateWithOptions(NULL, NULL); //创建一个出事信号量为0的信号 dispatch_semaphore_t sema=dispatch_semaphore_create(0); //申请访问权限 ABAddressBookRequestAccessWithCompletion(addBook, ^(bool greanted, CFErrorRef error) &#123; //greanted为YES是表示用户允许，否则为不允许 if (!greanted) &#123; tip=1; &#125; //发送一次信号 dispatch_semaphore_signal(sema); &#125;); //等待信号触发 dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); &#125;else&#123; //IOS6之前 addBook =ABAddressBookCreate(); &#125; if (tip) &#123; //做一个友好的提示 UIAlertView * alart = [[UIAlertView alloc]initWithTitle:@&quot;温馨提示&quot; message:@&quot;请您设置允许APP访问您的通讯录\\nSettings&gt;General&gt;Privacy&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil]; [alart show]; return; &#125; 几点注意：1、dispatch_semaphore_t三个相关的操作为 dispatch_semaphore_create 创建一个信号 dispatch_semaphore_signal 发送一个信号 dispatch_semaphore_wait 等待信号触发 dispatch_semaphore_create()创建一个信号，后面可以跟一个参数，表示信号量，当信号量正值时，dispatch_semaphore_wait后面的代码会被执行，否则程序将会一直等待在dispatch_semaphore_wait。 dispatch_semaphore_signal的作用是发送一个信号，会使信号量加1，相对的，dispatch_semaphore_wait执行后会使信号量减1. 2、因为是否被授权是在ABAddressBookRequestAccessWithCompletion的block回调中获取的，所以我们需要在外面做一个线程等待。 二、获取通讯录联系人详细信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 //获取所有联系人的数组 CFArrayRef allLinkPeople = ABAddressBookCopyArrayOfAllPeople(addBook); //获取联系人总数 CFIndex number = ABAddressBookGetPersonCount(addBook); //进行遍历 for (NSInteger i=0; i&lt;number; i++) &#123; //获取联系人对象的引用 ABRecordRef people = CFArrayGetValueAtIndex(allLinkPeople, i); //获取当前联系人名字 NSString*firstName=(__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); //获取当前联系人姓氏 NSString*lastName=(__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); //获取当前联系人中间名 NSString*middleName=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonMiddleNameProperty)); //获取当前联系人的名字前缀 NSString*prefix=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonPrefixProperty)); //获取当前联系人的名字后缀 NSString*suffix=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonSuffixProperty)); //获取当前联系人的昵称 NSString*nickName=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonNicknameProperty)); //获取当前联系人的名字拼音 NSString*firstNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonFirstNamePhoneticProperty)); //获取当前联系人的姓氏拼音 NSString*lastNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonLastNamePhoneticProperty)); //获取当前联系人的中间名拼音 NSString*middleNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonMiddleNamePhoneticProperty)); //获取当前联系人的公司 NSString*organization=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonOrganizationProperty)); //获取当前联系人的职位 NSString*job=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonJobTitleProperty)); //获取当前联系人的部门 NSString*department=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonDepartmentProperty)); //获取当前联系人的生日 NSString*birthday=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonBirthdayProperty)); NSMutableArray * emailArr = [[NSMutableArray alloc]init]; //获取当前联系人的邮箱 注意是数组 ABMultiValueRef emails= ABRecordCopyValue(people, kABPersonEmailProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(emails); j++) &#123; [emailArr addObject:(__bridge NSString *)(ABMultiValueCopyValueAtIndex(emails, j))]; &#125; //获取当前联系人的备注 NSString*notes=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonNoteProperty)); //获取当前联系人的电话 数组 NSMutableArray * phoneArr = [[NSMutableArray alloc]init]; ABMultiValueRef phones= ABRecordCopyValue(people, kABPersonPhoneProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(phones); j++) &#123; [phonerr addObject:(__bridge NSString *)(ABMultiValueCopyValueAtIndex(phones, j))]; &#125; //获取创建当前联系人的时间 注意是NSDate NSDate*creatTime=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonCreationDateProperty)); //获取最近修改当前联系人的时间 NSDate*alterTime=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonModificationDateProperty)); //获取地址 ABMultiValueRef address = ABRecordCopyValue(people, kABPersonAddressProperty); for (int j=0; j&lt;ABMultiValueGetCount(address); j++) &#123; //地址类型 NSString * type = (__bridge NSString *)(ABMultiValueCopyLabelAtIndex(address, j)); NSDictionary * temDic = (__bridge NSDictionary *)(ABMultiValueCopyValueAtIndex(address, j)); //地址字符串，可以按需求格式化 NSString * adress = [NSString stringWithFormat:@&quot;国家:%@\\n省:%@\\n市:%@\\n街道:%@\\n邮编:%@&quot;,[temDic valueForKey:(NSString*)kABPersonAddressCountryKey],[temDic valueForKey:(NSString*)kABPersonAddressStateKey],[temDic valueForKey:(NSString*)kABPersonAddressCityKey],[temDic valueForKey:(NSString*)kABPersonAddressStreetKey],[temDic valueForKey:(NSString*)kABPersonAddressZIPKey]]; &#125; //获取当前联系人头像图片 NSData*userImage=(__bridge NSData*)(ABPersonCopyImageData(people)); //获取当前联系人纪念日 NSMutableArray * dateArr = [[NSMutableArray alloc]init]; ABMultiValueRef dates= ABRecordCopyValue(people, kABPersonDateProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(dates); j++) &#123; //获取纪念日日期 NSDate * data =(__bridge NSDate*)(ABMultiValueCopyValueAtIndex(dates, j)); //获取纪念日名称 NSString * str =(__bridge NSString*)(ABMultiValueCopyLabelAtIndex(dates, j)); NSDictionary * temDic = [NSDictionary dictionaryWithObject:data forKey:str]; [dateArr addObject:temDic]; &#125; 一点扩展：相同的方法，可以获取关联人信息，社交信息，邮箱信息，各种类型的电话信息，字段如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //相关人，组织字段const ABPropertyID kABPersonKindProperty; const CFNumberRef kABPersonKindPerson;const CFNumberRef kABPersonKindOrganization;// 电话相关字段AB_EXTERN const ABPropertyID kABPersonPhoneProperty;AB_EXTERN const CFStringRef kABPersonPhoneMobileLabel;AB_EXTERN const CFStringRef kABPersonPhoneIPhoneLabel AB_EXTERN const CFStringRef kABPersonPhoneMainLabel;AB_EXTERN const CFStringRef kABPersonPhoneHomeFAXLabel;AB_EXTERN const CFStringRef kABPersonPhoneWorkFAXLabel;AB_EXTERN const CFStringRef kABPersonPhoneOtherFAXLabelAB_EXTERN const CFStringRef kABPersonPhonePagerLabel;// 即时聊天信息相关字段AB_EXTERN const ABPropertyID kABPersonInstantMessageProperty; AB_EXTERN const CFStringRef kABPersonInstantMessageServiceKey; AB_EXTERN const CFStringRef kABPersonInstantMessageServiceYahoo;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceJabber;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceMSN;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceICQ;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceAIM;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceQQ AB_EXTERN const CFStringRef kABPersonInstantMessageServiceGoogleTalk;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceSkype;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceFacebook;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceGaduGadu;AB_EXTERN const CFStringRef kABPersonInstantMessageUsernameKey; // 个人网页相关字段AB_EXTERN const ABPropertyID kABPersonURLProperty;AB_EXTERN const CFStringRef kABPersonHomePageLabel; //相关人姓名字段AB_EXTERN const ABPropertyID kABPersonRelatedNamesProperty; AB_EXTERN const CFStringRef kABPersonFatherLabel; // FatherAB_EXTERN const CFStringRef kABPersonMotherLabel; // MotherAB_EXTERN const CFStringRef kABPersonParentLabel; // ParentAB_EXTERN const CFStringRef kABPersonBrotherLabel; // BrotherAB_EXTERN const CFStringRef kABPersonSisterLabel; // SisterAB_EXTERN const CFStringRef kABPersonChildLabel; // ChildAB_EXTERN const CFStringRef kABPersonFriendLabel; // FriendAB_EXTERN const CFStringRef kABPersonSpouseLabel; // SpouseAB_EXTERN const CFStringRef kABPersonPartnerLabel; // PartnerAB_EXTERN const CFStringRef kABPersonAssistantLabel; // AssistantAB_EXTERN const CFStringRef kABPersonManagerLabel; // Manager 三、通讯录“写”的相关操作看到上面读取信息的代码，你可能觉得一阵目炫，其实只是字段比较长，逻辑还是很简单的，同样，写的操作与之类似，创建，修改，删除，是我们对通讯录“写”的常用操作。 1、创建一个联系人123456789101112131415161718192021222324252627 //创建一个联系人引用 ABRecordRef person = ABPersonCreate(); NSString *firstName = @&quot;哈&quot;; NSString *lastName = @&quot;哈&quot;; // 电话号码数组 NSArray *phones = [NSArray arrayWithObjects:@&quot;123&quot;,@&quot;456&quot;,nil]; // 电话号码对应的名称 NSArray *labels = [NSArray arrayWithObjects:@&quot;iphone&quot;,@&quot;home&quot;,nil]; //这里的字段和上面的字段完全相同 // 设置名字属性 ABRecordSetValue(person, kABPersonFirstNameProperty,(__bridge CFStringRef)firstName, NULL); // 设置姓氏属性 ABRecordSetValue(person, kABPersonLastNameProperty, (__bridge CFStringRef)lastName, NULL); // 设置生日属性 ABRecordSetValue(person, kABPersonBirthdayProperty,(__bridge CFDateRef)birthday, NULL); // 字典引用 ABMultiValueRef dic =ABMultiValueCreateMutable(kABMultiStringPropertyType); // 添加电话号码与其对应的名称内容 for (int i = 0; i &lt; [phones count]; i ++) &#123; ABMultiValueIdentifier obj = ABMultiValueAddValueAndLabel(dic,(__bridge CFStringRef)[phones objectAtIndex:i], (__bridge CFStringRef)[labels objectAtIndex:i], &amp;obj); &#125; // 设置phone属性 ABRecordSetValue(person, kABPersonPhoneProperty, dic, NULL); // 将新建的联系人添加到通讯录中 ABAddressBookAddRecord(addBook, person, NULL); // 保存通讯录数据 ABAddressBookSave(addBook, NULL); 2、修改联系人修改联系人的操作就是将获取和添加和在一起，先获取到相应的联系人引用，重设其属性字段即可。 3.删除联系人12345678910111213 //获取所有联系人 NSArray *array = (__bridge NSArray*)ABAddressBookCopyArrayOfAllPeople(addBook); // 遍历所有的联系人 for (id obj in array) &#123; ABRecordRef people = (__bridge ABRecordRef)obj; NSString *firstName = (__bridge NSString*)ABRecordCopyValue(people, kABPersonFirstNameProperty); NSString *lastName = (__bridge NSString*)ABRecordCopyValue(people, kABPersonLastNameProperty); if ([firstName isEqualToString:@&quot;哈&quot;] &amp;&amp;[lastName isEqualToString:@&quot;哈&quot;]) &#123; ABAddressBookRemoveRecord(addBook, people,NULL); &#125; &#125; // 保存修改的通讯录对象 ABAddressBookSave(addBook, NULL); 四、重中之重-关于内存管理上面的代码为了演示方便，创建的全部引用都没有释放，势必是造成内存泄露，在我们用ABAddressBookCreate()创建一个引用对象时，切记无论ARC还MRC，要用CFRelease()进行释放引用，例如上面的例子，我们需要加上这句代码 CFRelease(addBook); 如果你耐心的看到了这里，我想你一定明白了我为什么不在前边的代码里说明这个问题，因为在ARC项目普及的现在，这的确是重中之重。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中JSON数据的解析","slug":"35iOS中JSON数据的解析","date":"2015-04-26T16:00:00.000Z","updated":"2021-06-21T08:23:28.466Z","comments":true,"path":"2015/04/27/35iOS中JSON数据的解析/","link":"","permalink":"http://huishao.cc/2015/04/27/35iOS中JSON数据的解析/","excerpt":"","text":"iOS中JSON数据解析官方为我们提供的解析JSON数据的类是NSJSONSerialization，首先我们先来看下这个类的几个方法： + (BOOL)isValidJSONObject:(id)obj; 判断一个数据对象是否可以转化为JSON数据 + (NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error; 将JSON数据写为NSData数据，其中opt参数的枚举如下，这个参数可以设置，也可以不设置，如果设置，则会输出视觉美观的JSON数据，否则输出紧凑的JSON数据。 123typedef NS_OPTIONS(NSUInteger, NSJSONWritingOptions) &#123; NSJSONWritingPrettyPrinted = (1UL &lt;&lt; 0)&#125; + (id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error; 这个方法是解析中数据的核心方法，data是JSON数据对象，可以设置一个opt参数，具体用法如下： 12345678typedef NS_OPTIONS(NSUInteger, NSJSONReadingOptions) &#123; //将解析的数组和字典设置为可变对象 NSJSONReadingMutableContainers = (1UL &lt;&lt; 0), //将解析数据的子节点创建为可变字符串对象 NSJSONReadingMutableLeaves = (1UL &lt;&lt; 1), //允许解析对象的最上层不是字典或者数组 NSJSONReadingAllowFragments = (1UL &lt;&lt; 2)&#125; + (NSInteger)writeJSONObject:(id)obj toStream:(NSOutputStream *)stream options:(NSJSONWritingOptions)opt error:(NSError **)error; 将JSON数据写入到输出流，返回的是写入流的字节数 + (id)JSONObjectWithStream:(NSInputStream *)stream options:(NSJSONReadingOptions)opt error:(NSError **)error; 从输入流读取JSON数据 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS(CGGeometry)几何类方法总结","slug":"36iOS(CGGeometry)几何类方法总结","date":"2015-04-26T16:00:00.000Z","updated":"2021-06-21T08:32:55.866Z","comments":true,"path":"2015/04/27/36iOS(CGGeometry)几何类方法总结/","link":"","permalink":"http://huishao.cc/2015/04/27/36iOS(CGGeometry)几何类方法总结/","excerpt":"","text":"iOS开发几何类方法总结CGGeometry.h文件是用C语言实现的一个封装了许多常用几何方法的文件。 一、几个常用结构体struct CGPoint { CGFloat x; CGFloat y; }; 定义一个点，设置x坐标和y坐标 struct CGSize { CGFloat width; CGFloat height; }; 定义一个尺寸，设置宽度和高度 struct CGVector { CGFloat dx; CGFloat dy; }; 定义一个二维矢量 struct CGRect { CGPoint origin; CGSize size; }; 定义一个矩形 二、几个系统定义的量const CGPoint CGPointZero 零点，与CGPointMake(0, 0)等效 const CGSize CGSizeZero 零尺寸，与CGSizeMake(0, 0)等效 const CGRect CGRectZero 零矩形，与CGRectMake(0, 0, 0, 0)等效 const CGRect CGRectNull 空矩形，这个和零矩形并不相同，当我们返回两个不相交矩形的交集时，会返回空矩形。 const CGRect CGRectInfinite 无限的矩形 三、一些常用方法CGPoint CGPointMake(CGFloat x, CGFloat y); 创建一个点 CGSize CGSizeMake(CGFloat width, CGFloat height); 创建一个尺寸 CGVectorMake(CGFloat dx, CGFloat dy); 创建一个矢量 CGRect CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height); 创建一个矩形 CGFloat CGRectGetMinX(CGRect rect); 获得矩形最左边的x值 CGFloat CGRectGetMidX(CGRect rect); 获取矩形中点的x值 CGFloat CGRectGetMaxX(CGRect rect); 获取矩形最右端的x值 CGFloat CGRectGetMinY(CGRect rect); 获取矩形最上端的y值 CGFloat CGRectGetMidY(CGRect rect); 获取矩形中心点的y值 CGFloat CGRectGetMaxY(CGRect rect); 获取矩形最下端的y值 CGFloat CGRectGetWidth(CGRect rect); 获取矩形宽度 CGFloat CGRectGetHeight(CGRect rect); 获取矩形高度 bool CGPointEqualToPoint(CGPoint point1, CGPoint point2); 判断两个点是否相等 bool CGSizeEqualToSize(CGSize size1, CGSize size2); 判断两个尺寸是否相等 bool CGRectEqualToRect(CGRect rect1, CGRect rect2); 判断两个矩形是否相等 CGRect CGRectStandardize(CGRect rect); 根据一个矩形创建一个标准的矩形 bool CGRectIsEmpty(CGRect rect); 判断是否为零矩形 CGRectIsNull(CGRect rect); 判断是否为空矩形 bool CGRectIsInfinite(CGRect rect); 判断是否为无限矩形 CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy); 创建一个内嵌的矩形，中心和rect参数的中心一样，dx，dy对应内嵌的宽度和高度 比如：CGRect rect= CGRectInset(CGRectMake(0, 0, 100, 100), 10, 10); 会创建出的rect为（10，10，80，80），dx，dy也可以为负值，则是创建出来的矩形会大于原矩形范围。 CGRect CGRectIntegral(CGRect rect) 根据一个矩形，返回四个参数都是整数的矩形 CGRect CGRectUnion(CGRect r1, CGRect r2); 返回两个矩形的并集 CGRect CGRectIntersection(CGRect r1, CGRect r2); 返回两个矩形的交集，如果没有交集，返回空矩形 CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy); 返回一个矩形，偏移量相对于rect void CGRectDivide(CGRect rect, CGRect slice, CGRect remainder, CGFloat amount, CGRectEdge edge); 这个函数用来分割矩形，参数rect是源矩形，slice和remainder是分割后的两部分矩形，amount是分割线，edge是分割选项。 注意：1、edge是一个宏，定义了分割的方式如下： 12345678910typedef CF_ENUM(uint32_t, CGRectEdge) &#123; //从x的最小处进行垂直分割 CGRectMinXEdge, //从y的最小处进行水平分割 CGRectMinYEdge, //从x最大处进行垂直分割 CGRectMaxXEdge, //从y最大处进行水平分割 CGRectMaxYEdge&#125;; 2、slice和remainder是地址。 3、举例如下，将会分割出两个矩形分别为(40,0,60,100)(0,0,40,100); 1234CGRect rect = CGRectMake(0, 0, 100, 100); CGRect slice ; CGRect remainder; CGRectDivide(rect, &amp;slice, &amp;remainder, 60, CGRectMaxXEdge); bool CGRectContainsPoint(CGRect rect, CGPoint point); 判断点是否在矩形内 bool CGRectContainsRect(CGRect rect1, CGRect rect2); 判断矩形1是否包含矩形2 bool CGRectIntersectsRect(CGRect rect1, CGRect rect2); 判断矩形1和矩形2是否相交 CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point); 返回一个表示点的字典 bool CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point); 将字典转换为点 CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size); 返回一个表示尺寸的字典 bool CGSizeMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGSize *size) ; 将字典转换为尺寸 CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect); 返回一个表示矩形的字典 bool CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect); 将字典转化为矩形 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中使用像素位图(CGImageRef)对图片进行处理","slug":"34iOS中使用像素位图(CGImageRef)对图片进行处理","date":"2015-04-25T16:00:00.000Z","updated":"2021-06-21T05:51:24.579Z","comments":true,"path":"2015/04/26/34iOS中使用像素位图(CGImageRef)对图片进行处理/","link":"","permalink":"http://huishao.cc/2015/04/26/34iOS中使用像素位图(CGImageRef)对图片进行处理/","excerpt":"","text":"iOS中对图片进行重绘处理的方法总结一、CGImageRef是什么CGImageRef是定义在QuartzCore框架中的一个结构体指针，用C语言编写。在CGImage.h文件中，我们可以看到下面的定义： 1typedef struct CGImage *CGImageRef; CGImageRef 和 struct CGImage * 是完全等价的。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。 QuartzCore这个框架是可移植的。 二、CGImageRef相关的一些方法解析CFTypeID CGImageGetTypeID(void) 这个方法返回的是一个编号，每个Core Foundation框架中得结构都会有一个这样的编号，CFTypeID定义如下： 1234567891011#if __LLP64__typedef unsigned long long CFTypeID;typedef unsigned long long CFOptionFlags;typedef unsigned long long CFHashCode;typedef signed long long CFIndex;#elsetypedef unsigned long CFTypeID;typedef unsigned long CFOptionFlags;typedef unsigned long CFHashCode;typedef signed long CFIndex;#endif 这个方法没有特殊的意义，只是一个标识符。 CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent); 通过这个方法，我们可以创建出一个CGImageRef类型的对象，下面分别对参数进行解释： sizt_t是定义的一个可移植性的单位，在64位机器中为8字节，32位位4字节。 width：图片宽度像素 height：图片高度像素 bitsPerComponent：每个颜色的比特数，例如在rgba-32模式下为8 bitsPerPixel：每个像素的总比特数 bytesPerRow：每一行占用的字节数，注意这里的单位是字节 space：颜色空间模式，例如const CFStringRef kCGColorSpaceGenericRGB 这个函数可以返回一个颜色空间对象。 bitmapInfo：位图像素布局，枚举如下： 1234567891011typedef CF_OPTIONS(uint32_t, CGBitmapInfo) &#123; kCGBitmapAlphaInfoMask = 0x1F, kCGBitmapFloatComponents = (1 &lt;&lt; 8), kCGBitmapByteOrderMask = 0x7000, kCGBitmapByteOrderDefault = (0 &lt;&lt; 12), kCGBitmapByteOrder16Little = (1 &lt;&lt; 12), kCGBitmapByteOrder32Little = (2 &lt;&lt; 12), kCGBitmapByteOrder16Big = (3 &lt;&lt; 12), kCGBitmapByteOrder32Big = (4 &lt;&lt; 12)&#125; provider：数据源提供者 decode[]：解码渲染数组 shouldInterpolate：是否抗锯齿 intent：图片相关参数 CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat decode\\[\\], bool shouldInterpolate) 这个方法用于创建mask图片图层，可以设置其显示部分与不显示部分达到特殊的效果，参数意义同上。 CGImageRef CGImageCreateCopy(CGImageRef image) 这个方法可以复制一个CGImageRef对象 CGImageRef CGImageCreateWithJPEGDataProvider(CGDataProviderRef source, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent) 通过JPEG数据源获取图像 CGImageRef CGImageCreateWithPNGDataProvider(CGDataProviderRef source, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent) 通过PNG数据源获取图像 CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect) 截取图像的一个区域重绘图像 CGImageRef CGImageCreateWithMask(CGImageRef image, CGImageRef mask) 截取mask图像的某一区域重绘 CGImageRef CGImageCreateWithMaskingColors(CGImageRef image, const CGFloat components\\[\\]) 通过颜色分量数组创建位图 CGImageRef CGImageCreateCopyWithColorSpace(CGImageRef image, CGColorSpaceRef space) 通过颜色空间模式复制位图 CGImageRef CGImageRetain(CGImageRef image) 引用+1 void CGImageRelease(CGImageRef image) 引用-1 bool CGImageIsMask(CGImageRef image) 返回是否为Mask图层 size_t CGImageGetWidth(CGImageRef image) 获取宽度像素 size_t CGImageGetHeight(CGImageRef image) 获取高度像素 下面这些方法分别获取相应属性 size_t CGImageGetBitsPerComponent(CGImageRef image) size_t CGImageGetBitsPerPixel(CGImageRef image) size_t CGImageGetBytesPerRow(CGImageRef image) CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)CG_EXTERN CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image) CGDataProviderRef CGImageGetDataProvider(CGImageRef image) const CGFloat *CGImageGetDecode(CGImageRef image) bool CGImageGetShouldInterpolate(CGImageRef image) CGColorRenderingIntent CGImageGetRenderingIntent(CGImageRef image) CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image) 三、应用举例使用CGImageRef进行图片截取 12345678910 //原图片 UIImage * img = [UIImage imageNamed:@&quot;11.11.52.png&quot;]; //转化为位图 CGImageRef temImg = img.CGImage; //根据范围截图 temImg=CGImageCreateWithImageInRect(temImg, CGRectMake(0, 0, 100, 100)); //得到新的图片 UIImage *new = [UIImage imageWithCGImage:temImg]; //释放位图对象 CGImageRelease(temImg); 注意：最后必须要调用这个函数，否则会造成内存泄露 1 CGImageRelease(temImg) 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中通知中心(NSNotificationCenter)的使用总结","slug":"33iOS中通知中心(NSNotificationCenter)的使用总结","date":"2015-04-24T16:00:00.000Z","updated":"2021-06-21T03:05:07.652Z","comments":true,"path":"2015/04/25/33iOS中通知中心(NSNotificationCenter)的使用总结/","link":"","permalink":"http://huishao.cc/2015/04/25/33iOS中通知中心(NSNotificationCenter)的使用总结/","excerpt":"","text":"iOS中通知中心NSNotificationCenter应用总结一、了解几个相关的类1、NSNotification这个类可以理解为一个消息对象，其中有三个成员变量。 这个成员变量是这个消息对象的唯一标识，用于辨别消息对象。 @property (readonly, copy) NSString *name; 这个成员变量定义一个对象，可以理解为针对某一个对象的消息。 @property (readonly, retain) id object; 这个成员变量是一个字典，可以用其来进行传值。 @property (readonly, copy) NSDictionary *userInfo; NSNotification的初始化方法： - (instancetype)initWithName:(NSString )name object:(id)object userInfo:(NSDictionary )userInfo; + (instancetype)notificationWithName:(NSString *)aName object:(id)anObject; + (instancetype)notificationWithName:(NSString )aName object:(id)anObject userInfo:(NSDictionary )aUserInfo; 注意:官方文档有明确的说明，不可以使用init进行初始化 2、NSNotificationCenter这个类是一个通知中心，使用单例设计，每个应用程序都会有一个默认的通知中心。用于调度通知的发送的接受。 添加一个观察者，可以为它指定一个方法，名字和对象。接受到通知时，执行方法。 - (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject; 发送通知消息的方法 - (void)postNotification:(NSNotification *)notification; - (void)postNotificationName:(NSString *)aName object:(id)anObject; - (void)postNotificationName:(NSString )aName object:(id)anObject userInfo:(NSDictionary )aUserInfo; 移除观察者的方法 - (void)removeObserver:(id)observer; - (void)removeObserver:(id)observer name:(NSString *)aName object:(id)anObject; 几点注意： 1、如果发送的通知指定了object对象，那么观察者接收的通知设置的object对象与其一样，才会接收到通知，但是接收通知如果将这个参数设置为了nil，则会接收一切通知。 2、观察者的SEL函数指针可以有一个参数，参数就是发送的死奥西对象本身，可以通过这个参数取到消息对象的userInfo，实现传值。 二、通知的使用流程首先，我们在需要接收通知的地方注册观察者，比如： 1234 //获取通知中心单例对象 NSNotificationCenter * center = [NSNotificationCenter defaultCenter]; //添加当前类对象为一个观察者，name和object设置为nil，表示接收一切通知 [center addObserver:self selector:@selector(notice:) name:@&quot;123&quot; object:nil]; 之后，在我们需要时发送通知消息 1234 //创建一个消息对象 NSNotification * notice = [NSNotification notificationWithName:@&quot;123&quot; object:nil userInfo:@&#123;@&quot;1&quot;:@&quot;123&quot;&#125;]; //发送消息 [[NSNotificationCenter defaultCenter]postNotification:notice]; 我们可以在回调的函数中取到userInfo内容，如下： 123-(void)notice:(id)sender&#123; NSLog(@&quot;%@&quot;,sender);&#125; 打印结果如下： 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS7使用原生API进行二维码和条形码的扫描","slug":"32iOS7使用原生API进行二维码和条形码的扫描","date":"2015-04-23T16:00:00.000Z","updated":"2021-06-21T03:04:00.268Z","comments":true,"path":"2015/04/24/32iOS7使用原生API进行二维码和条形码的扫描/","link":"","permalink":"http://huishao.cc/2015/04/24/32iOS7使用原生API进行二维码和条形码的扫描/","excerpt":"","text":"使用iOS7原生API进行二维码条形码的扫描IOS7之前，开发者进行扫码编程时，一般会借助第三方库。常用的是ZBarSDK，IOS7之后，系统的AVMetadataObject类中，为我们提供了解析二维码的接口。经过测试，使用原生API扫描和处理的效率非常高，远远高于第三方库。 一、使用方法示例官方提供的接口非常简单，代码如下： 123456789101112131415161718192021222324252627282930313233343536@interface ViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate&gt;//用于处理采集信息的代理&#123; AVCaptureSession * session;//输入输出的中间桥梁&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //获取摄像设备 AVCaptureDevice * device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; //创建输入流 AVCaptureDeviceInput * input = [AVCaptureDeviceInput deviceInputWithDevice:device error:nil]; //创建输出流 AVCaptureMetadataOutput * output = [[AVCaptureMetadataOutput alloc]init]; //设置代理 在主线程里刷新 [output setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()]; //初始化链接对象 session = [[AVCaptureSession alloc]init]; //高质量采集率 [session setSessionPreset:AVCaptureSessionPresetHigh]; [session addInput:input]; [session addOutput:output]; //设置扫码支持的编码格式(如下设置条形码和二维码兼容) output.metadataObjectTypes=@[AVMetadataObjectTypeQRCode,AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode128Code]; AVCaptureVideoPreviewLayer * layer = [AVCaptureVideoPreviewLayer layerWithSession:session]; layer.videoGravity=AVLayerVideoGravityResizeAspectFill; layer.frame=self.view.layer.bounds; [self.view.layer insertSublayer:layer atIndex:0]; //开始捕获 [session startRunning];&#125; 之后我们的UI上已经可以看到摄像头捕获的内容，只要实现代理中的方法，就可以完成二维码条形码的扫描： 12345678-(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection&#123; if (metadataObjects.count&gt;0) &#123; //[session stopRunning]; AVMetadataMachineReadableCodeObject * metadataObject = [metadataObjects objectAtIndex : 0 ]; //输出扫描字符串 NSLog(@&quot;%@&quot;,metadataObject.stringValue); &#125;&#125; 二、一些优化通过上面的代码测试，我们可以发现系统的解析处理效率是相当的高，IOS官方提供的API也确实非常强大，然而，我们可以做进一步的优化，将效率更加提高： 首先，AVCaptureMetadataOutput类中有一个这样的属性(在IOS7.0之后可用)： @property(nonatomic) CGRect rectOfInterest; 这个属性大致意思就是告诉系统它需要注意的区域，大部分APP的扫码UI中都会有一个框，提醒你将条形码放入那个区域，这个属性的作用就在这里，它可以设置一个范围，只处理在这个范围内捕获到的图像的信息。如此一来，可想而知，我们代码的效率又会得到很大的提高，在使用这个属性的时候。需要几点注意： 1、这个CGRect参数和普通的Rect范围不太一样，它的四个值的范围都是0-1，表示比例。 2、经过测试发现，这个参数里面的x对应的恰恰是距离左上角的垂直距离，y对应的是距离左上角的水平距离。 3、宽度和高度设置的情况也是类似。 3、举个例子如果我们想让扫描的处理区域是屏幕的下半部分，我们这样设置 1output.rectOfInterest=CGRectMake(0.5,0,0.5, 1); 具体apple为什么要设计成这样，或者是这个参数我的用法那里不对，还需要了解的朋友给个指导。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中使用本地通知为你的APP添加提示用户功能","slug":"31iOS中使用本地通知为你的APP添加提示用户功能","date":"2015-04-22T16:00:00.000Z","updated":"2021-06-21T02:28:44.460Z","comments":true,"path":"2015/04/23/31iOS中使用本地通知为你的APP添加提示用户功能/","link":"","permalink":"http://huishao.cc/2015/04/23/31iOS中使用本地通知为你的APP添加提示用户功能/","excerpt":"","text":"iOS中使用本地通知为你的APP添加提示用户功能首先，我们先要明白一个概念，这里的本地通知是UILocalNotification类，和系统的NSNotificationCenter通知中心是完全不同的概念。 一、我们可以通过本地通知做什么通知，实际上是由IOS系统管理的一个功能，比如某些后台应用做了某项活动需要我们处理、已经退出的应用在某个时间提醒我们唤起等等，如果注册了通知，系统都会在通知触发时给我们发送消息。由此，我们可以通过系统给我们的APP添加通知用户的功能，并且应用非常广泛。例如，闹种类应用，有按时签到相似功能的应用。下面，我们就来介绍如何注册并且设置一个本地通知。 二、了解UILocalNotification类顾名思义，这个类就是我们需要使用的本地通知类，先来看它的几个属性： 设置系统发送通知的时间(如果是过去的时间或者0，则会立刻发起通知) @property(nonatomic,copy) NSDate *fireDate; 设置时间的时区 @property(nonatomic,copy) NSTimeZone *timeZone; 设置周期性通知 @property(nonatomic) NSCalendarUnit repeatInterval; NSCalendarUnit对象是枚举，设定通知的周期 1234567891011typedef NS_OPTIONS(NSUInteger, NSCalendarUnit) &#123; NSCalendarUnitEra = kCFCalendarUnitEra, NSCalendarUnitYear = kCFCalendarUnitYear, NSCalendarUnitMonth = kCFCalendarUnitMonth, NSCalendarUnitDay = kCFCalendarUnitDay, NSCalendarUnitHour = kCFCalendarUnitHour, NSCalendarUnitMinute = kCFCalendarUnitMinute, NSCalendarUnitSecond = kCFCalendarUnitSecond, NSCalendarUnitWeekday = kCFCalendarUnitWeekday, NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal, &#125; 设置周期性通知参照的日历表 @property(nonatomic,copy) NSCalendar *repeatCalendar; 下面这两个函数是IOS8的新功能，在用户进去或者离开某一区域时发送通知 @property(nonatomic,copy) CLRegion *region; 设置区域检测通知是否重复(如果为YES，则没次进去出来都会发送，否则只发送一次) @property(nonatomic,assign) BOOL regionTriggersOnce; 设置通知的主体内容 @property(nonatomic,copy) NSString *alertBody; 是否隐藏滑动启动按钮 @property(nonatomic) BOOL hasAction; 设置滑动打开的提示文字 @property(nonatomic,copy) NSString *alertAction; 设置点击通知后启动的启动图片 @property(nonatomic,copy) NSString *alertLaunchImage; 下面这个方法是IOS8的新方法，是iwatch的接口，通知的短标题 @property(nonatomic,copy) NSString *alertTitle; 收到通知时，播放的系统音 @property(nonatomic,copy) NSString *soundName; 设置应用程序Icon头标数字 @property(nonatomic) NSInteger applicationIconBadgeNumber; 用户字典，可用于传递通知消息参数 @property(nonatomic,copy) NSDictionary *userInfo; 注意：这个字符串是系统默认的提示音 NSString *const UILocalNotificationDefaultSoundName; 三、本地通知的设计流程首先，想让我们的APP实现本地通知功能，必须得到用户的授权，在Appdelegate中实现如下代码： 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //如果已经得到授权，就直接添加本地通知，否则申请询问授权 if ([[UIApplication sharedApplication]currentUserNotificationSettings].types!=UIUserNotificationTypeNone) &#123; [self addLocalNotification]; &#125;else&#123; [[UIApplication sharedApplication]registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]]; &#125; return YES;&#125; 当用户点击允许或者不允许后，会执行如下代理方法，我们把处理逻辑在其中实现 12345-(void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings&#123; if (notificationSettings.types!=UIUserNotificationTypeNone) &#123; [self addLocalNotification]; &#125;&#125; 添加本地通知的方法： 12345678910111213-(void)addLocalNotification&#123; //定义本地通知对象 UILocalNotification *notification=[[UILocalNotification alloc]init]; //设置调用时间 notification.fireDate=[NSDate dateWithTimeIntervalSinceNow:0];//立即触发 //设置通知属性 notification.alertBody=@&quot;HELLO，我是本地通知哦!&quot;; //通知主体 notification.applicationIconBadgeNumber=1;//应用程序图标右上角显示的消息数 notification.alertAction=@&quot;打开应用&quot;; //待机界面的滑动动作提示 notification.soundName=UILocalNotificationDefaultSoundName;//收到通知时播放的声音，默认消息声音 //调用通知 [[UIApplication sharedApplication] scheduleLocalNotification:notification];&#125; 实现了上面三个步骤，本地通知的发出和接受基本都已完成，还有一些细节我们需要考虑： 应用进入前台后，将Icon上的头标清除： 123-(void)applicationWillEnterForeground:(UIApplication *)application&#123; [[UIApplication sharedApplication]setApplicationIconBadgeNumber:0];//进入前台取消应用消息图标&#125; 当不再需要这个通知时，清除它 1 [[UIApplication sharedApplication] cancelAllLocalNotifications]; 四、获取通知中的用户参数字典在上面，我们提到了一个参数 @property(nonatomic,copy) NSDictionary *userInfo; 我们可以在注册通知时将这个参数设置，然后在收到通知时使用get方法得到，但是这里有两种情况： 1、如果我们的APP在前台或者后台进入前台时-(void)application:(UIApplication )application didReceiveLocalNotification:(UILocalNotification )notification; 这个方法是APP在前台或者后台收到通知进入前台时调用的方法 2、如果我们的APP在关闭状态如果是这种情况，我们只能从下面函数的launchOptions中取到我们想要的参数 - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions; 代码示例如下： 123 //接收通知参数 UILocalNotification *notification=[launchOptions valueForKey:UIApplicationLaunchOptionsLocalNotificationKey]; NSDictionary *userInfo= notification.userInfo; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UITableView代理方法详解","slug":"29iOS UITableView代理方法详解","date":"2015-04-21T16:00:00.000Z","updated":"2021-06-10T09:02:45.123Z","comments":true,"path":"2015/04/22/29iOS UITableView代理方法详解/","link":"","permalink":"http://huishao.cc/2015/04/22/29iOS UITableView代理方法详解/","excerpt":"","text":"iOS UITableView的代理方法详解一、补充在上一篇博客中，http://my.oschina.net/u/2340880/blog/404605，我将IOS中tableView(表视图)的一些常用方法总结了一下，这篇将tableView的代理方法作了总结，对上一篇博客进行了补充。 二、UITableViewDataSourc（数据源代理）1、必须实现的回调方法返回每个分区的行数 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; 返回每一行的cell - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; 2、可选实现的方法返回分区数(默认为1) - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 返回每个分区头部的标题 - (NSString )tableView:(UITableView )tableView titleForHeaderInSection:(NSInteger)section; 返回每个分区的尾部标题 - (NSString )tableView:(UITableView )tableView titleForFooterInSection:(NSInteger)section; 设置某行是否可编辑 - (BOOL)tableView:(UITableView )tableView canEditRowAtIndexPath:(NSIndexPath )indexPath; 设置某行是否可以被移动 - (BOOL)tableView:(UITableView )tableView canMoveRowAtIndexPath:(NSIndexPath )indexPath; 设置索引栏标题数组（实现这个方法，会在tableView右边显示每个分区的索引） - (NSArray )sectionIndexTitlesForTableView:(UITableView )tableView; 设置索引栏标题对应的分区 - (NSInteger)tableView:(UITableView )tableView sectionForSectionIndexTitle:(NSString )title atIndex:(NSInteger)index tableView接受编辑时调用的方法 - (void)tableView:(UITableView )tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath )indexPath; 这个方法中的editingStyle参数是一个枚举，代表了cell被编辑的模式，如下： 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone,//没有编辑操作 UITableViewCellEditingStyleDelete,//删除操作 UITableViewCellEditingStyleInsert//插入操作&#125;; tableView的cell被移动时调用的方法 - (void)tableView:(UITableView )tableView moveRowAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath; 三、UITableViewDelegate（tableView代理）cell将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath *)indexPath; 头视图将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayHeaderView:(UIView )view forSection:(NSInteger)section; 尾视图将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayFooterView:(UIView )view forSection:(NSInteger)section; 和上面的方法对应，这三个方法分别是cell，头视图，尾视图已经显示时调用的方法 - (void)tableView:(UITableView )tableView didEndDisplayingCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath*)indexPath; - (void)tableView:(UITableView )tableView didEndDisplayingHeaderView:(UIView )view forSection:(NSInteger)section; - (void)tableView:(UITableView )tableView didEndDisplayingFooterView:(UIView )view forSection:(NSInteger)section; 设置行高，头视图高度和尾视图高度的方法 - (CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath; - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section; 设置行高，头视图高度和尾视图高度的估计值(对于高度可变的情况下，提高效率) - (CGFloat)tableView:(UITableView )tableView estimatedHeightForRowAtIndexPath:(NSIndexPath )indexPath; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section; 设置自定义头视图和尾视图 - (UIView )tableView:(UITableView )tableView viewForHeaderInSection:(NSInteger)section; - (UIView )tableView:(UITableView )tableView viewForFooterInSection:(NSInteger)section; 设置cell是否可以高亮 - (BOOL)tableView:(UITableView )tableView shouldHighlightRowAtIndexPath:(NSIndexPath )indexPath; cell高亮和取消高亮时分别调用的函数 - (void)tableView:(UITableView )tableView didHighlightRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView )tableView didUnhighlightRowAtIndexPath:(NSIndexPath )indexPath; 当即将选中某行和取消选中某行时调用的函数，返回一直位置，执行选中或者取消选中 - (NSIndexPath )tableView:(UITableView )tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath; - (NSIndexPath )tableView:(UITableView )tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath; 已经选中和已经取消选中后调用的函数 - (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView )tableView didDeselectRowAtIndexPath:(NSIndexPath )indexPath; 设置tableView被编辑时的状态风格，如果不设置，默认都是删除风格 - (UITableViewCellEditingStyle)tableView:(UITableView )tableView editingStyleForRowAtIndexPath:(NSIndexPath )indexPath; 自定义删除按钮的标题 - (NSString )tableView:(UITableView )tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath; 下面这个方法是IOS8中的新方法，用于自定义创建tableView被编辑时右边的按钮，按钮类型为UITableViewRowAction。 - (NSArray )tableView:(UITableView )tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath ; 设置编辑时背景是否缩进 - (BOOL)tableView:(UITableView )tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath )indexPath; 将要编辑和结束编辑时调用的方法 - (void)tableView:(UITableView)tableView willBeginEditingRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView)tableView didEndEditingRowAtIndexPath:(NSIndexPath )indexPath; 移动特定的某行 - (NSIndexPath )tableView:(UITableView )tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath )sourceIndexPath toProposedIndexPath:(NSIndexPath )proposedDestinationIndexPath; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITableView","slug":"UITableView","permalink":"http://huishao.cc/tags/UITableView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS8的新特性：简洁易用的毛玻璃效果","slug":"30iOS8的新特性：简洁易用的毛玻璃效果","date":"2015-04-21T16:00:00.000Z","updated":"2021-06-10T09:03:58.590Z","comments":true,"path":"2015/04/22/30iOS8的新特性：简洁易用的毛玻璃效果/","link":"","permalink":"http://huishao.cc/2015/04/22/30iOS8的新特性：简洁易用的毛玻璃效果/","excerpt":"","text":"探寻iOS8的新亮点：毛玻璃效果的简易实现IOS8之前，apple官方并不建议开发者使用类似毛玻璃的模糊效果，也并没有开放相关的接口，大部分的开发者是通过转化CGImage这个类来实现毛玻璃的模糊效果，并且实现的效果也很优秀。在IOS8之后，苹果官方新出了一个类UIVisualEffectView，通过这个类，实现毛玻璃效果变得轻而易举，而且效率非常之高，下面，我们来介绍下这个类的简单用法。 一、了解几个类1、UIVisualEffectView 这个类为我们提供了一个方便的接口，用来展示复杂的图像效果。 2、UIVisualEffect 官方对这个类的解释相当简单，它没有任何方法，只是充当一个帮助UIVisualEffectView创建的对象，是UIBlurEffect和UIVibrancyEffect的父类，或者可以理解，它的功能相当于一个抽象类。 3、UIBlurEffect 这个类是创建模糊效果，也就是毛玻璃效果的类，可以设置风格。 4、UIVibrancyEffect 从这个类的名字就可以看出，这个类是UIBlurEffect的扩展，可以创建出明亮的标签的按钮。 二、开始创建虚化的背景首先，初始化一个UIVisualEffectView对象： - (instancetype)initWithEffect:(UIVisualEffect *)effect; 这个方法里面的参数是UIVisuaEffect对象，我们先用UIBlueEffect的方式来创建： + (UIBlurEffect *)effectWithStyle:(UIBlurEffectStyle)style; 这个方法可以设置一个风格参数，风格枚举如下： 12345typedef NS_ENUM(NSInteger, UIBlurEffectStyle) &#123; UIBlurEffectStyleExtraLight,//高亮的风格 UIBlurEffectStyleLight,//亮化的风格 UIBlurEffectStyleDark//暗化的风格&#125; ; 这些都做好之后，我们需要给这个UIVisualEfffectView对象一个frame，然后直接加到我们想要虚化的背景上，总体代码如下： 123456789 UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleExtraLight]]; //设置虚化度 effectView.alpha=1.0; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 三、UIVisualEffectView的几个属性@property (nonatomic, retain, readonly) UIView *contentView; 这个参数和我们后面将要说的创建明亮的标签和按钮有关，这里先不多介绍。 @property (nonatomic, copy, readonly) UIVisualEffect *effect; 获得UIVissualEffect对象 @property(nonatomic) CGFloat alpha; 这个参数和虚化的程度有关 四、在虚化的背景上创建颜色绚丽的标签我们先来看一个效果，我们在刚才创建的虚化的背景上添加一个标签，代码如下： 12345678910111213UILabel * view2 = [[UILabel alloc]init]; view2.text=@&quot;注意看字体的颜色!&quot;; view2.font=[UIFont boldSystemFontOfSize:32]; view2.frame=CGRectMake(0, 0,300, 100); UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleExtraLight]]; [effectView addSubview:view2]; effectView.alpha=0.8; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 我们换另一种虚化效果来对背景进行虚化： 12345678910111213UILabel * view2 = [[UILabel alloc]init]; view2.text=@&quot;注意看字体的颜色!&quot;; view2.font=[UIFont boldSystemFontOfSize:32]; view2.frame=CGRectMake(0, 0,300, 100); UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIVibrancyEffect effectForBlurEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]]]; [effectView.contentView addSubview:view2]; effectView.alpha=0.8; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 现在可以很明白的了解，UIBlurEffect是对整个背景进行虚化，UIVibrancyEffect是对添加的标签等附件进行背景虚化。注意，这些附件，必须加在UIVisualEffectView的contentView里，否则将不起任何作用。 五、一个小控件通过上面的介绍，我们可以发现，在IOS8中创建一个毛玻璃效果是如此的容易，apple官方提供的类也是如此的强大，我们很轻松就可以实现实时变化虚化程度的动画效果，这在以前是非常麻烦和低效的。但是apple还有一个忠告：莫要泛滥的使用虚化，导致很差的用户体验! 最后，和大家分享一个前两天写的小控件，实现的效果是仿IOS8中在桌面下拉会是背景渐变虚化，从顶部会滑出搜索框。如下：可以当做一个demo来参考。 链接地址：http://d.cocoachina.com/code/detail/297393。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中表视图(UITableView)使用详解","slug":"28iOS中表视图(UITableView)使用详解","date":"2015-04-20T16:00:00.000Z","updated":"2021-06-10T09:01:26.033Z","comments":true,"path":"2015/04/21/28iOS中表视图(UITableView)使用详解/","link":"","permalink":"http://huishao.cc/2015/04/21/28iOS中表视图(UITableView)使用详解/","excerpt":"","text":"iOS中UITableView使用总结一、初始化方法- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style; 这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下： 1234typedef NS_ENUM(NSInteger, UITableViewStyle) &#123; UITableViewStylePlain, // 标准的表视图风格 UITableViewStyleGrouped // 分组的表视图风格&#125;; 二、常用属性获取表视图的风格(只读属性) @property (nonatomic, readonly) UITableViewStyle style; 设置表示图代理和数据源代理(代理方法后面讨论) @property (nonatomic, assign) id &lt;UITableViewDataSource> dataSource; @property (nonatomic, assign) id &lt;UITableViewDelegate> delegate; 设置表示图的行高(默认为44) @property (nonatomic)CGFloat rowHeight; 设置分区的头视图高度和尾视图高度(当代理方法没有实现时才有效) @property (nonatomic) CGFloat sectionHeaderHeight; @property (nonatomic) CGFloat sectionFooterHeight; 设置一个行高的估计值(默认为0，表示没有估计,7.0之后可用) @property (nonatomic) CGFloat estimatedRowHeight; 注意：这个属性官方的解释是如果你的tableView的行高是可变的，那么设计一个估计高度可以加快代码的运行效率。 下面这两个属性和上面相似，分别设置分区头视图和尾视图的估计高度(7.0之后可用) @property (nonatomic) CGFloat estimatedSectionHeaderHeight; @property (nonatomic) CGFloat estimatedSectionFooterHeight; 设置分割线的位置 @property (nonatomic) UIEdgeInsets separatorInset; 如果细心，你可能会发现系统默认的tableView的分割线左端并没有顶到边沿。通过这个属性，可以手动设置分割线的位置偏移，比如你向让tableView的分割线只显示右半边，可以如下设置： 12UITableView * tab = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain];tab.separatorInset=UIEdgeInsetsMake(0, tab.frame.size.width/2, 0,0); 设置tableView背景view视图 @property(nonatomic, readwrite, retain) UIView *backgroundView; 三、常用方法详解重载tableView - (void)reloadData; 重载索引栏 - (void)reloadSectionIndexTitles; 这个方法常用语新加或者删除了索引类别而无需刷新整个表视图的情况下。 获取分区数 - (NSInteger)numberOfSections; 根据分区获取行数 - (NSInteger)numberOfRowsInSection:(NSInteger)section; 获取分区的大小(包括头视图，所有行和尾视图) - (CGRect)rectForSection:(NSInteger)section; 根据分区分别获取头视图，尾视图和行的高度 - (CGRect)rectForHeaderInSection:(NSInteger)section; - (CGRect)rectForFooterInSection:(NSInteger)section; - (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath; 获取某个点在tableView中的位置信息 - (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point; 获取某个cell在tableView中的位置信息 - (NSIndexPath )indexPathForCell:(UITableViewCell )cell; 根据一个矩形范围返回一个信息数组，数组中是每一行row的位置信息 - (NSArray *)indexPathsForRowsInRect:(CGRect)rect; 通过位置路径获取cell - (UITableViewCell )cellForRowAtIndexPath:(NSIndexPath )indexPath; 获取所有可见的cell - (NSArray *)visibleCells; 获取所有可见行的位置信息 - (NSArray *)indexPathsForVisibleRows; 根据分区获取头视图 - (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section; 根据分区获取尾视图 - (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section; 使表示图定位到某一位置(行) - (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated; 注意：indexPah参数是定位的位置，决定于分区和行号。animated参数决定是否有动画。scrollPosition参数决定定位的相对位置，它使一个枚举，如下： 123456typedef NS_ENUM(NSInteger, UITableViewScrollPosition) &#123; UITableViewScrollPositionNone,//同UITableViewScrollPositionTop UITableViewScrollPositionTop,//定位完成后，将定位的行显示在tableView的顶部 UITableViewScrollPositionMiddle,//定位完成后，将定位的行显示在tableView的中间 UITableViewScrollPositionBottom//定位完成后，将定位的行显示在tableView最下面&#125;; 使表示图定位到选中行 - (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated; 这个函数与上面的非常相似，只是它是将表示图定位到选中的行。 四、tableView操作刷新块的应用在介绍动画块之前，我们先看几个函数： 插入分区 - (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; animation参数是一个枚举，枚举的动画类型如下 12345678910typedef NS_ENUM(NSInteger, UITableViewRowAnimation) &#123; UITableViewRowAnimationFade,//淡入淡出 UITableViewRowAnimationRight,//从右滑入 UITableViewRowAnimationLeft,//从左滑入 UITableViewRowAnimationTop,//从上滑入 UITableViewRowAnimationBottom,//从下滑入 UITableViewRowAnimationNone, //没有动画 UITableViewRowAnimationMiddle, UITableViewRowAnimationAutomatic = 100 // 自动选择合适的动画&#125;; 删除分区 - (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; 重载一个分区 - (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation ; 移动一个分区 - (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection; 插入一些行 - (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 删除一些行 - (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 重载一些行 - (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 移动某行 - (void)moveRowAtIndexPath:(NSIndexPath )indexPath toIndexPath:(NSIndexPath )newIndexPath; 了解了上面几个函数，我们来看什么是操作刷新块： 当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，而然数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。 IOS为我们提供了下面两个函数解决这个问题： 开始块标志 - (void)beginUpdates; 结束快标志 - (void)endUpdates; 我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下： 1234[tab beginUpdates]; [tab deleteRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:1 inSection:0]] withRowAnimation:UITableViewRowAnimationLeft]; [dataArray removeObjectAtIndex:1]; [tab endUpdates]; 注意：不要在这个块中调用reloadData这个方法，它会使动画失效。 五、tableView的编辑操作设置是否是编辑状态(编辑状态下的cell左边会出现一个减号，点击右边会划出删除按钮) @property (nonatomic, getter=isEditing) BOOL editing; - (void)setEditing:(BOOL)editing animated:(BOOL)animated; 设置cell是否可以被选中(默认为YES) @property (nonatomic) BOOL allowsSelection; 设置cell编辑模式下是否可以被选中 @property (nonatomic) BOOL allowsSelectionDuringEditing; 设置是否支持多选 @property (nonatomic) BOOL allowsMultipleSelection; 设置编辑模式下是否支持多选 @property (nonatomic) BOOL allowsMultipleSelectionDuringEditing; 六、选中cell的相关操作获取选中cell的位置信息 - (NSIndexPath *)indexPathForSelectedRow; 获取多选cell的位置信息 - (NSArray *)indexPathsForSelectedRows; 代码手动选中与取消选中某行 - (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition; - (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated; 注意：这两个方法将不会回调代理中的方法。 七、tableView附件的相关方法设置索引栏最小显示行数 @property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount; 设置索引栏字体颜色 @property (nonatomic, retain) UIColor *sectionIndexColor; 设置索引栏背景颜色 @property (nonatomic, retain) UIColor *sectionIndexBackgroundColor; 设置索引栏被选中时的颜色 @property (nonatomic, retain) UIColor *sectionIndexTrackingBackgroundColor; 设置分割线的风格 @property (nonatomic) UITableViewCellSeparatorStyle separatorStyle; 这个风格是一个枚举，如下： 12345typedef NS_ENUM(NSInteger, UITableViewCellSeparatorStyle) &#123; UITableViewCellSeparatorStyleNone,//无线 UITableViewCellSeparatorStyleSingleLine,//有线 UITableViewCellSeparatorStyleSingleLineEtched &#125;; 设置分割线颜色 @property (nonatomic, retain) UIColor *separatorColor; 设置分割线毛玻璃效果(IOS8之后可用) @property (nonatomic, copy) UIVisualEffect *separatorEffect; 注意：这个属性是IOS8之后新的。 设置tableView头视图 @property (nonatomic, retain) UIView *tableHeaderView; 设置tableView尾视图 @property (nonatomic, retain) UIView *tableFooterView; 从复用池中取cell - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier; 获取一个已注册的cell - (id)dequeueReusableCellWithIdentifier:(NSString )identifier forIndexPath:(NSIndexPath )indexPath 从复用池获取头视图或尾视图 - (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier; 通过xib文件注册cell - (void)registerNib:(UINib )nib forCellReuseIdentifier:(NSString )identifier; 通过OC类注册cell - (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier 上面两个方法是IOS6之后的方法。 通过xib文件和OC类获取注册头视图和尾视图 - (void)registerNib:(UINib )nib forHeaderFooterViewReuseIdentifier:(NSString )identifier; - (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *) 关于tableView的代理方法，因为篇幅原因，总结在下一篇博客中。 错误之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS使用Xcode可视化图像编辑功能进行图片拉伸","slug":"27iOS使用xcode可视化图像编辑功能进行图片拉伸","date":"2015-04-20T16:00:00.000Z","updated":"2021-06-10T08:59:39.270Z","comments":true,"path":"2015/04/21/27iOS使用xcode可视化图像编辑功能进行图片拉伸/","link":"","permalink":"http://huishao.cc/2015/04/21/27iOS使用xcode可视化图像编辑功能进行图片拉伸/","excerpt":"","text":"iOS中可视化拉伸图片技巧一、补充在我的另一篇博客http://my.oschina.net/u/2340880/blog/403996中探讨了IOS拉伸图像(UIImage)的几种方法和一些小经验，这篇是一个补充，再将xcode中的另一种可视化拉伸图像的方法的使用介绍给大家。 二、如何使用IOS开发文档中的描述：https://developer.apple.com/library/ios/recipes/xcode_help-image_catalog-1.0/chapters/SlicinganImage.html 1、xcode5的新特性xcode5之后，IOS为我们提供了一个管理图片的新方法Asset Catalogs，简单说来，它相当于一个目录，专门用来管理我们项目中的图片素材，包括Icon和启动页，这样使项目管理更加方便也更加简洁。 创建一个AssetCatalogs：在xcode中新建一个文件，选择AssetCatalogs，如下： 然后我们点开这个包，将图片直接拖入工具区即可： 2、使用AssetCatalogs中的可视化工具进行图片拉伸完成了上面的步骤之后，我们可以对管理的图片进行处理，点击右下角的show Slicing按钮，我们就会进入可视化编辑区，如下： 如上图，有三条竖直线，其中边界的两条分别约束了图片两侧不被拉伸的区域范围，中间虚线和左侧虚线围成的部分，将是被复制拉伸的区域。水平方向的线同理。 很重要的一点：官方文档告诉我们，这个方法只能在iOS 7 或者 OS X v10.10之后使用。效果如下： 3、在xib文件中UIImage的拉伸在xib文件中的UIImageView，在上面加上图片后，可以设置stretching这个属性： 这个属性的四个值：X,Y,Width,Height的取值范围是0-1；X，Y，用来确定一个点，比如我们设置为X=0.1，Y=0.1，则这个点就是图片的左上角开始，水平1/10处和竖直1/10处，设置图片的拉伸点为从这个点开始。后两个参数分别设置图片拉伸区域的宽度和高度，比如我们这样设置：Width=0.8，Height=0.8，则图片拉伸时上下左右各1/10的宽度不会被拉伸，中间部分被拉伸，还是刚才的图片，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中图片(UIImage)拉伸技巧","slug":"26iOS中图片(UIImage)拉伸技巧","date":"2015-04-19T16:00:00.000Z","updated":"2021-06-10T08:58:17.409Z","comments":true,"path":"2015/04/20/26iOS中图片(UIImage)拉伸技巧/","link":"","permalink":"http://huishao.cc/2015/04/20/26iOS中图片(UIImage)拉伸技巧/","excerpt":"","text":"iOS中图片拉伸技巧与方法总结一、了解几个图像拉伸的函数和方法1、直接拉伸法简单暴力，却是最最常用的方法，直接将图片设置为ImageView的image属性，图片便会随UIImageView对象的大小做自动拉伸。这种拉伸的方法有一个致命的缺陷，它会使图像发生失真与形变。 2、像素点的拉伸- (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight; 这个函数我们可以用来拉伸类似QQ，微信的聊天气泡背景图，它的两个参数分别leftCapWidth和topCapHeight，这两个参数给定一个坐标，比如： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img stretchableImageWithLeftCapWidth:1 topCapHeight:1]; 这段代码的意思是将图片从左起第2列，上起第2行，坐标为(2,2)的像素点进行复制。将图片进行拉伸。这个方法和上面的方法比起来似乎灵活性更多了，但其也有它的一些局限，如果被拉伸的图片中间也有需要拉伸的像素，这个方法就无能为力了，例如，如下的一张图片，我们需要将其拉伸放大： 便会出现这样的效果： 这明显和我们的意图是不符的，那么，我们可以使用下面的方法。 3、区域的拉伸- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; 这个函数需要设置一个UIEdgeInsets参数，UIEdgeInsets结构体如下： 123typedef struct UIEdgeInsets &#123; CGFloat top, left, bottom, right; &#125; UIEdgeInsets; 它分别对用了图片进行拉伸的区域距离顶部、左部、下部、右部的像素。比如，一个10*10像素的图片，将UIEdgeInsets参数全部设置为1，则实际拉伸的部分就是中间的8*8的区域的像素。有一点需要注意，这个方法默认使用的拉伸模式是区域复制，比如还是上面的图案，如下代码拉伸： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(1, 1, 1, 1)]; 结果如下： 可以明显的看到中间的虚线，这便是区域复制的杰作。 那么问题又来了，如果某些图片中间有渐变，我们该怎么处理了，来看下一个函数。 4、拉伸模式的设置- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode; 这个函数和上一个函数相比，唯一的差别是多了一个参数。这个参数是个枚举，如下： 1234typedef NS_ENUM(NSInteger, UIImageResizingMode) &#123; UIImageResizingModeTile,//进行区域复制模式拉伸 UIImageResizingModeStretch,//进行渐变复制模式拉伸&#125;; 现在就明了了，我们只需要设置一下模式，就可以实现渐变拉伸了： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(1, 1, 1, 1) resizingMode:UIImageResizingModeStretch]; 来看一下效果： 二、拉伸的用武之地圆角按钮，空心按钮，渐变的背景，内容可变的标签，聊天气泡等等这样的素材在APP中很可能会多次出现，并且每次出现的尺寸可能还会略微有些差异，如果仅仅依靠美工的素材，恐怕不仅很难达到要求，也会额外增加软件的内存开销，这时，我们使用恰当的拉伸技巧，能使我们的代码更加健壮，APP更加高效。 三、一点小经验你是否注意观察过最细的线？ 看到上面的问句，你可能有些差异。最细的线不就是一像素么？确实，能绘图画出来的最细的实心线确实是一像素，但在一个项目中，我们优秀的美工察觉到无论她把线做的多么细，无论我怎样控制拉伸方法，绘制出的登录框总是没有QQ的细，QQ的框线看起来更加干脆利索。后来索性用绘图画出登录框，结果很不幸，我依然无法将线做到像QQ登录框那样细致。后来偶然试了一种方法，不知原理是否正确，效果总算达到了，当然这也要归功于我们的美工，她将一个图片做的很大，适配最大的分辨率，然后让我手动缩，如此一来，那线就变得非常细。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIImage","slug":"UIImage","permalink":"http://huishao.cc/tags/UIImage/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中正则表达式的使用","slug":"25iOS中正则表达式的使用","date":"2015-04-18T16:00:00.000Z","updated":"2021-06-10T08:54:22.001Z","comments":true,"path":"2015/04/19/25iOS中正则表达式的使用/","link":"","permalink":"http://huishao.cc/2015/04/19/25iOS中正则表达式的使用/","excerpt":"","text":"正则表达式在iOS开发中的应用正则表达式在字符串查找，替换，检测中的应用非常广泛，正则表达式是什么，有怎样的语法，我的另一篇博客中有详细的介绍：http://my.oschina.net/u/2340880/blog/403508。这里只简单说一下其概念 ，正则表达式是一种语法小巧简单的语言，用来约束一些过滤字符串条的条件。很多开发工具都有支持正则表达式的内容，IOS也不例外，在IOS中NSRegularExpression类就是一个专门来处理正则表达式的类。 一、初始化方法初始化NSRegularExpression的方法有两种，一个init方法和一个类方法。其作用基本是一样的 + (NSRegularExpression )regularExpressionWithPattern:(NSString )pattern options:(NSRegularExpressionOptions)options error:(NSError **)error; - (instancetype)initWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error 其中，pattern是正则表达式，options是参数。对于option参数，它是一个枚举，表示正则模式的设置，如下： 123456789typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) &#123; NSRegularExpressionCaseInsensitive = 1 &lt;&lt; 0, //不区分字母大小写的模式 NSRegularExpressionAllowCommentsAndWhitespace = 1 &lt;&lt; 1, //忽略掉正则表达式中的空格和#号之后的字符 NSRegularExpressionIgnoreMetacharacters = 1 &lt;&lt; 2, //将正则表达式整体作为字符串处理 NSRegularExpressionDotMatchesLineSeparators = 1 &lt;&lt; 3, //允许.匹配任何字符，包括换行符 NSRegularExpressionAnchorsMatchLines = 1 &lt;&lt; 4, //允许^和$符号匹配行的开头和结尾 NSRegularExpressionUseUnixLineSeparators = 1 &lt;&lt; 5, //设置\\n为唯一的行分隔符，否则所有的都有效。 NSRegularExpressionUseUnicodeWordBoundaries = 1 &lt;&lt; 6 //使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效&#125;; 注意：1、NSRegularExpressionCaseInsensitive模式下正则表达式 aBc 会匹配到abc. 2、NSRegularExpressionIgnoreMetacharacters模式下正则表达式a b c 会匹配到abc，正则表达式ab#c会匹配到ab。 3、NSRegularExpressionAllowCommentsAndWhitespace模式下正则表达式\\[a-z\\]，会匹配到\\[a-z\\]。 二、获取查询结果初始化完毕正则表达式的处理类后，我们需要进行正则表达式的查询，IOS官方提供了两种模式： 1、带block模式的方法：- (void)enumerateMatchesInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range usingBlock:(void (^)(NSTextCheckingResult \\result, NSMatchingFlags flags, BOOL *stop))block; 使用举例： 1234NSRegularExpression * regex = [[NSRegularExpression alloc]initWithPattern:@&quot;[a-z]&quot; options:NSRegularExpressionCaseInsensitive error:nil]; [regex enumerateMatchesInString:@&quot;124a&quot; options:NSMatchingReportProgress range:NSMakeRange(0, 4) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) &#123; NSLog(@&quot;%@&quot;,result); &#125; ]; 注意：1、这个函数的一个参数options是一个枚举，设置回调的方式，如下： 1234567typedef NS_OPTIONS(NSUInteger, NSMatchingOptions) &#123; NSMatchingReportProgress = 1 &lt;&lt; 0, //找到最长的匹配字符串后调用block回调 NSMatchingReportCompletion = 1 &lt;&lt; 1, //找到任何一个匹配串后都回调一次block NSMatchingAnchored = 1 &lt;&lt; 2, //从匹配范围的开始出进行极限匹配 NSMatchingWithTransparentBounds = 1 &lt;&lt; 3, //允许匹配的范围超出设置的范围 NSMatchingWithoutAnchoringBounds = 1 &lt;&lt; 4 //禁止^和$自动匹配行还是和结束&#125;; 2、block回调中的flags枚举对应如下： 1234567typedef NS_OPTIONS(NSUInteger, NSMatchingFlags) &#123; NSMatchingProgress = 1 &lt;&lt; 0, //匹配到最长串是被设置 NSMatchingCompleted = 1 &lt;&lt; 1, //全部分配完成后被设置 NSMatchingHitEnd = 1 &lt;&lt; 2, //匹配到设置范围的末尾时被设置 NSMatchingRequiredEnd = 1 &lt;&lt; 3, //当前匹配到的字符串在匹配范围的末尾时被设置 NSMatchingInternalError = 1 &lt;&lt; 4 //由于错误导致的匹配失败时被设置 &#125;; 3、还有一点需要注意，就是那个bool值stop，我们可以在block块中设置它为YES，之后便会停止查找。 2、非block的方法这个方法会返回一个结果数组，将所有匹配的结果返回 - (NSArray )matchesInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法会返回匹配到得字符串的个数 - (NSUInteger)numberOfMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法会返回第一个查询到得结果，这个NSTextCheckingResult对象中有一个range属性，可以得到匹配到的字符串的范围。 - (NSTextCheckingResult )firstMatchInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法直接返回匹配到得范围，NSRange。 - (NSRange)rangeOfFirstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range; 三、一个辅助方法在NSRegularExpression类中还提供了一个辅助方法： + (NSString )escapedPatternForString:(NSString )string; 它可以帮助我们将正则表达式加上”\\“进行保护，将元字符转化成字面值。 到此，在IOS中正则表达式的基本用法就介绍完了，希望正则表达式的应用，能为你的项目节省更多时间。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"分分钟使用正则表达式","slug":"24分分钟使用正则表达式","date":"2015-04-18T16:00:00.000Z","updated":"2021-06-10T08:53:07.481Z","comments":true,"path":"2015/04/19/24分分钟使用正则表达式/","link":"","permalink":"http://huishao.cc/2015/04/19/24分分钟使用正则表达式/","excerpt":"","text":"正则表达式简单语法总结一、什么是正则表达式从概念上来说，正则表达式也是一门小巧而精炼的语言，它可以用来简化检索特定的字符串，替换特定字符等功能，有许多开发语言工具，都内嵌支持正则表达式。那么一个正则表达式，究竟是什么？其实它就是一个字符串，但这个字符串具有特定含义。 二、正则表达式的基础语法1、字面值所谓字面值，就是没有任何转义，查找的对象就是其本身，比如正则表达式 abc ，查找的结果就是返回要查找字符串中 a，b，c三个字母连在一起的字符串。又如，123 就是查找到123这个子串。 2、特殊字符（元字符）（1）句号“.”在正则表达式中表示匹配任意字符，很相似于通配符*。如果我们查找a.b这个正则表达式，我们可以找到所有开头和结尾为a，b，中间是任意字符的字符串，比如abc，adc，a2c等。 （2）字符类（[]）如果你在一个正则表达式中看到有一些字符被[]括号括起来，那么他们的含义将不再是简单的字面值，他们表示某一个被括号中属性约束的字符。比如[123456]，这个正则表达式表示找到1-6中的任意一个字符，又比如a[bd]c，这表示查找abc或者adc。 注意： 1.在字符类中字符的顺序和重复性都不是我们关心的。\\[123\\]和\\[2233111\\]，含义是一模一样的。 2.句号在字符类中表示的就是其本身，\\[.\\]就是查找一个句号。 （3）区间符号（-）如果我们需要查找一个数字，[0123456789]，这样做是可以达到目的的，但这写起非常麻烦，并不符合正则表达式小巧的特性，这时我们可以使用区间符号来简化，[0-9]和上面的式子意义完全一样。同样，我们可以[a-zA-Z]，表示任意一个字母。 注意： 1.区间的范围应该有意义，\\[a-1\\]这样的区间并无任何意义，尽管它在语法上可能没有错误。 2.区间左右两端对应的是字符，并不是数字，比如\\[2-41\\]，这个式子的含义是找到2-4的一个数字或者1，和\\[1-4\\]是一样的。 （4）取反符号（^）“^”在正则表达式中表示取反，这个很好理解，[^a]，表示找到除了a之外的任意字符。[^0-9]，表示找到一个非数字的字符。 注意： 1.^必须在中括号内，及字符类属性中使用。 2.^是将后面的整体作为取反条件的。 （5）简化的字符类某些符号具有和字符类相同的含义： \\d和[0-9]相同 \\w和[0-9A-Za-z_]相同 表示数字，字母或者下划线 \\s表示匹配空格，tab和换行等不可见符。 与此相对的\\D,\\W,\\S，则表示上述条件的取反情况。 （6）乘法集（{}）乘法集的最大用处也是简化正则表达式，用大括号表示。比如，a{2}，表示找到aa这个字符串。 注意： 乘法集是已前面整体为乘法条件的，比如\\[ab\\]{2}，不是简单的比配aa，bb，而是和\\[ab\\]\\[ab\\]含义是相同的，会匹配ab，ba，aa，bb。 （7）乘法集中的区间（,）乘法集和字符类相同，也可以用区间进行简化，但是符号不相同。a{1,3}，表示找到a，aa，aaa这三个字符串。a{0,1}是合法的，表示找到空字符，或者a。 注意： 1.乘法集的&quot;越长越好&quot;属性：乘法集具有这样的特点，比如a{2,4}，如果我搜索myaaaa，它不会找到aa后就停止，而是会找到aaaa。 2.乘法集的&quot;全部获取&quot;属性：比如a{2.4}，如果搜索myaayouaaaa，它会找到aa和aaaa。 3.乘法集支持开区间，a{1,}是合法的，表示找到任何a相连的字符串。 （8）判断符号（？）这个符号的含义和{0,1}完全相同，123?4，表示匹配1234或者124； （9）统配符号（*）这个符号的含义和{0,}相同，比如.* 表示通配一切字符串。 （10）+符号这个符号和{1,}相同。 （11）或符号（|）“|”符号表示或的关系，比如abc|edf，表示找到abc或者def （12）组合（()）小括号在正则表达式中表示组合，比如(a|b|c)d，表示找到ad，bd，cd，可以将小括号的作用理解为优先级。 （13）单词边界（\\b）\\b表示单词的边界，比如\\b[a-z]{3}\\b，表示匹配一个三个字母的小写单词。 （14）行边界（^ $）单单的一个^符号表示的是行的开头，$表示行的结束。 注意： \\[^\\]是非法的，\\[$\\]表示匹配一个$符号。 三、做些小总结上面说了这么多正则表达式的语法规则，我们现在来做下总结： 1、几个概念：1、字面值:直接查找的字符，比如123，avb。 2、字符类：描述字符的一些属性，比如[123],[a-z],\\d,\\w,\\s,.。 3、乘法集：简化表达式，比如{0,3},?,+,*。 4、或和组合：比如(a|b|v)。 5、单词，行的边界\\b ^ $ 2、元字符列表. \\ [ ] { } ? * + | ( ) ^ $ 3、字符类中元字符列表[ ] \\ - ^ 四、一个特别重要的字符最后，还有一个特别特别重要的字符我们没考虑到，如果我们要查找元字符怎么办，在正则表达式中还有一个转义字符”\\“，如果我们要查找. 只要查找\\. 同理\\[\\]是查找”[]“这个字符串。如果要查找”\\“，再加一个转义字符就好:\\\\。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://huishao.cc/categories/正则表达式/"}],"tags":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/tags/编程珠玑/"}],"keywords":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://huishao.cc/categories/正则表达式/"}]},{"title":"iOS 单例设计模式解读","slug":"22iOS 单例设计模式解读","date":"2015-04-16T16:00:00.000Z","updated":"2021-06-10T08:49:14.271Z","comments":true,"path":"2015/04/17/22iOS 单例设计模式解读/","link":"","permalink":"http://huishao.cc/2015/04/17/22iOS 单例设计模式解读/","excerpt":"","text":"iOS 中单例设计模式的解读与用法一、单例的作用顾名思义，单例，即是在整个项目中，这个类的对象只能被初始化一次。它的这种特性，可以广泛应用于某些需要全局共享的资源中，比如管理类，引擎类，也可以通过单例来实现传值。UIApplication、NSUserDefaults等都是IOS中的系统单例。 二、单例的写法单例的写法常用的有两种方式： 方式1、不考虑线程12345678static SingleCase *manager = nil; + (SingleCase *)defaultManager &#123; if (!manager)&#123; SingleCase = [[self alloc] init]; return manager; &#125;&#125; 方式2、考虑线程安全123456789+ (SingleCase *)sharedManager &#123; static SingleCase *ManagerInstance = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; ManagerInstance = [[self alloc] init]; &#125;); return ManagerInstance; &#125; 三、代码的优化通过上面的方法，我们已经可以使用类方法来得到这个单例，但很多时候，项目的工程量很大，还有可能会很多开发者同时参与一个项目的开发，为了安全与管理代码的方便，也为了给不是这个单例的创作者但会用到这个单例的开发人员一些提示，我们通常会重写一些方法： 首先我们自己实现一个alloc方法： 123+(instancetype)myAlloc&#123; return [super allocWithZone:nil];&#125; 将我们的单例实现方法略作修改： 1234567+(ZYHPayManager *)sharedMamager&#123; static ZYHPayManager * manager; if (manager==nil) &#123; manager=[[ZYHPayManager myAlloc]init]; &#125; return manager;&#125; 将一些视图实例化对象的方法重写： 1234567891011121314+(instancetype)alloc&#123; NSAssert(0, @&quot;这是一个单例对象，请使用+(ZYHPayManager *)sharedMamager方法&quot;); return nil;&#125;+(instancetype)allocWithZone:(struct _NSZone *)zone&#123; return [self alloc];&#125;-(id)copy&#123; NSLog(@&quot;这是一个单例对象，copy将不起任何作用&quot;); return self;&#125;+(instancetype)new&#123; return [self alloc];&#125; 注意：这里的alloc使用了断言，让任何视图通过alloc创建对象的程序段断在此处，给程序员提示。copy方法这里只是简单的返回了原对象，并未做任何处理，打印信息给程序员提示。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://huishao.cc/categories/设计模式/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://huishao.cc/categories/设计模式/"}]},{"title":"iOS description与debugDescription在调试程序中的应用","slug":"23iOS description与debugDescription在调试程序中的应用","date":"2015-04-16T16:00:00.000Z","updated":"2021-06-10T08:51:30.216Z","comments":true,"path":"2015/04/17/23iOS description与debugDescription在调试程序中的应用/","link":"","permalink":"http://huishao.cc/2015/04/17/23iOS description与debugDescription在调试程序中的应用/","excerpt":"","text":"iOS 中打印函数description与debugDescription的应用一、description和debugDescription是什么description和debugDescription是NSObject协议中的声明的两个方法，同时NSObject类也实现了这个方法，如果子类没有重写，则会调用父类的description和debugDescription方法。首先，这两个方法适用于程序代码的调试的，当我们调用打印Log时，会向对象发送一个这样的消息。 我们先来看声明部分的代码： 12+ (NSString *)description;+ (NSString *)debugDescription; 这里返回的字符串就是我们打印在控制台显示的信息。 二、NSObject基类中的description方法是如何实现的我们写如下的测试代码： 12 NSObject * objc = [[NSObject alloc]init]; NSLog(@&quot;objc:%@&quot;,objc); 控制台输出的信息如下： 可以看到，方法的实现大致是这样的： 123-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;&lt;%@:%p&gt;&quot;,[self class],&amp;self];&#125; 三、重写description方法通过上面的介绍，我们大致知道description方法的原理了，在程序调试时，我们可以充分利用这个方法带来的便利，大大缩减我们调试程序所需要的时间。例如：创建一个Test类，给它定义两个属性如下： Text.h 12345#import &lt;Foundation/Foundation.h&gt;@interface TestObject : NSObject@property(nonatomic,strong)NSString * name;@property(nonatomic,strong)NSString * age;@end 我们在.m文件中将description方法重写： 123456#import &quot;TestObject.h&quot;@implementation TestObject-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;%@&quot;,@&#123;@&quot;name&quot;:_name,@&quot;age&quot;:_age&#125;];&#125;@end 重写的方法将Test类对象的属性打印了出来，这时我们在调用NSLog函数时，打印结果如下： 是不是很炫酷，如此一来，我们可以将我们基本不会用到的类名和地址转换成打印数据，极大的方便了我们代码的调试工作。 四、description与debugDescription的区别这两个方法的区别仅仅在于调试的位置不同，调用不同的函数。description是我们在程序中打Log会调用的方法，debugDescription则是我们在断点调试时，在控制台使用po命令打印会调用的方法，比如我们重写Test类的这个方法： 123-(NSString *)debugDescription&#123; return [NSString stringWithFormat:@&quot;&lt;%@:%p&gt;:%@&quot;,[self class],&amp;self,@&#123;@&quot;name&quot;:_name,@&quot;age&quot;:_age&#125;];&#125; 然后我们在程序中加个断点运行，在程序断掉之后，我们在调试区输入：po text，回车之后，会出现如下的信息： 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UIStepper(步进控件)使用总结","slug":"20iOS UIStepper(步进控件)使用总结","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:44:37.596Z","comments":true,"path":"2015/04/16/20iOS UIStepper(步进控件)使用总结/","link":"","permalink":"http://huishao.cc/2015/04/16/20iOS UIStepper(步进控件)使用总结/","excerpt":"","text":"iOS中步进控件的简单使用 初始化控件 1UIStepper * step = [[UIStepper alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器值是否连续触发变化 @property(nonatomic,getter=isContinuous) BOOL continuous; 若设置为YES，则长按会连续触发变化，若设置为NO，只有在按击结束后，才会触发。 设置长按是否一直触发变化 @property(nonatomic) BOOL autorepeat; 若设置为YES，则长按值会一直改变，若设置为NO，则一次点击只会改变一次值 设置控制器的值是否循环(到达边界后，重头开始，默认为NO) @property(nonatomic) BOOL wraps; 设置控制器的值 @property(nonatomic) double value; 设置控制器的最大值和最小值 @property(nonatomic) double minimumValue;//默认为0 @property(nonatomic) double maximumValue; //默认为100 设置控制器的步长 @property(nonatomic) double stepValue; 设置控制器风格颜色 @property(nonatomic,retain) UIColor *tintColor; 设置控制器背景图片 - (void)setBackgroundImage:(UIImage*)image forState:(UIControlState)state; 获取背景图片 - (UIImage*)backgroundImageForState:(UIControlState)state; 通过左右按钮的状态设置分割线的图片 - (void)setDividerImage:(UIImage*)image forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; 获取分割线图片 - (UIImage*)dividerImageForLeftSegmentState:(UIControlState)state rightSegmentState:(UIControlState)state; 设置和获取加号按钮的图片 - (void)setIncrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)incrementImageForState:(UIControlState)state; 设置和获取减号按钮的图片 - (void)setDecrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)decrementImageForState:(UIControlState)state; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIStepper","slug":"UIStepper","permalink":"http://huishao.cc/tags/UIStepper/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIProgressView控件用法","slug":"18iOS UIProgressView控件用法","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:42:13.167Z","comments":true,"path":"2015/04/16/18iOS UIProgressView控件用法/","link":"","permalink":"http://huishao.cc/2015/04/16/18iOS UIProgressView控件用法/","excerpt":"","text":"进度条控件是IOS开发中一个简单的系统控件，使用总结如下： 初始化一个进度条： (instancetype)initWithProgressViewStyle:(UIProgressViewStyle)style; 注意：1.用这个方式初始化的进度条系统会默认给一个长度。 2.进度条的长度可以通过frame来设置，但是只有前三个参数有效。 3.风格枚举如下： typedef NS_ENUM(NSInteger, UIProgressViewStyle) { UIProgressViewStyleDefault, // 普通样式 UIProgressViewStyleBar, // 用于工具条的样式}; 设置进度条风格样式 @property(nonatomic) UIProgressViewStyle progressViewStyle; 设置进度条进度(0.0-1.0之间，默认为0.0) @property(nonatomic) float progress; 设置已走过进度的进度条颜色 @property(nonatomic, retain) UIColor* progressTintColor; 设置未走过进度的进度条颜色 @property(nonatomic, retain) UIColor* trackTintColor; 设置进度条已走过进度的背景图案和为走过进度的背景图案(IOS7后好像没有效果了) @property(nonatomic, retain) UIImage* progressImage; @property(nonatomic, retain) UIImage* trackImage; 设置进度条进度和是否动画显示(动画显示会平滑过渡) (void)setProgress:(float)progress animated:(BOOL)animated; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIProgressView","slug":"UIProgressView","permalink":"http://huishao.cc/tags/UIProgressView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIPageControl(分页控制器) 用法总结","slug":"19iOS UIPageControl(分页控制器) 用法总结","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:43:35.178Z","comments":true,"path":"2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","excerpt":"","text":"UIPageControll 是继承于UIControl的一个IOS系统UI控件，可以提供给开发者设计分页效果的功能。 初始化方法 UIPageControl * page = [[UIPageControl alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器页数（默认为0） @property(nonatomic) NSInteger numberOfPages; 设置当前所在页码 @property(nonatomic) NSInteger currentPage; 设置当总页数为1时，是否自动隐藏控制器 @property(nonatomic) BOOL hidesForSinglePage; 设置是否延迟自动更新控制器的当前页码（默认为NO） @property(nonatomic) BOOL defersCurrentPageDisplay; 注意：这个属性如果设置为YES，点击时并不会改变控制器显示的当前页码点，必须手动调用 (void)updateCurrentPageDisplay; 这个方法，才会更新。 更新控制器当前页码 (void)updateCurrentPageDisplay; 通过页数得到控制器大小 (CGSize)sizeForNumberOfPages:(NSInteger)pageCount; 这个属性用于页数会变化的情况下进行大小动态处理 设置控制器页码点得颜色 @property(nonatomic,retain) UIColor *pageIndicatorTintColor; 设置控制器当前所在页码点的颜色 @property(nonatomic,retain) UIColor *currentPageIndicatorTintColor; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIPageControl","slug":"UIPageControl","permalink":"http://huishao.cc/tags/UIPageControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C 中变量的作用域","slug":"21Objective-C 中变量的作用域","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-10T08:47:29.313Z","comments":true,"path":"2015/04/16/21Objective-C 中变量的作用域/","link":"","permalink":"http://huishao.cc/2015/04/16/21Objective-C 中变量的作用域/","excerpt":"","text":"iOS中，修饰变量的关键字有四个，分别是： 1 @public 被这个关键字修饰的变量是完全开放的，只要有这类的对象存在，就可以访问到这个变量。 2 @protected 被这个关键字修饰的变量是受保护的，只有在声明变量的这个类中和它的子类中，可以访问。 3 @private 被这个关键字修饰的变量是私有的，只能在声明这个变量的类中使用，子类也不能使用。 4 @package 这个关键字比较难理解，大致意思是被修饰的变量是封装的，在本框架内可以自由使用，效果和@public 相同，而在框架外不能使用，其子类也不能使用，效果又相当于@private。 因为@package的这种特点，它非常适用于franework框架。 一点扩展： 访问类中的变量，我们可以用-&gt;符号，它和点语法的区别在于，点语法实际上是调用的set与get方法，而-&gt;符号是直接访问变量。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://huishao.cc/tags/Objective-C/"}],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS UISlider用法总结","slug":"15iOS UISlider用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:38:39.900Z","comments":true,"path":"2015/04/15/15iOS UISlider用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/15iOS UISlider用法总结/","excerpt":"","text":"UIslider滑块控件在IOS开发中会常用到，可用于调节音量，字体大小等UI方面的交互，用法总结如下： 初始化一个滑块： 1 UISlider * slider = [[UISlider alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; 设置滑块位置 @property(nonatomic) float value;这个值是介于滑块的最大值和最小值之间的，如果没有设置边界值，默认为0-1； 设置滑块最小边界值（默认为0） @property(nonatomic) float minimumValue; 设置滑块最大边界值（默认为1） @property(nonatomic) float maximumValue; 设置滑块最左端显示的图片： @property(nonatomic,retain) UIImage *minimumValueImage； 设置滑块最右端显示的图片： @property(nonatomic,retain) UIImage *maximumValueImage; 设置滑块值是否连续变化(默认为YES) @property(nonatomic,getter=isContinuous) BOOL continuous; 这个属性设置为YES则在滑动时，其value就会随时变化，设置为NO，则当滑动结束时，value才会改变。 设置滑块左边（小于部分）线条的颜色 @property(nonatomic,retain) UIColor *minimumTrackTintColor； 设置滑块右边（大于部分）线条的颜色 @property(nonatomic,retain) UIColor *maximumTrackTintColor； 设置滑块颜色（影响已划过一端的颜色） @property(nonatomic,retain) UIColor *thumbTintColor； 注意这个属性：如果你没有设置滑块的图片，那个这个属性将只会改变已划过一段线条的颜色，不会改变滑块的颜色，如果你设置了滑块的图片，又设置了这个属性，那么滑块的图片将不显示，滑块的颜色会改变（IOS7） 手动设置滑块的值： - (void)setValue:(float)value animated:(BOOL)animated; 设置滑块的图片： - (void)setThumbImage:(UIImage *)image forState:(UIControlState)state; 设置滑块划过部分的线条图案 - (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state; 设置滑块未划过部分的线条图案 - (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state; 对应的几个get方法 - (UIImage )thumbImageForState:(UIControlState)state;- (UIImage )minimumTrackImageForState:(UIControlState)state;- (UIImage *)maximumTrackImageForState:(UIControlState)state; 对应的设置当前状态的响应属性的方法 @property(nonatomic,readonly) UIImage currentThumbImage;@property(nonatomic,readonly) UIImage currentMinimumTrackImage;@property(nonatomic,readonly) UIImage* currentMaximumTrackImage; 添加触发事件 1[slider addTarget:self action:@selector(log:) forControlEvents:UIControlEventValueChanged]; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISlider","slug":"UISlider","permalink":"http://huishao.cc/tags/UISlider/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISwitch 用法总结","slug":"16iOS UISwitch 用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:39:45.598Z","comments":true,"path":"2015/04/15/16iOS UISwitch 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/16iOS UISwitch 用法总结/","excerpt":"","text":"iOS 系统开关控件简单使用总结： 初始化： (instancetype)initWithFrame:(CGRect)frame; 这个frame是没有意义的，系统的开关控件大小是确定的。 设置开关开启状态时的颜色 @property(nonatomic, retain) UIColor *onTintColor; 设置开关风格颜色 @property(nonatomic, retain) UIColor *tintColor; 设置开关按钮颜色 @property(nonatomic, retain) UIColor *thumbTintColor; 设置开关开启状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *onImage; 设置开关关闭状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *offImage; 开关的状态 @property(nonatomic,getter=isOn) BOOL on; 手动设置开关状态 (void)setOn:(BOOL)on animated:(BOOL)animated; 一点感想：iOS的系统的UISwitch控件虽然定制性很差，配合IOS7之后的扁平化和俭约的风格，在美观上确实不逊色于任何私人定制的开关控件，在没有特殊需求的情况下，对于开关逻辑，这是一个非常不错的UI交互选择。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISwitch","slug":"UISwitch","permalink":"http://huishao.cc/tags/UISwitch/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIActivityIndicatorView(指示控制器)用法总结","slug":"17iOS UIActivityIndicatorView(指示控制器)用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:40:42.975Z","comments":true,"path":"2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","excerpt":"","text":"对于UIActivityIndicatorView的使用，我们一般会创建一个背景View,设置一定的透明度，然后将UIActivityIndicatorView贴在背景View上，在我们需要的时候将这个view呼出。 初始化UIActivityIndicatorView (instancetype)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style; 这个风格是一个枚举，如下 typedef NS_ENUM(NSInteger, UIActivityIndicatorViewStyle) { //大号白色 UIActivityIndicatorViewStyleWhiteLarge, //白色 UIActivityIndicatorViewStyleWhite, //灰色 UIActivityIndicatorViewStyleGray,}; 初始化之后，还需要给它一个Frame，但是只有前两个位置参数有效，大小参数将没有任何影响。 设置指示器风格： @property(nonatomic) UIActivityIndicatorViewStyle activityIndicatorViewStyle; 设置指示器是否停止动画时隐藏 @property(nonatomic) BOOL hidesWhenStopped; 设置指示器颜色 @property (readwrite, nonatomic, retain) UIColor *color； 让指示器开始动画 (void)startAnimating; 让指示器停止动画 (void)stopAnimating; 获取指示器动画状态 (BOOL)isAnimating; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIActivityIndicatorView","slug":"UIActivityIndicatorView","permalink":"http://huishao.cc/tags/UIActivityIndicatorView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UITextField 使用与方法解读","slug":"14iOS UITextField 使用与方法解读","date":"2015-04-13T16:00:00.000Z","updated":"2021-06-02T08:38:34.799Z","comments":true,"path":"2015/04/14/14iOS UITextField 使用与方法解读/","link":"","permalink":"http://huishao.cc/2015/04/14/14iOS UITextField 使用与方法解读/","excerpt":"","text":"UITextField是IOS开发中用户交互中重要的一个控件，常被用来做账号密码框，输入信息框等。 初始化一个文字框： UITextField * textField = [[UITextField alloc]initWithFrame:CGRectMake(100, 30, 100, 100)]; 设置和获取文字框文字： @property(nonatomic,copy) NSString *text; 通过AttributedString创建和获取文字： @property(nonatomic,copy) NSAttributedString *attributedText； 设置字体颜色属性： @property(nonatomic,retain) UIColor *textColor; 设置字体属性： @property(nonatomic,retain) UIFont *font; 设置字体对齐格式： @property(nonatomic)NSTextAlignment textAlignment; 设置输入框风格： @property(nonatomic) UITextBorderStyle borderStyle; 这个风格是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextBorderStyle) { //没有任何边框 UITextBorderStyleNone, //线性边框 UITextBorderStyleLine, //阴影效果边框 UITextBorderStyleBezel, //原型效果边框 UITextBorderStyleRoundedRect}; 设置默认字体属性 @property(nonatomic,copy) NSDictionary *defaultTextAttributes； 这个属性的设置会影响到全部字体的属性。 设置缺省时显示的灰度字符串 @property(nonatomic,copy) NSString *placeholder; 通过AttributedString设置缺省字符串 @property(nonatomic,copy) NSAttributedString *attributedPlaceholder； 设置是否在开始编辑时清空输入框内容 @property(nonatomic) BOOL clearsOnBeginEditing; 设置字体大小是否随宽度自适应（默认为NO） @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 设置最小字体大小 @property(nonatomic) CGFloat minimumFontSize; 设置背景图片（会被拉伸） @property(nonatomic,retain) UIImage *background; 设置禁用时的背景图片 @property(nonatomic,retain) UIImage *disabledBackground; 是否正在编辑（只读属性） @property(nonatomic,readonly,getter=isEditing) BOOL editing; 是否允许更改字符属性字典 @property(nonatomic) BOOL allowsEditingTextAttributes； 设置属性字典 @property(nonatomic,copy) NSDictionary *typingAttributes； 设置清除按钮的显示模式 @property(nonatomic) UITextFieldViewMode clearButtonMode; 这是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextFieldViewMode) { //从不显示 UITextFieldViewModeNever, //编辑的时候显示 UITextFieldViewModeWhileEditing, //非编辑的时候显示 UITextFieldViewModeUnlessEditing, //任何时候都显示 UITextFieldViewModeAlways}; 设置输入框左边的view @property(nonatomic,retain) UIView *leftView; 设置输入框左视图的显示模式 @property(nonatomic) UITextFieldViewMode leftViewMode; 设置输入框右边的view @property(nonatomic,retain) UIView *rightView; 设置输入框右视图的显示模式 @property(nonatomic) UITextFieldViewMode rightViewMode; 设置输入框成为第一响应时弹出的视图和辅助视图（类似键盘） @property (readwrite, retain) UIView inputView;@property (readwrite, retain) UIView inputAccessoryView; 这个属性设置是否允许再次编辑时在内容中间插入内容 @property(nonatomic) BOOL clearsOnInsertion； 注销第一响应（収键盘） (BOOL)endEditing:(BOOL)force; UITextFieldDelegate 代理中的方法 点击输入框时触发的方法，返回YES则可以进入编辑状态，NO则不能。 (BOOL)textFieldShouldBeginEditing:(UITextField *)textField; 开始编辑时调用的方法 (void)textFieldDidBeginEditing:(UITextField *)textField; 将要结束编辑时调用的方法，返回YES则可以结束编辑状态，NO则不能 (BOOL)textFieldShouldEndEditing:(UITextField *)textField; 结束编辑调用的方法 (void)textFieldDidEndEditing:(UITextField *)textField; 输入字符时调用的方法 (BOOL)textField:(UITextField )textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString )string; 点击清除按钮时调用的函数，返回YES则可以清除，点击NO则不能清除 (BOOL)textFieldShouldClear:(UITextField *)textField; 点击return键触发的函数 (BOOL)textFieldShouldReturn:(UITextField *)textField; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITextField","slug":"UITextField","permalink":"http://huishao.cc/tags/UITextField/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISegmentedControl","slug":"13iOS UISegmentedControl","date":"2015-04-12T16:00:00.000Z","updated":"2021-06-02T08:36:44.741Z","comments":true,"path":"2015/04/13/13iOS UISegmentedControl/","link":"","permalink":"http://huishao.cc/2015/04/13/13iOS UISegmentedControl/","excerpt":"","text":"SegmentedControl又被称作分段控制器，是IOS开发中经常用到的一个UI控件。 初始化方法：传入的数组可以是字符串也可以是UIImage对象的图片数组 (instancetype)initWithItems:(NSArray *)items; 设置控件风格： @property(nonatomic) UISegmentedControlStyle segmentedControlStyle 注意：这个属性已经废弃，不再起任何作用，它的枚举如下： typedef NS_ENUM(NSInteger, UISegmentedControlStyle) { UISegmentedControlStylePlain, // large plain UISegmentedControlStyleBordered, // large bordered UISegmentedControlStyleBar, // small button/nav bar style. tintable UISegmentedControlStyleBezeled, // DEPRECATED. Do not use this style.} NS_DEPRECATED_IOS(2_0, 7_0, “The segmentedControlStyle property no longer has any effect”); 设置是否保持选中状态： @property(nonatomic,getter=isMomentary) BOOL momentary; 注意：如果设置为YES，点击结束后，将不保持选中状态，默认为NO 获取标签个数：(只读) @property(nonatomic,readonly) NSUInteger numberOfSegments; 设置标签宽度是否随内容自适应： @property(nonatomic) BOOL apportionsSegmentWidthsByContent； 注意：如果设置为NO，则所有标签宽度一致，为最大宽度。 插入文字标签在index位置： (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated 插入图片标签在index位置 (void)insertSegmentWithImage:(UIImage *)image atIndex:(NSUInteger)segment animated:(BOOL)animated 根据索引删除标签 (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated; 删除所有标签 (void)removeAllSegments; 重设标签标题 (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment; 获取标签标题 (NSString *)titleForSegmentAtIndex:(NSUInteger)segment; 设置标签图片 (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment; 获取标签图片 (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment; 注意：标题的图片只能设置一个 根据索引设置相应标签宽度 (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;注意：如果设置为0.0，则为自适应，默认为此设置。 根据索引获取标签宽度 (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment; 设置标签内容的偏移量 (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment; 注意：这个偏移量指的是标签的文字或者图片 根据索引获取变标签内容的偏移量 (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment; 根据所以设置标签是否有效(默认有效) (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment; 根据索引获取当前标签是否有效 (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment; 设置和获取当前选中的标签索引 @property(nonatomic) NSInteger selectedSegmentIndex; 设置标签风格颜色 @property(nonatomic,retain) UIColor *tintColor; 注意：这个风格颜色会影响标签的文字和图片 设置特定状态下segment的背景图案 (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 注意：UIBarMetrics是一个枚举，如下：(defaulf风格会充满背景) typedef NS_ENUM(NSInteger, UIBarMetrics) { UIBarMetricsDefault, UIBarMetricsCompact, UIBarMetricsDefaultPrompt = 101, // Applicable only in bars with the prompt property, such as UINavigationBar and UISearchBar UIBarMetricsCompactPrompt, UIBarMetricsLandscapePhone NS_ENUM_DEPRECATED_IOS(5_0, 8_0, &quot;Use UIBarMetricsCompact instead&quot;) = UIBarMetricsCompact, UIBarMetricsLandscapePhonePrompt NS_ENUM_DEPRECATED_IOS(7_0, 8_0, &quot;Use UIBarMetricsCompactPrompt&quot;) = UIBarMetricsCompactPrompt, }; 获取背景图案 (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 设置标签之间分割线的图案 (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 获取标签之间分割线的图案 (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 通过Attribute字符串属性字典设置标签标题 (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state 获取Attribute字符串属性字典 (NSDictionary *)titleTextAttributesForState:(UIControlState)state 自行设置标签内容的偏移量 (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 注意：UIOffset为偏移量，这个结构体中又两个浮点数，分别表示水平量和竖直量；UISegmentedControlSegment类型参数是一个枚举，如下： typedef NS_ENUM(NSInteger, UISegmentedControlSegment) { UISegmentedControlSegmentAny = 0,//所有标签都受影响 UISegmentedControlSegmentLeft = 1, //只有左边部分受到影响 UISegmentedControlSegmentCenter = 2, // 只有中间部分受到影响 UISegmentedControlSegmentRight = 3, // 只有右边部分受到影响 UISegmentedControlSegmentAlone = 4, // 在只有一个标签的时候生效}; 获取自定义偏移量 (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 添加点击事件 [segmentedControl addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISegmentedControl","slug":"UISegmentedControl","permalink":"http://huishao.cc/tags/UISegmentedControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS 封装静态库(.a文件)","slug":"11iOS 封装静态库(.a文件)","date":"2015-04-10T16:00:00.000Z","updated":"2021-06-02T08:33:44.701Z","comments":true,"path":"2015/04/11/11iOS 封装静态库(.a文件)/","link":"","permalink":"http://huishao.cc/2015/04/11/11iOS 封装静态库(.a文件)/","excerpt":"","text":"iOS中导入外部文件，一种是将源码导入，一种是导入静态库，有很多第三方库都是以静态库的形式提供给我们使用的，如何制作一个静态库呢？ 一、xCode创建文件时，选择创建静态库文件：cacoaTouchStaticLibrary 创建完成后，我们在里面写我们的方法和实现： .h文件和.m文件 1234#import &lt;Foundation/Foundation.h&gt;@interface MyStaticLibrary : NSObject-(void)myLog;@end 123456#import &quot;MyStaticLibrary.h&quot;@implementation MyStaticLibrary-(void)myLog&#123; NSLog(@&quot;myLog&quot;);&#125;@end 二、生成静态库文件：这里需要将设备选成IOS Device然后 使用command+B进行编译，如果xcode报出这样的一个错误：我们需要在Peoject-&gt;Code Signing -&gt;Code Signing Identity 改成IOS Developer再次编译，成功。然后你会看到，Products中的.a文件由红色编程了黑色。我们右键show in finder，就可以看到编译成功的静态库文件了。 三、合并静态库 在文件夹中，我们看到有两个.a文件，分别用在模拟器调试和真机调试中，如果我们在开发时需要真机模拟器不停的切换，我们可以将这两个静态库文件合并成为一个： 在终端使用：lipo -create -output 命令： 这时，我们的静态库文件就做好了。 三、静态库文件的使用： 将.a和.h文件导入工程，在需要的文件中导入头文件，即可使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"静态库","slug":"静态库","permalink":"http://huishao.cc/tags/静态库/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS UIButton解读","slug":"12iOS UIButton解读","date":"2015-04-10T16:00:00.000Z","updated":"2021-06-02T08:35:20.122Z","comments":true,"path":"2015/04/11/12iOS UIButton解读/","link":"","permalink":"http://huishao.cc/2015/04/11/12iOS UIButton解读/","excerpt":"","text":"UIButton控件是应用界面中常用的一个控件，用法总结： 一、初始化 UIButton的初始化一般使用其类方法，+ (id)buttonWithType:(UIButtonType)buttonType; 风格的枚举如下： typedef NS_ENUM(NSInteger, UIButtonType) { //用户自定义，无风格 UIButtonTypeCustom = 0, //系统默认风格 UIButtonTypeSystem NS_ENUM_AVAILABLE_IOS(7_0), //一下这三种创建出来的按钮一样，一个蓝色的圆圈，中间有个叹号 UIButtonTypeDetailDisclosure, UIButtonTypeInfoLight, UIButtonTypeInfoDark, //创建+号按钮 UIButtonTypeContactAdd, //废弃 UIButtonTypeRoundedRect = UIButtonTypeSystem,}; 二、属性设置 @property(nonatomic) UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR;//这个属性设置button里内容的偏移量，包括title和image，可以用如下方法设置btn.contentEdgeInsets=UIEdgeInsetsMake(20, 20, 0, 0); @property(nonatomic) UIEdgeInsets titleEdgeInsets;//这个属性设置标题的偏移量@property(nonatomic) BOOL reversesTitleShadowWhenHighlighted;//按钮高亮时，是否改变阴影效果@property(nonatomic) UIEdgeInsets imageEdgeInsets;//图片的偏移量@property(nonatomic)BOOL adjustsImageWhenHighlighted;//设置图片的绘制是否高亮时变暗@property(nonatomic)BOOL adjustsImageWhenDisabled;//设置图片是否轻绘制当按钮禁用时@property(nonatomic)BOOL showsTouchWhenHighlighted;//设置是否显示手指印在按钮高亮的时候@property(nonatomic,retain) UIColor *tintColor NS_AVAILABLE_IOS(5_0);//这个属性会作用于标题和图片，但是如果你是自定义风格的按钮，这个属性将不起任何作用，它只作用于系统的@property(nonatomic,readonly) UIButtonType buttonType;//设置button的风格 三、一些set方法 (void)setTitle:(NSString *)title forState:(UIControlState)state;//设置标题和显示当前标题的按钮状态 (void)setTitleColor:(UIColor *)color forState:(UIControlState)state;//设置标题颜色和显示当前颜色的按钮状态 (void)setTitleShadowColor:(UIColor *)color forState:(UIControlState)state;//设置标题阴影颜色及显示时的状态 (void)setImage:(UIImage *)image forState:(UIControlState)state;//设置按钮图片和显示当前图片时的状态 (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state;//设置按钮背景图片和显示图片时的状态 (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state NS_AVAILABLE_IOS(6_0);//通过AttributeString创建标题 注意：按钮图片设置和背景图片的不同在于： 1、设置图片，如果有标题会和标题并列显示 2、设置背景图片会出现在标题下面 3、图片的偏移量可以设置，背景图片不可以。 四、一些get方法，可以得到上述设置的属性 (NSString *)titleForState:(UIControlState)state; (UIColor *)titleColorForState:(UIControlState)state; (UIColor *)titleShadowColorForState:(UIControlState)state; (UIImage *)imageForState:(UIControlState)state; (UIImage *)backgroundImageForState:(UIControlState)state; (NSAttributedString *)attributedTitleForState:(UIControlState)state NS_AVAILABLE_IOS(6_0); 五、一些只读属性 @property(nonatomic,readonly,retain) NSString currentTitle;@property(nonatomic,readonly,retain) UIColor currentTitleColor;@property(nonatomic,readonly,retain) UIColor currentTitleShadowColor;@property(nonatomic,readonly,retain) UIImage currentImage;@property(nonatomic,readonly,retain) UIImage currentBackgroundImage;@property(nonatomic,readonly,retain) NSAttributedString currentAttributedTitle NS_AVAILABLE_IOS(6_0);//这两个参数需要注意，虽然他们是只读属性不能重新设置，但是我们可以设置label和imageView的相关属性@property(nonatomic,readonly,retain) UILabel titleLabel NS_AVAILABLE_IOS(3_0);@property(nonatomic,readonly,retain) UIImageView imageView NS_AVAILABLE_IOS(3_0); 六、下面这些函数，都会返回一个CGRect 矩形范围 (CGRect)backgroundRectForBounds:(CGRect)bounds;//返回背景大小 (CGRect)contentRectForBounds:(CGRect)bounds;//返回视图大小，包括标题和图片 (CGRect)titleRectForContentRect:(CGRect)contentRect;//返回标题大小 (CGRect)imageRectForContentRect:(CGRect)contentRect;//返回图片大小 关于触发事件，button是继承于UIControl,这里不再叙述。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIButton","slug":"UIButton","permalink":"http://huishao.cc/tags/UIButton/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS NSInvocation应用与理解","slug":"09iOS NSInvocation应用与理解","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:36:47.104Z","comments":true,"path":"2015/04/10/09iOS NSInvocation应用与理解/","link":"","permalink":"http://huishao.cc/2015/04/10/09iOS NSInvocation应用与理解/","excerpt":"","text":"IOS中有一个类型是SEL，它的作用很相似与函数指针，通过performSelector:withObject:函数可以直接调用这个消息。但是perform相关的这些函数，有一个局限性，其参数数量不能超过2个，否则要做很麻烦的处理，与之相对，NSInvocation也是一种消息调用的方法，并且它的参数没有限制。这两种直接调用对象消息的方法，在IOS4.0之后，大多被block结构所取代，只有在很老的兼容性系统中才会使用，简单用法总结如下： 一、初始化与调用 在官方文档中有明确说明，NSInvocation对象只能使用其类方法来初始化，不可使用alloc/init方法。它执行调用之前，需要设置两个方法：setSelector: 和setArgument:atIndex： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog); //创建一个函数签名，这个签名可以是任意的,但需要注意，签名函数的参数数量要和调用的一致。 NSMethodSignature * sig = [NSNumber instanceMethodSignatureForSelector:@selector(init)]; //通过签名初始化 NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; //设置target [invocatin setTarget:self]; //设置selecteor [invocatin setSelector:myMethod]; //消息调用 [invocatin invoke]; &#125;-(void)myLog&#123; NSLog(@&quot;MyLog&quot;);&#125; 注意：签名函数的参数数量要和调用函数的一致。测试后发现，当签名函数参数数量大于被调函数时，也是没有问题的。 调用多参数的方法，我们可以这样写： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 注意：1、这里设置参数的Index 需要从2开始，因为前两个被selector和target占用。下面这样写也没有任何问题： 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); SEL myMethod2 = @selector(myLog); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; ViewController * view = self; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 2、这里的传参方式必须是传递参数地址。 二、NSInvocation的返回值 NSInvocation对象，是可以有返回值的，然而这个返回值，并不是其所调用函数的返回值，需要我们手动设置： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; ViewController * view = self; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; //我们将c的值设置为返回值 [invocatin setReturnValue:&amp;c]; int d; //取这个返回值 [invocatin getReturnValue:&amp;d]; NSLog(@&quot;%d&quot;,d); &#125;-(int)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c); return a+b+c;&#125; 注意：这里的操作传递的都是地址。如果是OC对象，也是取地址。 三、关于内存 可以注意到- (void)retainArguments;这个方法，它会将传入的所有参数以及target都retain一遍。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSInvocation","slug":"NSInvocation","permalink":"http://huishao.cc/tags/NSInvocation/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSTimer 定时器用法总结","slug":"10iOS NSTimer 定时器用法总结","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:37:50.677Z","comments":true,"path":"2015/04/10/10iOS NSTimer 定时器用法总结/","link":"","permalink":"http://huishao.cc/2015/04/10/10iOS NSTimer 定时器用法总结/","excerpt":"","text":"NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下： 一、初始化方法：有五种初始化方法，分别是 + (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个Invocation对象 NSInvocation * invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(init)]]; [invo setTarget:self]; [invo setSelector:@selector(myLog)]; NSTimer * timer = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES]; //加入主循环池中 [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; //开始循环 [timer fire];&#125; + (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 1 NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES]; + (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:NO] + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:@&quot;123&quot; repeats:YES] - (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep 12 NSTimer * timer = [[NSTimer alloc]initWithFireDate:[NSDate distantPast] interval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; 注意：这五种初始化方法的异同： 1、参数repeats是指定是否循环执行，YES将循环，NO将只执行一次。 2、timerWithTimeInterval这两个类方法创建出来的对象如果不用 addTimer: forMode方法手动加入主循环池中，将不会循环执行。并且如果不手动调用fair，则定时器不会启动。 3、scheduledTimerWithTimeInterval这两个方法不需要手动调用fair，会自动执行，并且自动加入主循环池。 4、init方法需要手动加入循环池，它会在设定的启动时间启动。 二、成员变量 @property (copy) NSDate *fireDate; 这是设置定时器的启动时间，常用来管理定时器的启动与停止 1234 //启动定时器 timer.fireDate = [NSDate distantPast]; //停止定时器 timer.fireDate = [NSDate distantFuture]; @property (readonly) NSTimeInterval timeInterval; 这个是一个只读属性，获取定时器调用间隔时间。 @property NSTimeInterval tolerance; 这是7.0之后新增的一个属性，因为NSTimer并不完全精准，通过这个值设置误差范围。 @property (readonly, getter=isValid) BOOL valid; 获取定时器是否有效 @property (readonly, retain) id userInfo; 获取参数信息 三、关于内存释放 如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。所以我们需要这样做： 123456789101112131415161718-(void)dealloc&#123; NSLog(@&quot;dealloc:%@&quot;,[self class]);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; timer= [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(btn) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;-(void)btn&#123; if (timer.isValid) &#123; [timer invalidate]; &#125; timer=nil; [self dismissViewControllerAnimated:YES completion:nil];&#125; 在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSTimer","slug":"NSTimer","permalink":"http://huishao.cc/tags/NSTimer/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS 中block结构的简单用法","slug":"08iOS 中block结构的简单用法","date":"2015-04-08T16:00:00.000Z","updated":"2021-05-31T03:35:27.069Z","comments":true,"path":"2015/04/09/08iOS 中block结构的简单用法/","link":"","permalink":"http://huishao.cc/2015/04/09/08iOS 中block结构的简单用法/","excerpt":"","text":"自从block出现之后，很多API都开始采用这样的结构，由此可见，block确实有许多优势存在，这里将一些简单用法总结如下： 一、如何声明一个block变量 我们通过^符号来声明block类型，形式如下： void (^myBlock)(); 其中第一个void是返回值，可以是任意类型，中间括号中^后面的是这个block变量的名字，我把它命名为myBlock，最后一个括号中是参数，如果多参数，可以写成如下样式： int (^myBlock)(int,int); 同样，你也可以给参数起名字： int (^myBlock)(int a,int b); 很多时候，我们需要将我们声明的block类型作为函数的参数，也有两种方式： 1、-(void)func:(int (^)(int a,int b))block； 第二种方式是通过typedef定义一种新的类型，这也是大多数情况下采用的方式： 2、typedef int (^myBlock)(int a,int b) ; -(void)func:(myBlock)block ; 二、如何实现一个block 既然block可以被声明为变量，那么就一定可以实现它，就像其他类型变量的赋值。我自己对block的理解为它是一断代码块，所以给它赋值赋便是一段代码段： 1234567891011121314151617typedef int (^myBlock)(int,int) ;@interface ViewController ()&#123; myBlock block1;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. block1 =^(int a, int b)&#123; return a+b; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 这里打印的结果是2，从这里可以发现block和函数的功能很像。 注意：1、在上面的代码里 block1是一个对象，如果直接打印将打印对象地址 2、block()，加上后面的括号才是执行block语句块 三、block中访问对象的微妙关系 1、如果你在一个block块中仅仅访问对象，而不是对他进行修改操作，是没有任何问题的： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; int count= tem+1; return count; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 而如果我在block块中直接修改，编译器会报错： 1234 block1 = ^(int a,int b)&#123; tem+=1; return tem+1; &#125;; 为什么会出现这样的情况，根据猜测，可能是block内部将访问的变量都备份了一份，如果我们在内部修改，外部的变量并不会被修改，我们可以通过打印变量的地址来证明这一点： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; int tem=2; NSLog(@&quot;%p&quot;,&amp;tem); block1 = ^(int a,int b)&#123; NSLog(@&quot;%p&quot;,&amp;tem); return tem+1; &#125;; NSLog(@&quot;%d&quot;,block1(1,1)); &#125; 打印结果如下： 可以看出，变量的地址已经改变。 2、__block 做了什么 为了可以在block块中访问并修改外部变量，我们常会把变量声明成__block类型，通过上面的原理，可以发现，其实这个关键字只做了一件事，如果在block中访问没有添加这个关键字的变量，会访问到block自己拷贝的那一份变量，它是在block创建的时候创建的，而访问加了这个关键字的变量，则会访问这个变量的地址所对应的变量。我们可以通过代码来证明： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; tem=4; NSLog(@&quot;%d&quot;,block1(1,1)); block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; __block int tem2=2; tem2=4; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 结果： 3、一点点扩展 由此，我们可以理解，如果block中操作的对象是指针，那么直接可以进行修改，这包括OC对象，如果不是，则需要用__block关键字修饰。 4、关于引用计数 在block中访问的对象，会默认retain： 1234567 UIImage * number; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 结果如下： 而添加__block的对象不会被retain; 注意：如果我们访问类的成员变量，或者通过类方法来访问对象，那么这些对象不会被retain，而类对象会被return，最常见的时self: 1234567891011121314151617181920212223242526272829303132typedef void(^myBlock)(int,int) ;@interface ViewController2 ()&#123; myBlock block1; __block UIImage * number; &#125;@end@implementation ViewController2-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number));&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; //block1(1,1); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 打印结果： 可以看出，UIImage对象没有被retain,而self也将循环引用，造成内存泄露。解决方法如下： 1234567 number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIImage * im = number; block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)im)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 打印结果： 注意：根据这个机制，如果我们将block用来传值，在block不用时，务必要置为nil,而在实现block的方法里，务必要释放;我们通过代码来解释： 首先，创建三个ViewController，为ViewController1，ViewController2，ViewController3； 1、在ViewController1中创建一个按钮，跳转ViewController2 2、在ViewController2中： 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController2.h&quot;#import &quot;ViewController3.h&quot;@interface ViewController2 ()&#123; UIButton * im;&#125;@end@implementation ViewController3-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(300, 300, 100, 100); btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; im = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; im.backgroundColor=[UIColor blackColor]; [im addTarget:self action:@selector(rele) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:im];&#125;-(void)rele&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController3 alloc]init]; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 3、在ViewController3中： 12345678910111213141516171819202122#import &quot;ViewController3.h&quot;void (^myBlock)();@implementation ViewController3-(void)setBlock:(void(^)())block&#123; myBlock = [block copy];&#125;-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; myBlock(); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 通过打印信息，我们会发现，ViewController2不被释放，原因是其成员变量im被block中retain没有释放，我们这样做： 1234567891011121314151617@interface ViewController2 ()&#123; UIButton * im; ViewController3 * tem;&#125;-(void)rele&#123; [tem setBlock:nil]; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController2 alloc]init]; tem=con; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 这样就解决了内存问题。 四、关于block的作用域 应避免将花括号中的block用于外面，如果需要，你可以将这个block声明为全局的。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"Block","slug":"Block","permalink":"http://huishao.cc/tags/Block/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中使用NSAttributedString灵活创建标签","slug":"07iOS中使用NSAttributedString灵活创建标签","date":"2015-04-07T16:00:00.000Z","updated":"2021-05-31T03:33:47.188Z","comments":true,"path":"2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","link":"","permalink":"http://huishao.cc/2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","excerpt":"","text":"灵活使用NSAttributedString可以更轻松的创建出内容复杂的标签。需要注意一点：如果一个label设置了这个属性，那它其他的设置都将失效。 首先，我们初始化一个NSMutableAttributedString对象。 12345678//通过字符串初始化//- (instancetype)initWithString:(NSString *)str;//通过字符串和属性字典直接初始化//- (instancetype)initWithString:(NSString *)str attributes:(NSDictionary *)attrs;//通过自身对象初始化//- (instancetype)initWithAttributedString:(NSAttributedString *)attrStr; NSMutableAttributedString * attribute = [[NSMutableAttributedString alloc]initWithString:@&quot;123!@#你好么QWE&quot;]; 可以通过下面两个函数对attrebute字符串进行设置与修改 123456//可以替换字符- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;//属性设置- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;//设置一定范围内字符属性- (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; 字典的键值对应如下： 123456789101112131415161718//kCTFontAttributeName 这个键是字体的名称 必须传入CTFont对象//kCTKernAttributeName 这个键设置字体间距 传入必须是数字对象 默认为0//kCTLigatureAttributeName 这个键设置连字方式 必须传入CFNumber对象//kCTParagraphStyleAttributeName 段落对其方式//kCTForegroundColorAttributeName 字体颜色 必须传入CGColor对象//kCTStrokeWidthAttributeName 笔画宽度 必须是CFNumber对象//kCTStrokeColorAttributeName 笔画颜色//kCTSuperscriptAttributeName 控制垂直文本定位 CFNumber对象//kCTUnderlineColorAttributeName 下划线颜色[attribute addAttribute:(NSString*)kCTKernAttributeName value:@5 range:NSMakeRange(0, 5)];[attribute addAttribute:(NSString *)kCTFontAttributeName value:(id)CFBridgingRelease(CTFontCreateWithName((CFStringRef)[UIFont boldSystemFontOfSize:14].fontName, 14, NULL)) range:NSMakeRange(0, 4)]; [attribute addAttribute:(NSString *)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; 通过测试，发现上面有些键值并没有作用，可以替换下面的方法，效果相同，不同的地方在于其传值的类型不同，下面的方法更加方便（使用UIFont UIColor NSString 和一些系统枚举） 1234567891011121314151617181920 NSParagraphStyleAttributeNameNSForegroundColorAttributeNameNSBackgroundColorAttributeNameNSLigatureAttributeNameNSKernAttributeNameNSStrikethroughStyleAttributeNameNSUnderlineStyleAttributeNameNSStrokeColorAttributeName NSStrokeWidthAttributeName NSShadowAttributeName NSTextEffectAttributeNameNSAttachmentAttributeName NSLinkAttributeName NSBaselineOffsetAttributeName NSUnderlineColorAttributeNameNSStrikethroughColorAttributeNameNSObliquenessAttributeName NSExpansionAttributeName NSWritingDirectionAttributeNameNSVerticalGlyphFormAttributeName 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://huishao.cc/tags/NSAttributedString/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS6中横屏的处理方法","slug":"05iOS6中横屏的处理方法","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:33:03.710Z","comments":true,"path":"2015/04/07/05iOS6中横屏的处理方法/","link":"","permalink":"http://huishao.cc/2015/04/07/05iOS6中横屏的处理方法/","excerpt":"","text":"IOS6以后，若想在项目中支持横屏，我们首先需要在plist文件中添加支持横屏的设置，否则有些代码设置将会失效。 有来那个方式设置： 1、在pilist的Supported interface orientations 字段中添加 2、在Xcode的设置中勾选 现在我们来看决定屏幕方向的几个函数： 在IOS6之前，我们只需通过一个函数 - (BOOL) shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation { return (toInterfaceOrientation == UIInterfaceOrientationLandscapeRight);} 就可以支持指定控制器的旋转。通过新的文档，我们可以看到： 1234// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);//这个方法在6.0之后被标记为过时的 我们通过下面两个方法来代替： //是否允许屏幕旋转 -(BOOL)shouldAutorotate{ return YES;}//支持的方向- (NSUInteger)supportedInterfaceOrientations { return UIInterfaceOrientationMaskLandscapeRight;}这是个枚举 123456789101112131415typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown=(1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125;; 通过这两个函数，如果我们需要某个控制器强制方向，我们可以设置支持单一的方向，即可达到目的。 注意： 如果你们项目中的RootViewController是导航，你会发现，你在Push出来的视图中添加刚才的代码并没有起作用，原因是导航，并没有进行设置，我们创建一个文件，继承于NavigationController。在里面重写刚才的方法，这么做后，屏幕确实横了过来，并且这个导航push的所有子界面都将横屏，这也不是我们想要的效果。我们想自由的控制每个push出来的界面的屏幕方向，可以在导航里这么做： 1234567-(BOOL)shouldAutorotate&#123; return [self.topViewController shouldAutorotate];&#125;//支持的方向- (NSUInteger)supportedInterfaceOrientations &#123; return [self.topViewController supportedInterfaceOrientations];;&#125; 我们还需要做一些处理，经过我的测试，导航必须在pop后才会重新调用这些函数，所以我的方法是这样做：弹出一个中间控制器后再POP回来 1234567@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController pushViewController:[[ViewController3 alloc]init] animated:YES];&#125; 1234567@implementation ViewController3- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController popViewControllerAnimated:YES];&#125; 这样做，我们就可以自由的控制每个视图控制器的方向了。 同理，如果根视图控制器是tabBar，则我们需要在tabBar中做操作。 如果我们大多是的视图控制器都是一个方向的，只有偶尔的几个会不同，这时候，我们其实可以采取presentationController的方式，然后直接在弹出的控制器中写那两个方法即可。这是最简单的途径了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"横屏","slug":"横屏","permalink":"http://huishao.cc/tags/横屏/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS UILabe及UIFont用法总结","slug":"06iOS UILabe及UIFont用法总结","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:32:56.548Z","comments":true,"path":"2015/04/07/06iOS UILabe及UIFont用法总结/","link":"","permalink":"http://huishao.cc/2015/04/07/06iOS UILabe及UIFont用法总结/","excerpt":"","text":"初始化一个UILabel对象，并初始化大小 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置显示的文字 label.text=@”123”; 和字体相关的一个类，字号大小默认17 @property(nonatomic,retain) UIFont*font; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//7.0之后可用 设置字体风格// NSString *const UIFontTextStyleHeadline; 用于标题的风格// NSString *const UIFontTextStyleSubheadline;用于副标题的风格// NSString *const UIFontTextStyleBody;用于正文的字体// NSString *const UIFontTextStyleFootnote;用于脚注的字体// NSString *const UIFontTextStyleCaption1;用于标准字幕字体// NSString *const UIFontTextStyleCaption2;用于替换字幕字体 label.font=[UIFont preferredFontForTextStyle:UIFontTextStyleCaption2];//说实话，没看出什么太大的差别//设置字体和字体大小+ (UIFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize;//返回所有字体的字体家族名称数组+ (NSArray *)familyNames;//按字体家族名称返回字体名称数组+ (NSArray *)fontNamesForFamilyName:(NSString *)familyName;//设置普通字体字号大小+ (UIFont *)systemFontOfSize:(CGFloat)fontSize;//设置加粗字体字号大小+ (UIFont *)boldSystemFontOfSize:(CGFloat)fontSize;//设置斜体字号大小+ (UIFont *)italicSystemFontOfSize:(CGFloat)fontSize;//一些只读属性//字体家族名称@property(nonatomic,readonly,retain) NSString *familyName;//字体名称@property(nonatomic,readonly,retain) NSString *fontName;//字号大小@property(nonatomic,readonly) CGFloat pointSize;//字体设计模型，表示距离最高点偏移余量@property(nonatomic,readonly) CGFloat ascender;//底部的模型偏移量@property(nonatomic,readonly) CGFloat descender;//字体模型的头高信息@property(nonatomic,readonly) CGFloat capHeight;//字体模型的xHeight信息@property(nonatomic,readonly) CGFloat xHeight;//字体行高@property(nonatomic,readonly) CGFloat lineHeight NS_AVAILABLE_IOS(4_0);//模型主体信息@property(nonatomic,readonly) CGFloat leading;//创建一个新字体与当前字体相同，除了指定的大小- (UIFont *)fontWithSize:(CGFloat)fontSize;//通过描述信息返回字体 7.0后可用+ (UIFont *)fontWithDescriptor:(UIFontDescriptor *)descriptor size:(CGFloat)pointSize NS_AVAILABLE_IOS(7_0);//返回字体的描述信息，7.0后可用- (UIFontDescriptor *)fontDescriptor NS_AVAILABLE_IOS(7_0); 设置字体颜色 label.textColor=[UIColor redColor]; 设置阴影偏移量 label.shadowOffset=CGSizeMake(20, 20); 设置阴影颜色 label.shadowColor=[UIColor blackColor]; 设置对齐模式 label.textAlignment=NSTextAlignmentJustified; 1234567891011enum &#123; //沿左边沿对齐文本 NSTextAlignmentLeft = 0, //中心对齐 NSTextAlignmentCenter = 1, //右边沿对齐 NSTextAlignmentRight = 2, //最后一行自然对齐 NSTextAlignmentJustified = 3, //默认对齐 NSTextAlignmentNatural = 4,&#125;;typedef NSInteger NSTextAlignment; 多行文本设置 label.lineBreakMode=NSLineBreakByCharWrapping; 12345678910111213enum &#123; //文本边缘处理 NSLineBreakByWordWrapping = 0, //提前处理不合适的字符 NSLineBreakByCharWrapping, //简单线性处理 NSLineBreakByClipping, //丢失的开头用省略号表示 NSLineBreakByTruncatingHead, //丢失的文本在末尾显示省略号 NSLineBreakByTruncatingTail, //丢失的文本在中间显示省略号 NSLineBreakByTruncatingMiddle &#125;;typedef NSUInteger NSLineBreakMode 使用attributedText绘制 @property(nonatomic,copy) NSAttributedString *attributedText 设置高亮的字体颜色 label.highlightedTextColor=[UIColor blueColor]; //设置是否高亮 label.highlighted=YES; 用户交互 默认关闭 label.userInteractionEnabled=NO; 是否有效，默认是YES，无效为灰色 label.enabled=NO; 显示的行数，0为无限 @property(nonatomic) NSInteger numberOfLines; 宽度自适应大小 默认是NO @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 字符适应宽度：不赞成使用 @property(nonatomic) BOOL adjustsLetterSpacingToFitWidth 最小适应大小2.0-6.0 @property(nonatomic) CGFloat minimumFontSize 最小适应大小 6.0 之后 @property(nonatomic) CGFloat minimumScaleFactor 垂直方向的调整 @property(nonatomic) UIBaselineAdjustment baselineAdjustment; 1234567typedef enum &#123; //调整文本对应基线位置 UIBaselineAdjustmentAlignBaselines, //调整文本相对其边框的中心 UIBaselineAdjustmentAlignCenters, //调整文本相对于边界的左上角 默认的 UIBaselineAdjustmentNone,&#125; UIBaselineAdjustment; 返回文本绘制矩形 - (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines; 文本绘制函数 - (void)drawTextInRect:(CGRect)rect 文本自动布局参数 @property(nonatomic) CGFloat preferredMaxLayoutWidth 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UILabel","slug":"UILabel","permalink":"http://huishao.cc/tags/UILabel/"},{"name":"UIFont","slug":"UIFont","permalink":"http://huishao.cc/tags/UIFont/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS SEL的理解与使用","slug":"04iOS SEL的理解与使用","date":"2015-04-04T16:00:00.000Z","updated":"2021-05-28T10:11:35.356Z","comments":true,"path":"2015/04/05/04iOS SEL的理解与使用/","link":"","permalink":"http://huishao.cc/2015/04/05/04iOS SEL的理解与使用/","excerpt":"","text":"有很多人，认为block的推广可取代代理设计模式，其实block并不能取代代理，代理的模式可以让代码逻辑性更强，更整洁，也会有更高的可读性和可扩展性。相比之下，我觉得block更多的是取代了选择器@selector。 @selector是什么？我们要首先明白SEL，SEL并不是一种对象类型，我们通过xCode的字体颜色就可以判断出来，它是一个关键字，就像int，long一样，它声明了一种类型：类方法指针。其实就可以理解为一个函数指针。比如，我们生命一个叫myLog的函数指针： 1234567#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end 声明出了这个指针，我们该如何给它传递这个函数呢？有两种方式： 1、在编译时，使用@selector来取得函数 现在，我们应该明白@selector是什么了，它是一个编译标示，我们通过它来取到相应函数。 12345678910111213141516171819@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = @selector(myLogL); //通过performSelector来执行方法 [self performSelector:myLog];//打印 “myLog” &#125;-(void)myLogL&#123; NSLog(@&quot;myLog&quot;);&#125; 2、在运行时，通过NSSelectorFromString方法来取到相应函数： 12345678910111213141516171819202122#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = NSSelectorFromString(@&quot;myLogN&quot;); [self performSelector:myLog]; &#125;-(void)myLogN&#123; NSLog(@&quot;myLog&quot;);&#125; 这两种方式的差别在于，编译时的方法如果没有找到相应函数，xcode会报错，而运行时的方法不会。 至于SEL的应用，我相信最广泛的便是target——action设计模式了。我们来简单模拟一下系统button的工作原理： 我们先创建一个继承于UIButton的类： .h文件： 12345#import &lt;UIKit/UIKit.h&gt;@interface Mybutton : UIButton-(void)addMyTarget:(id)target action:(SEL)action;@end .m文件 1234567891011121314151617#import &quot;Mybutton.h&quot;@implementation Mybutton&#123; SEL _action; id _target;&#125;-(void)addMyTarget:(id)target action:(SEL)action&#123; _target=target; _action=action;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_target performSelector:_action];&#125;@end 在外部： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; Mybutton * btn = [[Mybutton alloc]initWithFrame:CGRectMake(100, 100, 60, 60)]; btn.backgroundColor=[UIColor redColor]; [btn addMyTarget:self action:@selector(click)]; [self.view addSubview:btn];&#125;-(void)click&#123; NSLog(@&quot;点击了btn&quot;);&#125; 当然，如果要调用参数，系统提供的默认参数不超过两个，如果参数很多，一种是我们可以通过字典传参，另一种方法比较复杂，在这里先不讨论。 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"SEL","slug":"SEL","permalink":"http://huishao.cc/tags/SEL/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS事件响应控制","slug":"03iOS事件响应控制","date":"2015-04-03T16:00:00.000Z","updated":"2021-05-28T10:09:54.887Z","comments":true,"path":"2015/04/04/03iOS事件响应控制/","link":"","permalink":"http://huishao.cc/2015/04/04/03iOS事件响应控制/","excerpt":"","text":"以前遇到一个项目，一个UIImageView对象上面有一个UIButton对象，然而项目的需求需要在点击 button的同时，UIImageView也接收到点击事件，在不使用代理和通知方法的前提下，通过事件响应链的原理，我们也可以很便捷的解决这个问题。 在处理这个问题之前，我们应该先清楚IOS的事件响应机制到底是个什么样的原理。 首先，这个事件响应的机制是分为两个部分的。 1、先在视图层级关系中找到应该响应事件的那个视图。 这一步是什么意思，其实很简单，就是找到你所触摸点对应的那个最上层的视图，它的工作原理是这样的：当用户发出事件后，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会取出队列中最前面的事件，发消息给UIWindow，然后UIWindow会对其所有子视图调用hitTest:withEvent:这个方法，这个方法会返回一个UIView的对象，这个方法在执行的时候，它会调用当前视图的pointInside:withEvent:这个方法，如果触摸事件在当前视图范围内，pointInside:withEvent:会返回YES，否则会返回NO；如果返回YES，则会遍历当前视图的所有子视图，统统发送hitTest:withEvent:这个消息，如果返回NO,则hitTest:withEvent:方法返回nil； 上面说起来有些绕，其实就是：hitTest:withEvent:方法会一层一层的向上找，若最上层响应的子视图pointInside:withEvent:返回YES，则返回此子视图，如果所有的都返回nil，则返回当前视图本身self。 例如：我们建两个文件，一个继承于UIButton，一个继承于UIImageView，我们在UIImageView里的代码如下： 12345678910111213141516171819#import &quot;MyImageView.h&quot;@implementation MyImageView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor=[UIColor redColor]; &#125; return self;&#125;//在这里，我们重写了这个方法，让它直接返回自身，而不是继续向下寻找应该响应事件的视图-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;点击了Image&quot;);&#125; 然后将他们创建在一个View上： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; // Do any additional setup after loading the view, typically from a nib.&#125; 我们运行，点击这个Btn，会打印如下的信息： 可以证明，在事件视图寻找中，UIImageView我们重写hitTest:withEvent:方法后，切断了寻找链，如果我们这个做： 123-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return nil;&#125; 你会发现，UIImageView也不再接收事件。2、寻找到应该响应的视图后，会进行消息处理，这个处理的方式是通过消息处理链来做的。如果它自身不能处理消息，会通过nextResponder将消息传递给下一个处理者，默认只要有一个view将消息处理了，这个消息处理传递链将不再传递。 现在，我们把刚才UIimageView里重写的hitTest:withEvent:方法注释掉，给btn添加一个点击方法，同时将用户交互关闭： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; image.userInteractionEnabled=YES; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click&#123; NSLog(@&quot;btn被点击了&quot;);&#125; 这样，我们的UIImageView又可以响应事件了，原因是事件处理传递链向下传递了。 现在，在回到我们刚开始的问题，如何让btn响应的同时imageView也响应，我们这样做： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; image.userInteractionEnabled=YES; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click:(UIButton *)btn&#123; NSLog(@&quot;btn被点击了&quot;); //响应链继续传递 [btn.nextResponder touchesBegan:nil withEvent:nil]; &#125; 结果如下： 虽然最终，我们完成了这个需求，可是我建议你最好不要这么干，因为这样的逻辑是违背现实生活中人们的行为认知的，更重要的是，我们的项目最后也确实改掉了这样的逻辑~~~ 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"事件","slug":"事件","permalink":"http://huishao.cc/tags/事件/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中DES与MD5加密方案","slug":"02MD","date":"2015-04-02T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/03/02MD/","link":"","permalink":"http://huishao.cc/2015/04/03/02MD/","excerpt":"","text":"MD5算法和DES算法是常见的两种加密算法。 MD5：MD5是一种不可逆的加密算法，按我的理解，所谓不可逆，就是不能解密，那么它有什么用的，它的用处大了，大多数的登录功能都会使用到这种算法。后面根据我的项目经验来介绍。 DES：一种使用密钥加密的块算法，所以，使用它加密时，需要一个密钥，加上一些设置和你需要加密的文段。 在IOS中，使用这两种加密算法非常简单，系统的&lt;CommonCrypto/CommonCrypto.h&gt;库给我们提供的边界的接口。在很多移动项目中，安卓平台和IOS平台的后台服务是统一的，比如一个登录功能是这样的流程： 1、客户端向服务端请求密钥，请求的参数是双方约定好的一个MD5加密的字符串。我们可以通过下面的进行第一步加密： 1234567891011121314- (NSString *)MD5Digest&#123; //要进行UTF8的转码 const char* input = [self UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(input, (CC_LONG)strlen(input), result); NSMutableString *digest = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) &#123; [digest appendFormat:@&quot;%02x&quot;, result[i]]; &#125; return digest;&#125; 通过这样的方法，我们可以很容易的得到一串MD5加密字符串，但是一定要和后台约定好，MD5加密的位数是16位还是32位，用上述方法加密出来的时32位，当然他们之间是有联系的，通过下面的方法可以将其转成16为： 1234567+(NSString *)trransFromMD532ToMD516:(NSString *)MD532&#123; NSString * string; for (int i=0; i&lt;24; i++) &#123; string=[MD532 substringWithRange:NSMakeRange(8, 16)]; &#125; return string;&#125; 还有一点需要注意，加密后的大小写也要对应。 2、服务端将得到的MD5串和以约定好的MD5串进行对比，如果一致，可以放行，返回密钥。 3、客户端取到密钥，将密钥再进行一次MD5加密，然后通过DES将要传送的数据加密发给服务器。 这一步至关重要，我们先看DES的加密代码 12345678910111213141516171819202122232425262728293031+(NSString *) encryptUseDES:(NSString *)clearText key:(NSString *)key andiv:(NSString *)iv&#123; //这个iv 是DES加密的初始化向量，可以用和密钥一样的MD5字符 NSData * date = [iv dataUsingEncoding:NSUTF8StringEncoding]; NSString *ciphertext = nil; NSUInteger dataLength = [clearText length]; NSData *textData = [clearText dataUsingEncoding:NSUTF8StringEncoding]; unsigned char buffer[1024]; memset(buffer, 0, sizeof(char)); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,//加密模式 kCCDecrypt 代表解密 kCCAlgorithmDES,//加密方式 kCCOptionPKCS7Padding,//填充算法 [key UTF8String], //密钥字符串 kCCKeySizeDES,//加密位数 [date bytes],//初始化向量 [textData bytes] , dataLength, buffer, 1024, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; NSLog(@&quot;DES加密成功&quot;); NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted]; Byte* bb = (Byte*)[data bytes]; ciphertext = [Base64 parseByteArray2HexString:bb]; &#125;else&#123; NSLog(@&quot;DES加密失败&quot;); &#125; return ciphertext;&#125; 几点注意： （1）加密方式，IOS官方提供的是如下几种 12345678910enum &#123; kCCAlgorithmAES128 = 0, kCCAlgorithmAES = 0, kCCAlgorithmDES, kCCAlgorithm3DES, kCCAlgorithmCAST, kCCAlgorithmRC4, kCCAlgorithmRC2, kCCAlgorithmBlowfish &#125;; （2）填充算法 123456enum &#123; /* options for block ciphers */ kCCOptionPKCS7Padding = 0x0001, kCCOptionECBMode = 0x0002 /* stream ciphers currently have no options */&#125;; 我们可以发现，官方提供的只有这两种，然而JAVA使用的却是 1kCCOptionPKCS7Padding 但是不用担心，在密钥是8位的时候，这两种填充算法加密出来的结果试一模一样的。 4、服务器通过相同的方式，解密出密文，通配安卓端。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"加密","slug":"加密","permalink":"http://huishao.cc/tags/加密/"},{"name":"DES","slug":"DES","permalink":"http://huishao.cc/tags/DES/"},{"name":"MD5","slug":"MD5","permalink":"http://huishao.cc/tags/MD5/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"AFNetWorking用法及缓存处理","slug":"01AF","date":"2015-04-01T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/02/01AF/","link":"","permalink":"http://huishao.cc/2015/04/02/01AF/","excerpt":"","text":"AFNetWorking 在IOS开发中是一个经常会用的第三方开源库，其最好处是维护及时，源码开源。 常用GET与POST请求方法： POST请求： 123456789//初始化一个请求对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; //dic 为参数字典 [manager POST:url parameters:dic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; GET请求： 1234567AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; 这里有一个地方需要注意， 1[AFHTTPRequestOperationManager manager] 这个类方法我们点进源码可以发现： 123+ (instancetype)manager &#123; return [[self alloc] initWithBaseURL:nil];&#125; 这里初始化了一个返回了一个新的对象，并不是单例。 使用这样的下载方法，下载完成后的数据AFNetWorking会帮我们自动解析，但是有时候服务器给的数据并不标准，这时我们需要加上这个设置： manager.responseSerializer = [AFHTTPResponseSerializer serializer]; 这样我们将得到原始的HTTP返回给我们数据。 我们再来探究一下，下载成功后，回调方法里的参数到底是什么东西 1success:^(AFHTTPRequestOperation *operation, id responseObject) 其中，第二个参数 responseObject 是下载下来的data数据，可直接进行JSON等解析。 第一个参数，是个AFHTTPRequestOperation对象，来看源文件 123456789@interface AFHTTPRequestOperation : AFURLConnectionOperation@property (readonly, nonatomic, strong) NSHTTPURLResponse *response;@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;@property (readonly, nonatomic, strong) id responseObject;@end 可以发现，里面有一个成员便是responseObject，同时，AFHTTPRequestOperation是继承于AFURLConnectionOperation,我们在看看AFURLConnectionOperation这个类： 123456789101112131415161718192021222324252627282930313233343536373839@interface AFURLConnectionOperation : NSOperation &lt;NSURLConnectionDelegate, NSURLConnectionDataDelegate, NSSecureCoding, NSCopying&gt;@property (nonatomic, strong) NSSet *runLoopModes;@property (readonly, nonatomic, strong) NSURLRequest *request;@property (readonly, nonatomic, strong) NSURLResponse *response;@property (readonly, nonatomic, strong) NSError *error;@property (readonly, nonatomic, strong) NSData *responseData;@property (readonly, nonatomic, copy) NSString *responseString;@property (readonly, nonatomic, assign) NSStringEncoding responseStringEncoding;@property (nonatomic, assign) BOOL shouldUseCredentialStorage;@property (nonatomic, strong) NSURLCredential *credential;@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;@property (nonatomic, strong) NSInputStream *inputStream;@property (nonatomic, strong) NSOutputStream *outputStream;@property (nonatomic, strong) dispatch_queue_t completionQueue;@property (nonatomic, strong) dispatch_group_t completionGroup;@property (nonatomic, strong) NSDictionary *userInfo;- (instancetype)initWithRequest:(NSURLRequest *)urlRequest NS_DESIGNATED_INITIALIZER;- (void)pause;- (BOOL)isPaused;- (void)resume; 看到这里，就离AFNETWorking封装的源头很近了，里面的成员非常多，其中包含了大部分我们需要的信息，可以通过点语法取到，其中有输入输出流，错误信息，请求到的Data数据，以及请求到的字符串数据 1responseString 我们可以通过 1NSLog ( @&quot;operation: %@&quot; , operation. responseString ); 来打印查看请求到的原始信息。 几点注意： 1.关于崩溃url为nil 大多数这样的原因是url中有特殊字符或者中文字符，AFNETWorking并没有做UTF8的转码，需要： 1url = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 2.添加HttpHead字段的方法 1234 //为这个下载任务HTTP头添加@&quot;User-Agent&quot;字段 [manager.requestSerializer setValue:_scrData forHTTPHeaderField:@&quot;User-Agent&quot;]; //打印头信息 NSLog(@&quot;%@&quot;,manager.requestSerializer.HTTPRequestHeaders); 在下载请求中，经常会请求一些不长变化的数据，如果每次APP启动都进行请求，会消耗许多资源，并且有时候缓存的处理，可以大大改善用户体验。 在AFNETWorking中，并没有提供现成的缓存方案，我们可以通过写文件的方式，自行做缓存。 在下载方法中： 1234567[manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //写缓存 NSString *cachePath = @&quot;你的缓存路径&quot;;// /Library/Caches/MyCache [data writeToFile:cachePath atomically:YES]; succsee(data); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; &#125;]; 然后在每次下载前，进行如下判断： 12345 NSString * cachePath = @&quot;你的缓存路径&quot;; if ([[NSFileManager defaultManager] fileExistsAtPath:cachePath]) &#123; //从本地读缓存文件 NSData *data = [NSData dataWithContentsOfFile:cachePath]; &#125; 有时，我们的下载请求可能是用户的动作触发的，比如一个按钮。我们还应该做一个保护机制的处理， 123456789101112131415//初始化一个下载请求数组NSArray * requestArray=[[NSMutableArray alloc]init];//每次开始下载任务前做如下判断for (NSString * request in requestArray) &#123; if ([url isEqualToString:request]) &#123; return; &#125; &#125; [requestArray addObject:url]; //下载成功或失败后 [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [requestArray removeObject:url] &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [requestArray removeObject:url] &#125;]; 至此，一个比较完成AFNETWorking请求使用流程就完成了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://huishao.cc/tags/网络/"},{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"AFNetWorking","slug":"AFNetWorking","permalink":"http://huishao.cc/tags/AFNetWorking/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]}]}