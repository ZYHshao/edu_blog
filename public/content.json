{"meta":{"title":"珲少的技术博客","subtitle":"专注技术 有趣生活","description":"珲少的技术博客","author":"珲少","url":"http://huishao.cc"},"pages":[],"posts":[{"title":"iOS系统关于URL Schemes的漏洞探究","slug":"70iOS系统关于URL Schemes的漏洞探究","date":"2015-06-01T16:00:00.000Z","updated":"2021-06-29T07:51:09.032Z","comments":true,"path":"2015/06/02/70iOS系统关于URL Schemes的漏洞探究/","link":"","permalink":"http://huishao.cc/2015/06/02/70iOS系统关于URL Schemes的漏洞探究/","excerpt":"","text":"iOS系统关于URL Schemes的漏洞探究一、何为URL Schemes我想这个东西的设计的目的是为了方便App之间的相互调用与通讯，你可以在自己的App中使用OpenURL方法来唤起其他的App。比如微信的URL Schemes是wiexin，我们新建一个工程，实现如下代码后运行程序： 1[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;weixin://]]; 这时你会发现，你的应用启动后很快就调起了微信的客户端。 二、由URL Schemes引发的漏洞的根源1、一个小问题引起的漏洞根源如上所说，通过URL Schemes可以在应用间相互唤起，而产生漏洞的根源在于这个URL并非是应用唯一的。apple并没有任何限制或者审核这个URL的任何措施，也就是说，如果两个App有着相同的URL Schemes，那么系统唤起的App可能并不是你想唤起的。 2、URL Schemes的优先级如何确定由于相同的URL Scheme可能同时被多个App使用，再如果这些App都安装在了同一个设备上，那么系统究竟会唤起哪一个呢？这个我也不能十分的确定，只有一点可以肯定：如果有和系统应用的URL Scheme相同，那么系统一定会唤起系统自己的应用，在这里系统的应用有着最高的优先级（苹果这里做的好像很不厚道，将自己的应用保护了起来，而把广大其他开发者的应用放在漏洞前置之不理）。如果没有和系统耦合的，那么系统会唤起哪一个App就看运气了。不过，这也不是无章可循，经过测试，优先级和App的Bundle identifier有关，更准确说和Bundle identifier的字母排序有关，如果精心设计这个id，我们就可以做到截获其他应用的URL。 3、这个漏洞会引发什么问题么？仅仅通过上面的叙述，你可能还看不出这个漏洞会引发什么样的后果。可是如果你仔细观察，你会发现，各种iPhone上的第三方调用，例如QQ音乐快捷登录，腾讯的各种游戏，甚至包括调用支付宝钱包的支付功能，都是通过这样的原理实现的。如果这些回调的数据被截获，那么就等于说登录信息，用户信息甚至支付订单信息都会暴漏在他人眼下，对于截获者来说，他可以用你的信息进行登录，可以替你完成支付，也可以盗取你登陆后的用户信息。 三、利用URL Scheme漏洞进行远程登录下面，就用一个实例来演示一下我如何通过一个伪装App登录天天炫斗账号。 天天炫斗是腾讯的一款十分火爆的格斗游戏，像其他腾讯游戏一样，支持QQ和微信登录，这里我拿微信登录为例。 首先，我们需要做一个伪装的App来截取用户的登录信息，新建一个项目，在plist文件中添加一个和天天炫斗微信登录相同的URL Scheme： 这里的wx63124814f356e266就是微信登录天天炫斗的URL Scheme，这里将Bundle id设置为A，使它有比天天炫斗更高的优先级。 在AppDelegate中添加如下代码： 1234-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; NSLog(@&quot;%@&quot;,url); return YES;&#125; 这个函数是在App被通过URL唤起时首先调用的函数，这里传入的URL就是用户的登录验证信息，我们可以在这里将这个信息发送回来。 将伪装好的程序跑一遍后，运行天天炫斗，然后使用微信登录，会发现在微信验证成功后跳转后并没有跳转回天天炫斗应用，而是跳转到了我们伪装的这个Demo。这时xcode调试区会打印出如下的信息： 之后，来开始做我们的侵入程序，这个其实更加简单，新建一个工程，只需要添加一行代码： 1[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;wx63124814f356e266://oauth?code=0118aa2f2b99d8a9e0e76a7176b2bd4E&amp;state=weixin&quot;]]; 这里的URL就是我们截获的带参的URL，在另一个装有天天炫斗的手机上跑这个程序（在同一个手机上测试的话要将刚才的伪装App删去，不然它也会将我们的侵入程序一起骗了）。会发现登录天天炫斗成功，角色信息完全一致。 同样的做法，还可以远程登录QQ音乐，天天飞车等等各种通过微信，QQ，微博快捷登录的应用。 四、要战胜你的敌人，必须要了解你的敌人不了解apple为什么一直不对URL Scheme做限制，或许需要或许不需要。但是这一点建议总是好的：在你的App使用快捷登录的时候，最好同时将设备号或者某个本地保存的标志绑定，防止恶意的第三方借此获取用户的信息。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS界面布局之二——初识autolayout布局模型","slug":"69iOS界面布局之二——初识autolayout布局模型","date":"2015-05-31T16:00:00.000Z","updated":"2021-06-29T07:50:01.480Z","comments":true,"path":"2015/06/01/69iOS界面布局之二——初识autolayout布局模型/","link":"","permalink":"http://huishao.cc/2015/06/01/69iOS界面布局之二——初识autolayout布局模型/","excerpt":"","text":"iOS界面布局之二——初识autolayout布局模型一、引言 在上一篇博客中介绍了传统的布局方式：autoresizing。随着iphone型号的越来越多，屏幕的标准也更加多样化，通过autoresizing已经不能满足开发的需求，而进行两套布局或者动态代码控制又大大增加了开发者的工作量，autolayout的出现拯救个这一切，它让动态布局变的十分简单便捷。 autoresizing介绍：[http://my.oschina.net/u/2340880/blog/423357](http://my.oschina.net/u/2340880/blog/423357)。 二、autolayout的设计思想正如storyboard的设计目的是为了让开发者将更多的精力投入到逻辑实现而不是界面布局一样。autolayout的设计思想是让开发者将布局上更多的精力放在控件关系上而不是坐标。我们只需要关心控件之间的摆放关系，而并不需要关心这是如何实现的。因此你使用autolayout进行布局时，就是在添加一个一个的约束。控件与控件之间的约束，控件与父视图之间的约束。 1、了解几种约束点击xcode的storyboard文件，在xcode的导航栏上点击Edito，然后选择Pin，可以看到如图，其中是可以添加的约束类型。 Width：对视图宽度的约束 Height：对视图高度的约束 Horizontal Spacing：对视图间水平距离的约束 Vertical Spacing：对视图间垂直距离的约束 Leading Space to Superview：与父视图左边界的约束 Trailing Space to Superview：与父视图右边界的约束 Top Space to Superview：与父视图上边界的约束 Bottom Space to Superview：与父视图下边界的约束 Widehs Equally：视图等宽约束 Heights Equally：视图等高约束 2、网上的一个很简单的约束例子了解了上面的几种约束，现在我们来实现一个效果，借用网上关于autolayout自动布局的一个小例子。我们在storyboard中拖入三个label，使它们如下效果： 然后我们将屏幕横过来，会发现这时的效果并不是我们想得到的结果： 在进行添加约束之前，我们先来理清这三个视图之间的关系，将上面两个视图编号为1.2，下面那个视图编号为3. （1）1和2的宽和高相等 （2）1距离父视图左边20px （3）2距离父视图右边20px （4）3距离父视图左边20px，右边20px （5）1和2水平间距20px （6）1与3垂直间距20px （7）1和2距离父视图上边距50px （8）3距离父视图下边距20px （9）3与1和2的高度一样 通过上面的约束，所有视图的位置都将被相对的固定，下面我们只需要按照顺序一一添加即可。 （1）选中1和2视图（按住cmd键可以多选），然后点击Editor-&gt;Pin之后选择Widehs Equally，重复上面的过程，选择Heights Equally。我们会看到如下的效果： 几点注意： *线是橙色代表警告，我们没有添加足够的约束来确定位置或者约束有矛盾。 *如果线的中间显示的不是等号，而是数字，则是因为视图1和2的尺寸设置的不等，约束有矛盾。 （2）选中1.重复上面步骤，选择Leading Space to Superview。这时1的左边又会增加一条线： 点击这条线，在右边的设置去将约束值设置为20： （3）重复上面步骤，选中视图2，添加Trailing Space to Superview约束。 （4）选中视图3，重复上面步骤。 （5）选中1和2，添加Horizontal Spacing，设置为20. （6）选中1和3，添加Vertical Spacing，设置为20. （7）为1和2分别添加Top Space to Superview约束。 （8）为3添加Bottom Space to Superview约束。 （9）选中1和3，添加Heights Equally约束。 上面的过程虽然繁琐，但是逻辑性十分清晰，这时你会发现所有的线都变成了蓝色，约束已经添加完整，我们再次运行后横屏，效果如下： 这就是我们想要的结果了。 3、自动布局的几种对其方式在xcode导航的Editor菜单中，还有一个子菜单，Align，这里面的选项可以为控件添加对其约束： Left Edges：控件左对齐 Right Edges：控件右对齐 Top Edges：控件上对齐 Bottom Edges：控件下对齐 Horizontal Centers：控件水平中心对齐 Vertical Centers：控件垂直水平对齐 Horizontal Center in Container：控件与其父视图水平中心对齐 Vertical Center in Container：控件与其父视图垂直中心对齐 三、几点小感悟到此为止，基本上已经可以使用autolayout自动布局解决复杂的布局需求了，但是切记，正式因为aotulayout的强大使它会隐藏更多的坑，下面是我的几点感悟，再次分享： 1、autolayout的精髓在于足够多的约束，autolayout之所以比autoresizing强大，就在于其布局的精确性，而精确性正是由约束来提供的。 2、切莫画蛇添足，矛盾的约束会使xcode晕掉，所以在添加约束前，我建议将试图间的布局关系先整理出来。 3、应该转变你的思路，如果你已经习惯了使用CGRect、Point等传统的坐标布局模式，那么你应该稍微转变一下，autolayout倡导的是一个相对的概念，你需要将更多的关注放在视图间的关系，比如A和B距离10，A和C右对齐等。具体的坐标会有autolayout帮你算。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之一——使用autoresizing进行动态布局","slug":"68iOS界面布局之一——使用autoresizing进行动态布局","date":"2015-05-31T16:00:00.000Z","updated":"2021-06-29T07:46:40.535Z","comments":true,"path":"2015/06/01/68iOS界面布局之一——使用autoresizing进行动态布局/","link":"","permalink":"http://huishao.cc/2015/06/01/68iOS界面布局之一——使用autoresizing进行动态布局/","excerpt":"","text":"iOS界面布局之一——使用autoresizing进行动态布局autoresizing是iOS中传统的界面自动布局方式，通过它，当父视图frame变换时，子视图会自动的做出相应的调整。 一、通过代码进行布局任何一个view都有autoresizingMask这个属性，通过这个属性可以设置当前view与其父视图的相对关系。我们先来看UIViewAutoresizing这个枚举： 123456789typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123; UIViewAutoresizingNone = 0,//默认 UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,//与父视图右边间距固定，左边可变 UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,//视图宽度可变 UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,//与父视图左边间距固定，右边可变 UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3,//与父视图下边间距固定，上边可变 UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4,//视图高度可变 UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5//与父视图上边间距固定，下边可变&#125;; 下面我们通过效果来看这些属性的作用： 先创建两个view，为了区分，设置不同的背景色： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(20, 40, 200, 200)]; view1.backgroundColor=[UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(10, 10, 100, 100)]; view2.backgroundColor=[UIColor greenColor]; [view1 addSubview:view2]; [self.view addSubview:view1];&#125; 设置view2的自动布局属性如下： 1 view2.autoresizingMask=UIViewAutoresizingFlexibleBottomMargin; 这时的效果如下： 改变view1的frame如下： 1UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(20, 40, 300, 300)]; 效果如下： 这时view2的下边距离相对父视图是可变的。 设置如下： 1 view2.autoresizingMask=UIViewAutoresizingFlexibleHeight; 效果如下： 可以看出，这时子视图的高度是随父视图变化而自动改变的。 如下设置： 1view2.autoresizingMask=UIViewAutoresizingFlexibleLeftMargin; 效果如下： 这时子视图的左边是随父视图变化而可变的。 同理，UIViewAutoresizingFlexibleRightMargin将使子视图右边与父视图的距离可变。 UIViewAutoresizingFlexibleTopMargin将使子视图上边与父视图距离可变。UIViewAutoresizingFlexibleWidth将使子视图的宽度可变。 注意：这些自动布局的属性是可以叠加的，比如保持视图与父视图边距不变，如下设置： 1view2.autoresizingMask=UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight; 效果如下： 二、nib文件中可视化设置自动布局在storyboard中我们可以更加轻松的进行autoresizing自动布局。在view设置栏中有autoresizing这个设置，点中相应的箭头，就是刚才我们探讨的设置选项。并且我们把鼠标放在这个上面的时候，右侧会自动为我们预览效果。 如果你觉得autoresizing很强大，那么你就太容易满足了，autoresizing可以满足大部分简单的自动布局需求，可是它有一个致命的缺陷，它只能设置子视图相对于父视图的变化，却不能精确这个变化的度是多少，因此对于复杂的精准的布局需求，它就力不从心了。但是有一个好消息告诉你，iOS6之后的autolayout自动布局方案，正是解决复杂布局的好帮手，我们在下一遍博客中再进行详细讨论。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发音频播放基础——AVAudioPlayer的应用","slug":"66iOS开发音频播放基础——AVAudioPlayer的应用","date":"2015-05-25T16:00:00.000Z","updated":"2021-06-29T07:04:17.883Z","comments":true,"path":"2015/05/26/66iOS开发音频播放基础——AVAudioPlayer的应用/","link":"","permalink":"http://huishao.cc/2015/05/26/66iOS开发音频播放基础——AVAudioPlayer的应用/","excerpt":"","text":"iOS音频开发——AVAudioPlayer应用AVAudioPlayer是系统提供给我们的一个音频播放类，在AVFoundation框架下，通过它，我们可以实现一个功能强大的音乐播放器。首先，在项目中我们需要导入AVFoundation这个框架。 一、AVAudioPlayer方法与属性详解初始化方法有两种，通过音频的路径或者音频data数据初始化player对象 12- (instancetype)initWithContentsOfURL:(NSURL *)url error:(NSError **)outError;- (instancetype)initWithData:(NSData *)data error:(NSError **)outError; 注意：支持的音频格式有:AAC,ALAC,HE-AAC,iLBC,IMA4,MP3. 准备播放音频，返回值标志是否解析成功，是否可以播放。 1- (BOOL)prepareToPlay; 开始播放音频 1- (BOOL)play; 在一段时间间隔后播放 1- (BOOL)playAtTime:(NSTimeInterval)time; 暂停播放，并且准备好继续播放 1- (void)pause; 停止播放，不再准备好继续播放 1- (void)stop; 获取是否正在播放 1@property(readonly, getter=isPlaying) BOOL playing; 获取当前音频声道数 1@property(readonly) NSUInteger numberOfChannels; 获取当前音频时长 1@property(readonly) NSTimeInterval duration; 获取创建时的音频路径 1@property(readonly) NSURL *url; 获取创建时的音频数据 1@property(readonly) NSData *data; 设置声道偏移量，0为中心，-1为只有左声道，1为只有右声道 1@property float pan; 设置音频音量，取值为0-1之间 1@property float volume; 设置是否可以改变播放速度 1@property BOOL enableRate; 注意:设置这个属性前必须先调用prepareToPlay这个方法。 设置播放速度，1为正常，0.5为一半速度，2.0为2倍速度 1@property float rate; 设置当前播放的时间点 1@property NSTimeInterval currentTime; 设置音频播放循环次数 1@property NSInteger numberOfLoops; 获取音频设置字典 1@property(readonly) NSDictionary *settings; 是否开启仪表计数功能 1@property(getter=isMeteringEnabled) BOOL meteringEnabled; 更新仪表计数的值 1- (void)updateMeters; 获取指定声道音频峰值 1- (float)peakPowerForChannel:(NSUInteger)channelNumber; 获取指定声道音频平均值 1- (float)averagePowerForChannel:(NSUInteger)channelNumber; 二、AVAudioPlayerDelegate方法详解音频播放结束后调用的函数 1- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag; 播放遇到错误时调用的函数 1- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError *)error; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS后台音频播放及锁屏界面显示音频信息用","slug":"67iOS后台音频播放及锁屏界面显示音频信息","date":"2015-05-25T16:00:00.000Z","updated":"2021-06-29T07:45:33.360Z","comments":true,"path":"2015/05/26/67iOS后台音频播放及锁屏界面显示音频信息/","link":"","permalink":"http://huishao.cc/2015/05/26/67iOS后台音频播放及锁屏界面显示音频信息/","excerpt":"","text":"iOS后台播放音乐及用户交互处理后台播放是任何一个音频软件都支持的功能，在上一篇博客中，详细介绍了使用AVAudioPlayer播放音频的方法，这篇博客将对后台的处理做介绍，关于播放与设置音频的博客地址：http://my.oschina.net/u/2340880/blog/420129。 一、设置后台播放iOS设置后台音频播放的步骤非常简单，首先需要在系统设置的plist文件中添加一个键Required background modes，值为App plays audio or streams audio/video using AirPlay，如下： 然后进行如下代码设置： 123 AVAudioSession *session = [AVAudioSession sharedInstance]; [session setActive:YES error:nil]; [session setCategory:AVAudioSessionCategoryPlayback error:nil]; 此时播放音频时我们点击HOME回到主页面，会发现音频不会停，已经实现后台播放的功能。 二、设置后台用户交互在appDelegate中，我们需要先注册响应后台控制： 1[[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; 然后在appDelegate中我们实现如下函数处理后台传递给我们的信息： 12345-(void)remoteControlReceivedWithEvent:(UIEvent *)event&#123; if (event.type==UIEventTypeRemoteControl) &#123; NSLog(@&quot;%ld&quot;,event.subtype); &#125;&#125; event中的subtype是操作类型，我们打开系统桌面抽屉，可以看到如下的控制键： subtype中的枚举便是点击这些控制键后传递给我们的消息，我们可以根据这些消息在app内做逻辑处理。枚举如下，其中只有100之后的在音频控制中对我们有效： 12345678910111213141516171819202122232425262728typedef NS_ENUM(NSInteger, UIEventSubtype) &#123; // available in iPhone OS 3.0 UIEventSubtypeNone = 0, // for UIEventTypeMotion, available in iPhone OS 3.0 UIEventSubtypeMotionShake = 1, //这之后的是我们需要关注的枚举信息 // for UIEventTypeRemoteControl, available in iOS 4.0 //点击播放按钮或者耳机线控中间那个按钮 UIEventSubtypeRemoteControlPlay = 100, //点击暂停按钮 UIEventSubtypeRemoteControlPause = 101, //点击停止按钮 UIEventSubtypeRemoteControlStop = 102, //点击播放与暂停开关按钮(iphone抽屉中使用这个) UIEventSubtypeRemoteControlTogglePlayPause = 103, //点击下一曲按钮或者耳机中间按钮两下 UIEventSubtypeRemoteControlNextTrack = 104, //点击上一曲按钮或者耳机中间按钮三下 UIEventSubtypeRemoteControlPreviousTrack = 105, //快退开始 点击耳机中间按钮三下不放开 UIEventSubtypeRemoteControlBeginSeekingBackward = 106, //快退结束 耳机快退控制松开后 UIEventSubtypeRemoteControlEndSeekingBackward = 107, //开始快进 耳机中间按钮两下不放开 UIEventSubtypeRemoteControlBeginSeekingForward = 108, //快进结束 耳机快进操作松开后 UIEventSubtypeRemoteControlEndSeekingForward = 109,&#125;; 三、设置后台信息显示及锁屏界面设置设置锁屏界面显示信息的原理是通过设置一个系统的字典，当音频开始播放时，系统会自动从这个字典中读取要显示的信息，如果需要动态显示，我们只需要不断更新这个字典即可。首先需要添加&lt;MediaPlayer/MediaPlayer.h&gt;这个头文件。 代码示例如下： 1234567891011121314151617 NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; //设置歌曲题目 [dict setObject:@&quot;题目&quot; forKey:MPMediaItemPropertyTitle]; //设置歌手名 [dict setObject:@&quot;歌手&quot; forKey:MPMediaItemPropertyArtist]; //设置专辑名 [dict setObject:@&quot;专辑&quot; forKey:MPMediaItemPropertyAlbumTitle]; //设置显示的图片 UIImage *newImage = [UIImage imageNamed:@&quot;43.png&quot;]; [dict setObject:[[MPMediaItemArtwork alloc] initWithImage:newImage] forKey:MPMediaItemPropertyArtwork]; //设置歌曲时长 [dict setObject:[NSNumber numberWithDouble:300] forKey:MPMediaItemPropertyPlaybackDuration]; //设置已经播放时长 [dict setObject:[NSNumber numberWithDouble:150] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; //更新字典 [[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:dict]; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美八——网页框架","slug":"65标签之美八——网页框架","date":"2015-05-24T16:00:00.000Z","updated":"2021-06-29T01:59:00.691Z","comments":true,"path":"2015/05/25/65标签之美八——网页框架/","link":"","permalink":"http://huishao.cc/2015/05/25/65标签之美八——网页框架/","excerpt":"","text":"标签之美——网页框架的应用一、框架集框架集用来设置框架的属性，修饰框架的总体效果。 1、框架宽度cols属性用来设置框架的宽度，示例如下： 12345678&lt;body&gt;&lt;frameset cols=&quot;30%,30%,30%,10%&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 其中属性设置的值可以是百分比，可以是固定值，*符号表示除了已经分配后的剩余空间。上面代码中每个html文件设置不同的背景颜色，效果如下： 2、框架高度使用rows属性可是设置框架的高度。其用法和cols属性类似，示例如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 注意：宽度和高度这两个属性，不能同时使用，只能二选一。 3、边框宽度可以通过border属性设置框架边框的宽度，如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot; border=&quot;10&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 4、边框颜色和其他属性类似，通过bordercolor可以设置边框的颜色。 5、设置是否显示边框通过设置frameborder可以显示和隐藏边框，其值可取0或者1。隐藏效果如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot; frameborder=&quot;0&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 二、框架框架和框架集是可以嵌套的。可以在一个框架中继续嵌套框架集。 1、设置框架大小不可调节使用的框架，默认当鼠标点击拉动时是可以调节大小的，可以设置nosize=”nosize”来设置不可调节。 2、设置框架的滚动条scrolling属性可以设置框架是否显示滚动条,可以设置yes或者no。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS多线程编程之三——GCD的应用","slug":"64iOS多线程编程之三——GCD的应用","date":"2015-05-20T16:00:00.000Z","updated":"2021-06-29T01:57:52.855Z","comments":true,"path":"2015/05/21/64iOS多线程编程之三——GCD的应用/","link":"","permalink":"http://huishao.cc/2015/05/21/64iOS多线程编程之三——GCD的应用/","excerpt":"","text":"iOS多线程编程之三——GCD的应用一、引言在软件开发中使用多线程可以大大的提升用户体验度，增加工作效率。iOS系统中提供了多种分线程编程的方法，在前两篇博客都有提及： NSThread类进行多线程编程：http://my.oschina.net/u/2340880/blog/416524。 NSOperation进行多线程操作编程：http://my.oschina.net/u/2340880/blog/416782。 上两个进行多线程编程的机制都是封装于Object-C的类与方法。这篇博客将讨论的Grand Central Dispatch(GCD)机制，则是基于C语言的，相比上面两种机制，GCD更加高效，并且线程有系统管理，会自动运用多核运算。因为这些优势，GCD是apple推荐我们使用的多线程解决方案。 二、GCD的调度机制GCD机制中一个很重要的概念是调度队列，我们对线程的操作实际上是由调度队列完成的。我们只需要将要执行的任务添加到合适的调度队列中即可。 1、调度队列的类型调度队列有三种类型： （1）主队列 其中的任务在主线程中执行，因为其会阻塞主线程，所以这是一个串行的队列。可以通过dispatch_get_main_queue()方法得到。 （2）全局并行队列 队列中任务的执行方式是严格按照先进先出的模式进行了。如果是串行的队列，则当一个任务结束后，才会开启另一个任务，如果是并行队列，则任务的开启顺序是和添加顺序一致的。系统为iOS应用自动创建了四个全局共享的并发队列。使用如下函数获得： dispatch_get_global_queue(long identifier, unsigned long flags); 其中第一个参数是这个队列的id，系统的四个全局队列默认的优先级不同，这个参数可填的定义如下： 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2//优先级最高的全局队列#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0//优先级中等的全局队列#define DISPATCH_QUEUE_PRIORITY_LOW (-2)//优先级低的全局队列#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN//后台的全局队列 优先级最低 这个函数的第二个参数，按照官方文档的说法是有待未来使用，现在我们都填0即可。 （3）自定义队列 上面的两种队列都是系统为我们创建好的，我们只需要获取到他们，将任务添加即可。当然，我们可可以创建我们自己的队列，包括串行的和并行的。使用如下方法创建： 1dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL); 其中，第一个参数是这个队列的名字，第二个参数决定创建的是串行的还是并行的队列。填写DISPATCH_QUEUE_SERIAL或者NULL创建串行队列，填写DISPATCH_QUEUE_CONCURRENT创建并行队列。 2、添加任务到队列中使用dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)函数或者dispatch_async(dispatch_queue_t queue, dispatch_block_t block)函数来同步或者异步的执行任务，示例如下： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; NSLog(@&quot;%@:1&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;%@:2&quot;,[NSThread currentThread]); &#125;);&#125; 打印结果如下： 可以看出第一个任务在主线程中执行，第二个在分线程中执行。 三、队列调度机制的更多技巧通过上面的演示，我们已经可以运用队列进行多线程的执行任务，但是GCD的强大之处远远不止如此。 1、使用队列组如果有这样三个任务，A与B是没有关系的，他们可以并行执行，C必须在A,B结束之后才能执行，当然，实现这样的逻辑并不困难，使用KVO就可以实现，但是使用队列组处理这样的逻辑，代码会更加清晰简单。 可以使用dispatch_group_create()创建一个队列组，使用如下函数将队列添加到队列组中： 123void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 队列组中的队列是异步执行的，示例如下： 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个队列组 dispatch_group_t group=dispatch_group_create(); 创建一个异步队列 dispatch_queue_t queue=dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); //阻塞线程直到队列任务完成 dispatch_group_wait(group,DISPATCH_TIME_FOREVER); for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;over:%d&quot;,i); &#125;&#125; 打印出来的信息如下： 可以看出，队列中的任务是异步执行的，并且等待队列组中队列任务全部执行后才执行后面的任务。这样的做法在实际应用中我们很少使用，通常我们会把后续的任务在放在异步中执行，做法如下： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个队列组 dispatch_group_t group=dispatch_group_create(); //创建一个队列 dispatch_queue_t queue=dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //添加队列任务到队列组 dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); //队列组任务执行完后执行的任务 dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;over:%d&quot;,i); &#125; &#125;); for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;Finish:%d&quot;,i); &#125; &#125; 打印信息如下： 可以看出GCD的强大了吧，复杂的任务逻辑关系因为GCD变得十分清晰简单。 2、循环机制一开始我们就提到，GCD相比NSOperation的优势在于多核心的应用，更深得挖掘出了硬件的性能。GCD在多核方面的一个明显的特点就是循环机制。 123 dispatch_apply(10, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t i) &#123; NSLog(@&quot;%@:%zu&quot;,[NSThread currentThread],i); &#125;); 打印结果如下： 可以看出，程序的运行效率又会高许多。 3、消息传递机制dispatch_source_t类型的对象可以用来传递和接受某个消息，然后执行block方法，示例如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个数据对象，DISPATCH_SOURCE_TYPE_DATA_ADD的含义表示数据变化时相加 dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue()); //创建接收数据变化的句柄 dispatch_source_set_event_handler(source, ^&#123; NSLog(@&quot;%lu&quot;,dispatch_source_get_data(source)); &#125;); //启动 dispatch_resume(source); //设置数据 dispatch_source_merge_data(source, 1); //这步执行完之后会执行打印方法&#125; 4、发送和等待信号GCD中还有一个重要的概念是信号量。它的用法法消息的传递有所类似，通过代码来解释： 1234567 //创建一个信号，其中的参数为信号的初始值 dispatch_semaphore_t singer = dispatch_semaphore_create(0); //发送信号，使信号量+1 dispatch_semaphore_signal(singer); //等待信号，当信号量大于0时执行后面的方法，否则等待，第二个参数为等待的超时时长，下面设置的为一直等待 dispatch_semaphore_wait(singer, DISPATCH_TIME_FOREVER); NSLog(@&quot;123&quot;); 通过发送信号，可以试信号量+1，每次执行过等待信号后，信号量会-1；如此，我们可以很方便的控制不同队列中方法的执行流程。 5、挂起和开启任务队列GCD还提供了暂停与开始任务的方法，使用 void dispatch_suspend(dispatch_object_t object); 可以将队列或者队列组进行暂时的挂起，使用 void dispatch_resume(dispatch_object_t object); 将队列或者队列组重新开启。 需要注意的是，暂停队列时，队列中正在执行的任务并不会被中断，会挂起未开启的任务。 四、关于内存管理GCD虽然是基于C语言封装的框架，使用了面向对象的思想。因此，它的内存管理是需要我们注意的，不论是ARC或者MRC，我们都应该手动去处理这些对象。还好，GCD的内存管理思路和Object—C是兼容的，我们使用dispatch_retain()和dispatch_release()来将引用对象的计数进行加减。这一点十分重要，切记切记。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美七——为网页添加音乐","slug":"63标签之美七——为网页添加音乐","date":"2015-05-19T16:00:00.000Z","updated":"2021-06-29T01:56:51.181Z","comments":true,"path":"2015/05/20/63标签之美七——为网页添加音乐/","link":"","permalink":"http://huishao.cc/2015/05/20/63标签之美七——为网页添加音乐/","excerpt":"","text":"标签之美——为网页添加音乐一、添加音乐为网页添加音乐可以使用这个标签。其用法和插入图片类似。 标签的几个属性设置如下： src：音频路径 autostart：可是设置为ture或者false，代表是否自动播放。 loop：设置是否循环播放 hidden：是否隐藏播放界面 二、插入背景音乐使用标签插入背景音乐，其中插入路径的写法和插入图片类似。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS多线程编程之二——NSOperation与NSOperationQueue","slug":"62iOS多线程编程之二——NSOperation与NSOperationQueue","date":"2015-05-18T16:00:00.000Z","updated":"2021-06-29T01:55:36.085Z","comments":true,"path":"2015/05/19/62iOS多线程编程之二——NSOperation与NSOperationQueue/","link":"","permalink":"http://huishao.cc/2015/05/19/62iOS多线程编程之二——NSOperation与NSOperationQueue/","excerpt":"","text":"iOS多线程编程之二——NSOperation与NSOperationQueue一、NSOperation解析NSOperation是基于Objective-C封装的一套管理与执行线程操作的类。这个类是一个抽象类，通常情况下，我们会使用NSInvocationOperation和NSBlockOperation这两个子类进行多线程的开发，当然我们也可以写继承于NSOperation的类，封装我们自己的操作类。 1、NSOperation抽象类中提供的逻辑方法操作开始执行 1- (void)start; 在子类中可以重写这个方法，实现执行的方法 1- (void)main; 取消执行 1- (void)cancel; 获取当操作状态的几个属性 12345@property (readonly, getter=isCancelled) BOOL cancelled;//当前操作是否取消执行@property (readonly, getter=isExecuting) BOOL executing;//当前操作是否正在执行@property (readonly, getter=isFinished) BOOL finished;//当前操作是否执行结束@property (readonly, getter=isAsynchronous) BOOL asynchronous;//当前操作是否在异步线程中@property (readonly, getter=isReady) BOOL ready;//当前操作是否已经准备好 阻塞当前线程直到操作完成 1- (void)waitUntilFinished; 设置在操作队列中的优先级 1@property NSOperationQueuePriority queuePriority; 其中NSOperationQueuePriority的枚举如下： 1234567typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L,//优先级很低 NSOperationQueuePriorityLow = -4L,//优先级低 NSOperationQueuePriorityNormal = 0,//优先级普通 NSOperationQueuePriorityHigh = 4,//优先级高 NSOperationQueuePriorityVeryHigh = 8//优先级非常高&#125;; 设置操作完成后的回调block 1@property (copy) void (^completionBlock)(void); 设置操作的优先级 1@property double threadPriority; 设置操作的名称 1@property (copy) NSString *name; 2、带block的操作类实例——NSBlockOperationNSBlockOperation是NSOperation的一个子类，其可以异步的执行多个block，当所有的block都完成时，这个操作才算完成。 初始化方法： 1+ (instancetype)blockOperationWithBlock:(void (^)(void))block; 在操作中添加block 1- (void)addExecutionBlock:(void (^)(void))block; 添加进去的block的数组 1@property (readonly, copy) NSArray *executionBlocks; 示例如下： 1234567891011NSBlockOperation * opera = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;]; [opera addExecutionBlock:^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;]; [opera start]; 打印情况如下，可以看出，两个block块的执行是异步的： 3、使用NSInvocationOperation调用方法根据选择器创建一个对象 1- (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(id)arg; 通过Invocation创建一个对象 1- (instancetype)initWithInvocation:(NSInvocation *)inv; 这个类执行的操作是与调用它的线程同步的，示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSInvocationOperation * operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(log) object:nil]; [operation start]; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;-(void)log&#123; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 通过打印结果可以看出其执行的同步性。 二、操作之间的依赖关系依赖关系和优先级的作用很像，却也不同。如果一个操作A依赖于另一个操作B，那么只有当B操作完成后，A操作才会执行。操作添加依赖的 添加一个依赖： 1- (void)addDependency:(NSOperation *)op; 删除一个依赖 1- (void)removeDependency:(NSOperation *)op; 原则上说，一个操作对象的依赖可以添加多个，并且当所有依赖都执行完成后才会执行这个操作。 三、NSOperationQueue操作队列NSOperationQueue是操作队列类，通过上面的介绍，我们已经可以理解操作，并且操作默认的执行方式是串行的，尽管NSBlockOperation中的block块间是并行执行的，但其和外部操作依然是串行的。如果将操作放入操作队列中，则默认为并行执行的。 示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSOperationQueue * queue = [[NSOperationQueue alloc]init]; NSInvocationOperation * op1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(log) object:nil]; [queue addOperation:op1]; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125;-(void)log&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 打印信息如下： 可以看出来，队列的操作是在一个新的线程中执行的，并且操作队列之中的操作也都是异步执行的。 在操作队列中添加一个操作任务： 1- (void)addOperation:(NSOperation *)op; 在队列中插入一组操作任务，后面的参数设置是否队列中得任务都执行完成后再执行这一组操作： 1- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 在队列中添加一个block操作 1- (void)addOperationWithBlock:(void (^)(void))block; 获取操作队列中的所有操作的数组 1@property (readonly, copy) NSArray *operations; 获取操作队列中操作的个数 1@property (readonly) NSUInteger operationCount; 设置队列最大并行操作数量 1@property NSInteger maxConcurrentOperationCount; 设置是否暂停队列任务执行 1@property (getter=isSuspended) BOOL suspended; 设置队列名字 1@property (copy) NSString *name; 设置队列的优先级别（iOS8后支持） 1@property NSQualityOfService qualityOfService; 取消队列中所有操作任务 1- (void)cancelAllOperations; 阻塞当前线程，直到队列中所有任务完成 1- (void)waitUntilAllOperationsAreFinished; 获取当前执行的队列 1+ (NSOperationQueue *)currentQueue; 获取主线程中的操作队列 1+ (NSOperationQueue *)mainQueue; 四、队列中操作的执行顺序法则1、决定于依赖关系，只有当这个操作的依赖全部执行完成后，它才会被执行。 2、影响于优先级，优先级高的会先执行。 如有疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS多线程编程之一——NSThread线程管理","slug":"61iOS多线程编程之一——NSThread线程管理","date":"2015-05-18T16:00:00.000Z","updated":"2021-06-28T12:09:56.310Z","comments":true,"path":"2015/05/19/61iOS多线程编程之一——NSThread线程管理/","link":"","permalink":"http://huishao.cc/2015/05/19/61iOS多线程编程之一——NSThread线程管理/","excerpt":"","text":"iOS多线程编程之一——NSThread线程管理NSTread是iOS中进行多线程开发的一个类，其结构逻辑清晰，使用十分方便，但其封装度和性能不高，线程周期，加锁等需要手动处理。 一、NSThread类方法总结获取当前线程 1+ (NSThread *)currentThread; 这个方法通过开启一个新的线程执行选择器方法 1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 线程用法示例如下： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [NSThread detachNewThreadSelector:@selector(log) toTarget:self withObject:nil]; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125;-(void)log&#123; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 运行后的打印信息： 可以清晰的看出来，新启的线程和主线程是异步的。 程序是否是多线程执行 1+ (BOOL)isMultiThreaded; 线程字典，我们可以为特殊的线程设置键值对 1@property (readonly, retain) NSMutableDictionary *threadDictionary; 线程在某个时间执行 1+ (void)sleepUntilDate:(NSDate *)date; 线程在等待一个时间间隔后执行 1+ (void)sleepForTimeInterval:(NSTimeInterval)ti; 结束线程 1+ (void)exit; 设置线程的优先级，取值的范围为0-1，1的优先级最高 12+ (double)threadPriority;+ (BOOL)setThreadPriority:(double)p; 这个属性是iOS8之后的新特性，将优先级更人性化的封装了起来 1@property NSQualityOfService qualityOfService; NSQualityOfService的枚举如下： 123456789101112typedef NS_ENUM(NSInteger, NSQualityOfService) &#123; //刷新UI级别的线程 NSQualityOfServiceUserInteractive = 0x21, //用户请求的无需精确的任务的线程，例如点击加载邮件 NSQualityOfServiceUserInitiated = 0x19, //周期性的任务线程，例如定时刷新 NSQualityOfServiceUtility = 0x11, //后台任务的线程 NSQualityOfServiceBackground = 0x09, //优先级未知的线程，优先级介于UserInteractive和Utility之间 NSQualityOfServiceDefault = -1&#125;; 判断是否是主线程 1+ (BOOL)isMainThread; 获取主线程 1+ (NSThread *)mainThread; 二、属性与成员方法总结初始化方法，选择器可以带一个参数 1- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 线程是否正在执行 1@property (readonly, getter=isExecuting) BOOL executing; 线程是否已经执行结束 1@property (readonly, getter=isFinished) BOOL finished; 线程是否已经取消执行 1@property (readonly, getter=isCancelled) BOOL cancelled; 三、隐式的通过NSThread进行多线程编程NSObject的一个类别中提供了支持多线程的方法，如下： 这个函数指定在主线程执行一个选择器，arg是参数，wait是是否立即执行，如果YES，则会阻塞当前主线程的任务，NO则会等待当前任务结束后执行。 1- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait; 这个函数指定在某个线程执行选择器 1- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; 指定在后台线程中执行选择器 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发进阶——使用导航和附近兴趣点检索","slug":"60iOS原生地图开发进阶——使用导航和附近兴趣点检索","date":"2015-05-17T16:00:00.000Z","updated":"2021-06-25T02:25:06.638Z","comments":true,"path":"2015/05/18/60iOS原生地图开发进阶——使用导航和附近兴趣点检索/","link":"","permalink":"http://huishao.cc/2015/05/18/60iOS原生地图开发进阶——使用导航和附近兴趣点检索/","excerpt":"","text":"iOS原生地图开发进阶——使用导航和附近兴趣点检索iOS中的mapKit框架对国际化的支持非常出色。在前些篇博客中，对这个地图框架的基础用法和标注与覆盖物的添加进行了详细的介绍，这篇博客将介绍两个更加实用的功能的开发：线路导航与兴趣点搜索。前几篇博客的链接如下： 地图基础用法详解：http://my.oschina.net/u/2340880/blog/415360。 添加大头针与自定义标注：http://my.oschina.net/u/2340880/blog/415441。 添加地图覆盖物：http://my.oschina.net/u/2340880/blog/415611。 一、线路导航1、从几个类的关系说起(1)MKPlacemark 一个地点信息类，如下： 1234567@interface MKPlacemark : CLPlacemark &lt;MKAnnotation&gt;//初始化方法，通过给定一个经纬度和地点信息字典- (instancetype)initWithCoordinate:(CLLocationCoordinate2D)coordinate addressDictionary:(NSDictionary *)addressDictionary;//国家编码@property (nonatomic, readonly) NSString *countryCode;@end (2)MKMapItem 地点节点类，包含此节点的许多地点信息，如下： 1234567891011121314151617@interface MKMapItem : NSObject//当前节点的地点信息对象@property (nonatomic, readonly) MKPlacemark *placemark;//是否是当前位置@property (nonatomic, readonly) BOOL isCurrentLocation;//节点名称@property (nonatomic, copy) NSString *name;//电话号码@property (nonatomic, copy) NSString *phoneNumber;//网址@property (nonatomic, strong) NSURL *url;//将当前位置创建为节点+ (MKMapItem *)mapItemForCurrentLocation;//由一个位置信息创建节点- (instancetype)initWithPlacemark:(MKPlacemark *)placemark;@end (3)MKDirectionsRequest 导航请求类 123456789@interface MKDirectionsRequest : NSObject//起点节点- (MKMapItem *)source NS_AVAILABLE(10_9, 6_0);- (void)setSource:(MKMapItem *)source NS_AVAILABLE(10_9, 7_0);//目的地节点- (MKMapItem *)destination NS_AVAILABLE(10_9, 6_0);- (void)setDestination:(MKMapItem *)destination NS_AVAILABLE(10_9, 7_0);@end 这个类还有一些扩展的设置属性： @property (nonatomic) MKDirectionsTransportType transportType; 设置路线检索类型，枚举如下： 12345typedef NS_OPTIONS(NSUInteger, MKDirectionsTransportType) &#123; MKDirectionsTransportTypeAutomobile = 1 &lt;&lt; 0,//适合驾车时导航 MKDirectionsTransportTypeWalking = 1 &lt;&lt; 1,//适合步行时导航 MKDirectionsTransportTypeAny = 0x0FFFFFFF//任何情况&#125;; @property (nonatomic) BOOL requestsAlternateRoutes; 设置是否搜索多条线路 @property (nonatomic, copy) NSDate *departureDate; 设置出发日期 @property (nonatomic, copy) NSDate *arrivalDate; 设置到达日期 （4）MKDirections 从apple服务器获取数据的连接类 123456789101112@interface MKDirections : NSObject//初始化方法- (instancetype)initWithRequest:(MKDirectionsRequest *)request NS_DESIGNATED_INITIALIZER;//开始计算线路信息- (void)calculateDirectionsWithCompletionHandler:(MKDirectionsHandler)completionHandler;//开始计算时间信息- (void)calculateETAWithCompletionHandler:(MKETAHandler)completionHandler;//取消- (void)cancel;//是否正在计算@property (nonatomic, readonly, getter=isCalculating) BOOL calculating;@end (5)MKDirectionsResponse 线路信息结果类 12345@interface MKDirectionsResponse : NSObject@property (nonatomic, readonly) MKMapItem *source;//起点@property (nonatomic, readonly) MKMapItem *destination;//终点@property (nonatomic, readonly) NSArray *routes; //线路规划数组@end (6)MKETResponse 时间信息结果类 123456@interface MKETAResponse : NSObject@property (nonatomic, readonly) MKMapItem *source;//起点@property (nonatomic, readonly) MKMapItem *destination;//终点@property (nonatomic, readonly) NSTimeInterval expectedTravelTime;//耗时@end (7)MKRoute 线路信息类，导航的线路结果是这个类型的对象 12345678910111213@interface MKRoute : NSObject@property (nonatomic, readonly) NSString *name; //线路名称@property (nonatomic, readonly) NSArray *advisoryNotices; //注意事项@property (nonatomic, readonly) CLLocationDistance distance; //距离@property (nonatomic, readonly) NSTimeInterval expectedTravelTime;//耗时@property (nonatomic, readonly) MKDirectionsTransportType transportType; //检索的类型@property (nonatomic, readonly) MKPolyline *polyline; // 线路覆盖物@property (nonatomic, readonly) NSArray *steps; // 线路详情数组@end （8）MKRouteStep 线路详情信息类，线路中每一步的信息都是这个类的对象 123456789101112@interface MKRouteStep : NSObject@property (nonatomic, readonly) NSString *instructions; // 节点信息@property (nonatomic, readonly) NSString *notice; // 注意事项@property (nonatomic, readonly) MKPolyline *polyline; //线路覆盖物@property (nonatomic, readonly) CLLocationDistance distance; // 距离@property (nonatomic, readonly) MKDirectionsTransportType transportType; // 导航类型@end 看到上面如此多的类，你可能会觉得一头雾水，那么不用着急，类虽然繁杂，但他们之间的逻辑非常清晰，下面就通过一个例子来进行线路导航。 2、进行线路导航12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667- (void)viewDidLoad &#123; [super viewDidLoad]; //地图初始化设置 mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(5, 5)); mapView.mapType=MKMapTypeStandard; mapView.delegate=self; [self.view addSubview:mapView]; //导航设置 CLLocationCoordinate2D fromcoor=CLLocationCoordinate2DMake(39.26, 116.3); CLLocationCoordinate2D tocoor = CLLocationCoordinate2DMake(33.33, 113.33); //创建出发点和目的点信息 MKPlacemark *fromPlace = [[MKPlacemark alloc] initWithCoordinate:fromcoor addressDictionary:nil]; MKPlacemark *toPlace = [[MKPlacemark alloc]initWithCoordinate:tocoor addressDictionary:nil]; //创建出发节点和目的地节点 MKMapItem * fromItem = [[MKMapItem alloc]initWithPlacemark:fromPlace]; MKMapItem * toItem = [[MKMapItem alloc]initWithPlacemark:toPlace]; //初始化导航搜索请求 MKDirectionsRequest *request = [[MKDirectionsRequest alloc]init]; request.source=fromItem; request.destination=toItem; request.requestsAlternateRoutes=YES; //初始化请求检索 MKDirections *directions = [[MKDirections alloc]initWithRequest:request]; //开始检索，结果会返回在block中 [directions calculateDirectionsWithCompletionHandler:^(MKDirectionsResponse *response, NSError *error) &#123; if (error) &#123; NSLog(@&quot;error:%@&quot;,error); &#125;else&#123; //提取导航线路结果中的一条线路 MKRoute *route =response.routes[0]; //将线路中的每一步详情提取出来 NSArray * stepArray = [NSArray arrayWithArray:route.steps]; //进行遍历 for (int i=0; i&lt;stepArray.count; i++) &#123; //线路的详情节点 MKRouteStep * step = stepArray[i]; //在此节点处添加一个大头针 MKPointAnnotation * point = [[MKPointAnnotation alloc]init]; point.coordinate=step.polyline.coordinate; point.title=step.instructions; point.subtitle=step.notice; [mapView addAnnotation:point]; //将此段线路添加到地图上 [mapView addOverlay:step.polyline]; &#125; &#125; &#125;]; &#125;//地图覆盖物的代理方法-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKPolylineRenderer *renderer = [[MKPolylineRenderer alloc] initWithPolyline:overlay]; renderer.strokeColor = [UIColor redColor]; renderer.lineWidth = 4.0; return renderer;&#125;//标注的代理方法-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; MKPinAnnotationView * view= [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;anno&quot;]; view.canShowCallout=YES; return view;&#125; 效果如下： 二、附近兴趣点检索兴趣点检索的逻辑和导航线路检索的逻辑相似，直接通过代码来演示： 1234567891011121314151617181920212223 //创建一个位置信息对象，第一个参数为经纬度，第二个为纬度检索范围，单位为米，第三个为经度检索范围，单位为米 MKCoordinateRegion region = MKCoordinateRegionMakeWithDistance(tocoor, 5000, 5000); //初始化一个检索请求对象 MKLocalSearchRequest * req = [[MKLocalSearchRequest alloc]init]; //设置检索参数 req.region=region; //兴趣点关键字 req.naturalLanguageQuery=@&quot;hotal&quot;; //初始化检索 MKLocalSearch * ser = [[MKLocalSearch alloc]initWithRequest:req]; //开始检索，结果返回在block中 [ser startWithCompletionHandler:^(MKLocalSearchResponse *response, NSError *error) &#123; //兴趣点节点数组 NSArray * array = [NSArray arrayWithArray:response.mapItems]; for (int i=0; i&lt;array.count; i++) &#123; MKMapItem * item=array[i]; MKPointAnnotation * point = [[MKPointAnnotation alloc]init]; point.title=item.name; point.subtitle=item.phoneNumber; point.coordinate=item.placemark.coordinate; [mapView addAnnotation:point]; &#125; &#125;]; 效果如下： 如果疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南再续——地图覆盖物的应用","slug":"59iOS原生地图开发指南再续——地图覆盖物的应用","date":"2015-05-15T16:00:00.000Z","updated":"2021-06-25T02:23:37.847Z","comments":true,"path":"2015/05/16/59iOS原生地图开发指南再续——地图覆盖物的应用/","link":"","permalink":"http://huishao.cc/2015/05/16/59iOS原生地图开发指南再续——地图覆盖物的应用/","excerpt":"","text":"iOS原生地图开发指南再续——地图覆盖物的应用一、引言在前两篇博客中，将iOS系统的地图框架MapKit中地图的设置与应用以及关于添加大头针和自定义大头针的相关操作做了详细的介绍。链接如下：http://my.oschina.net/u/2340880/blog/415360、http://my.oschina.net/u/2340880/blog/415441。这篇博客中将进一步讨论关于地图添加覆盖物的使用方法。 二、添加地图覆盖物的逻辑原理地图覆盖物其实就是在地图上画一些东西，例如路径，范围等等。添加地图覆盖物的逻辑原理其实和添加大头针很相似。首先所有可以成为覆盖物的对象必须遵守MKOverlay这个协议，通过 - (void)addOverlay:(id )overlay; 将覆盖物添加在地图上，然后地图会调用代理方法 -(MKOverlayRenderer )mapView:(MKMapView )mapView rendererForOverlay:(id)overlay; 对覆盖物进行绘制，我们可以在这个方法中设置覆盖物，例如线宽，颜色等，注意，必须实现这个方法，覆盖物才会显示。 1、添加折线覆盖物12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //初始化地图对象 MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; //设置地图 _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); //设置代理 _mapView.delegate=self; //下面是C的语法，创建一个结构体数组 CLLocationCoordinate2D *coor; coor = malloc(sizeof(CLLocationCoordinate2D)*5); for (int i=0; i&lt;5; i++) &#123; CLLocationCoordinate2D po = CLLocationCoordinate2DMake(33.23+i*0.01, 113.112); coor[i]=po; &#125; //创建一个折线对象 MKPolyline * line = [MKPolyline polylineWithCoordinates:coor count:5]; [_mapView addOverlay:line]; [self.view addSubview:_mapView];&#125;//覆盖物绘制的代理-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; //折线覆盖物提供类 MKPolylineRenderer * render = [[MKPolylineRenderer alloc]initWithPolyline:overlay]; //设置线宽 render.lineWidth=3; //设置颜色 render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 2、添加圆形覆盖物1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); _mapView.delegate=self; //创建圆形覆盖物对象 MKCircle * cirle = [MKCircle circleWithCenterCoordinate:CLLocationCoordinate2DMake(33.23, 113.122) radius:500]; [_mapView addOverlay:cirle]; [self.view addSubview:_mapView];&#125;-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKCircleRenderer * render=[[MKCircleRenderer alloc]initWithCircle:overlay]; render.lineWidth=3; //填充颜色 render.fillColor=[UIColor greenColor]; //线条颜色 render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 3、添加多边形覆盖物1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); _mapView.delegate=self; CLLocationCoordinate2D *coor; coor = malloc(sizeof(CLLocationCoordinate2D)*6); for (int i=0; i&lt;5; i++) &#123; CLLocationCoordinate2D po = CLLocationCoordinate2DMake(33.23+i*0.01, 113.112+((i/2==0)?0.01:-0.01)); coor[i]=po; &#125; coor[5]=CLLocationCoordinate2DMake(33.23, 113.112); MKPolygon * gon = [MKPolygon polygonWithCoordinates:coor count:6]; [_mapView addOverlay:gon]; [self.view addSubview:_mapView];&#125;-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKPolygonRenderer * render = [[MKPolygonRenderer alloc]initWithPolygon:overlay]; render.lineWidth=3; render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南","slug":"57iOS原生地图开发指南","date":"2015-05-14T16:00:00.000Z","updated":"2021-06-25T02:21:13.139Z","comments":true,"path":"2015/05/15/57iOS原生地图开发指南/","link":"","permalink":"http://huishao.cc/2015/05/15/57iOS原生地图开发指南/","excerpt":"","text":"iOS原生地图开发详解 在上一篇博客中:http://my.oschina.net/u/2340880/blog/414760。对iOS中的定位服务进行了详细的介绍与参数说明，在开发中，地位服务往往与地图框架结合使用，这篇博客主要对iOS官方的地图框架MapKit.framework进行介绍。 一、初始化地图视图与相关属性方法介绍1、初始化地图视图地图视图的展示依赖于MKMapView这个类，这个类继承于UIView，因此和其他View的使用方法类似。在我们需要展现地图的地方： 12345- (void)viewDidLoad &#123; [super viewDidLoad]; MKMapView * mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; [self.view addSubview:mapView];&#125; 运行发现，一张世界地图就在我们的设备上了，apple内置的地图数据是由高德提供的。 2、系统提供的三种地图样式可以通过MKMapView的mapType这个属性设置地图的模式： @property (nonatomic) MKMapType mapType; 枚举如下： 12345typedef NS_ENUM(NSUInteger, MKMapType) &#123; MKMapTypeStandard = 0,//标准式的行政地图(会显示城市，街道等) MKMapTypeSatellite,//标准的卫星地图 MKMapTypeHybrid//混合地图(在卫星图上显示街道等名称)&#125;; 3、设置地图的中心和比例尺在百度地图等第三方地图服务的SDK中，都会提供一个类似zoomLevel比例尺的属性。通过官方的API设置这个属性有些麻烦，但是也更加灵活。首先，设置地图的中心位置和比例尺是通过region这个属性实现的。region结构体如下： 1234typedef struct &#123; CLLocationCoordinate2D center;//地图中心的经纬度 MKCoordinateSpan span;//地图显示的经纬度范围&#125; MKCoordinateRegion; 这个结构体中包含了两个结构体，其中CLLocationCoordinate2D很好理解，就是简单的经纬度，解释如下： 1234typedef struct &#123; CLLocationDegrees latitude;//纬度，北纬为正，南纬为负 CLLocationDegrees longitude;//经度，东经为正，西经为负&#125; CLLocationCoordinate2D; MKCoordinateSpan这个结构体比较复杂，如下： 1234typedef struct &#123; CLLocationDegrees latitudeDelta;//纬度范围 CLLocationDegrees longitudeDelta;//经度范围&#125; MKCoordinateSpan; 这个结构体定义的应该是一个范围，因为北纬南纬加起来180°，所以纬度范围的取值应为0-180。同理，经度范围的取值范围为0-360。 通过上面的介绍，我们举个例子，将北京市设为地图的中心区域，并且比例设置为显示北京大小。通过百度，首先知道北京市界的地理坐标为：北纬39”26’至41”03’，东经115”25’至 117”30’。北京市区坐标为：北纬39.9”，东经116. 3”。代码如下： 1mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(1.8, 2.05)); 运行后可以看到，北京市基本上是在地图中心的，效果如下： 注意：MKCoordinateSpan的显示范围是取决于大的一边的，比如如果我们这样写： 1MKCoordinateSpanMake(1.8, 360); 最后依然会显示整个世界地图。 - (void)setRegion:(MKCoordinateRegion)region animated:(BOOL)animated; 这个方法可以在设置后给地图加上动画效果 @property (nonatomic) CLLocationCoordinate2D centerCoordinate; 设置地图的中心点位置 - (void)setCenterCoordinate:(CLLocationCoordinate2D)coordinate animated:(BOOL)animated; 设置地图的中心点位置，并附带动画效果 4、坐标转换方法- (CGPoint)convertCoordinate:(CLLocationCoordinate2D)coordinate toPointToView:(UIView *)view; 将经纬度转换为视图上的坐标 - (CLLocationCoordinate2D)convertPoint:(CGPoint)point toCoordinateFromView:(UIView *)view; 将视图上的坐标转换为经纬度 - (CGRect)convertRegion:(MKCoordinateRegion)region toRectToView:(UIView *)view; 将地理显示的区域转换为视图上的坐标区域 - (MKCoordinateRegion)convertRect:(CGRect)rect toRegionFromView:(UIView *)view;将视图上的坐标区域转换为地理区域 5、MKMapView常用方法和属性@property (nonatomic, getter=isZoomEnabled) BOOL zoomEnabled; 设置是否允许捏合手势进行地图缩放 @property (nonatomic, getter=isScrollEnabled) BOOL scrollEnabled; 设置是否允许滑动 @property (nonatomic, getter=isRotateEnabled) BOOL rotateEnabled; 设置是否允许旋转地图 @property (nonatomic, getter=isPitchEnabled) BOOL pitchEnabled; 设置是否支持3D效果 @property (nonatomic) BOOL showsPointsOfInterest; 设置是否显示兴趣点，例如学校，医院等 @property (nonatomic) BOOL showsBuildings; 设置是否显示建筑物轮廓，只在标准的地图中有效 @property (nonatomic) BOOL showsUserLocation; 是否显示用户位置 @property (nonatomic) MKUserTrackingMode userTrackingMode; - (void)setUserTrackingMode:(MKUserTrackingMode)mode animated:(BOOL)animated; 设置更新用户位置的模式,当显示用户位置设置为YES，这个方法也设置了后，地图框架为我们直接集成了定位，地图上就会显示我们的位置，模式的枚举如下： 12345typedef NS_ENUM(NSInteger, MKUserTrackingMode) &#123; MKUserTrackingModeNone = 0, // 不跟踪用户位置 MKUserTrackingModeFollow, // 跟踪用户位置 MKUserTrackingModeFollowWithHeading, // 当方向改变时跟踪用户位置&#125; @property (nonatomic, readonly) MKUserLocation *userLocation; 获取用户位置的标注 @property (nonatomic, readonly, getter=isUserLocationVisible) BOOL userLocationVisible; 获取用户位置是否可见 - (void)addAnnotation:(id )annotation; 在地图上添加一个标注 - (void)addAnnotations:(NSArray *)annotations;在地图上添加一组标注- (void)removeAnnotation:(id )annotation; 移除一个标注 - (void)removeAnnotations:(NSArray *)annotations; 移除一组标注 @property (nonatomic, readonly) NSArray *annotations; 获取所有标注数组 - (MKAnnotationView *)viewForAnnotation:(id )annotation; 获取标注的视图 - (MKAnnotationView )dequeueReusableAnnotationViewWithIdentifier:(NSString )identifier; 获取复用的标注 - (void)selectAnnotation:(id )annotation animated:(BOOL)animated; 选中一个标注 - (void)deselectAnnotation:(id )annotation animated:(BOOL)animated; 取消选中一个标注 @property (nonatomic, copy) NSArray *selectedAnnotations; 选中标注的数组 - (void)addOverlay:(id )overlay level:(MKOverlayLevel)level; 添加一个地图覆盖物，level是设置一个层级，枚举如下： 1234typedef NS_ENUM(NSInteger, MKOverlayLevel) &#123; MKOverlayLevelAboveRoads = 0, // 覆盖物位于道路之上 MKOverlayLevelAboveLabels//覆盖物位于标签之上&#125; - (void)addOverlays:(NSArray *)overlays level:(MKOverlayLevel)level; 添加一组地图覆盖物 - (void)removeOverlay:(id )overlay; 移除一个地图覆盖物 - (void)removeOverlays:(NSArray *)overlays; 移除一组地图覆盖物 - (void)insertOverlay:(id )overlay atIndex:(NSUInteger)index level:(MKOverlayLevel)level; 在索引处插入一个地图覆盖物 - (void)insertOverlay:(id )overlay aboveOverlay:(id )sibling; 将一个地图覆盖物插在到某个覆盖物之上 - (void)insertOverlay:(id )overlay belowOverlay:(id )sibling; 将一个地图覆盖物插入到某个覆盖物之下 - (void)exchangeOverlay:(id )overlay1 withOverlay:(id )overlay2; 替换一个地图覆盖物 @property (nonatomic, readonly) NSArray *overlays; 地图覆盖物数组 - (NSArray *)overlaysInLevel:(MKOverlayLevel)level; 层级属性下的东土覆盖物数组 二、MKMapViewDelegate相关方法解读- (void)mapView:(MKMapView *)mapView regionWillChangeAnimated:(BOOL)animated; 地图显示位置将要改变时调用的方法 - (void)mapView:(MKMapView *)mapView regionDidChangeAnimated:(BOOL)animated; 地图显示位置已经改变时调用的方法 - (void)mapViewWillStartLoadingMap:(MKMapView *)mapView; 地图将要加载时调用的方法 - (void)mapViewDidFinishLoadingMap:(MKMapView *)mapView; 地图加载完成时执行的方法 - (void)mapViewDidFailLoadingMap:(MKMapView )mapView withError:(NSError )error; 地图加载失败时执行的方法 - (MKAnnotationView )mapView:(MKMapView )mapView viewForAnnotation:(id )annotation; 渲染标注视图时调用的方法，可以通过这个方法自定义标注视图 - (void)mapView:(MKMapView )mapView didAddAnnotationViews:(NSArray )views; 标注添加完成后调用的方法 - (void)mapView:(MKMapView )mapView didSelectAnnotationView:(MKAnnotationView )view; 选中标注时调用的方法 - (void)mapView:(MKMapView )mapView didDeselectAnnotationView:(MKAnnotationView )view; 取消选中标注时调用的方法 - (void)mapViewWillStartLocatingUser:(MKMapView *)mapView; 将要开始定位用户位置时调用的方法 - (void)mapViewDidStopLocatingUser:(MKMapView *)mapView; 停止定位用户位置时调用的方法 - (void)mapView:(MKMapView )mapView didUpdateUserLocation:(MKUserLocation )userLocation; 更新用户位置时调用的方法 - (void)mapView:(MKMapView )mapView didFailToLocateUserWithError:(NSError )error; 更新用户位置失败时调用的方法 - (void)mapView:(MKMapView )mapView annotationView:(MKAnnotationView )view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState; 标注拖动状态改变调用的方法，MKAnnotationViewDragState的枚举如下： 1234567typedef NS_ENUM(NSUInteger, MKAnnotationViewDragState) &#123; MKAnnotationViewDragStateNone = 0, // 初始状态 MKAnnotationViewDragStateStarting, // 开始拖动时 MKAnnotationViewDragStateDragging, // 正在拖动 MKAnnotationViewDragStateCanceling, // 取消拖动 MKAnnotationViewDragStateEnding // 结束拖动&#125;; - (void)mapView:(MKMapView *)mapView didChangeUserTrackingMode:(MKUserTrackingMode)mode animated:(BOOL)animated; 定位用户位置模式改变时调用的方法 - (MKOverlayView )mapView:(MKMapView )mapView viewForOverlay:(id )overlay; 渲染覆盖物视图时调用的方法，可以自定义覆盖物视图 - (void)mapView:(MKMapView )mapView didAddOverlayViews:(NSArray )overlayViews; 添加完成覆盖物数组执行的方法 备注：在iOS9中，地图类型的枚举又添加了两种： 1234567typedef NS_ENUM(NSUInteger, MKMapType) &#123; MKMapTypeStandard = 0,//标准 MKMapTypeSatellite,//卫星 MKMapTypeHybrid,//混合 MKMapTypeSatelliteFlyover NS_ENUM_AVAILABLE(10_11, 9_0),//立体卫星 MKMapTypeHybridFlyover NS_ENUM_AVAILABLE(10_11, 9_0),//立体混合&#125; NS_ENUM_AVAILABLE(10_9, 3_0) __WATCHOS_PROHIBITED; 注：因篇幅限制，关于系统大头针和自定义标注的应用、地图覆盖物的应用将在下一篇博客中讨论。 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南续——大头针与自定义标注","slug":"58iOS原生地图开发指南续——大头针与自定义标注","date":"2015-05-14T16:00:00.000Z","updated":"2021-06-25T02:22:30.328Z","comments":true,"path":"2015/05/15/58iOS原生地图开发指南续——大头针与自定义标注/","link":"","permalink":"http://huishao.cc/2015/05/15/58iOS原生地图开发指南续——大头针与自定义标注/","excerpt":"","text":"iOS原生地图开发指南续——大头针与自定义标注在上一篇博客中http://my.oschina.net/u/2340880/blog/415360系统总结了iOS原生地图框架MapKit中主体地图的设置与应用。这篇是上一篇的一个后续，总结了系统的大头针视图以及自定义标注视图的方法。 一、先来认识一个协议MKAnnotation官方文档告诉我们，所有标注的类必须遵守这个协议。所以可以了解，标注这个概念在逻辑属性和视图上是分开的。先来看下这个协议声明了哪些方法： 123456789@protocol MKAnnotation &lt;NSObject&gt;@property (nonatomic, readonly) CLLocationCoordinate2D coordinate;//地理坐标位置@optional@property (nonatomic, readonly, copy) NSString *title;//标题@property (nonatomic, readonly, copy) NSString *subtitle;//副标题//拖动时调用- (void)setCoordinate:(CLLocationCoordinate2D)newCoordinate;@end 二、创建一个系统标注大头针123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化地图 mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; //设置代理 mapView.delegate=self; //设置位置 mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(1.8, 1)); mapView.mapType=MKMapTypeStandard; //初始化一个大头针类 MKPointAnnotation * ann = [[MKPointAnnotation alloc]init]; //设置大头针坐标 ann.coordinate=CLLocationCoordinate2DMake(39.26, 116.3); ann.title=@&quot;我&quot;; ann.subtitle=@&quot;看这里&quot;; [mapView addAnnotation:ann]; [self.view addSubview:mapView];&#125; 效果如下： 重绘大头针视图，大头针渲染时会调用地图代理的方法，我们可以重写这个方法进行大头针的重绘，来更改其颜色： 123456-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; //创建一个系统大头针对象 MKPinAnnotationView * view = [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;pin&quot;]; view.pinColor=MKPinAnnotationColorGreen;//设置颜色为绿色 return view;&#125; 效果如下： MKAnnotationView是标注的视图类，一会我们通过它来自定义我们自己的标注，先来看MKPinAnnotationView这个类，这个类继承于MKAnnotationView，是一个大头针视图类。这个类根简单，只有一下两个属性： @property (nonatomic) MKPinAnnotationColor pinColor; 设置大头针的颜色，枚举如下： 12345typedef NS_ENUM(NSUInteger, MKPinAnnotationColor) &#123; MKPinAnnotationColorRed = 0,//红色 MKPinAnnotationColorGreen,//绿色 MKPinAnnotationColorPurple//紫色&#125;; @property (nonatomic) BOOL animatesDrop; 设置添加时是否显示降落动画 三、自定义标注视图123456789101112131415161718-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; MKAnnotationView * view = [[MKAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;annotation&quot;]; //设置标注的图片 view.image=[UIImage imageNamed:@&quot;保温车0.png&quot;]; //点击显示图详情视图 必须MKPointAnnotation对象设置了标题和副标题 view.canShowCallout=YES; //创建了两个view UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 50, 50)]; view1.backgroundColor=[UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 50)]; view2.backgroundColor=[UIColor blueColor]; //设置左右辅助视图 view.leftCalloutAccessoryView=view1; view.rightCalloutAccessoryView=view2; //设置拖拽 可以通过点击不放进行拖拽 view.draggable=YES; return view;&#125; 效果如下： 四、标注视图类MKAnnotationView的其他常用属性解读@property (nonatomic) CGPoint centerOffset; 视图中心的偏移量 @property (nonatomic) CGPoint calloutOffset; 点击后弹出视图的偏移量 @property (nonatomic, getter=isEnabled) BOOL enabled; 设置是否有效 @property (nonatomic, getter=isHighlighted) BOOL highlighted; 是否高亮状态 @property (nonatomic) CGPoint leftCalloutOffset; 设置左辅助视图的偏移量 @property (nonatomic) CGPoint rightCalloutOffset; 设置右辅助视图的偏移量 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS定位服务的应用","slug":"55IOS定位服务的应用","date":"2015-05-13T16:00:00.000Z","updated":"2021-06-25T02:19:06.778Z","comments":true,"path":"2015/05/14/55IOS定位服务的应用/","link":"","permalink":"http://huishao.cc/2015/05/14/55IOS定位服务的应用/","excerpt":"","text":"iOS定位服务的应用一、授权的申请与设置在IOS8之后，IOS的定位服务做了优化，若要使用定位服务，必须先获取用户的授权。 首先需要在info.plist文件中添加一个键：NSLocationAlwaysUsageDescription或者NSLocationWhenInUseUsageDescription。其中NSLocationAlwaysUsageDescription是要始终使用定位服务，NSLocationWhenInUseUsageDescription是只在前台使用定位服务。 IOS8中CLLocationManager新增的两个新方法： - (void)requestAlwaysAuthorization; - (void)requestWhenInUseAuthorization; 这两个方法对应上面的两个键值，用于在代码中申请定位服务权限。 二、定位服务相关方法IOS的定位服务在CoreLocation.framework框架内，首先引入这个框架： 开启定位服务的代码非常简单，示例如下： 12345678910111213141516171819#import &quot;ViewController.h&quot;#import &lt;CoreLocation/CoreLocation.h&gt;@interface ViewController ()&lt;CLLocationManagerDelegate&gt;//定位服务的代理@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; CLLocationManager* manager = [[CLLocationManager alloc]init];//初始化一个定位管理对象 [manager requestWhenInUseAuthorization];//申请定位服务权限 manager.delegate=self;//设置代理 [manager startUpdatingLocation];//开启定位服务&#125;//定位位置改变后调用的函数-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations&#123; NSLog(@&quot;%@&quot;,locations);&#125;@end CLLocationManager相关方法解读： + (BOOL)locationServicesEnabled; 判断设备是否支持定位服务 + (BOOL)headingAvailable; 判断设备是否支持航向信息功能(海拔，速度，方向等传感器的支持) + (BOOL)significantLocationChangeMonitoringAvailable; 判断设备是否支持更新位置信息 + (BOOL)isMonitoringAvailableForClass:(Class)regionClass; 判断设备是否支持区域检测，regionClass是地图框架中的类。 + (BOOL)isRangingAvailabl; 判断设备是否支持蓝牙测距 + (CLAuthorizationStatus)authorizationStatus; 获得定位服务的授权状态，CLAuthorizationStatus的枚举如下： 1234567typedef NS_ENUM(int, CLAuthorizationStatus) &#123; kCLAuthorizationStatusNotDetermined = 0,//用户还没有做选择 kCLAuthorizationStatusRestricted,//应用拒接使用定位服务 kCLAuthorizationStatusDenied,//用户拒绝授权 kCLAuthorizationStatusAuthorizedAlways,//8.0后可用，始终授权位置服务 kCLAuthorizationStatusAuthorizedWhenInUse,//8.0后可用，只在前台授权位置服务&#125;; @property(assign, nonatomic) CLActivityType activityType; 这个属性用来设置位置更新的模式，枚举如下： 123456typedef NS_ENUM(NSInteger, CLActivityType) &#123; CLActivityTypeOther = 1,//未知模式，默认为此 CLActivityTypeAutomotiveNavigation, //车辆导航模式 CLActivityTypeFitness, //行人模式 CLActivityTypeOtherNavigation //其他交通工具模式&#125;; 模式的应用可以起到节省电量的作用，例如车辆导航模式，当汽车停止时，位置更新服务会暂停。 @property(assign, nonatomic) CLLocationDistance distanceFilter; 设置位置更新的敏感范围，单位为米。 @property(assign, nonatomic) CLLocationAccuracy desiredAccuracy; 设置定位服务的精确度，系统定义好的几个参数如下： kCLLocationAccuracyBestForNavigation;//导航最高精确kCLLocationAccuracyBest;//高精确kCLLocationAccuracyNearestTenMeters;//10米kCLLocationAccuracyHundredMeters;//百米kCLLocationAccuracyKilometer;//千米kCLLocationAccuracyThreeKilometers;//三公里 @property(assign, nonatomic) BOOL pausesLocationUpdatesAutomatically; 设置位置更新是否自动暂停 @property(readonly, nonatomic, copy) CLLocation *location; 最后一次更新的位置信息，只读属性 @property(assign, nonatomic) CLLocationDegrees headingFilter; 相关航向更新的敏感范围 @property(assign, nonatomic) CLDeviceOrientation headingOrientation; 定位航向时的参照方向默认为正北，枚举如下： 123456789typedef NS_ENUM(int, CLDeviceOrientation) &#123; CLDeviceOrientationUnknown = 0,//方向未知 CLDeviceOrientationPortrait,//纵向模式 CLDeviceOrientationPortraitUpsideDown,//纵向倒置模式 CLDeviceOrientationLandscapeLeft,//左向横向模式 CLDeviceOrientationLandscapeRight,//右向横向模式 CLDeviceOrientationFaceUp,//水平屏幕向上模式 CLDeviceOrientationFaceDown//水平屏幕下模式&#125;; @property(readonly, nonatomic, copy) CLHeading *heading; 最后一个定位得到的航向信息 - (void)startUpdatingLocation; 开启定位服务 - (void)stopUpdatingLocation; 停止定位服务 - (void)startUpdatingHeading; 开启航向地理信息服务 - (void)stopUpdatingHeading; 停止航向地理信息服务 三、定位服务代理的相关方法- (void)locationManager:(CLLocationManager )manager didUpdateLocations:(NSArray )locations； 位置更新后调用的方法，数组中是所有定位到的位置信息，最后一个是最新的。 - (void)locationManager:(CLLocationManager )manager didUpdateHeading:(CLHeading )newHeading； 航向信息更新后调用的方法 - (void)locationManager:(CLLocationManager )manager didFailWithError:(NSError )error; 定位异常时调用的方法 四、定位服务获取到的位置对象上面也提到，定位后返回的数组中存放的都是CLLocation对象，这里面有很详细的位置信息，属性如下： @property(readonly, nonatomic) CLLocationCoordinate2D coordinate; 经纬度属性，CLLocationCoordinate2D是一个结构体，如下： 1234typedef struct &#123; CLLocationDegrees latitude;//纬度 CLLocationDegrees longitude;//经度&#125; CLLocationCoordinate2D; @property(readonly, nonatomic) CLLocationDistance altitude; 海拔高度，浮点型 @property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy; 水平方向的容错半径 @property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy; 竖直方向的容错半径 @property(readonly, nonatomic) CLLocationDirection course; 设备前进的方向，取值范围为0-359.9，相对正北方向 @property(readonly, nonatomic) CLLocationSpeed speed; 速度，单位为m/s @property(readonly, nonatomic, copy) NSDate *timestamp; 定位时的时间戳 五、航标定位得到的航标信息对象CLHeading对象的属性信息： @property(readonly, nonatomic) CLLocationDirection magneticHeading; 设备朝向航标方向，0为北磁极。 @property(readonly, nonatomic) CLLocationDirection trueHeading; 设备朝向真实方向，0被地理上的北极 @property(readonly, nonatomic) CLLocationDirection headingAccuracy; 方向偏差 @property(readonly, nonatomic) CLHeadingComponentValue x; x轴的方向值 @property(readonly, nonatomic) CLHeadingComponentValue y; y轴方向值 @property(readonly, nonatomic) CLHeadingComponentValue z; z轴方向值 @property(readonly, nonatomic, copy) NSDate *timestamp; 方向定位时间戳 如有疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美六——滚动字幕的应用","slug":"56标签之美六——滚动字幕的应用","date":"2015-05-13T16:00:00.000Z","updated":"2021-06-25T02:20:03.143Z","comments":true,"path":"2015/05/14/56标签之美六——滚动字幕的应用/","link":"","permalink":"http://huishao.cc/2015/05/14/56标签之美六——滚动字幕的应用/","excerpt":"","text":"标签之美——滚动字幕的应用在网页中，我们经常可以看到一些滚动出现的字幕，按钮等内容。滚动字幕的应用会使网页的内容更加生动紧凑。 1、滚动标签 将滚动显示的文字放在这个标签内，就可以实现滚动字幕。这个标签有一个behavior属性，可以设置滚动方式： scroll：循环滚动，默认的滚动方式 slide：只滚动一次 alternate：左右来回滚动 2、设置字幕背景颜色 123&lt;body&gt;&lt;marquee behavior=&quot;alternate&quot; bgcolor=&quot;#F4070B&quot;&gt;这里是滚动字幕&lt;/marquee&gt;&lt;/body&gt; 3、设置字幕滚动方向：direction属性，可以设置的值有：left，right，up，down。分别表示从右向左滚动，从左向右滚动，从下向上滚动，从上向下滚动。 4、设置字幕的滚动速度 通过设置scrollamount属性来更改字幕的滚动速度，数值越大，速度越快。 5、设置字幕滚动时间间隔 scrolldelay可以来设置字幕的停顿时间间隔，单位是毫秒。效果和速度属性相似。 6、设置滚动次数 loop属性可以设置滚动次数，-1则为循环滚动。 7、设置鼠标滑过时停止滚动，移开时继续滚动： 123&lt;body&gt;&lt;marquee direction=&quot;down&quot; onMouseOver=&quot;this.stop()&quot; onMouseOut=&quot;this.start()&quot;&gt;这里是滚动字幕&lt;/marquee&gt;&lt;/body&gt; 滚动字幕也支持图片的滚动，将文字换位图片即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美五——网页表格的设计","slug":"54标签之美五——网页表格的设计","date":"2015-05-12T16:00:00.000Z","updated":"2021-06-25T02:16:52.682Z","comments":true,"path":"2015/05/13/54标签之美五——网页表格的设计/","link":"","permalink":"http://huishao.cc/2015/05/13/54标签之美五——网页表格的设计/","excerpt":"","text":"标签之美——网页表格的使用通过表格，可以使网页排版更加清晰，形式更加简洁漂亮。 一、表格布局中三个重要的标签1、：表格的开始和结束标签，行列的布局都在标签内。 2、行标签的开始和结束 3、列标签的开始和结束 行标签在列标签的外层，不能单独使用，其中必须至少有一列。示例如下： 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;!--为了便于观察，设置一个边框--&gt;&lt;tr&gt;&lt;td&gt;表格的内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 效果如下： 二、单元格设置的相关标签1、单元格表头 这个标签用来设置表格的表头，作用和列标签相似，只是字体是加黑的。 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 2、表格宽度属性和高度属性width,height 这两个属性可以设置在标签里，也可以设置在和中，作用域会不同。 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th width=&quot;200&quot;&gt;1&lt;/th&gt;&lt;th width=&quot;100&quot;&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 3、设置表格背景图片background 这个属性和尺寸属性用法一样，写在相应的标签里，就是相应的背景图案，设置的是图片的路径。 4、设置表格行列间距cellspacing 1234567&lt;body&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;20&quot;&gt;&lt;tr&gt;&lt;th width=&quot;200&quot;&gt;1&lt;/th&gt;&lt;th width=&quot;100&quot;&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 5、设置单元格内容偏移量 cellpadding 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 三、表格的边框属性和对齐模式灵活的应用边框，可以使表格看起来更加整洁有序。 1、边框宽度属性border 2、边框的颜色属性bordercolor 3、不显示外边框frame=”void” 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;void&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 4、设置frame=”hsides”则只显示上下外边框 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 5、设置frame=”vsides”则只显示左右外边框 6、单独显示边框的frame值分别为： 上：above 下：below 左：lhs 右：rhs 7、设置表格对齐模式： 水平对齐模式：align 表格的align属性可以设置对齐模式，center,left,right分别对应居中，左对齐，右对齐。 垂直对齐模式：valign 和水平对齐模式相似，这个属性的值为：middle，top，bottom对应了中间对齐，上对齐和下对齐。 四、表格行和列的操作1、行的合并：rowspan 12345678910&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;第一行&lt;/td&gt;&lt;td&gt;第一行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第二行&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 2、列的合并colspan 12345678910&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;第一列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 3、表格的标题标签 1234567891011&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot; &gt;&lt;caption&gt;标题&lt;/caption&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;第一列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"分分钟搞定IOS远程消息推送","slug":"53分分钟搞定IOS远程消息推送","date":"2015-05-11T16:00:00.000Z","updated":"2021-06-25T02:13:59.786Z","comments":true,"path":"2015/05/12/53分分钟搞定IOS远程消息推送/","link":"","permalink":"http://huishao.cc/2015/05/12/53分分钟搞定IOS远程消息推送/","excerpt":"","text":"分分钟搞定IOS远程消息推送一、引言IOS中消息的推送有两种方式，分别是本地推送和远程推送，本地推送在http://my.oschina.net/u/2340880/blog/405491这篇博客中有详细的介绍，这里主要讨论远程推送的流程与配置过程。 二、远程推送机制的原理1、从一张很火的图说起搜索IOS远程推送，你总能看到一张如下的流程示意图，因为这张图确实很火，所以我也将它引用在此： 这张图示意的很清晰，大致意思是这样：你的应用服务端将消息发送到apple的APNS服务器，APNS服务器将消息推送到指定的Iphone，最后由Iphone负责将消息推送至你的APP。在此先不说这个过程是如何实现的，仅仅看这个流程，你可能会觉得，在你们服务端和客户端之间增加了一个apple的APNS，不是增加开发者的负担么？其实结果恰恰相反，因为apple对推送的统一管理，使我们开发者的工作变得异常简单。 2、服务端如何连接到客户端的如果你是做android开发的，你一定非常了解长链接与心跳包。事实上，大部分的android应用的推送也确实是通过长链接来实现的。因为android系统的开放性，APP是很容易做到自启动和后台长链接的，而心跳验证，就是始终保证长链接属于接通状态，然后由服务端直接推送消息。如果IOS开发者也采用这种思路，就十分困难了，在IOS中想要保持一个APP服务始终不被系统杀死，我只能说太难了。通过上面的流程图，对比android的推送思路，我们很容易明白，IOS中其实也始终有一个长链接，那就是系统本身，这个长链接始终与APNS服务器相连，然后统一管理所有应用程序的推送。 3、这是IOS推送机制的优势？下面的这些，只是我个人的一些看法。系统并无优劣，优劣在于个人喜好。 1、因为推送的服务端是appleID的验证用户，推送可靠性会高。 2、所有推送消息由APNS统一管理，效率高。 3、在客户端只需系统维护一个长链接，节省了用户流量消耗和手机的性能消耗，并且提高了安全性，使得有恶意推送和流氓软件的几率降低。 三、分分钟让你的APP收到远程推送1、工欲善其事、必先利其器——创建推送证书(1)请求CSR文件 在MAC应用程序中找到钥匙串访问，打开它。 点击选项栏中的钥匙串访问中的证书助理： 选择从证书颁发机构申请证书: 填写电子邮件和名称，选择储存到磁盘，然后继续。 这时，我们存储的地方有了这样一个文件：CertificateSigningRequest.certSigningRequest。 (2)导出密钥文件 打开钥匙串，会发现多了一对密钥，名字就是上面你填写的常用名称。 我们选择专用密钥进行导出，然后设置一个我们自己的密码： 这时候我们又有了一个后缀名为.p12的文件。 (3)创建AppId 到https://developer.apple.com的member Center： 用你付过费的开发者appleID登陆后，选择Certificates: 如果你的项目已经创建了APP id，则可以不用重新创建，但是你创建的APP id必须要支持远程推送。如果还没有创建，点击加号，创建一个： 之后的界面中APP ID有两种类型：Explicit和Wildcard，分别是特殊的和通配的，我们需要推送功能，这个ID不能是通配的，所以我们选择第一个。 这里需要填的的Bundle ID必须和我们App中的一致： 在APP ID的服务设置中，将Push Notification勾选上，点击continue。 之后点击submit，最后点击Done。这时我们的APP IDs列表中会出现我们刚才创建的APP ID。 (4)创建证书 点击我们刚才创建的APP ID，你会看到Push Notification一行为未设定的。我们点击Edit。 在Push Notifications设置里是如下界面，development是开发证书，Production是产品证书，我们现在需要测试，所以用Development证书，上线时要使用Production证书。点击Create Certificate。 接着点击continue，如下界面会让我们选择一个CSR文件，我们第一步创建的文件在这里派上用场了，选择那个文件，点击Generate。 将创建好的证书下载到电脑中： 至此，我们已经有了三个文件了，分别是CSR文件，.p12文件，.cer文件。要将这三个文件放在同一个目录下。.cer文件分为测试和产品两个，需要哪个自行选择。写了这么多，我们的准备工作可算是做完了，不要灰心，其实你的推送工作基本上也就做完了。只是申请过程麻烦了一些，但工程的代码，我们几乎不用怎么配置。 2、兵马未动、粮草先行——服务端进行信息推送的设置(1)处理证书 打开终端cd到我们上面得到的三个文件所在的目录。 在终端执行如下命令： 1$ openssl x509 -in aps_development.cer -inform der -out PushCert.pem aps_development.cer是刚才生成的.cer文件的文件名。会在当前文件夹中生成一个pem文件，这是我们服务端对应的证书。 再执行如下命令： 1$ openssl pkcs12 -nocerts -out PushKey.pem -in key.p12 key.p12是上面生成的.p12文件的文件名。这时终端会让输入密码，这里的密码就是上面我们设置的密钥的密码。输入密码后回车，如果密码正确，会让我们输入新密码(一定切记)，输入两次后，终端会提示成功创建PushKey.pem文件。 最后一步，将我们生成的两个pem文件和成为一个： 1$ cat PushCert.pem PushKey.pem &gt; ck.pem (2)测试证书是否可用 在终端执行下面的命令： 1$ telnet gateway.sandbox.push.apple.com 2195 等一小会，如果终端显示下面的情形，则证书正常。 然后执行如下命令： 1openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert PushChatCert.pem -key PushKey.pem 输入密码后回车显示如下的结果则连接成功： 3、天涯海角、一步之遥——应用程序中的配置在我们项目的AppDelegate中添加如下代码： 12345678910111213141516171819202122- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;double version = [[UIDevice currentDevice].systemVersion doubleValue];//判定系统版本。if(version&gt;=8.0f)&#123; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:(UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound|UIRemoteNotificationTypeAlert) categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; &#125;else&#123; UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes]; &#125;&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; // 处理推送消息 NSLog(@&quot;userinfo:%@&quot;,userInfo); NSLog(@&quot;收到推送消息:%@&quot;,[[userInfo objectForKey:@&quot;aps&quot;] objectForKey:@&quot;alert&quot;]);&#125;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *) error &#123; NSLog(@&quot;Registfail%@&quot;,error);&#125;-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; NSLog(@&quot;%@&quot;,deviceToken);//这里的Token就是我们设备要告诉服务端的Token码&#125; 下面是网上搜的PHP服务端的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php//这里填写设备的Token码$deviceToken = &apos;74314cc9e8f747e2fa96c2c1585c830cdf994de6b453ce9fa1c09ba396b2f9e9&apos;;//这里是密钥密码$passphrase = &apos;abcabc&apos;;//推送的消息$message = &apos;这是一条推送消息&apos;;////////////////////////////////////////////////////////////////////////////////$ctx = stream_context_create();stream_context_set_option($ctx, &apos;ssl&apos;, &apos;local_cert&apos;, &apos;ck.pem&apos;);//ck文件stream_context_set_option($ctx, &apos;ssl&apos;, &apos;passphrase&apos;, $passphrase);// Open a connection to the APNS server$fp = stream_socket_client( &apos;ssl://gateway.sandbox.push.apple.com:2195&apos;, $err, $errstr, 60, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);if (!$fp) exit(&quot;Failed to connect: $err $errstr&quot; . PHP_EOL);echo &apos;Connected to APNS&apos; . PHP_EOL;// Create the payload body$body[&apos;aps&apos;] = array( &apos;alert&apos; =&gt; $message, &apos;sound&apos; =&gt; &apos;default&apos; );// Encode the payload as JSON$payload = json_encode($body);// Build the binary notification$msg = chr(0) . pack(&apos;n&apos;, 32) . pack(&apos;H*&apos;, $deviceToken) . pack(&apos;n&apos;, strlen($payload)) . $payload;// Send it to the server$result = fwrite($fp, $msg, strlen($msg));if (!$result) echo &apos;Message not delivered&apos; . PHP_EOL;else echo &apos;Message successfully delivered&apos; . PHP_EOL;// Close the connection to the serverfclose($fp); ?&gt; 把上面的PHP文件和我们的ck文件放在同一目录下。在终端的当前目录下，执行如下命令： 1$php push.php 如果我们的设备王略正常，就可收到推送的消息了： 四、几点注意1、如果终端发送信息时提示密钥不可访问之类的错误，请检查是否cd到了当前目录，如果还存在问题，将密钥部分从新生成一次。 2、注意PHP代码中的字符为英文字符。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美四——为网页添加绚丽多彩的图像","slug":"52标签之美四——为网页添加绚丽多彩的图像","date":"2015-05-10T16:00:00.000Z","updated":"2021-06-25T02:12:36.825Z","comments":true,"path":"2015/05/11/52标签之美四——为网页添加绚丽多彩的图像/","link":"","permalink":"http://huishao.cc/2015/05/11/52标签之美四——为网页添加绚丽多彩的图像/","excerpt":"","text":"标签之美——图像的使用一、设置网页背景图片12&lt;body background=&quot;1.jpg&quot;&gt;&lt;/body&gt; 这里图片路径的写法和本地超链接的写法是一样的，可以参考上一篇博客中关于本地路径的地方：http://my.oschina.net/u/2340880/blog/412934。 注意：如果图片大小不能充满网页，图片将会被复制平铺。 二、图片标签的应用是图片插入标签。其中图片路径的写法和超链接路径的写法一样。示例如下： 123&lt;body&gt;&lt;img src=&quot;2.png&quot;/&gt;&lt;/body&gt; 效果如下： 标签的alt属性可以为图片添加缺省文字，当图片不存在或者无法显示时，会有提示效果。示例如下： 123&lt;body&gt;&lt;img src=&quot;3.png&quot; alt=&quot;图片不存在&quot;/&gt;&lt;/body&gt; 设置图片的尺寸属性：width，height 123&lt;body&gt;&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;&lt;!--设置宽高为200像素--&gt;&lt;/body&gt; 三、图片的对齐模式align是图片标签的对齐属性，对齐模式有5种属性值，下面一一对其进行介绍： 1、bottom:底部对其1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;bottom&quot;/&gt;的图片 效果如下： 2、left:左部对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;left&quot;/&gt;的图片 3、right:右部对其1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;right&quot;/&gt;的图片 效果如下： 4、middle:居中对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;middle&quot;/&gt;的图片 效果如下： 5、top:上部对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;top&quot;/&gt;的图片 效果如下： 四、设置图片边框和边距通过border属性可以给图片添加边框。属性的值为边框的宽度。 1&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;top&quot; border=&quot;4&quot;/&gt; 效果如下，图片被加上了黑色的边框： 也可以给图片设置一个间距，间距的效果和透明的边框是一样的。 1这里是图片&lt;img src=&quot;1.png&quot; align=&quot;middle&quot; hspace=&quot;20&quot;&gt;内容 其中，hspace是设置水平边框的宽度，还有一个属性vspace是设置垂直边框的宽度，上面代码效果如下： 五、插入视频的相关操作插入视频的原理和图像是一样的，只是路径使用的时dynsrc，可以使用loop属性来设置循环次数，start属性来设置播放方式，这里，只将start属性说明一下，有两种方式，fileopen是网页加载就开始播放，mouseover是鼠标移动到视频位置后开始播放。 1&lt;img dynsrc=&quot;2.wmv&quot; start=&quot;fileopen&quot; loop=&quot;1&quot;&gt; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美三——超链接的嵌入","slug":"51标签之美三——超链接的嵌入","date":"2015-05-09T16:00:00.000Z","updated":"2021-06-25T02:11:41.747Z","comments":true,"path":"2015/05/10/51标签之美三——超链接的嵌入/","link":"","permalink":"http://huishao.cc/2015/05/10/51标签之美三——超链接的嵌入/","excerpt":"","text":"标签之美——超链接标签一、创建超链接通常的超链接有两种方式，一种是链接到另一个文件，另一种是链接到当前文件的某个位置。这两种方式都是通过标签来创建，其中href属性用来指定链接的目标地址。 1、链接到当前页面指定位置被链接的地方需要使用标签的name属性标记，示例如下： 1234&lt;a href=&quot;#last&quot;&gt;链接到本页最后&lt;/a&gt;&lt;!--创建一个超链接--&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=&quot;last&quot;&gt;最后&lt;/a&gt;&lt;!--链接的标记名--&gt;&lt;/body&gt; 2、链接到本地相对路径文件相对路径是以当前\b文件所在的路径为参考的。示例如下： 12345678&lt;body&gt;&lt;!--同级链接：所链接到得文件与当前文件在同一目录下，直接链接文件名即可--&gt;&lt;a href=&quot;nwe.html&quot;&gt;同级链接&lt;/a&gt;&lt;!--下级链接：所链接的文件在当前文件所在目录的子目录下--&gt;&lt;a href=&quot;thml/new.html&quot;&gt;下级链接&lt;/a&gt;&lt;!--上级链接：所链接文件在当前文件所在的上级目录--&gt;&lt;a href=&quot;../new.html&quot;&gt;上级链接&lt;/a&gt;&lt;/body&gt; 3、链接到网址URL这种方式通常会用在友情链接中。例如如下链接到百度： 123&lt;body&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/body&gt; 二、链接的打开方式标签中的target属性可以设置标签的打开方式，一共有四种方式，分别是_blank,_parent,_self,_top。 1、_blank打开方式会让浏览器在新的窗口中打开标签。 2、_parent打开方式在父窗口中打开，当前页面会被覆盖。 3、_self打开方式在当前窗口打开，当前窗口会被覆盖。 4、_top打开方式在最上层窗体中打开。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美二——文本标签","slug":"50标签之美二——文本标签","date":"2015-05-07T16:00:00.000Z","updated":"2021-06-24T11:32:33.037Z","comments":true,"path":"2015/05/08/50标签之美二——文本标签/","link":"","permalink":"http://huishao.cc/2015/05/08/50标签之美二——文本标签/","excerpt":"","text":"标签之美–HTML文本标签属性详解1、使用标题标签 是标题的开始和结束标签，html提供6级标题划分，示例如下： 123&lt;body&gt;&lt;!--设置背景为蓝色--&gt;&lt;h1&gt;这是一级标题&lt;/h1&gt;&lt;h2&gt;这是二级标题&lt;/h&gt;&lt;h6&gt;这是六级标题&lt;/h6&gt;&lt;/body&gt; 2、使用字体标签 用于定义字体，其中详细属性如下： 定义字体大小：size 例如设置其中文字字号为4。 设置字体：face 其中可以填写多个字体名称，浏览器会按顺序寻找。 3、使用文本布局标签 缩进标签，可以让内容布局更加清晰，效果如下： 1234&lt;body&gt;这是没有使用索引的内容&lt;br&gt;&lt;blockquote&gt;这里使用了标签的内容&lt;/blockquote&gt;&lt;/body&gt; 手动格式化布局标签这个标签可以不通过代码进行空格和换行的控制，而是直接将文本中的布局显示。效果如下： 1234&lt;body&gt;&lt;pre&gt;手动的空格 与换行这里是第二行&lt;/pre&gt;&lt;/body&gt; 内联标签，这个标签的作用是将对象内联与某些内容，比如将鼠标悬停时展现的内容，示例如下： 123&lt;body&gt;&lt;span title=&quot;看这里&quot;&gt;标题&lt;/span&gt;&lt;/body&gt; 4、使用字体属性标签 为字体加粗： 使用斜体： 添加下划线： 添加标注： 与下划线形式相同 添加删除标记： 与 添加上标： 添加下表： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS有关内存管理的二三事","slug":"49iOS有关内存管理的二三事","date":"2015-05-06T16:00:00.000Z","updated":"2021-06-24T11:31:41.336Z","comments":true,"path":"2015/05/07/49iOS有关内存管理的二三事/","link":"","permalink":"http://huishao.cc/2015/05/07/49iOS有关内存管理的二三事/","excerpt":"","text":"iOS有关内存管理的二三事一、前引随着移动设备的内存越来越大，程序员也已经度过了为了那一两M的内存在系统的抽丝剥茧的年代，对于JAVA的开发者，对内存更是伸手即取，并且从不关心什么时候还回去。但是，程序的掌控度对程序员来说是至关重要的，任何语言的内存管理机制的初衷也是在有限的空间里完成最精致的逻辑。 二、Xcode工程设置ARCARC是xcode5中引入的自动引用计数，其原理与MRC是一样，只是系统帮助我们添加了retain和release。现在在xcode中新建的项目默认都是ARC的环境，我们可以通过设置其为MRC。 在BuildSettings中搜索ARC： 将下面的参数设置为NO，默认是YES。 这时项目工程的环境就变成了MRC。 三、项目中实现MRC和ARC混编现实中的许多旧的项目，还有一些比较老的第三方库，可能都是采用MRC环境编写的，我们在对其进行扩展或者做新项目的兼容的时候，可以在xcode中对其进行混编。 选择：target-&gt;build phases-&gt;compile sources 如果工程是ARC，要混编MRC的文件，我们选中compiler flags，后面设置为-fno-objc-arc 如果工程是MRC，要混编ARC文件，我们在后面设置-fobjc-arc 四、IOS内存管理机制基本原理无论你是只注重于代码逻辑，将内存交给ARC的新时代程序员，还是依然对apple的信任不足，依然事必躬亲的MRC古板程序员，我想你都应该了解IOS中内存管理的机制，尽管ARC机制很成熟也很可靠，可是依然会有很多应用存在循环应用，内存泄露等问题，要知道，ARC不是万能的，它仅仅只是帮你省去写一些繁琐的代码。 首先，在Object-C中创建对象返回的并不是对象本身，而是一个指针。比如我们使用alloc申请空间，会经常这样做： UIImage * image = [[UIImage alloc]init]; 这里，调用的alloc时，系统将给我们创建的类分配一块内存空间，并返回一个指向这个空间的指针。调用init时对对象进行初始化。如果此时，我们将image这个指针置为nil：image=nil;那样将造成内存泄露，系统分配给image的空间永远无法回收。所以，在我们不需要image这个对象时，我们会使用dealloc方法将其交还给系统：[image dealloc];然而这里，有将产生一个严重的问题，如果我们此时打印image的指针，会发现它现在成了一个危险东西，因为它指向的东西不存在了，而它却依然指向那个地方，这便是很多程序员的噩梦：野指针。为此，我们应该养成一个好习惯，不用的指针置为nil，所有对空指针进行的操作都被认为是安全的。 通过上面的理解，我们发现了一个非常麻烦的地方，我申请了一块内存空间，如果我将指针置空了而没有释放对象，则会内存泄露，如果我提前释放了对象，又很可能会有野指针的出现。并且如果有很多类都引用了这个对象，我甚至的不知道我应该什么时候释放它。因此，Object-C为我们引入了引用计数这种管理内存的方法，任何引用这个对象的地方，都应该让这个对象的引用计数加1。同样，任何不再需要这个对象的地方，也应该使它的引用计数减1，如此一来，对象内存便被统一的管理了起来。 五、内存管理的黄金法则引用计数内存管理的机制是对象的计数，每个对象至少会有一个引用者，如果没有了引用者，对象会被释放。 黄金法则： 1、当你使用alloc,new,copy,mutableCopy创建对象时，你才需要管理他们。 2、你可以使用retain给一个对象增加引用计数。 3、当你不再需要一个对象时，你必须调用release减少其引用计数。 4、你不能释放不属于你的对象的所有权。 上面就是黄金法则的所有内容，我译的可能不到位，总结为一点，也是至关重要的一点就是：谁创建了对象，谁释放掉对象。谁增加了引用计数，谁就在不用时减少计数。alloc，new，copy，mutableCopy，retain这些方法会使引用计数增加，release会使引用计数减少，当计数为0时，系统会调用dealloc释放内存。 六、自动释放池为了方便内存管理，避免我们频繁的调用release方法，Object-C中还为我们引用了一种机制：自动释放池。自动释放池的原理其实只是延时释放，它并没有帮我们做太多的工作。自动释放池的使用方式有两种： 1、MRC时： 123 NSAutoreleasePool * pool = [[NSAutoreleasePool alloc]init];//创建一个自动释放池，系统默认会为我们创建一个，我们也可以创建自己的。 UIImage * image = [[[UIImage alloc]init] autorelease];//在池内创建一些对象，会和最近的自动释放池匹配 [pool release];//这时自动释放池会向池子中的每一个对象发送release消息 2、ARC时： 123 @autoreleasepool &#123; UIImage * image = [[[UIImage alloc]init] autorelease]; &#125; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发遇到的屏幕上下闪出黑边的解决方法","slug":"48iOS开发遇到的屏幕上下闪出黑边的解决方法","date":"2015-05-06T16:00:00.000Z","updated":"2021-06-24T11:30:43.274Z","comments":true,"path":"2015/05/07/48iOS开发遇到的屏幕上下闪出黑边的解决方法/","link":"","permalink":"http://huishao.cc/2015/05/07/48iOS开发遇到的屏幕上下闪出黑边的解决方法/","excerpt":"","text":"iOS开发遇到的屏幕上下闪出黑边的解决方法在IOS开发时，使用的时IOS的模拟器，程序中任何有关坐标的地方也是根据屏幕获取的，而在IOS7的系统上运行，却发现屏幕小了一截，上下各闪出一块黑色区域。后经过查找原因，解决方法如下: 项目的App Icon and Launch Images设置中，本来是这样的： 点击Use Asset Catalog，之后点击Migrate，设置界面如下图模样： 这时在IOS7上就能充满屏幕了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美一——HTML基础元素","slug":"47标签之美一——HTML基础元素","date":"2015-05-05T16:00:00.000Z","updated":"2021-06-24T11:29:30.670Z","comments":true,"path":"2015/05/06/47标签之美一——HTML基础元素/","link":"","permalink":"http://huishao.cc/2015/05/06/47标签之美一——HTML基础元素/","excerpt":"","text":"标签之美–HTML基础标签使用总结HTML是一种标记语言，因此，标签便是HTML的核心，一些基础标签的用法总结如下： 1、 任何HTML文件都会有这样一个标签，标记网页的开始和结束。 2、 头部标签中可以包含许多网页的头信息。 3、 这个标签包含在头部标签内，其内容就是网页显示的标题，比如： 12345&lt;html&gt;&lt;head&gt;&lt;title&gt;我的HTML网页&lt;/title&gt;&lt;/head&gt;&lt;/html&gt; 结果如下： 4、 这是一个设置标签，也叫元信息标签，用于记录和设置网页的一些属性。 其中：name属性可以用来设置关键字，简要内容，网页生成工具及网页的制作者和网页链接查询权限，分别对应的字段为：Keywords、Description、Generator、Author、Robots。 每一个name的属性，后面都要用contect进行解释。对于Robots属性，contect权限的说明如下： all:文件和链接都可以被检索 none:都不可以被检索 index:文件被检索 follow:页面上的链接被检索 noindex：文件不被检索，链接可以被查询 标签的另一个属性值为http-equiv，它将告诉浏览器一些重要的信息，例如编码信息： 1&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--告诉浏览器编码格式--&gt; 定时跳转网页： 1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5;url=http://www.baidu.com&quot;&gt;&lt;!--5S后将跳转到百度网页--&gt; 5、 顾名思义，网页的主体内容写在这个标签里。 下面这些标签都是在标签下的： 6、 段落标签，示例如下： 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;我的HTML网页&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是第一段&lt;/p&gt;&lt;p&gt;这是第二段&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 7、 换行标签，如下： 123&lt;body&gt;这是第一行&lt;br&gt;这是第二行&lt;/body&gt; 8、 水平分割线，示例如下： 123456789&lt;body&gt;这是第一行&lt;hr&gt;这是第二行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第三行&lt;hr width=&quot;200&quot;&gt;&lt;!--设置分割线的长度--&gt;这是第四行&lt;hr width=&quot;100&quot; align=&quot;left&quot;&gt;&lt;!--设置居左--&gt;&lt;/body&gt; 在设置分割线的颜色之前，我们先把HTML中颜色对应的代码总结如下： 123456789&lt;body&gt;这是第一行&lt;hr color=&quot;#0C2DEC&quot;&gt;这是第二行&lt;hr size=&quot;12&quot; color=&quot;#FF0000&quot;&gt;&lt;!--设置颜色--&gt;这是第三行&lt;hr width=&quot;200&quot; color=&quot;#730C0D&quot;&gt;这是第四行&lt;hr width=&quot;100&quot; align=&quot;left&quot; color=&quot;#158C4F&quot;&gt;&lt;/body&gt; 取消分割线阴影： 123456&lt;body&gt;这是第一行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第二行&lt;hr size=&quot;16&quot; noshade&gt;&lt;!--取消分割线阴影--&gt;&lt;/body&gt; 9、 注释标签，任何编程语言都会有注释语句，这个就无需多说了。形式如下： 10、设置网页背景色 标签中有一个属性，可以用来设置网页的背景颜色：bgcolor 123456&lt;body bgcolor=&quot;#002BF8&quot;&gt;&lt;!--设置背景为蓝色--&gt;这是第一行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第二行&lt;hr size=&quot;16&quot; noshade&gt;&lt;!--取消分割线阴影--&gt;&lt;/body&gt; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS通过NSUserDefaults实现简单的应用间数据传递","slug":"46iOS通过NSUserDefaults实现简单的应用间数据传递","date":"2015-05-05T16:00:00.000Z","updated":"2021-06-24T11:27:18.667Z","comments":true,"path":"2015/05/06/46iOS通过NSUserDefaults实现简单的应用间数据传递/","link":"","permalink":"http://huishao.cc/2015/05/06/46iOS通过NSUserDefaults实现简单的应用间数据传递/","excerpt":"","text":"iOS中NSUserDefaults详解NSUserDefaults是用于保存应用程序设置，应用信息等轻量级数据的的一个类，其本质是将数据写为plist文件的形式保存在本地。在IOS中，系统为每一个应用程序都默认创建了一个NSUserDefaults对象。 一、常用方法总结+ (NSUserDefaults *)standardUserDefaults; 获取系统默认创建的应用程序设置表 + (void)resetStandardUserDefaults; 这个方法用于将默认的UserDefaults释放掉，并在下次使用时创建一个新的对象，需要注意的是，调用这个方法后，对原UserDefaults单例进行的KVO监听将失效。 - (instancetype)initWithSuiteName:(NSString *)suitename; 这个方法创建一个新的域：根据名字可以创建一些不同的域，分别存储几套设置信息。 - (id)objectForKey:(NSString *)defaultName; - (void)setObject:(id)value forKey:(NSString *)defaultName; - (void)removeObjectForKey:(NSString *)defaultName; 上面三个方法是对对象存储进行的操作，分别是存储，获取和删除。 - (NSString )stringForKey:(NSString )defaultName; 获取字符串数据 - (NSArray )arrayForKey:(NSString )defaultName; 获取数组数据 - (NSDictionary )dictionaryForKey:(NSString )defaultName; 获取字典数据 - (NSData )dataForKey:(NSString )defaultName; 获取data数据 - (NSArray )stringArrayForKey:(NSString )defaultName; 获取字符串数组数据 - (NSInteger)integerForKey:(NSString *)defaultName; 获取整型数据 - (float)floatForKey:(NSString *)defaultName; 获取浮点型数据 - (double)doubleForKey:(NSString *)defaultName; 获取双精度浮点型数据 - (BOOL)boolForKey:(NSString *)defaultName; 获取布尔诗句 - (NSURL )URLForKey:(NSString )defaultName; 获取网址数据 下面是一些对应的set方法 - (void)setInteger:(NSInteger)value forKey:(NSString *)defaultName; - (void)setFloat:(float)value forKey:(NSString *)defaultName; - (void)setDouble:(double)value forKey:(NSString *)defaultName; - (void)setBool:(BOOL)value forKey:(NSString *)defaultName; - (void)setURL:(NSURL )url forKey:(NSString )defaultName; - (void)registerDefaults:(NSDictionary *)registrationDictionary; 这个方法可以通过字典对数据表进行赋值 - (void)addSuiteNamed:(NSString *)suiteName; 添加一个域 - (void)removeSuiteNamed:(NSString *)suiteName; 移除一个域 - (NSDictionary *)dictionaryRepresentation; 返回系统设置的信息，也是NSGlobalDomain域中的信息。 @property (readonly, copy) NSArray *volatileDomainNames; 返回一个数组，其中是所有不稳定域的名字 - (NSDictionary )volatileDomainForName:(NSString )domainName; 根据名字获取不稳定域中的数据 - (void)setVolatileDomain:(NSDictionary )domain forName:(NSString )domainName; 根据名字设置不稳定域 - (void)removeVolatileDomainForName:(NSString *)domainName; 根据名字移除不稳定域 - (NSDictionary )persistentDomainForName:(NSString )domainName; 根据名字获取稳定域的数据 - (void)setPersistentDomain:(NSDictionary )domain forName:(NSString )domainName; 根据名字设置稳定域 - (void)removePersistentDomainForName:(NSString *)domainName; 根据名字移除稳定域 - (BOOL)synchronize; 对象的同步方法，将内存中的数据写入磁盘。 - (BOOL)objectIsForcedForKey:(NSString *)key; 判断某个键值的数据是否存在 - (BOOL)objectIsForcedForKey:(NSString )key inDomain:(NSString )domain; 判断某个域中某个键值的数据是否存在 注：目前的iOS版本已经不能通过下面的方法在应用间进行传值！！！ 二、三个特殊的域及实现简单的应用间信息传递我们应该了解到，在IOS中，因为沙盒模式的存在，应用间是不允许互相访问数据与传值通信的。这样做的好处显而易见： 1、保证了数据的安全性 2、数据的管理更加简洁 3、当我们删除数据时，只需要将沙盒删除。 在某些需求下，我们可能会需要应用程序间的传值与通信，当然除了通过网络外，对于非常小的数据量，比如验证另一应用从程序是否登录，是否安装并且开启过一次，我们也可以通过NSUserDefaults的一个全局的数据表来实现。 NSUserDefaults的三个特殊的系统域如下： NSString * const NSGlobalDomain; 这个是一个系统级别的全局的域，存储这系统配置信息，我们可以通过它实现应用程序间传值 NSString * const NSArgumentDomain; 这个是在本应用程序内可访问的域，存储着应用程序的信息 NSString * const NSRegistrationDomain; 这个是存放临时数据的域 代码示例如下： 首先在第一个工程中，我们写如下代码运运行一下： 123456789 //获取全局的域 NSDictionary * dic = [[NSUserDefaults standardUserDefaults]persistentDomainForName:NSGlobalDomain]; NSMutableDictionary * temDic = [NSMutableDictionary dictionaryWithDictionary:dic]; [temDic setObject:@&quot;传递的值&quot; forKey:@&quot;应用1&quot;]; //重设 [[NSUserDefaults standardUserDefaults]setPersistentDomain:temDic forName:NSGlobalDomain]; //同步 [NSUserDefaults resetStandardUserDefaults]; NSLog(@&quot;%@&quot;,dic); 打印的结果是许多系统信息。 在第二个工程中，我们这样做： 12 NSDictionary * dic = [[NSUserDefaults standardUserDefaults]persistentDomainForName:NSGlobalDomain]; NSLog(@&quot;%@\\n--------------\\n%@=%@&quot;,dic,@&quot;应用1&quot;,[dic objectForKey:@&quot;应用1&quot;]); 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657582015-05-06 15:48:49.897 321[4100:186745] &#123; AppleITunesStoreItemKinds = ( newsstand, podcast, &quot;itunes-u&quot;, artist, booklet, document, eBook, software, &quot;software-update&quot;, &quot;podcast-episode&quot; ); AppleLanguages = ( en, fr, de, &quot;zh-Hans&quot;, &quot;zh-Hant&quot;, ja, nl, it, es, &quot;es-MX&quot;, ko, pt, &quot;pt-PT&quot;, da, fi, nb, sv, ru, pl, tr, uk, ar, hr, cs, el, he, ro, sk, th, id, ms, &quot;en-GB&quot;, &quot;en-AU&quot;, ca, hu, vi, hi ); AppleLocale = &quot;en_US&quot;; MSVLoggingMasterSwitchEnabledKey = 0; &quot;\\U5e94\\U75281&quot; = &quot;\\U4f20\\U9012\\U7684\\U503c&quot;;&#125;--------------应用1=传递的值 这样，我们就简单实现了应用程序间的传值，但是建议最好不要轻易操作系统的这个域。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中KVC与KVO的应用解析","slug":"45iOS中KVC与KVO的应用解析","date":"2015-05-04T16:00:00.000Z","updated":"2021-06-24T11:26:23.274Z","comments":true,"path":"2015/05/05/45iOS中KVC与KVO的应用解析/","link":"","permalink":"http://huishao.cc/2015/05/05/45iOS中KVC与KVO的应用解析/","excerpt":"","text":"iOS中KVC与KVO的应用解析一、NSKeyValueCoding（KVC）1、从一个小例子引入KVC键值编码是Object-C为我们提供的一种对成员变量赋值的方法。在探讨其方法之前，我们先来看一个小例子： 首先，创建一个数据模型model类： 12345678//.h文件#import &lt;Foundation/Foundation.h&gt;@interface Model : NSObject&#123; @public//将成员变量设置为公有的 以便其他文件有访问权限 NSString * str;&#125;@end 我们在其他文件中有两种方法str进行赋值和取值： 12345 Model * model = [[Model alloc]init]; model-&gt;str=@&quot;312&quot;;//普通方法赋值 [model setValue:@&quot;321&quot; forKey:@&quot;str&quot;];//kvc赋值 NSLog(@&quot;%@&quot;,model-&gt;str);//普通方法取值 NSLog(@&quot;%@&quot;,[model valueForKey:@&quot;str&quot;]);//kvc取值 同样的，对于用@property声明的变量，使用kvc的效果和使用点语法，setter，getter方法的效果是一样的。 2、KVC有关函数方法详解通过上面的例子，我们已经可以简单了解KVC是干什么的了，下面是一些常用方法。 + (BOOL)accessInstanceVariablesDirectly; 这个方法类似一个开关，默认返回为YES，表示支持KVC方式赋值，也可以在子类中将其重写，如果返回为NO，则再进行KVC会抛出异常。 - (id)valueForKey:(NSString *)key; 通过键取值 - (void)setValue:(id)value forKey:(NSString *)key; 通过字符串键给成员变量赋值 - (BOOL)validateValue:(inout id )ioValue forKey:(NSString )inKey error:(out NSError **)outError; 系统默认实现的方法，验证一个键值是否有效 - (NSMutableArray )mutableArrayValueForKey:(NSString )key; 将取到的值放入一个可变数组中 - (NSMutableOrderedSet )mutableOrderedSetValueForKey:(NSString )key NS_AVAILABLE(10_7, 5_0); 将取到的值放入可变的有序集合中 - (NSMutableSet )mutableSetValueForKey:(NSString )key; 将取到的值放入可变的集合中 - (id)valueForKeyPath:(NSString )keyPath;- (void)setValue:(id)value forKeyPath:(NSString )keyPath; 上面这两个方法分别是通过路径赋值与取值，数据结构类似地图，比如在model类中有一个成员变量model2，在Model2类中有一个字符串，我们可以通过如下的方式赋值取值 123456789101112131415161718192021//Model.h#import &quot;Model2.h&quot;@interface Model : NSObject&#123; @public NSString * str; Model2 * model2;&#125;//Model2.h@interface Model2 : NSObject&#123;@public NSString * str2;&#125;@end//其他文件 Model * model = [[Model alloc]init]; Model2 * model2 = [[Model2 alloc]init]; model-&gt;model2=model2; [model setValue:@&quot;123&quot; forKeyPath:@&quot;model2.str2&quot;]; NSLog(@&quot;%@&quot;,[model valueForKeyPath:@&quot;model2.str2&quot;]); - (NSMutableArray )mutableArrayValueForKeyPath:(NSString )keyPath;- (NSMutableOrderedSet )mutableOrderedSetValueForKeyPath:(NSString )keyPath NS_AVAILABLE(10_7, 5_0);- (NSMutableSet )mutableSetValueForKeyPath:(NSString )keyPath; 上面三个方法与前面类似，只是是从路径取值的。 - (id)valueForUndefinedKey:(NSString *)key; 这个方法可以获取没有提前定义的成员变量的值，比如运行时创建的，下面这个方法是给未定义的成员变量赋值 - (void)setValue:(id)value forUndefinedKey:(NSString *)key; 注意：这两个方法默认的实现会抛出异常，子类必须重写才能使用。 - (void)setNilValueForKey:(NSString *)key; 将成员变量置为nil - (NSDictionary )dictionaryWithValuesForKeys:(NSArray )keys; 根据键值获取键值对字典 - (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues; 通过字典对成员变量同意赋值，经常使用 二、NSKeyValueObservingCustomization（KVO）KVO是一种消息监听机制，可以在某个量发生变化的时候将消息传送给监听者，因此广泛用于传值，界面低耦合等逻辑中。KVO机制的核心是以下三个方法： - (void)addObserver:(NSObject )observer forKeyPath:(NSString )keyPath options:(NSKeyValueObservingOptions)options context:(void *)context; 使用这个方法注册一个监听者，参数解释如下： observer：监听者对象 keyPath：监听的参数 options：监听选项 context：参数传递 监听的选项枚举如下： 12345678typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123; NSKeyValueObservingOptionNew = 0x01,//回调的字典中存放新值 NSKeyValueObservingOptionOld = 0x02,//回调的字典中存放旧值 NSKeyValueObservingOptionInitial ,//值改变前进行回调 NSKeyValueObservingOptionPrior//改变前后都进行回调&#125;;//回调字典后面会解释 - (void)removeObserver:(NSObject )observer forKeyPath:(NSString )keyPath context:(void )context ;- (void)removeObserver:(NSObject )observer forKeyPath:(NSString *)keyPath; 这两个方法都是用来移除监听者 - (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary )change context:(void *)context; 这个方法是监听对象数据改变时回调的方法，change是一个字典，字典中根据监听的选项不同，存放不同的值（新或者旧）。context是传递的参数。 代码示例： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. model = [[Model alloc]init]; //添加监听者 [model addObserver:self forKeyPath:@&quot;str&quot; options:NSKeyValueObservingOptionNew context:@&quot;321&quot;]; [model setValue:@&quot;qw&quot; forKey:@&quot;str&quot;];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if ([keyPath isEqualToString:@&quot;str&quot;]) &#123; NSLog(@&quot;%@&quot;,context); &#125;&#125; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UITableViewCell使用详解","slug":"44iOS UITableViewCell使用详解","date":"2015-05-03T16:00:00.000Z","updated":"2021-06-24T11:23:49.828Z","comments":true,"path":"2015/05/04/44iOS UITableViewCell使用详解/","link":"","permalink":"http://huishao.cc/2015/05/04/44iOS UITableViewCell使用详解/","excerpt":"","text":"iOS中UITableViewCell使用详解- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier; Cell的初始化方法，可以设置一个风格和标识符，风格的枚举如下： 123456typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123; UITableViewCellStyleDefault, // 默认风格，自带标题和一个图片视图，图片在左 UITableViewCellStyleValue1, // 只有标题和副标题 副标题在右边 UITableViewCellStyleValue2, // 只有标题和副标题，副标题在左边标题的下边 UITableViewCellStyleSubtitle // 自带图片视图和主副标题，主副标题都在左边，副标题在下&#125;; @property (nonatomic, readonly, retain) UIImageView *imageView; 图片视图，风格允许时才会创建 @property (nonatomic, readonly, retain) UILabel *textLabel; 标题标签 @property (nonatomic, readonly, retain) UILabel *detailTextLabel; 副标题标签 @property (nonatomic, readonly, retain) UIView *contentView; 容纳视图，任何cell的子视图都应该添加在这个上面 @property (nonatomic, retain) UIView *backgroundView; 背景视图 @property (nonatomic, retain) UIView *selectedBackgroundView; 选中状态下的背景视图 @property (nonatomic, retain) UIView *multipleSelectionBackgroundView; 多选选中时的背景视图 @property (nonatomic, readonly, copy) NSString *reuseIdentifier; cell的标识符 - (void)prepareForReuse; 当被重用的cell将要显示时，会调用这个方法，这个方法最大的用武之地是当你自定义的cell上面有图片时，如果产生了重用，图片可能会错乱（当图片来自异步下载时及其明显），这时我们可以重写这个方法把内容抹掉。 @property (nonatomic) UITableViewCellSelectionStyle selectionStyle; cell被选中时的风格，枚举如下： 123456typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123; UITableViewCellSelectionStyleNone,//无 UITableViewCellSelectionStyleBlue,//蓝色 UITableViewCellSelectionStyleGray,//灰色 UITableViewCellSelectionStyleDefault//默认 为蓝色&#125;; @property (nonatomic, getter=isSelected) BOOL selected; 设置cell是否选中状态 @property (nonatomic, getter=isHighlighted) BOOL highlighted; 设置cell是否高亮状态 - (void)setSelected:(BOOL)selected animated:(BOOL)animated; - (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated; 与上面的两个属性对应 @property (nonatomic, readonly) UITableViewCellEditingStyle editingStyle; 获取cell的编辑状态，枚举如下 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone,//无编辑 UITableViewCellEditingStyleDelete,//删除编辑 UITableViewCellEditingStyleInsert//插入编辑&#125;; @property (nonatomic) BOOL showsReorderControl; 设置是否显示cell自带的自动排序控件 注意：要让cell实现拖动排序的功能，除了上面设置为YES，还需实现代理中的如下方法： -(BOOL)tableView:(UITableView )tableView canMoveRowAtIndexPath:(NSIndexPath )indexPath{ return YES; } -(void)tableView:(UITableView )tableView moveRowAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{ } @property (nonatomic) BOOL shouldIndentWhileEditing; 设置编辑状态下是否显示缩进 @property (nonatomic) UITableViewCellAccessoryType accessoryType; 设置附件视图的风格(cell最右侧显示的视图) 枚举如下： 1234567typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123; UITableViewCellAccessoryNone, // 没有视图 UITableViewCellAccessoryDisclosureIndicator, // cell右侧显示一个灰色箭头 UITableViewCellAccessoryDetailDisclosureButton, // 显示详情符号和灰色箭头 UITableViewCellAccessoryCheckmark, // cell右侧显示蓝色对号 UITableViewCellAccessoryDetailButton // cell右侧显示一个详情符号&#125;; @property (nonatomic, retain) UIView *accessoryView; 附件视图 @property (nonatomic) UITableViewCellAccessoryType editingAccessoryType; cell编辑时的附件视图风格 @property (nonatomic, retain) UIView *editingAccessoryView; cell编辑时的附件视图 @property (nonatomic) NSInteger indentationLevel; 设置内容区域的缩进级别 @property (nonatomic) CGFloat indentationWidth; 设置每个级别的缩进宽度 @property (nonatomic) UIEdgeInsets separatorInset; 设置分割线的偏移量 @property (nonatomic, getter=isEditing) BOOL editing; - (void)setEditing:(BOOL)editing animated:(BOOL)animated; 设置是否编辑状态 @property(nonatomic, readonly) BOOL showingDeleteConfirmation; 返回是否目前正在显示删除按钮 - (void)willTransitionToState:(UITableViewCellStateMask)state; cell状态将要转换时调用的函数，可以在子类中重写 - (void)didTransitionToState:(UITableViewCellStateMask)state; cell状态已经转换时调用的函数，可以在子类中重写，状态枚举如下： 12345typedef NS_OPTIONS(NSUInteger, UITableViewCellStateMask) &#123; UITableViewCellStateDefaultMask = 0,//默认状态 UITableViewCellStateShowingEditControlMask = 1 &lt;&lt; 0,//编辑状态 UITableViewCellStateShowingDeleteConfirmationMask = 1 &lt;&lt; 1//确认删除状态&#125;; 注意：下面这些方法已经全部在IOS3.0后被废弃了，虽然还有效果，但是会被警告 @property (nonatomic, copy) NSString *text; 设置标题 @property (nonatomic, retain) UIFont *font; 设置字体 @property (nonatomic) NSTextAlignment textAlignment; 设置对其模式 @property (nonatomic) NSLineBreakMode lineBreakMode; 设置断行模式 @property (nonatomic, retain) UIColor *textColor; 设置字体颜色 @property (nonatomic, retain) UIColor *selectedTextColor; 设置选中状态下的字体颜色 @property (nonatomic, retain) UIImage *image; 设置图片 @property (nonatomic, retain) UIImage *selectedImage; 设置选中状态时的图片 @property (nonatomic) BOOL hidesAccessoryWhenEditing; 设置编辑的时候是否隐藏附件视图 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C中编写省略参数的多参函数","slug":"43Objective-C中编写省略参数的多参函数","date":"2015-05-03T16:00:00.000Z","updated":"2021-06-24T11:22:42.493Z","comments":true,"path":"2015/05/04/43Objective-C中编写省略参数的多参函数/","link":"","permalink":"http://huishao.cc/2015/05/04/43Objective-C中编写省略参数的多参函数/","excerpt":"","text":"Objective-C中编写省略参数的多参数函数引语：在Object-C中，我们会遇到很多像NSLog这样的函数，其中参数的个数不确定，由程序员自由控制，在初始化数组，字典等方面应用广泛，那么，这类的函数是如何实现的呢？我们怎么编写我们自己的省略参数的函数呢？当然，这不是唯一的多参函数的处理方法，你也可以通过一个字典或者数组传递参数。但C为我们提供的这样的一种机制，无疑是最方便的。 一、了解几个概念va_list C语言中定义的一个指针，用于指向当前的参数。 va_start(ap,param) 这个宏是初始化参数列表，其中第一个参数是va_list对象，第二个参数是参数列表的第一个参数。 va_arg(ap, type) 一个用于取出参数的宏，这个宏的第一个参数是va_list对象，第二个参数是要取出的参数类型。 va_end(ap) 这个宏用于关闭取参列表 二、多参函数的取参原理在编写我们自己的多参函数之前，明白函数的取参原理是十分重要的，首先，函数的参数是被放入我们内存的栈段的，而且放入的顺序是从后往前放入，比如如果一个函数参数如下： void func(int a,int b,int c,int d) 那么传递参数的时候参数d先入栈，接着是c、b、a。如此这样，在取参的时候，根据堆栈的取值原则，则取值顺序为a、b、c、d。所以在原理上，只要我们知道第一个参数的地址和每个参数的类型，我们就可以将参数都取出来。而上面介绍的几个宏，就是帮助我们做这些的。 三、声明与实现省略参数的多参函数“…”这个符号就是我们用来实现省略参数函数的符号。例如我们模拟实现一个log函数如下： 12345678910-(void)myLog:(NSString *)str,...&#123;//省略参数的写法 va_list list;//创建一个列表指针对象 va_start(list, str);//进行列表的初始化，str为省略前的第一个参数，及...之前的那个参数 NSString * temStr = str; while (temStr!=nil) &#123;//如果不是nil，则继续取值 NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*);//返回取到的值，并且让指针指向下一个参数的地址 &#125; va_end(list);//关闭列表指针&#125; 注意，调用时，我们必须在参数的最后加上nil这个判断结束的条件： 1[self myLog:@&quot;312&quot;,@&quot;321&quot;, nil];//必须有nil 四、一点补充细心的你可能发现了，这里的nil是我们在调用函数时手动加上的，可是系统的许多函数在我们调用时，系统直接帮我们加上了参数结尾的那个nil，例如 NSArray * array = [NSArray arrayWithObjects:(id), nil] 这是如何做到的呢？我们只需要在函数的声明里加上一个宏，就可以实现这个功能，修改如下： 12345678910-(void)myLog:(NSString *)str,...NS_REQUIRES_NIL_TERMINATION&#123;//这里加上一个宏 va_list list; va_start(list, str); NSString * temStr = str; while (temStr!=nil) &#123; NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*); &#125; va_end(list);&#125; 顾名思义，这个宏的作用就是在结束位置加上我们需要的nil。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中UIActionSheet使用详解","slug":"42IOS中UIActionSheet使用详解","date":"2015-05-02T16:00:00.000Z","updated":"2021-06-24T09:20:29.141Z","comments":true,"path":"2015/05/03/42IOS中UIActionSheet使用详解/","link":"","permalink":"http://huishao.cc/2015/05/03/42IOS中UIActionSheet使用详解/","excerpt":"","text":"IOS中UIActionSheet使用方法详解一、初始化方法- (instancetype)initWithTitle:(NSString )title delegate:(id)delegate cancelButtonTitle:(NSString )cancelButtonTitle destructiveButtonTitle:(NSString )destructiveButtonTitle otherButtonTitles:(NSString )otherButtonTitles, …; 参数说明： title：视图标题 delegate：设置代理 cancelButtonTitle：取消按钮的标题 destructiveButtonTitle：特殊标记的按钮的标题 otherButtonTitles：其他按钮的标题 二、常用方法和属性介绍@property(nonatomic,copy) NSString *title; 设置标题 @property(nonatomic) UIActionSheetStyle actionSheetStyle; 设置风格，枚举如下： 123456typedef NS_ENUM(NSInteger, UIActionSheetStyle) &#123; UIActionSheetStyleAutomatic = -1, UIActionSheetStyleDefault = UIBarStyleDefault, UIActionSheetStyleBlackTranslucent = UIBarStyleBlackTranslucent, UIActionSheetStyleBlackOpaque = UIBarStyleBlackOpaque,&#125;; - (NSInteger)addButtonWithTitle:(NSString *)title; 添加一个按钮，会返回按钮的索引 - (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex; 获取按钮标题 @property(nonatomic,readonly) NSInteger numberOfButtons; 获取按钮数量 @property(nonatomic) NSInteger cancelButtonIndex; 设置取消按钮的索引值 @property(nonatomic) NSInteger destructiveButtonIndex; 设置特殊标记 @property(nonatomic,readonly,getter=isVisible) BOOL visible; 视图当前是否可见 下面是几种弹出方式，会根据风格不同展现不同的方式 - (void)showFromToolbar:(UIToolbar *)view; - (void)showFromTabBar:(UITabBar *)view; - (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated ; - (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated ; - (void)showInView:(UIView *)view; - (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; 使用代码将视图收回 三、UIActionSheet代理方法- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex; 点击按钮时触发的方法 - (void)willPresentActionSheet:(UIActionSheet *)actionSheet; 视图将要弹出时触发的方法 - (void)didPresentActionSheet:(UIActionSheet *)actionSheet; 视图已经弹出式触发的方法 - (void)actionSheet:(UIActionSheet *)actionSheet willDismissWithButtonIndex:(NSInteger)buttonIndex; 点击按钮后，视图将要收回时触发的方法 - (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex; 点击按钮后，视图已经收回时触发的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIAlertView（警告框）方法总结","slug":"41IOS UIAlertView（警告框）方法总结","date":"2015-04-30T16:00:00.000Z","updated":"2021-06-24T09:18:18.869Z","comments":true,"path":"2015/05/01/41IOS UIAlertView（警告框）方法总结/","link":"","permalink":"http://huishao.cc/2015/05/01/41IOS UIAlertView（警告框）方法总结/","excerpt":"","text":"IOS中UIAlertView(警告框)常用方法总结一、初始化方法- (instancetype)initWithTitle:(NSString )title message:(NSString )message delegate:(id //)delegate cancelButtonTitle:(NSString )cancelButtonTitle otherButtonTitles:(NSString )otherButtonTitles, …;这个方法通过设置一个标题，内容，代理和一些按钮的标题创建警告框，代码示例如下： 12 UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;我的警告框&quot; message:@&quot;这是一个警告框&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil]; [alert show]; 效果如下： 注意：如果按钮数超过两个，将会创建成如下样子： 如果按钮数量超出屏幕显示范围，则会创建类似tableView的效果。 二、属性与方法解析标题属性 @property(nonatomic,copy) NSString *title; 内容属性 @property(nonatomic,copy) NSString *message; 添加一个按钮，返回的是此按钮的索引值 - (NSInteger)addButtonWithTitle:(NSString *)title; 返回根据按钮索引按钮标题 - (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex; 获取按钮数量 @property(nonatomic,readonly) NSInteger numberOfButtons; 设置将某一个按钮设置为取消按钮 @property(nonatomic) NSInteger cancelButtonIndex; 返回其他类型按钮第一个的索引值 @property(nonatomic,readonly) NSInteger firstOtherButtonIndex; 警告框是否可见 @property(nonatomic,readonly,getter=isVisible) BOOL visible; 显现警告框 - (void)show; 代码模拟点击按钮消失触发方法 - (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; 设置警告框风格 @property(nonatomic,assign) UIAlertViewStyle alertViewStyle; 风格的枚举如下 123456typedef NS_ENUM(NSInteger, UIAlertViewStyle) &#123; UIAlertViewStyleDefault = 0,//默认风格 UIAlertViewStyleSecureTextInput,//密码输入框风格 UIAlertViewStylePlainTextInput,//普通输入框风格 UIAlertViewStyleLoginAndPasswordInput//账号密码框风格&#125;; 这个方法设置文本输入框的索引 - (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex; 三、UIAlertViewDelegate中的方法点击按钮时触发的方法 - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex; 将要展现警告框时触发的方法 - (void)willPresentAlertView:(UIAlertView *)alertView; 已经展现警告框时触发的方法 - (void)didPresentAlertView:(UIAlertView *)alertView; 警告框将要消失时触发的方法 - (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex; 警告框已经消失时触发的方法 - (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex; 设置是否允许第一个按钮不是取消按钮 - (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS调用系统通讯录","slug":"39iOS调用系统通讯录","date":"2015-04-28T16:00:00.000Z","updated":"2021-06-22T03:16:44.607Z","comments":true,"path":"2015/04/29/39iOS调用系统通讯录/","link":"","permalink":"http://huishao.cc/2015/04/29/39iOS调用系统通讯录/","excerpt":"","text":"iOS调用系统通讯录上一篇博客详细介绍了在IOS开发中，我们如何获取通讯录联系人的信息，即对其进行增删改查的操作：http://my.oschina.net/u/2340880/blog/407347。而在一些开发项目中，如果没有特殊需求，并且我们只是需要一些通讯录信息，并不做修改操作，我们完全可以采取另一种更加方便的方式，直接调用系统的通讯录。 首先，导入这个头文件： 1#import &lt;AddressBookUI/AddressBookUI.h&gt; 注意：需要在项目中链接如下两个库： 只需简单的几句代码，就可以弹出系统的通讯录界面： 123 ABPeoplePickerNavigationController * con = [[ABPeoplePickerNavigationController alloc]init]; con.peoplePickerDelegate=self; [self presentViewController:con animated:YES completion:nil]; 点击联系人后执行的方法，我们只需要实现下面的代理方法即可 123-(void)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person&#123; //person参数就是选择的联系人的引用 具体含义和数据获取，在上一篇博客中有详细介绍&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中调用系统拨打电话与发送短信","slug":"40IOS中调用系统拨打电话与发送短信","date":"2015-04-28T16:00:00.000Z","updated":"2021-06-24T03:04:55.230Z","comments":true,"path":"2015/04/29/40IOS中调用系统拨打电话与发送短信/","link":"","permalink":"http://huishao.cc/2015/04/29/40IOS中调用系统拨打电话与发送短信/","excerpt":"","text":"IOS中调用系统拨打电话发送短信一、调用打电话界面[[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@”tel://%@”,_phoneNumber]]]; 二、发送短消息界面调用系统的发送短信的界面，需要引入以下头文件： #import &lt;MessageUI/MessageUI.h&gt; 系统短信界面的调用很简单，只需下面几句代码： 12345 MFMessageComposeViewController * con = [[MFMessageComposeViewController alloc]init]; if ([MFMessageComposeViewController canSendText]) &#123; con.recipients=@[_phoneNumber];//电话数组 con.messageComposeDelegate=self; [self presentViewController:con animated:YES completion:nil]; 下面将MessageUI的一些常用方法总结如下： + (BOOL)canSendText 判断是否支持发送文字 + (BOOL)canSendSubject; 判断是否支持发送主题信息 + (BOOL)canSendAttachments; 判断是否支持发送附件 + (BOOL)isSupportedAttachmentUTI:(NSString *)uti; 判断是否支持统一标示附件 - (void)disableUserAttachments; 禁止发送附件 @property(nonatomic,copy) NSArray *recipients; 联系人数组，会显示在发送人列表里 @property(nonatomic,copy) NSString *body; 信息主体内容 @property(nonatomic,copy) NSString *subject; 信息标题 @property(nonatomic,copy, readonly) NSArray *attachments; 信息附件数组 只读的 里面是字典 - (BOOL)addAttachmentURL:(NSURL )attachmentURL withAlternateFilename:(NSString )alternateFilename; 根据URL路径和添加附件，返回YES表示添加成功 - (BOOL)addAttachmentData:(NSData )attachmentData typeIdentifier:(NSString )uti filename:(NSString *)filename; 根据Data数据添加附件 - (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result; MFMessageComposeViewControllerDelegate的代理方法，result会传回来一个结果，枚举如下： 12345678enum MessageComposeResult &#123; //取消发送 MessageComposeResultCancelled, //发送成功 MessageComposeResultSent, //发送失败 MessageComposeResultFailed&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS获取通讯录联系人信息","slug":"38iOS获取通讯录联系人信息","date":"2015-04-27T16:00:00.000Z","updated":"2021-06-21T08:41:05.248Z","comments":true,"path":"2015/04/28/38iOS获取通讯录联系人信息/","link":"","permalink":"http://huishao.cc/2015/04/28/38iOS获取通讯录联系人信息/","excerpt":"","text":"iOS获取系统通讯录联系人信息一、权限注册随着apple对用户隐私的越来越重视，IOS系统的权限设置也更加严格，在获取系统通讯录之前，我们必须获得用户的授权。权限申请代码示例如下： 12345678910111213141516171819202122232425262728293031 //这个变量用于记录授权是否成功，即用户是否允许我们访问通讯录 int __block tip=0; //声明一个通讯簿的引用 ABAddressBookRef addBook =nil; //因为在IOS6.0之后和之前的权限申请方式有所差别，这里做个判断 if ([[UIDevice currentDevice].systemVersion floatValue]&gt;=6.0) &#123; //创建通讯簿的引用 addBook=ABAddressBookCreateWithOptions(NULL, NULL); //创建一个出事信号量为0的信号 dispatch_semaphore_t sema=dispatch_semaphore_create(0); //申请访问权限 ABAddressBookRequestAccessWithCompletion(addBook, ^(bool greanted, CFErrorRef error) &#123; //greanted为YES是表示用户允许，否则为不允许 if (!greanted) &#123; tip=1; &#125; //发送一次信号 dispatch_semaphore_signal(sema); &#125;); //等待信号触发 dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); &#125;else&#123; //IOS6之前 addBook =ABAddressBookCreate(); &#125; if (tip) &#123; //做一个友好的提示 UIAlertView * alart = [[UIAlertView alloc]initWithTitle:@&quot;温馨提示&quot; message:@&quot;请您设置允许APP访问您的通讯录\\nSettings&gt;General&gt;Privacy&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil]; [alart show]; return; &#125; 几点注意：1、dispatch_semaphore_t三个相关的操作为 dispatch_semaphore_create 创建一个信号 dispatch_semaphore_signal 发送一个信号 dispatch_semaphore_wait 等待信号触发 dispatch_semaphore_create()创建一个信号，后面可以跟一个参数，表示信号量，当信号量正值时，dispatch_semaphore_wait后面的代码会被执行，否则程序将会一直等待在dispatch_semaphore_wait。 dispatch_semaphore_signal的作用是发送一个信号，会使信号量加1，相对的，dispatch_semaphore_wait执行后会使信号量减1. 2、因为是否被授权是在ABAddressBookRequestAccessWithCompletion的block回调中获取的，所以我们需要在外面做一个线程等待。 二、获取通讯录联系人详细信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 //获取所有联系人的数组 CFArrayRef allLinkPeople = ABAddressBookCopyArrayOfAllPeople(addBook); //获取联系人总数 CFIndex number = ABAddressBookGetPersonCount(addBook); //进行遍历 for (NSInteger i=0; i&lt;number; i++) &#123; //获取联系人对象的引用 ABRecordRef people = CFArrayGetValueAtIndex(allLinkPeople, i); //获取当前联系人名字 NSString*firstName=(__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); //获取当前联系人姓氏 NSString*lastName=(__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); //获取当前联系人中间名 NSString*middleName=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonMiddleNameProperty)); //获取当前联系人的名字前缀 NSString*prefix=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonPrefixProperty)); //获取当前联系人的名字后缀 NSString*suffix=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonSuffixProperty)); //获取当前联系人的昵称 NSString*nickName=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonNicknameProperty)); //获取当前联系人的名字拼音 NSString*firstNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonFirstNamePhoneticProperty)); //获取当前联系人的姓氏拼音 NSString*lastNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonLastNamePhoneticProperty)); //获取当前联系人的中间名拼音 NSString*middleNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonMiddleNamePhoneticProperty)); //获取当前联系人的公司 NSString*organization=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonOrganizationProperty)); //获取当前联系人的职位 NSString*job=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonJobTitleProperty)); //获取当前联系人的部门 NSString*department=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonDepartmentProperty)); //获取当前联系人的生日 NSString*birthday=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonBirthdayProperty)); NSMutableArray * emailArr = [[NSMutableArray alloc]init]; //获取当前联系人的邮箱 注意是数组 ABMultiValueRef emails= ABRecordCopyValue(people, kABPersonEmailProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(emails); j++) &#123; [emailArr addObject:(__bridge NSString *)(ABMultiValueCopyValueAtIndex(emails, j))]; &#125; //获取当前联系人的备注 NSString*notes=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonNoteProperty)); //获取当前联系人的电话 数组 NSMutableArray * phoneArr = [[NSMutableArray alloc]init]; ABMultiValueRef phones= ABRecordCopyValue(people, kABPersonPhoneProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(phones); j++) &#123; [phonerr addObject:(__bridge NSString *)(ABMultiValueCopyValueAtIndex(phones, j))]; &#125; //获取创建当前联系人的时间 注意是NSDate NSDate*creatTime=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonCreationDateProperty)); //获取最近修改当前联系人的时间 NSDate*alterTime=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonModificationDateProperty)); //获取地址 ABMultiValueRef address = ABRecordCopyValue(people, kABPersonAddressProperty); for (int j=0; j&lt;ABMultiValueGetCount(address); j++) &#123; //地址类型 NSString * type = (__bridge NSString *)(ABMultiValueCopyLabelAtIndex(address, j)); NSDictionary * temDic = (__bridge NSDictionary *)(ABMultiValueCopyValueAtIndex(address, j)); //地址字符串，可以按需求格式化 NSString * adress = [NSString stringWithFormat:@&quot;国家:%@\\n省:%@\\n市:%@\\n街道:%@\\n邮编:%@&quot;,[temDic valueForKey:(NSString*)kABPersonAddressCountryKey],[temDic valueForKey:(NSString*)kABPersonAddressStateKey],[temDic valueForKey:(NSString*)kABPersonAddressCityKey],[temDic valueForKey:(NSString*)kABPersonAddressStreetKey],[temDic valueForKey:(NSString*)kABPersonAddressZIPKey]]; &#125; //获取当前联系人头像图片 NSData*userImage=(__bridge NSData*)(ABPersonCopyImageData(people)); //获取当前联系人纪念日 NSMutableArray * dateArr = [[NSMutableArray alloc]init]; ABMultiValueRef dates= ABRecordCopyValue(people, kABPersonDateProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(dates); j++) &#123; //获取纪念日日期 NSDate * data =(__bridge NSDate*)(ABMultiValueCopyValueAtIndex(dates, j)); //获取纪念日名称 NSString * str =(__bridge NSString*)(ABMultiValueCopyLabelAtIndex(dates, j)); NSDictionary * temDic = [NSDictionary dictionaryWithObject:data forKey:str]; [dateArr addObject:temDic]; &#125; 一点扩展：相同的方法，可以获取关联人信息，社交信息，邮箱信息，各种类型的电话信息，字段如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //相关人，组织字段const ABPropertyID kABPersonKindProperty; const CFNumberRef kABPersonKindPerson;const CFNumberRef kABPersonKindOrganization;// 电话相关字段AB_EXTERN const ABPropertyID kABPersonPhoneProperty;AB_EXTERN const CFStringRef kABPersonPhoneMobileLabel;AB_EXTERN const CFStringRef kABPersonPhoneIPhoneLabel AB_EXTERN const CFStringRef kABPersonPhoneMainLabel;AB_EXTERN const CFStringRef kABPersonPhoneHomeFAXLabel;AB_EXTERN const CFStringRef kABPersonPhoneWorkFAXLabel;AB_EXTERN const CFStringRef kABPersonPhoneOtherFAXLabelAB_EXTERN const CFStringRef kABPersonPhonePagerLabel;// 即时聊天信息相关字段AB_EXTERN const ABPropertyID kABPersonInstantMessageProperty; AB_EXTERN const CFStringRef kABPersonInstantMessageServiceKey; AB_EXTERN const CFStringRef kABPersonInstantMessageServiceYahoo;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceJabber;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceMSN;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceICQ;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceAIM;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceQQ AB_EXTERN const CFStringRef kABPersonInstantMessageServiceGoogleTalk;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceSkype;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceFacebook;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceGaduGadu;AB_EXTERN const CFStringRef kABPersonInstantMessageUsernameKey; // 个人网页相关字段AB_EXTERN const ABPropertyID kABPersonURLProperty;AB_EXTERN const CFStringRef kABPersonHomePageLabel; //相关人姓名字段AB_EXTERN const ABPropertyID kABPersonRelatedNamesProperty; AB_EXTERN const CFStringRef kABPersonFatherLabel; // FatherAB_EXTERN const CFStringRef kABPersonMotherLabel; // MotherAB_EXTERN const CFStringRef kABPersonParentLabel; // ParentAB_EXTERN const CFStringRef kABPersonBrotherLabel; // BrotherAB_EXTERN const CFStringRef kABPersonSisterLabel; // SisterAB_EXTERN const CFStringRef kABPersonChildLabel; // ChildAB_EXTERN const CFStringRef kABPersonFriendLabel; // FriendAB_EXTERN const CFStringRef kABPersonSpouseLabel; // SpouseAB_EXTERN const CFStringRef kABPersonPartnerLabel; // PartnerAB_EXTERN const CFStringRef kABPersonAssistantLabel; // AssistantAB_EXTERN const CFStringRef kABPersonManagerLabel; // Manager 三、通讯录“写”的相关操作看到上面读取信息的代码，你可能觉得一阵目炫，其实只是字段比较长，逻辑还是很简单的，同样，写的操作与之类似，创建，修改，删除，是我们对通讯录“写”的常用操作。 1、创建一个联系人123456789101112131415161718192021222324252627 //创建一个联系人引用 ABRecordRef person = ABPersonCreate(); NSString *firstName = @&quot;哈&quot;; NSString *lastName = @&quot;哈&quot;; // 电话号码数组 NSArray *phones = [NSArray arrayWithObjects:@&quot;123&quot;,@&quot;456&quot;,nil]; // 电话号码对应的名称 NSArray *labels = [NSArray arrayWithObjects:@&quot;iphone&quot;,@&quot;home&quot;,nil]; //这里的字段和上面的字段完全相同 // 设置名字属性 ABRecordSetValue(person, kABPersonFirstNameProperty,(__bridge CFStringRef)firstName, NULL); // 设置姓氏属性 ABRecordSetValue(person, kABPersonLastNameProperty, (__bridge CFStringRef)lastName, NULL); // 设置生日属性 ABRecordSetValue(person, kABPersonBirthdayProperty,(__bridge CFDateRef)birthday, NULL); // 字典引用 ABMultiValueRef dic =ABMultiValueCreateMutable(kABMultiStringPropertyType); // 添加电话号码与其对应的名称内容 for (int i = 0; i &lt; [phones count]; i ++) &#123; ABMultiValueIdentifier obj = ABMultiValueAddValueAndLabel(dic,(__bridge CFStringRef)[phones objectAtIndex:i], (__bridge CFStringRef)[labels objectAtIndex:i], &amp;obj); &#125; // 设置phone属性 ABRecordSetValue(person, kABPersonPhoneProperty, dic, NULL); // 将新建的联系人添加到通讯录中 ABAddressBookAddRecord(addBook, person, NULL); // 保存通讯录数据 ABAddressBookSave(addBook, NULL); 2、修改联系人修改联系人的操作就是将获取和添加和在一起，先获取到相应的联系人引用，重设其属性字段即可。 3.删除联系人12345678910111213 //获取所有联系人 NSArray *array = (__bridge NSArray*)ABAddressBookCopyArrayOfAllPeople(addBook); // 遍历所有的联系人 for (id obj in array) &#123; ABRecordRef people = (__bridge ABRecordRef)obj; NSString *firstName = (__bridge NSString*)ABRecordCopyValue(people, kABPersonFirstNameProperty); NSString *lastName = (__bridge NSString*)ABRecordCopyValue(people, kABPersonLastNameProperty); if ([firstName isEqualToString:@&quot;哈&quot;] &amp;&amp;[lastName isEqualToString:@&quot;哈&quot;]) &#123; ABAddressBookRemoveRecord(addBook, people,NULL); &#125; &#125; // 保存修改的通讯录对象 ABAddressBookSave(addBook, NULL); 四、重中之重-关于内存管理上面的代码为了演示方便，创建的全部引用都没有释放，势必是造成内存泄露，在我们用ABAddressBookCreate()创建一个引用对象时，切记无论ARC还MRC，要用CFRelease()进行释放引用，例如上面的例子，我们需要加上这句代码 CFRelease(addBook); 如果你耐心的看到了这里，我想你一定明白了我为什么不在前边的代码里说明这个问题，因为在ARC项目普及的现在，这的确是重中之重。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS代码运行的磨刀石-预编译指令","slug":"37iOS代码运行的磨刀石-预编译指令","date":"2015-04-27T16:00:00.000Z","updated":"2021-06-21T08:37:21.077Z","comments":true,"path":"2015/04/28/37iOS代码运行的磨刀石-预编译指令/","link":"","permalink":"http://huishao.cc/2015/04/28/37iOS代码运行的磨刀石-预编译指令/","excerpt":"","text":"iOS中代码运行的磨刀石–预编译指令所谓预编译，就是程序代码在编译之前，开发工具为我们预先做的一些工作。不要小瞧这些指令，没有它们，我们的代码可能寸步难行。 一、文件包含相关预处理命令#include #include “header” C语言中使用的包含文件的指令””和&lt;&gt;的区别为，””是从当前目录开始寻找文件，&lt;&gt;是从系统库中寻找文件。这两个指令不能使头文件循环引入，也不能重复包含同一个头文件。 #import “header” #import 这两个指令和上面两个作用一样，只是更加智能，智能处理重复包含头文件的问题。 #include_next “header” #include_next 这两个指令是C中的指令，OC也支持，只是很少使用，它的作用是在找到名字匹配的头文件后跳过，寻找下一个相同名字的导入。 二、宏定义宏定义是开发中会经常用到的一个指令了，我们还会将许多简单的函数定义为宏，省去系统压栈的时间，提高代码效率。因为这篇博客的主题是预处理命令，所以宏的用法和高级用法就不再多写了，下次再讨论。 #define 参数1 参数2 定义一个简单的替换宏，不带参数，在预编译阶段，会把所有参数1的地方直接替换为参数2。 #define ADD(x) (x+x) 定义一个带参数的宏，类似带参函数的功能，但也是编译前做简单替换。 三、条件编译条件编译用于判断一个表达式是否成立，成立则进入条件编译。 方式一： #if 表达式 #else #endif 方式二： #if 表达式 #elif 表达式 #endif 方式三: #ifndef 如果没有定义一个宏进行编译 #ifdef 如果定义一个宏进行编译 四、错误，警告的预处理#error 错误 当程序检查到这里时会停止编译，这个命令的作用是在错误的地方禁止编译。 #warning 警告 这个命令并不会影响程序的编译和运行，但是会认为的在这里显示一条警告信息，提醒我们自己。 五、更改文件名和行号在OC中，有一个系统的定义的宏: __LINE__ 这个宏表示当前行的行号，可以打印。 #line number 改变当前行的行号，会影响下面所有的行 #line number “filename” 改变当前行号和编译后的文件名 六、编译器控制指令#pragma 参数 这个预编译指令是最复杂的，用于控制编译器的行为，一般我们开发应用APP是很少用到的，常用的有两种方式： #pragma mark - 信息 为代码加上标注 #pragma message(“信息”) 编译时提示信息 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中JSON数据的解析","slug":"35iOS中JSON数据的解析","date":"2015-04-26T16:00:00.000Z","updated":"2021-06-21T08:23:28.466Z","comments":true,"path":"2015/04/27/35iOS中JSON数据的解析/","link":"","permalink":"http://huishao.cc/2015/04/27/35iOS中JSON数据的解析/","excerpt":"","text":"iOS中JSON数据解析官方为我们提供的解析JSON数据的类是NSJSONSerialization，首先我们先来看下这个类的几个方法： + (BOOL)isValidJSONObject:(id)obj; 判断一个数据对象是否可以转化为JSON数据 + (NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error; 将JSON数据写为NSData数据，其中opt参数的枚举如下，这个参数可以设置，也可以不设置，如果设置，则会输出视觉美观的JSON数据，否则输出紧凑的JSON数据。 123typedef NS_OPTIONS(NSUInteger, NSJSONWritingOptions) &#123; NSJSONWritingPrettyPrinted = (1UL &lt;&lt; 0)&#125; + (id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error; 这个方法是解析中数据的核心方法，data是JSON数据对象，可以设置一个opt参数，具体用法如下： 12345678typedef NS_OPTIONS(NSUInteger, NSJSONReadingOptions) &#123; //将解析的数组和字典设置为可变对象 NSJSONReadingMutableContainers = (1UL &lt;&lt; 0), //将解析数据的子节点创建为可变字符串对象 NSJSONReadingMutableLeaves = (1UL &lt;&lt; 1), //允许解析对象的最上层不是字典或者数组 NSJSONReadingAllowFragments = (1UL &lt;&lt; 2)&#125; + (NSInteger)writeJSONObject:(id)obj toStream:(NSOutputStream *)stream options:(NSJSONWritingOptions)opt error:(NSError **)error; 将JSON数据写入到输出流，返回的是写入流的字节数 + (id)JSONObjectWithStream:(NSInputStream *)stream options:(NSJSONReadingOptions)opt error:(NSError **)error; 从输入流读取JSON数据 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS(CGGeometry)几何类方法总结","slug":"36iOS(CGGeometry)几何类方法总结","date":"2015-04-26T16:00:00.000Z","updated":"2021-06-21T08:32:55.866Z","comments":true,"path":"2015/04/27/36iOS(CGGeometry)几何类方法总结/","link":"","permalink":"http://huishao.cc/2015/04/27/36iOS(CGGeometry)几何类方法总结/","excerpt":"","text":"iOS开发几何类方法总结CGGeometry.h文件是用C语言实现的一个封装了许多常用几何方法的文件。 一、几个常用结构体struct CGPoint { CGFloat x; CGFloat y; }; 定义一个点，设置x坐标和y坐标 struct CGSize { CGFloat width; CGFloat height; }; 定义一个尺寸，设置宽度和高度 struct CGVector { CGFloat dx; CGFloat dy; }; 定义一个二维矢量 struct CGRect { CGPoint origin; CGSize size; }; 定义一个矩形 二、几个系统定义的量const CGPoint CGPointZero 零点，与CGPointMake(0, 0)等效 const CGSize CGSizeZero 零尺寸，与CGSizeMake(0, 0)等效 const CGRect CGRectZero 零矩形，与CGRectMake(0, 0, 0, 0)等效 const CGRect CGRectNull 空矩形，这个和零矩形并不相同，当我们返回两个不相交矩形的交集时，会返回空矩形。 const CGRect CGRectInfinite 无限的矩形 三、一些常用方法CGPoint CGPointMake(CGFloat x, CGFloat y); 创建一个点 CGSize CGSizeMake(CGFloat width, CGFloat height); 创建一个尺寸 CGVectorMake(CGFloat dx, CGFloat dy); 创建一个矢量 CGRect CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height); 创建一个矩形 CGFloat CGRectGetMinX(CGRect rect); 获得矩形最左边的x值 CGFloat CGRectGetMidX(CGRect rect); 获取矩形中点的x值 CGFloat CGRectGetMaxX(CGRect rect); 获取矩形最右端的x值 CGFloat CGRectGetMinY(CGRect rect); 获取矩形最上端的y值 CGFloat CGRectGetMidY(CGRect rect); 获取矩形中心点的y值 CGFloat CGRectGetMaxY(CGRect rect); 获取矩形最下端的y值 CGFloat CGRectGetWidth(CGRect rect); 获取矩形宽度 CGFloat CGRectGetHeight(CGRect rect); 获取矩形高度 bool CGPointEqualToPoint(CGPoint point1, CGPoint point2); 判断两个点是否相等 bool CGSizeEqualToSize(CGSize size1, CGSize size2); 判断两个尺寸是否相等 bool CGRectEqualToRect(CGRect rect1, CGRect rect2); 判断两个矩形是否相等 CGRect CGRectStandardize(CGRect rect); 根据一个矩形创建一个标准的矩形 bool CGRectIsEmpty(CGRect rect); 判断是否为零矩形 CGRectIsNull(CGRect rect); 判断是否为空矩形 bool CGRectIsInfinite(CGRect rect); 判断是否为无限矩形 CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy); 创建一个内嵌的矩形，中心和rect参数的中心一样，dx，dy对应内嵌的宽度和高度 比如：CGRect rect= CGRectInset(CGRectMake(0, 0, 100, 100), 10, 10); 会创建出的rect为（10，10，80，80），dx，dy也可以为负值，则是创建出来的矩形会大于原矩形范围。 CGRect CGRectIntegral(CGRect rect) 根据一个矩形，返回四个参数都是整数的矩形 CGRect CGRectUnion(CGRect r1, CGRect r2); 返回两个矩形的并集 CGRect CGRectIntersection(CGRect r1, CGRect r2); 返回两个矩形的交集，如果没有交集，返回空矩形 CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy); 返回一个矩形，偏移量相对于rect void CGRectDivide(CGRect rect, CGRect slice, CGRect remainder, CGFloat amount, CGRectEdge edge); 这个函数用来分割矩形，参数rect是源矩形，slice和remainder是分割后的两部分矩形，amount是分割线，edge是分割选项。 注意：1、edge是一个宏，定义了分割的方式如下： 12345678910typedef CF_ENUM(uint32_t, CGRectEdge) &#123; //从x的最小处进行垂直分割 CGRectMinXEdge, //从y的最小处进行水平分割 CGRectMinYEdge, //从x最大处进行垂直分割 CGRectMaxXEdge, //从y最大处进行水平分割 CGRectMaxYEdge&#125;; 2、slice和remainder是地址。 3、举例如下，将会分割出两个矩形分别为(40,0,60,100)(0,0,40,100); 1234CGRect rect = CGRectMake(0, 0, 100, 100); CGRect slice ; CGRect remainder; CGRectDivide(rect, &amp;slice, &amp;remainder, 60, CGRectMaxXEdge); bool CGRectContainsPoint(CGRect rect, CGPoint point); 判断点是否在矩形内 bool CGRectContainsRect(CGRect rect1, CGRect rect2); 判断矩形1是否包含矩形2 bool CGRectIntersectsRect(CGRect rect1, CGRect rect2); 判断矩形1和矩形2是否相交 CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point); 返回一个表示点的字典 bool CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point); 将字典转换为点 CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size); 返回一个表示尺寸的字典 bool CGSizeMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGSize *size) ; 将字典转换为尺寸 CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect); 返回一个表示矩形的字典 bool CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect); 将字典转化为矩形 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中使用像素位图(CGImageRef)对图片进行处理","slug":"34iOS中使用像素位图(CGImageRef)对图片进行处理","date":"2015-04-25T16:00:00.000Z","updated":"2021-06-21T05:51:24.579Z","comments":true,"path":"2015/04/26/34iOS中使用像素位图(CGImageRef)对图片进行处理/","link":"","permalink":"http://huishao.cc/2015/04/26/34iOS中使用像素位图(CGImageRef)对图片进行处理/","excerpt":"","text":"iOS中对图片进行重绘处理的方法总结一、CGImageRef是什么CGImageRef是定义在QuartzCore框架中的一个结构体指针，用C语言编写。在CGImage.h文件中，我们可以看到下面的定义： 1typedef struct CGImage *CGImageRef; CGImageRef 和 struct CGImage * 是完全等价的。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。 QuartzCore这个框架是可移植的。 二、CGImageRef相关的一些方法解析CFTypeID CGImageGetTypeID(void) 这个方法返回的是一个编号，每个Core Foundation框架中得结构都会有一个这样的编号，CFTypeID定义如下： 1234567891011#if __LLP64__typedef unsigned long long CFTypeID;typedef unsigned long long CFOptionFlags;typedef unsigned long long CFHashCode;typedef signed long long CFIndex;#elsetypedef unsigned long CFTypeID;typedef unsigned long CFOptionFlags;typedef unsigned long CFHashCode;typedef signed long CFIndex;#endif 这个方法没有特殊的意义，只是一个标识符。 CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent); 通过这个方法，我们可以创建出一个CGImageRef类型的对象，下面分别对参数进行解释： sizt_t是定义的一个可移植性的单位，在64位机器中为8字节，32位位4字节。 width：图片宽度像素 height：图片高度像素 bitsPerComponent：每个颜色的比特数，例如在rgba-32模式下为8 bitsPerPixel：每个像素的总比特数 bytesPerRow：每一行占用的字节数，注意这里的单位是字节 space：颜色空间模式，例如const CFStringRef kCGColorSpaceGenericRGB 这个函数可以返回一个颜色空间对象。 bitmapInfo：位图像素布局，枚举如下： 1234567891011typedef CF_OPTIONS(uint32_t, CGBitmapInfo) &#123; kCGBitmapAlphaInfoMask = 0x1F, kCGBitmapFloatComponents = (1 &lt;&lt; 8), kCGBitmapByteOrderMask = 0x7000, kCGBitmapByteOrderDefault = (0 &lt;&lt; 12), kCGBitmapByteOrder16Little = (1 &lt;&lt; 12), kCGBitmapByteOrder32Little = (2 &lt;&lt; 12), kCGBitmapByteOrder16Big = (3 &lt;&lt; 12), kCGBitmapByteOrder32Big = (4 &lt;&lt; 12)&#125; provider：数据源提供者 decode[]：解码渲染数组 shouldInterpolate：是否抗锯齿 intent：图片相关参数 CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat decode\\[\\], bool shouldInterpolate) 这个方法用于创建mask图片图层，可以设置其显示部分与不显示部分达到特殊的效果，参数意义同上。 CGImageRef CGImageCreateCopy(CGImageRef image) 这个方法可以复制一个CGImageRef对象 CGImageRef CGImageCreateWithJPEGDataProvider(CGDataProviderRef source, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent) 通过JPEG数据源获取图像 CGImageRef CGImageCreateWithPNGDataProvider(CGDataProviderRef source, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent) 通过PNG数据源获取图像 CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect) 截取图像的一个区域重绘图像 CGImageRef CGImageCreateWithMask(CGImageRef image, CGImageRef mask) 截取mask图像的某一区域重绘 CGImageRef CGImageCreateWithMaskingColors(CGImageRef image, const CGFloat components\\[\\]) 通过颜色分量数组创建位图 CGImageRef CGImageCreateCopyWithColorSpace(CGImageRef image, CGColorSpaceRef space) 通过颜色空间模式复制位图 CGImageRef CGImageRetain(CGImageRef image) 引用+1 void CGImageRelease(CGImageRef image) 引用-1 bool CGImageIsMask(CGImageRef image) 返回是否为Mask图层 size_t CGImageGetWidth(CGImageRef image) 获取宽度像素 size_t CGImageGetHeight(CGImageRef image) 获取高度像素 下面这些方法分别获取相应属性 size_t CGImageGetBitsPerComponent(CGImageRef image) size_t CGImageGetBitsPerPixel(CGImageRef image) size_t CGImageGetBytesPerRow(CGImageRef image) CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)CG_EXTERN CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image) CGDataProviderRef CGImageGetDataProvider(CGImageRef image) const CGFloat *CGImageGetDecode(CGImageRef image) bool CGImageGetShouldInterpolate(CGImageRef image) CGColorRenderingIntent CGImageGetRenderingIntent(CGImageRef image) CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image) 三、应用举例使用CGImageRef进行图片截取 12345678910 //原图片 UIImage * img = [UIImage imageNamed:@&quot;11.11.52.png&quot;]; //转化为位图 CGImageRef temImg = img.CGImage; //根据范围截图 temImg=CGImageCreateWithImageInRect(temImg, CGRectMake(0, 0, 100, 100)); //得到新的图片 UIImage *new = [UIImage imageWithCGImage:temImg]; //释放位图对象 CGImageRelease(temImg); 注意：最后必须要调用这个函数，否则会造成内存泄露 1 CGImageRelease(temImg) 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中通知中心(NSNotificationCenter)的使用总结","slug":"33iOS中通知中心(NSNotificationCenter)的使用总结","date":"2015-04-24T16:00:00.000Z","updated":"2021-06-21T03:05:07.652Z","comments":true,"path":"2015/04/25/33iOS中通知中心(NSNotificationCenter)的使用总结/","link":"","permalink":"http://huishao.cc/2015/04/25/33iOS中通知中心(NSNotificationCenter)的使用总结/","excerpt":"","text":"iOS中通知中心NSNotificationCenter应用总结一、了解几个相关的类1、NSNotification这个类可以理解为一个消息对象，其中有三个成员变量。 这个成员变量是这个消息对象的唯一标识，用于辨别消息对象。 @property (readonly, copy) NSString *name; 这个成员变量定义一个对象，可以理解为针对某一个对象的消息。 @property (readonly, retain) id object; 这个成员变量是一个字典，可以用其来进行传值。 @property (readonly, copy) NSDictionary *userInfo; NSNotification的初始化方法： - (instancetype)initWithName:(NSString )name object:(id)object userInfo:(NSDictionary )userInfo; + (instancetype)notificationWithName:(NSString *)aName object:(id)anObject; + (instancetype)notificationWithName:(NSString )aName object:(id)anObject userInfo:(NSDictionary )aUserInfo; 注意:官方文档有明确的说明，不可以使用init进行初始化 2、NSNotificationCenter这个类是一个通知中心，使用单例设计，每个应用程序都会有一个默认的通知中心。用于调度通知的发送的接受。 添加一个观察者，可以为它指定一个方法，名字和对象。接受到通知时，执行方法。 - (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject; 发送通知消息的方法 - (void)postNotification:(NSNotification *)notification; - (void)postNotificationName:(NSString *)aName object:(id)anObject; - (void)postNotificationName:(NSString )aName object:(id)anObject userInfo:(NSDictionary )aUserInfo; 移除观察者的方法 - (void)removeObserver:(id)observer; - (void)removeObserver:(id)observer name:(NSString *)aName object:(id)anObject; 几点注意： 1、如果发送的通知指定了object对象，那么观察者接收的通知设置的object对象与其一样，才会接收到通知，但是接收通知如果将这个参数设置为了nil，则会接收一切通知。 2、观察者的SEL函数指针可以有一个参数，参数就是发送的死奥西对象本身，可以通过这个参数取到消息对象的userInfo，实现传值。 二、通知的使用流程首先，我们在需要接收通知的地方注册观察者，比如： 1234 //获取通知中心单例对象 NSNotificationCenter * center = [NSNotificationCenter defaultCenter]; //添加当前类对象为一个观察者，name和object设置为nil，表示接收一切通知 [center addObserver:self selector:@selector(notice:) name:@&quot;123&quot; object:nil]; 之后，在我们需要时发送通知消息 1234 //创建一个消息对象 NSNotification * notice = [NSNotification notificationWithName:@&quot;123&quot; object:nil userInfo:@&#123;@&quot;1&quot;:@&quot;123&quot;&#125;]; //发送消息 [[NSNotificationCenter defaultCenter]postNotification:notice]; 我们可以在回调的函数中取到userInfo内容，如下： 123-(void)notice:(id)sender&#123; NSLog(@&quot;%@&quot;,sender);&#125; 打印结果如下： 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS7使用原生API进行二维码和条形码的扫描","slug":"32iOS7使用原生API进行二维码和条形码的扫描","date":"2015-04-23T16:00:00.000Z","updated":"2021-06-21T03:04:00.268Z","comments":true,"path":"2015/04/24/32iOS7使用原生API进行二维码和条形码的扫描/","link":"","permalink":"http://huishao.cc/2015/04/24/32iOS7使用原生API进行二维码和条形码的扫描/","excerpt":"","text":"使用iOS7原生API进行二维码条形码的扫描IOS7之前，开发者进行扫码编程时，一般会借助第三方库。常用的是ZBarSDK，IOS7之后，系统的AVMetadataObject类中，为我们提供了解析二维码的接口。经过测试，使用原生API扫描和处理的效率非常高，远远高于第三方库。 一、使用方法示例官方提供的接口非常简单，代码如下： 123456789101112131415161718192021222324252627282930313233343536@interface ViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate&gt;//用于处理采集信息的代理&#123; AVCaptureSession * session;//输入输出的中间桥梁&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //获取摄像设备 AVCaptureDevice * device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; //创建输入流 AVCaptureDeviceInput * input = [AVCaptureDeviceInput deviceInputWithDevice:device error:nil]; //创建输出流 AVCaptureMetadataOutput * output = [[AVCaptureMetadataOutput alloc]init]; //设置代理 在主线程里刷新 [output setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()]; //初始化链接对象 session = [[AVCaptureSession alloc]init]; //高质量采集率 [session setSessionPreset:AVCaptureSessionPresetHigh]; [session addInput:input]; [session addOutput:output]; //设置扫码支持的编码格式(如下设置条形码和二维码兼容) output.metadataObjectTypes=@[AVMetadataObjectTypeQRCode,AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode128Code]; AVCaptureVideoPreviewLayer * layer = [AVCaptureVideoPreviewLayer layerWithSession:session]; layer.videoGravity=AVLayerVideoGravityResizeAspectFill; layer.frame=self.view.layer.bounds; [self.view.layer insertSublayer:layer atIndex:0]; //开始捕获 [session startRunning];&#125; 之后我们的UI上已经可以看到摄像头捕获的内容，只要实现代理中的方法，就可以完成二维码条形码的扫描： 12345678-(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection&#123; if (metadataObjects.count&gt;0) &#123; //[session stopRunning]; AVMetadataMachineReadableCodeObject * metadataObject = [metadataObjects objectAtIndex : 0 ]; //输出扫描字符串 NSLog(@&quot;%@&quot;,metadataObject.stringValue); &#125;&#125; 二、一些优化通过上面的代码测试，我们可以发现系统的解析处理效率是相当的高，IOS官方提供的API也确实非常强大，然而，我们可以做进一步的优化，将效率更加提高： 首先，AVCaptureMetadataOutput类中有一个这样的属性(在IOS7.0之后可用)： @property(nonatomic) CGRect rectOfInterest; 这个属性大致意思就是告诉系统它需要注意的区域，大部分APP的扫码UI中都会有一个框，提醒你将条形码放入那个区域，这个属性的作用就在这里，它可以设置一个范围，只处理在这个范围内捕获到的图像的信息。如此一来，可想而知，我们代码的效率又会得到很大的提高，在使用这个属性的时候。需要几点注意： 1、这个CGRect参数和普通的Rect范围不太一样，它的四个值的范围都是0-1，表示比例。 2、经过测试发现，这个参数里面的x对应的恰恰是距离左上角的垂直距离，y对应的是距离左上角的水平距离。 3、宽度和高度设置的情况也是类似。 3、举个例子如果我们想让扫描的处理区域是屏幕的下半部分，我们这样设置 1output.rectOfInterest=CGRectMake(0.5,0,0.5, 1); 具体apple为什么要设计成这样，或者是这个参数我的用法那里不对，还需要了解的朋友给个指导。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中使用本地通知为你的APP添加提示用户功能","slug":"31iOS中使用本地通知为你的APP添加提示用户功能","date":"2015-04-22T16:00:00.000Z","updated":"2021-06-21T02:28:44.460Z","comments":true,"path":"2015/04/23/31iOS中使用本地通知为你的APP添加提示用户功能/","link":"","permalink":"http://huishao.cc/2015/04/23/31iOS中使用本地通知为你的APP添加提示用户功能/","excerpt":"","text":"iOS中使用本地通知为你的APP添加提示用户功能首先，我们先要明白一个概念，这里的本地通知是UILocalNotification类，和系统的NSNotificationCenter通知中心是完全不同的概念。 一、我们可以通过本地通知做什么通知，实际上是由IOS系统管理的一个功能，比如某些后台应用做了某项活动需要我们处理、已经退出的应用在某个时间提醒我们唤起等等，如果注册了通知，系统都会在通知触发时给我们发送消息。由此，我们可以通过系统给我们的APP添加通知用户的功能，并且应用非常广泛。例如，闹种类应用，有按时签到相似功能的应用。下面，我们就来介绍如何注册并且设置一个本地通知。 二、了解UILocalNotification类顾名思义，这个类就是我们需要使用的本地通知类，先来看它的几个属性： 设置系统发送通知的时间(如果是过去的时间或者0，则会立刻发起通知) @property(nonatomic,copy) NSDate *fireDate; 设置时间的时区 @property(nonatomic,copy) NSTimeZone *timeZone; 设置周期性通知 @property(nonatomic) NSCalendarUnit repeatInterval; NSCalendarUnit对象是枚举，设定通知的周期 1234567891011typedef NS_OPTIONS(NSUInteger, NSCalendarUnit) &#123; NSCalendarUnitEra = kCFCalendarUnitEra, NSCalendarUnitYear = kCFCalendarUnitYear, NSCalendarUnitMonth = kCFCalendarUnitMonth, NSCalendarUnitDay = kCFCalendarUnitDay, NSCalendarUnitHour = kCFCalendarUnitHour, NSCalendarUnitMinute = kCFCalendarUnitMinute, NSCalendarUnitSecond = kCFCalendarUnitSecond, NSCalendarUnitWeekday = kCFCalendarUnitWeekday, NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal, &#125; 设置周期性通知参照的日历表 @property(nonatomic,copy) NSCalendar *repeatCalendar; 下面这两个函数是IOS8的新功能，在用户进去或者离开某一区域时发送通知 @property(nonatomic,copy) CLRegion *region; 设置区域检测通知是否重复(如果为YES，则没次进去出来都会发送，否则只发送一次) @property(nonatomic,assign) BOOL regionTriggersOnce; 设置通知的主体内容 @property(nonatomic,copy) NSString *alertBody; 是否隐藏滑动启动按钮 @property(nonatomic) BOOL hasAction; 设置滑动打开的提示文字 @property(nonatomic,copy) NSString *alertAction; 设置点击通知后启动的启动图片 @property(nonatomic,copy) NSString *alertLaunchImage; 下面这个方法是IOS8的新方法，是iwatch的接口，通知的短标题 @property(nonatomic,copy) NSString *alertTitle; 收到通知时，播放的系统音 @property(nonatomic,copy) NSString *soundName; 设置应用程序Icon头标数字 @property(nonatomic) NSInteger applicationIconBadgeNumber; 用户字典，可用于传递通知消息参数 @property(nonatomic,copy) NSDictionary *userInfo; 注意：这个字符串是系统默认的提示音 NSString *const UILocalNotificationDefaultSoundName; 三、本地通知的设计流程首先，想让我们的APP实现本地通知功能，必须得到用户的授权，在Appdelegate中实现如下代码： 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //如果已经得到授权，就直接添加本地通知，否则申请询问授权 if ([[UIApplication sharedApplication]currentUserNotificationSettings].types!=UIUserNotificationTypeNone) &#123; [self addLocalNotification]; &#125;else&#123; [[UIApplication sharedApplication]registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]]; &#125; return YES;&#125; 当用户点击允许或者不允许后，会执行如下代理方法，我们把处理逻辑在其中实现 12345-(void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings&#123; if (notificationSettings.types!=UIUserNotificationTypeNone) &#123; [self addLocalNotification]; &#125;&#125; 添加本地通知的方法： 12345678910111213-(void)addLocalNotification&#123; //定义本地通知对象 UILocalNotification *notification=[[UILocalNotification alloc]init]; //设置调用时间 notification.fireDate=[NSDate dateWithTimeIntervalSinceNow:0];//立即触发 //设置通知属性 notification.alertBody=@&quot;HELLO，我是本地通知哦!&quot;; //通知主体 notification.applicationIconBadgeNumber=1;//应用程序图标右上角显示的消息数 notification.alertAction=@&quot;打开应用&quot;; //待机界面的滑动动作提示 notification.soundName=UILocalNotificationDefaultSoundName;//收到通知时播放的声音，默认消息声音 //调用通知 [[UIApplication sharedApplication] scheduleLocalNotification:notification];&#125; 实现了上面三个步骤，本地通知的发出和接受基本都已完成，还有一些细节我们需要考虑： 应用进入前台后，将Icon上的头标清除： 123-(void)applicationWillEnterForeground:(UIApplication *)application&#123; [[UIApplication sharedApplication]setApplicationIconBadgeNumber:0];//进入前台取消应用消息图标&#125; 当不再需要这个通知时，清除它 1 [[UIApplication sharedApplication] cancelAllLocalNotifications]; 四、获取通知中的用户参数字典在上面，我们提到了一个参数 @property(nonatomic,copy) NSDictionary *userInfo; 我们可以在注册通知时将这个参数设置，然后在收到通知时使用get方法得到，但是这里有两种情况： 1、如果我们的APP在前台或者后台进入前台时-(void)application:(UIApplication )application didReceiveLocalNotification:(UILocalNotification )notification; 这个方法是APP在前台或者后台收到通知进入前台时调用的方法 2、如果我们的APP在关闭状态如果是这种情况，我们只能从下面函数的launchOptions中取到我们想要的参数 - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions; 代码示例如下： 123 //接收通知参数 UILocalNotification *notification=[launchOptions valueForKey:UIApplicationLaunchOptionsLocalNotificationKey]; NSDictionary *userInfo= notification.userInfo; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UITableView代理方法详解","slug":"29iOS UITableView代理方法详解","date":"2015-04-21T16:00:00.000Z","updated":"2021-06-10T09:02:45.123Z","comments":true,"path":"2015/04/22/29iOS UITableView代理方法详解/","link":"","permalink":"http://huishao.cc/2015/04/22/29iOS UITableView代理方法详解/","excerpt":"","text":"iOS UITableView的代理方法详解一、补充在上一篇博客中，http://my.oschina.net/u/2340880/blog/404605，我将IOS中tableView(表视图)的一些常用方法总结了一下，这篇将tableView的代理方法作了总结，对上一篇博客进行了补充。 二、UITableViewDataSourc（数据源代理）1、必须实现的回调方法返回每个分区的行数 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; 返回每一行的cell - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; 2、可选实现的方法返回分区数(默认为1) - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 返回每个分区头部的标题 - (NSString )tableView:(UITableView )tableView titleForHeaderInSection:(NSInteger)section; 返回每个分区的尾部标题 - (NSString )tableView:(UITableView )tableView titleForFooterInSection:(NSInteger)section; 设置某行是否可编辑 - (BOOL)tableView:(UITableView )tableView canEditRowAtIndexPath:(NSIndexPath )indexPath; 设置某行是否可以被移动 - (BOOL)tableView:(UITableView )tableView canMoveRowAtIndexPath:(NSIndexPath )indexPath; 设置索引栏标题数组（实现这个方法，会在tableView右边显示每个分区的索引） - (NSArray )sectionIndexTitlesForTableView:(UITableView )tableView; 设置索引栏标题对应的分区 - (NSInteger)tableView:(UITableView )tableView sectionForSectionIndexTitle:(NSString )title atIndex:(NSInteger)index tableView接受编辑时调用的方法 - (void)tableView:(UITableView )tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath )indexPath; 这个方法中的editingStyle参数是一个枚举，代表了cell被编辑的模式，如下： 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone,//没有编辑操作 UITableViewCellEditingStyleDelete,//删除操作 UITableViewCellEditingStyleInsert//插入操作&#125;; tableView的cell被移动时调用的方法 - (void)tableView:(UITableView )tableView moveRowAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath; 三、UITableViewDelegate（tableView代理）cell将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath *)indexPath; 头视图将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayHeaderView:(UIView )view forSection:(NSInteger)section; 尾视图将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayFooterView:(UIView )view forSection:(NSInteger)section; 和上面的方法对应，这三个方法分别是cell，头视图，尾视图已经显示时调用的方法 - (void)tableView:(UITableView )tableView didEndDisplayingCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath*)indexPath; - (void)tableView:(UITableView )tableView didEndDisplayingHeaderView:(UIView )view forSection:(NSInteger)section; - (void)tableView:(UITableView )tableView didEndDisplayingFooterView:(UIView )view forSection:(NSInteger)section; 设置行高，头视图高度和尾视图高度的方法 - (CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath; - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section; 设置行高，头视图高度和尾视图高度的估计值(对于高度可变的情况下，提高效率) - (CGFloat)tableView:(UITableView )tableView estimatedHeightForRowAtIndexPath:(NSIndexPath )indexPath; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section; 设置自定义头视图和尾视图 - (UIView )tableView:(UITableView )tableView viewForHeaderInSection:(NSInteger)section; - (UIView )tableView:(UITableView )tableView viewForFooterInSection:(NSInteger)section; 设置cell是否可以高亮 - (BOOL)tableView:(UITableView )tableView shouldHighlightRowAtIndexPath:(NSIndexPath )indexPath; cell高亮和取消高亮时分别调用的函数 - (void)tableView:(UITableView )tableView didHighlightRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView )tableView didUnhighlightRowAtIndexPath:(NSIndexPath )indexPath; 当即将选中某行和取消选中某行时调用的函数，返回一直位置，执行选中或者取消选中 - (NSIndexPath )tableView:(UITableView )tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath; - (NSIndexPath )tableView:(UITableView )tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath; 已经选中和已经取消选中后调用的函数 - (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView )tableView didDeselectRowAtIndexPath:(NSIndexPath )indexPath; 设置tableView被编辑时的状态风格，如果不设置，默认都是删除风格 - (UITableViewCellEditingStyle)tableView:(UITableView )tableView editingStyleForRowAtIndexPath:(NSIndexPath )indexPath; 自定义删除按钮的标题 - (NSString )tableView:(UITableView )tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath; 下面这个方法是IOS8中的新方法，用于自定义创建tableView被编辑时右边的按钮，按钮类型为UITableViewRowAction。 - (NSArray )tableView:(UITableView )tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath ; 设置编辑时背景是否缩进 - (BOOL)tableView:(UITableView )tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath )indexPath; 将要编辑和结束编辑时调用的方法 - (void)tableView:(UITableView)tableView willBeginEditingRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView)tableView didEndEditingRowAtIndexPath:(NSIndexPath )indexPath; 移动特定的某行 - (NSIndexPath )tableView:(UITableView )tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath )sourceIndexPath toProposedIndexPath:(NSIndexPath )proposedDestinationIndexPath; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITableView","slug":"UITableView","permalink":"http://huishao.cc/tags/UITableView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS8的新特性：简洁易用的毛玻璃效果","slug":"30iOS8的新特性：简洁易用的毛玻璃效果","date":"2015-04-21T16:00:00.000Z","updated":"2021-06-10T09:03:58.590Z","comments":true,"path":"2015/04/22/30iOS8的新特性：简洁易用的毛玻璃效果/","link":"","permalink":"http://huishao.cc/2015/04/22/30iOS8的新特性：简洁易用的毛玻璃效果/","excerpt":"","text":"探寻iOS8的新亮点：毛玻璃效果的简易实现IOS8之前，apple官方并不建议开发者使用类似毛玻璃的模糊效果，也并没有开放相关的接口，大部分的开发者是通过转化CGImage这个类来实现毛玻璃的模糊效果，并且实现的效果也很优秀。在IOS8之后，苹果官方新出了一个类UIVisualEffectView，通过这个类，实现毛玻璃效果变得轻而易举，而且效率非常之高，下面，我们来介绍下这个类的简单用法。 一、了解几个类1、UIVisualEffectView 这个类为我们提供了一个方便的接口，用来展示复杂的图像效果。 2、UIVisualEffect 官方对这个类的解释相当简单，它没有任何方法，只是充当一个帮助UIVisualEffectView创建的对象，是UIBlurEffect和UIVibrancyEffect的父类，或者可以理解，它的功能相当于一个抽象类。 3、UIBlurEffect 这个类是创建模糊效果，也就是毛玻璃效果的类，可以设置风格。 4、UIVibrancyEffect 从这个类的名字就可以看出，这个类是UIBlurEffect的扩展，可以创建出明亮的标签的按钮。 二、开始创建虚化的背景首先，初始化一个UIVisualEffectView对象： - (instancetype)initWithEffect:(UIVisualEffect *)effect; 这个方法里面的参数是UIVisuaEffect对象，我们先用UIBlueEffect的方式来创建： + (UIBlurEffect *)effectWithStyle:(UIBlurEffectStyle)style; 这个方法可以设置一个风格参数，风格枚举如下： 12345typedef NS_ENUM(NSInteger, UIBlurEffectStyle) &#123; UIBlurEffectStyleExtraLight,//高亮的风格 UIBlurEffectStyleLight,//亮化的风格 UIBlurEffectStyleDark//暗化的风格&#125; ; 这些都做好之后，我们需要给这个UIVisualEfffectView对象一个frame，然后直接加到我们想要虚化的背景上，总体代码如下： 123456789 UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleExtraLight]]; //设置虚化度 effectView.alpha=1.0; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 三、UIVisualEffectView的几个属性@property (nonatomic, retain, readonly) UIView *contentView; 这个参数和我们后面将要说的创建明亮的标签和按钮有关，这里先不多介绍。 @property (nonatomic, copy, readonly) UIVisualEffect *effect; 获得UIVissualEffect对象 @property(nonatomic) CGFloat alpha; 这个参数和虚化的程度有关 四、在虚化的背景上创建颜色绚丽的标签我们先来看一个效果，我们在刚才创建的虚化的背景上添加一个标签，代码如下： 12345678910111213UILabel * view2 = [[UILabel alloc]init]; view2.text=@&quot;注意看字体的颜色!&quot;; view2.font=[UIFont boldSystemFontOfSize:32]; view2.frame=CGRectMake(0, 0,300, 100); UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleExtraLight]]; [effectView addSubview:view2]; effectView.alpha=0.8; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 我们换另一种虚化效果来对背景进行虚化： 12345678910111213UILabel * view2 = [[UILabel alloc]init]; view2.text=@&quot;注意看字体的颜色!&quot;; view2.font=[UIFont boldSystemFontOfSize:32]; view2.frame=CGRectMake(0, 0,300, 100); UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIVibrancyEffect effectForBlurEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]]]; [effectView.contentView addSubview:view2]; effectView.alpha=0.8; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 现在可以很明白的了解，UIBlurEffect是对整个背景进行虚化，UIVibrancyEffect是对添加的标签等附件进行背景虚化。注意，这些附件，必须加在UIVisualEffectView的contentView里，否则将不起任何作用。 五、一个小控件通过上面的介绍，我们可以发现，在IOS8中创建一个毛玻璃效果是如此的容易，apple官方提供的类也是如此的强大，我们很轻松就可以实现实时变化虚化程度的动画效果，这在以前是非常麻烦和低效的。但是apple还有一个忠告：莫要泛滥的使用虚化，导致很差的用户体验! 最后，和大家分享一个前两天写的小控件，实现的效果是仿IOS8中在桌面下拉会是背景渐变虚化，从顶部会滑出搜索框。如下：可以当做一个demo来参考。 链接地址：http://d.cocoachina.com/code/detail/297393。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS使用Xcode可视化图像编辑功能进行图片拉伸","slug":"27iOS使用xcode可视化图像编辑功能进行图片拉伸","date":"2015-04-20T16:00:00.000Z","updated":"2021-06-10T08:59:39.270Z","comments":true,"path":"2015/04/21/27iOS使用xcode可视化图像编辑功能进行图片拉伸/","link":"","permalink":"http://huishao.cc/2015/04/21/27iOS使用xcode可视化图像编辑功能进行图片拉伸/","excerpt":"","text":"iOS中可视化拉伸图片技巧一、补充在我的另一篇博客http://my.oschina.net/u/2340880/blog/403996中探讨了IOS拉伸图像(UIImage)的几种方法和一些小经验，这篇是一个补充，再将xcode中的另一种可视化拉伸图像的方法的使用介绍给大家。 二、如何使用IOS开发文档中的描述：https://developer.apple.com/library/ios/recipes/xcode_help-image_catalog-1.0/chapters/SlicinganImage.html 1、xcode5的新特性xcode5之后，IOS为我们提供了一个管理图片的新方法Asset Catalogs，简单说来，它相当于一个目录，专门用来管理我们项目中的图片素材，包括Icon和启动页，这样使项目管理更加方便也更加简洁。 创建一个AssetCatalogs：在xcode中新建一个文件，选择AssetCatalogs，如下： 然后我们点开这个包，将图片直接拖入工具区即可： 2、使用AssetCatalogs中的可视化工具进行图片拉伸完成了上面的步骤之后，我们可以对管理的图片进行处理，点击右下角的show Slicing按钮，我们就会进入可视化编辑区，如下： 如上图，有三条竖直线，其中边界的两条分别约束了图片两侧不被拉伸的区域范围，中间虚线和左侧虚线围成的部分，将是被复制拉伸的区域。水平方向的线同理。 很重要的一点：官方文档告诉我们，这个方法只能在iOS 7 或者 OS X v10.10之后使用。效果如下： 3、在xib文件中UIImage的拉伸在xib文件中的UIImageView，在上面加上图片后，可以设置stretching这个属性： 这个属性的四个值：X,Y,Width,Height的取值范围是0-1；X，Y，用来确定一个点，比如我们设置为X=0.1，Y=0.1，则这个点就是图片的左上角开始，水平1/10处和竖直1/10处，设置图片的拉伸点为从这个点开始。后两个参数分别设置图片拉伸区域的宽度和高度，比如我们这样设置：Width=0.8，Height=0.8，则图片拉伸时上下左右各1/10的宽度不会被拉伸，中间部分被拉伸，还是刚才的图片，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中表视图(UITableView)使用详解","slug":"28iOS中表视图(UITableView)使用详解","date":"2015-04-20T16:00:00.000Z","updated":"2021-06-10T09:01:26.033Z","comments":true,"path":"2015/04/21/28iOS中表视图(UITableView)使用详解/","link":"","permalink":"http://huishao.cc/2015/04/21/28iOS中表视图(UITableView)使用详解/","excerpt":"","text":"iOS中UITableView使用总结一、初始化方法- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style; 这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下： 1234typedef NS_ENUM(NSInteger, UITableViewStyle) &#123; UITableViewStylePlain, // 标准的表视图风格 UITableViewStyleGrouped // 分组的表视图风格&#125;; 二、常用属性获取表视图的风格(只读属性) @property (nonatomic, readonly) UITableViewStyle style; 设置表示图代理和数据源代理(代理方法后面讨论) @property (nonatomic, assign) id &lt;UITableViewDataSource> dataSource; @property (nonatomic, assign) id &lt;UITableViewDelegate> delegate; 设置表示图的行高(默认为44) @property (nonatomic)CGFloat rowHeight; 设置分区的头视图高度和尾视图高度(当代理方法没有实现时才有效) @property (nonatomic) CGFloat sectionHeaderHeight; @property (nonatomic) CGFloat sectionFooterHeight; 设置一个行高的估计值(默认为0，表示没有估计,7.0之后可用) @property (nonatomic) CGFloat estimatedRowHeight; 注意：这个属性官方的解释是如果你的tableView的行高是可变的，那么设计一个估计高度可以加快代码的运行效率。 下面这两个属性和上面相似，分别设置分区头视图和尾视图的估计高度(7.0之后可用) @property (nonatomic) CGFloat estimatedSectionHeaderHeight; @property (nonatomic) CGFloat estimatedSectionFooterHeight; 设置分割线的位置 @property (nonatomic) UIEdgeInsets separatorInset; 如果细心，你可能会发现系统默认的tableView的分割线左端并没有顶到边沿。通过这个属性，可以手动设置分割线的位置偏移，比如你向让tableView的分割线只显示右半边，可以如下设置： 12UITableView * tab = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain];tab.separatorInset=UIEdgeInsetsMake(0, tab.frame.size.width/2, 0,0); 设置tableView背景view视图 @property(nonatomic, readwrite, retain) UIView *backgroundView; 三、常用方法详解重载tableView - (void)reloadData; 重载索引栏 - (void)reloadSectionIndexTitles; 这个方法常用语新加或者删除了索引类别而无需刷新整个表视图的情况下。 获取分区数 - (NSInteger)numberOfSections; 根据分区获取行数 - (NSInteger)numberOfRowsInSection:(NSInteger)section; 获取分区的大小(包括头视图，所有行和尾视图) - (CGRect)rectForSection:(NSInteger)section; 根据分区分别获取头视图，尾视图和行的高度 - (CGRect)rectForHeaderInSection:(NSInteger)section; - (CGRect)rectForFooterInSection:(NSInteger)section; - (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath; 获取某个点在tableView中的位置信息 - (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point; 获取某个cell在tableView中的位置信息 - (NSIndexPath )indexPathForCell:(UITableViewCell )cell; 根据一个矩形范围返回一个信息数组，数组中是每一行row的位置信息 - (NSArray *)indexPathsForRowsInRect:(CGRect)rect; 通过位置路径获取cell - (UITableViewCell )cellForRowAtIndexPath:(NSIndexPath )indexPath; 获取所有可见的cell - (NSArray *)visibleCells; 获取所有可见行的位置信息 - (NSArray *)indexPathsForVisibleRows; 根据分区获取头视图 - (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section; 根据分区获取尾视图 - (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section; 使表示图定位到某一位置(行) - (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated; 注意：indexPah参数是定位的位置，决定于分区和行号。animated参数决定是否有动画。scrollPosition参数决定定位的相对位置，它使一个枚举，如下： 123456typedef NS_ENUM(NSInteger, UITableViewScrollPosition) &#123; UITableViewScrollPositionNone,//同UITableViewScrollPositionTop UITableViewScrollPositionTop,//定位完成后，将定位的行显示在tableView的顶部 UITableViewScrollPositionMiddle,//定位完成后，将定位的行显示在tableView的中间 UITableViewScrollPositionBottom//定位完成后，将定位的行显示在tableView最下面&#125;; 使表示图定位到选中行 - (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated; 这个函数与上面的非常相似，只是它是将表示图定位到选中的行。 四、tableView操作刷新块的应用在介绍动画块之前，我们先看几个函数： 插入分区 - (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; animation参数是一个枚举，枚举的动画类型如下 12345678910typedef NS_ENUM(NSInteger, UITableViewRowAnimation) &#123; UITableViewRowAnimationFade,//淡入淡出 UITableViewRowAnimationRight,//从右滑入 UITableViewRowAnimationLeft,//从左滑入 UITableViewRowAnimationTop,//从上滑入 UITableViewRowAnimationBottom,//从下滑入 UITableViewRowAnimationNone, //没有动画 UITableViewRowAnimationMiddle, UITableViewRowAnimationAutomatic = 100 // 自动选择合适的动画&#125;; 删除分区 - (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; 重载一个分区 - (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation ; 移动一个分区 - (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection; 插入一些行 - (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 删除一些行 - (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 重载一些行 - (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 移动某行 - (void)moveRowAtIndexPath:(NSIndexPath )indexPath toIndexPath:(NSIndexPath )newIndexPath; 了解了上面几个函数，我们来看什么是操作刷新块： 当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，而然数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。 IOS为我们提供了下面两个函数解决这个问题： 开始块标志 - (void)beginUpdates; 结束快标志 - (void)endUpdates; 我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下： 1234[tab beginUpdates]; [tab deleteRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:1 inSection:0]] withRowAnimation:UITableViewRowAnimationLeft]; [dataArray removeObjectAtIndex:1]; [tab endUpdates]; 注意：不要在这个块中调用reloadData这个方法，它会使动画失效。 五、tableView的编辑操作设置是否是编辑状态(编辑状态下的cell左边会出现一个减号，点击右边会划出删除按钮) @property (nonatomic, getter=isEditing) BOOL editing; - (void)setEditing:(BOOL)editing animated:(BOOL)animated; 设置cell是否可以被选中(默认为YES) @property (nonatomic) BOOL allowsSelection; 设置cell编辑模式下是否可以被选中 @property (nonatomic) BOOL allowsSelectionDuringEditing; 设置是否支持多选 @property (nonatomic) BOOL allowsMultipleSelection; 设置编辑模式下是否支持多选 @property (nonatomic) BOOL allowsMultipleSelectionDuringEditing; 六、选中cell的相关操作获取选中cell的位置信息 - (NSIndexPath *)indexPathForSelectedRow; 获取多选cell的位置信息 - (NSArray *)indexPathsForSelectedRows; 代码手动选中与取消选中某行 - (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition; - (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated; 注意：这两个方法将不会回调代理中的方法。 七、tableView附件的相关方法设置索引栏最小显示行数 @property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount; 设置索引栏字体颜色 @property (nonatomic, retain) UIColor *sectionIndexColor; 设置索引栏背景颜色 @property (nonatomic, retain) UIColor *sectionIndexBackgroundColor; 设置索引栏被选中时的颜色 @property (nonatomic, retain) UIColor *sectionIndexTrackingBackgroundColor; 设置分割线的风格 @property (nonatomic) UITableViewCellSeparatorStyle separatorStyle; 这个风格是一个枚举，如下： 12345typedef NS_ENUM(NSInteger, UITableViewCellSeparatorStyle) &#123; UITableViewCellSeparatorStyleNone,//无线 UITableViewCellSeparatorStyleSingleLine,//有线 UITableViewCellSeparatorStyleSingleLineEtched &#125;; 设置分割线颜色 @property (nonatomic, retain) UIColor *separatorColor; 设置分割线毛玻璃效果(IOS8之后可用) @property (nonatomic, copy) UIVisualEffect *separatorEffect; 注意：这个属性是IOS8之后新的。 设置tableView头视图 @property (nonatomic, retain) UIView *tableHeaderView; 设置tableView尾视图 @property (nonatomic, retain) UIView *tableFooterView; 从复用池中取cell - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier; 获取一个已注册的cell - (id)dequeueReusableCellWithIdentifier:(NSString )identifier forIndexPath:(NSIndexPath )indexPath 从复用池获取头视图或尾视图 - (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier; 通过xib文件注册cell - (void)registerNib:(UINib )nib forCellReuseIdentifier:(NSString )identifier; 通过OC类注册cell - (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier 上面两个方法是IOS6之后的方法。 通过xib文件和OC类获取注册头视图和尾视图 - (void)registerNib:(UINib )nib forHeaderFooterViewReuseIdentifier:(NSString )identifier; - (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *) 关于tableView的代理方法，因为篇幅原因，总结在下一篇博客中。 错误之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中图片(UIImage)拉伸技巧","slug":"26iOS中图片(UIImage)拉伸技巧","date":"2015-04-19T16:00:00.000Z","updated":"2021-06-10T08:58:17.409Z","comments":true,"path":"2015/04/20/26iOS中图片(UIImage)拉伸技巧/","link":"","permalink":"http://huishao.cc/2015/04/20/26iOS中图片(UIImage)拉伸技巧/","excerpt":"","text":"iOS中图片拉伸技巧与方法总结一、了解几个图像拉伸的函数和方法1、直接拉伸法简单暴力，却是最最常用的方法，直接将图片设置为ImageView的image属性，图片便会随UIImageView对象的大小做自动拉伸。这种拉伸的方法有一个致命的缺陷，它会使图像发生失真与形变。 2、像素点的拉伸- (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight; 这个函数我们可以用来拉伸类似QQ，微信的聊天气泡背景图，它的两个参数分别leftCapWidth和topCapHeight，这两个参数给定一个坐标，比如： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img stretchableImageWithLeftCapWidth:1 topCapHeight:1]; 这段代码的意思是将图片从左起第2列，上起第2行，坐标为(2,2)的像素点进行复制。将图片进行拉伸。这个方法和上面的方法比起来似乎灵活性更多了，但其也有它的一些局限，如果被拉伸的图片中间也有需要拉伸的像素，这个方法就无能为力了，例如，如下的一张图片，我们需要将其拉伸放大： 便会出现这样的效果： 这明显和我们的意图是不符的，那么，我们可以使用下面的方法。 3、区域的拉伸- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; 这个函数需要设置一个UIEdgeInsets参数，UIEdgeInsets结构体如下： 123typedef struct UIEdgeInsets &#123; CGFloat top, left, bottom, right; &#125; UIEdgeInsets; 它分别对用了图片进行拉伸的区域距离顶部、左部、下部、右部的像素。比如，一个10*10像素的图片，将UIEdgeInsets参数全部设置为1，则实际拉伸的部分就是中间的8*8的区域的像素。有一点需要注意，这个方法默认使用的拉伸模式是区域复制，比如还是上面的图案，如下代码拉伸： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(1, 1, 1, 1)]; 结果如下： 可以明显的看到中间的虚线，这便是区域复制的杰作。 那么问题又来了，如果某些图片中间有渐变，我们该怎么处理了，来看下一个函数。 4、拉伸模式的设置- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode; 这个函数和上一个函数相比，唯一的差别是多了一个参数。这个参数是个枚举，如下： 1234typedef NS_ENUM(NSInteger, UIImageResizingMode) &#123; UIImageResizingModeTile,//进行区域复制模式拉伸 UIImageResizingModeStretch,//进行渐变复制模式拉伸&#125;; 现在就明了了，我们只需要设置一下模式，就可以实现渐变拉伸了： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(1, 1, 1, 1) resizingMode:UIImageResizingModeStretch]; 来看一下效果： 二、拉伸的用武之地圆角按钮，空心按钮，渐变的背景，内容可变的标签，聊天气泡等等这样的素材在APP中很可能会多次出现，并且每次出现的尺寸可能还会略微有些差异，如果仅仅依靠美工的素材，恐怕不仅很难达到要求，也会额外增加软件的内存开销，这时，我们使用恰当的拉伸技巧，能使我们的代码更加健壮，APP更加高效。 三、一点小经验你是否注意观察过最细的线？ 看到上面的问句，你可能有些差异。最细的线不就是一像素么？确实，能绘图画出来的最细的实心线确实是一像素，但在一个项目中，我们优秀的美工察觉到无论她把线做的多么细，无论我怎样控制拉伸方法，绘制出的登录框总是没有QQ的细，QQ的框线看起来更加干脆利索。后来索性用绘图画出登录框，结果很不幸，我依然无法将线做到像QQ登录框那样细致。后来偶然试了一种方法，不知原理是否正确，效果总算达到了，当然这也要归功于我们的美工，她将一个图片做的很大，适配最大的分辨率，然后让我手动缩，如此一来，那线就变得非常细。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIImage","slug":"UIImage","permalink":"http://huishao.cc/tags/UIImage/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中正则表达式的使用","slug":"25iOS中正则表达式的使用","date":"2015-04-18T16:00:00.000Z","updated":"2021-06-10T08:54:22.001Z","comments":true,"path":"2015/04/19/25iOS中正则表达式的使用/","link":"","permalink":"http://huishao.cc/2015/04/19/25iOS中正则表达式的使用/","excerpt":"","text":"正则表达式在iOS开发中的应用正则表达式在字符串查找，替换，检测中的应用非常广泛，正则表达式是什么，有怎样的语法，我的另一篇博客中有详细的介绍：http://my.oschina.net/u/2340880/blog/403508。这里只简单说一下其概念 ，正则表达式是一种语法小巧简单的语言，用来约束一些过滤字符串条的条件。很多开发工具都有支持正则表达式的内容，IOS也不例外，在IOS中NSRegularExpression类就是一个专门来处理正则表达式的类。 一、初始化方法初始化NSRegularExpression的方法有两种，一个init方法和一个类方法。其作用基本是一样的 + (NSRegularExpression )regularExpressionWithPattern:(NSString )pattern options:(NSRegularExpressionOptions)options error:(NSError **)error; - (instancetype)initWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error 其中，pattern是正则表达式，options是参数。对于option参数，它是一个枚举，表示正则模式的设置，如下： 123456789typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) &#123; NSRegularExpressionCaseInsensitive = 1 &lt;&lt; 0, //不区分字母大小写的模式 NSRegularExpressionAllowCommentsAndWhitespace = 1 &lt;&lt; 1, //忽略掉正则表达式中的空格和#号之后的字符 NSRegularExpressionIgnoreMetacharacters = 1 &lt;&lt; 2, //将正则表达式整体作为字符串处理 NSRegularExpressionDotMatchesLineSeparators = 1 &lt;&lt; 3, //允许.匹配任何字符，包括换行符 NSRegularExpressionAnchorsMatchLines = 1 &lt;&lt; 4, //允许^和$符号匹配行的开头和结尾 NSRegularExpressionUseUnixLineSeparators = 1 &lt;&lt; 5, //设置\\n为唯一的行分隔符，否则所有的都有效。 NSRegularExpressionUseUnicodeWordBoundaries = 1 &lt;&lt; 6 //使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效&#125;; 注意：1、NSRegularExpressionCaseInsensitive模式下正则表达式 aBc 会匹配到abc. 2、NSRegularExpressionIgnoreMetacharacters模式下正则表达式a b c 会匹配到abc，正则表达式ab#c会匹配到ab。 3、NSRegularExpressionAllowCommentsAndWhitespace模式下正则表达式\\[a-z\\]，会匹配到\\[a-z\\]。 二、获取查询结果初始化完毕正则表达式的处理类后，我们需要进行正则表达式的查询，IOS官方提供了两种模式： 1、带block模式的方法：- (void)enumerateMatchesInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range usingBlock:(void (^)(NSTextCheckingResult \\result, NSMatchingFlags flags, BOOL *stop))block; 使用举例： 1234NSRegularExpression * regex = [[NSRegularExpression alloc]initWithPattern:@&quot;[a-z]&quot; options:NSRegularExpressionCaseInsensitive error:nil]; [regex enumerateMatchesInString:@&quot;124a&quot; options:NSMatchingReportProgress range:NSMakeRange(0, 4) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) &#123; NSLog(@&quot;%@&quot;,result); &#125; ]; 注意：1、这个函数的一个参数options是一个枚举，设置回调的方式，如下： 1234567typedef NS_OPTIONS(NSUInteger, NSMatchingOptions) &#123; NSMatchingReportProgress = 1 &lt;&lt; 0, //找到最长的匹配字符串后调用block回调 NSMatchingReportCompletion = 1 &lt;&lt; 1, //找到任何一个匹配串后都回调一次block NSMatchingAnchored = 1 &lt;&lt; 2, //从匹配范围的开始出进行极限匹配 NSMatchingWithTransparentBounds = 1 &lt;&lt; 3, //允许匹配的范围超出设置的范围 NSMatchingWithoutAnchoringBounds = 1 &lt;&lt; 4 //禁止^和$自动匹配行还是和结束&#125;; 2、block回调中的flags枚举对应如下： 1234567typedef NS_OPTIONS(NSUInteger, NSMatchingFlags) &#123; NSMatchingProgress = 1 &lt;&lt; 0, //匹配到最长串是被设置 NSMatchingCompleted = 1 &lt;&lt; 1, //全部分配完成后被设置 NSMatchingHitEnd = 1 &lt;&lt; 2, //匹配到设置范围的末尾时被设置 NSMatchingRequiredEnd = 1 &lt;&lt; 3, //当前匹配到的字符串在匹配范围的末尾时被设置 NSMatchingInternalError = 1 &lt;&lt; 4 //由于错误导致的匹配失败时被设置 &#125;; 3、还有一点需要注意，就是那个bool值stop，我们可以在block块中设置它为YES，之后便会停止查找。 2、非block的方法这个方法会返回一个结果数组，将所有匹配的结果返回 - (NSArray )matchesInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法会返回匹配到得字符串的个数 - (NSUInteger)numberOfMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法会返回第一个查询到得结果，这个NSTextCheckingResult对象中有一个range属性，可以得到匹配到的字符串的范围。 - (NSTextCheckingResult )firstMatchInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法直接返回匹配到得范围，NSRange。 - (NSRange)rangeOfFirstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range; 三、一个辅助方法在NSRegularExpression类中还提供了一个辅助方法： + (NSString )escapedPatternForString:(NSString )string; 它可以帮助我们将正则表达式加上”\\“进行保护，将元字符转化成字面值。 到此，在IOS中正则表达式的基本用法就介绍完了，希望正则表达式的应用，能为你的项目节省更多时间。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"分分钟使用正则表达式","slug":"24分分钟使用正则表达式","date":"2015-04-18T16:00:00.000Z","updated":"2021-06-10T08:53:07.481Z","comments":true,"path":"2015/04/19/24分分钟使用正则表达式/","link":"","permalink":"http://huishao.cc/2015/04/19/24分分钟使用正则表达式/","excerpt":"","text":"正则表达式简单语法总结一、什么是正则表达式从概念上来说，正则表达式也是一门小巧而精炼的语言，它可以用来简化检索特定的字符串，替换特定字符等功能，有许多开发语言工具，都内嵌支持正则表达式。那么一个正则表达式，究竟是什么？其实它就是一个字符串，但这个字符串具有特定含义。 二、正则表达式的基础语法1、字面值所谓字面值，就是没有任何转义，查找的对象就是其本身，比如正则表达式 abc ，查找的结果就是返回要查找字符串中 a，b，c三个字母连在一起的字符串。又如，123 就是查找到123这个子串。 2、特殊字符（元字符）（1）句号“.”在正则表达式中表示匹配任意字符，很相似于通配符*。如果我们查找a.b这个正则表达式，我们可以找到所有开头和结尾为a，b，中间是任意字符的字符串，比如abc，adc，a2c等。 （2）字符类（[]）如果你在一个正则表达式中看到有一些字符被[]括号括起来，那么他们的含义将不再是简单的字面值，他们表示某一个被括号中属性约束的字符。比如[123456]，这个正则表达式表示找到1-6中的任意一个字符，又比如a[bd]c，这表示查找abc或者adc。 注意： 1.在字符类中字符的顺序和重复性都不是我们关心的。\\[123\\]和\\[2233111\\]，含义是一模一样的。 2.句号在字符类中表示的就是其本身，\\[.\\]就是查找一个句号。 （3）区间符号（-）如果我们需要查找一个数字，[0123456789]，这样做是可以达到目的的，但这写起非常麻烦，并不符合正则表达式小巧的特性，这时我们可以使用区间符号来简化，[0-9]和上面的式子意义完全一样。同样，我们可以[a-zA-Z]，表示任意一个字母。 注意： 1.区间的范围应该有意义，\\[a-1\\]这样的区间并无任何意义，尽管它在语法上可能没有错误。 2.区间左右两端对应的是字符，并不是数字，比如\\[2-41\\]，这个式子的含义是找到2-4的一个数字或者1，和\\[1-4\\]是一样的。 （4）取反符号（^）“^”在正则表达式中表示取反，这个很好理解，[^a]，表示找到除了a之外的任意字符。[^0-9]，表示找到一个非数字的字符。 注意： 1.^必须在中括号内，及字符类属性中使用。 2.^是将后面的整体作为取反条件的。 （5）简化的字符类某些符号具有和字符类相同的含义： \\d和[0-9]相同 \\w和[0-9A-Za-z_]相同 表示数字，字母或者下划线 \\s表示匹配空格，tab和换行等不可见符。 与此相对的\\D,\\W,\\S，则表示上述条件的取反情况。 （6）乘法集（{}）乘法集的最大用处也是简化正则表达式，用大括号表示。比如，a{2}，表示找到aa这个字符串。 注意： 乘法集是已前面整体为乘法条件的，比如\\[ab\\]{2}，不是简单的比配aa，bb，而是和\\[ab\\]\\[ab\\]含义是相同的，会匹配ab，ba，aa，bb。 （7）乘法集中的区间（,）乘法集和字符类相同，也可以用区间进行简化，但是符号不相同。a{1,3}，表示找到a，aa，aaa这三个字符串。a{0,1}是合法的，表示找到空字符，或者a。 注意： 1.乘法集的&quot;越长越好&quot;属性：乘法集具有这样的特点，比如a{2,4}，如果我搜索myaaaa，它不会找到aa后就停止，而是会找到aaaa。 2.乘法集的&quot;全部获取&quot;属性：比如a{2.4}，如果搜索myaayouaaaa，它会找到aa和aaaa。 3.乘法集支持开区间，a{1,}是合法的，表示找到任何a相连的字符串。 （8）判断符号（？）这个符号的含义和{0,1}完全相同，123?4，表示匹配1234或者124； （9）统配符号（*）这个符号的含义和{0,}相同，比如.* 表示通配一切字符串。 （10）+符号这个符号和{1,}相同。 （11）或符号（|）“|”符号表示或的关系，比如abc|edf，表示找到abc或者def （12）组合（()）小括号在正则表达式中表示组合，比如(a|b|c)d，表示找到ad，bd，cd，可以将小括号的作用理解为优先级。 （13）单词边界（\\b）\\b表示单词的边界，比如\\b[a-z]{3}\\b，表示匹配一个三个字母的小写单词。 （14）行边界（^ $）单单的一个^符号表示的是行的开头，$表示行的结束。 注意： \\[^\\]是非法的，\\[$\\]表示匹配一个$符号。 三、做些小总结上面说了这么多正则表达式的语法规则，我们现在来做下总结： 1、几个概念：1、字面值:直接查找的字符，比如123，avb。 2、字符类：描述字符的一些属性，比如[123],[a-z],\\d,\\w,\\s,.。 3、乘法集：简化表达式，比如{0,3},?,+,*。 4、或和组合：比如(a|b|v)。 5、单词，行的边界\\b ^ $ 2、元字符列表. \\ [ ] { } ? * + | ( ) ^ $ 3、字符类中元字符列表[ ] \\ - ^ 四、一个特别重要的字符最后，还有一个特别特别重要的字符我们没考虑到，如果我们要查找元字符怎么办，在正则表达式中还有一个转义字符”\\“，如果我们要查找. 只要查找\\. 同理\\[\\]是查找”[]“这个字符串。如果要查找”\\“，再加一个转义字符就好:\\\\。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://huishao.cc/categories/正则表达式/"}],"tags":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/tags/编程珠玑/"}],"keywords":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://huishao.cc/categories/正则表达式/"}]},{"title":"iOS description与debugDescription在调试程序中的应用","slug":"23iOS description与debugDescription在调试程序中的应用","date":"2015-04-16T16:00:00.000Z","updated":"2021-06-10T08:51:30.216Z","comments":true,"path":"2015/04/17/23iOS description与debugDescription在调试程序中的应用/","link":"","permalink":"http://huishao.cc/2015/04/17/23iOS description与debugDescription在调试程序中的应用/","excerpt":"","text":"iOS 中打印函数description与debugDescription的应用一、description和debugDescription是什么description和debugDescription是NSObject协议中的声明的两个方法，同时NSObject类也实现了这个方法，如果子类没有重写，则会调用父类的description和debugDescription方法。首先，这两个方法适用于程序代码的调试的，当我们调用打印Log时，会向对象发送一个这样的消息。 我们先来看声明部分的代码： 12+ (NSString *)description;+ (NSString *)debugDescription; 这里返回的字符串就是我们打印在控制台显示的信息。 二、NSObject基类中的description方法是如何实现的我们写如下的测试代码： 12 NSObject * objc = [[NSObject alloc]init]; NSLog(@&quot;objc:%@&quot;,objc); 控制台输出的信息如下： 可以看到，方法的实现大致是这样的： 123-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;&lt;%@:%p&gt;&quot;,[self class],&amp;self];&#125; 三、重写description方法通过上面的介绍，我们大致知道description方法的原理了，在程序调试时，我们可以充分利用这个方法带来的便利，大大缩减我们调试程序所需要的时间。例如：创建一个Test类，给它定义两个属性如下： Text.h 12345#import &lt;Foundation/Foundation.h&gt;@interface TestObject : NSObject@property(nonatomic,strong)NSString * name;@property(nonatomic,strong)NSString * age;@end 我们在.m文件中将description方法重写： 123456#import &quot;TestObject.h&quot;@implementation TestObject-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;%@&quot;,@&#123;@&quot;name&quot;:_name,@&quot;age&quot;:_age&#125;];&#125;@end 重写的方法将Test类对象的属性打印了出来，这时我们在调用NSLog函数时，打印结果如下： 是不是很炫酷，如此一来，我们可以将我们基本不会用到的类名和地址转换成打印数据，极大的方便了我们代码的调试工作。 四、description与debugDescription的区别这两个方法的区别仅仅在于调试的位置不同，调用不同的函数。description是我们在程序中打Log会调用的方法，debugDescription则是我们在断点调试时，在控制台使用po命令打印会调用的方法，比如我们重写Test类的这个方法： 123-(NSString *)debugDescription&#123; return [NSString stringWithFormat:@&quot;&lt;%@:%p&gt;:%@&quot;,[self class],&amp;self,@&#123;@&quot;name&quot;:_name,@&quot;age&quot;:_age&#125;];&#125; 然后我们在程序中加个断点运行，在程序断掉之后，我们在调试区输入：po text，回车之后，会出现如下的信息： 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS 单例设计模式解读","slug":"22iOS 单例设计模式解读","date":"2015-04-16T16:00:00.000Z","updated":"2021-06-10T08:49:14.271Z","comments":true,"path":"2015/04/17/22iOS 单例设计模式解读/","link":"","permalink":"http://huishao.cc/2015/04/17/22iOS 单例设计模式解读/","excerpt":"","text":"iOS 中单例设计模式的解读与用法一、单例的作用顾名思义，单例，即是在整个项目中，这个类的对象只能被初始化一次。它的这种特性，可以广泛应用于某些需要全局共享的资源中，比如管理类，引擎类，也可以通过单例来实现传值。UIApplication、NSUserDefaults等都是IOS中的系统单例。 二、单例的写法单例的写法常用的有两种方式： 方式1、不考虑线程12345678static SingleCase *manager = nil; + (SingleCase *)defaultManager &#123; if (!manager)&#123; SingleCase = [[self alloc] init]; return manager; &#125;&#125; 方式2、考虑线程安全123456789+ (SingleCase *)sharedManager &#123; static SingleCase *ManagerInstance = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; ManagerInstance = [[self alloc] init]; &#125;); return ManagerInstance; &#125; 三、代码的优化通过上面的方法，我们已经可以使用类方法来得到这个单例，但很多时候，项目的工程量很大，还有可能会很多开发者同时参与一个项目的开发，为了安全与管理代码的方便，也为了给不是这个单例的创作者但会用到这个单例的开发人员一些提示，我们通常会重写一些方法： 首先我们自己实现一个alloc方法： 123+(instancetype)myAlloc&#123; return [super allocWithZone:nil];&#125; 将我们的单例实现方法略作修改： 1234567+(ZYHPayManager *)sharedMamager&#123; static ZYHPayManager * manager; if (manager==nil) &#123; manager=[[ZYHPayManager myAlloc]init]; &#125; return manager;&#125; 将一些视图实例化对象的方法重写： 1234567891011121314+(instancetype)alloc&#123; NSAssert(0, @&quot;这是一个单例对象，请使用+(ZYHPayManager *)sharedMamager方法&quot;); return nil;&#125;+(instancetype)allocWithZone:(struct _NSZone *)zone&#123; return [self alloc];&#125;-(id)copy&#123; NSLog(@&quot;这是一个单例对象，copy将不起任何作用&quot;); return self;&#125;+(instancetype)new&#123; return [self alloc];&#125; 注意：这里的alloc使用了断言，让任何视图通过alloc创建对象的程序段断在此处，给程序员提示。copy方法这里只是简单的返回了原对象，并未做任何处理，打印信息给程序员提示。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://huishao.cc/categories/设计模式/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://huishao.cc/categories/设计模式/"}]},{"title":"iOS UIStepper(步进控件)使用总结","slug":"20iOS UIStepper(步进控件)使用总结","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:44:37.596Z","comments":true,"path":"2015/04/16/20iOS UIStepper(步进控件)使用总结/","link":"","permalink":"http://huishao.cc/2015/04/16/20iOS UIStepper(步进控件)使用总结/","excerpt":"","text":"iOS中步进控件的简单使用 初始化控件 1UIStepper * step = [[UIStepper alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器值是否连续触发变化 @property(nonatomic,getter=isContinuous) BOOL continuous; 若设置为YES，则长按会连续触发变化，若设置为NO，只有在按击结束后，才会触发。 设置长按是否一直触发变化 @property(nonatomic) BOOL autorepeat; 若设置为YES，则长按值会一直改变，若设置为NO，则一次点击只会改变一次值 设置控制器的值是否循环(到达边界后，重头开始，默认为NO) @property(nonatomic) BOOL wraps; 设置控制器的值 @property(nonatomic) double value; 设置控制器的最大值和最小值 @property(nonatomic) double minimumValue;//默认为0 @property(nonatomic) double maximumValue; //默认为100 设置控制器的步长 @property(nonatomic) double stepValue; 设置控制器风格颜色 @property(nonatomic,retain) UIColor *tintColor; 设置控制器背景图片 - (void)setBackgroundImage:(UIImage*)image forState:(UIControlState)state; 获取背景图片 - (UIImage*)backgroundImageForState:(UIControlState)state; 通过左右按钮的状态设置分割线的图片 - (void)setDividerImage:(UIImage*)image forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; 获取分割线图片 - (UIImage*)dividerImageForLeftSegmentState:(UIControlState)state rightSegmentState:(UIControlState)state; 设置和获取加号按钮的图片 - (void)setIncrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)incrementImageForState:(UIControlState)state; 设置和获取减号按钮的图片 - (void)setDecrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)decrementImageForState:(UIControlState)state; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIStepper","slug":"UIStepper","permalink":"http://huishao.cc/tags/UIStepper/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIPageControl(分页控制器) 用法总结","slug":"19iOS UIPageControl(分页控制器) 用法总结","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:43:35.178Z","comments":true,"path":"2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","excerpt":"","text":"UIPageControll 是继承于UIControl的一个IOS系统UI控件，可以提供给开发者设计分页效果的功能。 初始化方法 UIPageControl * page = [[UIPageControl alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器页数（默认为0） @property(nonatomic) NSInteger numberOfPages; 设置当前所在页码 @property(nonatomic) NSInteger currentPage; 设置当总页数为1时，是否自动隐藏控制器 @property(nonatomic) BOOL hidesForSinglePage; 设置是否延迟自动更新控制器的当前页码（默认为NO） @property(nonatomic) BOOL defersCurrentPageDisplay; 注意：这个属性如果设置为YES，点击时并不会改变控制器显示的当前页码点，必须手动调用 (void)updateCurrentPageDisplay; 这个方法，才会更新。 更新控制器当前页码 (void)updateCurrentPageDisplay; 通过页数得到控制器大小 (CGSize)sizeForNumberOfPages:(NSInteger)pageCount; 这个属性用于页数会变化的情况下进行大小动态处理 设置控制器页码点得颜色 @property(nonatomic,retain) UIColor *pageIndicatorTintColor; 设置控制器当前所在页码点的颜色 @property(nonatomic,retain) UIColor *currentPageIndicatorTintColor; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIPageControl","slug":"UIPageControl","permalink":"http://huishao.cc/tags/UIPageControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C 中变量的作用域","slug":"21Objective-C 中变量的作用域","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-10T08:47:29.313Z","comments":true,"path":"2015/04/16/21Objective-C 中变量的作用域/","link":"","permalink":"http://huishao.cc/2015/04/16/21Objective-C 中变量的作用域/","excerpt":"","text":"iOS中，修饰变量的关键字有四个，分别是： 1 @public 被这个关键字修饰的变量是完全开放的，只要有这类的对象存在，就可以访问到这个变量。 2 @protected 被这个关键字修饰的变量是受保护的，只有在声明变量的这个类中和它的子类中，可以访问。 3 @private 被这个关键字修饰的变量是私有的，只能在声明这个变量的类中使用，子类也不能使用。 4 @package 这个关键字比较难理解，大致意思是被修饰的变量是封装的，在本框架内可以自由使用，效果和@public 相同，而在框架外不能使用，其子类也不能使用，效果又相当于@private。 因为@package的这种特点，它非常适用于franework框架。 一点扩展： 访问类中的变量，我们可以用-&gt;符号，它和点语法的区别在于，点语法实际上是调用的set与get方法，而-&gt;符号是直接访问变量。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://huishao.cc/tags/Objective-C/"}],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS UIProgressView控件用法","slug":"18iOS UIProgressView控件用法","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:42:13.167Z","comments":true,"path":"2015/04/16/18iOS UIProgressView控件用法/","link":"","permalink":"http://huishao.cc/2015/04/16/18iOS UIProgressView控件用法/","excerpt":"","text":"进度条控件是IOS开发中一个简单的系统控件，使用总结如下： 初始化一个进度条： (instancetype)initWithProgressViewStyle:(UIProgressViewStyle)style; 注意：1.用这个方式初始化的进度条系统会默认给一个长度。 2.进度条的长度可以通过frame来设置，但是只有前三个参数有效。 3.风格枚举如下： typedef NS_ENUM(NSInteger, UIProgressViewStyle) { UIProgressViewStyleDefault, // 普通样式 UIProgressViewStyleBar, // 用于工具条的样式}; 设置进度条风格样式 @property(nonatomic) UIProgressViewStyle progressViewStyle; 设置进度条进度(0.0-1.0之间，默认为0.0) @property(nonatomic) float progress; 设置已走过进度的进度条颜色 @property(nonatomic, retain) UIColor* progressTintColor; 设置未走过进度的进度条颜色 @property(nonatomic, retain) UIColor* trackTintColor; 设置进度条已走过进度的背景图案和为走过进度的背景图案(IOS7后好像没有效果了) @property(nonatomic, retain) UIImage* progressImage; @property(nonatomic, retain) UIImage* trackImage; 设置进度条进度和是否动画显示(动画显示会平滑过渡) (void)setProgress:(float)progress animated:(BOOL)animated; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIProgressView","slug":"UIProgressView","permalink":"http://huishao.cc/tags/UIProgressView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIActivityIndicatorView(指示控制器)用法总结","slug":"17iOS UIActivityIndicatorView(指示控制器)用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:40:42.975Z","comments":true,"path":"2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","excerpt":"","text":"对于UIActivityIndicatorView的使用，我们一般会创建一个背景View,设置一定的透明度，然后将UIActivityIndicatorView贴在背景View上，在我们需要的时候将这个view呼出。 初始化UIActivityIndicatorView (instancetype)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style; 这个风格是一个枚举，如下 typedef NS_ENUM(NSInteger, UIActivityIndicatorViewStyle) { //大号白色 UIActivityIndicatorViewStyleWhiteLarge, //白色 UIActivityIndicatorViewStyleWhite, //灰色 UIActivityIndicatorViewStyleGray,}; 初始化之后，还需要给它一个Frame，但是只有前两个位置参数有效，大小参数将没有任何影响。 设置指示器风格： @property(nonatomic) UIActivityIndicatorViewStyle activityIndicatorViewStyle; 设置指示器是否停止动画时隐藏 @property(nonatomic) BOOL hidesWhenStopped; 设置指示器颜色 @property (readwrite, nonatomic, retain) UIColor *color； 让指示器开始动画 (void)startAnimating; 让指示器停止动画 (void)stopAnimating; 获取指示器动画状态 (BOOL)isAnimating; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIActivityIndicatorView","slug":"UIActivityIndicatorView","permalink":"http://huishao.cc/tags/UIActivityIndicatorView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISlider用法总结","slug":"15iOS UISlider用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:38:39.900Z","comments":true,"path":"2015/04/15/15iOS UISlider用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/15iOS UISlider用法总结/","excerpt":"","text":"UIslider滑块控件在IOS开发中会常用到，可用于调节音量，字体大小等UI方面的交互，用法总结如下： 初始化一个滑块： 1 UISlider * slider = [[UISlider alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; 设置滑块位置 @property(nonatomic) float value;这个值是介于滑块的最大值和最小值之间的，如果没有设置边界值，默认为0-1； 设置滑块最小边界值（默认为0） @property(nonatomic) float minimumValue; 设置滑块最大边界值（默认为1） @property(nonatomic) float maximumValue; 设置滑块最左端显示的图片： @property(nonatomic,retain) UIImage *minimumValueImage； 设置滑块最右端显示的图片： @property(nonatomic,retain) UIImage *maximumValueImage; 设置滑块值是否连续变化(默认为YES) @property(nonatomic,getter=isContinuous) BOOL continuous; 这个属性设置为YES则在滑动时，其value就会随时变化，设置为NO，则当滑动结束时，value才会改变。 设置滑块左边（小于部分）线条的颜色 @property(nonatomic,retain) UIColor *minimumTrackTintColor； 设置滑块右边（大于部分）线条的颜色 @property(nonatomic,retain) UIColor *maximumTrackTintColor； 设置滑块颜色（影响已划过一端的颜色） @property(nonatomic,retain) UIColor *thumbTintColor； 注意这个属性：如果你没有设置滑块的图片，那个这个属性将只会改变已划过一段线条的颜色，不会改变滑块的颜色，如果你设置了滑块的图片，又设置了这个属性，那么滑块的图片将不显示，滑块的颜色会改变（IOS7） 手动设置滑块的值： - (void)setValue:(float)value animated:(BOOL)animated; 设置滑块的图片： - (void)setThumbImage:(UIImage *)image forState:(UIControlState)state; 设置滑块划过部分的线条图案 - (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state; 设置滑块未划过部分的线条图案 - (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state; 对应的几个get方法 - (UIImage )thumbImageForState:(UIControlState)state;- (UIImage )minimumTrackImageForState:(UIControlState)state;- (UIImage *)maximumTrackImageForState:(UIControlState)state; 对应的设置当前状态的响应属性的方法 @property(nonatomic,readonly) UIImage currentThumbImage;@property(nonatomic,readonly) UIImage currentMinimumTrackImage;@property(nonatomic,readonly) UIImage* currentMaximumTrackImage; 添加触发事件 1[slider addTarget:self action:@selector(log:) forControlEvents:UIControlEventValueChanged]; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISlider","slug":"UISlider","permalink":"http://huishao.cc/tags/UISlider/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISwitch 用法总结","slug":"16iOS UISwitch 用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:39:45.598Z","comments":true,"path":"2015/04/15/16iOS UISwitch 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/16iOS UISwitch 用法总结/","excerpt":"","text":"iOS 系统开关控件简单使用总结： 初始化： (instancetype)initWithFrame:(CGRect)frame; 这个frame是没有意义的，系统的开关控件大小是确定的。 设置开关开启状态时的颜色 @property(nonatomic, retain) UIColor *onTintColor; 设置开关风格颜色 @property(nonatomic, retain) UIColor *tintColor; 设置开关按钮颜色 @property(nonatomic, retain) UIColor *thumbTintColor; 设置开关开启状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *onImage; 设置开关关闭状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *offImage; 开关的状态 @property(nonatomic,getter=isOn) BOOL on; 手动设置开关状态 (void)setOn:(BOOL)on animated:(BOOL)animated; 一点感想：iOS的系统的UISwitch控件虽然定制性很差，配合IOS7之后的扁平化和俭约的风格，在美观上确实不逊色于任何私人定制的开关控件，在没有特殊需求的情况下，对于开关逻辑，这是一个非常不错的UI交互选择。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISwitch","slug":"UISwitch","permalink":"http://huishao.cc/tags/UISwitch/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UITextField 使用与方法解读","slug":"14iOS UITextField 使用与方法解读","date":"2015-04-13T16:00:00.000Z","updated":"2021-06-02T08:38:34.799Z","comments":true,"path":"2015/04/14/14iOS UITextField 使用与方法解读/","link":"","permalink":"http://huishao.cc/2015/04/14/14iOS UITextField 使用与方法解读/","excerpt":"","text":"UITextField是IOS开发中用户交互中重要的一个控件，常被用来做账号密码框，输入信息框等。 初始化一个文字框： UITextField * textField = [[UITextField alloc]initWithFrame:CGRectMake(100, 30, 100, 100)]; 设置和获取文字框文字： @property(nonatomic,copy) NSString *text; 通过AttributedString创建和获取文字： @property(nonatomic,copy) NSAttributedString *attributedText； 设置字体颜色属性： @property(nonatomic,retain) UIColor *textColor; 设置字体属性： @property(nonatomic,retain) UIFont *font; 设置字体对齐格式： @property(nonatomic)NSTextAlignment textAlignment; 设置输入框风格： @property(nonatomic) UITextBorderStyle borderStyle; 这个风格是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextBorderStyle) { //没有任何边框 UITextBorderStyleNone, //线性边框 UITextBorderStyleLine, //阴影效果边框 UITextBorderStyleBezel, //原型效果边框 UITextBorderStyleRoundedRect}; 设置默认字体属性 @property(nonatomic,copy) NSDictionary *defaultTextAttributes； 这个属性的设置会影响到全部字体的属性。 设置缺省时显示的灰度字符串 @property(nonatomic,copy) NSString *placeholder; 通过AttributedString设置缺省字符串 @property(nonatomic,copy) NSAttributedString *attributedPlaceholder； 设置是否在开始编辑时清空输入框内容 @property(nonatomic) BOOL clearsOnBeginEditing; 设置字体大小是否随宽度自适应（默认为NO） @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 设置最小字体大小 @property(nonatomic) CGFloat minimumFontSize; 设置背景图片（会被拉伸） @property(nonatomic,retain) UIImage *background; 设置禁用时的背景图片 @property(nonatomic,retain) UIImage *disabledBackground; 是否正在编辑（只读属性） @property(nonatomic,readonly,getter=isEditing) BOOL editing; 是否允许更改字符属性字典 @property(nonatomic) BOOL allowsEditingTextAttributes； 设置属性字典 @property(nonatomic,copy) NSDictionary *typingAttributes； 设置清除按钮的显示模式 @property(nonatomic) UITextFieldViewMode clearButtonMode; 这是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextFieldViewMode) { //从不显示 UITextFieldViewModeNever, //编辑的时候显示 UITextFieldViewModeWhileEditing, //非编辑的时候显示 UITextFieldViewModeUnlessEditing, //任何时候都显示 UITextFieldViewModeAlways}; 设置输入框左边的view @property(nonatomic,retain) UIView *leftView; 设置输入框左视图的显示模式 @property(nonatomic) UITextFieldViewMode leftViewMode; 设置输入框右边的view @property(nonatomic,retain) UIView *rightView; 设置输入框右视图的显示模式 @property(nonatomic) UITextFieldViewMode rightViewMode; 设置输入框成为第一响应时弹出的视图和辅助视图（类似键盘） @property (readwrite, retain) UIView inputView;@property (readwrite, retain) UIView inputAccessoryView; 这个属性设置是否允许再次编辑时在内容中间插入内容 @property(nonatomic) BOOL clearsOnInsertion； 注销第一响应（収键盘） (BOOL)endEditing:(BOOL)force; UITextFieldDelegate 代理中的方法 点击输入框时触发的方法，返回YES则可以进入编辑状态，NO则不能。 (BOOL)textFieldShouldBeginEditing:(UITextField *)textField; 开始编辑时调用的方法 (void)textFieldDidBeginEditing:(UITextField *)textField; 将要结束编辑时调用的方法，返回YES则可以结束编辑状态，NO则不能 (BOOL)textFieldShouldEndEditing:(UITextField *)textField; 结束编辑调用的方法 (void)textFieldDidEndEditing:(UITextField *)textField; 输入字符时调用的方法 (BOOL)textField:(UITextField )textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString )string; 点击清除按钮时调用的函数，返回YES则可以清除，点击NO则不能清除 (BOOL)textFieldShouldClear:(UITextField *)textField; 点击return键触发的函数 (BOOL)textFieldShouldReturn:(UITextField *)textField; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITextField","slug":"UITextField","permalink":"http://huishao.cc/tags/UITextField/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISegmentedControl","slug":"13iOS UISegmentedControl","date":"2015-04-12T16:00:00.000Z","updated":"2021-06-02T08:36:44.741Z","comments":true,"path":"2015/04/13/13iOS UISegmentedControl/","link":"","permalink":"http://huishao.cc/2015/04/13/13iOS UISegmentedControl/","excerpt":"","text":"SegmentedControl又被称作分段控制器，是IOS开发中经常用到的一个UI控件。 初始化方法：传入的数组可以是字符串也可以是UIImage对象的图片数组 (instancetype)initWithItems:(NSArray *)items; 设置控件风格： @property(nonatomic) UISegmentedControlStyle segmentedControlStyle 注意：这个属性已经废弃，不再起任何作用，它的枚举如下： typedef NS_ENUM(NSInteger, UISegmentedControlStyle) { UISegmentedControlStylePlain, // large plain UISegmentedControlStyleBordered, // large bordered UISegmentedControlStyleBar, // small button/nav bar style. tintable UISegmentedControlStyleBezeled, // DEPRECATED. Do not use this style.} NS_DEPRECATED_IOS(2_0, 7_0, “The segmentedControlStyle property no longer has any effect”); 设置是否保持选中状态： @property(nonatomic,getter=isMomentary) BOOL momentary; 注意：如果设置为YES，点击结束后，将不保持选中状态，默认为NO 获取标签个数：(只读) @property(nonatomic,readonly) NSUInteger numberOfSegments; 设置标签宽度是否随内容自适应： @property(nonatomic) BOOL apportionsSegmentWidthsByContent； 注意：如果设置为NO，则所有标签宽度一致，为最大宽度。 插入文字标签在index位置： (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated 插入图片标签在index位置 (void)insertSegmentWithImage:(UIImage *)image atIndex:(NSUInteger)segment animated:(BOOL)animated 根据索引删除标签 (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated; 删除所有标签 (void)removeAllSegments; 重设标签标题 (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment; 获取标签标题 (NSString *)titleForSegmentAtIndex:(NSUInteger)segment; 设置标签图片 (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment; 获取标签图片 (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment; 注意：标题的图片只能设置一个 根据索引设置相应标签宽度 (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;注意：如果设置为0.0，则为自适应，默认为此设置。 根据索引获取标签宽度 (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment; 设置标签内容的偏移量 (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment; 注意：这个偏移量指的是标签的文字或者图片 根据索引获取变标签内容的偏移量 (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment; 根据所以设置标签是否有效(默认有效) (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment; 根据索引获取当前标签是否有效 (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment; 设置和获取当前选中的标签索引 @property(nonatomic) NSInteger selectedSegmentIndex; 设置标签风格颜色 @property(nonatomic,retain) UIColor *tintColor; 注意：这个风格颜色会影响标签的文字和图片 设置特定状态下segment的背景图案 (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 注意：UIBarMetrics是一个枚举，如下：(defaulf风格会充满背景) typedef NS_ENUM(NSInteger, UIBarMetrics) { UIBarMetricsDefault, UIBarMetricsCompact, UIBarMetricsDefaultPrompt = 101, // Applicable only in bars with the prompt property, such as UINavigationBar and UISearchBar UIBarMetricsCompactPrompt, UIBarMetricsLandscapePhone NS_ENUM_DEPRECATED_IOS(5_0, 8_0, &quot;Use UIBarMetricsCompact instead&quot;) = UIBarMetricsCompact, UIBarMetricsLandscapePhonePrompt NS_ENUM_DEPRECATED_IOS(7_0, 8_0, &quot;Use UIBarMetricsCompactPrompt&quot;) = UIBarMetricsCompactPrompt, }; 获取背景图案 (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 设置标签之间分割线的图案 (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 获取标签之间分割线的图案 (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 通过Attribute字符串属性字典设置标签标题 (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state 获取Attribute字符串属性字典 (NSDictionary *)titleTextAttributesForState:(UIControlState)state 自行设置标签内容的偏移量 (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 注意：UIOffset为偏移量，这个结构体中又两个浮点数，分别表示水平量和竖直量；UISegmentedControlSegment类型参数是一个枚举，如下： typedef NS_ENUM(NSInteger, UISegmentedControlSegment) { UISegmentedControlSegmentAny = 0,//所有标签都受影响 UISegmentedControlSegmentLeft = 1, //只有左边部分受到影响 UISegmentedControlSegmentCenter = 2, // 只有中间部分受到影响 UISegmentedControlSegmentRight = 3, // 只有右边部分受到影响 UISegmentedControlSegmentAlone = 4, // 在只有一个标签的时候生效}; 获取自定义偏移量 (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 添加点击事件 [segmentedControl addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISegmentedControl","slug":"UISegmentedControl","permalink":"http://huishao.cc/tags/UISegmentedControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIButton解读","slug":"12iOS UIButton解读","date":"2015-04-10T16:00:00.000Z","updated":"2021-06-02T08:35:20.122Z","comments":true,"path":"2015/04/11/12iOS UIButton解读/","link":"","permalink":"http://huishao.cc/2015/04/11/12iOS UIButton解读/","excerpt":"","text":"UIButton控件是应用界面中常用的一个控件，用法总结： 一、初始化 UIButton的初始化一般使用其类方法，+ (id)buttonWithType:(UIButtonType)buttonType; 风格的枚举如下： typedef NS_ENUM(NSInteger, UIButtonType) { //用户自定义，无风格 UIButtonTypeCustom = 0, //系统默认风格 UIButtonTypeSystem NS_ENUM_AVAILABLE_IOS(7_0), //一下这三种创建出来的按钮一样，一个蓝色的圆圈，中间有个叹号 UIButtonTypeDetailDisclosure, UIButtonTypeInfoLight, UIButtonTypeInfoDark, //创建+号按钮 UIButtonTypeContactAdd, //废弃 UIButtonTypeRoundedRect = UIButtonTypeSystem,}; 二、属性设置 @property(nonatomic) UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR;//这个属性设置button里内容的偏移量，包括title和image，可以用如下方法设置btn.contentEdgeInsets=UIEdgeInsetsMake(20, 20, 0, 0); @property(nonatomic) UIEdgeInsets titleEdgeInsets;//这个属性设置标题的偏移量@property(nonatomic) BOOL reversesTitleShadowWhenHighlighted;//按钮高亮时，是否改变阴影效果@property(nonatomic) UIEdgeInsets imageEdgeInsets;//图片的偏移量@property(nonatomic)BOOL adjustsImageWhenHighlighted;//设置图片的绘制是否高亮时变暗@property(nonatomic)BOOL adjustsImageWhenDisabled;//设置图片是否轻绘制当按钮禁用时@property(nonatomic)BOOL showsTouchWhenHighlighted;//设置是否显示手指印在按钮高亮的时候@property(nonatomic,retain) UIColor *tintColor NS_AVAILABLE_IOS(5_0);//这个属性会作用于标题和图片，但是如果你是自定义风格的按钮，这个属性将不起任何作用，它只作用于系统的@property(nonatomic,readonly) UIButtonType buttonType;//设置button的风格 三、一些set方法 (void)setTitle:(NSString *)title forState:(UIControlState)state;//设置标题和显示当前标题的按钮状态 (void)setTitleColor:(UIColor *)color forState:(UIControlState)state;//设置标题颜色和显示当前颜色的按钮状态 (void)setTitleShadowColor:(UIColor *)color forState:(UIControlState)state;//设置标题阴影颜色及显示时的状态 (void)setImage:(UIImage *)image forState:(UIControlState)state;//设置按钮图片和显示当前图片时的状态 (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state;//设置按钮背景图片和显示图片时的状态 (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state NS_AVAILABLE_IOS(6_0);//通过AttributeString创建标题 注意：按钮图片设置和背景图片的不同在于： 1、设置图片，如果有标题会和标题并列显示 2、设置背景图片会出现在标题下面 3、图片的偏移量可以设置，背景图片不可以。 四、一些get方法，可以得到上述设置的属性 (NSString *)titleForState:(UIControlState)state; (UIColor *)titleColorForState:(UIControlState)state; (UIColor *)titleShadowColorForState:(UIControlState)state; (UIImage *)imageForState:(UIControlState)state; (UIImage *)backgroundImageForState:(UIControlState)state; (NSAttributedString *)attributedTitleForState:(UIControlState)state NS_AVAILABLE_IOS(6_0); 五、一些只读属性 @property(nonatomic,readonly,retain) NSString currentTitle;@property(nonatomic,readonly,retain) UIColor currentTitleColor;@property(nonatomic,readonly,retain) UIColor currentTitleShadowColor;@property(nonatomic,readonly,retain) UIImage currentImage;@property(nonatomic,readonly,retain) UIImage currentBackgroundImage;@property(nonatomic,readonly,retain) NSAttributedString currentAttributedTitle NS_AVAILABLE_IOS(6_0);//这两个参数需要注意，虽然他们是只读属性不能重新设置，但是我们可以设置label和imageView的相关属性@property(nonatomic,readonly,retain) UILabel titleLabel NS_AVAILABLE_IOS(3_0);@property(nonatomic,readonly,retain) UIImageView imageView NS_AVAILABLE_IOS(3_0); 六、下面这些函数，都会返回一个CGRect 矩形范围 (CGRect)backgroundRectForBounds:(CGRect)bounds;//返回背景大小 (CGRect)contentRectForBounds:(CGRect)bounds;//返回视图大小，包括标题和图片 (CGRect)titleRectForContentRect:(CGRect)contentRect;//返回标题大小 (CGRect)imageRectForContentRect:(CGRect)contentRect;//返回图片大小 关于触发事件，button是继承于UIControl,这里不再叙述。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIButton","slug":"UIButton","permalink":"http://huishao.cc/tags/UIButton/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS 封装静态库(.a文件)","slug":"11iOS 封装静态库(.a文件)","date":"2015-04-10T16:00:00.000Z","updated":"2021-06-02T08:33:44.701Z","comments":true,"path":"2015/04/11/11iOS 封装静态库(.a文件)/","link":"","permalink":"http://huishao.cc/2015/04/11/11iOS 封装静态库(.a文件)/","excerpt":"","text":"iOS中导入外部文件，一种是将源码导入，一种是导入静态库，有很多第三方库都是以静态库的形式提供给我们使用的，如何制作一个静态库呢？ 一、xCode创建文件时，选择创建静态库文件：cacoaTouchStaticLibrary 创建完成后，我们在里面写我们的方法和实现： .h文件和.m文件 1234#import &lt;Foundation/Foundation.h&gt;@interface MyStaticLibrary : NSObject-(void)myLog;@end 123456#import &quot;MyStaticLibrary.h&quot;@implementation MyStaticLibrary-(void)myLog&#123; NSLog(@&quot;myLog&quot;);&#125;@end 二、生成静态库文件：这里需要将设备选成IOS Device然后 使用command+B进行编译，如果xcode报出这样的一个错误：我们需要在Peoject-&gt;Code Signing -&gt;Code Signing Identity 改成IOS Developer再次编译，成功。然后你会看到，Products中的.a文件由红色编程了黑色。我们右键show in finder，就可以看到编译成功的静态库文件了。 三、合并静态库 在文件夹中，我们看到有两个.a文件，分别用在模拟器调试和真机调试中，如果我们在开发时需要真机模拟器不停的切换，我们可以将这两个静态库文件合并成为一个： 在终端使用：lipo -create -output 命令： 这时，我们的静态库文件就做好了。 三、静态库文件的使用： 将.a和.h文件导入工程，在需要的文件中导入头文件，即可使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"静态库","slug":"静态库","permalink":"http://huishao.cc/tags/静态库/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSInvocation应用与理解","slug":"09iOS NSInvocation应用与理解","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:36:47.104Z","comments":true,"path":"2015/04/10/09iOS NSInvocation应用与理解/","link":"","permalink":"http://huishao.cc/2015/04/10/09iOS NSInvocation应用与理解/","excerpt":"","text":"IOS中有一个类型是SEL，它的作用很相似与函数指针，通过performSelector:withObject:函数可以直接调用这个消息。但是perform相关的这些函数，有一个局限性，其参数数量不能超过2个，否则要做很麻烦的处理，与之相对，NSInvocation也是一种消息调用的方法，并且它的参数没有限制。这两种直接调用对象消息的方法，在IOS4.0之后，大多被block结构所取代，只有在很老的兼容性系统中才会使用，简单用法总结如下： 一、初始化与调用 在官方文档中有明确说明，NSInvocation对象只能使用其类方法来初始化，不可使用alloc/init方法。它执行调用之前，需要设置两个方法：setSelector: 和setArgument:atIndex： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog); //创建一个函数签名，这个签名可以是任意的,但需要注意，签名函数的参数数量要和调用的一致。 NSMethodSignature * sig = [NSNumber instanceMethodSignatureForSelector:@selector(init)]; //通过签名初始化 NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; //设置target [invocatin setTarget:self]; //设置selecteor [invocatin setSelector:myMethod]; //消息调用 [invocatin invoke]; &#125;-(void)myLog&#123; NSLog(@&quot;MyLog&quot;);&#125; 注意：签名函数的参数数量要和调用函数的一致。测试后发现，当签名函数参数数量大于被调函数时，也是没有问题的。 调用多参数的方法，我们可以这样写： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 注意：1、这里设置参数的Index 需要从2开始，因为前两个被selector和target占用。下面这样写也没有任何问题： 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); SEL myMethod2 = @selector(myLog); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; ViewController * view = self; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 2、这里的传参方式必须是传递参数地址。 二、NSInvocation的返回值 NSInvocation对象，是可以有返回值的，然而这个返回值，并不是其所调用函数的返回值，需要我们手动设置： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; ViewController * view = self; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; //我们将c的值设置为返回值 [invocatin setReturnValue:&amp;c]; int d; //取这个返回值 [invocatin getReturnValue:&amp;d]; NSLog(@&quot;%d&quot;,d); &#125;-(int)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c); return a+b+c;&#125; 注意：这里的操作传递的都是地址。如果是OC对象，也是取地址。 三、关于内存 可以注意到- (void)retainArguments;这个方法，它会将传入的所有参数以及target都retain一遍。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSInvocation","slug":"NSInvocation","permalink":"http://huishao.cc/tags/NSInvocation/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSTimer 定时器用法总结","slug":"10iOS NSTimer 定时器用法总结","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:37:50.677Z","comments":true,"path":"2015/04/10/10iOS NSTimer 定时器用法总结/","link":"","permalink":"http://huishao.cc/2015/04/10/10iOS NSTimer 定时器用法总结/","excerpt":"","text":"NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下： 一、初始化方法：有五种初始化方法，分别是 + (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个Invocation对象 NSInvocation * invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(init)]]; [invo setTarget:self]; [invo setSelector:@selector(myLog)]; NSTimer * timer = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES]; //加入主循环池中 [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; //开始循环 [timer fire];&#125; + (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 1 NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES]; + (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:NO] + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:@&quot;123&quot; repeats:YES] - (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep 12 NSTimer * timer = [[NSTimer alloc]initWithFireDate:[NSDate distantPast] interval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; 注意：这五种初始化方法的异同： 1、参数repeats是指定是否循环执行，YES将循环，NO将只执行一次。 2、timerWithTimeInterval这两个类方法创建出来的对象如果不用 addTimer: forMode方法手动加入主循环池中，将不会循环执行。并且如果不手动调用fair，则定时器不会启动。 3、scheduledTimerWithTimeInterval这两个方法不需要手动调用fair，会自动执行，并且自动加入主循环池。 4、init方法需要手动加入循环池，它会在设定的启动时间启动。 二、成员变量 @property (copy) NSDate *fireDate; 这是设置定时器的启动时间，常用来管理定时器的启动与停止 1234 //启动定时器 timer.fireDate = [NSDate distantPast]; //停止定时器 timer.fireDate = [NSDate distantFuture]; @property (readonly) NSTimeInterval timeInterval; 这个是一个只读属性，获取定时器调用间隔时间。 @property NSTimeInterval tolerance; 这是7.0之后新增的一个属性，因为NSTimer并不完全精准，通过这个值设置误差范围。 @property (readonly, getter=isValid) BOOL valid; 获取定时器是否有效 @property (readonly, retain) id userInfo; 获取参数信息 三、关于内存释放 如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。所以我们需要这样做： 123456789101112131415161718-(void)dealloc&#123; NSLog(@&quot;dealloc:%@&quot;,[self class]);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; timer= [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(btn) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;-(void)btn&#123; if (timer.isValid) &#123; [timer invalidate]; &#125; timer=nil; [self dismissViewControllerAnimated:YES completion:nil];&#125; 在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSTimer","slug":"NSTimer","permalink":"http://huishao.cc/tags/NSTimer/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS 中block结构的简单用法","slug":"08iOS 中block结构的简单用法","date":"2015-04-08T16:00:00.000Z","updated":"2021-05-31T03:35:27.069Z","comments":true,"path":"2015/04/09/08iOS 中block结构的简单用法/","link":"","permalink":"http://huishao.cc/2015/04/09/08iOS 中block结构的简单用法/","excerpt":"","text":"自从block出现之后，很多API都开始采用这样的结构，由此可见，block确实有许多优势存在，这里将一些简单用法总结如下： 一、如何声明一个block变量 我们通过^符号来声明block类型，形式如下： void (^myBlock)(); 其中第一个void是返回值，可以是任意类型，中间括号中^后面的是这个block变量的名字，我把它命名为myBlock，最后一个括号中是参数，如果多参数，可以写成如下样式： int (^myBlock)(int,int); 同样，你也可以给参数起名字： int (^myBlock)(int a,int b); 很多时候，我们需要将我们声明的block类型作为函数的参数，也有两种方式： 1、-(void)func:(int (^)(int a,int b))block； 第二种方式是通过typedef定义一种新的类型，这也是大多数情况下采用的方式： 2、typedef int (^myBlock)(int a,int b) ; -(void)func:(myBlock)block ; 二、如何实现一个block 既然block可以被声明为变量，那么就一定可以实现它，就像其他类型变量的赋值。我自己对block的理解为它是一断代码块，所以给它赋值赋便是一段代码段： 1234567891011121314151617typedef int (^myBlock)(int,int) ;@interface ViewController ()&#123; myBlock block1;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. block1 =^(int a, int b)&#123; return a+b; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 这里打印的结果是2，从这里可以发现block和函数的功能很像。 注意：1、在上面的代码里 block1是一个对象，如果直接打印将打印对象地址 2、block()，加上后面的括号才是执行block语句块 三、block中访问对象的微妙关系 1、如果你在一个block块中仅仅访问对象，而不是对他进行修改操作，是没有任何问题的： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; int count= tem+1; return count; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 而如果我在block块中直接修改，编译器会报错： 1234 block1 = ^(int a,int b)&#123; tem+=1; return tem+1; &#125;; 为什么会出现这样的情况，根据猜测，可能是block内部将访问的变量都备份了一份，如果我们在内部修改，外部的变量并不会被修改，我们可以通过打印变量的地址来证明这一点： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; int tem=2; NSLog(@&quot;%p&quot;,&amp;tem); block1 = ^(int a,int b)&#123; NSLog(@&quot;%p&quot;,&amp;tem); return tem+1; &#125;; NSLog(@&quot;%d&quot;,block1(1,1)); &#125; 打印结果如下： 可以看出，变量的地址已经改变。 2、__block 做了什么 为了可以在block块中访问并修改外部变量，我们常会把变量声明成__block类型，通过上面的原理，可以发现，其实这个关键字只做了一件事，如果在block中访问没有添加这个关键字的变量，会访问到block自己拷贝的那一份变量，它是在block创建的时候创建的，而访问加了这个关键字的变量，则会访问这个变量的地址所对应的变量。我们可以通过代码来证明： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; tem=4; NSLog(@&quot;%d&quot;,block1(1,1)); block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; __block int tem2=2; tem2=4; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 结果： 3、一点点扩展 由此，我们可以理解，如果block中操作的对象是指针，那么直接可以进行修改，这包括OC对象，如果不是，则需要用__block关键字修饰。 4、关于引用计数 在block中访问的对象，会默认retain： 1234567 UIImage * number; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 结果如下： 而添加__block的对象不会被retain; 注意：如果我们访问类的成员变量，或者通过类方法来访问对象，那么这些对象不会被retain，而类对象会被return，最常见的时self: 1234567891011121314151617181920212223242526272829303132typedef void(^myBlock)(int,int) ;@interface ViewController2 ()&#123; myBlock block1; __block UIImage * number; &#125;@end@implementation ViewController2-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number));&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; //block1(1,1); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 打印结果： 可以看出，UIImage对象没有被retain,而self也将循环引用，造成内存泄露。解决方法如下： 1234567 number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIImage * im = number; block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)im)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 打印结果： 注意：根据这个机制，如果我们将block用来传值，在block不用时，务必要置为nil,而在实现block的方法里，务必要释放;我们通过代码来解释： 首先，创建三个ViewController，为ViewController1，ViewController2，ViewController3； 1、在ViewController1中创建一个按钮，跳转ViewController2 2、在ViewController2中： 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController2.h&quot;#import &quot;ViewController3.h&quot;@interface ViewController2 ()&#123; UIButton * im;&#125;@end@implementation ViewController3-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(300, 300, 100, 100); btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; im = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; im.backgroundColor=[UIColor blackColor]; [im addTarget:self action:@selector(rele) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:im];&#125;-(void)rele&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController3 alloc]init]; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 3、在ViewController3中： 12345678910111213141516171819202122#import &quot;ViewController3.h&quot;void (^myBlock)();@implementation ViewController3-(void)setBlock:(void(^)())block&#123; myBlock = [block copy];&#125;-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; myBlock(); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 通过打印信息，我们会发现，ViewController2不被释放，原因是其成员变量im被block中retain没有释放，我们这样做： 1234567891011121314151617@interface ViewController2 ()&#123; UIButton * im; ViewController3 * tem;&#125;-(void)rele&#123; [tem setBlock:nil]; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController2 alloc]init]; tem=con; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 这样就解决了内存问题。 四、关于block的作用域 应避免将花括号中的block用于外面，如果需要，你可以将这个block声明为全局的。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"Block","slug":"Block","permalink":"http://huishao.cc/tags/Block/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中使用NSAttributedString灵活创建标签","slug":"07iOS中使用NSAttributedString灵活创建标签","date":"2015-04-07T16:00:00.000Z","updated":"2021-05-31T03:33:47.188Z","comments":true,"path":"2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","link":"","permalink":"http://huishao.cc/2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","excerpt":"","text":"灵活使用NSAttributedString可以更轻松的创建出内容复杂的标签。需要注意一点：如果一个label设置了这个属性，那它其他的设置都将失效。 首先，我们初始化一个NSMutableAttributedString对象。 12345678//通过字符串初始化//- (instancetype)initWithString:(NSString *)str;//通过字符串和属性字典直接初始化//- (instancetype)initWithString:(NSString *)str attributes:(NSDictionary *)attrs;//通过自身对象初始化//- (instancetype)initWithAttributedString:(NSAttributedString *)attrStr; NSMutableAttributedString * attribute = [[NSMutableAttributedString alloc]initWithString:@&quot;123!@#你好么QWE&quot;]; 可以通过下面两个函数对attrebute字符串进行设置与修改 123456//可以替换字符- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;//属性设置- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;//设置一定范围内字符属性- (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; 字典的键值对应如下： 123456789101112131415161718//kCTFontAttributeName 这个键是字体的名称 必须传入CTFont对象//kCTKernAttributeName 这个键设置字体间距 传入必须是数字对象 默认为0//kCTLigatureAttributeName 这个键设置连字方式 必须传入CFNumber对象//kCTParagraphStyleAttributeName 段落对其方式//kCTForegroundColorAttributeName 字体颜色 必须传入CGColor对象//kCTStrokeWidthAttributeName 笔画宽度 必须是CFNumber对象//kCTStrokeColorAttributeName 笔画颜色//kCTSuperscriptAttributeName 控制垂直文本定位 CFNumber对象//kCTUnderlineColorAttributeName 下划线颜色[attribute addAttribute:(NSString*)kCTKernAttributeName value:@5 range:NSMakeRange(0, 5)];[attribute addAttribute:(NSString *)kCTFontAttributeName value:(id)CFBridgingRelease(CTFontCreateWithName((CFStringRef)[UIFont boldSystemFontOfSize:14].fontName, 14, NULL)) range:NSMakeRange(0, 4)]; [attribute addAttribute:(NSString *)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; 通过测试，发现上面有些键值并没有作用，可以替换下面的方法，效果相同，不同的地方在于其传值的类型不同，下面的方法更加方便（使用UIFont UIColor NSString 和一些系统枚举） 1234567891011121314151617181920 NSParagraphStyleAttributeNameNSForegroundColorAttributeNameNSBackgroundColorAttributeNameNSLigatureAttributeNameNSKernAttributeNameNSStrikethroughStyleAttributeNameNSUnderlineStyleAttributeNameNSStrokeColorAttributeName NSStrokeWidthAttributeName NSShadowAttributeName NSTextEffectAttributeNameNSAttachmentAttributeName NSLinkAttributeName NSBaselineOffsetAttributeName NSUnderlineColorAttributeNameNSStrikethroughColorAttributeNameNSObliquenessAttributeName NSExpansionAttributeName NSWritingDirectionAttributeNameNSVerticalGlyphFormAttributeName 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://huishao.cc/tags/NSAttributedString/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS6中横屏的处理方法","slug":"05iOS6中横屏的处理方法","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:33:03.710Z","comments":true,"path":"2015/04/07/05iOS6中横屏的处理方法/","link":"","permalink":"http://huishao.cc/2015/04/07/05iOS6中横屏的处理方法/","excerpt":"","text":"IOS6以后，若想在项目中支持横屏，我们首先需要在plist文件中添加支持横屏的设置，否则有些代码设置将会失效。 有来那个方式设置： 1、在pilist的Supported interface orientations 字段中添加 2、在Xcode的设置中勾选 现在我们来看决定屏幕方向的几个函数： 在IOS6之前，我们只需通过一个函数 - (BOOL) shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation { return (toInterfaceOrientation == UIInterfaceOrientationLandscapeRight);} 就可以支持指定控制器的旋转。通过新的文档，我们可以看到： 1234// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);//这个方法在6.0之后被标记为过时的 我们通过下面两个方法来代替： //是否允许屏幕旋转 -(BOOL)shouldAutorotate{ return YES;}//支持的方向- (NSUInteger)supportedInterfaceOrientations { return UIInterfaceOrientationMaskLandscapeRight;}这是个枚举 123456789101112131415typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown=(1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125;; 通过这两个函数，如果我们需要某个控制器强制方向，我们可以设置支持单一的方向，即可达到目的。 注意： 如果你们项目中的RootViewController是导航，你会发现，你在Push出来的视图中添加刚才的代码并没有起作用，原因是导航，并没有进行设置，我们创建一个文件，继承于NavigationController。在里面重写刚才的方法，这么做后，屏幕确实横了过来，并且这个导航push的所有子界面都将横屏，这也不是我们想要的效果。我们想自由的控制每个push出来的界面的屏幕方向，可以在导航里这么做： 1234567-(BOOL)shouldAutorotate&#123; return [self.topViewController shouldAutorotate];&#125;//支持的方向- (NSUInteger)supportedInterfaceOrientations &#123; return [self.topViewController supportedInterfaceOrientations];;&#125; 我们还需要做一些处理，经过我的测试，导航必须在pop后才会重新调用这些函数，所以我的方法是这样做：弹出一个中间控制器后再POP回来 1234567@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController pushViewController:[[ViewController3 alloc]init] animated:YES];&#125; 1234567@implementation ViewController3- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController popViewControllerAnimated:YES];&#125; 这样做，我们就可以自由的控制每个视图控制器的方向了。 同理，如果根视图控制器是tabBar，则我们需要在tabBar中做操作。 如果我们大多是的视图控制器都是一个方向的，只有偶尔的几个会不同，这时候，我们其实可以采取presentationController的方式，然后直接在弹出的控制器中写那两个方法即可。这是最简单的途径了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"横屏","slug":"横屏","permalink":"http://huishao.cc/tags/横屏/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS UILabe及UIFont用法总结","slug":"06iOS UILabe及UIFont用法总结","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:32:56.548Z","comments":true,"path":"2015/04/07/06iOS UILabe及UIFont用法总结/","link":"","permalink":"http://huishao.cc/2015/04/07/06iOS UILabe及UIFont用法总结/","excerpt":"","text":"初始化一个UILabel对象，并初始化大小 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置显示的文字 label.text=@”123”; 和字体相关的一个类，字号大小默认17 @property(nonatomic,retain) UIFont*font; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//7.0之后可用 设置字体风格// NSString *const UIFontTextStyleHeadline; 用于标题的风格// NSString *const UIFontTextStyleSubheadline;用于副标题的风格// NSString *const UIFontTextStyleBody;用于正文的字体// NSString *const UIFontTextStyleFootnote;用于脚注的字体// NSString *const UIFontTextStyleCaption1;用于标准字幕字体// NSString *const UIFontTextStyleCaption2;用于替换字幕字体 label.font=[UIFont preferredFontForTextStyle:UIFontTextStyleCaption2];//说实话，没看出什么太大的差别//设置字体和字体大小+ (UIFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize;//返回所有字体的字体家族名称数组+ (NSArray *)familyNames;//按字体家族名称返回字体名称数组+ (NSArray *)fontNamesForFamilyName:(NSString *)familyName;//设置普通字体字号大小+ (UIFont *)systemFontOfSize:(CGFloat)fontSize;//设置加粗字体字号大小+ (UIFont *)boldSystemFontOfSize:(CGFloat)fontSize;//设置斜体字号大小+ (UIFont *)italicSystemFontOfSize:(CGFloat)fontSize;//一些只读属性//字体家族名称@property(nonatomic,readonly,retain) NSString *familyName;//字体名称@property(nonatomic,readonly,retain) NSString *fontName;//字号大小@property(nonatomic,readonly) CGFloat pointSize;//字体设计模型，表示距离最高点偏移余量@property(nonatomic,readonly) CGFloat ascender;//底部的模型偏移量@property(nonatomic,readonly) CGFloat descender;//字体模型的头高信息@property(nonatomic,readonly) CGFloat capHeight;//字体模型的xHeight信息@property(nonatomic,readonly) CGFloat xHeight;//字体行高@property(nonatomic,readonly) CGFloat lineHeight NS_AVAILABLE_IOS(4_0);//模型主体信息@property(nonatomic,readonly) CGFloat leading;//创建一个新字体与当前字体相同，除了指定的大小- (UIFont *)fontWithSize:(CGFloat)fontSize;//通过描述信息返回字体 7.0后可用+ (UIFont *)fontWithDescriptor:(UIFontDescriptor *)descriptor size:(CGFloat)pointSize NS_AVAILABLE_IOS(7_0);//返回字体的描述信息，7.0后可用- (UIFontDescriptor *)fontDescriptor NS_AVAILABLE_IOS(7_0); 设置字体颜色 label.textColor=[UIColor redColor]; 设置阴影偏移量 label.shadowOffset=CGSizeMake(20, 20); 设置阴影颜色 label.shadowColor=[UIColor blackColor]; 设置对齐模式 label.textAlignment=NSTextAlignmentJustified; 1234567891011enum &#123; //沿左边沿对齐文本 NSTextAlignmentLeft = 0, //中心对齐 NSTextAlignmentCenter = 1, //右边沿对齐 NSTextAlignmentRight = 2, //最后一行自然对齐 NSTextAlignmentJustified = 3, //默认对齐 NSTextAlignmentNatural = 4,&#125;;typedef NSInteger NSTextAlignment; 多行文本设置 label.lineBreakMode=NSLineBreakByCharWrapping; 12345678910111213enum &#123; //文本边缘处理 NSLineBreakByWordWrapping = 0, //提前处理不合适的字符 NSLineBreakByCharWrapping, //简单线性处理 NSLineBreakByClipping, //丢失的开头用省略号表示 NSLineBreakByTruncatingHead, //丢失的文本在末尾显示省略号 NSLineBreakByTruncatingTail, //丢失的文本在中间显示省略号 NSLineBreakByTruncatingMiddle &#125;;typedef NSUInteger NSLineBreakMode 使用attributedText绘制 @property(nonatomic,copy) NSAttributedString *attributedText 设置高亮的字体颜色 label.highlightedTextColor=[UIColor blueColor]; //设置是否高亮 label.highlighted=YES; 用户交互 默认关闭 label.userInteractionEnabled=NO; 是否有效，默认是YES，无效为灰色 label.enabled=NO; 显示的行数，0为无限 @property(nonatomic) NSInteger numberOfLines; 宽度自适应大小 默认是NO @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 字符适应宽度：不赞成使用 @property(nonatomic) BOOL adjustsLetterSpacingToFitWidth 最小适应大小2.0-6.0 @property(nonatomic) CGFloat minimumFontSize 最小适应大小 6.0 之后 @property(nonatomic) CGFloat minimumScaleFactor 垂直方向的调整 @property(nonatomic) UIBaselineAdjustment baselineAdjustment; 1234567typedef enum &#123; //调整文本对应基线位置 UIBaselineAdjustmentAlignBaselines, //调整文本相对其边框的中心 UIBaselineAdjustmentAlignCenters, //调整文本相对于边界的左上角 默认的 UIBaselineAdjustmentNone,&#125; UIBaselineAdjustment; 返回文本绘制矩形 - (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines; 文本绘制函数 - (void)drawTextInRect:(CGRect)rect 文本自动布局参数 @property(nonatomic) CGFloat preferredMaxLayoutWidth 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UILabel","slug":"UILabel","permalink":"http://huishao.cc/tags/UILabel/"},{"name":"UIFont","slug":"UIFont","permalink":"http://huishao.cc/tags/UIFont/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS SEL的理解与使用","slug":"04iOS SEL的理解与使用","date":"2015-04-04T16:00:00.000Z","updated":"2021-05-28T10:11:35.356Z","comments":true,"path":"2015/04/05/04iOS SEL的理解与使用/","link":"","permalink":"http://huishao.cc/2015/04/05/04iOS SEL的理解与使用/","excerpt":"","text":"有很多人，认为block的推广可取代代理设计模式，其实block并不能取代代理，代理的模式可以让代码逻辑性更强，更整洁，也会有更高的可读性和可扩展性。相比之下，我觉得block更多的是取代了选择器@selector。 @selector是什么？我们要首先明白SEL，SEL并不是一种对象类型，我们通过xCode的字体颜色就可以判断出来，它是一个关键字，就像int，long一样，它声明了一种类型：类方法指针。其实就可以理解为一个函数指针。比如，我们生命一个叫myLog的函数指针： 1234567#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end 声明出了这个指针，我们该如何给它传递这个函数呢？有两种方式： 1、在编译时，使用@selector来取得函数 现在，我们应该明白@selector是什么了，它是一个编译标示，我们通过它来取到相应函数。 12345678910111213141516171819@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = @selector(myLogL); //通过performSelector来执行方法 [self performSelector:myLog];//打印 “myLog” &#125;-(void)myLogL&#123; NSLog(@&quot;myLog&quot;);&#125; 2、在运行时，通过NSSelectorFromString方法来取到相应函数： 12345678910111213141516171819202122#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = NSSelectorFromString(@&quot;myLogN&quot;); [self performSelector:myLog]; &#125;-(void)myLogN&#123; NSLog(@&quot;myLog&quot;);&#125; 这两种方式的差别在于，编译时的方法如果没有找到相应函数，xcode会报错，而运行时的方法不会。 至于SEL的应用，我相信最广泛的便是target——action设计模式了。我们来简单模拟一下系统button的工作原理： 我们先创建一个继承于UIButton的类： .h文件： 12345#import &lt;UIKit/UIKit.h&gt;@interface Mybutton : UIButton-(void)addMyTarget:(id)target action:(SEL)action;@end .m文件 1234567891011121314151617#import &quot;Mybutton.h&quot;@implementation Mybutton&#123; SEL _action; id _target;&#125;-(void)addMyTarget:(id)target action:(SEL)action&#123; _target=target; _action=action;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_target performSelector:_action];&#125;@end 在外部： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; Mybutton * btn = [[Mybutton alloc]initWithFrame:CGRectMake(100, 100, 60, 60)]; btn.backgroundColor=[UIColor redColor]; [btn addMyTarget:self action:@selector(click)]; [self.view addSubview:btn];&#125;-(void)click&#123; NSLog(@&quot;点击了btn&quot;);&#125; 当然，如果要调用参数，系统提供的默认参数不超过两个，如果参数很多，一种是我们可以通过字典传参，另一种方法比较复杂，在这里先不讨论。 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"SEL","slug":"SEL","permalink":"http://huishao.cc/tags/SEL/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS事件响应控制","slug":"03iOS事件响应控制","date":"2015-04-03T16:00:00.000Z","updated":"2021-05-28T10:09:54.887Z","comments":true,"path":"2015/04/04/03iOS事件响应控制/","link":"","permalink":"http://huishao.cc/2015/04/04/03iOS事件响应控制/","excerpt":"","text":"以前遇到一个项目，一个UIImageView对象上面有一个UIButton对象，然而项目的需求需要在点击 button的同时，UIImageView也接收到点击事件，在不使用代理和通知方法的前提下，通过事件响应链的原理，我们也可以很便捷的解决这个问题。 在处理这个问题之前，我们应该先清楚IOS的事件响应机制到底是个什么样的原理。 首先，这个事件响应的机制是分为两个部分的。 1、先在视图层级关系中找到应该响应事件的那个视图。 这一步是什么意思，其实很简单，就是找到你所触摸点对应的那个最上层的视图，它的工作原理是这样的：当用户发出事件后，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会取出队列中最前面的事件，发消息给UIWindow，然后UIWindow会对其所有子视图调用hitTest:withEvent:这个方法，这个方法会返回一个UIView的对象，这个方法在执行的时候，它会调用当前视图的pointInside:withEvent:这个方法，如果触摸事件在当前视图范围内，pointInside:withEvent:会返回YES，否则会返回NO；如果返回YES，则会遍历当前视图的所有子视图，统统发送hitTest:withEvent:这个消息，如果返回NO,则hitTest:withEvent:方法返回nil； 上面说起来有些绕，其实就是：hitTest:withEvent:方法会一层一层的向上找，若最上层响应的子视图pointInside:withEvent:返回YES，则返回此子视图，如果所有的都返回nil，则返回当前视图本身self。 例如：我们建两个文件，一个继承于UIButton，一个继承于UIImageView，我们在UIImageView里的代码如下： 12345678910111213141516171819#import &quot;MyImageView.h&quot;@implementation MyImageView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor=[UIColor redColor]; &#125; return self;&#125;//在这里，我们重写了这个方法，让它直接返回自身，而不是继续向下寻找应该响应事件的视图-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;点击了Image&quot;);&#125; 然后将他们创建在一个View上： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; // Do any additional setup after loading the view, typically from a nib.&#125; 我们运行，点击这个Btn，会打印如下的信息： 可以证明，在事件视图寻找中，UIImageView我们重写hitTest:withEvent:方法后，切断了寻找链，如果我们这个做： 123-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return nil;&#125; 你会发现，UIImageView也不再接收事件。2、寻找到应该响应的视图后，会进行消息处理，这个处理的方式是通过消息处理链来做的。如果它自身不能处理消息，会通过nextResponder将消息传递给下一个处理者，默认只要有一个view将消息处理了，这个消息处理传递链将不再传递。 现在，我们把刚才UIimageView里重写的hitTest:withEvent:方法注释掉，给btn添加一个点击方法，同时将用户交互关闭： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; image.userInteractionEnabled=YES; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click&#123; NSLog(@&quot;btn被点击了&quot;);&#125; 这样，我们的UIImageView又可以响应事件了，原因是事件处理传递链向下传递了。 现在，在回到我们刚开始的问题，如何让btn响应的同时imageView也响应，我们这样做： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; image.userInteractionEnabled=YES; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click:(UIButton *)btn&#123; NSLog(@&quot;btn被点击了&quot;); //响应链继续传递 [btn.nextResponder touchesBegan:nil withEvent:nil]; &#125; 结果如下： 虽然最终，我们完成了这个需求，可是我建议你最好不要这么干，因为这样的逻辑是违背现实生活中人们的行为认知的，更重要的是，我们的项目最后也确实改掉了这样的逻辑~~~ 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"事件","slug":"事件","permalink":"http://huishao.cc/tags/事件/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中DES与MD5加密方案","slug":"02MD","date":"2015-04-02T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/03/02MD/","link":"","permalink":"http://huishao.cc/2015/04/03/02MD/","excerpt":"","text":"MD5算法和DES算法是常见的两种加密算法。 MD5：MD5是一种不可逆的加密算法，按我的理解，所谓不可逆，就是不能解密，那么它有什么用的，它的用处大了，大多数的登录功能都会使用到这种算法。后面根据我的项目经验来介绍。 DES：一种使用密钥加密的块算法，所以，使用它加密时，需要一个密钥，加上一些设置和你需要加密的文段。 在IOS中，使用这两种加密算法非常简单，系统的&lt;CommonCrypto/CommonCrypto.h&gt;库给我们提供的边界的接口。在很多移动项目中，安卓平台和IOS平台的后台服务是统一的，比如一个登录功能是这样的流程： 1、客户端向服务端请求密钥，请求的参数是双方约定好的一个MD5加密的字符串。我们可以通过下面的进行第一步加密： 1234567891011121314- (NSString *)MD5Digest&#123; //要进行UTF8的转码 const char* input = [self UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(input, (CC_LONG)strlen(input), result); NSMutableString *digest = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) &#123; [digest appendFormat:@&quot;%02x&quot;, result[i]]; &#125; return digest;&#125; 通过这样的方法，我们可以很容易的得到一串MD5加密字符串，但是一定要和后台约定好，MD5加密的位数是16位还是32位，用上述方法加密出来的时32位，当然他们之间是有联系的，通过下面的方法可以将其转成16为： 1234567+(NSString *)trransFromMD532ToMD516:(NSString *)MD532&#123; NSString * string; for (int i=0; i&lt;24; i++) &#123; string=[MD532 substringWithRange:NSMakeRange(8, 16)]; &#125; return string;&#125; 还有一点需要注意，加密后的大小写也要对应。 2、服务端将得到的MD5串和以约定好的MD5串进行对比，如果一致，可以放行，返回密钥。 3、客户端取到密钥，将密钥再进行一次MD5加密，然后通过DES将要传送的数据加密发给服务器。 这一步至关重要，我们先看DES的加密代码 12345678910111213141516171819202122232425262728293031+(NSString *) encryptUseDES:(NSString *)clearText key:(NSString *)key andiv:(NSString *)iv&#123; //这个iv 是DES加密的初始化向量，可以用和密钥一样的MD5字符 NSData * date = [iv dataUsingEncoding:NSUTF8StringEncoding]; NSString *ciphertext = nil; NSUInteger dataLength = [clearText length]; NSData *textData = [clearText dataUsingEncoding:NSUTF8StringEncoding]; unsigned char buffer[1024]; memset(buffer, 0, sizeof(char)); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,//加密模式 kCCDecrypt 代表解密 kCCAlgorithmDES,//加密方式 kCCOptionPKCS7Padding,//填充算法 [key UTF8String], //密钥字符串 kCCKeySizeDES,//加密位数 [date bytes],//初始化向量 [textData bytes] , dataLength, buffer, 1024, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; NSLog(@&quot;DES加密成功&quot;); NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted]; Byte* bb = (Byte*)[data bytes]; ciphertext = [Base64 parseByteArray2HexString:bb]; &#125;else&#123; NSLog(@&quot;DES加密失败&quot;); &#125; return ciphertext;&#125; 几点注意： （1）加密方式，IOS官方提供的是如下几种 12345678910enum &#123; kCCAlgorithmAES128 = 0, kCCAlgorithmAES = 0, kCCAlgorithmDES, kCCAlgorithm3DES, kCCAlgorithmCAST, kCCAlgorithmRC4, kCCAlgorithmRC2, kCCAlgorithmBlowfish &#125;; （2）填充算法 123456enum &#123; /* options for block ciphers */ kCCOptionPKCS7Padding = 0x0001, kCCOptionECBMode = 0x0002 /* stream ciphers currently have no options */&#125;; 我们可以发现，官方提供的只有这两种，然而JAVA使用的却是 1kCCOptionPKCS7Padding 但是不用担心，在密钥是8位的时候，这两种填充算法加密出来的结果试一模一样的。 4、服务器通过相同的方式，解密出密文，通配安卓端。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"加密","slug":"加密","permalink":"http://huishao.cc/tags/加密/"},{"name":"DES","slug":"DES","permalink":"http://huishao.cc/tags/DES/"},{"name":"MD5","slug":"MD5","permalink":"http://huishao.cc/tags/MD5/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"AFNetWorking用法及缓存处理","slug":"01AF","date":"2015-04-01T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/02/01AF/","link":"","permalink":"http://huishao.cc/2015/04/02/01AF/","excerpt":"","text":"AFNetWorking 在IOS开发中是一个经常会用的第三方开源库，其最好处是维护及时，源码开源。 常用GET与POST请求方法： POST请求： 123456789//初始化一个请求对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; //dic 为参数字典 [manager POST:url parameters:dic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; GET请求： 1234567AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; 这里有一个地方需要注意， 1[AFHTTPRequestOperationManager manager] 这个类方法我们点进源码可以发现： 123+ (instancetype)manager &#123; return [[self alloc] initWithBaseURL:nil];&#125; 这里初始化了一个返回了一个新的对象，并不是单例。 使用这样的下载方法，下载完成后的数据AFNetWorking会帮我们自动解析，但是有时候服务器给的数据并不标准，这时我们需要加上这个设置： manager.responseSerializer = [AFHTTPResponseSerializer serializer]; 这样我们将得到原始的HTTP返回给我们数据。 我们再来探究一下，下载成功后，回调方法里的参数到底是什么东西 1success:^(AFHTTPRequestOperation *operation, id responseObject) 其中，第二个参数 responseObject 是下载下来的data数据，可直接进行JSON等解析。 第一个参数，是个AFHTTPRequestOperation对象，来看源文件 123456789@interface AFHTTPRequestOperation : AFURLConnectionOperation@property (readonly, nonatomic, strong) NSHTTPURLResponse *response;@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;@property (readonly, nonatomic, strong) id responseObject;@end 可以发现，里面有一个成员便是responseObject，同时，AFHTTPRequestOperation是继承于AFURLConnectionOperation,我们在看看AFURLConnectionOperation这个类： 123456789101112131415161718192021222324252627282930313233343536373839@interface AFURLConnectionOperation : NSOperation &lt;NSURLConnectionDelegate, NSURLConnectionDataDelegate, NSSecureCoding, NSCopying&gt;@property (nonatomic, strong) NSSet *runLoopModes;@property (readonly, nonatomic, strong) NSURLRequest *request;@property (readonly, nonatomic, strong) NSURLResponse *response;@property (readonly, nonatomic, strong) NSError *error;@property (readonly, nonatomic, strong) NSData *responseData;@property (readonly, nonatomic, copy) NSString *responseString;@property (readonly, nonatomic, assign) NSStringEncoding responseStringEncoding;@property (nonatomic, assign) BOOL shouldUseCredentialStorage;@property (nonatomic, strong) NSURLCredential *credential;@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;@property (nonatomic, strong) NSInputStream *inputStream;@property (nonatomic, strong) NSOutputStream *outputStream;@property (nonatomic, strong) dispatch_queue_t completionQueue;@property (nonatomic, strong) dispatch_group_t completionGroup;@property (nonatomic, strong) NSDictionary *userInfo;- (instancetype)initWithRequest:(NSURLRequest *)urlRequest NS_DESIGNATED_INITIALIZER;- (void)pause;- (BOOL)isPaused;- (void)resume; 看到这里，就离AFNETWorking封装的源头很近了，里面的成员非常多，其中包含了大部分我们需要的信息，可以通过点语法取到，其中有输入输出流，错误信息，请求到的Data数据，以及请求到的字符串数据 1responseString 我们可以通过 1NSLog ( @&quot;operation: %@&quot; , operation. responseString ); 来打印查看请求到的原始信息。 几点注意： 1.关于崩溃url为nil 大多数这样的原因是url中有特殊字符或者中文字符，AFNETWorking并没有做UTF8的转码，需要： 1url = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 2.添加HttpHead字段的方法 1234 //为这个下载任务HTTP头添加@&quot;User-Agent&quot;字段 [manager.requestSerializer setValue:_scrData forHTTPHeaderField:@&quot;User-Agent&quot;]; //打印头信息 NSLog(@&quot;%@&quot;,manager.requestSerializer.HTTPRequestHeaders); 在下载请求中，经常会请求一些不长变化的数据，如果每次APP启动都进行请求，会消耗许多资源，并且有时候缓存的处理，可以大大改善用户体验。 在AFNETWorking中，并没有提供现成的缓存方案，我们可以通过写文件的方式，自行做缓存。 在下载方法中： 1234567[manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //写缓存 NSString *cachePath = @&quot;你的缓存路径&quot;;// /Library/Caches/MyCache [data writeToFile:cachePath atomically:YES]; succsee(data); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; &#125;]; 然后在每次下载前，进行如下判断： 12345 NSString * cachePath = @&quot;你的缓存路径&quot;; if ([[NSFileManager defaultManager] fileExistsAtPath:cachePath]) &#123; //从本地读缓存文件 NSData *data = [NSData dataWithContentsOfFile:cachePath]; &#125; 有时，我们的下载请求可能是用户的动作触发的，比如一个按钮。我们还应该做一个保护机制的处理， 123456789101112131415//初始化一个下载请求数组NSArray * requestArray=[[NSMutableArray alloc]init];//每次开始下载任务前做如下判断for (NSString * request in requestArray) &#123; if ([url isEqualToString:request]) &#123; return; &#125; &#125; [requestArray addObject:url]; //下载成功或失败后 [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [requestArray removeObject:url] &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [requestArray removeObject:url] &#125;]; 至此，一个比较完成AFNETWorking请求使用流程就完成了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://huishao.cc/tags/网络/"},{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"AFNetWorking","slug":"AFNetWorking","permalink":"http://huishao.cc/tags/AFNetWorking/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]}]}