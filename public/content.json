{"meta":{"title":"珲少的技术博客","subtitle":"专注技术 有趣生活","description":"珲少的技术博客","author":"珲少","url":"http://huishao.cc"},"pages":[],"posts":[{"title":"iOS UIStepper(步进控件)使用总结","slug":"20iOS UIStepper(步进控件)使用总结","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:44:37.596Z","comments":true,"path":"2015/04/16/20iOS UIStepper(步进控件)使用总结/","link":"","permalink":"http://huishao.cc/2015/04/16/20iOS UIStepper(步进控件)使用总结/","excerpt":"","text":"iOS中步进控件的简单使用 初始化控件 1UIStepper * step = [[UIStepper alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器值是否连续触发变化 @property(nonatomic,getter=isContinuous) BOOL continuous; 若设置为YES，则长按会连续触发变化，若设置为NO，只有在按击结束后，才会触发。 设置长按是否一直触发变化 @property(nonatomic) BOOL autorepeat; 若设置为YES，则长按值会一直改变，若设置为NO，则一次点击只会改变一次值 设置控制器的值是否循环(到达边界后，重头开始，默认为NO) @property(nonatomic) BOOL wraps; 设置控制器的值 @property(nonatomic) double value; 设置控制器的最大值和最小值 @property(nonatomic) double minimumValue;//默认为0 @property(nonatomic) double maximumValue; //默认为100 设置控制器的步长 @property(nonatomic) double stepValue; 设置控制器风格颜色 @property(nonatomic,retain) UIColor *tintColor; 设置控制器背景图片 - (void)setBackgroundImage:(UIImage*)image forState:(UIControlState)state; 获取背景图片 - (UIImage*)backgroundImageForState:(UIControlState)state; 通过左右按钮的状态设置分割线的图片 - (void)setDividerImage:(UIImage*)image forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; 获取分割线图片 - (UIImage*)dividerImageForLeftSegmentState:(UIControlState)state rightSegmentState:(UIControlState)state; 设置和获取加号按钮的图片 - (void)setIncrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)incrementImageForState:(UIControlState)state; 设置和获取减号按钮的图片 - (void)setDecrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)decrementImageForState:(UIControlState)state; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIStepper","slug":"UIStepper","permalink":"http://huishao.cc/tags/UIStepper/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIProgressView控件用法","slug":"18iOS UIProgressView控件用法","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:42:13.167Z","comments":true,"path":"2015/04/16/18iOS UIProgressView控件用法/","link":"","permalink":"http://huishao.cc/2015/04/16/18iOS UIProgressView控件用法/","excerpt":"","text":"进度条控件是IOS开发中一个简单的系统控件，使用总结如下： 初始化一个进度条： (instancetype)initWithProgressViewStyle:(UIProgressViewStyle)style; 注意：1.用这个方式初始化的进度条系统会默认给一个长度。 2.进度条的长度可以通过frame来设置，但是只有前三个参数有效。 3.风格枚举如下： typedef NS_ENUM(NSInteger, UIProgressViewStyle) { UIProgressViewStyleDefault, // 普通样式 UIProgressViewStyleBar, // 用于工具条的样式}; 设置进度条风格样式 @property(nonatomic) UIProgressViewStyle progressViewStyle; 设置进度条进度(0.0-1.0之间，默认为0.0) @property(nonatomic) float progress; 设置已走过进度的进度条颜色 @property(nonatomic, retain) UIColor* progressTintColor; 设置未走过进度的进度条颜色 @property(nonatomic, retain) UIColor* trackTintColor; 设置进度条已走过进度的背景图案和为走过进度的背景图案(IOS7后好像没有效果了) @property(nonatomic, retain) UIImage* progressImage; @property(nonatomic, retain) UIImage* trackImage; 设置进度条进度和是否动画显示(动画显示会平滑过渡) (void)setProgress:(float)progress animated:(BOOL)animated; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIProgressView","slug":"UIProgressView","permalink":"http://huishao.cc/tags/UIProgressView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIPageControl(分页控制器) 用法总结","slug":"19iOS UIPageControl(分页控制器) 用法总结","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:43:35.178Z","comments":true,"path":"2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","excerpt":"","text":"UIPageControll 是继承于UIControl的一个IOS系统UI控件，可以提供给开发者设计分页效果的功能。 初始化方法 UIPageControl * page = [[UIPageControl alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器页数（默认为0） @property(nonatomic) NSInteger numberOfPages; 设置当前所在页码 @property(nonatomic) NSInteger currentPage; 设置当总页数为1时，是否自动隐藏控制器 @property(nonatomic) BOOL hidesForSinglePage; 设置是否延迟自动更新控制器的当前页码（默认为NO） @property(nonatomic) BOOL defersCurrentPageDisplay; 注意：这个属性如果设置为YES，点击时并不会改变控制器显示的当前页码点，必须手动调用 (void)updateCurrentPageDisplay; 这个方法，才会更新。 更新控制器当前页码 (void)updateCurrentPageDisplay; 通过页数得到控制器大小 (CGSize)sizeForNumberOfPages:(NSInteger)pageCount; 这个属性用于页数会变化的情况下进行大小动态处理 设置控制器页码点得颜色 @property(nonatomic,retain) UIColor *pageIndicatorTintColor; 设置控制器当前所在页码点的颜色 @property(nonatomic,retain) UIColor *currentPageIndicatorTintColor; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIPageControl","slug":"UIPageControl","permalink":"http://huishao.cc/tags/UIPageControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISlider用法总结","slug":"15iOS UISlider用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:38:39.900Z","comments":true,"path":"2015/04/15/15iOS UISlider用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/15iOS UISlider用法总结/","excerpt":"","text":"UIslider滑块控件在IOS开发中会常用到，可用于调节音量，字体大小等UI方面的交互，用法总结如下： 初始化一个滑块： 1 UISlider * slider = [[UISlider alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; 设置滑块位置 @property(nonatomic) float value;这个值是介于滑块的最大值和最小值之间的，如果没有设置边界值，默认为0-1； 设置滑块最小边界值（默认为0） @property(nonatomic) float minimumValue; 设置滑块最大边界值（默认为1） @property(nonatomic) float maximumValue; 设置滑块最左端显示的图片： @property(nonatomic,retain) UIImage *minimumValueImage； 设置滑块最右端显示的图片： @property(nonatomic,retain) UIImage *maximumValueImage; 设置滑块值是否连续变化(默认为YES) @property(nonatomic,getter=isContinuous) BOOL continuous; 这个属性设置为YES则在滑动时，其value就会随时变化，设置为NO，则当滑动结束时，value才会改变。 设置滑块左边（小于部分）线条的颜色 @property(nonatomic,retain) UIColor *minimumTrackTintColor； 设置滑块右边（大于部分）线条的颜色 @property(nonatomic,retain) UIColor *maximumTrackTintColor； 设置滑块颜色（影响已划过一端的颜色） @property(nonatomic,retain) UIColor *thumbTintColor； 注意这个属性：如果你没有设置滑块的图片，那个这个属性将只会改变已划过一段线条的颜色，不会改变滑块的颜色，如果你设置了滑块的图片，又设置了这个属性，那么滑块的图片将不显示，滑块的颜色会改变（IOS7） 手动设置滑块的值： - (void)setValue:(float)value animated:(BOOL)animated; 设置滑块的图片： - (void)setThumbImage:(UIImage *)image forState:(UIControlState)state; 设置滑块划过部分的线条图案 - (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state; 设置滑块未划过部分的线条图案 - (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state; 对应的几个get方法 - (UIImage )thumbImageForState:(UIControlState)state;- (UIImage )minimumTrackImageForState:(UIControlState)state;- (UIImage *)maximumTrackImageForState:(UIControlState)state; 对应的设置当前状态的响应属性的方法 @property(nonatomic,readonly) UIImage currentThumbImage;@property(nonatomic,readonly) UIImage currentMinimumTrackImage;@property(nonatomic,readonly) UIImage* currentMaximumTrackImage; 添加触发事件 1[slider addTarget:self action:@selector(log:) forControlEvents:UIControlEventValueChanged]; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISlider","slug":"UISlider","permalink":"http://huishao.cc/tags/UISlider/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIActivityIndicatorView(指示控制器)用法总结","slug":"17iOS UIActivityIndicatorView(指示控制器)用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:40:42.975Z","comments":true,"path":"2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","excerpt":"","text":"对于UIActivityIndicatorView的使用，我们一般会创建一个背景View,设置一定的透明度，然后将UIActivityIndicatorView贴在背景View上，在我们需要的时候将这个view呼出。 初始化UIActivityIndicatorView (instancetype)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style; 这个风格是一个枚举，如下 typedef NS_ENUM(NSInteger, UIActivityIndicatorViewStyle) { //大号白色 UIActivityIndicatorViewStyleWhiteLarge, //白色 UIActivityIndicatorViewStyleWhite, //灰色 UIActivityIndicatorViewStyleGray,}; 初始化之后，还需要给它一个Frame，但是只有前两个位置参数有效，大小参数将没有任何影响。 设置指示器风格： @property(nonatomic) UIActivityIndicatorViewStyle activityIndicatorViewStyle; 设置指示器是否停止动画时隐藏 @property(nonatomic) BOOL hidesWhenStopped; 设置指示器颜色 @property (readwrite, nonatomic, retain) UIColor *color； 让指示器开始动画 (void)startAnimating; 让指示器停止动画 (void)stopAnimating; 获取指示器动画状态 (BOOL)isAnimating; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIActivityIndicatorView","slug":"UIActivityIndicatorView","permalink":"http://huishao.cc/tags/UIActivityIndicatorView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISwitch 用法总结","slug":"16iOS UISwitch 用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:39:45.598Z","comments":true,"path":"2015/04/15/16iOS UISwitch 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/16iOS UISwitch 用法总结/","excerpt":"","text":"iOS 系统开关控件简单使用总结： 初始化： (instancetype)initWithFrame:(CGRect)frame; 这个frame是没有意义的，系统的开关控件大小是确定的。 设置开关开启状态时的颜色 @property(nonatomic, retain) UIColor *onTintColor; 设置开关风格颜色 @property(nonatomic, retain) UIColor *tintColor; 设置开关按钮颜色 @property(nonatomic, retain) UIColor *thumbTintColor; 设置开关开启状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *onImage; 设置开关关闭状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *offImage; 开关的状态 @property(nonatomic,getter=isOn) BOOL on; 手动设置开关状态 (void)setOn:(BOOL)on animated:(BOOL)animated; 一点感想：iOS的系统的UISwitch控件虽然定制性很差，配合IOS7之后的扁平化和俭约的风格，在美观上确实不逊色于任何私人定制的开关控件，在没有特殊需求的情况下，对于开关逻辑，这是一个非常不错的UI交互选择。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISwitch","slug":"UISwitch","permalink":"http://huishao.cc/tags/UISwitch/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UITextField 使用与方法解读","slug":"14iOS UITextField 使用与方法解读","date":"2015-04-13T16:00:00.000Z","updated":"2021-06-02T08:38:34.799Z","comments":true,"path":"2015/04/14/14iOS UITextField 使用与方法解读/","link":"","permalink":"http://huishao.cc/2015/04/14/14iOS UITextField 使用与方法解读/","excerpt":"","text":"UITextField是IOS开发中用户交互中重要的一个控件，常被用来做账号密码框，输入信息框等。 初始化一个文字框： UITextField * textField = [[UITextField alloc]initWithFrame:CGRectMake(100, 30, 100, 100)]; 设置和获取文字框文字： @property(nonatomic,copy) NSString *text; 通过AttributedString创建和获取文字： @property(nonatomic,copy) NSAttributedString *attributedText； 设置字体颜色属性： @property(nonatomic,retain) UIColor *textColor; 设置字体属性： @property(nonatomic,retain) UIFont *font; 设置字体对齐格式： @property(nonatomic)NSTextAlignment textAlignment; 设置输入框风格： @property(nonatomic) UITextBorderStyle borderStyle; 这个风格是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextBorderStyle) { //没有任何边框 UITextBorderStyleNone, //线性边框 UITextBorderStyleLine, //阴影效果边框 UITextBorderStyleBezel, //原型效果边框 UITextBorderStyleRoundedRect}; 设置默认字体属性 @property(nonatomic,copy) NSDictionary *defaultTextAttributes； 这个属性的设置会影响到全部字体的属性。 设置缺省时显示的灰度字符串 @property(nonatomic,copy) NSString *placeholder; 通过AttributedString设置缺省字符串 @property(nonatomic,copy) NSAttributedString *attributedPlaceholder； 设置是否在开始编辑时清空输入框内容 @property(nonatomic) BOOL clearsOnBeginEditing; 设置字体大小是否随宽度自适应（默认为NO） @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 设置最小字体大小 @property(nonatomic) CGFloat minimumFontSize; 设置背景图片（会被拉伸） @property(nonatomic,retain) UIImage *background; 设置禁用时的背景图片 @property(nonatomic,retain) UIImage *disabledBackground; 是否正在编辑（只读属性） @property(nonatomic,readonly,getter=isEditing) BOOL editing; 是否允许更改字符属性字典 @property(nonatomic) BOOL allowsEditingTextAttributes； 设置属性字典 @property(nonatomic,copy) NSDictionary *typingAttributes； 设置清除按钮的显示模式 @property(nonatomic) UITextFieldViewMode clearButtonMode; 这是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextFieldViewMode) { //从不显示 UITextFieldViewModeNever, //编辑的时候显示 UITextFieldViewModeWhileEditing, //非编辑的时候显示 UITextFieldViewModeUnlessEditing, //任何时候都显示 UITextFieldViewModeAlways}; 设置输入框左边的view @property(nonatomic,retain) UIView *leftView; 设置输入框左视图的显示模式 @property(nonatomic) UITextFieldViewMode leftViewMode; 设置输入框右边的view @property(nonatomic,retain) UIView *rightView; 设置输入框右视图的显示模式 @property(nonatomic) UITextFieldViewMode rightViewMode; 设置输入框成为第一响应时弹出的视图和辅助视图（类似键盘） @property (readwrite, retain) UIView inputView;@property (readwrite, retain) UIView inputAccessoryView; 这个属性设置是否允许再次编辑时在内容中间插入内容 @property(nonatomic) BOOL clearsOnInsertion； 注销第一响应（収键盘） (BOOL)endEditing:(BOOL)force; UITextFieldDelegate 代理中的方法 点击输入框时触发的方法，返回YES则可以进入编辑状态，NO则不能。 (BOOL)textFieldShouldBeginEditing:(UITextField *)textField; 开始编辑时调用的方法 (void)textFieldDidBeginEditing:(UITextField *)textField; 将要结束编辑时调用的方法，返回YES则可以结束编辑状态，NO则不能 (BOOL)textFieldShouldEndEditing:(UITextField *)textField; 结束编辑调用的方法 (void)textFieldDidEndEditing:(UITextField *)textField; 输入字符时调用的方法 (BOOL)textField:(UITextField )textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString )string; 点击清除按钮时调用的函数，返回YES则可以清除，点击NO则不能清除 (BOOL)textFieldShouldClear:(UITextField *)textField; 点击return键触发的函数 (BOOL)textFieldShouldReturn:(UITextField *)textField; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITextField","slug":"UITextField","permalink":"http://huishao.cc/tags/UITextField/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISegmentedControl","slug":"13iOS UISegmentedControl","date":"2015-04-12T16:00:00.000Z","updated":"2021-06-02T08:36:44.741Z","comments":true,"path":"2015/04/13/13iOS UISegmentedControl/","link":"","permalink":"http://huishao.cc/2015/04/13/13iOS UISegmentedControl/","excerpt":"","text":"SegmentedControl又被称作分段控制器，是IOS开发中经常用到的一个UI控件。 初始化方法：传入的数组可以是字符串也可以是UIImage对象的图片数组 (instancetype)initWithItems:(NSArray *)items; 设置控件风格： @property(nonatomic) UISegmentedControlStyle segmentedControlStyle 注意：这个属性已经废弃，不再起任何作用，它的枚举如下： typedef NS_ENUM(NSInteger, UISegmentedControlStyle) { UISegmentedControlStylePlain, // large plain UISegmentedControlStyleBordered, // large bordered UISegmentedControlStyleBar, // small button/nav bar style. tintable UISegmentedControlStyleBezeled, // DEPRECATED. Do not use this style.} NS_DEPRECATED_IOS(2_0, 7_0, “The segmentedControlStyle property no longer has any effect”); 设置是否保持选中状态： @property(nonatomic,getter=isMomentary) BOOL momentary; 注意：如果设置为YES，点击结束后，将不保持选中状态，默认为NO 获取标签个数：(只读) @property(nonatomic,readonly) NSUInteger numberOfSegments; 设置标签宽度是否随内容自适应： @property(nonatomic) BOOL apportionsSegmentWidthsByContent； 注意：如果设置为NO，则所有标签宽度一致，为最大宽度。 插入文字标签在index位置： (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated 插入图片标签在index位置 (void)insertSegmentWithImage:(UIImage *)image atIndex:(NSUInteger)segment animated:(BOOL)animated 根据索引删除标签 (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated; 删除所有标签 (void)removeAllSegments; 重设标签标题 (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment; 获取标签标题 (NSString *)titleForSegmentAtIndex:(NSUInteger)segment; 设置标签图片 (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment; 获取标签图片 (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment; 注意：标题的图片只能设置一个 根据索引设置相应标签宽度 (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;注意：如果设置为0.0，则为自适应，默认为此设置。 根据索引获取标签宽度 (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment; 设置标签内容的偏移量 (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment; 注意：这个偏移量指的是标签的文字或者图片 根据索引获取变标签内容的偏移量 (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment; 根据所以设置标签是否有效(默认有效) (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment; 根据索引获取当前标签是否有效 (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment; 设置和获取当前选中的标签索引 @property(nonatomic) NSInteger selectedSegmentIndex; 设置标签风格颜色 @property(nonatomic,retain) UIColor *tintColor; 注意：这个风格颜色会影响标签的文字和图片 设置特定状态下segment的背景图案 (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 注意：UIBarMetrics是一个枚举，如下：(defaulf风格会充满背景) typedef NS_ENUM(NSInteger, UIBarMetrics) { UIBarMetricsDefault, UIBarMetricsCompact, UIBarMetricsDefaultPrompt = 101, // Applicable only in bars with the prompt property, such as UINavigationBar and UISearchBar UIBarMetricsCompactPrompt, UIBarMetricsLandscapePhone NS_ENUM_DEPRECATED_IOS(5_0, 8_0, &quot;Use UIBarMetricsCompact instead&quot;) = UIBarMetricsCompact, UIBarMetricsLandscapePhonePrompt NS_ENUM_DEPRECATED_IOS(7_0, 8_0, &quot;Use UIBarMetricsCompactPrompt&quot;) = UIBarMetricsCompactPrompt, }; 获取背景图案 (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 设置标签之间分割线的图案 (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 获取标签之间分割线的图案 (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 通过Attribute字符串属性字典设置标签标题 (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state 获取Attribute字符串属性字典 (NSDictionary *)titleTextAttributesForState:(UIControlState)state 自行设置标签内容的偏移量 (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 注意：UIOffset为偏移量，这个结构体中又两个浮点数，分别表示水平量和竖直量；UISegmentedControlSegment类型参数是一个枚举，如下： typedef NS_ENUM(NSInteger, UISegmentedControlSegment) { UISegmentedControlSegmentAny = 0,//所有标签都受影响 UISegmentedControlSegmentLeft = 1, //只有左边部分受到影响 UISegmentedControlSegmentCenter = 2, // 只有中间部分受到影响 UISegmentedControlSegmentRight = 3, // 只有右边部分受到影响 UISegmentedControlSegmentAlone = 4, // 在只有一个标签的时候生效}; 获取自定义偏移量 (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 添加点击事件 [segmentedControl addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISegmentedControl","slug":"UISegmentedControl","permalink":"http://huishao.cc/tags/UISegmentedControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIButton解读","slug":"12iOS UIButton解读","date":"2015-04-10T16:00:00.000Z","updated":"2021-06-02T08:35:20.122Z","comments":true,"path":"2015/04/11/12iOS UIButton解读/","link":"","permalink":"http://huishao.cc/2015/04/11/12iOS UIButton解读/","excerpt":"","text":"UIButton控件是应用界面中常用的一个控件，用法总结： 一、初始化 UIButton的初始化一般使用其类方法，+ (id)buttonWithType:(UIButtonType)buttonType; 风格的枚举如下： typedef NS_ENUM(NSInteger, UIButtonType) { //用户自定义，无风格 UIButtonTypeCustom = 0, //系统默认风格 UIButtonTypeSystem NS_ENUM_AVAILABLE_IOS(7_0), //一下这三种创建出来的按钮一样，一个蓝色的圆圈，中间有个叹号 UIButtonTypeDetailDisclosure, UIButtonTypeInfoLight, UIButtonTypeInfoDark, //创建+号按钮 UIButtonTypeContactAdd, //废弃 UIButtonTypeRoundedRect = UIButtonTypeSystem,}; 二、属性设置 @property(nonatomic) UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR;//这个属性设置button里内容的偏移量，包括title和image，可以用如下方法设置btn.contentEdgeInsets=UIEdgeInsetsMake(20, 20, 0, 0); @property(nonatomic) UIEdgeInsets titleEdgeInsets;//这个属性设置标题的偏移量@property(nonatomic) BOOL reversesTitleShadowWhenHighlighted;//按钮高亮时，是否改变阴影效果@property(nonatomic) UIEdgeInsets imageEdgeInsets;//图片的偏移量@property(nonatomic)BOOL adjustsImageWhenHighlighted;//设置图片的绘制是否高亮时变暗@property(nonatomic)BOOL adjustsImageWhenDisabled;//设置图片是否轻绘制当按钮禁用时@property(nonatomic)BOOL showsTouchWhenHighlighted;//设置是否显示手指印在按钮高亮的时候@property(nonatomic,retain) UIColor *tintColor NS_AVAILABLE_IOS(5_0);//这个属性会作用于标题和图片，但是如果你是自定义风格的按钮，这个属性将不起任何作用，它只作用于系统的@property(nonatomic,readonly) UIButtonType buttonType;//设置button的风格 三、一些set方法 (void)setTitle:(NSString *)title forState:(UIControlState)state;//设置标题和显示当前标题的按钮状态 (void)setTitleColor:(UIColor *)color forState:(UIControlState)state;//设置标题颜色和显示当前颜色的按钮状态 (void)setTitleShadowColor:(UIColor *)color forState:(UIControlState)state;//设置标题阴影颜色及显示时的状态 (void)setImage:(UIImage *)image forState:(UIControlState)state;//设置按钮图片和显示当前图片时的状态 (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state;//设置按钮背景图片和显示图片时的状态 (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state NS_AVAILABLE_IOS(6_0);//通过AttributeString创建标题 注意：按钮图片设置和背景图片的不同在于： 1、设置图片，如果有标题会和标题并列显示 2、设置背景图片会出现在标题下面 3、图片的偏移量可以设置，背景图片不可以。 四、一些get方法，可以得到上述设置的属性 (NSString *)titleForState:(UIControlState)state; (UIColor *)titleColorForState:(UIControlState)state; (UIColor *)titleShadowColorForState:(UIControlState)state; (UIImage *)imageForState:(UIControlState)state; (UIImage *)backgroundImageForState:(UIControlState)state; (NSAttributedString *)attributedTitleForState:(UIControlState)state NS_AVAILABLE_IOS(6_0); 五、一些只读属性 @property(nonatomic,readonly,retain) NSString currentTitle;@property(nonatomic,readonly,retain) UIColor currentTitleColor;@property(nonatomic,readonly,retain) UIColor currentTitleShadowColor;@property(nonatomic,readonly,retain) UIImage currentImage;@property(nonatomic,readonly,retain) UIImage currentBackgroundImage;@property(nonatomic,readonly,retain) NSAttributedString currentAttributedTitle NS_AVAILABLE_IOS(6_0);//这两个参数需要注意，虽然他们是只读属性不能重新设置，但是我们可以设置label和imageView的相关属性@property(nonatomic,readonly,retain) UILabel titleLabel NS_AVAILABLE_IOS(3_0);@property(nonatomic,readonly,retain) UIImageView imageView NS_AVAILABLE_IOS(3_0); 六、下面这些函数，都会返回一个CGRect 矩形范围 (CGRect)backgroundRectForBounds:(CGRect)bounds;//返回背景大小 (CGRect)contentRectForBounds:(CGRect)bounds;//返回视图大小，包括标题和图片 (CGRect)titleRectForContentRect:(CGRect)contentRect;//返回标题大小 (CGRect)imageRectForContentRect:(CGRect)contentRect;//返回图片大小 关于触发事件，button是继承于UIControl,这里不再叙述。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIButton","slug":"UIButton","permalink":"http://huishao.cc/tags/UIButton/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS 封装静态库(.a文件)","slug":"11iOS 封装静态库(.a文件)","date":"2015-04-10T16:00:00.000Z","updated":"2021-06-02T08:33:44.701Z","comments":true,"path":"2015/04/11/11iOS 封装静态库(.a文件)/","link":"","permalink":"http://huishao.cc/2015/04/11/11iOS 封装静态库(.a文件)/","excerpt":"","text":"iOS中导入外部文件，一种是将源码导入，一种是导入静态库，有很多第三方库都是以静态库的形式提供给我们使用的，如何制作一个静态库呢？ 一、xCode创建文件时，选择创建静态库文件：cacoaTouchStaticLibrary 创建完成后，我们在里面写我们的方法和实现： .h文件和.m文件 1234#import &lt;Foundation/Foundation.h&gt;@interface MyStaticLibrary : NSObject-(void)myLog;@end 123456#import &quot;MyStaticLibrary.h&quot;@implementation MyStaticLibrary-(void)myLog&#123; NSLog(@&quot;myLog&quot;);&#125;@end 二、生成静态库文件：这里需要将设备选成IOS Device然后 使用command+B进行编译，如果xcode报出这样的一个错误：我们需要在Peoject-&gt;Code Signing -&gt;Code Signing Identity 改成IOS Developer再次编译，成功。然后你会看到，Products中的.a文件由红色编程了黑色。我们右键show in finder，就可以看到编译成功的静态库文件了。 三、合并静态库 在文件夹中，我们看到有两个.a文件，分别用在模拟器调试和真机调试中，如果我们在开发时需要真机模拟器不停的切换，我们可以将这两个静态库文件合并成为一个： 在终端使用：lipo -create -output 命令： 这时，我们的静态库文件就做好了。 三、静态库文件的使用： 将.a和.h文件导入工程，在需要的文件中导入头文件，即可使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"静态库","slug":"静态库","permalink":"http://huishao.cc/tags/静态库/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSInvocation应用与理解","slug":"09iOS NSInvocation应用与理解","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:36:47.104Z","comments":true,"path":"2015/04/10/09iOS NSInvocation应用与理解/","link":"","permalink":"http://huishao.cc/2015/04/10/09iOS NSInvocation应用与理解/","excerpt":"","text":"IOS中有一个类型是SEL，它的作用很相似与函数指针，通过performSelector:withObject:函数可以直接调用这个消息。但是perform相关的这些函数，有一个局限性，其参数数量不能超过2个，否则要做很麻烦的处理，与之相对，NSInvocation也是一种消息调用的方法，并且它的参数没有限制。这两种直接调用对象消息的方法，在IOS4.0之后，大多被block结构所取代，只有在很老的兼容性系统中才会使用，简单用法总结如下： 一、初始化与调用 在官方文档中有明确说明，NSInvocation对象只能使用其类方法来初始化，不可使用alloc/init方法。它执行调用之前，需要设置两个方法：setSelector: 和setArgument:atIndex： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog); //创建一个函数签名，这个签名可以是任意的,但需要注意，签名函数的参数数量要和调用的一致。 NSMethodSignature * sig = [NSNumber instanceMethodSignatureForSelector:@selector(init)]; //通过签名初始化 NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; //设置target [invocatin setTarget:self]; //设置selecteor [invocatin setSelector:myMethod]; //消息调用 [invocatin invoke]; &#125;-(void)myLog&#123; NSLog(@&quot;MyLog&quot;);&#125; 注意：签名函数的参数数量要和调用函数的一致。测试后发现，当签名函数参数数量大于被调函数时，也是没有问题的。 调用多参数的方法，我们可以这样写： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 注意：1、这里设置参数的Index 需要从2开始，因为前两个被selector和target占用。下面这样写也没有任何问题： 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); SEL myMethod2 = @selector(myLog); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; ViewController * view = self; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 2、这里的传参方式必须是传递参数地址。 二、NSInvocation的返回值 NSInvocation对象，是可以有返回值的，然而这个返回值，并不是其所调用函数的返回值，需要我们手动设置： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; ViewController * view = self; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; //我们将c的值设置为返回值 [invocatin setReturnValue:&amp;c]; int d; //取这个返回值 [invocatin getReturnValue:&amp;d]; NSLog(@&quot;%d&quot;,d); &#125;-(int)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c); return a+b+c;&#125; 注意：这里的操作传递的都是地址。如果是OC对象，也是取地址。 三、关于内存 可以注意到- (void)retainArguments;这个方法，它会将传入的所有参数以及target都retain一遍。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSInvocation","slug":"NSInvocation","permalink":"http://huishao.cc/tags/NSInvocation/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSTimer 定时器用法总结","slug":"10iOS NSTimer 定时器用法总结","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:37:50.677Z","comments":true,"path":"2015/04/10/10iOS NSTimer 定时器用法总结/","link":"","permalink":"http://huishao.cc/2015/04/10/10iOS NSTimer 定时器用法总结/","excerpt":"","text":"NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下： 一、初始化方法：有五种初始化方法，分别是 + (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个Invocation对象 NSInvocation * invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(init)]]; [invo setTarget:self]; [invo setSelector:@selector(myLog)]; NSTimer * timer = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES]; //加入主循环池中 [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; //开始循环 [timer fire];&#125; + (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 1 NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES]; + (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:NO] + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:@&quot;123&quot; repeats:YES] - (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep 12 NSTimer * timer = [[NSTimer alloc]initWithFireDate:[NSDate distantPast] interval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; 注意：这五种初始化方法的异同： 1、参数repeats是指定是否循环执行，YES将循环，NO将只执行一次。 2、timerWithTimeInterval这两个类方法创建出来的对象如果不用 addTimer: forMode方法手动加入主循环池中，将不会循环执行。并且如果不手动调用fair，则定时器不会启动。 3、scheduledTimerWithTimeInterval这两个方法不需要手动调用fair，会自动执行，并且自动加入主循环池。 4、init方法需要手动加入循环池，它会在设定的启动时间启动。 二、成员变量 @property (copy) NSDate *fireDate; 这是设置定时器的启动时间，常用来管理定时器的启动与停止 1234 //启动定时器 timer.fireDate = [NSDate distantPast]; //停止定时器 timer.fireDate = [NSDate distantFuture]; @property (readonly) NSTimeInterval timeInterval; 这个是一个只读属性，获取定时器调用间隔时间。 @property NSTimeInterval tolerance; 这是7.0之后新增的一个属性，因为NSTimer并不完全精准，通过这个值设置误差范围。 @property (readonly, getter=isValid) BOOL valid; 获取定时器是否有效 @property (readonly, retain) id userInfo; 获取参数信息 三、关于内存释放 如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。所以我们需要这样做： 123456789101112131415161718-(void)dealloc&#123; NSLog(@&quot;dealloc:%@&quot;,[self class]);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; timer= [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(btn) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;-(void)btn&#123; if (timer.isValid) &#123; [timer invalidate]; &#125; timer=nil; [self dismissViewControllerAnimated:YES completion:nil];&#125; 在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSTimer","slug":"NSTimer","permalink":"http://huishao.cc/tags/NSTimer/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS 中block结构的简单用法","slug":"08iOS 中block结构的简单用法","date":"2015-04-08T16:00:00.000Z","updated":"2021-05-31T03:35:27.069Z","comments":true,"path":"2015/04/09/08iOS 中block结构的简单用法/","link":"","permalink":"http://huishao.cc/2015/04/09/08iOS 中block结构的简单用法/","excerpt":"","text":"自从block出现之后，很多API都开始采用这样的结构，由此可见，block确实有许多优势存在，这里将一些简单用法总结如下： 一、如何声明一个block变量 我们通过^符号来声明block类型，形式如下： void (^myBlock)(); 其中第一个void是返回值，可以是任意类型，中间括号中^后面的是这个block变量的名字，我把它命名为myBlock，最后一个括号中是参数，如果多参数，可以写成如下样式： int (^myBlock)(int,int); 同样，你也可以给参数起名字： int (^myBlock)(int a,int b); 很多时候，我们需要将我们声明的block类型作为函数的参数，也有两种方式： 1、-(void)func:(int (^)(int a,int b))block； 第二种方式是通过typedef定义一种新的类型，这也是大多数情况下采用的方式： 2、typedef int (^myBlock)(int a,int b) ; -(void)func:(myBlock)block ; 二、如何实现一个block 既然block可以被声明为变量，那么就一定可以实现它，就像其他类型变量的赋值。我自己对block的理解为它是一断代码块，所以给它赋值赋便是一段代码段： 1234567891011121314151617typedef int (^myBlock)(int,int) ;@interface ViewController ()&#123; myBlock block1;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. block1 =^(int a, int b)&#123; return a+b; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 这里打印的结果是2，从这里可以发现block和函数的功能很像。 注意：1、在上面的代码里 block1是一个对象，如果直接打印将打印对象地址 2、block()，加上后面的括号才是执行block语句块 三、block中访问对象的微妙关系 1、如果你在一个block块中仅仅访问对象，而不是对他进行修改操作，是没有任何问题的： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; int count= tem+1; return count; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 而如果我在block块中直接修改，编译器会报错： 1234 block1 = ^(int a,int b)&#123; tem+=1; return tem+1; &#125;; 为什么会出现这样的情况，根据猜测，可能是block内部将访问的变量都备份了一份，如果我们在内部修改，外部的变量并不会被修改，我们可以通过打印变量的地址来证明这一点： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; int tem=2; NSLog(@&quot;%p&quot;,&amp;tem); block1 = ^(int a,int b)&#123; NSLog(@&quot;%p&quot;,&amp;tem); return tem+1; &#125;; NSLog(@&quot;%d&quot;,block1(1,1)); &#125; 打印结果如下： 可以看出，变量的地址已经改变。 2、__block 做了什么 为了可以在block块中访问并修改外部变量，我们常会把变量声明成__block类型，通过上面的原理，可以发现，其实这个关键字只做了一件事，如果在block中访问没有添加这个关键字的变量，会访问到block自己拷贝的那一份变量，它是在block创建的时候创建的，而访问加了这个关键字的变量，则会访问这个变量的地址所对应的变量。我们可以通过代码来证明： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; tem=4; NSLog(@&quot;%d&quot;,block1(1,1)); block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; __block int tem2=2; tem2=4; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 结果： 3、一点点扩展 由此，我们可以理解，如果block中操作的对象是指针，那么直接可以进行修改，这包括OC对象，如果不是，则需要用__block关键字修饰。 4、关于引用计数 在block中访问的对象，会默认retain： 1234567 UIImage * number; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 结果如下： 而添加__block的对象不会被retain; 注意：如果我们访问类的成员变量，或者通过类方法来访问对象，那么这些对象不会被retain，而类对象会被return，最常见的时self: 1234567891011121314151617181920212223242526272829303132typedef void(^myBlock)(int,int) ;@interface ViewController2 ()&#123; myBlock block1; __block UIImage * number; &#125;@end@implementation ViewController2-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number));&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; //block1(1,1); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 打印结果： 可以看出，UIImage对象没有被retain,而self也将循环引用，造成内存泄露。解决方法如下： 1234567 number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIImage * im = number; block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)im)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 打印结果： 注意：根据这个机制，如果我们将block用来传值，在block不用时，务必要置为nil,而在实现block的方法里，务必要释放;我们通过代码来解释： 首先，创建三个ViewController，为ViewController1，ViewController2，ViewController3； 1、在ViewController1中创建一个按钮，跳转ViewController2 2、在ViewController2中： 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController2.h&quot;#import &quot;ViewController3.h&quot;@interface ViewController2 ()&#123; UIButton * im;&#125;@end@implementation ViewController3-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(300, 300, 100, 100); btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; im = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; im.backgroundColor=[UIColor blackColor]; [im addTarget:self action:@selector(rele) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:im];&#125;-(void)rele&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController3 alloc]init]; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 3、在ViewController3中： 12345678910111213141516171819202122#import &quot;ViewController3.h&quot;void (^myBlock)();@implementation ViewController3-(void)setBlock:(void(^)())block&#123; myBlock = [block copy];&#125;-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; myBlock(); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 通过打印信息，我们会发现，ViewController2不被释放，原因是其成员变量im被block中retain没有释放，我们这样做： 1234567891011121314151617@interface ViewController2 ()&#123; UIButton * im; ViewController3 * tem;&#125;-(void)rele&#123; [tem setBlock:nil]; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController2 alloc]init]; tem=con; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 这样就解决了内存问题。 四、关于block的作用域 应避免将花括号中的block用于外面，如果需要，你可以将这个block声明为全局的。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"Block","slug":"Block","permalink":"http://huishao.cc/tags/Block/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中使用NSAttributedString灵活创建标签","slug":"07iOS中使用NSAttributedString灵活创建标签","date":"2015-04-07T16:00:00.000Z","updated":"2021-05-31T03:33:47.188Z","comments":true,"path":"2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","link":"","permalink":"http://huishao.cc/2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","excerpt":"","text":"灵活使用NSAttributedString可以更轻松的创建出内容复杂的标签。需要注意一点：如果一个label设置了这个属性，那它其他的设置都将失效。 首先，我们初始化一个NSMutableAttributedString对象。 12345678//通过字符串初始化//- (instancetype)initWithString:(NSString *)str;//通过字符串和属性字典直接初始化//- (instancetype)initWithString:(NSString *)str attributes:(NSDictionary *)attrs;//通过自身对象初始化//- (instancetype)initWithAttributedString:(NSAttributedString *)attrStr; NSMutableAttributedString * attribute = [[NSMutableAttributedString alloc]initWithString:@&quot;123!@#你好么QWE&quot;]; 可以通过下面两个函数对attrebute字符串进行设置与修改 123456//可以替换字符- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;//属性设置- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;//设置一定范围内字符属性- (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; 字典的键值对应如下： 123456789101112131415161718//kCTFontAttributeName 这个键是字体的名称 必须传入CTFont对象//kCTKernAttributeName 这个键设置字体间距 传入必须是数字对象 默认为0//kCTLigatureAttributeName 这个键设置连字方式 必须传入CFNumber对象//kCTParagraphStyleAttributeName 段落对其方式//kCTForegroundColorAttributeName 字体颜色 必须传入CGColor对象//kCTStrokeWidthAttributeName 笔画宽度 必须是CFNumber对象//kCTStrokeColorAttributeName 笔画颜色//kCTSuperscriptAttributeName 控制垂直文本定位 CFNumber对象//kCTUnderlineColorAttributeName 下划线颜色[attribute addAttribute:(NSString*)kCTKernAttributeName value:@5 range:NSMakeRange(0, 5)];[attribute addAttribute:(NSString *)kCTFontAttributeName value:(id)CFBridgingRelease(CTFontCreateWithName((CFStringRef)[UIFont boldSystemFontOfSize:14].fontName, 14, NULL)) range:NSMakeRange(0, 4)]; [attribute addAttribute:(NSString *)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; 通过测试，发现上面有些键值并没有作用，可以替换下面的方法，效果相同，不同的地方在于其传值的类型不同，下面的方法更加方便（使用UIFont UIColor NSString 和一些系统枚举） 1234567891011121314151617181920 NSParagraphStyleAttributeNameNSForegroundColorAttributeNameNSBackgroundColorAttributeNameNSLigatureAttributeNameNSKernAttributeNameNSStrikethroughStyleAttributeNameNSUnderlineStyleAttributeNameNSStrokeColorAttributeName NSStrokeWidthAttributeName NSShadowAttributeName NSTextEffectAttributeNameNSAttachmentAttributeName NSLinkAttributeName NSBaselineOffsetAttributeName NSUnderlineColorAttributeNameNSStrikethroughColorAttributeNameNSObliquenessAttributeName NSExpansionAttributeName NSWritingDirectionAttributeNameNSVerticalGlyphFormAttributeName 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://huishao.cc/tags/NSAttributedString/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UILabe及UIFont用法总结","slug":"06iOS UILabe及UIFont用法总结","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:32:56.548Z","comments":true,"path":"2015/04/07/06iOS UILabe及UIFont用法总结/","link":"","permalink":"http://huishao.cc/2015/04/07/06iOS UILabe及UIFont用法总结/","excerpt":"","text":"初始化一个UILabel对象，并初始化大小 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置显示的文字 label.text=@”123”; 和字体相关的一个类，字号大小默认17 @property(nonatomic,retain) UIFont*font; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//7.0之后可用 设置字体风格// NSString *const UIFontTextStyleHeadline; 用于标题的风格// NSString *const UIFontTextStyleSubheadline;用于副标题的风格// NSString *const UIFontTextStyleBody;用于正文的字体// NSString *const UIFontTextStyleFootnote;用于脚注的字体// NSString *const UIFontTextStyleCaption1;用于标准字幕字体// NSString *const UIFontTextStyleCaption2;用于替换字幕字体 label.font=[UIFont preferredFontForTextStyle:UIFontTextStyleCaption2];//说实话，没看出什么太大的差别//设置字体和字体大小+ (UIFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize;//返回所有字体的字体家族名称数组+ (NSArray *)familyNames;//按字体家族名称返回字体名称数组+ (NSArray *)fontNamesForFamilyName:(NSString *)familyName;//设置普通字体字号大小+ (UIFont *)systemFontOfSize:(CGFloat)fontSize;//设置加粗字体字号大小+ (UIFont *)boldSystemFontOfSize:(CGFloat)fontSize;//设置斜体字号大小+ (UIFont *)italicSystemFontOfSize:(CGFloat)fontSize;//一些只读属性//字体家族名称@property(nonatomic,readonly,retain) NSString *familyName;//字体名称@property(nonatomic,readonly,retain) NSString *fontName;//字号大小@property(nonatomic,readonly) CGFloat pointSize;//字体设计模型，表示距离最高点偏移余量@property(nonatomic,readonly) CGFloat ascender;//底部的模型偏移量@property(nonatomic,readonly) CGFloat descender;//字体模型的头高信息@property(nonatomic,readonly) CGFloat capHeight;//字体模型的xHeight信息@property(nonatomic,readonly) CGFloat xHeight;//字体行高@property(nonatomic,readonly) CGFloat lineHeight NS_AVAILABLE_IOS(4_0);//模型主体信息@property(nonatomic,readonly) CGFloat leading;//创建一个新字体与当前字体相同，除了指定的大小- (UIFont *)fontWithSize:(CGFloat)fontSize;//通过描述信息返回字体 7.0后可用+ (UIFont *)fontWithDescriptor:(UIFontDescriptor *)descriptor size:(CGFloat)pointSize NS_AVAILABLE_IOS(7_0);//返回字体的描述信息，7.0后可用- (UIFontDescriptor *)fontDescriptor NS_AVAILABLE_IOS(7_0); 设置字体颜色 label.textColor=[UIColor redColor]; 设置阴影偏移量 label.shadowOffset=CGSizeMake(20, 20); 设置阴影颜色 label.shadowColor=[UIColor blackColor]; 设置对齐模式 label.textAlignment=NSTextAlignmentJustified; 1234567891011enum &#123; //沿左边沿对齐文本 NSTextAlignmentLeft = 0, //中心对齐 NSTextAlignmentCenter = 1, //右边沿对齐 NSTextAlignmentRight = 2, //最后一行自然对齐 NSTextAlignmentJustified = 3, //默认对齐 NSTextAlignmentNatural = 4,&#125;;typedef NSInteger NSTextAlignment; 多行文本设置 label.lineBreakMode=NSLineBreakByCharWrapping; 12345678910111213enum &#123; //文本边缘处理 NSLineBreakByWordWrapping = 0, //提前处理不合适的字符 NSLineBreakByCharWrapping, //简单线性处理 NSLineBreakByClipping, //丢失的开头用省略号表示 NSLineBreakByTruncatingHead, //丢失的文本在末尾显示省略号 NSLineBreakByTruncatingTail, //丢失的文本在中间显示省略号 NSLineBreakByTruncatingMiddle &#125;;typedef NSUInteger NSLineBreakMode 使用attributedText绘制 @property(nonatomic,copy) NSAttributedString *attributedText 设置高亮的字体颜色 label.highlightedTextColor=[UIColor blueColor]; //设置是否高亮 label.highlighted=YES; 用户交互 默认关闭 label.userInteractionEnabled=NO; 是否有效，默认是YES，无效为灰色 label.enabled=NO; 显示的行数，0为无限 @property(nonatomic) NSInteger numberOfLines; 宽度自适应大小 默认是NO @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 字符适应宽度：不赞成使用 @property(nonatomic) BOOL adjustsLetterSpacingToFitWidth 最小适应大小2.0-6.0 @property(nonatomic) CGFloat minimumFontSize 最小适应大小 6.0 之后 @property(nonatomic) CGFloat minimumScaleFactor 垂直方向的调整 @property(nonatomic) UIBaselineAdjustment baselineAdjustment; 1234567typedef enum &#123; //调整文本对应基线位置 UIBaselineAdjustmentAlignBaselines, //调整文本相对其边框的中心 UIBaselineAdjustmentAlignCenters, //调整文本相对于边界的左上角 默认的 UIBaselineAdjustmentNone,&#125; UIBaselineAdjustment; 返回文本绘制矩形 - (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines; 文本绘制函数 - (void)drawTextInRect:(CGRect)rect 文本自动布局参数 @property(nonatomic) CGFloat preferredMaxLayoutWidth 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UILabel","slug":"UILabel","permalink":"http://huishao.cc/tags/UILabel/"},{"name":"UIFont","slug":"UIFont","permalink":"http://huishao.cc/tags/UIFont/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS6中横屏的处理方法","slug":"05iOS6中横屏的处理方法","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:33:03.710Z","comments":true,"path":"2015/04/07/05iOS6中横屏的处理方法/","link":"","permalink":"http://huishao.cc/2015/04/07/05iOS6中横屏的处理方法/","excerpt":"","text":"IOS6以后，若想在项目中支持横屏，我们首先需要在plist文件中添加支持横屏的设置，否则有些代码设置将会失效。 有来那个方式设置： 1、在pilist的Supported interface orientations 字段中添加 2、在Xcode的设置中勾选 现在我们来看决定屏幕方向的几个函数： 在IOS6之前，我们只需通过一个函数 - (BOOL) shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation { return (toInterfaceOrientation == UIInterfaceOrientationLandscapeRight);} 就可以支持指定控制器的旋转。通过新的文档，我们可以看到： 1234// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);//这个方法在6.0之后被标记为过时的 我们通过下面两个方法来代替： //是否允许屏幕旋转 -(BOOL)shouldAutorotate{ return YES;}//支持的方向- (NSUInteger)supportedInterfaceOrientations { return UIInterfaceOrientationMaskLandscapeRight;}这是个枚举 123456789101112131415typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown=(1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125;; 通过这两个函数，如果我们需要某个控制器强制方向，我们可以设置支持单一的方向，即可达到目的。 注意： 如果你们项目中的RootViewController是导航，你会发现，你在Push出来的视图中添加刚才的代码并没有起作用，原因是导航，并没有进行设置，我们创建一个文件，继承于NavigationController。在里面重写刚才的方法，这么做后，屏幕确实横了过来，并且这个导航push的所有子界面都将横屏，这也不是我们想要的效果。我们想自由的控制每个push出来的界面的屏幕方向，可以在导航里这么做： 1234567-(BOOL)shouldAutorotate&#123; return [self.topViewController shouldAutorotate];&#125;//支持的方向- (NSUInteger)supportedInterfaceOrientations &#123; return [self.topViewController supportedInterfaceOrientations];;&#125; 我们还需要做一些处理，经过我的测试，导航必须在pop后才会重新调用这些函数，所以我的方法是这样做：弹出一个中间控制器后再POP回来 1234567@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController pushViewController:[[ViewController3 alloc]init] animated:YES];&#125; 1234567@implementation ViewController3- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController popViewControllerAnimated:YES];&#125; 这样做，我们就可以自由的控制每个视图控制器的方向了。 同理，如果根视图控制器是tabBar，则我们需要在tabBar中做操作。 如果我们大多是的视图控制器都是一个方向的，只有偶尔的几个会不同，这时候，我们其实可以采取presentationController的方式，然后直接在弹出的控制器中写那两个方法即可。这是最简单的途径了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"横屏","slug":"横屏","permalink":"http://huishao.cc/tags/横屏/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS SEL的理解与使用","slug":"04iOS SEL的理解与使用","date":"2015-04-04T16:00:00.000Z","updated":"2021-05-28T10:11:35.356Z","comments":true,"path":"2015/04/05/04iOS SEL的理解与使用/","link":"","permalink":"http://huishao.cc/2015/04/05/04iOS SEL的理解与使用/","excerpt":"","text":"有很多人，认为block的推广可取代代理设计模式，其实block并不能取代代理，代理的模式可以让代码逻辑性更强，更整洁，也会有更高的可读性和可扩展性。相比之下，我觉得block更多的是取代了选择器@selector。 @selector是什么？我们要首先明白SEL，SEL并不是一种对象类型，我们通过xCode的字体颜色就可以判断出来，它是一个关键字，就像int，long一样，它声明了一种类型：类方法指针。其实就可以理解为一个函数指针。比如，我们生命一个叫myLog的函数指针： 1234567#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end 声明出了这个指针，我们该如何给它传递这个函数呢？有两种方式： 1、在编译时，使用@selector来取得函数 现在，我们应该明白@selector是什么了，它是一个编译标示，我们通过它来取到相应函数。 12345678910111213141516171819@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = @selector(myLogL); //通过performSelector来执行方法 [self performSelector:myLog];//打印 “myLog” &#125;-(void)myLogL&#123; NSLog(@&quot;myLog&quot;);&#125; 2、在运行时，通过NSSelectorFromString方法来取到相应函数： 12345678910111213141516171819202122#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = NSSelectorFromString(@&quot;myLogN&quot;); [self performSelector:myLog]; &#125;-(void)myLogN&#123; NSLog(@&quot;myLog&quot;);&#125; 这两种方式的差别在于，编译时的方法如果没有找到相应函数，xcode会报错，而运行时的方法不会。 至于SEL的应用，我相信最广泛的便是target——action设计模式了。我们来简单模拟一下系统button的工作原理： 我们先创建一个继承于UIButton的类： .h文件： 12345#import &lt;UIKit/UIKit.h&gt;@interface Mybutton : UIButton-(void)addMyTarget:(id)target action:(SEL)action;@end .m文件 1234567891011121314151617#import &quot;Mybutton.h&quot;@implementation Mybutton&#123; SEL _action; id _target;&#125;-(void)addMyTarget:(id)target action:(SEL)action&#123; _target=target; _action=action;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_target performSelector:_action];&#125;@end 在外部： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; Mybutton * btn = [[Mybutton alloc]initWithFrame:CGRectMake(100, 100, 60, 60)]; btn.backgroundColor=[UIColor redColor]; [btn addMyTarget:self action:@selector(click)]; [self.view addSubview:btn];&#125;-(void)click&#123; NSLog(@&quot;点击了btn&quot;);&#125; 当然，如果要调用参数，系统提供的默认参数不超过两个，如果参数很多，一种是我们可以通过字典传参，另一种方法比较复杂，在这里先不讨论。 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"SEL","slug":"SEL","permalink":"http://huishao.cc/tags/SEL/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS事件响应控制","slug":"03iOS事件响应控制","date":"2015-04-03T16:00:00.000Z","updated":"2021-05-28T10:09:54.887Z","comments":true,"path":"2015/04/04/03iOS事件响应控制/","link":"","permalink":"http://huishao.cc/2015/04/04/03iOS事件响应控制/","excerpt":"","text":"以前遇到一个项目，一个UIImageView对象上面有一个UIButton对象，然而项目的需求需要在点击 button的同时，UIImageView也接收到点击事件，在不使用代理和通知方法的前提下，通过事件响应链的原理，我们也可以很便捷的解决这个问题。 在处理这个问题之前，我们应该先清楚IOS的事件响应机制到底是个什么样的原理。 首先，这个事件响应的机制是分为两个部分的。 1、先在视图层级关系中找到应该响应事件的那个视图。 这一步是什么意思，其实很简单，就是找到你所触摸点对应的那个最上层的视图，它的工作原理是这样的：当用户发出事件后，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会取出队列中最前面的事件，发消息给UIWindow，然后UIWindow会对其所有子视图调用hitTest:withEvent:这个方法，这个方法会返回一个UIView的对象，这个方法在执行的时候，它会调用当前视图的pointInside:withEvent:这个方法，如果触摸事件在当前视图范围内，pointInside:withEvent:会返回YES，否则会返回NO；如果返回YES，则会遍历当前视图的所有子视图，统统发送hitTest:withEvent:这个消息，如果返回NO,则hitTest:withEvent:方法返回nil； 上面说起来有些绕，其实就是：hitTest:withEvent:方法会一层一层的向上找，若最上层响应的子视图pointInside:withEvent:返回YES，则返回此子视图，如果所有的都返回nil，则返回当前视图本身self。 例如：我们建两个文件，一个继承于UIButton，一个继承于UIImageView，我们在UIImageView里的代码如下： 12345678910111213141516171819#import &quot;MyImageView.h&quot;@implementation MyImageView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor=[UIColor redColor]; &#125; return self;&#125;//在这里，我们重写了这个方法，让它直接返回自身，而不是继续向下寻找应该响应事件的视图-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;点击了Image&quot;);&#125; 然后将他们创建在一个View上： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; // Do any additional setup after loading the view, typically from a nib.&#125; 我们运行，点击这个Btn，会打印如下的信息： 可以证明，在事件视图寻找中，UIImageView我们重写hitTest:withEvent:方法后，切断了寻找链，如果我们这个做： 123-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return nil;&#125; 你会发现，UIImageView也不再接收事件。2、寻找到应该响应的视图后，会进行消息处理，这个处理的方式是通过消息处理链来做的。如果它自身不能处理消息，会通过nextResponder将消息传递给下一个处理者，默认只要有一个view将消息处理了，这个消息处理传递链将不再传递。 现在，我们把刚才UIimageView里重写的hitTest:withEvent:方法注释掉，给btn添加一个点击方法，同时将用户交互关闭： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; image.userInteractionEnabled=YES; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click&#123; NSLog(@&quot;btn被点击了&quot;);&#125; 这样，我们的UIImageView又可以响应事件了，原因是事件处理传递链向下传递了。 现在，在回到我们刚开始的问题，如何让btn响应的同时imageView也响应，我们这样做： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; image.userInteractionEnabled=YES; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click:(UIButton *)btn&#123; NSLog(@&quot;btn被点击了&quot;); //响应链继续传递 [btn.nextResponder touchesBegan:nil withEvent:nil]; &#125; 结果如下： 虽然最终，我们完成了这个需求，可是我建议你最好不要这么干，因为这样的逻辑是违背现实生活中人们的行为认知的，更重要的是，我们的项目最后也确实改掉了这样的逻辑~~~ 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"事件","slug":"事件","permalink":"http://huishao.cc/tags/事件/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中DES与MD5加密方案","slug":"02MD","date":"2015-04-02T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/03/02MD/","link":"","permalink":"http://huishao.cc/2015/04/03/02MD/","excerpt":"","text":"MD5算法和DES算法是常见的两种加密算法。 MD5：MD5是一种不可逆的加密算法，按我的理解，所谓不可逆，就是不能解密，那么它有什么用的，它的用处大了，大多数的登录功能都会使用到这种算法。后面根据我的项目经验来介绍。 DES：一种使用密钥加密的块算法，所以，使用它加密时，需要一个密钥，加上一些设置和你需要加密的文段。 在IOS中，使用这两种加密算法非常简单，系统的&lt;CommonCrypto/CommonCrypto.h&gt;库给我们提供的边界的接口。在很多移动项目中，安卓平台和IOS平台的后台服务是统一的，比如一个登录功能是这样的流程： 1、客户端向服务端请求密钥，请求的参数是双方约定好的一个MD5加密的字符串。我们可以通过下面的进行第一步加密： 1234567891011121314- (NSString *)MD5Digest&#123; //要进行UTF8的转码 const char* input = [self UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(input, (CC_LONG)strlen(input), result); NSMutableString *digest = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) &#123; [digest appendFormat:@&quot;%02x&quot;, result[i]]; &#125; return digest;&#125; 通过这样的方法，我们可以很容易的得到一串MD5加密字符串，但是一定要和后台约定好，MD5加密的位数是16位还是32位，用上述方法加密出来的时32位，当然他们之间是有联系的，通过下面的方法可以将其转成16为： 1234567+(NSString *)trransFromMD532ToMD516:(NSString *)MD532&#123; NSString * string; for (int i=0; i&lt;24; i++) &#123; string=[MD532 substringWithRange:NSMakeRange(8, 16)]; &#125; return string;&#125; 还有一点需要注意，加密后的大小写也要对应。 2、服务端将得到的MD5串和以约定好的MD5串进行对比，如果一致，可以放行，返回密钥。 3、客户端取到密钥，将密钥再进行一次MD5加密，然后通过DES将要传送的数据加密发给服务器。 这一步至关重要，我们先看DES的加密代码 12345678910111213141516171819202122232425262728293031+(NSString *) encryptUseDES:(NSString *)clearText key:(NSString *)key andiv:(NSString *)iv&#123; //这个iv 是DES加密的初始化向量，可以用和密钥一样的MD5字符 NSData * date = [iv dataUsingEncoding:NSUTF8StringEncoding]; NSString *ciphertext = nil; NSUInteger dataLength = [clearText length]; NSData *textData = [clearText dataUsingEncoding:NSUTF8StringEncoding]; unsigned char buffer[1024]; memset(buffer, 0, sizeof(char)); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,//加密模式 kCCDecrypt 代表解密 kCCAlgorithmDES,//加密方式 kCCOptionPKCS7Padding,//填充算法 [key UTF8String], //密钥字符串 kCCKeySizeDES,//加密位数 [date bytes],//初始化向量 [textData bytes] , dataLength, buffer, 1024, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; NSLog(@&quot;DES加密成功&quot;); NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted]; Byte* bb = (Byte*)[data bytes]; ciphertext = [Base64 parseByteArray2HexString:bb]; &#125;else&#123; NSLog(@&quot;DES加密失败&quot;); &#125; return ciphertext;&#125; 几点注意： （1）加密方式，IOS官方提供的是如下几种 12345678910enum &#123; kCCAlgorithmAES128 = 0, kCCAlgorithmAES = 0, kCCAlgorithmDES, kCCAlgorithm3DES, kCCAlgorithmCAST, kCCAlgorithmRC4, kCCAlgorithmRC2, kCCAlgorithmBlowfish &#125;; （2）填充算法 123456enum &#123; /* options for block ciphers */ kCCOptionPKCS7Padding = 0x0001, kCCOptionECBMode = 0x0002 /* stream ciphers currently have no options */&#125;; 我们可以发现，官方提供的只有这两种，然而JAVA使用的却是 1kCCOptionPKCS7Padding 但是不用担心，在密钥是8位的时候，这两种填充算法加密出来的结果试一模一样的。 4、服务器通过相同的方式，解密出密文，通配安卓端。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"加密","slug":"加密","permalink":"http://huishao.cc/tags/加密/"},{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"DES","slug":"DES","permalink":"http://huishao.cc/tags/DES/"},{"name":"MD5","slug":"MD5","permalink":"http://huishao.cc/tags/MD5/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"AFNetWorking用法及缓存处理","slug":"01AF","date":"2015-04-01T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/02/01AF/","link":"","permalink":"http://huishao.cc/2015/04/02/01AF/","excerpt":"","text":"AFNetWorking 在IOS开发中是一个经常会用的第三方开源库，其最好处是维护及时，源码开源。 常用GET与POST请求方法： POST请求： 123456789//初始化一个请求对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; //dic 为参数字典 [manager POST:url parameters:dic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; GET请求： 1234567AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; 这里有一个地方需要注意， 1[AFHTTPRequestOperationManager manager] 这个类方法我们点进源码可以发现： 123+ (instancetype)manager &#123; return [[self alloc] initWithBaseURL:nil];&#125; 这里初始化了一个返回了一个新的对象，并不是单例。 使用这样的下载方法，下载完成后的数据AFNetWorking会帮我们自动解析，但是有时候服务器给的数据并不标准，这时我们需要加上这个设置： manager.responseSerializer = [AFHTTPResponseSerializer serializer]; 这样我们将得到原始的HTTP返回给我们数据。 我们再来探究一下，下载成功后，回调方法里的参数到底是什么东西 1success:^(AFHTTPRequestOperation *operation, id responseObject) 其中，第二个参数 responseObject 是下载下来的data数据，可直接进行JSON等解析。 第一个参数，是个AFHTTPRequestOperation对象，来看源文件 123456789@interface AFHTTPRequestOperation : AFURLConnectionOperation@property (readonly, nonatomic, strong) NSHTTPURLResponse *response;@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;@property (readonly, nonatomic, strong) id responseObject;@end 可以发现，里面有一个成员便是responseObject，同时，AFHTTPRequestOperation是继承于AFURLConnectionOperation,我们在看看AFURLConnectionOperation这个类： 123456789101112131415161718192021222324252627282930313233343536373839@interface AFURLConnectionOperation : NSOperation &lt;NSURLConnectionDelegate, NSURLConnectionDataDelegate, NSSecureCoding, NSCopying&gt;@property (nonatomic, strong) NSSet *runLoopModes;@property (readonly, nonatomic, strong) NSURLRequest *request;@property (readonly, nonatomic, strong) NSURLResponse *response;@property (readonly, nonatomic, strong) NSError *error;@property (readonly, nonatomic, strong) NSData *responseData;@property (readonly, nonatomic, copy) NSString *responseString;@property (readonly, nonatomic, assign) NSStringEncoding responseStringEncoding;@property (nonatomic, assign) BOOL shouldUseCredentialStorage;@property (nonatomic, strong) NSURLCredential *credential;@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;@property (nonatomic, strong) NSInputStream *inputStream;@property (nonatomic, strong) NSOutputStream *outputStream;@property (nonatomic, strong) dispatch_queue_t completionQueue;@property (nonatomic, strong) dispatch_group_t completionGroup;@property (nonatomic, strong) NSDictionary *userInfo;- (instancetype)initWithRequest:(NSURLRequest *)urlRequest NS_DESIGNATED_INITIALIZER;- (void)pause;- (BOOL)isPaused;- (void)resume; 看到这里，就离AFNETWorking封装的源头很近了，里面的成员非常多，其中包含了大部分我们需要的信息，可以通过点语法取到，其中有输入输出流，错误信息，请求到的Data数据，以及请求到的字符串数据 1responseString 我们可以通过 1NSLog ( @&quot;operation: %@&quot; , operation. responseString ); 来打印查看请求到的原始信息。 几点注意： 1.关于崩溃url为nil 大多数这样的原因是url中有特殊字符或者中文字符，AFNETWorking并没有做UTF8的转码，需要： 1url = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 2.添加HttpHead字段的方法 1234 //为这个下载任务HTTP头添加@&quot;User-Agent&quot;字段 [manager.requestSerializer setValue:_scrData forHTTPHeaderField:@&quot;User-Agent&quot;]; //打印头信息 NSLog(@&quot;%@&quot;,manager.requestSerializer.HTTPRequestHeaders); 在下载请求中，经常会请求一些不长变化的数据，如果每次APP启动都进行请求，会消耗许多资源，并且有时候缓存的处理，可以大大改善用户体验。 在AFNETWorking中，并没有提供现成的缓存方案，我们可以通过写文件的方式，自行做缓存。 在下载方法中： 1234567[manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //写缓存 NSString *cachePath = @&quot;你的缓存路径&quot;;// /Library/Caches/MyCache [data writeToFile:cachePath atomically:YES]; succsee(data); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; &#125;]; 然后在每次下载前，进行如下判断： 12345 NSString * cachePath = @&quot;你的缓存路径&quot;; if ([[NSFileManager defaultManager] fileExistsAtPath:cachePath]) &#123; //从本地读缓存文件 NSData *data = [NSData dataWithContentsOfFile:cachePath]; &#125; 有时，我们的下载请求可能是用户的动作触发的，比如一个按钮。我们还应该做一个保护机制的处理， 123456789101112131415//初始化一个下载请求数组NSArray * requestArray=[[NSMutableArray alloc]init];//每次开始下载任务前做如下判断for (NSString * request in requestArray) &#123; if ([url isEqualToString:request]) &#123; return; &#125; &#125; [requestArray addObject:url]; //下载成功或失败后 [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [requestArray removeObject:url] &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [requestArray removeObject:url] &#125;]; 至此，一个比较完成AFNETWorking请求使用流程就完成了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"网络","slug":"网络","permalink":"http://huishao.cc/tags/网络/"},{"name":"AFNetWorking","slug":"AFNetWorking","permalink":"http://huishao.cc/tags/AFNetWorking/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]}]}