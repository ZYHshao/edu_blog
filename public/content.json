{"meta":{"title":"珲少的技术博客","subtitle":"专注技术 有趣生活","description":"珲少的技术博客","author":"珲少","url":"http://huishao.cc"},"pages":[],"posts":[{"title":"iOS中动态更新补丁策略JSPatch运用基础一","slug":"190iOS中动态更新补丁策略JSPatch运用基础一","date":"2016-03-23T16:00:00.000Z","updated":"2021-07-06T07:15:26.932Z","comments":true,"path":"2016/03/24/190iOS中动态更新补丁策略JSPatch运用基础一/","link":"","permalink":"http://huishao.cc/2016/03/24/190iOS中动态更新补丁策略JSPatch运用基础一/","excerpt":"","text":"iOS中动态更新补丁策略JSPatch运用基础JSPatch是GitHub上一个开源的框架，其可以通过Objective-C的run-time机制动态的使用JavaScript调用与替换项目中的Objective-C属性与方法。其框架小巧，代码简洁，并且通过系统的JavaScriptCore框架与Objective-C进行交互，这使其在安全性和审核风险上都有很强的优势。Git源码地址：[https://github.com/bang590/JSPatch](https://github.com/bang590/JSPatch)。 一、从一个官方的小demo看起通过cocoapods将JSPath集成进一个Xcode工程中，在AppDelegate类的中编写如下代码： 123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; //开始初始化引擎 [JPEngine startEngine]; //读取js文件 NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;demo&quot; ofType:@&quot;js&quot;]; NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; //运行js文件 [JPEngine evaluateScript:script]; self.window = [[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds]; self.window.rootViewController = [[ViewController alloc]init]; [self.window addSubview:[self genView]]; [self.window makeKeyAndVisible]; return YES;&#125;- (UIView *)genView&#123; UIView * view= [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 320)]; view.backgroundColor = [UIColor redColor]; return view;&#125; 在工程中添加一个js文件，编写如下： 123456789101112131415 require(&apos;UIView, UIColor, UILabel&apos;) //要替换函数的类 defineClass(&apos;AppDelegate&apos;, &#123; //替换函数 //要替换函数的名称 genView: function() &#123; var view = self.ORIGgenView(); view.setBackgroundColor(UIColor.greenColor()) var label = UILabel.alloc().initWithFrame(view.frame()); label.setText(&quot;JSPatch&quot;); label.setTextAlignment(1); view.addSubview(label); return view; &#125; &#125;); 运行工程，可以看到genView方法被替换成了js文件中的方法，原本红色的视图被修改成了绿色。 二、使用JavaScript代码向Objective-C中修改或添加方法JSPatch引擎中支持3中方式进行JavaScript代码的调用，分别是使用JavaScript字符串进行代码运行，读取本地的JavaScript文件进行代码运行和获取网络的JavaScript文件进行代码运行。例如，如果想要通过JavaScript代码在项目中弹出一个警告框，在Objective-C代码中插入如下代码： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // ‘\\’符用于进行换行 [JPEngine evaluateScript:@&quot;\\ var alertView = require(&apos;UIAlertView&apos;).alloc().init();\\ alertView.setTitle(&apos;Alert&apos;);\\ alertView.setMessage(&apos;AlertView from js&apos;); \\ alertView.addButtonWithTitle(&apos;OK&apos;);\\ alertView.show(); \\ &quot;];&#125; 开发者也可以动态在Objective-C类文件中添加方法，例如在ViewController类中编写如下： 123456789- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; [JPEngine startEngine]; NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;demo&quot; ofType:@&quot;js&quot;]; NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil]; [JPEngine evaluateScript:script]; [self performSelectorOnMainThread:@selector(creatView) withObject:nil waitUntilDone:nil];&#125; JavaScript文件代码如下： 12345678910111213 require(&apos;UIView, UIColor, UILabel&apos;) defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method creatView: function() &#123; var view = UIView.alloc().initWithFrame(&#123;x:20, y:20, width:100, height:100&#125;); view.setBackgroundColor(UIColor.greenColor()); var label = UILabel.alloc().initWithFrame(&#123;x:0, y:0, width:100, height:100&#125;); label.setText(&quot;JSPatch&quot;); label.setTextAlignment(1); view.addSubview(label); self.view().addSubview(view) &#125; &#125;); 除了上面的代码，在ViewController.m文件中没有编写任何其他的方法，运行工程，可以看到程序并没有崩溃，ViewController执行了creatView方法。 通过上面的示例，我们发现使用JSPatch可以做一些十分有趣的事。对于iOS应用来说，通过官方渠道AppStore进行应用程序的发布要通过人工审核，有时这个审核周期会非常长，如果在开发者在编写代码时留下了一些小漏洞，应用一旦上线，若要修改掉这个bug就十分艰难了。有了JSPatch，我们可以想象，如果可以定位到线上应用有问题的方法，使用JS文件来修改掉这个方法，这将是多么cool的一件事，事实上，JSPatch的主要用途也是可以实现线上应用极小问题的hotfix。 三、JavaScript与Objective-C交互的基础方法要使用JSPatch来进行Objective-C风格的方法编写，需要遵守一些JavaScript与Objective-C交互的规则。 1.在JavaScript文件中使用Objective-C类 在编写JavaScript代码时如果需要用到Objective-C的类，必须先对这个类进行require引用，例如，如果需要使用UIView这个类，需要在使用前进行如下引用： 1require(&apos;UIView&apos;) 同样也可以一次对多个Objective-C类进行引用： 1require(&apos;UIView, UIColor, UILabel&apos;) 还有一种更加简便的写法，直接在使用的时候对其进行引用： 1require(&apos;UIView&apos;).alloc().init() 2.在JavaScript文件中进行Objective-C方法的调用在进行Objective-C方法的调用时，分为两种，一种是调用类方法，一种是调用类的对象方法。 调用类方法：通过类名打点的方式来调用类方法，格式类似如下，括号内为参数传递： 1UIColor.redColor() 调用实例方法：通过对象打点的方式调用类的实例方法，格式如下，括号内为参数传递： 1view.addSubview(label) 对于Objective-C中的多参数方法，转化为JavaScript将参数分割的位置以_进行分割，参数全部放入后面的括号中，以逗号分割，示例如下： 1view.setBackgroundColor(UIColor.colorWithRed_green_blue_alpha(0,0.5,0.5,1)) 对于Objective-C类的属性变量，在JavaScript中只能使用getter与setter方法来访问，示例如下： 1label.setText(&quot;JSPatch&quot;) 提示：如果原Objective-C的方法中已经包含了_符号，则在JavaScript中使用__代替。 3.在JavaScript中操作与修改Objective-C类JSPatch的最大应用是在应用运行时动态的操作和修改类。 重写或者添加类的方法： 在JavaScript中使用defineClass来定义和修改类中的方法，其编写格式如下所示： 123456/*classDeclaration:要添加或者重写方法的类名 字符串 如果此类不存在 则会创建新的类instanceMethods:要添加或者重写的实例方法 &#123;&#125;classMethods:要添加或者重写的类方法 &#123;&#125;*/defineClass(classDeclaration, instanceMethods, classMethods) 示例如下: 123456789101112131415defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method newFunc: function() &#123; //编写实例方法 self.view().setBackgroundColor(UIColor.redColor()) &#125; &#125;,&#123; myLoad:function()&#123; //编写类方法 &#125; &#125; ) 如果在重写了类中的方法后要调用原方法，需要使用ORIG前缀，示例如下： 123456789defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.ORIGviewDidLoad() &#125; &#125; ) 对于Objective-C中super关键字调用的方法，在JavaScript中可以使用self.super()来调用，例如： 123456789defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.super().viewDidLoad() &#125; &#125; ) 同样JSPatch也可以为类添加临时属性，用于在方法间参数传递，使用set_Prop_forKey()来添加属性，使用getProp()来获取属性，注意，JSPatch添加的属性不能使用Objective-C的setter与getter方法访问，如下： 1234567891011121314defineClass(&apos;ViewController&apos;, &#123; // replace the -genView method viewDidLoad: function() &#123; //编写实例方法 self.super().viewDidLoad() self.setProp_forKey(&quot;JSPatch&quot;, &quot;data&quot;) &#125;, touchesBegan_withEvent(id,touch)&#123; self.getProp(&quot;data&quot;) self.view().setBackgroundColor(UIColor.redColor()) &#125; &#125; ) 关于为类添加协议的遵守，和Objective-C中遵守协议的方式一致，如下： 1234567891011121314151617defineClass(&quot;ViewController2: UIViewController &lt;UIAlertViewDelegate&gt;&quot;, &#123; viewDidAppear: function(animated) &#123; var alertView = require(&apos;UIAlertView&apos;) .alloc() .initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles( &quot;Alert&quot;, &quot;content&quot;, self, &quot;OK&quot;, null ) alertView.show() &#125;, alertView_clickedButtonAtIndex:function(alertView, buttonIndex) &#123; console.log(&apos;clicked index &apos; + buttonIndex) &#125; &#125;) 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}],"tags":[],"keywords":[{"name":"JSPatch","slug":"JSPatch","permalink":"http://huishao.cc/categories/JSPatch/"}]},{"title":"设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框","slug":"189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框","date":"2016-03-22T16:00:00.000Z","updated":"2021-07-06T07:14:19.973Z","comments":true,"path":"2016/03/23/189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框/","link":"","permalink":"http://huishao.cc/2016/03/23/189设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框/","excerpt":"","text":"设计iOS中随系统键盘弹收和内容文字长度自适应高度的文本框文本输入框是多数与社交相关的app中不可或缺的一个控件，这些文本输入框应该具备如下的功能： 1.在键盘为弹起时，输入框悬浮在界面底部。 2.当键盘弹起时，输入框位置上移至键盘上方，并且动画应与键盘同步。 3.当输入的文字超出一行时，输入框应想用的进行高度扩展。 4.当输入框的高度达到某一极限值时，输入框高度不应继续扩展，文字区域应该支持滑动。 使用autolayout布局技术加上对键盘的相关监听，可以十分方便的实现上述效果。首先在xib文件中进行相关约束的添加，如下图： 将需要的属性与约束对象关联到文件中： 12345678910//整体文本控件的高度 @IBOutlet weak var textViewHeight: NSLayoutConstraint! //文本控件中的文字输入控件UITestView的高度 @IBOutlet weak var textFieldHeight: NSLayoutConstraint! //文本控件中文字输入控件 @IBOutlet weak var ourTextField: UITextView! //文本控件与父视图底部的约束距离 @IBOutlet weak var textViewBottom: NSLayoutConstraint! //文本控件 @IBOutlet weak var ourTextView: UIView! 在初始化方法中进行通知的注册和代理的设置： 123 NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector(&quot;keyboardWillShow:&quot;), name: UIKeyboardWillShowNotification, object: nil) NSNotificationCenter.defaultCenter().addObserver(self, selector: Selector(&quot;keyboardWillHidden:&quot;), name: UIKeyboardWillHideNotification, object: nil) ourTextField.delegate=self 实现通知的监听方法如下： 123456789101112131415161718192021222324252627282930 //键盘将要展示时触发的方法 func keyboardWillShow(noti:NSNotification)&#123; //获取通知信息 let info:Dictionary = noti.userInfo! //获取信息中的键盘尺寸和位置信息 let value:NSValue = info[UIKeyboardFrameBeginUserInfoKey] as! NSValue //获取键盘动画的时间信息 let value2:NSValue = info[UIKeyboardAnimationDurationUserInfoKey] as! NSValue let keyboardSize = value.CGRectValue() let height = keyboardSize.height var time:NSTimeInterval=0 value2.getValue(&amp;time) //重设约束 textViewBottom.constant = height //动画展示 UIView.animateWithDuration(time) &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125; &#125; //键盘将要隐藏时触发的方法 func keyboardWillHidden(noti:NSNotification)&#123; let info:Dictionary = noti.userInfo! let value2:NSValue = info[UIKeyboardAnimationDurationUserInfoKey] as! NSValue var time:NSTimeInterval=0 value2.getValue(&amp;time) textViewBottom.constant = 0 UIView.animateWithDuration(time) &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125; &#125; 监听的键盘状态发送的通知中，会传递进来许多键盘信息，可取的键值如下： 12345678910@available(iOS 3.2, *)public let UIKeyboardFrameBeginUserInfoKey: String //键盘的初始位置尺寸 为CGRect类型的NSValue值@available(iOS 3.2, *)public let UIKeyboardFrameEndUserInfoKey: String // 键盘的末位位置尺寸 为CGRect类型的NSValue值@available(iOS 3.0, *)public let UIKeyboardAnimationDurationUserInfoKey: String // 键盘动画时间 double类型的NSValue@available(iOS 3.0, *)public let UIKeyboardAnimationCurveUserInfoKey: String // 键盘动画效果 (UIViewAnimationCurve)枚举类型的NSNumber值@available(iOS 9.0, *)public let UIKeyboardIsLocalUserInfoKey: String //与多任务相关 判断键盘是否属于当前应用 iOS9后可用 可以监听的与键盘相关信息的通知有如下几种： 12345678public let UIKeyboardWillShowNotification: String//键盘将要出现public let UIKeyboardDidShowNotification: String//键盘已经出现public let UIKeyboardWillHideNotification: String//键盘将要隐藏public let UIKeyboardDidHideNotification: String//键盘已经隐藏@available(iOS 5.0, *)public let UIKeyboardWillChangeFrameNotification: String//键盘frame将要改变@available(iOS 5.0, *)public let UIKeyboardDidChangeFrameNotification: String//键盘frame已经改变 还需要实现当输入框文字长度改变时的回调方法如下： 123456789101112131415161718192021222324func textViewDidChange(textView: UITextView) &#123; let height = textView.contentSize.height if height &lt;= 37 &#123; textFieldHeight.constant = 37 textViewHeight.constant = 53 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) return //临界值 &#125;else if height&lt;100 &#123; textFieldHeight.constant = height textViewHeight.constant = height+16 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) &#125;else&#123; textFieldHeight.constant = 100 textViewHeight.constant = 116 UIView.animateWithDuration(0.3, animations: &#123; () -&gt; Void in self.view.layoutIfNeeded() &#125;) &#125; &#125; 上面代码是实现可自适应高度和位置的文本输入框控件的核心代码，效果图下图： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计","slug":"187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计","date":"2016-03-20T16:00:00.000Z","updated":"2021-07-06T07:12:16.245Z","comments":true,"path":"2016/03/21/187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计/","link":"","permalink":"http://huishao.cc/2016/03/21/187iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计/","excerpt":"","text":"iOS简易蓝牙对战五子棋游戏设计思路之一——核心蓝牙通讯类的设计一、引言本系列博客将系统的介绍一款蓝牙对战五子棋的开发思路与过程，其中的核心部分有两个，一部分是蓝牙通讯中对战双方信息交互框架的设计与开发，一部分是五子棋游戏中棋盘逻辑与胜负判定的算法实现。本篇博客将介绍游戏中蓝牙通讯类的设计思路 二、设计通讯类的核心想法 在前篇的一篇博客中，我们有详细的介绍iOS中蓝牙4.0技术的应用与系统框架CoorBluetooth.framework中提供的编程接口的用法。博客地址如下，如果读者需要更详细的了解iOS中蓝牙技术的使用，可以先阅读这篇博客： iOS开发之蓝牙通讯：http://my.oschina.net/u/2340880/blog/548127。 在使用蓝牙进行应用间通讯交互时，必须有一方作为中心设备，有一方作为外围设备。举一个简单的例子，通过手机蓝牙可以和刷卡设备、打印机等进行信息交互，这里的刷卡设备、打印机就充当着外围设备的角色，手机就充当着中心设备的角色。在中心设备与外围设备间，外设负责向周围广播广告告知其他设备自己的存在，中心设备接收到外设广播的广告后可以选择目标设备进行连接，当然，外设的广播的广告中会携带一些身份信息供中心设备进行识别。一旦中心设备与外设建立连接，中心设备变可以使用外设提供的服务，一个外设可以提供多个服务，例如一款蓝牙打印机外设可能会提供两种服务，一种服务向中心设备发送约定信息，告知中心设备支持的打印格式，一种服务获取中心设备的数据来进行打印服务。服务是中心设备与外设机型通讯的功能标识，然而具体的通讯媒介则是由服务中的特征值来完成的，一个服务也可以提供多个特征值。可以这样理解，特征值是两设备进行蓝牙通讯的最小通讯单元，是读写数据的载体。 上面简单介绍了在蓝牙通讯中的一些基本流程与相关概念，应用于游戏中略微有一些区别，首先我们这款游戏应该具备既可以作为中心设备也可以作为外设的能力，因此，我们需要将中心设备的通讯模式与外设的通讯模式都集成与游戏的通讯框架中。游戏的双方要建立连接应该有如下几个过程： 1.有一方建立游戏，作为房主。 2.由一方作为游戏的加入者，扫描附近的游戏。 3.外设提供的服务中应该至少有两个特征值，一个用于己方下子后通知对方设备，一个用于监听对方设备的下子操作。 由上面分析可知，游戏中的房主正是充当蓝牙通讯中的外设，它将广播广告告知周围设备自己的存在。而游戏中的加入者则是充当着蓝牙通讯中的中心设备，扫描到周围的游戏房间后进行连接加入，开始游戏。 三、游戏中蓝牙通讯类的设计 创建一个命名为BlueToothTool的工具类，作为游戏的蓝牙通讯类，编写其头文件如下： BlueToothTool.h 1234567891011121314151617181920212223242526272829303132333435#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;CoreBluetooth/CoreBluetooth.h&gt;//这个代理用于处理接收到对方设备发送来的数据后的回调@protocol BlueToothToolDelegate &lt;NSObject&gt;//获取对方数据-(void)getData:(NSString *)data;@end@interface BlueToothTool : NSObject&lt;CBPeripheralManagerDelegate,CBCentralManagerDelegate,CBPeripheralDelegate,UIAlertViewDelegate&gt;//代理@property(nonatomic,weak)id&lt;BlueToothToolDelegate&gt;delegate;//标记是否是游戏中的房主@property(nonatomic,assign)BOOL isCentral;/** *获取单例对象的方法 */+(instancetype)sharedManager;/* *作为游戏的房主建立游戏房间 */-(void)setUpGame:(NSString *)name block:(void(^)(BOOL first))finish;/* *作为游戏的加入者查找附近的游戏 */-(void)searchGame;/** *断块连接 */-(void)disConnect;/* *进行写数据操作 */-(void)writeData:(NSString *)data;@end 实现BlueToothTool.m文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274#import &quot;BlueToothTool.h&quot;@implementation BlueToothTool&#123; //外设管理中心 CBPeripheralManager * _peripheralManager; //外设提供的服务 CBMutableService * _ser; //服务提供的读特征值 CBMutableCharacteristic * _readChara; //服务提供的写特征值 CBMutableCharacteristic * _writeChara; //等待对方加入的提示视图 UIView * _waitOtherView; //正在扫描附近游戏的提示视图 UIView * _searchGameView; //设备中心管理对象 CBCentralManager * _centerManger; //要连接的外设 CBPeripheral * _peripheral; //要交互的外设属性 CBCharacteristic * _centerReadChara; CBCharacteristic * _centerWriteChara; //开始游戏后的回调 告知先手与后手信息 void(^block)(BOOL first);&#125;//实现单例方法+(instancetype)sharedManager&#123; static BlueToothTool *tool = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; tool = [[self alloc] init]; &#125;); return tool;&#125;//实现创建游戏的方法-(void)setUpGame:(NSString *)name block:(void (^)(BOOL))finish&#123; block = [finish copy]; if (_peripheralManager==nil) &#123; //初始化服务 _ser= [[CBMutableService alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;] primary:YES]; //初始化特征 _readChara = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;] properties:CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable]; _writeChara = [[CBMutableCharacteristic alloc]initWithType:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00068&quot;] properties:CBCharacteristicPropertyWriteWithoutResponse value:nil permissions:CBAttributePermissionsWriteable]; //向服务中添加特征 _ser.characteristics = @[_readChara,_writeChara]; _peripheralManager = [[CBPeripheralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)]; &#125; //设置为房主 _isCentral=YES; //开始广播广告 [_peripheralManager startAdvertising:@&#123;CBAdvertisementDataLocalNameKey:@&quot;WUZIGame&quot;&#125;];&#125;//外设检测蓝牙状态-(void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral&#123; //判断是否可用 if (peripheral.state==CBPeripheralManagerStatePoweredOn) &#123; //添加服务 [_peripheralManager addService:_ser]; //开始广播广告 [_peripheralManager startAdvertising:@&#123;CBAdvertisementDataLocalNameKey:@&quot;WUZIGame&quot;&#125;]; &#125;else&#123; //弹提示框 dispatch_async(dispatch_get_main_queue(), ^&#123; [self showAlert]; &#125;); &#125;&#125;//开始放广告的回调-(void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error&#123; if (_waitOtherView==nil) &#123; _waitOtherView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; dispatch_async(dispatch_get_main_queue(), ^&#123; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;等待附近玩家加入&quot;; [_waitOtherView addSubview:label]; _waitOtherView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [[[UIApplication sharedApplication].delegate window]addSubview:_waitOtherView]; &#125;); &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_waitOtherView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_waitOtherView]; &#125;); &#125;&#125;//添加服务后回调的方法-(void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error&#123; if (error) &#123; NSLog(@&quot;添加服务失败&quot;); &#125; NSLog(@&quot;添加服务成功&quot;);&#125;//中心设备订阅特征值时回调-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic&#123; [_peripheralManager stopAdvertising]; if (_isCentral) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;&quot; message:@&quot;请选择先手后手&quot; delegate:self cancelButtonTitle:@&quot;我先手&quot; otherButtonTitles:@&quot;我后手&quot;, nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [_waitOtherView removeFromSuperview]; [alert show]; &#125;); &#125;&#125;//收到写消息后的回调-(void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.delegate getData:[[NSString alloc]initWithData:requests.firstObject.value encoding:NSUTF8StringEncoding]]; &#125;);&#125;//弹提示框的方法-(void)showAlert&#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;温馨提示&quot; message:@&quot;请确保您的蓝牙可用&quot; delegate:nil cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show];&#125;//===============================================================作为游戏加入这实现的方法========//搜索周围游戏-(void)searchGame&#123; if (_centerManger==nil) &#123; _centerManger = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)]; &#125;else&#123; [_centerManger scanForPeripheralsWithServices:nil options:nil]; if (_searchGameView==nil) &#123; _searchGameView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;正在扫加入描附近游戏&quot;; _searchGameView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [_searchGameView addSubview:label]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;else&#123; [_searchGameView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125; &#125; //设置为游戏加入方 _isCentral = NO;&#125;//设备硬件检测状态回调的方法 可用后开始扫描设备-(void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; if (_centerManger.state==CBCentralManagerStatePoweredOn) &#123; [_centerManger scanForPeripheralsWithServices:nil options:nil]; if (_searchGameView==nil) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; _searchGameView = [[UIView alloc]initWithFrame:CGRectMake([UIScreen mainScreen].bounds.size.width/2-100, 240, 200, 100)]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 200, 100)]; label.backgroundColor = [UIColor clearColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @&quot;正在扫加入描附近游戏&quot;; _searchGameView.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.4]; [_searchGameView addSubview:label]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;); &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_searchGameView removeFromSuperview]; [[[UIApplication sharedApplication].delegate window]addSubview:_searchGameView]; &#125;); &#125; &#125;else&#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self showAlert]; &#125;); &#125;&#125;//发现外设后调用的方法-(void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; //获取设备的名称 或者广告中的相应字段来配对 NSString * name = [advertisementData objectForKey:CBAdvertisementDataLocalNameKey]; if ([name isEqualToString:@&quot;WUZIGame&quot;]) &#123; //保存此设备 _peripheral = peripheral; //进行连接 [_centerManger connectPeripheral:peripheral options:@&#123;CBConnectPeripheralOptionNotifyOnConnectionKey:@YES&#125;]; &#125;&#125;//连接外设成功的回调-(void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; NSLog(@&quot;连接成功&quot;); //设置代理与搜索外设中的服务 [peripheral setDelegate:self]; [peripheral discoverServices:nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [_searchGameView removeFromSuperview]; &#125;);&#125;//连接断开-(void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@&quot;连接断开&quot;); [_centerManger connectPeripheral:peripheral options:@&#123;CBConnectPeripheralOptionNotifyOnConnectionKey:@YES&#125;];&#125;//发现服务后回调的方法-(void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; for (CBService *service in peripheral.services) &#123; //发现服务 比较服务的UUID if ([service.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;]]) &#123; NSLog(@&quot;Service found with UUID: %@&quot;, service.UUID); //查找服务中的特征值 [peripheral discoverCharacteristics:nil forService:service]; break; &#125; &#125;&#125;//开发服务中的特征值后回调的方法-(void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; for (CBCharacteristic *characteristic in service.characteristics) &#123; //发现特征 比较特征值得UUID 来获取所需要的 if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00067&quot;]]) &#123; //保存特征值 _centerReadChara = characteristic; //监听特征值 [_peripheral setNotifyValue:YES forCharacteristic:_centerReadChara]; &#125; if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@&quot;68753A44-4D6F-1226-9C60-0050E4C00068&quot;]]) &#123; //保存特征值 _centerWriteChara = characteristic; &#125; &#125;&#125;//所监听的特征值更新时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; //更新接收到的数据 NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:characteristic.value encoding:NSUTF8StringEncoding]); //要在主线程中刷新 dispatch_async(dispatch_get_main_queue(), ^&#123; [self.delegate getData:[[NSString alloc]initWithData:characteristic.value encoding:NSUTF8StringEncoding]]; &#125;);&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; //告诉开发者先后手信息 if (buttonIndex==0) &#123; if (_isCentral) &#123; block(1); &#125;else&#123; block(0); &#125; &#125;else&#123; if (_isCentral) &#123; block(0); &#125;else&#123; block(1); &#125; &#125;&#125;//断开连接-(void)disConnect&#123; if (!_isCentral) &#123; [_centerManger cancelPeripheralConnection:_peripheral]; [_peripheral setNotifyValue:NO forCharacteristic:_centerReadChara]; &#125;&#125;//写数据-(void)writeData:(NSString *)data&#123; if (_isCentral) &#123; [_peripheralManager updateValue:[data dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:_readChara onSubscribedCentrals:nil]; &#125;else&#123; [_peripheral writeValue:[data dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:_centerWriteChara type:CBCharacteristicWriteWithoutResponse]; &#125;&#125;@end 附录：游戏的源码已经放在git上，时间比较仓促，只用了一下午来写，其中还有许多细节与bug没有进行调整，有需要的可以作为参考： git地址：https://github.com/ZYHshao/BlueGame。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法","slug":"188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法","date":"2016-03-20T16:00:00.000Z","updated":"2021-07-06T07:13:07.367Z","comments":true,"path":"2016/03/21/188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法/","link":"","permalink":"http://huishao.cc/2016/03/21/188iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法/","excerpt":"","text":"iOS简易蓝牙对战五子棋游戏设计思路之二——核心棋盘逻辑与胜负判定算法一、引言上一篇博客我们介绍了在开发一款蓝牙对战五子棋游戏中核心的蓝牙通讯框架的设计与编写，本篇博客将来完成独立的棋盘逻辑与胜负判定算法。上篇博客地址如下： 五子棋游戏中和核心通讯类设计：http://my.oschina.net/u/2340880/blog/644432。 二、棋盘中独立棋格的设计我们知道，五子棋游戏的棋盘是由横纵交叉的两组平行线组成，每一个横纵线的交点即是棋盘上可以落子的点。因此，在设计棋盘前，我们可以先来设计创建棋盘上每一个独立的落子点，这里称之为棋格，在iOS中，可以使用UIButton类来进行棋格的设计。 创建一个类，命名为TipButton作为棋格类，实现其头文件如下： TipButton.h 1234567891011#import &lt;UIKit/UIKit.h&gt;@interface TipButton : UIButton//标记此瓦片是否已经落子 0 空 1 己方落子 2 敌方落子@property(nonatomic,assign)int hasChess;//落子 BOOL类型的参数 决定是己方还是敌方-(void)dropChess:(BOOL)isMine;//设置白子或者黑子@property(nonatomic,assign)BOOL isWhite;//瓦片编号@property(nonatomic,assign)int index;@end 实现.m文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &quot;TipButton.h&quot;@implementation TipButton- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; [self creatView]; &#125; return self;&#125;-(void)creatView&#123; //创建横竖两条线 UIView * line1 = [[UIView alloc]initWithFrame:CGRectMake(self.frame.size.width/2-0.25, 0, 0.5, self.frame.size.height)]; line1.backgroundColor = [UIColor grayColor]; [self addSubview:line1]; UIView * line2 = [[UIView alloc]initWithFrame:CGRectMake(0, self.frame.size.height/2-0.25, self.frame.size.width, 0.5)]; line2.backgroundColor = [UIColor grayColor]; [self addSubview:line2];&#125;-(void)dropChess:(BOOL)isMine&#123; UIView * view = [[UIView alloc]initWithFrame:CGRectMake(self.frame.size.width/2-5, self.frame.size.height/2-5, 10, 10)]; view.layer.masksToBounds = YES; view.layer.cornerRadius = 5; UIColor * myColor; UIColor * otherColor; if (_isWhite) &#123; myColor = [UIColor whiteColor]; otherColor = [UIColor blackColor]; &#125;else&#123; myColor = [UIColor blackColor]; otherColor = [UIColor whiteColor]; &#125; if (isMine) &#123; view.backgroundColor = myColor; self.hasChess = 1; &#125;else&#123; view.backgroundColor = otherColor; self.hasChess = 2; &#125; [self addSubview:view]; &#125;@end 三、游戏棋盘的设计创建一个继承于UIView的类，作为五子棋游戏的棋盘，命名为GameView实现如下： GameView.h 1234567891011121314#import &lt;UIKit/UIKit.h&gt;#import &quot;TipButton.h&quot;#import &quot;BlueToothTool.h&quot;//用于处理用户下子后的逻辑@protocol GameViewDelegate&lt;NSObject&gt;-(void)gameViewClick:(NSString *)index;@end@interface GameView : UIView&lt;UIAlertViewDelegate&gt;//存放所有棋格@property(nonatomic,strong)NSMutableArray&lt;TipButton *&gt; * tipArray;@property(nonatomic,weak)id&lt;GameViewDelegate&gt;delegate;//进行下子-(void)setTipIndex:(int)index;@end GameView.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391#import &quot;GameView.h&quot;@implementation GameView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _tipArray = [[NSMutableArray alloc]init]; [self creatView]; &#125; return self;&#125;//创建表格视图 横16 竖20-(void)creatView&#123; self.layer.borderColor = [UIColor colorWithRed:222/255.0 green:222/255.0 blue:222/255.0 alpha:1].CGColor; self.layer.borderWidth = 0.5; CGFloat width = self.frame.size.width/12; CGFloat height = self.frame.size.height/20; //排列布局 for (int i=0; i&lt;240; i++) &#123; TipButton * btn = [[TipButton alloc]initWithFrame:CGRectMake(width*(i%12), height*(i/12), width, height)]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.isWhite = NO; btn.index=i; [self addSubview:btn]; [_tipArray addObject:btn]; &#125;&#125;-(void)click:(TipButton *)btn&#123; if (btn.hasChess==0) &#123; //下子 [btn dropChess:YES]; //进行胜负判定 [self cheak]; [self.delegate gameViewClick:[NSString stringWithFormat:@&quot;%d&quot;,btn.index]]; &#125;&#125;//进行胜负判定-(void)cheak&#123; //判定己方是否胜利 if ([self cheakMine]) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;您胜利啦&quot; message:@&quot;&quot; delegate:self cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show]; &#125; //判断对方是否胜利 if ([self cheakOther]) &#123; UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;您失败了&quot; message:@&quot;&quot; delegate:self cancelButtonTitle:@&quot;好的&quot; otherButtonTitles:nil, nil]; [alert show]; &#125;&#125;-(void)setTipIndex:(int)index&#123; //下子 for (TipButton * btn in _tipArray) &#123; if (btn.index==index) &#123; [btn dropChess:NO]; [self cheak]; &#125; &#125;&#125;-(BOOL)cheakOther&#123; //遍历所有棋子 for (int i=0; i&lt;_tipArray.count; i++) &#123; TipButton * tip = _tipArray[i]; //获取是否是己方棋子 if (tip.hasChess==2) &#123; //进行五子判定逻辑 //横向 if ( [self cheak1HasMineOrOther:NO index:i]) &#123; return YES; &#125; //左上到右下的对角线 if ( [self cheak2HasMineOrOther:NO index:i]) &#123; return YES; &#125; //纵向 if ( [self cheak3HasMineOrOther:NO index:i]) &#123; return YES; &#125; //右上到左下的对角线 if ( [self cheak4HasMineOrOther:NO index:i]) &#123; return YES; &#125; &#125; &#125; return NO;&#125;-(BOOL)cheakMine&#123; //遍历所有棋子 for (int i=0; i&lt;_tipArray.count; i++) &#123; TipButton * tip = _tipArray[i]; //获取是否是己方棋子 if (tip.hasChess==1) &#123; //进行五子判定逻辑 //横向 if ( [self cheak1HasMineOrOther:YES index:i]) &#123; return YES; &#125; //左上到右下的对角线 if ( [self cheak2HasMineOrOther:YES index:i]) &#123; return YES; &#125; //纵向 if ( [self cheak3HasMineOrOther:YES index:i]) &#123; return YES; &#125; //右上到左下的对角线 if ( [self cheak4HasMineOrOther:YES index:i]) &#123; return YES; &#125; &#125; &#125; return NO;&#125;-(BOOL)cheak1HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //左侧右侧同时进行可以增加效率 //左侧 count = count +[self algorithmic1:index param:mineOrOther num:4]; //右侧 count = count +[self algorithmic2:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak2HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //左上右下同时进行可以增加效率 //左上 count = count +[self algorithmic3:index param:mineOrOther num:4]; //右下 count = count +[self algorithmic4:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak3HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //纵向 //向上 count = count +[self algorithmic5:index param:mineOrOther num:4]; //向下 count = count +[self algorithmic6:index param:mineOrOther num:4]; if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;-(BOOL)cheak4HasMineOrOther:(BOOL)mine index:(int)index&#123; int mineOrOther = 0; if (mine) &#123; mineOrOther = 1; &#125;else&#123; mineOrOther = 2; &#125; int count=1; //纵向 //向上 count = count +[self algorithmic7:index param:mineOrOther num:4]; //向下 count = count +[self algorithmic8:index param:mineOrOther num:4]; NSLog(@&quot;%d&quot;,count); if (count&gt;=5) &#123; return YES; &#125;else&#123; return NO; &#125;&#125;/* 左侧递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic1:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左侧有子 if (index-tem&gt;=0) &#123; //左侧无换行 if(((index-tem)%12)!=11)&#123; if (_tipArray[index-tem].hasChess==param) &#123; return [self algorithmic1:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;/* 右侧递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic2:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //右侧有子 if (index+tem&lt;240) &#123; //右侧无换行 if(((index+tem)%12)!=11)&#123; if (_tipArray[index+tem].hasChess==param) &#123; return [self algorithmic2:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;/* 左上递归进行查找 index 棋子编号 param 对比值 num 递归次数 */-(int)algorithmic3:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index-(tem*12)-tem)&gt;=0) &#123; //右侧无换行 if(((index-(tem*12)-tem)%12)!=11)&#123; if (_tipArray[(index-(tem*12)-tem)].hasChess==param) &#123; return [self algorithmic3:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic4:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index+(tem*12)+tem)&lt;240) &#123; //右侧无换行 if(((index+(tem*12)+tem)%12)!=0)&#123; if (_tipArray[(index+(tem*12)+tem)].hasChess==param) &#123; return [self algorithmic4:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic5:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //上有子 if ((index-(tem*12))&gt;=0) &#123; if (_tipArray[(index-(tem*12))].hasChess==param) &#123; return [self algorithmic5:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic6:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //上有子 if ((index+(tem*12))&lt;240) &#123; if (_tipArray[(index+(tem*12))].hasChess==param) &#123; return [self algorithmic6:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic7:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index-(tem*12)+tem)&gt;=0) &#123; //右侧无换行 if(((index-(tem*12)+tem)%12)!=0)&#123; if (_tipArray[(index-(tem*12)+tem)].hasChess==param) &#123; return [self algorithmic7:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(int)algorithmic8:(int)index param:(int)param num:(int)num&#123; if (num&gt;0) &#123; int tem = 4-(num-1); //左上有子 if ((index+(tem*12)-tem)&lt;240) &#123; //右侧无换行 if(((index+(tem*12)-tem)%12)!=11)&#123; if (_tipArray[(index+(tem*12)-tem)].hasChess==param) &#123; return [self algorithmic8:index param:param num:num-1]; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; return 4-num; &#125; &#125;else&#123; //递归了四次 return 4-num; &#125;&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; [[BlueToothTool sharedManager]disConnect]; [(UIViewController *)[self.superview nextResponder] dismissViewControllerAnimated:YES completion:nil];&#125;@end 关于胜负判定的算法逻辑，这里采用了向各个方向进行递归查找的方式，这里有一点需要主要，在4个方向进行递归查找时，理论上每个方向只需要单面递归即可，但是代码中采用了双面递归在进行累加的方式，这样的设计可以遍历更少的棋子判定出胜负情况。 四、整合通讯与游戏逻辑 创建一个继承于UIViewController的类作为游戏视图控制器，实现如下： GameViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#import &quot;GameViewController.h&quot;#import &quot;GameView.h&quot;#import &quot;BlueToothTool.h&quot;@interface GameViewController ()&lt;BlueToothToolDelegate,GameViewDelegate&gt;&#123; UIView * _bgView; UILabel * _tipLabel; GameView * _view;&#125;@end@implementation GameViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor brownColor]; //创建游戏视图 _view = [[GameView alloc]initWithFrame:CGRectMake(20, 40, (self.view.frame.size.width-40), (self.view.frame.size.width-40)/12*20)]; _view.delegate=self; [self.view addSubview:_view]; //创建背景视图 _bgView = [[UIView alloc]initWithFrame:self.view.frame]; _bgView.backgroundColor = [UIColor colorWithRed:1 green:1 blue:1 alpha:0.1]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeSystem]; btn.frame = CGRectMake(self.view.frame.size.width/2-50, 150, 100, 30); UIButton * btn2 = [UIButton buttonWithType:UIButtonTypeSystem]; btn2.frame = CGRectMake(self.view.frame.size.width/2-50, 250, 100, 30); [btn setTitle:@&quot;创建游戏&quot; forState:UIControlStateNormal]; [btn2 setTitle:@&quot;扫描附近游戏&quot; forState:UIControlStateNormal]; btn.backgroundColor = [UIColor orangeColor]; btn2.backgroundColor = [UIColor orangeColor]; [btn addTarget:self action:@selector(creatGame) forControlEvents:UIControlEventTouchUpInside]; [btn2 addTarget:self action:@selector(searchGame) forControlEvents:UIControlEventTouchUpInside]; [_bgView addSubview:btn]; [_bgView addSubview:btn2]; [self.view addSubview:_bgView]; //设置蓝牙通讯类代理 [BlueToothTool sharedManager].delegate=self; //创建提示标签 _tipLabel = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width,40)]; [self.view addSubview:_tipLabel]; _tipLabel.textAlignment = NSTextAlignmentCenter;&#125;-(void)creatGame&#123; [[BlueToothTool sharedManager]setUpGame:@&quot;&quot; block:^(BOOL first) &#123; [_bgView removeFromSuperview]; if (first) &#123; _tipLabel.text = @&quot;请您下子&quot;; //进行发送下子信息 &#125;else&#123; _tipLabel.text = @&quot;请等待对方下子&quot;; self.view.userInteractionEnabled = NO; [self gameViewClick:@&quot;-1&quot;]; &#125; &#125;];&#125;-(void)searchGame&#123; [[BlueToothTool sharedManager]searchGame];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;-(void)getData:(NSString *)data&#123; if (_bgView.superview) &#123; [_bgView removeFromSuperview]; &#125; if ([data integerValue]==-1) &#123; _tipLabel.text = @&quot;请您下子&quot;; self.view.userInteractionEnabled = YES; return; &#125; _tipLabel.text = @&quot;请您下子&quot;; [_view setTipIndex:[data intValue]]; self.view.userInteractionEnabled = YES;&#125;-(void)gameViewClick:(NSString *)index&#123; _tipLabel.text = @&quot;请等待对方下子&quot;; [[BlueToothTool sharedManager]writeData:index]; self.view.userInteractionEnabled = NO;&#125;@end 游戏运行的主要界面如下图所示： 附录：游戏的源码已经放在git上，时间比较仓促，只用了一下午来写，其中还有许多细节与bug没有进行调整，有需要的可以作为参考： git地址：https://github.com/ZYHshao/BlueGame。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS音频播放器锁屏歌词显示与性能优化","slug":"186iOS音频播放器锁屏歌词显示与性能优化","date":"2016-03-12T16:00:00.000Z","updated":"2021-07-06T07:11:10.155Z","comments":true,"path":"2016/03/13/186iOS音频播放器锁屏歌词显示与性能优化/","link":"","permalink":"http://huishao.cc/2016/03/13/186iOS音频播放器锁屏歌词显示与性能优化/","excerpt":"","text":"iOS音频播放器锁屏歌词显示与性能优化一、引言前边有博客探讨了有关iOS开发中音频播放的技术与进行后台音频播放并在后台与用户进行交互的方法，本篇将探讨一种在锁屏界面同步显示歌词歌词的方法，并在应用性能上进行一些处理。前边博客地址如下： iOS音频开发AVAudioPlayer的应用：http://my.oschina.net/u/2340880/blog/420129。 iOS后台音频开发与交互技术：http://my.oschina.net/u/2340880/blog/420183。 二、在锁屏界面同步显示歌词 我们知道，在音频后台播放时，锁屏界面的信息是由MPNowPlayingInfoCenter来设置的，其中的歌曲信息字典可以设置类似歌曲封面，艺术家，歌曲名，歌曲时间等。然而，对于MPNowPlayingInfoCenter中可以由开发者掌握的接口十分有限，若要在锁屏界面同步的显示歌曲歌词，一个比较简单的方法是不停的将当前歌词与封面进行图片合成，之后刷新锁屏界面的图片。下面代码是根据解析好的LRC歌词数据进行图片合成的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//这个方法通过传入的LRC歌词数据进行图片的合成 array参数为每行lrc歌词数据集合 index为当前需要播放的lrc歌词行数-(void)setCurretLRCArray:(NSArray *)array index:(int)index&#123; //LRCItem是歌词模型 里面的lrc方法获取歌词文字字符串 NSString * lineLRC = [(LRCItem *)array[index] lrc]; //提高性能 进行判断 当前显示的歌词有无变化 如果没变化 不进行后续操作 if ([_lrcLabel.text isEqualToString:lineLRC]) &#123; return; &#125; _lrcLabel.text = lineLRC; //将歌词整理成整齐数据 //进行行数设置 NSMutableString * lrcStr = [[NSMutableString alloc]init]; if (index&lt;_lines/2) &#123; //前面用\\n补齐 int offset = (int)_lines/2-index; for (int j=0; j&lt;offset; j++) &#123; [lrcStr appendFormat:@&quot;\\n&quot;]; &#125; for (int j=0; j&lt;_lines-offset; j++) &#123; [lrcStr appendFormat:@&quot;%@\\n&quot;,[(LRCItem *)array[j] lrc]]; &#125; &#125; else if (array.count-1-index&lt;_lines/2) &#123; //后面用\\n补齐 int offset = (int)_lines/2-(int)(array.count-index-1); for (int j=index-(_lines/2); j&lt;array.count; j++) &#123; [lrcStr appendFormat:@&quot;%@\\n&quot;,[(LRCItem *)array[j] lrc]]; &#125; for (int j=0; j&lt;offset; j++) &#123; [lrcStr appendFormat:@&quot;\\n&quot;]; &#125; &#125;else &#123; for (int j=0; j&lt;_lines; j++) &#123; [lrcStr appendString:[(LRCItem *)array[index-_lines/2+j] lrc]]; [lrcStr appendString:@&quot;\\n&quot;]; &#125; &#125; //将当前显示的歌词部分高亮 NSMutableAttributedString * attriStr = [[NSMutableAttributedString alloc]initWithString:lrcStr]; NSRange range = [lrcStr rangeOfString:[array[index] lrc]]; [attriStr setAttributes:@&#123;NSForegroundColorAttributeName:[UIColor greenColor]&#125; range:range]; _lrcView.attributedText = attriStr; _lrcIMGLabel.attributedText = attriStr; //进行截屏 if (!_lrcIMGbg) &#123; _lrcIMGbg = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)]; _lrcIMGbg.image = [UIImage imageNamed:@&quot;BG.jpeg&quot;]; [_lrcIMGbg addSubview:_lrcIMGLabel]; &#125; //获取添加了歌词数据的背景图 UIGraphicsBeginImageContext(_lrcIMGbg.frame.size); CGContextRef context = UIGraphicsGetCurrentContext(); [_lrcIMGbg.layer renderInContext:context]; UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); _lrcImage = [img copy];&#125; 锁屏歌词的显示效果如下： 三、应用性能的优化 从功能上来说，通过一直合成刷新锁屏界面的封面图是可行的，然而在使用中我发现，不停和合成图片和刷新操作将使设备非常耗电，如果可以完成下面的优化，则可以大大提高应用的性能： 1.应用在前台时不进行后台锁屏界面的刷新操作。 2.应用在后台时不进行前台歌词信息、歌曲信息的相应更新。 3.当屏幕变黑关闭时，停止所有刷新操作。 4.当屏幕从新被点亮时，进行后台信息刷新。 上面4点需求，前两点十分容易搞定，在AppDelegate中有如下的方法可以监听应用程序前台与后台的切换： 123456789//应用进入后台时调用- (void)applicationWillResignActive:(UIApplication *)application &#123; //发送通知 [[NSNotificationCenter defaultCenter]postNotificationName:@&quot;goBack&quot; object:nil];&#125;//应用进入前台时调用- (void)applicationDidBecomeActive:(UIApplication *)application &#123; [[NSNotificationCenter defaultCenter]postNotificationName:@&quot;goForward&quot; object:nil];&#125; 在相应的类中监听这两个通知即可以做到刷新模式的切换。 对于上面需求的第3点与第4点，Foundation框架中没有提供公开的方法来监听屏幕设备的点亮状态，但是可以通过notify\\_register\\_dispath()方法来监听。使用示例代码如下： 123456789101112#import &lt;notify.h&gt; //在定时器中使用如下代码实时监听屏幕状态 uint64_t locked; __block int token = 0; notify_register_dispatch(&quot;com.apple.springboard.hasBlankedScreen&quot;,&amp;token,dispatch_get_main_queue(),^(int t)&#123; &#125;); notify_get_state(token, &amp;locked); //如果屏幕变暗 直接不走更新方法 lock为1则为变暗关闭状态 0则为点亮状态 if (locked) &#123; return; &#125; 通过上面优化的代码，性能将会强很多。 由于前面博客已经详细的介绍了音频开发与后台交互的内容，这篇博客主要探讨了锁屏歌词相关的开发思路与优化方向，提供的示例代码都是片段，并不完整，经过优化的音频播放器源码在如下git地址上，需要的朋友可以作为参考： 同步显示锁屏歌词的音乐播放器：https://github.com/ZYHshao/MyPlayer。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C中通过下标的方式访问自定义数据模型中属性","slug":"185Objective-C中通过下标的方式访问自定义数据模型中属性","date":"2016-03-06T16:00:00.000Z","updated":"2021-07-06T07:10:13.899Z","comments":true,"path":"2016/03/07/185Objective-C中通过下标的方式访问自定义数据模型中属性/","link":"","permalink":"http://huishao.cc/2016/03/07/185Objective-C中通过下标的方式访问自定义数据模型中属性/","excerpt":"","text":"Objective-C中通过下标的方式访问自定义数据模型中属性在Objective-C中，可以通过下标来访问数组中的元素，如果数组是NSMutableArray类型的可变数组，则还可以通过下标来对数组中的元素进行赋值操作。例如： 1234 NSMutableArray * array = [[NSMutableArray alloc]init]; array[0] = @&quot;one&quot;; NSString * str = array[0]; NSLog(@&quot;%@&quot;,str); 对于Objective-C中的字典对象，可以通过键值下标的方式来进行访问，例如： 123 NSMutableDictionary * dic = [[NSMutableDictionary alloc]init]; dic[@&quot;name&quot;] = @&quot;name&quot;; NSLog(@&quot;%@&quot;,dic[@&quot;name&quot;]); 对于开发者自定义的的数据结构，一般会采用getter与setter方法来对其属性进行访问，虽然官方文档上没有提及，实际上，可以通过实现一些方法，来使自定义的数据模型支持使用下标来进行访问。 创建一个数据模型类，使其继承自NSObject，如下： MyModel.h 12@interface MyModel : NSObject@end MyModel.m 123456789101112131415161718192021222324@implementation MyModel&#123; NSString * _index0; NSString * _index1; NSString * _value;&#125;//通过下标获取属性值-(id) objectAtIndexedSubscript:(NSUInteger)idx &#123; return [self valueForKey:[NSString stringWithFormat:@&quot;_index%lu&quot;,idx]];&#125;//通过下标设置属性值- (void)setObject:(id)anObject atIndexedSubscript:(NSUInteger)index&#123; [self setValue:anObject forKey:[NSString stringWithFormat:@&quot;_index%lu&quot;,index]];&#125;//通过键值下标获取属性-(id) objectForKeyedSubscript:(id)key &#123; return [self valueForKey:key];&#125;//通过键值下标设置属性- (void)setObject:(id)object forKeyedSubscript:(id &lt; NSCopying &gt;)aKey&#123; [self setValue:object forKey:aKey];&#125;@end 使用如下代码进行测试： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; id model = [[MyModel alloc]init]; model[@&quot;_value&quot;] = @&quot;name&quot;; model[0] = @&quot;one&quot;; model[1] = @&quot;two&quot;; NSLog(@&quot;%@,%@,%@&quot;,model[0],model[1],model[@&quot;_value&quot;]);&#125; 这里有一点需要注意，若使用下标访问属性这种方法，必须将model声明为id类型，否则会影响编译。 在打印信息的可以看到，模型数据的设置和获取都没有问题，这种方法可以完全解放.h文件，如上所示，我们在数据模型的.h文件中一行代码都没有编写即可完成与MyModel模型数据的交互。然而其也有很大的弊端，代码的易调试和可读性都大大的降低，因此，没有特殊需求，一般不要使用这种方式来构建模型。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS翻页视图控制器UIPageViewController的应用","slug":"184iOS翻页视图控制器UIPageViewController的应用","date":"2016-03-02T16:00:00.000Z","updated":"2021-07-06T07:09:12.561Z","comments":true,"path":"2016/03/03/184iOS翻页视图控制器UIPageViewController的应用/","link":"","permalink":"http://huishao.cc/2016/03/03/184iOS翻页视图控制器UIPageViewController的应用/","excerpt":"","text":"iOS翻页视图控制器UIPageViewController的应用一、引言UIPageViewController是iOS中少见的动画视图控制器之一，通过它既可以创建类似UIScrollView与UIPageControl结合的滚屏视图，也可以创建类似图书效果的炫酷翻页视图。UIPageViewController类似一个视图容器，其中每个具体的视图由各自的ViewController进行维护管理，UIPageViewController只进行协调与动画布置。下图可以很好的展现出UIPageViewControlelr的使用结构： 上图中，UIPageViewControllerDataSource协议为UIPageViewController提供数据支持，DataSource协议提供的数据来自各个ViewContoller自行维护，UIPageViewControllerDelegate中的回调可以对翻页动作，屏幕旋转动作等进行监听。UIPageViewController把从DataSource中获取到的视图数据渲染给View用于当前视图控制器的展示。 二、创建一个UIPageViewController首先新建一个类作为翻页视图控制器中具体每一页视图的控制器，使其继承于UIViewController： ModelViewController.h 12345#import &lt;UIKit/UIKit.h&gt;@interface ModelViewController : UIViewController+(ModelViewController *)creatWithIndex:(int)index;@property(nonatomic,strong)UILabel * indexLabel;@end ModelViewController.m 1234567891011121314151617#import &quot;ModelViewController.h&quot;@interface ModelViewController ()@end@implementation ModelViewController+(ModelViewController *)creatWithIndex:(int)index&#123; ModelViewController * con = [[ModelViewController alloc]init]; con.indexLabel = [[UILabel alloc]initWithFrame:CGRectMake(110, 200, 100, 30)]; con.indexLabel.text = [NSString stringWithFormat:@&quot;第%d页&quot;,index]; [con.view addSubview:con.indexLabel]; return con;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. self.view.backgroundColor = [UIColor redColor];&#125;@end 在工程模板自带的ViewController.m文件中实现如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#import &quot;ViewController.h&quot;#import &quot;ModelViewController.h&quot;//遵守协议@interface ViewController ()&lt;UIPageViewControllerDataSource,UIPageViewControllerDelegate&gt;&#123; //翻页视图控制器对象 UIPageViewController * _pageViewControl; //数据源数组 NSMutableArray * _dataArray;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //进行初始化 _pageViewControl = [[UIPageViewController alloc]initWithTransitionStyle:UIPageViewControllerTransitionStyleScroll navigationOrientation:UIPageViewControllerNavigationOrientationHorizontal options:@&#123;UIPageViewControllerOptionSpineLocationKey:@0,UIPageViewControllerOptionInterPageSpacingKey:@10&#125;]; self.view.backgroundColor = [UIColor greenColor]; //设置翻页视图的尺寸 _pageViewControl.view.bounds=self.view.bounds; //设置数据源与代理 _pageViewControl.dataSource=self; _pageViewControl.delegate=self; //创建初始界面 ModelViewController * model = [ModelViewController creatWithIndex:1]; //设置初始界面 [_pageViewControl setViewControllers:@[model] direction:UIPageViewControllerNavigationDirectionReverse animated:YES completion:nil]; //设置是否双面展示 _pageViewControl.doubleSided = NO; _dataArray = [[NSMutableArray alloc]init]; [_dataArray addObject:model]; [self.view addSubview:_pageViewControl.view];&#125;//翻页控制器进行向前翻页动作 这个数据源方法返回的视图控制器为要显示视图的视图控制器- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerBeforeViewController:(UIViewController *)viewController&#123; int index = (int)[_dataArray indexOfObject:viewController]; if (index==0) &#123; return nil; &#125;else&#123; return _dataArray[index-1]; &#125;&#125;//翻页控制器进行向后翻页动作 这个数据源方法返回的视图控制器为要显示视图的视图控制器- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerAfterViewController:(UIViewController *)viewController&#123; int index = (int)[_dataArray indexOfObject:viewController]; if (index==9) &#123; return nil; &#125;else&#123; if (_dataArray.count-1&gt;=(index+1)) &#123; return _dataArray[index+1]; &#125;else&#123; ModelViewController * model = [ModelViewController creatWithIndex:index+2]; [_dataArray addObject:model]; return model; &#125; &#125;&#125;//屏幕旋转触发的代理方法- (UIPageViewControllerSpineLocation) pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation&#123; return UIPageViewControllerSpineLocationMin;&#125;//设置分页控制器的分页数- (NSInteger)presentationCountForPageViewController:(UIPageViewController *)pageViewController &#123; return 10;&#125;//设置初始的分页点- (NSInteger)presentationIndexForPageViewController:(UIPageViewController *)pageViewController&#123; return 0;&#125;@end 上面创建了最简单的翻页视图控制器示例，效果如下图： 三、UIPageViewController中方法使用解析12//创建翻页视图控制器对象- (instancetype)initWithTransitionStyle:(UIPageViewControllerTransitionStyle)style navigationOrientation:(UIPageViewControllerNavigationOrientation)navigationOrientation options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 上面方法用于创建视图控制器对象，其中UIPageViewControllerTransitionStyle参数设置翻页控制器的风格，枚举如下： 1234typedef NS_ENUM(NSInteger, UIPageViewControllerTransitionStyle) &#123; UIPageViewControllerTransitionStylePageCurl = 0, //类似于书本翻页效果 UIPageViewControllerTransitionStyleScroll = 1 // 类似于ScrollView的滑动效果&#125;; 如果设置为UIPageViewControllerTransitionStyleCurl，翻页效果如下图所示： 上面初始化方法中的UIPageViewControllerNavigationOrientation属性设置翻页的方向，枚举如下： 1234typedef NS_ENUM(NSInteger, UIPageViewControllerNavigationOrientation) &#123; UIPageViewControllerNavigationOrientationHorizontal = 0,//水平翻页 UIPageViewControllerNavigationOrientationVertical = 1//竖直翻页&#125;; options参数用于设置翻页视图控制器的配置字典，其可以设置的配置键值如下： 1234//这个键需要设置为UIPageViewControllerOptionSpineLocationKey枚举值对应的NSNumber对象 设置翻页控制器的书轴 后面会介绍NSString * const UIPageViewControllerOptionSpineLocationKey;//这个键需要设置为NSNumber类型 设置每页视图的间距 用于滚动视图风格的NSString * const UIPageViewControllerOptionInterPageSpacingKey; 下面是UIPageViewController的一些常用属性与方法： 1234567891011121314//设置数据源@property (nullable, nonatomic, weak) id &lt;UIPageViewControllerDelegate&gt; delegate;//设置代理@property (nullable, nonatomic, weak) id &lt;UIPageViewControllerDataSource&gt; dataSource;//获取翻页风格@property (nonatomic, readonly) UIPageViewControllerTransitionStyle transitionStyle;//获取翻页方向@property (nonatomic, readonly) UIPageViewControllerNavigationOrientation navigationOrientation;//获取书轴类型@property (nonatomic, readonly) UIPageViewControllerSpineLocation spineLocation;//设置是否双面显示@property (nonatomic, getter=isDoubleSided) BOOL doubleSided;//设置要显示的视图控制器- (void)setViewControllers:(nullable NSArray&lt;UIViewController *&gt; *)viewControllers direction:(UIPageViewControllerNavigationDirection)direction animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion; 上面只有spineLocation属性有些难于理解，其枚举如下： 12345678910typedef NS_ENUM(NSInteger, UIPageViewControllerSpineLocation) &#123; //对于SCrollView类型的滑动效果 没有书轴 会返回下面这个枚举值 UIPageViewControllerSpineLocationNone = 0, //以左边或者上边为轴进行翻转 界面同一时间只显示一个View UIPageViewControllerSpineLocationMin = 1, //以中间为轴进行翻转 界面同时可以显示两个View UIPageViewControllerSpineLocationMid = 2, //以下边或者右边为轴进行翻转 界面同一时间只显示一个View UIPageViewControllerSpineLocationMax = 3 &#125;; 将上面的示例代码修改几个地方如下： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. _pageViewControl = [[UIPageViewController alloc]initWithTransitionStyle:UIPageViewControllerTransitionStylePageCurl navigationOrientation:UIPageViewControllerNavigationOrientationVertical options:@&#123;UIPageViewControllerOptionSpineLocationKey:@2,UIPageViewControllerOptionInterPageSpacingKey:@10&#125;]; self.view.backgroundColor = [UIColor greenColor]; _pageViewControl.view.bounds=self.view.bounds; _pageViewControl.dataSource=self; _pageViewControl.delegate=self; ModelViewController * model = [ModelViewController creatWithIndex:1]; ModelViewController * model2 = [ModelViewController creatWithIndex:2]; [_pageViewControl setViewControllers:@[model,model2] direction:UIPageViewControllerNavigationDirectionReverse animated:YES completion:nil]; _pageViewControl.doubleSided = YES; _dataArray = [[NSMutableArray alloc]init]; [_dataArray addObject:model]; [self.view addSubview:_pageViewControl.view];&#125;- (UIPageViewControllerSpineLocation) pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation&#123; return UIPageViewControllerSpineLocationMid;&#125; 运行效果如下图所示： 四、UIPageViewControllerDataSource中方法解析12345678//向前翻页展示的ViewController- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerBeforeViewController:(UIViewController *)viewController;//向后翻页展示的ViewController- (nullable UIViewController *)pageViewController:(UIPageViewController *)pageViewController viewControllerAfterViewController:(UIViewController *)viewController;//设置分页控制器的分页点数- (NSInteger)presentationCountForPageViewController:(UIPageViewController *)pageViewController NS_AVAILABLE_IOS(6_0);//设置当前分页控制器所高亮的点- (NSInteger)presentationIndexForPageViewController:(UIPageViewController *)pageViewController NS_AVAILABLE_IOS(6_0); 五、UIPageViewControllerDelegate中方法解析123456//翻页视图控制器将要翻页时执行的方法- (void)pageViewController:(UIPageViewController *)pageViewController willTransitionToViewControllers:(NSArray&lt;UIViewController *&gt; *)pendingViewControllers NS_AVAILABLE_IOS(6_0);//翻页动画执行完成后回调的方法- (void)pageViewController:(UIPageViewController *)pageViewController didFinishAnimating:(BOOL)finished previousViewControllers:(NSArray&lt;UIViewController *&gt; *)previousViewControllers transitionCompleted:(BOOL)completed;//屏幕防线改变时回到的方法，可以通过返回值重设书轴类型枚举- (UIPageViewControllerSpineLocation)pageViewController:(UIPageViewController *)pageViewController spineLocationForInterfaceOrientation:(UIInterfaceOrientation)orientation; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS网络编程之七——本地用户凭证Cookie的应用","slug":"183iOS网络编程之七——本地用户凭证Cookie的应用","date":"2016-02-29T16:00:00.000Z","updated":"2021-07-06T07:08:22.118Z","comments":true,"path":"2016/03/01/183iOS网络编程之七——本地用户凭证Cookie的应用/","link":"","permalink":"http://huishao.cc/2016/03/01/183iOS网络编程之七——本地用户凭证Cookie的应用/","excerpt":"","text":"iOS网络编程之七——本地用户凭证Cookie的应用一、何为CookieCookie是网站为了便是终端身份，保存在终端本地的用户凭证信息。Cookie中的字段与意义由服务端进行定义。例如，当用户在某个网站进行了登录操作后，服务端会将Cookie信息返回给终端，终端会将这些信息进行保存，在下一次再次访问这个网站时，终端会将保存的Cookie信息一并发送到服务端，服务端根据Cookie信息是否有效来判断此用户是否可以自动登录。 二、iOS中进行Cookie管理的两个类iOS中进行HTTP网络请求Cookie管理主要由两个类负责，一个类是NSHTTPCookieStorage类，一个是NSHTTPCookie类。 1.NSHTTPCookieStorageNSHTTPCookieStorage类采用单例的设计模式，其中管理着所有HTTP请求的Cookie信息，常用方法如下： 123456789101112131415161718192021222324//获取单例对象+ (NSHTTPCookieStorage *)sharedHTTPCookieStorage;//所有Cookie数据数组 其中存放NSHTTPCookie对象@property (nullable , readonly, copy) NSArray&lt;NSHTTPCookie *&gt; *cookies;//手动设置一条Cookie数据- (void)setCookie:(NSHTTPCookie *)cookie;//删除某条Cookie信息- (void)deleteCookie:(NSHTTPCookie *)cookie;//删除某个时间后的所有Cookie信息 iOS8后可用- (nullable NSArray&lt;NSHTTPCookie *&gt; *)cookiesForURL:(NSURL *)URL;//获取某个特定URL的所有Cookie数据- (void)removeCookiesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//为某个特定的URL设置Cookie- (void)setCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies forURL:(nullable NSURL *)URL mainDocumentURL:(nullable NSURL *)mainDocumentURL;//Cookie数据的接收协议/*枚举如下：typedef NS_ENUM(NSUInteger, NSHTTPCookieAcceptPolicy) &#123; NSHTTPCookieAcceptPolicyAlways,//接收所有Cookie信息 NSHTTPCookieAcceptPolicyNever,//不接收所有Cookie信息 NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain//只接收主文档域的Cookie信息&#125;;*/@property NSHTTPCookieAcceptPolicy cookieAcceptPolicy; 系统下面的两个通知与Cookie管理有关： 1234//Cookie数据的接收协议改变时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerAcceptPolicyChangedNotification;//管理的Cookie数据发生变化时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerCookiesChangedNotification; 2.NSHTTPCookieNSHTTPCookie是具体的HTTP请求Cookie数据对象，其中属性方法如下： 12345678910111213141516171819202122232425262728293031//下面两个方法用于对象的创建和初始化 都是通过字典进行键值设置- (nullable instancetype)initWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;+ (nullable NSHTTPCookie *)cookieWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;//返回Cookie数据中可用于添加HTTP头字段的字典+ (NSDictionary&lt;NSString *, NSString *&gt; *)requestHeaderFieldsWithCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies;//从指定的响应头和URL地址中解析出Cookie数据+ (NSArray&lt;NSHTTPCookie *&gt; *)cookiesWithResponseHeaderFields:(NSDictionary&lt;NSString *, NSString *&gt; *)headerFields forURL:(NSURL *)URL;//Cookie数据中的属性字典@property (nullable, readonly, copy) NSDictionary&lt;NSString *, id&gt; *properties;//请求响应的版本@property (readonly) NSUInteger version;//请求相应的名称@property (readonly, copy) NSString *name;//请求相应的值@property (readonly, copy) NSString *value;//过期时间@property (nullable, readonly, copy) NSDate *expiresDate;//请求的域名@property (readonly, copy) NSString *domain;//请求的路径@property (readonly, copy) NSString *path;//是否是安全传输@property (readonly, getter=isSecure) BOOL secure;//是否只发送HTTP的服务@property (readonly, getter=isHTTPOnly) BOOL HTTPOnly;//响应的文档@property (nullable, readonly, copy) NSString *comment;//相应的文档URL@property (nullable, readonly, copy) NSURL *commentURL;//服务端口列表@property (nullable, readonly, copy) NSArray&lt;NSNumber *&gt; *portList; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之六——数据缓存类NSURLCache使用解析","slug":"182iOS网络编程之六——数据缓存类NSURLCache使用解析","date":"2016-02-25T16:00:00.000Z","updated":"2021-07-06T07:07:32.331Z","comments":true,"path":"2016/02/26/182iOS网络编程之六——数据缓存类NSURLCache使用解析/","link":"","permalink":"http://huishao.cc/2016/02/26/182iOS网络编程之六——数据缓存类NSURLCache使用解析/","excerpt":"","text":"iOS网络编程之六——数据缓存类NSURLCache使用解析一、引言在前面博客中，介绍了NSURLRequest请求类的相关使用方法，其中有介绍关于请求返回数据的缓存策略，实际上，iOS中具体缓存操作的管理是由NSURLCache类来实现的。NSURLRequest类介绍的博客地址如下： iOS中NSURLRequest相关使用：http://my.oschina.net/u/2340880/blog/620225。 二、NSURLCache中方法与属性123456789101112131415161718192021222324252627282930//获取当前应用的缓存管理对象+ (NSURLCache *)sharedURLCache;//设置自定义的NSURLCache作为应用缓存管理对象+ (void)setSharedURLCache:(NSURLCache *)cache;//初始化一个应用缓存对象/*memoryCapacity 设置内存缓存容量diskCapacity 设置磁盘缓存容量path 磁盘缓存路径内容缓存会在应用程序退出后 清空 磁盘缓存不会*/- (instancetype)initWithMemoryCapacity:(NSUInteger)memoryCapacity diskCapacity:(NSUInteger)diskCapacity diskPath:(nullable NSString *)path;//获取某一请求的缓存- (nullable NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request;//给请求设置指定的缓存- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;//移除某个请求的缓存- (void)removeCachedResponseForRequest:(NSURLRequest *)request;//移除所有缓存数据- (void)removeAllCachedResponses;//移除某个时间起的缓存设置- (void)removeCachedResponsesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//内存缓存容量大小@property NSUInteger memoryCapacity;//磁盘缓存容量大小@property NSUInteger diskCapacity;//当前已用内存容量@property (readonly) NSUInteger currentMemoryUsage;//当前已用磁盘容量@property (readonly) NSUInteger currentDiskUsage; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS新的视频开发框架AVPlayerViewContoller与画中画技术","slug":"181iOS新的视频开发框架AVPlayerViewContoller与画中画技术","date":"2016-02-24T16:00:00.000Z","updated":"2021-07-06T07:06:46.470Z","comments":true,"path":"2016/02/25/181iOS新的视频开发框架AVPlayerViewContoller与画中画技术/","link":"","permalink":"http://huishao.cc/2016/02/25/181iOS新的视频开发框架AVPlayerViewContoller与画中画技术/","excerpt":"","text":"iOS新的视频开发框架AVPlayerViewContoller与画中画技术一、引言前面有一篇博客探讨了iOS中视频播放的开发相关类和方法，那篇博客中主要讲解的是MeidaPlayer框架中的MPMoviePlayerController类和MPMoviePlayerViewController类。在iOS8中，iOS开发框架中引入了一个新的视频框架AVKit，其中提供了视频开发类AVPlayerViewController用于在应用中嵌入播放视频的控件。在iOS8中，这两个框架中的视频播放功能并无太大差异，基本都可以满足开发者的需求。iOS9系统后，iPad Air正式开始支持多任务与画中画的分屏功能，所谓画中画，即是用户可以将当前播放的视频缩小放在屏幕上同时进行其他应用程序的使用。这个革命性的功能将极大的方便用户的使用。于此同时，在iOS9中，MPMoviePlayerController与MPMoviePlayerViewController类也被完全易用，开发者使用AVPlayerViewController可以十分方便的实现视频播放的功能并在一些型号的iPad上集成画中画的功能。 二、AVPlayerViewController的使用与其中方法属性解析使用AVPlayerViewController首先需要引入两个框架，如下： 12#import &lt;AVKit/AVKit.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt; 使用如下代码进行视频的播放： 12345 NSString * path = [[NSBundle mainBundle]pathForResource:@&quot;iphone&quot; ofType:@&quot;mp4&quot;]; NSURL *url = [NSURL fileURLWithPath:path]; AVPlayerViewController * play = [[AVPlayerViewController alloc]init]; play.player = [[AVPlayer alloc]initWithURL:url]; [self presentViewController:play animated:YES completion:nil]; 运行工程，可以看到如下图所示的视频播放界面： AVPlayerViewController中还有如下属性和方法提供给开发者使用： 1234567891011121314151617181920//是否显示视频播放控制控件@property (nonatomic) BOOL showsPlaybackControls;//设置视频播放界面的尺寸缩放选项/*可以设置的值及意义如下：AVLayerVideoGravityResizeAspect 不进行比例缩放 以宽高中长的一边充满为基准AVLayerVideoGravityResizeAspectFill 不进行比例缩放 以宽高中短的一边充满为基准AVLayerVideoGravityResize 进行缩放充满屏幕*/@property (nonatomic, copy) NSString *videoGravity;//获取是否已经准备好开始播放@property (nonatomic, readonly, getter = isReadyForDisplay) BOOL readyForDisplay;//获取视频播放界面的尺寸@property (nonatomic, readonly) CGRect videoBounds;//视频播放器的视图 自定义的控件可以添加在其上@property (nonatomic, readonly, nullable) UIView *contentOverlayView;//画中画代理 iOS9后可用@property (nonatomic, weak, nullable) id &lt;AVPlayerViewControllerDelegate&gt; delegate NS_AVAILABLE_IOS(9_0);//是否支持画中画 iOS9后可用 默认支持@property (nonatomic) BOOL allowsPictureInPicturePlayback NS_AVAILABLE_IOS(9_0); 三、画中画编程技术应用AVPlayerViewController是默认支持画中画操作的，如上图所示，视频的播放界面右下角出现一个画中画的按钮，点击这个按钮当前播放的视频界面会缩小显示在屏幕角落，这时点击Home键回到主界面，或者切换到其他应用程序，视频播放不会中断。如下图所示： 两指的捏合操作可以将缩小的视频播放窗口进行任意尺寸的放大，如果将视频窗口拖进屏幕的边界，视频窗口会被吸进边界，用户可以通过拖拽手势将其拉出，如下图： AVPlayerViewControllerDelegate中的方法可以对用户画中画的操作进行监听： 12345678910111213141516171819202122//将要开始画中画时调用的方法- (void)playerViewControllerWillStartPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//已经开始画中画时调用的方法- (void)playerViewControllerDidStartPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//开始画中画失败调用的方法- (void)playerViewController:(AVPlayerViewController *)playerViewController failedToStartPictureInPictureWithError:(NSError *)error&#123;&#125;//将要停止画中画时调用的方法- (void)playerViewControllerWillStopPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//已经停止画中画时调用的方法- (void)playerViewControllerDidStopPictureInPicture:(AVPlayerViewController *)playerViewController&#123;&#125;//是否在开始画中画时自动将当前的播放界面dismiss掉 返回YES则自动dismiss 返回NO则不会自动dismiss- (BOOL)playerViewControllerShouldAutomaticallyDismissAtPictureInPictureStart:(AVPlayerViewController *)playerViewController&#123; return YES;&#125;//用户点击还原按钮 从画中画模式还原回app内嵌模式时调用的方法- (void)playerViewController:(AVPlayerViewController *)playerViewController restoreUserInterfaceForPictureInPictureStopWithCompletionHandler:(void (^)(BOOL restored))completionHandler&#123;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之五——请求回执类NSURLResponse属性简介","slug":"180iOS网络编程之五——请求回执类NSURLResponse属性简介","date":"2016-02-24T16:00:00.000Z","updated":"2021-07-06T07:05:44.967Z","comments":true,"path":"2016/02/25/180iOS网络编程之五——请求回执类NSURLResponse属性简介/","link":"","permalink":"http://huishao.cc/2016/02/25/180iOS网络编程之五——请求回执类NSURLResponse属性简介/","excerpt":"","text":"iOS网络编程之五——请求回执类NSURLResponse属性简介NSURLResponse类中存放请求的回执信息，在发送网络请求时，如果请求成功，首先会接收到服务端的回执信息，直接开始接收具体的返回数据。NSURLResponse对象中主要有以下属性： 12345678910//请求的URL地址@property (nullable, readonly, copy) NSURL *URL;//返回数据的数据类型@property (nullable, readonly, copy) NSString *MIMEType;//获取返回数据的内容长度@property (readonly) long long expectedContentLength;//获取返回数据的编码方式@property (nullable, readonly, copy) NSString *textEncodingName;//返回拼接的数据文件名 以url为名 数据没醒MIMEType为扩展名@property (nullable, readonly, copy) NSString *suggestedFilename; 对于HTTP请求，请求回执会被封装为NSHTTPURLResponse对象，其中除了有上面那些属性外，还有如下的扩展属性： 1234//请求的状态码@property (readonly) NSInteger statusCode;//请求头中所有的字段@property (readonly, copy) NSDictionary *allHeaderFields; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之四——请求类NSURLRequest使用详解","slug":"179iOS网络编程之四——请求类NSURLRequest使用详解","date":"2016-02-23T16:00:00.000Z","updated":"2021-07-06T07:04:51.574Z","comments":true,"path":"2016/02/24/179iOS网络编程之四——请求类NSURLRequest使用详解/","link":"","permalink":"http://huishao.cc/2016/02/24/179iOS网络编程之四——请求类NSURLRequest使用详解/","excerpt":"","text":"iOS网络编程之四——请求类NSURLRequest使用详解一、引言在前面几篇博客中，介绍了iOS开发中的网络编程相关内容并且介绍了常用了两个平行的网络框架NSURLSession和NSURLConnection。无论是NSURLSession类还是NSURLConnection类，其网络请求都是通过NSURLRequest类进行发起的，本篇博客将介绍NSURLRequest类的用法和其中请求属性的设置。 前几篇博客地址如下： 1.iOS网络框架介绍：http://my.oschina.net/u/2340880/blog/618460。 2.NSURLSesstion的使用：http://my.oschina.net/u/2340880/blog/618888。 3.NSURLConnection的使用：http://my.oschina.net/u/2340880/blog/618920。 二、NSURLRequest类中常用方法和属性总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//通过类方法创建默认的请求对象/*通过这种方式创建的请求对象 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s*/+ (instancetype)requestWithURL:(NSURL *)URL;//返回一个BOOL值 用于判断是否支持安全编码+ (BOOL)supportsSecureCoding;//请求对象的初始化方法 创建时设置缓存逻辑和超时时限+ (instancetype)requestWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval;//init方法进行对象的创建 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s- (instancetype)initWithURL:(NSURL *)URL;//init方法进行对象的创建- (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval;//只读属性 获取请求对象的URL@property (nullable, readonly, copy) NSURL *URL;//只读属性 缓存策略枚举/*NSURLRequestCachePolicy枚举如下：typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)&#123; //默认的缓存协议 NSURLRequestUseProtocolCachePolicy = 0, //无论有无本地缓存数据 都进行从新请求 NSURLRequestReloadIgnoringLocalCacheData = 1, //忽略本地和远程的缓存数据 未实现的策略 NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, //无论有无缓存数据 都进行从新请求 NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, //先检查缓存 如果没有缓存再进行请求 NSURLRequestReturnCacheDataElseLoad = 2, //类似离线模式，只读缓存 无论有无缓存都不进行请求 NSURLRequestReturnCacheDataDontLoad = 3, //未实现的策略 NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented&#125;;*/@property (readonly) NSURLRequestCachePolicy cachePolicy;//只读属性 获取请求的超时时限@property (readonly) NSTimeInterval timeoutInterval;//请求主文档地址 @property (nullable, readonly, copy) NSURL *mainDocumentURL;//获取网络请求的服务类型 枚举如下/*typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)&#123; NSURLNetworkServiceTypeDefault = 0, // Standard internet traffic NSURLNetworkServiceTypeVoIP = 1, // Voice over IP control traffic NSURLNetworkServiceTypeVideo = 2, // Video traffic NSURLNetworkServiceTypeBackground = 3, // Background traffic NSURLNetworkServiceTypeVoice = 4 // Voice data&#125;;*/@property (readonly) NSURLRequestNetworkServiceType networkServiceType;//获取是否允许使用服务商蜂窝网络@property (readonly) BOOL allowsCellularAccess; NSURLRequest请求类除了在初始化时可以设定一些属性，创建出来后则大部分属性都为只读的，无法设置与修改。另一个类NSMutableURLRequest可以更加灵活的设置请求的相关属性。 三、NSMutableURLRequest类中常用方法与属性总结123456789101112//设置请求的URL@property (nullable, copy) NSURL *URL;//设置请求的缓存策略@property NSURLRequestCachePolicy cachePolicy;//设置超时时间@property NSTimeInterval timeoutInterval;//请求主文档地址@property (nullable, copy) NSURL *mainDocumentURL;//设置网络服务类型@property NSURLRequestNetworkServiceType networkServiceType NS_AVAILABLE(10_7, 4_0);//设置是否允许使用服务商蜂窝网@property BOOL allowsCellularAccess NS_AVAILABLE(10_8, 6_0); 四、NSURLRequest请求对象与HTTP/HTTPS协议相关请求的属性设置一下属性的设置必须使用NSMutableURLRequest类，如果是NSURLRequest，则只可以读，不可以修改。 12345678910111213141516//设置HPPT请求方式 默认为“GET”@property (copy) NSString *HTTPMethod;//通过字典设置HTTP请求头的键值数据@property (nullable, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields;//设置http请求头中的字段值- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//向http请求头中添加一个字段- (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//设置http请求体 用于POST请求@property (nullable, copy) NSData *HTTPBody;//设置http请求体的输入流@property (nullable, retain) NSInputStream *HTTPBodyStream;//设置发送请求时是否发送cookie数据@property BOOL HTTPShouldHandleCookies;//设置请求时是否按顺序收发 默认禁用 在某些服务器中设为YES可以提高网络性能@property BOOL HTTPShouldUsePipelining; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS应用内跳转系统设置相关界面的方法","slug":"178iOS应用内跳转系统设置相关界面的方法","date":"2016-02-22T16:00:00.000Z","updated":"2021-07-06T07:04:07.525Z","comments":true,"path":"2016/02/23/178iOS应用内跳转系统设置相关界面的方法/","link":"","permalink":"http://huishao.cc/2016/02/23/178iOS应用内跳转系统设置相关界面的方法/","excerpt":"","text":"iOS应用内跳转系统设置相关界面的方法在iOS开发中，有时会有跳转系统设置界面的需求，例如提示用户打开蓝牙或者WIFI，提醒用户打开推送或者位置权限等。在iOS6之后，第三方应用需要跳转系统设置界面，需要在URL type中添加一个prefs值，如下图： 跳转系统设置根目录中的项目使用如下的方法： 123456789101112131415161718 _array = @[ @&#123;@&quot;系统设置&quot;:@&quot;prefs:root=INTERNET_TETHERING&quot;&#125;, @&#123;@&quot;WIFI设置&quot;:@&quot;prefs:root=WIFI&quot;&#125;, @&#123;@&quot;蓝牙设置&quot;:@&quot;prefs:root=Bluetooth&quot;&#125;, @&#123;@&quot;系统通知&quot;:@&quot;prefs:root=NOTIFICATIONS_ID&quot;&#125;, @&#123;@&quot;通用设置&quot;:@&quot;prefs:root=General&quot;&#125;, @&#123;@&quot;显示设置&quot;:@&quot;prefs:root=DISPLAY&amp;BRIGHTNESS&quot;&#125;, @&#123;@&quot;壁纸设置&quot;:@&quot;prefs:root=Wallpaper&quot;&#125;, @&#123;@&quot;声音设置&quot;:@&quot;prefs:root=Sounds&quot;&#125;, @&#123;@&quot;隐私设置&quot;:@&quot;prefs:root=privacy&quot;&#125;, @&#123;@&quot;APP Store&quot;:@&quot;prefs:root=STORE&quot;&#125;, @&#123;@&quot;Notes&quot;:@&quot;prefs:root=NOTES&quot;&#125;, @&#123;@&quot;Safari&quot;:@&quot;prefs:root=Safari&quot;&#125;, @&#123;@&quot;Music&quot;:@&quot;prefs:root=MUSIC&quot;&#125;, @&#123;@&quot;photo&quot;:@&quot;prefs:root=Photos&quot;&#125; ]; NSURL * url = [NSURL URLWithString:[_array[index] allValues].firstObject]; [[UIApplication sharedApplication]openURL:url]; 如果要跳转第三方应用的设置界面中，使用prefs:root=boundleId的方式，boundleId是第三方应用的boundleId。 如果需要继续向项目内层进行跳转，可以通过添加path路径的方式，如下： 1234567891011121314 _array = @[ @&#123;@&quot;关于本机&quot;:@&quot;prefs:root=General&amp;path=About&quot;&#125;, @&#123;@&quot;软件升级&quot;:@&quot;prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK&quot;&#125;, @&#123;@&quot;日期时间&quot;:@&quot;prefs:root=General&amp;path=DATE_AND_TIME&quot;&#125;, @&#123;@&quot;Accessibility&quot;:@&quot;prefs:root=General&amp;path=ACCESSIBILITY&quot;&#125;, @&#123;@&quot;键盘设置&quot;:@&quot;prefs:root=General&amp;path=Keyboard&quot;&#125;, @&#123;@&quot;VPN&quot;:@&quot;prefs:root=General&amp;path=VPN&quot;&#125;, @&#123;@&quot;壁纸设置&quot;:@&quot;prefs:root=Wallpaper&quot;&#125;, @&#123;@&quot;声音设置&quot;:@&quot;prefs:root=Sounds&quot;&#125;, @&#123;@&quot;隐私设置&quot;:@&quot;prefs:root=privacy&quot;&#125;, @&#123;@&quot;APP Store&quot;:@&quot;prefs:root=STORE&quot;&#125;, @&#123;@&quot;还原设置&quot;:@&quot;prefs:root=General&amp;path=Reset&quot;&#125;, @&#123;@&quot;应用通知&quot;:@&quot;prefs:root=NOTIFICATIONS_ID&amp;path=应用的boundleId&quot;&#125; ]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之一——iOS网络框架简介","slug":"175iOS网络编程之一——iOS网络框架简介","date":"2016-02-21T16:00:00.000Z","updated":"2021-07-06T07:00:53.808Z","comments":true,"path":"2016/02/22/175iOS网络编程之一——iOS网络框架简介/","link":"","permalink":"http://huishao.cc/2016/02/22/175iOS网络编程之一——iOS网络框架简介/","excerpt":"","text":"iOS网络编程之一——iOS网络框架简介一、引言通过网络，一款应用才能够内容丰富，才能够完成用户操作与后台数据的交互。网络编程是移动应用或游戏开发开发中不可缺少的技术。iOS原生的网络框架也十分完善，其中涉及到的许多类和协议用于处理网络开发中的各种需求 二、URL加载框架iOS的URL加载系统包含许多类与协议，这些类和协议相互协作完成URL加载的信息配置，协议支持，身份验证，cookie和缓存等功能。APPLE开发文档中有如下图表示他们之间的关系： 关于URL加载系统，在iOS7之后，NSURLSession是首选的API框架，在iOS9中NSURLConnection相关的方法被弃用，如果需要兼容十分旧的版本，依然需要使用NSURLConnection。 三、一些辅助类1.NSURLRequestNSURLRequest类负责一个具体的网络请求，其内部封装一个请求路径NSURL对象。如果需要对请求参数进行配置，可以使用NSMutableURLRequest。 2.NSURLResponseNSURLResponse类封装了相应数据，相应数据包括两部分，一部分是返回数据的状态码，数据长度、编码等信息，另一部分是内容数据本身。 3.NSURLCredential、NSURLProtectionSpace、NSURLCredentialStorage、NSURLAuthenticatioChallenge一些访问请求需要证书或者身份凭证进行验证，上面4个类对请求凭证进行相关设置。 4.NSURLCache在应用程序的开发中，为了减小对网络的依赖，提高程序性能，常常会对一些非实时性的数据进行缓存处理，NSURLCache类用于管理NSURLRequest请求缓存。 5.NSHTTPCookieStorage、NSHTTPCookieNSHTTPCookieStorage与NSHTTPCookie用于持久化的存储HTTP请求的Cookie数据。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之三——NSURLConnection的简单使用","slug":"177iOS网络编程之三——NSURLConnection的简单使用","date":"2016-02-21T16:00:00.000Z","updated":"2021-07-06T07:03:17.566Z","comments":true,"path":"2016/02/22/177iOS网络编程之三——NSURLConnection的简单使用/","link":"","permalink":"http://huishao.cc/2016/02/22/177iOS网络编程之三——NSURLConnection的简单使用/","excerpt":"","text":"iOS网络编程之三——NSURLConnection的简单使用一、引言在iOS7后，NSURLSession基本代替了NSURLConnection进行网络开发，在iOS9后，NSURLConnection相关方法被完全的弃用，iOS系统有向下兼容的特性，尽管NSURLConnection已经被弃用，但在开发中，其方法依然可以被使用，并且如果需要兼容到很低版本的iOS系统，有时就必须使用NSURLConnection类了。 二、使用NSURLConnection进行同步请求对于网络请求分为同步和异步两种，同步是指在请求结果返回之前，程序代码会卡在请求处，之后的代码不会被执行，异步是指在发送请求之后，一边在子线程中接收返回数据，一边执行之后的代码，当返回数据接收完毕后，采用回调的方式通知主线程做处理。 使用如下方法进行NSURLConnection的同步请求： 12345 NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; NSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil]; NSLog(@&quot;%@&quot;,data); NSLog(@&quot;继续执行&quot;); 打印信息如下图所示，从中可以看出，当数据返回结束时才执行后面的代码： 三、使用NSURLConnection进行异步请求使用同步的方式进行请求有一个很大的弊端，在进行网络请求时，数据的返回往往需要一定时间，不可能瞬间完成，使用同步的方式将导致界面卡死，没有提示也不能交互任何用户操作，这样的话，很有可能会给用户程序卡死的假象。 NSURLConnection类提供两种方式进行异步请求操作。 1.使用block的方式进行异步请求使用如下代码进行block方式的异步请求，在block中会传入请求到的返回数据和数据信息等参数： 1234567 NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; //其中的queue参数决定block中的代码在哪个队列中执行 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; NSLog(@&quot;%@&quot;,data); &#125;]; NSLog(@&quot;继续执行&quot;); 2.使用代理回调的异步请求方式首先遵守协议与生命一个可变的NSData用于接收数据： 12345@interface ViewController ()&lt;NSURLConnectionDataDelegate&gt;&#123; NSMutableData * _data;&#125;@end 使用如下的代码进行请求： 1234 _data = [[NSMutableData alloc]init]; NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [NSURLConnection connectionWithRequest:request delegate:self]; 请求发出后，会一次调用如下代理方法进行请求过程的监听和数据的获取： 12345678910111213141516-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; //开始接收数据 [_data setLength:0];&#125;-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; //正在接收数据 [_data appendData:data];&#125;-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; //接收数据失败 NSLog(@&quot;%@&quot;,error);&#125;-(void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; //接收数据完成 NSLog(@&quot;%@&quot;,_data);&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS网络编程之二——NSURLSession的简单使用","slug":"176iOS网络编程之二——NSURLSession的简单使用","date":"2016-02-21T16:00:00.000Z","updated":"2021-07-06T07:01:57.767Z","comments":true,"path":"2016/02/22/176iOS网络编程之二——NSURLSession的简单使用/","link":"","permalink":"http://huishao.cc/2016/02/22/176iOS网络编程之二——NSURLSession的简单使用/","excerpt":"","text":"iOS网络编程之二——NSURLSession的简单使用一、NSURLSession简介在iOS7之后，NSURLSession作为系统推荐使用的HTTP请求框架，在进行前台请求的情况下，NSURLSession与NSURLConnection并无太大差异，对于后台的请求，NSURLSession更加灵活的优势就将展现无遗。 1.NSURLSession集合的类型NSURLSession类提供3中Session类型： Default类型：提供前台请求相关方法，支持配置缓存，身份凭证等。 Ephemeral类型：即时的请求类型，不使用缓存，身份凭证等。 Background：后台类型，支持在后台完成请求任务。 2.NSURLSession任务的类型在NSURLSession中添加的请求任务支持3中类型： 数据任务：使用NSData对象进行数据的发送和获取，一般用于短数据的任务。 下载任务：从文件下载数据，支持后台下载。 上传任务：以文件的形式上传数据，支持后台上传。 二、创建并配置NSURLSession通过NSURLSessionConfiguration类对象对NSURLSession进行配置与创建，创建和配NSURLSession的示例代码如下： 1234567891011 //默认类型的 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; //即时类型的 NSURLSessionConfiguration * ephemeralConfiguration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; //后台类型的 NSURLSessionConfiguration * backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;SessionId&quot;]; //创建并设置session NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration]; NSURLSession * ephemeralSession = [NSURLSession sessionWithConfiguration:ephemeralConfiguration]; NSURLSession * backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfiguration]; NSURLSessionConfiguration还可以配置如缓存，网络模式等参数 三、使用NSURLSession进行网络请求的两种方式NSURLSession有两种方式进行网络数据的请求，一种是通过block的方式获取网络数据，一种是通过代理回调的方式获取网络数据。通过block的方式进行请求代码如下： 123456789101112 //创建session配置对象 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; //创建请求对象 NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; //创建session对象 NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration]; //添加任务 NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;,data); &#125;]; //开始任务 [task resume]; 使用代理回调的方式进行请求需要遵守如下协议： 12@interface ViewController ()&lt;NSURLSessionDataDelegate&gt;@end 将请求代码修改如下： 123456 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration delegate:self delegateQueue:[NSOperationQueue mainQueue]]; NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request]; [task resume]; 实现代理方法如下： 12345678//开始接受数据-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSLog(@&quot;=======%@&quot;,data);&#125;//接受数据结束-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;完成：error%@&quot;,error);&#125; 四、进行后台下载任务NSURLSession最大的优势在于其后台下载的灵活性，使用如下的代码进行后台数据下载： 1234 NSURLSessionConfiguration * backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;com.zyprosoft.backgroundsession&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]; NSURLSession * backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfiguration delegate:self delegateQueue:nil]; [[backgroundSession downloadTaskWithRequest:request]resume]; 在下面的回调方法中可以进行下载进度的监听： 1234- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; NSLog(@&quot;######&quot;);&#125; 如果在下载过程中点击Home键使应用程序进入后台，NSURLSession的相关代理方法将不再被回调，但是下载任务依然在进行，当后台下载完成后会与AppDelegate进行交互，会调用AppDelegate中的如下方法： 123-(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler&#123; NSLog(@&quot;1111&quot;);&#125; 之后应用程序在后台会调用NSURLSesstion代理的如下方法来通知下载结果： 12345678//此方法无论成功失败都会调用-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;完成：error%@&quot;,error);&#125;//此方法只有下载成功才会调用 文件放在location位置-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location&#123; &#125; 最后将调用NSURLSesstion的如下方法： 123456-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session&#123; NSLog(@&quot;All tasks are finished&quot;); &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列四——进行数据与页面的绑定","slug":"174iOS中CoreData数据管理系列四——进行数据与页面的绑定","date":"2016-01-31T16:00:00.000Z","updated":"2021-07-06T07:00:09.045Z","comments":true,"path":"2016/02/01/174iOS中CoreData数据管理系列四——进行数据与页面的绑定/","link":"","permalink":"http://huishao.cc/2016/02/01/174iOS中CoreData数据管理系列四——进行数据与页面的绑定/","excerpt":"","text":"iOS中CoreData数据管理系列四——进行数据与页面的绑定一、引言在上一篇博客中，我们讨论了CoreData框架中添加与查询数据的操作，事实上，在大多数情况下，这些数据都是由一个UITableView表视图进行展示的，因此，CoreData框架中还未开发者提供了一个类NSFetchedResultsController，这个类作为桥接，将视图与数据进行绑定。 添加与查询数据操作：http://my.oschina.net/u/2340880/blog/611430。 二、进行数据初始化NSFetchedResultsController的初始化需要一个查询请求和一个数据操作上下文。代码示例如下： 12345678910111213141516171819202122232425262728293031//遵守协议@interface ViewController ()&lt;NSFetchedResultsControllerDelegate&gt;&#123; //数据桥接对象 NSFetchedResultsController * _fecCon;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //进行初始化操作 NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; NSPersistentStoreCoordinator * psc = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:mom]; NSURL * path =[NSURL fileURLWithPath:[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]]; [psc addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:path options:nil error:nil]; NSManagedObjectContext * moc = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType]; [moc setPersistentStoreCoordinator:psc]; NSFetchRequest * request = [NSFetchRequest fetchRequestWithEntityName:@&quot;SchoolClass&quot;]; //设置数据排序 [request setSortDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@&quot;stuNum&quot; ascending:YES]]]; //进行数据桥接对象的初始化 _fecCon = [[NSFetchedResultsController alloc]initWithFetchRequest:request managedObjectContext:moc sectionNameKeyPath:nil cacheName:nil]; //设置代理 _fecCon.delegate=self; //进行数据查询 [_fecCon performFetch:nil];&#125;@end 用于初始化NSFecthedResultsController的数据请求对象必须设置一个排序规则。在initWithFetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:方法中，如果设置第三个参数，则会以第三个参数为键值进行数据的分区。当数据发生变化时，将通过代理进行方法的回调。 三、与UITableView进行数据绑定12345678910111213141516171819-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cellid&quot;]; if (!cell) &#123; cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;cellid&quot;]; &#125; //获取相应数据模型 SchoolClass * obj = [_fecCon objectAtIndexPath:indexPath]; cell.textLabel.text = obj.name; cell.detailTextLabel.text = [NSString stringWithFormat:@&quot;有%@人&quot;,obj.stuNum]; return cell;&#125;-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123; return [_fecCon sections].count;&#125;-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; id&lt;NSFetchedResultsSectionInfo&gt; info = [_fecCon sections][section]; return [info numberOfObjects]; &#125; 效果如下： 四、将数据变化映射到视图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//数据将要改变时调用的方法- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller&#123; //开启tableView更新预处理 [[self tableView] beginUpdates];&#125;//分区数据改变时调用的方法- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;NSFetchedResultsSectionInfo&gt;)sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type&#123; //判断行为类型 switch(type) &#123; //插入新分区 case NSFetchedResultsChangeInsert: [[self tableView] insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; //删除分区 case NSFetchedResultsChangeDelete: [[self tableView] deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade]; break; //移动分区 case NSFetchedResultsChangeMove: //更新分区 case NSFetchedResultsChangeUpdate: break; &#125;&#125;//数据改变时回调的代理- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath&#123; switch(type) &#123; //插入数据 case NSFetchedResultsChangeInsert: [[self tableView] insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade]; break; //删除数据 case NSFetchedResultsChangeDelete: [[self tableView] deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; break; //更新数据 case NSFetchedResultsChangeUpdate: [self reloadData]; break; //移动数据 case NSFetchedResultsChangeMove: [[self tableView] deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade]; [[self tableView] insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade]; break; &#125;&#125;//数据更新结束调用的代理- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller&#123; [[self tableView] endUpdates];&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列三——添加与查询数据","slug":"173iOS中CoreData数据管理系列三——添加与查询数据","date":"2016-01-28T16:00:00.000Z","updated":"2021-07-06T06:59:11.149Z","comments":true,"path":"2016/01/29/173iOS中CoreData数据管理系列三——添加与查询数据/","link":"","permalink":"http://huishao.cc/2016/01/29/173iOS中CoreData数据管理系列三——添加与查询数据/","excerpt":"","text":"iOS中CoreData数据管理系列三——添加与查询数据一、引言在前两篇博客中，分别介绍了iOS中CoreData框架创建数据模型和CoreData框架中的三个核心类。博客地址如下： iOS中CoreData框架简介：http://my.oschina.net/u/2340880/blog/610488。 CoreData框架中三个核心的类：http://my.oschina.net/u/2340880/blog/610948。 本篇博客将综合使用三个核心的类，进行数据创建和查询的操作介绍。 二、建立数据对象类前面博客介绍的NSManagedObjectModel是数据管理模型，可以将其类比如数据库，NSManagedObjectModel中存放着数据库的结构信息。NSEntityDescription是实体描述对象，它可以类比如数据库中的表，NSEntityDescription存放的是表的结构信息。这些类都是一些抽象的结构类，并不存储实际每条数据的信息，具体的数据由NSManagedObject类来描述，我们一般会将实体类化继承于NSManagedObject。 Xocde工具提供了快捷的实体类化功能，还拿我们一开始创建的班级与学生实体来演示，点击.xcdatamodeld文件，点击Xcode工具上方导航栏的Editor标签，选择Creat NSManagedObject Subclass选项，在弹出的窗口中勾选要类化的实体，如下图： 这时，Xcode会自动为我们创建一个文件，这些文件中有各个类中属性的声明。 三、创建一条数据使用如下代码进行数据的创建： 12345678910111213141516171819202122232425262728293031323334 //读取数据模型文件 NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; //创建数据模型 NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; //创建持久化存储协调者 NSPersistentStoreCoordinator * psc = [[NSPersistentStoreCoordinator alloc]initWithManagedObjectModel:mom]; //数据库保存路径 NSURL * path =[NSURL fileURLWithPath:[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]]; //为持久化协调者添加一个数据接收栈 /* 可以支持的类型如下： NSString * const NSSQLiteStoreType;//sqlite NSString * const NSXMLStoreType;//XML NSString * const NSBinaryStoreType;//二进制 NSString * const NSInMemoryStoreType;//内存 */ [psc addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:path options:nil error:nil]; //创建数据管理上下文 NSManagedObjectContext * moc = [[NSManagedObjectContext alloc]initWithConcurrencyType:NSMainQueueConcurrencyType]; //关联持久化协调者 [moc setPersistentStoreCoordinator:psc]; //创建数据对象 /* 数据对象的创建是通过实体名获取到的 */ SchoolClass * modelS = [NSEntityDescription insertNewObjectForEntityForName:@&quot;SchoolClass&quot; inManagedObjectContext:moc]; //对数据进行设置 modelS.name = @&quot;第一班&quot;; modelS.stuNum = @60; //进行存储 if ([moc save:nil]) &#123; NSLog(@&quot;新增成功&quot;); &#125; NSLog(@&quot;%@&quot;,[[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)lastObject] stringByAppendingPathComponent:@&quot;CoreDataExample.sqlite&quot;]); 找到在打印出的路径，会发现里面多了一个sqlite文件，其中有一张表中添加进了一条数据。 四、查询数据CoreData中通过查询请求来对数据进行查询操作，查询请求由NSFetchRequest来进行管理和维护。 NSFetchRequest主要提供两个方面的查询服务： 1.提供范围查询的相关功能 2.提供查询结果返回类型与排序的相关功能 NSFetchRequest中常用方法如下： 12345678910111213141516171819202122//创建一个实体的查询请求 可以理解为在某个表中进行查询+ (instancetype)fetchRequestWithEntityName:(NSString*)entityName;//查询条件@property (nullable, nonatomic, strong) NSPredicate *predicate;//数据排序@property (nullable, nonatomic, strong) NSArray&lt;NSSortDescriptor *&gt; *sortDescriptors;//每次查询返回的数据条数@property (nonatomic) NSUInteger fetchLimit;//设置查询到数据的返回类型/*typedef NS_OPTIONS(NSUInteger, NSFetchRequestResultType) &#123; NSManagedObjectResultType = 0x00, NSManagedObjectIDResultType = 0x01, NSDictionaryResultType NS_ENUM_AVAILABLE(10_6,3_0) = 0x02, NSCountResultType NS_ENUM_AVAILABLE(10_6,3_0) = 0x04&#125;;*/@property (nonatomic) NSFetchRequestResultType resultType;//设置查询结果是否包含子实体@property (nonatomic) BOOL includesSubentities;//设置要查询的属性值@property (nullable, nonatomic, copy) NSArray *propertiesToFetch; 在SchoolClass实体中查询数据，使用如下的代码： 1234567 //创建一条查询请求 NSFetchRequest * request = [NSFetchRequest fetchRequestWithEntityName:@&quot;SchoolClass&quot;]; //设置条件为 stuNum=60的数据 [request setPredicate:[NSPredicate predicateWithFormat:@&quot;stuNum == 60&quot;]]; //进行查询操作 NSArray * res = [moc executeFetchRequest:request error:nil]; NSLog(@&quot;%@&quot;,[res.firstObject stuNum]); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列二——CoreData框架中三个重要的类","slug":"172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类","date":"2016-01-27T16:00:00.000Z","updated":"2021-07-06T06:58:10.678Z","comments":true,"path":"2016/01/28/172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类/","link":"","permalink":"http://huishao.cc/2016/01/28/172iOS中CoreData数据管理系列二——CoreData框架中三个重要的类/","excerpt":"","text":"iOS中CoreData数据管理系列二——CoreData框架中三个重要的类一、引言在上一篇博客中，介绍了iOS中使用CoreData框架设计数据模型的相关步骤。CoreData框架中通过相关的类将数据——数据模型——开发者无缝的衔接起来。NSManagedObjectModel对应数据模型，即上篇博客中我们创建的.xcdatamodeld文件；NSPersistentStoreCoordinator相当于数据库与数据模型之间的桥接器，通过NSPersistentStoreCoordinator将数据模型存入数据库；NSManagedObjectContext是核心的数据管理类，开发者通过操作它来执行对数据的相关操作。 二、数据模型管理类NSManagedObjectModel通过NSManagedObjectModel，可以将创建的数据模型文件读取为模型管理类对象，使用如下方法： 1234 //获取.xcdatamodeld文件url NSURL *modelUrl = [[NSBundle mainBundle]URLForResource:@&quot;Model&quot; withExtension:@&quot;momd&quot;]; //读取文件 NSManagedObjectModel * mom = [[NSManagedObjectModel alloc]initWithContentsOfURL:modelUrl]; 其中还有一些属性和方法进行数据模型的管理： 123456789101112131415161718//将多个数据模型管理文件进行合并+ (nullable NSManagedObjectModel *)mergedModelFromBundles:(nullable NSArray&lt;NSBundle *&gt; *)bundles; //将多个数据模型管理类对象进行合并 + (nullable NSManagedObjectModel *)modelByMergingModels:(nullable NSArray&lt;NSManagedObjectModel *&gt; *)models;//存放数据中所有实体模型的字典 字典中是实体名和实体描述对象@property (readonly, copy) NSDictionary&lt;NSString *, NSEntityDescription *&gt; *entitiesByName;//存放数据中所有实体描述对象@property (strong) NSArray&lt;NSEntityDescription *&gt; *entities;//返回所有可用的配置名称@property (readonly, strong) NSArray&lt;NSString *&gt; *configurations;//获取关联某个配置的所有实体- (nullable NSArray&lt;NSEntityDescription *&gt; *)entitiesForConfiguration:(nullable NSString *)configuration;//为某个实体关联配置- (void)setEntities:(NSArray&lt;NSEntityDescription *&gt; *)entities forConfiguration:(NSString *)configuration;//创建请求模板- (void)setFetchRequestTemplate:(nullable NSFetchRequest *)fetchRequestTemplate forName:(NSString *)name;//获取请求模板- (nullable NSFetchRequest *)fetchRequestTemplateForName:(NSString *)name; 关于实体描述对象NSEntityDescription： 实体类似于数据库中的表结构，例如上次我们创建的班级实体模型，一个实体模型中可以添加许多属性与关系，NSEntityDescription对象中存放这些信息，常用如下： 1234567891011121314151617181920212223242526//实体所在的模型管理对象@property (readonly, assign) NSManagedObjectModel *managedObjectModel;//实体所在的模型管理对象的名称@property (null_resettable, copy) NSString *managedObjectClassName;//实体名@property (nullable, copy) NSString *name;//设置是否是抽象实体@property (getter=isAbstract) BOOL abstract;//子类实体字典@property (readonly, copy) NSDictionary&lt;NSString *, NSEntityDescription *&gt; *subentitiesByName;//所有子类实体对象数组@property (strong) NSArray&lt;NSEntityDescription *&gt; *subentities;//父类实体@property (nullable, readonly, assign) NSEntityDescription *superentity;//所有属性字典@property (readonly, copy) NSDictionary&lt;NSString *, __kindof NSPropertyDescription *&gt; *propertiesByName;//所有属性数组 @property (strong) NSArray&lt;__kindof NSPropertyDescription *&gt; *properties;//所有常类型属性@property (readonly, copy) NSDictionary&lt;NSString *, NSAttributeDescription *&gt; *attributesByName;//所有关系@property (readonly, copy) NSDictionary&lt;NSString *, NSRelationshipDescription *&gt; *relationshipsByName;//某个实体类型的所有关系- (NSArray&lt;NSRelationshipDescription *&gt; *)relationshipsWithDestinationEntity:(NSEntityDescription *)entity;//判断是否是某种实体- (BOOL)isKindOfEntity:(NSEntityDescription *)entity; NSPropertyDescription类是数据模型属性的父类，NSAttributeDescription和NSRelationshipDescription都是继承于NSPropertyDescription类，NSAttributeDescription描述正常类型的属性，NSRelationshipDescription用于描述自定义类型的关系。 三、持久化存储协调者类NSPersistentStoreCoordinatorNSPersistentStoreCoordinator建立数据模型与本地文件或数据库之间的联系，通过它将本地数据读入内存或者将修改过的临时数据进行持久化的保存。其初始化与链接数据持久化接收对象方法如下： 123456//通过数据模型管理对象进行初始化- (instancetype)initWithManagedObjectModel:(NSManagedObjectModel *)model；//添加一个持久化的数据接收对象- (nullable __kindof NSPersistentStore *)addPersistentStoreWithType:(NSString *)storeType configuration:(nullable NSString *)configuration URL:(nullable NSURL *)storeURL options:(nullable NSDictionary *)options error:(NSError **)error;//移除一个持久化的数据接收对象- (BOOL)removePersistentStore:(NSPersistentStore *)store error:(NSError **)error; 四、数据对象管理上下文NSManagedObjectContextNSManagedObjectContext是进行数据管理的核心类，我们通过这个类来进行数据的增删改查等操作。其中常用方法如下： 1234567891011121314151617181920212223242526272829303132//初始化方法 通过一个并发类型进行初始化 参数枚举如下：/*typedef NS_ENUM(NSUInteger, NSManagedObjectContextConcurrencyType) &#123; NSPrivateQueueConcurrencyType = 0x01,//上下文对象与私有队列关联 NSMainQueueConcurrencyType = 0x02//上下文对象与主队列关联&#125;;*/- (instancetype)initWithConcurrencyType:(NSManagedObjectContextConcurrencyType)ct;//异步执行block- (void)performBlock:(void (^)())block;//同步执行block- (void)performBlockAndWait:(void (^)())block;//关联数据持久化对象@property (nullable, strong) NSPersistentStoreCoordinator *persistentStoreCoordinator;//是否有未提交的更改@property (nonatomic, readonly) BOOL hasChanges;//进行查询数据请求- (nullable NSArray *)executeFetchRequest:(NSFetchRequest *)request error:(NSError **)error;//进行查询数据条数请求- (NSUInteger) countForFetchRequest: (NSFetchRequest *)request error: (NSError **)error ; //插入元素- (void)insertObject:(NSManagedObject *)object;//删除元素- (void)deleteObject:(NSManagedObject *)object;//回滚一步操作- (void)undo;//清楚缓存- (void)reset;//还原数据- (void)rollback;//提交保存数据- (BOOL)save:(NSError **)error; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中CoreData数据管理系列一——初识CoreData","slug":"171iOS中CoreData数据管理系列一——初识CoreData","date":"2016-01-26T16:00:00.000Z","updated":"2021-07-06T06:56:40.291Z","comments":true,"path":"2016/01/27/171iOS中CoreData数据管理系列一——初识CoreData/","link":"","permalink":"http://huishao.cc/2016/01/27/171iOS中CoreData数据管理系列一——初识CoreData/","excerpt":"","text":"iOS中CoreData数据管理系列一——初识CoreData一、何为CoreDataCoreData是一个专门用来管理数据的框架，其在性能与书写方便上都有很大的优势，在数据库管理方面，apple强烈推荐开发者使用CoreData框架，在apple的官方文档中称，使用CoreData框架可以减少开发者50%——70%的代码量，这虽然有些夸张，但由此可见，CoreData的确十分强大。 二、设计数据模型在iOS开发中，时常使用SQL数据库对大量的表结构数据进行处理，但是SQL有一个十分明显的缺陷，对于常规数据模型的表，其处理起来是没问题的，例如一个班级表，其中每条数据中有班级名称，人数这样的属性，一个学生表，其中每条数据有学生的姓名，性别，年龄这样的属性。但是如果要在表与表之间建立联系，自定义对象与自定义对象之间产生从属关系，使用SQL处理起来就十分麻烦了，例如如果这个班级表中有一个班长的属性，这个属性是一个学生类型。关于iOS中SQL的使用相关博客，地址如下： Sqlite数据库相关知识：http://my.oschina.net/u/2340880/blog/600820 iOS中sqlite3框架的使用和封装：http://my.oschina.net/u/2340880/blog/601802 CoreData的一大优势即是其可以方便的在对象之间建立关系。 1.创建实体类型及其属性使用Xcode创建一个工程，在工程中新建一个文件，选择Core Data分类中的DataModel创建，如下图： 这时在Xcode的文件导航区会出现一个以xcdatamodeld为扩展名的文件，这个文件就是数据模型文件，点击Add Entity按钮添加一个实体类型，取名为SchoolClass，为这个类型添加两个属性，分别为名字name和学生数量stuNum，如下图: 2.对实体类型进行设置在Xcode右侧的工具栏中可以对实体类型进行一些设置，选中一个实体类型，如下图： Name设置实体类型的名称，Abstract Entity设置是否是抽象实体，如果勾选，则此实体不能被实例化，只能被继承，类似于抽象类，比如定义人为一个实体类型，在定义继承于人实体类型的老师、学生等来进行实例化。Parent Entity用来选择父类实体，Class用于设置对应的类的。 3.在实体对象之间建立关系再创建一个学生类实体Student，添加name和age两个属性。选中SchoolClass，在其中的Relationships模块中点击+号，来添加一个关系，如下图： 这时，SchoolClass实体类型中就有了一个Student类型的班长属性。如果切换一下编辑风格，可以更加清晰的看到实体类型之间的关系，如下图： 4.对属性和关系进行设置选中一个属性或者关系，在右侧的工具栏中可以对属性进行一些设置，如下图： name设置属性的名字，Optional类型代表可选，即在实例化对象时可以赋值也可以不赋值。Attribute设置属性的数据类型，Default Value设置数据的默认值。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中播放gif动态图的方式探讨","slug":"170iOS中播放gif动态图的方式探讨","date":"2016-01-23T16:00:00.000Z","updated":"2021-07-06T06:48:41.373Z","comments":true,"path":"2016/01/24/170iOS中播放gif动态图的方式探讨/","link":"","permalink":"http://huishao.cc/2016/01/24/170iOS中播放gif动态图的方式探讨/","excerpt":"","text":"iOS中播放gif动态图的方式探讨一、引言在iOS开发中，UIImageView类专门来负责图片数据的渲染，并且UIImageView也有帧动画的方法来播放一组图片，但是对于gif类型的数据，UIImageView中并没有现成的接口提供给开发者使用，在iOS中一般可以通过两种方式来播放gif动态图，一种方式是通过ImageIO框架中的方法将gif文件中的数据进行解析，再使用coreAnimation核心动画来播放gif动画，另一种方式计较简单，可以直接通过webView来渲染gif图。 二、为原生的UIImageView添加类别来支持gif动态图的播放 gif动态图文件中包含了一组图片及其信息，信息主要记录着每一帧图片播放的时间，我们如果获取到了gif文件中所有的图片同时又获取到每一帧图片播放的时间，就可以为UIImageView添加核心动画的方法来让其播放gif的内容了。 首先解析gif文件中的数据，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//要引入ImageIO库#import &lt;ImageIO/ImageIO.h&gt;//解析gif文件数据的方法 block中会将解析的数据传递出来-(void)getGifImageWithUrk:(NSURL *)url returnData:(void(^)(NSArray&lt;UIImage *&gt; * imageArray, NSArray&lt;NSNumber *&gt;*timeArray, CGFloat totalTime, NSArray&lt;NSNumber *&gt;* widths, NSArray&lt;NSNumber *&gt;* heights))dataBlock&#123; //通过文件的url来将gif文件读取为图片数据引用 CGImageSourceRef source = CGImageSourceCreateWithURL((CFURLRef)url, NULL); //获取gif文件中图片的个数 size_t count = CGImageSourceGetCount(source); //定义一个变量记录gif播放一轮的时间 float allTime=0; //存放所有图片 NSMutableArray * imageArray = [[NSMutableArray alloc]init]; //存放每一帧播放的时间 NSMutableArray * timeArray = [[NSMutableArray alloc]init]; //存放每张图片的宽度 （一般在一个gif文件中，所有图片尺寸都会一样） NSMutableArray * widthArray = [[NSMutableArray alloc]init]; //存放每张图片的高度 NSMutableArray * heightArray = [[NSMutableArray alloc]init]; //遍历 for (size_t i=0; i&lt;count; i++) &#123; CGImageRef image = CGImageSourceCreateImageAtIndex(source, i, NULL); [imageArray addObject:(__bridge UIImage *)(image)]; CGImageRelease(image); //获取图片信息 NSDictionary * info = (__bridge NSDictionary*)CGImageSourceCopyPropertiesAtIndex(source, i, NULL); CGFloat width = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelWidth] floatValue]; CGFloat height = [[info objectForKey:(__bridge NSString *)kCGImagePropertyPixelHeight] floatValue]; [widthArray addObject:[NSNumber numberWithFloat:width]]; [heightArray addObject:[NSNumber numberWithFloat:height]]; NSDictionary * timeDic = [info objectForKey:(__bridge NSString *)kCGImagePropertyGIFDictionary]; CGFloat time = [[timeDic objectForKey:(__bridge NSString *)kCGImagePropertyGIFDelayTime]floatValue]; allTime+=time; [timeArray addObject:[NSNumber numberWithFloat:time]]; CFRelease(info); &#125; CFRelease(source); dataBlock(imageArray,timeArray,allTime,widthArray,heightArray);&#125; 为UIImageView添加一个设置gif图内容的方法： 1234567891011121314151617181920212223-(void)yh_setImage:(NSURL *)imageUrl&#123; __weak id __self = self; [self getGifImageWithUrk:imageUrl returnData:^(NSArray&lt;UIImage *&gt; *imageArray, NSArray&lt;NSNumber *&gt; *timeArray, CGFloat totalTime, NSArray&lt;NSNumber *&gt; *widths, NSArray&lt;NSNumber *&gt; *heights) &#123; //添加帧动画 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;contents&quot;]; NSMutableArray * times = [[NSMutableArray alloc]init]; float currentTime = 0; //设置每一帧的时间占比 for (int i=0; i&lt;imageArray.count; i++) &#123; [times addObject:[NSNumber numberWithFloat:currentTime/totalTime]]; currentTime+=[timeArray[i] floatValue]; &#125; [animation setKeyTimes:times]; [animation setValues:imageArray]; [animation setTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear]]; //设置循环 animation.repeatCount= MAXFLOAT; //设置播放总时长 animation.duration = totalTime; //Layer层添加 [[(UIImageView *)__self layer]addAnimation:animation forKey:@&quot;gifAnimation&quot;]; &#125;];&#125; 使用代码示例如下： 1234 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0,0 , 320, 200)]; NSURL * url = [[NSURL alloc]initFileURLWithPath:[[NSBundle mainBundle] pathForResource:imageName ofType:nil]]; [imageView yh_setImage:url]; [self.view addSubview:imageView]; 三、使用UIWebView来加载gif动态图数据iOS中的UIWebView功能十分强大，可以通过UIWebView为载体，来展示gif图。并且这种方法也十分简单，代码如下： 12345678910 //读取gif数据 NSData *gifData = [NSData dataWithContentsOfURL:imageUrl]; UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)]; //取消回弹效果 webView.scrollView.bounces=NO; webView.backgroundColor = [UIColor clearColor]; //设置缩放模式 webView.scalesPageToFit = YES; //用webView加载数据 [webView loadData:gifData MIMEType:@&quot;image/gif&quot; textEncodingName:nil baseURL:nil]; 四、两种加载gif动态图方式的优劣经过测试，从加载速度上来说，通过UIImageView类别加载的方式更加快速，UIWebView的方式加载时间会稍长，但是从性能上来比较，WebView的方式性能更优，播放的gif动态图更加流畅。在开发中，可以根据需求，适当选择，例如虽然WebView加载的方式性能更好，但是在许多情况下，原生的UIImageView能够更加自由的让开发者进行扩展。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"使用iOS原生sqlite3框架对sqlite数据库进行操作","slug":"169使用iOS原生sqlite3框架对sqlite数据库进行操作","date":"2016-01-12T16:00:00.000Z","updated":"2021-07-06T06:46:38.149Z","comments":true,"path":"2016/01/13/169使用iOS原生sqlite3框架对sqlite数据库进行操作/","link":"","permalink":"http://huishao.cc/2016/01/13/169使用iOS原生sqlite3框架对sqlite数据库进行操作/","excerpt":"","text":"使用iOS原生sqlite3框架对sqlite数据库进行操作一、引言sqlite数据库是一种小型数据库，由于其小巧与简洁，在移动开发领域应用深广，sqlite数据库有一套完备的sqlite语句进行管理操作，一些常用的语句和可视化的开发工具在上篇博客中有介绍，地址如下： sqlite数据库常用语句及可视化工具介绍：http://my.oschina.net/u/2340880/blog/600820。 在iOS的原生开发框架中可以对sqlite数据库进行很好的支持，这个框架中采用C风格且通过指针移动进行数据的操作，使用起来有些不便，我们可以对一些数据库的常用操作进行一些面向对象的封装。 二、libsqlite3系统库中操作数据库的常用方法libsqlite3是对sqlite数据库进行操作的系统库，在使用前，我们需要先导入，点击Xcode的Build Phases标签，展开Link Binary With Libraries，点击+号，在弹出的窗口中搜索libsqlite3.0，将其导入进工程，过程如下图： 在需要操作sqlite数据的文件中导入如下头文件： 1#import &lt;sqlite3.h&gt; 数据库文件的操作是由一个sqlite3类型的指针操作管理的，如下方法进行数据库的打开： 12sqlite3 *sqlite；sqlite3_open(dataBaePath, &amp;sqlite) sqlite3_open方法返回一个int值，实际上，在使用libsqlite3框架中的大多方法时都会返回一个int值，这个int值代表着方法执行的相应结果状态，这些状态再sqlite3.h文件中通过宏来定义，列举如下： 1234567891011121314151617181920212223242526272829303132#define SQLITE_OK 0 //操作成功/* 以下是错误代码 */#define SQLITE_ERROR 1 /* SQL数据库错误或者丢失*/#define SQLITE_INTERNAL 2 /* SQL内部逻辑错误 */#define SQLITE_PERM 3 /* 没有访问权限 */#define SQLITE_ABORT 4 /* 回调请求终止 */#define SQLITE_BUSY 5 /* 数据库文件被锁定 */#define SQLITE_LOCKED 6 /* 数据库中有表被锁定 */#define SQLITE_NOMEM 7 /* 分配空间失败 */#define SQLITE_READONLY 8 /* 企图向只读属性的数据库中做写操作 */#define SQLITE_INTERRUPT 9 /* 通过sqlite3_interrupt()方法终止操作*/#define SQLITE_IOERR 10 /* 磁盘发生错误 */#define SQLITE_CORRUPT 11 /* 数据库磁盘格式不正确 */#define SQLITE_NOTFOUND 12 /* 调用位置操作码 */#define SQLITE_FULL 13 /* 由于数据库已满造成的添加数据失败 */#define SQLITE_CANTOPEN 14 /* 不法打开数据库文件 */#define SQLITE_PROTOCOL 15 /* 数据库锁协议错误 */#define SQLITE_EMPTY 16 /* 数据库为空 */#define SQLITE_SCHEMA 17 /* 数据库模式更改 */#define SQLITE_TOOBIG 18 /* 字符或者二进制数据超出长度 */#define SQLITE_CONSTRAINT 19 /* 违反协议终止 */#define SQLITE_MISMATCH 20 /* 数据类型不匹配 */#define SQLITE_MISUSE 21 /* 库使用不当 */#define SQLITE_NOLFS 22 /* 使用不支持的操作系统 */#define SQLITE_AUTH 23 /* 授权拒绝 */#define SQLITE_FORMAT 24 /* 辅助数据库格式错误 */#define SQLITE_RANGE 25 /* sqlite3_bind 第二个参数超出范围 */#define SQLITE_NOTADB 26 /* 打开不是数据库的文件 */#define SQLITE_NOTICE 27 /* 来自sqlite3_log()的通知 */#define SQLITE_WARNING 28 /* 来自sqlite3_log() 的警告*/#define SQLITE_ROW 100 /* sqlite3_step() 方法准备好了一行数据 */#define SQLITE_DONE 101 /* sqlite3_step() 已完成执行*/ 执行非查询类的语句，例如创建，添加，删除等操作，使用如下方法： 123char * err;sqlite3 *sql;sqlite3_exec(sql, sqlStr, NULL, NULL, &amp;err); sqlite3_exec方法中第一个参数为成功执行了打开数据库操作的sqlite3指针，第二个参数为要执行的sql语句，最后一个参数为错误信息字符串。 执行查询语句的方法比较复杂，通过如下方法: 123456789 sqlite3 * sqlite; sqlite3_stmt *stmt =nil; int code = sqlite3_prepare_v2(sqlite, sqlStr, -1, &amp;stmt, NULL); while (sqlite3_step(stmt)==SQLITE_ROW) &#123; char * cString =(char*)sqlite3_column_text(stmt, 0); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; NSNumber * value = [NSNumber numberWithLongLong:sqlite3_column_int64(stmt, 1)]; &#125; sqlite3_finalize(stmt); stmt是一个数据位置指针，标记查询到数库的数据位置，sqlite3_prepare_v2()方法进行数据库查询的准备工作，第一个参数为成功打开的数据库指针，第二个参数为要执行的查询语句，第三个参数为sqlite3_stmt指针的地址，这个方法也会返回一个int值，作为标记状态是否成功。 sqlite3_step方法对stmt指针进行移动，会逐行进行移动，这个方法会返回一个int值，如果和SQLITE_ROW宏对应，则表明有此行数据，可以通过while循环来对数据进行读取。 sqlite3_column_XXX()是取行中每一列的数据，根据数据类型的不同，sqlite3_column_XXX()有一系列对应的方法，这个方法中第一个参数是stmt指针，第二个参数为列序号。 sqlite3_finalize()方法对stmt指针进行关闭。 三、面向对象的sqlite数据库操作框架封装网上不乏有许多优秀的第三方sqlite数据库使用框架，FFDM就是其中之一，并且apple自带的coreData也十分优秀。这篇博客中所述内容并不全面，代码也并不十分完善健壮，封装出来的代码除了能够完成基本的数据库操作外，更多主要是对设计思路的示例。 1.面向对象的sqlite管理类的设计思路为了便于使用，在设计时，我们尽量将libsqlite3中的方法不暴漏在使用层，通过面向应用的接口来进行方法的设计，设计思路类图如下： 图中，文件管理中心对文件进行存取删改管理，不暴漏在外，数据库管理中心负责对数据库的创建，删除打开等操作，具体的数据操作由数据库操作对象来完成。 2.文件管理中心方法的编写文件管理中心主要负责对数据库文件的存取，可以实现如下方法： YHBaseCecheCenter.h 12345678910111213141516/** * @brief 获取数据库方法的地址 * * @return 地址字符串 * */-(NSString *)getDataBaseFilePath;/** * @brief 获取某个数据库的大小 * * @param name 数据库名称 * * @return 文件大小 单位M * */-(float)getSizeFromDataBaseName:(NSString *)name; YHBaseCecheCenter.m 123456789101112131415-(NSString *)getDataBaseFilePath&#123; return NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;&#125;-(float)getSizeFromDataBaseName:(NSString *)name&#123; NSString * path = [NSString stringWithFormat:@&quot;/%@/%@&quot;,NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject,name]; return [self fileSizeAtPath:path]/(1024.0*1024.0);&#125;//获取文件大小- (long long) fileSizeAtPath:(NSString*) filePath&#123; NSFileManager* manager = [NSFileManager defaultManager]; if ([manager fileExistsAtPath:filePath])&#123; return [[manager attributesOfItemAtPath:filePath error:nil] fileSize]; &#125; return 0;&#125; 在iOS系统中因为其沙盒结构的限制，数据库必须方法documents目录下才能正常打开使用。 3.数据库管理中心的设计数据库管理中心主要负责对数据库的宏观操作，采用类方法的设计模式，如下 YHBaseSQLiteManager.h 123456789101112131415161718192021222324252627282930/** * @brief 打开一个数据库 如果不存在则会创建 * * @param name 数据库名称 * * @return 数据库操作对象 如果创建失败会返回nil * */+(YHBaseSQLiteContext *)openSQLiteWithName:(NSString *)name;/** * @brief 获取数据库文件的大小 单位M * * @param dataBase 数据库上下文对象 * * @return 数据库文件大小 */+(float)getSizeOfDataBase:(YHBaseSQLiteContext *)dataBase;/** * @brief 获取数据库文件的大小 单位M * * @param dataBaseName 数据库名称 * * @return 数据库文件大小 */+(float)getSizeOfDataBaseName:(NSString *)dataBaseName;/** * @brief 删除所有数据库 * */+(void)removeDataBase; YHBaseSQLiteManager.m 12345678910111213141516171819202122+(YHBaseSQLiteContext *)openSQLiteWithName:(NSString *)name&#123; NSString * path = [[YHBaseCecheCenter sharedTheSingletion]getDataBaseFilePath]; YHBaseSQLiteContext * context = [[YHBaseSQLiteContext alloc]init]; context.name = name; BOOL success = [context openDataBaeWithName:[NSString stringWithFormat:@&quot;%@/%@&quot;,path,name]]; if (success) &#123; return context; &#125;else&#123; return nil; &#125;&#125;+(float)getSizeOfDataBase:(YHBaseSQLiteContext *)dataBase&#123; return [[YHBaseCecheCenter sharedTheSingletion]getSizeFromDataBaseName:dataBase.name];&#125;+(float)getSizeOfDataBaseName:(NSString *)dataBaseName&#123; return [[YHBaseCecheCenter sharedTheSingletion]getSizeFromDataBaseName:dataBaseName];&#125;+(void)removeDataBase&#123; NSString * path = [[YHBaseCecheCenter sharedTheSingletion]getDataBaseFilePath]; return [[YHBaseCecheCenter sharedTheSingletion]removeCacheFromPath:path];&#125; 4.数据库操作对象将操作数据库的核心方法封装在这个类中： YHBaseSQLiteContext.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** *操作的数据库名称 */@property(nonatomic,strong)NSString * name;/** *内含sqlite3 对象 */@property(nonatomic,assign)sqlite3 * sqlite3_db;/** * @brief 打开一个数据库 不存在则创建 * * @param path 数据库路径 * * @return 是否操作成功 */-(BOOL)openDataBaeWithName:(NSString *)path;/** * @brief 再数据库中创建一张表 如果已经存在 会返回错误信息 * * @param name 表的名称 * * @prarm dic 表中的键 其中字典中需传入 键名：类型 类型的宏定义在YHBaseSQLTypeHeader.h中 * * @param callBack 结果回调 */-(void)createTableWithName:(NSString *)name keysDictionary:(NSDictionary&lt;NSString*,NSString*&gt; *) dic callBack:(void (^)(YHBaseSQLError * error))complete;/** * @brief 向表中添加一条数据 * * @param dataDic 添加数据的键值对 * * @param name 插入表的名称 * * @complete 回调 */-(void)insertData:(NSDictionary&lt;NSString *,id&gt;*)dataDic intoTable:(NSString *)name callBack:(void (^)(YHBaseSQLError * error))complete;/** * @brief 向表中添加一个键 * * @param kName 添加的键 * * @prarm type 类型 * * @prarm tableName 表名称 * * @prarm complete 结果回调 */-(void)addKey:(NSString *)kName keyType:(NSString *)type intoTable:(NSString *)tableName callBack:(void(^)(YHBaseSQLError *error))complete;/** * @brief 修改数据 * * @param dataDic 新的键值 * * @param wlStr 条件字符串 一般通过主键找到对应数据修改 可以为nil * * @param complete 结果回调 */-(void)update:(NSDictionary&lt;NSString*,id&gt; *)dataDic inTable:(NSString *)tableName whileString:(NSString *)wlStr callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 删除数据 * * @param tableName 表名 * * @param wlStr 条件字符串 一般通过主键找到对应数据删除 可以为nil 不传这个参数将删除所有数据 * */-(void)deleteDataFromTable:(NSString *)tableName whereString:(NSString *)wlStr callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 删除一张表 * * @param tableName 表名 * */-(void)dropTable:(NSString *)tableName callBack:(void(^)(YHBaseSQLError * error))complete;/** * @brief 查询数据 * * @param keys 要查询的键值 及其对应的数据类型 可以为nil则查询全部 * * @param tableName 表名 * * @param orderKey 进行排序的键值 可以为nil 则不排序 * * @param type 排序方式 在YHBaseSQLTypeHeader中有宏定义 * * @param wlstr 查询条件 同于查询单个数据 * * @param complete dataArray为查询到的数据 其内为字典 * */-(void)selectKeys:(NSArray&lt;NSDictionary *&gt; *)keys fromTable:(NSString*)tableName orderBy:(NSString *)orderKey orderType:(NSString *)type whileStr:(NSString *)wlstr callBack:(void(^)(NSArray&lt;NSDictionary *&gt; * dataArray,YHBaseSQLError * error))complete;/** * @brief 关闭数据库上下文操作 * 调用此方法后 这个context对象将不再有效 如果再需要使用 需要YHBaseSQLiteManager中的类方法再次返回 */-(void)closeContext; YHBaseSQLiteContext.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262-(BOOL)openDataBaeWithName:(NSString *)path&#123; if (sqlite3_open([path UTF8String], &amp;_sqlite3_db)!=SQLITE_OK) &#123; sqlite3_close(_sqlite3_db); _sqlite3_db=nil; return NO; &#125;else&#123; return YES; &#125;&#125;-(void)createTableWithName:(NSString *)name keysDictionary:(NSDictionary&lt;NSString *,NSString *&gt; *)dic callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * keys = [[NSMutableString alloc]init]; for (int i=0; i&lt;dic.allKeys.count; i++) &#123; NSString * key = dic.allKeys[i]; if (i&lt;dic.allKeys.count-1) &#123; [keys appendFormat:@&quot;%@ %@,&quot;,key,[dic objectForKey:key]]; &#125;else&#123; [keys appendFormat:@&quot;%@ %@&quot;,key,[dic objectForKey:key]]; &#125; &#125; NSString * sqlStr = [NSString stringWithFormat:@&quot;create table %@(%@)&quot;,name,keys]; [self runSQL:sqlStr callBack:^(YHBaseSQLError * error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)insertData:(NSDictionary&lt;NSString *,id&gt; *)dataDic intoTable:(NSString *)name callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * keys = [[NSMutableString alloc]init]; NSMutableString * values = [[NSMutableString alloc]init]; for (int i=0; i&lt;dataDic.allKeys.count; i++) &#123; NSString * key = dataDic.allKeys[i]; if (i&lt;dataDic.count-1) &#123; [keys appendFormat:@&quot;%@,&quot;,key]; [values appendFormat:@&quot;\\&quot;%@\\&quot;,&quot;,[dataDic objectForKey:key]]; &#125;else&#123; [keys appendFormat:@&quot;%@&quot;,key]; [values appendFormat:@&quot;\\&quot;%@\\&quot;&quot;,[dataDic objectForKey:key]]; &#125; &#125; NSString * sqlStr = [NSString stringWithFormat:@&quot;insert into %@(%@) values(%@)&quot;,name,keys,values]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)addKey:(NSString *)kName keyType:(NSString *)type intoTable:(NSString *)tableName callBack:(void (^)(YHBaseSQLError *))complete&#123; NSString * sqlStr = [NSString stringWithFormat:@&quot;alter table %@ add %@ %@&quot;,tableName,kName,type]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)update:(NSDictionary&lt;NSString *,id&gt; *)dataDic inTable:(NSString *)tableName whileString:(NSString *)wlStr callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;update %@ set &quot;,tableName]; for (int i=0; i&lt;dataDic.allKeys.count; i++) &#123; NSString * key = dataDic.allKeys[i]; if (i&lt;dataDic.allKeys.count-1) &#123; [sqlStr appendFormat:@&quot;%@=\\&quot;%@\\&quot;,&quot;,key,[dataDic objectForKey:key]]; &#125;else&#123; [sqlStr appendFormat:@&quot;%@=\\&quot;%@\\&quot;&quot;,key,[dataDic objectForKey:key]]; if (wlStr!=nil) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlStr]; &#125; &#125; &#125; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)deleteDataFromTable:(NSString *)tableName whereString:(NSString *)wlStr callBack:(void (^)(YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;delete from %@&quot;,tableName]; if (wlStr!=nil) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlStr]; &#125; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)dropTable:(NSString *)tableName callBack:(void (^)(YHBaseSQLError *))complete&#123; NSString * sqlStr = [NSString stringWithFormat:@&quot;drop table %@&quot;,tableName]; [self runSQL:sqlStr callBack:^(YHBaseSQLError *error) &#123; if (complete) &#123; complete(error); &#125; &#125;];&#125;-(void)selectKeys:(NSArray&lt;NSDictionary *&gt; *)keys fromTable:(NSString *)tableName orderBy:(NSString *)orderKey orderType:(NSString *)type whileStr:(NSString *)wlstr callBack:(void (^)(NSArray&lt;NSDictionary *&gt; *, YHBaseSQLError *))complete&#123; NSMutableString * sqlStr = [[NSMutableString alloc]init]; [sqlStr appendFormat:@&quot;select&quot;]; if (keys==nil||keys.count==0) &#123; [sqlStr appendFormat:@&quot; * from %@&quot;,tableName]; &#125;else&#123; for (int i=0; i&lt;keys.count; i++) &#123; if (i&lt;keys.count-1) &#123; [sqlStr appendFormat:@&quot; %@,&quot;,keys[i].allKeys.firstObject]; &#125;else&#123; [sqlStr appendFormat:@&quot; %@ from %@&quot;,keys[i].allKeys.firstObject,tableName]; &#125; &#125; &#125; if (wlstr) &#123; [sqlStr appendFormat:@&quot; where %@&quot;,wlstr]; &#125; if (orderKey) &#123; [sqlStr appendFormat:@&quot; order by %@&quot;,orderKey]; &#125; if (type) &#123; [sqlStr appendFormat:@&quot; %@&quot;,type]; &#125; NSMutableArray * keysArr = [[NSMutableArray alloc]init]; NSMutableArray * keysTypeArr = [[NSMutableArray alloc]init]; if (keys==nil||keys.count==0) &#123; NSArray&lt;NSDictionary *&gt; * tmpArr = [self getTheTableAllKeys:tableName]; for (int i=0; i&lt;tmpArr.count; i++) &#123; NSString * key = tmpArr[i].allKeys.firstObject; [keysArr addObject:key]; [keysTypeArr addObject:[tmpArr[i] objectForKey:key]]; &#125; &#125;else&#123; for (int i=0; i&lt;keys.count; i++) &#123; NSString * key = keys[i].allKeys.firstObject; [keysArr addObject:key]; [keysTypeArr addObject:[keys[i] objectForKey:key]]; &#125; &#125; [self runSelectSQL:sqlStr withKeys:keysArr withDataType:keysTypeArr callBack:^(NSArray&lt;NSDictionary *&gt; *dataArray, YHBaseSQLError *error) &#123; if (complete) &#123; complete(dataArray,error); &#125; &#125;]; &#125;-(void)closeContext&#123; sqlite3_close(_sqlite3_db); _sqlite3_db = nil;&#125;//内部方法 运行创建独立的非查询SQL语句-(void)runSQL:(NSString *)sql callBack:(void(^)(YHBaseSQLError * error))complete&#123; char * err; int code = sqlite3_exec(_sqlite3_db, [sql UTF8String], NULL, NULL, &amp;err); if (code!=SQLITE_OK) &#123; YHBaseSQLError * error = [[YHBaseSQLError alloc]init]; error.errorInfo = [NSString stringWithCString:err encoding:NSUTF8StringEncoding]; error.errorCode = code; complete(error); &#125;else&#123; complete(nil); &#125;&#125;//运行查询语句-(void)runSelectSQL:(NSString *)sql withKeys:(NSArray *)keys withDataType:(NSArray *)dataType callBack:(void(^)(NSArray&lt;NSDictionary *&gt; * dataArray, YHBaseSQLError * error))complete&#123; sqlite3_stmt *stmt =nil; int code = sqlite3_prepare_v2(_sqlite3_db, [sql UTF8String], -1, &amp;stmt, NULL); if (code!=SQLITE_OK) &#123; YHBaseSQLError * error = [[YHBaseSQLError alloc]init]; error.errorInfo = @&quot;查询失败&quot;; error.errorCode=code; complete(nil,error); &#125;else&#123; NSMutableArray * resultArray = [[NSMutableArray alloc]init]; while (sqlite3_step(stmt)==SQLITE_ROW) &#123; //数据类型的分别解析 NSMutableDictionary * dic = [[NSMutableDictionary alloc]init]; for (int i=0; i&lt;dataType.count; i++) &#123; NSString * type = dataType[i]; if ([type isEqualToString:YHBASE_SQL_DATATYPE_BINARY]) &#123; int length = sqlite3_column_bytes(stmt, i); const void *data = sqlite3_column_blob(stmt, i); NSData * value = [NSData dataWithBytes:data length:length]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_BLOB])&#123; int length = sqlite3_column_bytes(stmt, i); const void *data = sqlite3_column_blob(stmt, i); NSData * value = [NSData dataWithBytes:data length:length]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_BOOLEAN])&#123; NSNumber * value = [NSNumber numberWithInt:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_CURRENCY])&#123; NSNumber * value = [NSNumber numberWithLong:sqlite3_column_int64(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_DATE])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_DOUBLE])&#123; NSNumber * value = [NSNumber numberWithFloat:sqlite3_column_double(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_FLOAT])&#123; NSNumber * value = [NSNumber numberWithFloat:sqlite3_column_double(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_INTRGER])&#123; NSNumber * value = [NSNumber numberWithInt:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_REAL])&#123; NSNumber * value = [NSNumber numberWithDouble:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_SMALLINT])&#123; NSNumber * value = [NSNumber numberWithShort:sqlite3_column_int(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TEXT])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TIME])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_TIMESTAMP])&#123; NSNumber * value = [NSNumber numberWithLongLong:sqlite3_column_int64(stmt, i)]; [dic setObject:value forKey:keys[i]]; &#125;else if([type isEqualToString:YHBASE_SQL_DATATYPE_VARCHAR])&#123; char * cString =(char*)sqlite3_column_text(stmt, i); NSString * value = [NSString stringWithCString:cString?cString:&quot;NULL&quot; encoding:NSUTF8StringEncoding]; [dic setObject:value forKey:keys[i]]; &#125; &#125; [resultArray addObject:dic]; &#125; sqlite3_finalize(stmt); stmt=nil; complete(resultArray,nil); &#125;&#125;//获取表中所有字段名和类型-(NSArray&lt;NSDictionary *&gt; *)getTheTableAllKeys:(NSString *)tableName&#123; NSMutableArray * array = [[NSMutableArray alloc]init]; NSString * getColumn = [NSString stringWithFormat:@&quot;PRAGMA table_info(%@)&quot;,tableName]; sqlite3_stmt *statement; sqlite3_prepare_v2(_sqlite3_db, [getColumn UTF8String], -1, &amp;statement, nil); while (sqlite3_step(statement) == SQLITE_ROW) &#123; char *nameData = (char *)sqlite3_column_text(statement, 1); NSString *columnName = [[NSString alloc] initWithUTF8String:nameData]; char *typeData = (char *)sqlite3_column_text(statement, 2); NSString *columntype = [NSString stringWithCString:typeData encoding:NSUTF8StringEncoding]; NSDictionary * dic = @&#123;columnName:columntype&#125;; [array addObject:dic]; &#125; sqlite3_finalize(statement); statement=nil; return array;&#125; 5.错误信息类可以将数据库操作中的异常抛出提示开发者YHBaseSQLError.h 12345678/** *异常的提示信息 */__PROPERTY_NO_STRONG__(NSString *, errorInfo);/** *异常的对应code码 */__PROPERTY_NO_ASSIGN__(NSInteger, errorCode); 还有一个头文件中定义了sqlite数据库支持的数据类型和排序宏定义： YHBaseSQLTypeHeader.h 1234567891011121314151617#define YHBASE_SQL_DATATYPE_SMALLINT @&quot;smallint&quot; //short#define YHBASE_SQL_DATATYPE_INTRGER @&quot;integer&quot; //int#define YHBASE_SQL_DATATYPE_REAL @&quot;real&quot; //实数#define YHBASE_SQL_DATATYPE_FLOAT @&quot;float&quot; //float#define YHBASE_SQL_DATATYPE_DOUBLE @&quot;double&quot; //double#define YHBASE_SQL_DATATYPE_CURRENCY @&quot;currency&quot; //long#define YHBASE_SQL_DATATYPE_VARCHAR @&quot;varchar&quot; //char#define YHBASE_SQL_DATATYPE_TEXT @&quot;text&quot; //string#define YHBASE_SQL_DATATYPE_BINARY @&quot;binary&quot; //二进制#define YHBASE_SQL_DATATYPE_BLOB @&quot;blob&quot; //长二进制#define YHBASE_SQL_DATATYPE_BOOLEAN @&quot;boolean&quot; //bool#define YHBASE_SQL_DATATYPE_DATE @&quot;date&quot; //日期#define YHBASE_SQL_DATATYPE_TIME @&quot;time&quot; //时间#define YHBASE_SQL_DATATYPE_TIMESTAMP @&quot;timestamp&quot;//时间戳#define YHBASE_SQL_ORDERTYPE_ASC @&quot;asc&quot; //升序#define YHBASE_SQL_ORDERTYPE_DESC @&quot;desc&quot; //降序 四、使用在使用时，直接调用context的相应方法操作数据库即可，例如： 12345678YHBaseSQLiteContext * context = [YHBaseSQLiteManager openSQLiteWithName:@&quot;testDataBase&quot;]; if (context) &#123; [context selectKeys:nil fromTable:@&quot;MySQL&quot; orderBy:@&quot;age&quot; orderType:YHBASE_SQL_ORDERTYPE_DESC whileStr:@&quot;age&gt;18&quot; callBack:^(NSArray&lt;NSDictionary *&gt; *dataArray, YHBaseSQLError *error) &#123; NSLog(@&quot;%@&quot;,dataArray); NSLog(@&quot;%@&quot;,error.errorInfo); [context closeContext]; &#125;]; &#125; 上面的代码将查询textDataBase数据库中MySQL表里所有age列大于18的数据，并按照age从小到大进行排序，数据结果在回调的dataArray中。 外：完整的代码在下面的git地址中，这个git项目是一个基础的开发框架，里面封装了许多开发和调试常用功能，代码不完善之处，希望多多交流，QQ316045346. git：https://github.com/ZYHshao/YHBaseFoundationTest。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用","slug":"168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用","date":"2016-01-10T16:00:00.000Z","updated":"2021-07-06T06:45:24.955Z","comments":true,"path":"2016/01/11/168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用/","link":"","permalink":"http://huishao.cc/2016/01/11/168SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用/","excerpt":"","text":"SQLite数据库常用语句及MAC上的SQLite可视化工具MeasSQLlite使用一、引言在移动开发中，通常会用到一些小型的数据库进行数据管理。SQLite是一款十分小巧便捷的数据库，在iOS开发中，原生框架也对其有很好的支持。 二、SQLite常用语句数据库存在的意义就在于其对数据的整合和管理，所以数据库的核心操作无非是对数据进行增，删，改，查得操作。 1.建立数据表语句一个数据库文件中可以由一些表组成，通过下面的语句在数据库文件中创建一张表： 1create table class(num integer PRIMARY KEY,name text NOT NULL DEFAULT &quot;1班&quot;,count integer CHECK(count&gt;10)) 上面的语句代码可以简化成如下的格式： create table 表名(参数名1 类型 修饰条件，参数名2，类型 修饰参数，···) sqlite中支持如下的类型： smallint 短整型 integer 整型 real 实数型 float 单精度浮点 double 双精度浮点 currency 长整型 varchar 字符型 text 字符串 binary 二进制数据 blob 二进制大对象 boolean 布尔类型 date 日期类型 time 时间类型 timestamp 时间戳类型 关于修饰条件，常用的有如下几种： PRIMARY KEY：将本参数这个为主键，主键的值必须唯一，可以作为数据的索引，例如编号。 NOT NULL ：标记本参数为非空属性。 UNIQUE：标记本参数的键值唯一，类似主键。 DEFAULT:设置本参数的默认值 CHECK：参数检查条件，例如上面代码，写入数据是count必须大于时才有效。 2.添加数据使用下面的语句来进行数据行的添加操作： 1insert into class(num,name,count) values(2,&quot;三年2班&quot;,58) 上面的语句代码可以简化成如下格式： insert into 表名(键1，键2，···) values(值1，值2，···) 使用下面的语句进行数据列的添加，即添加一个新的键： 1alter table class add new text alter table 表名 add 键名 键类型 3.修改数据使用如下语句来进行改操作： 1update class set num=3,name=&quot;新的班级&quot; where num=1 update 表名 set 键1=值1，键2=值2 where 条件 where后面添加修改数据的条件，例如上面代码修改num为1的班级的名字和mun值。 4.删除数据1delete from class where num=1 delete from 表名 where 条件 上面代码删除num为1的一条数据。 删除一张表适用下面的语句： 1drop table class drop table 表名 5.查询操作查询操作是数据库的核心功能，sqlite的许多查询命令可以快捷的完成复杂的查询功能。 查询表中某些键值： 1select num from class select 键名，键名··· from 表名 查询全部键值数据： 1select * from class select * from 表名 *是一个全通配符，代表不限个数任意字符 查询排序： 1select * from class order by count asc select 键名，键名，··· from 表名 order by 键名 排序方式 order by 后面写要进行排序的键名，排序方式有 asc升序 desc降序 查找数据条数与查找位置限制： 1select * from class limit 2 offset 0 select 键名 from 表名 limit 最大条数 offset 查询起始位置 条件查询： 1select * from class where num&gt;2 select 键名 from 表名 where 条件 查询数据条数： 1select count(*) from class select count(键名) from 表名 去重查询： 1select distinct num from class select distinct 键名 from 表名 三、MesaSQLite的简单使用MesaSQLite是一款可视化的SQLite数据库编辑软件，使用十分方便。如下地址是下载链接：[http://pan.baidu.com/s/1sjW6DC5](http://pan.baidu.com/s/1sjW6DC5)。 1.创建数据库文件打开MesaSQLite软件，在导航栏中选择File，选择弹出菜单中的New DataBase创建一个新的数据库文件，也可以选择Open Database打开一个数据库。 注意：默认创建的数据库文件为rdb格式，手动改成db格式即可。 2.创建表MesaSQLite有两种方式对数据库进行操作，一种是通过sql语句，一种是通过可视化的界面。在SQL Query工具窗口中，可以通过SQL语句对数据库进行操作，如下图： 或者在Structure工具窗口中进行可视化的创建： 3.查询操作对于数据的查询操作，同样可以通过SQL Query工具通过语句进行查询或者在Content窗口中填写查询条件进行查询，如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展","slug":"167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展","date":"2015-12-22T16:00:00.000Z","updated":"2021-07-06T06:44:22.553Z","comments":true,"path":"2015/12/23/167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展/","link":"","permalink":"http://huishao.cc/2015/12/23/167iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展/","excerpt":"","text":"iOS开发封装一个可以响应超链接的label——基于RCLabel的交互扩展一、引言iOS系统是一个十分注重用户体验的系统，在iOS系统中，用户交互的方案也十分多，然而要在label中的某部分字体中添加交互行为确实不容易的，如果使用其他类似Button的控件来模拟，文字的排版又将是一个解决十分困难的问题。这个问题的由来是项目中的一个界面中有一些广告位标签，而这些广告位的标签却是嵌在文本中的，当用户点击文字标签的位置时，会跳转到响应的广告页。 CoreText框架和一些第三方库可以解决这个问题，但直接使用CoreText十分复杂，第三方库多注重于富文本的排版，对类似文字超链接的支持亦不是特别简洁，我们可以借助一些第三方的东西进行针对性更强，更易用的封装。 RCLabel是一个第三方的将html字符串进行文本布局的工具，代码十分轻巧，并且其是基于CoreText框架的，其原生性和扩展性十分强。在以前的一篇博客中，我将RCLabel进行了一些改进，使其支持异步加载远程图片，并且提供了更加简洁的面向应用的方法，博客地址如下： 扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计:http://my.oschina.net/u/2340880/blog/499311 。 本篇博文，将在其基础上，完成设计一个可以支持文本超链接的文字视图。 二、视图类与模型类的设计RCLabel的核心之处在于将HTML文本转换为富文本布局视图，因此我们可以将要显示的文本编程html字符串，将其可以进行用户交互的部分进行html超链接关联，RCLabel就检测到我们点击的区域进行响应逻辑的回调。设计类如下： .h文件 12345678910111213141516171819202122232425262728293031323334353637383940414243//文本与超链接地址关联的model类 后面会说@class YHBaseLinkingLabelModel;@protocol YHBaseLinkingLabelProtocol &lt;NSObject&gt;@optional/** *点击超链接后出发的代理方法 model中有链接地址和文字 */-(void)YHBaseLinkingLabelClickLinking:(YHBaseLinkingLabelModel *)model;/** *尺寸改变后出发的方法 */-(void)YHBaseLinkingLabelSizeChange:(CGSize)size;@end@interface YHBaseLinkingLabel : YHBaseView/** *文字数组 里面存放这文字对应的超链接对象 */@property(nonatomic,strong)NSArray&lt;YHBaseLinkingLabelModel *&gt; * textArray;@property(nonatomic,weak)id&lt;YHBaseLinkingLabelProtocol&gt;delegate;/** *设置文字颜色 */@property(nonatomic,strong)UIColor * textColor;/** *设置超链接文字颜色 */@property(nonatomic,strong)UIColor * linkColor;/** *设置字体大小 */@property(nonatomic,assign)NSUInteger fontSize;/** *设置超链接字体大小 */@property(nonatomic,assign)int linkingFontSize;/** *设置是否显示下划线 */@property(nonatomic,assign)BOOL isShowUnderLine;@end .m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124@interface YHBaseLinkingLabel()&lt;YHBaseHtmlViewProcotop&gt;@end@implementation YHBaseLinkingLabel&#123; //以前博客中 封装的显示HTML字符串富文本的视图 YHBaseHtmlView * _label;&#125;/*// 重载一些初始化方法- (instancetype)init&#123; self = [super init]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super initWithCoder:coder]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _label = [[YHBaseHtmlView alloc]init]; [self addSubview:_label]; [_label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.leading.equalTo(@0); make.trailing.equalTo(@0); make.top.equalTo(@0); make.bottom.equalTo(@0); &#125;]; _label.delegate=self; &#125; return self;&#125;//设置文本数组-(void)setTextArray:(NSArray&lt;YHBaseLinkingLabelModel *&gt; *)textArray&#123; _textArray = textArray; //进行html转换 NSString * htmlString = [self transLinkingDataToHtmlStr:textArray]; //进行布局 [_label reSetHtmlStr:htmlString]; &#125;-(void)setTextColor:(UIColor *)textColor&#123; _textColor = textColor; _label.fontColor = textColor;&#125;-(void)setLinkColor:(UIColor *)linkColor&#123; _linkColor = linkColor; _label.linkingColor = linkColor;&#125;-(void)setFontSize:(NSUInteger)fontSize&#123; _fontSize = fontSize; [_label setFontSize:(int)fontSize];&#125;-(void)setLinkingFontSize:(int)linkingFontSize&#123; _linkingFontSize = linkingFontSize; [_label setLinkingSize:linkingFontSize];&#125;-(void)setIsShowUnderLine:(BOOL)isShowUnderLine&#123; _isShowUnderLine = isShowUnderLine; [_label setShowUnderLine:isShowUnderLine];&#125;-(NSString *)transLinkingDataToHtmlStr:(NSArray&lt;YHBaseLinkingLabelModel *&gt; *)data&#123; NSMutableString * mutStr = [[NSMutableString alloc]init]; for (int i=0; i&lt;data.count; i++) &#123; //这个model中存放的是超链接部分的文字和对应的url YHBaseLinkingLabelModel * model = data[i]; if (!model.linking) &#123; [mutStr appendString:model.text]; &#125;else &#123; [mutStr appendString:@&quot;&lt;a href=&quot;]; [mutStr appendString:model.linking]; [mutStr appendString:@&quot;&gt;&quot;]; [mutStr appendString:model.text]; [mutStr appendString:@&quot;&lt;/a&gt;&quot;]; &#125; &#125; return mutStr;&#125;#pragma mark delegate//点击的回调-(void)YHBaseHtmlView:(YHBaseHtmlView *)htmlView ClickLink:(NSString *)url&#123; for (YHBaseLinkingLabelModel * model in _textArray) &#123; if ([model.linking isEqualToString:url]) &#123; if ([self.delegate respondsToSelector:@selector(YHBaseLinkingLabelClickLinking:)]) &#123; [self.delegate YHBaseLinkingLabelClickLinking:model]; return; &#125; &#125; &#125;&#125;//布局尺寸改变的回调-(void)YHBaseHtmlView:(YHBaseHtmlView *)htmlView SizeChanged:(CGSize)size&#123; if ([self.delegate respondsToSelector:@selector(YHBaseLinkingLabelSizeChange:)]) &#123; [self.delegate YHBaseLinkingLabelSizeChange:size]; &#125;&#125;@end 上面我们有用到一个YHBaseLinkingLabelModel类，这个类进行了链接与字符的映射，设计如下： 1234567891011@interface YHBaseLinkingLabelModel : YHBaseModel/** *文字内容 */@property(nonatomic,strong)NSString * text;/** *超链接地址 nil则为无 */@property(nonatomic,strong)NSString * linking;@end YHBaseHtmlView类是对RCLabel的一层封装，其中也对RCLabel进行了一些优化和改动，代码较多且在上篇博客中有介绍，这里不再多做解释了。 在ViewController中写如下代码进行使用： 12345678910111213141516171819202122232425262728- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. YHBaseLinkingLabel * label = [[YHBaseLinkingLabel alloc]initWithFrame:CGRectMake(100, 100, 200, 100)]; NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i=0; i&lt;6; i++) &#123; YHBaseLinkingLabelModel * model = [[YHBaseLinkingLabelModel alloc]init]; if (!(i%2)) &#123; model.text =[NSString stringWithFormat:@&quot;第%d个标签&quot;,i]; model.linking = [NSString stringWithFormat:@&quot;第%d个标签&quot;,i]; &#125;else&#123; model.text = @&quot;,不能点得文字,&quot;; &#125; [array addObject:model]; &#125; label.textColor = [UIColor blackColor]; label.linkColor = [UIColor purpleColor]; label.fontSize = 15; label.linkingFontSize = 17; label.isShowUnderLine=YES; label.delegate=self; label.textArray = array; [self.view addSubview:label]; &#125;-(void)YHBaseLinkingLabelClickLinking:(YHBaseLinkingLabelModel *)model&#123; NSLog(@&quot;%@&quot;,model.linking);&#125; 运行效果如下： 效果不错，并且十分简单易用，对吧。 我将这部分的相关代码集成进了以前写的一个项目开发框架中，git地址是：[https://github.com/ZYHshao/YHBaseFoundationTest](https://github.com/ZYHshao/YHBaseFoundationTest) 。总体看来，这个框架并不是干货，只是我开发中的一些积累，如果可以帮到你，择优而用，如果需要和我交流，QQ316045346，对视欢迎。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS开发之蓝牙通讯","slug":"166iOS开发之蓝牙通讯","date":"2015-12-19T16:00:00.000Z","updated":"2021-07-05T11:02:50.896Z","comments":true,"path":"2015/12/20/166iOS开发之蓝牙通讯/","link":"","permalink":"http://huishao.cc/2015/12/20/166iOS开发之蓝牙通讯/","excerpt":"","text":"iOS开发之蓝牙通讯一、引言蓝牙是设备近距离通信的一种方便手段，在iPhone引入蓝牙4.0后，设备之间的通讯变得更加简单。相关的蓝牙操作由专门的CoreBluetooth.framework进行统一管理。通过蓝牙进行通讯交互分为两方，一方为中心设备central，一方为外设peripheral，外设通过广播的方式向外发送信息，中心设备检索到外设发的广播信息，可以进行配对连接，进而进行数据交互。 二、中心设备CBCentralManagerCBCentralManager是管理中心设备的管理类，其中重要方法如下： 123456//设置中心设备代理@property(assign, nonatomic, nullable) id&lt;CBCentralManagerDelegate&gt; delegate;//中心设备当前状态@property(readonly) CBCentralManagerState state;//中心设备是否正在扫描@property(readonly) BOOL isScanning NS_AVAILABLE(NA, 9_0); 其中state是一个枚举，有关蓝牙是否可用的状态如下： 1234567891011121314typedef NS_ENUM(NSInteger, CBCentralManagerState) &#123; //状态未知 CBCentralManagerStateUnknown = 0, //连接断开 即将重置 CBCentralManagerStateResetting, //该平台不支持蓝牙 CBCentralManagerStateUnsupported, //未授权蓝牙使用 CBCentralManagerStateUnauthorized, //蓝牙关闭 CBCentralManagerStatePoweredOff, //蓝牙正常开启 CBCentralManagerStatePoweredOn,&#125;; 下面这些方法用于初始化管理中心： 1234567891011121314//初始化方法//设置的代理需要遵守CBCentralManagerDelegate协议//queue可以设置蓝牙扫描的线程 传入nil则为在主线程中进行- (instancetype)initWithDelegate:(nullable id&lt;CBCentralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue;//此方法同上 在options字典中用于进行一些管理中心的初始化属性设置//字典中支持的键值如下/*NSString * const CBCentralManagerOptionShowPowerAlertKey 对应一个NSNumber类型的bool值，用于设置是否在关闭蓝牙时弹出用户提示NSString * const CBCentralManagerOptionRestoreIdentifierKey 对应一个NSString对象，设置管理中心的标识符ID*/- (instancetype)initWithDelegate:(nullable id&lt;CBCentralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 1234//根据获取所有已知设备- (NSArray&lt;CBPeripheral *&gt; *)retrievePeripheralsWithIdentifiers:(NSArray&lt;NSUUID *&gt; *)identifiers;//根据服务id获取所有连接的设备- (NSArray&lt;CBPeripheral *&gt; *)retrieveConnectedPeripheralsWithServices:(NSArray&lt;CBUUID *&gt; *)serviceUUIDs; 在初始化管理中心完成后，会回调代理中的如下方法，我们必须实现如下方法： 12//这个方法中可以获取到管理中心的状态- (void)centralManagerDidUpdateState:(CBCentralManager *)central; 如果上面方法中管理中心状态为蓝牙可用，可以通过下面方法开启扫描外设： 12345678//serviceUUIDs用于扫描一个特点ID的外设 options用于设置一些扫描属性 键值如下/*//是否允许重复扫描 对应NSNumber的bool值，默认为NO，会自动去重NSString *const CBCentralManagerScanOptionAllowDuplicatesKey;//要扫描的设备UUID 数组 对应NSArrayNSString *const CBCentralManagerScanOptionSolicitedServiceUUIDsKey;*/- (void)scanForPeripheralsWithServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs options:(nullable NSDictionary&lt;NSString *, id&gt; *)options; 12//停止扫描外设- (void)stopScan; 扫描的结果会在如下代理方法中回掉： 1234//peripheral 扫描到的外设//advertisementData是外设发送的广播数据//RSSI 是信号强度- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI; 扫描到外设后，通过下面方法可以连接一个外设： 123456789101112/*options中可以设置一些连接设备的初始属性键值如下//对应NSNumber的bool值，设置当外设连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnConnectionKey;//对应NSNumber的bool值，设置当外设断开连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnDisconnectionKey;//对应NSNumber的bool值，设置当外设暂停连接后是否弹出一个警告NSString *const CBConnectPeripheralOptionNotifyOnNotificationKey;*/- (void)connectPeripheral:(CBPeripheral *)peripheral options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;//取消一个外设的连接- (void)cancelPeripheralConnection:(CBPeripheral *)peripheral; 调用过连接外设的方法后，会回掉如下代理方法： 123456//连接外设成功- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral;//连接外设失败- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error;//断开外设连接- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error; 当管理中心恢复时会调用如下代理： 12345678910//dict中会传入如下键值对/*//恢复连接的外设数组NSString *const CBCentralManagerRestoredStatePeripheralsKey;//恢复连接的服务UUID数组NSString *const CBCentralManagerRestoredStateScanServicesKey;//恢复连接的外设扫描属性字典数组NSString *const CBCentralManagerRestoredStateScanOptionsKey;*/- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict; 三、外设CBPeripheralManager从上面我们知道，中心设备是用来扫描周围的外设，两台设备的通讯中，必须有一个充当中心设备，一个充当外设，外设是由CBPeripheralManager进行管理，主要方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//设置外设管理中心代理@property(assign, nonatomic, nullable) id&lt;CBPeripheralManagerDelegate&gt; delegate;//外设状态 枚举如中心设备@property(readonly) CBPeripheralManagerState state;//是否正在发送广播@property(readonly) BOOL isAdvertising;//用户的授权状态+ (CBPeripheralManagerAuthorizationStatus)authorizationStatus;//初始化并设置代理 参数的具体含义与中心设备管理中心- (instancetype)initWithDelegate:(nullable id&lt;CBPeripheralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t);- (instancetype)initWithDelegate:(nullable id&lt;CBPeripheralManagerDelegate&gt;)delegate queue:(nullable dispatch_queue_t)queue options:(nullable NSDictionary&lt;NSString *, id&gt; *)options;//开始发送广播//advertisementData中可以发送的数据有约定 如下/*对应设置NSString类型的广播名NSString *const CBAdvertisementDataLocalNameKey;外设制造商的NSData数据NSString *const CBAdvertisementDataManufacturerDataKey;外设制造商的CBUUID数据NSString *const CBAdvertisementDataServiceDataKey;服务的UUID与其对应的服务数据字典数组NSString *const CBAdvertisementDataServiceUUIDsKey;附加服务的UUID数组NSString *const CBAdvertisementDataOverflowServiceUUIDsKey;外设的发送功率 NSNumber类型NSString *const CBAdvertisementDataTxPowerLevelKey;外设是否可以连接NSString *const CBAdvertisementDataIsConnectable;服务的UUID数组NSString *const CBAdvertisementDataSolicitedServiceUUIDsKey;*/- (void)startAdvertising:(nullable NSDictionary&lt;NSString *, id&gt; *)advertisementData;//停止发送广播- (void)stopAdvertising;//设置一个连接的具体central设备的延时 枚举如下/*typedef NS_ENUM(NSInteger, CBPeripheralManagerConnectionLatency) &#123; CBPeripheralManagerConnectionLatencyLow = 0, CBPeripheralManagerConnectionLatencyMedium, CBPeripheralManagerConnectionLatencyHigh&#125; NS_ENUM_AVAILABLE(NA, 6_0);*/- (void)setDesiredConnectionLatency:(CBPeripheralManagerConnectionLatency)latency forCentral:(CBCentral *)central;//添加一个服务- (void)addService:(CBMutableService *)service;//移除一个服务- (void)removeService:(CBMutableService *)service;//移除所有服务- (void)removeAllServices;//响应中心设备的读写请求- (void)respondToRequest:(CBATTRequest *)request withResult:(CBATTError)result;//更新一个连接中心设备的订阅特征值- (BOOL)updateValue:(NSData *)value forCharacteristic:(CBMutableCharacteristic *)characteristic onSubscribedCentrals:(nullable NSArray&lt;CBCentral *&gt; *)centrals; 外设代理的相关方法如下： 123456789101112131415161718//这个方法是必须实现的 状态可用后可以发送广播- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral;//连接回复时调用的方法 和centralManager类似- (void)peripheralManager:(CBPeripheralManager *)peripheral willRestoreState:(NSDictionary&lt;NSString *, id&gt; *)dict;//开始发送广播时调用的方法- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(nullable NSError *)error;//添加服务调用的回调- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(nullable NSError *)error;//当一个central设备订阅一个特征值时调用的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic;//取消订阅一个特征值时调用的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic;//收到读请求时触发的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request;//收到写请求时触发的方法- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests;//外设准备更新特征值时调用的方法- (void)peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)peripheral; 四、中心设备与外设对象CBCentral与CBPeripheral上面介绍了中心设备管理类与外设管理类，这些类用于将设备连接建立起来，器具的数据交换的服务和一些信息则是在对应的设备对象中。 1、中心设备 CBCentral属性与方法1234//设备UUID@property(readonly, nonatomic) NSUUID *identifier;//中心设备最大接收的数据长度@property(readonly, nonatomic) NSUInteger maximumUpdateValueLength; 2、外设CAPeripheral属性与方法外设对象要比中心对象复杂的多，当centralManager连接到外设后，需要通过外设对象的代理方法进行数据交互，其中主要方法属性如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//设置代理@property(assign, nonatomic, nullable) id&lt;CBPeripheralDelegate&gt; delegate;//外设name@property(retain, readonly, nullable) NSString *name;//信号强度@property(retain, readonly, nullable) NSNumber *RSSI NS_DEPRECATED(NA, NA, 5_0, 8_0);//外设状态/*typedef NS_ENUM(NSInteger, CBPeripheralState) &#123; CBPeripheralStateDisconnected = 0,//未连接 CBPeripheralStateConnecting,//正在链接 CBPeripheralStateConnected,//已经连接 CBPeripheralStateDisconnecting NS_AVAILABLE(NA, 9_0),//正在断开连接&#125; NS_AVAILABLE(NA, 7_0);*/@property(readonly) CBPeripheralState state;//所有的服务数组@property(retain, readonly, nullable) NSArray&lt;CBService *&gt; *services;//获取当前信号强度- (void)readRSSI;//根据服务UUID寻找服务对象- (void)discoverServices:(nullable NSArray&lt;CBUUID *&gt; *)serviceUUIDs;//在服务对象UUID数组中寻找特定服务- (void)discoverIncludedServices:(nullable NSArray&lt;CBUUID *&gt; *)includedServiceUUIDs forService:(CBService *)service;//在一个服务中寻找特征值- (void)discoverCharacteristics:(nullable NSArray&lt;CBUUID *&gt; *)characteristicUUIDs forService:(CBService *)service;//从一个特征中读取数据- (void)readValueForCharacteristic:(CBCharacteristic *)characteristic;//写数据的最大长度//type枚举如下/*typedef NS_ENUM(NSInteger, CBCharacteristicWriteType) &#123; CBCharacteristicWriteWithResponse = 0,//写数据并且接收成功与否回执 CBCharacteristicWriteWithoutResponse,//写数据不接收回执&#125;;*/- (NSUInteger)maximumWriteValueLengthForType:(CBCharacteristicWriteType)type NS_AVAILABLE(NA, 9_0);//向某个特征中写数据- (void)writeValue:(NSData *)data forCharacteristic:(CBCharacteristic *)characteristic type:(CBCharacteristicWriteType)type;//为制定的特征值设置监听通知- (void)setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic;//寻找特征值的描述- (void)discoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic;//读取特征的描述值- (void)readValueForDescriptor:(CBDescriptor *)descriptor;//写特征的描述值- (void)writeValue:(NSData *)data forDescriptor:(CBDescriptor *)descriptor; 外设的代理方法如下： 1234567891011121314151617181920212223242526//外设名称更改时回调的方法- (void)peripheralDidUpdateName:(CBPeripheral *)peripheral NS_AVAILABLE(NA, 6_0);//外设服务变化时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didModifyServices:(NSArray&lt;CBService *&gt; *)invalidatedServices NS_AVAILABLE(NA, 7_0);//信号强度改变时调用的方法- (void)peripheralDidUpdateRSSI:(CBPeripheral *)peripheral error:(nullable NSError *)error NS_DEPRECATED(NA, NA, 5_0, 8_0);//读取信号强度回调的方法- (void)peripheral:(CBPeripheral *)peripheral didReadRSSI:(NSNumber *)RSSI error:(nullable NSError *)error NS_AVAILABLE(NA, 8_0);//发现服务时调用的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error;//在服务中发现子服务回调的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverIncludedServicesForService:(CBService *)service error:(nullable NSError *)error;//发现服务的特征值后回调的方法- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error;//特征值更新时回调的方法- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error;//向特征值写数据时回调的方法 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //特征值的通知设置改变时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //发现特征值的描述信息触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error; //特征的描述值更新时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error; //写描述信息时触发的方法 - (void)peripheral:(CBPeripheral *)peripheral didWriteValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error; 五、服务对象CBService服务对象是用来管理外设提供的一些数据服务的，其中属性如下： 12345678//对应的外设@property(assign, readonly, nonatomic) CBPeripheral *peripheral;//是否是初等服务@property(readonly, nonatomic) BOOL isPrimary;//包含的自服务@property(retain, readonly, nullable) NSArray&lt;CBService *&gt; *includedServices;//服务中的特征值@property(retain, readonly, nullable) NSArray&lt;CBCharacteristic *&gt; *characteristics; 六、服务的特征值CBCharacteristic通过绑定服务中的特征值来进行数据的读写操作，其中属性如下： 1234567891011121314151617181920212223242526//对应的服务对象@property(assign, readonly, nonatomic) CBService *service;//特征值的属性 枚举如下/*typedef NS_OPTIONS(NSUInteger, CBCharacteristicProperties) &#123; CBCharacteristicPropertyBroadcast,//允许广播特征 CBCharacteristicPropertyRead,//可读属性 CBCharacteristicPropertyWriteWithoutResponse,//可写并且接收回执 CBCharacteristicPropertyWrite,//可写属性 CBCharacteristicPropertyNotify,//可通知属性 CBCharacteristicPropertyIndicate,//可展现的特征值 CBCharacteristicPropertyAuthenticatedSignedWrites,//允许签名的特征值写入 CBCharacteristicPropertyExtendedProperties, CBCharacteristicPropertyNotifyEncryptionRequired, CBCharacteristicPropertyIndicateEncryptionRequired&#125;;*/@property(readonly, nonatomic) CBCharacteristicProperties properties;//特征值的数据@property(retain, readonly, nullable) NSData *value;//特征值的描述@property(retain, readonly, nullable) NSArray&lt;CBDescriptor *&gt; *descriptors;//是否是当前广播的特征@property(readonly) BOOL isBroadcasted;//是否是正在通知的特征@property(readonly) BOOL isNotifying; 七、读写请求对象CBATTRequest服务对象是外设向中心设备提供的相关数据服务，获取到相应服务后，中心设备可以进行读写请求，读写对象属性如下： 123456//对应的中心设备@property(readonly, nonatomic) CBCentral *central;//对应的特征值@property(readonly, nonatomic) CBCharacteristic *characteristic;//读写数据值@property(readwrite, copy, nullable) NSData *value; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS获取和监测设备基本信息——UIDevice的使用","slug":"165iOS获取和监测设备基本信息——UIDevice的使用","date":"2015-12-17T16:00:00.000Z","updated":"2021-07-05T08:15:04.425Z","comments":true,"path":"2015/12/18/165iOS获取和监测设备基本信息——UIDevice的使用/","link":"","permalink":"http://huishao.cc/2015/12/18/165iOS获取和监测设备基本信息——UIDevice的使用/","excerpt":"","text":"iOS获取和监测设备基本信息——UIDevice的使用12345678910111213141516171819202122//获取当前设备单例+ (UIDevice *)currentDevice;//获取当前设备名称 @property(nonatomic,readonly,strong) NSString *name; // e.g. &quot;My iPhone&quot;//获取当前设备模式@property(nonatomic,readonly,strong) NSString *model; // e.g. @&quot;iPhone&quot;, @&quot;iPod touch&quot;//获取本地化的当前设备模式@property(nonatomic,readonly,strong) NSString *localizedModel; // localized version of model//获取系统名称@property(nonatomic,readonly,strong) NSString *systemName; // e.g. @&quot;iOS&quot;//获取系统版本@property(nonatomic,readonly,strong) NSString *systemVersion; // e.g. @&quot;4.0&quot;//获取设备方向@property(nonatomic,readonly) UIDeviceOrientation orientation; //获取设备UUID对象@property(nullable, nonatomic,readonly,strong) NSUUID *identifierForVendor;//是否开启监测电池状态 开启后 才可以正常获取电池状态@property(nonatomic,getter=isBatteryMonitoringEnabled) BOOL batteryMonitoringEnabled NS_AVAILABLE_IOS(3_0); // default is NO//获取电池状态@property(nonatomic,readonly) UIDeviceBatteryState batteryState NS_AVAILABLE_IOS(3_0); //获取电量@property(nonatomic,readonly) float batteryLevel NS_AVAILABLE_IOS(3_0); 设备方向的枚举如下： 123456789typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123; UIDeviceOrientationUnknown, UIDeviceOrientationPortrait, // home键在下 UIDeviceOrientationPortraitUpsideDown, // home键在上 UIDeviceOrientationLandscapeLeft, // home键在右 UIDeviceOrientationLandscapeRight, // home键在左 UIDeviceOrientationFaceUp, // 屏幕朝上 UIDeviceOrientationFaceDown // 屏幕朝下&#125;; 电池状态的枚举如下： 123456typedef NS_ENUM(NSInteger, UIDeviceBatteryState) &#123; UIDeviceBatteryStateUnknown, UIDeviceBatteryStateUnplugged, // 放电状态 UIDeviceBatteryStateCharging, // 充电未充满状态 UIDeviceBatteryStateFull, // 充电已充满&#125;; 下面的方法关于监测屏幕状态： 123456//获取是否开启屏幕状态更改通知@property(nonatomic,readonly,getter=isGeneratingDeviceOrientationNotifications) BOOL generatesDeviceOrientationNotifications;//开始监测通知- (void)beginGeneratingDeviceOrientationNotifications; //结束监测通知- (void)endGeneratingDeviceOrientationNotifications; 下面这两个放大与距离传感器应用相关，可参考：http://my.oschina.net/u/2340880/blog/544341. 123@property(nonatomic,getter=isProximityMonitoringEnabled) BOOL proximityMonitoringEnabled NS_AVAILABLE_IOS(3_0); //开启距离传感器//是否触发了距离传感器@property(nonatomic,readonly) BOOL proximityState 相关通知： 12345678//设备方向改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceOrientationDidChangeNotification;//电池状态改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceBatteryStateDidChangeNotification NS_AVAILABLE_IOS(3_0);//电量改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceBatteryLevelDidChangeNotification NS_AVAILABLE_IOS(3_0);//距离传感器状态改变时发送的通知UIKIT_EXTERN NSString *const UIDeviceProximityStateDidChangeNotification NS_AVAILABLE_IOS(3_0); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——距离传感器的应用","slug":"164iOS传感器开发——距离传感器的应用","date":"2015-12-13T16:00:00.000Z","updated":"2021-07-05T08:14:17.222Z","comments":true,"path":"2015/12/14/164iOS传感器开发——距离传感器的应用/","link":"","permalink":"http://huishao.cc/2015/12/14/164iOS传感器开发——距离传感器的应用/","excerpt":"","text":"iOS传感器开发——距离传感器的应用iPhone手机中内置了距离传感器，位置在手机的听筒附近，当我们在打电话的时候靠近听筒，手机的屏幕会自动熄灭，这就靠距离传感器来控制。 在我们开发app时，如果需要，也可以调用距离传感器的一些接口方法。距离传感器的接口十分简单，主要通过通知中心来对距离的改变进行通知。 首先，我们需要开启距离传感器应用： 1[UIDevice currentDevice].proximityMonitoringEnabled=YES; 监听距离改变的通知： 1[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(notice) name:UIDeviceProximityStateDidChangeNotification object:nil]; 在回调方法中，我们可以通过下面这个属性来监听距离状态： 1234567-(void)notice&#123; if ([UIDevice currentDevice].proximityState) &#123; NSLog(@&quot;近距离&quot;); &#125;else&#123; NSLog(@&quot;远距离&quot;); &#125;&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用","slug":"163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用","date":"2015-12-12T16:00:00.000Z","updated":"2021-07-05T08:13:22.467Z","comments":true,"path":"2015/12/13/163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用/","link":"","permalink":"http://huishao.cc/2015/12/13/163iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用/","excerpt":"","text":"iOS传感器开发——加速度传感器，螺旋仪传感器，磁力传感器的应用一、引言通过加速度传感器，螺旋仪传感器和磁力传感，我们可以获取到手机在当前三维空间中的形态，加速度传感器也被称作重力感应。在一些赛车游戏中可以广泛得到应用。在iOS5之前，iPhone支持的传感器有限，关于加速度传感器的管理用UIAccelerometer这个类负责，iOS5之后，有关设备空间信息的管理交由了CoreMotion这个框架，CoreMotion将多种传感器统一进行管理计算。 二、使用UIAccelerometer获取设备空间位置虽然在iOS5之后这个类被弃用了，但是和其他大多被弃用的方法类似，在新的iOS版本中，是兼容旧方法的，我们依然可以使用这个类来获取简单的设备空间信息。 我们主要使用到的类和代理方法如下： 1234567891011//设备信息对象类@interface UIAcceleration : NSObject//加速度传感器的时间戳@property(nonatomic,readonly) NSTimeInterval timestamp;//x方向值@property(nonatomic,readonly) UIAccelerationValue x;//y方向值@property(nonatomic,readonly) UIAccelerationValue y;//z方向值@property(nonatomic,readonly) UIAccelerationValue z;@end 上面的UIAccelerationValue就是double类型。 加速度传感器获取的属性是设备在三维空间的角度属性，借用下面这张图： 如果将设备这样立在桌面上，设备的三维坐标器如图，我们将设备已Z轴移动的时候，向右x为正，向左为负，其他两轴类似。 123456789//加速度管理类@interface UIAccelerometer : NSObject //获取单例对象+ (UIAccelerometer *)sharedAccelerometer;//刷新频率@property(nonatomic) NSTimeInterval updateInterval;//代理@property(nullable,nonatomic,weak) id&lt;UIAccelerometerDelegate&gt; delegate;@end UIAccelerometer是管理类，通过单例方法获取到实例对象。 123456@protocol UIAccelerometerDelegate&lt;NSObject&gt;@optional- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration NS_DEPRECATED_IOS(2_0, 5_0) __TVOS_PROHIBITED;@end 这个代理方法是刷新信息的回调，会以我们设置的帧率刷新。 举例代码如下： 123456789101112131415161718@interface ViewController ()&lt;UIAccelerometerDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [UIAccelerometer sharedAccelerometer].delegate=self; [UIAccelerometer sharedAccelerometer].updateInterval=1/60.0;&#125;-(void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration&#123; NSLog(@&quot;\\n%f\\n%f\\n%f&quot;,acceleration.x,acceleration.y,acceleration.z); // NSLog(@&quot;%f&quot;,acceleration.timestamp);&#125;@end 三、CoreMotion框架的使用CoreMotion框架十分强大，它不仅将加速度传感器和螺旋仪传感器进行了统一配置和管理，还为我们封装了许多算法，我们可以直接获取到设备的运动状态信息。 1、CoreMotion负责处理的数据CoreMotion负责处理四种数据，一种是加速度数据，一种是螺旋仪数据，一种是磁感应数据，还有一种是前三种数据通过复杂运算得到的设备的运动数据。几个主要的类如下： CMAccelerommterData:设备的加速度数据 1234567891011121314typedef struct &#123; double x; double y; double z;&#125; CMAcceleration;@interface CMAccelerometerData : CMLogItem&#123;@private id _internal;&#125;//加速度的数据对象@property(readonly, nonatomic) CMAcceleration acceleration;@end CMGyroData:设备的螺旋仪数据 1234567891011121314typedef struct &#123; double x; double y; double z; &#125; CMRotationRate;@interface CMGyroData : CMLogItem&#123;@private id _internal;&#125;//螺旋仪数据对象@property(readonly, nonatomic) CMRotationRate rotationRate;@end CMMagnetometerData：磁感应信息 12345678910111213141516typedef struct &#123; double x; double y; double z;&#125; CMMagneticField;@interface CMMagnetometerData : CMLogItem&#123;@private id _internal;&#125;//磁力对象@property(readonly, nonatomic) CMMagneticField magneticField;@end CMDeviceMotion:设备的运动状态数据 123456789101112131415@interface CMDeviceMotion : CMLogItem&#123;@private id _internal;&#125;//设备的状态对象@property(readonly, nonatomic) CMAttitude *attitude;//设备的角速度@property(readonly, nonatomic) CMRotationRate rotationRate;//设备的重力加速度@property(readonly, nonatomic) CMAcceleration gravity;//用户嫁给设备的加速度 设备的总加速度为重力加速度叫上用户给的加速度@property(readonly, nonatomic) CMAcceleration userAcceleration;//设备的磁场矢量对象@property(readonly, nonatomic) CMCalibratedMagneticField magneticField NS_AVAILABLE(NA,5_0); 相比之前两个类，这个就比较复杂了，attitude对象中又封装了许多设备的状态属性： 12345678910111213141516@interface CMAttitude : NSObject &lt;NSCopying, NSSecureCoding&gt;&#123;@private id _internal;&#125;//设备的欧拉角roll@property(readonly, nonatomic) double roll;//设备的欧拉角pitch@property(readonly, nonatomic) double pitch;//设备的欧拉角yaw@property(readonly, nonatomic) double yaw;//设备状态的旋转矩阵@property(readonly, nonatomic) CMRotationMatrix rotationMatrix;//设备状态的四元数@property(readonly, nonatomic) CMQuaternion quaternion;@end 2、CoreMotion的使用CoreMotion有两种使用方式，一种是我们主动向manager索取数据，一种是通过回调让manager将数据传给回调给我们，这两种方式分别称作pull方式和push方式。 pull方式： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建管理对象 manager= [[CMMotionManager alloc]init]; //开启加速度更新 [manager startAccelerometerUpdates]; //开启螺旋仪更新 [manager startGyroUpdates]; //开启状态更新 [manager startMagnetometerUpdates]; //创建定时器 NSTimer * time = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(updata) userInfo:nil repeats:YES]; time.fireDate = [NSDate distantPast];&#125;-(void)updata&#123;//获取数据 NSLog(@&quot;%f,%f,%f\\n%f,%f,%f&quot;,manager.accelerometerData.acceleration.x,manager.accelerometerData.acceleration.y,manager.accelerometerData.acceleration.z,manager.gyroData.rotationRate.x,manager.gyroData.rotationRate.y,manager.gyroData.rotationRate.z); &#125; push方式： 123456 //创建管理对象 manager= [[CMMotionManager alloc]init]; //在当前线程中回调 [manager startAccelerometerUpdatesToQueue:[NSOperationQueue currentQueue] withHandler:^(CMAccelerometerData * _Nullable accelerometerData, NSError * _Nullable error) &#123; NSLog(@&quot;%f,%f,%f\\n%f,%f,%f&quot;,manager.accelerometerData.acceleration.x,manager.accelerometerData.acceleration.y,manager.accelerometerData.acceleration.z,manager.gyroData.rotationRate.x,manager.gyroData.rotationRate.y,manager.gyroData.rotationRate.z); &#125;]; 3、CoreMotion的更多属性和方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@interface CMMotionManager : NSObject&#123;@private id _internal;&#125;//设置加速度传感器更新帧率@property(assign, nonatomic) NSTimeInterval accelerometerUpdateInterval __TVOS_PROHIBITED;//加速度传感器是否可用@property(readonly, nonatomic, getter=isAccelerometerAvailable) BOOL accelerometerAvailable __TVOS_PROHIBITED;//加速度传感器是否激活@property(readonly, nonatomic, getter=isAccelerometerActive) BOOL accelerometerActive __TVOS_PROHIBITED;//加速度传感器数据对象@property(readonly, nullable) CMAccelerometerData *accelerometerData __TVOS_PROHIBITED;//pull方式开始更新加速度数据- (void)startAccelerometerUpdates __TVOS_PROHIBITED;//push方式更新加速度数据- (void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler __TVOS_PROHIBITED;//停止更新加速度数据- (void)stopAccelerometerUpdates __TVOS_PROHIBITED;//螺旋仪传感器刷新帧率@property(assign, nonatomic) NSTimeInterval gyroUpdateInterval __TVOS_PROHIBITED;//螺旋仪是否可用@property(readonly, nonatomic, getter=isGyroAvailable) BOOL gyroAvailable __TVOS_PROHIBITED;//螺旋仪是否激活@property(readonly, nonatomic, getter=isGyroActive) BOOL gyroActive __TVOS_PROHIBITED;//螺旋仪数据@property(readonly, nullable) CMGyroData *gyroData __TVOS_PROHIBITED;//pull方式开始更新螺旋仪- (void)startGyroUpdates __TVOS_PROHIBITED;//push方式开始更新螺旋仪- (void)startGyroUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMGyroHandler)handler __TVOS_PROHIBITED;//停止更新螺旋仪- (void)stopGyroUpdates __TVOS_PROHIBITED;//磁力传感更新帧率@property(assign, nonatomic) NSTimeInterval magnetometerUpdateInterval NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力传感器是否可用@property(readonly, nonatomic, getter=isMagnetometerAvailable) BOOL magnetometerAvailable NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力传感器是否激活@property(readonly, nonatomic, getter=isMagnetometerActive) BOOL magnetometerActive NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备磁力状态数据@property(readonly, nullable) CMMagnetometerData *magnetometerData NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//pull方式更新设备磁力状态- (void)startMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//push方式更新设备磁力状态- (void)startMagnetometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMMagnetometerHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//停止更新设备状态- (void)stopMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备状态更新帧率@property(assign, nonatomic) NSTimeInterval deviceMotionUpdateInterval __TVOS_PROHIBITED;//参考器枚举+ (CMAttitudeReferenceFrame)availableAttitudeReferenceFrames NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;@property(readonly, nonatomic) CMAttitudeReferenceFrame attitudeReferenceFrame NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//设备运动信息是否可用@property(readonly, nonatomic, getter=isDeviceMotionAvailable) BOOL deviceMotionAvailable __TVOS_PROHIBITED;//设备运动信息是否激活@property(readonly, nonatomic, getter=isDeviceMotionActive) BOOL deviceMotionActive __TVOS_PROHIBITED;//设备运动信息对象@property(readonly, nullable) CMDeviceMotion *deviceMotion __TVOS_PROHIBITED;//pull方式开始刷新运动信息- (void)startDeviceMotionUpdates __TVOS_PROHIBITED;//push方式开始刷新运动信息- (void)startDeviceMotionUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler __TVOS_PROHIBITED;//使用某个参考系- (void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//push方式开始刷新设备运动信息- (void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame toQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;//停止刷新设备运动信息- (void)stopDeviceMotionUpdates __TVOS_PROHIBITED; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS传感器开发——为APP添加手机密码、指纹进行安全验证","slug":"162iOS传感器开发——为APP添加手机密码、指纹进行安全验证","date":"2015-12-09T16:00:00.000Z","updated":"2021-07-05T08:12:25.574Z","comments":true,"path":"2015/12/10/162iOS传感器开发——为APP添加手机密码、指纹进行安全验证/","link":"","permalink":"http://huishao.cc/2015/12/10/162iOS传感器开发——为APP添加手机密码、指纹进行安全验证/","excerpt":"","text":"iOS传感器开发——为APP添加手机密码、指纹进行安全验证一、引言iPhone5s之后，iPhone硬件上已支持进行指纹识别的功能，相应的，一些新的api也可以应用于APP中，进行用户安全的验证。目前，开发者可以使用的安全验证方式有两种，一种是通过手机密码进行验证，一种是通过识别指纹进行验证。 二、为APP添加安全验证要使用安全验证的相关api，我们需要引入如下头文件： 1#import &lt;LocalAuthentication/LocalAuthentication.h&gt; 添加手机密码验证： 123456789101112131415 //创建安全验证对象 LAContext * con = [[LAContext alloc]init]; NSError * error; //判断是否支持密码验证 /** *LAPolicyDeviceOwnerAuthentication 手机密码的验证方式 *LAPolicyDeviceOwnerAuthenticationWithBiometrics 指纹的验证方式 */ BOOL can = [con canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:&amp;error]; if (can) &#123; [con evaluatePolicy:LAPolicyDeviceOwnerAuthentication localizedReason:@&quot;验证信息&quot; reply:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@&quot;%d,%@&quot;,success,error); &#125;]; &#125; canEvaluatePolicy是用来判断是否支持手机密码验证的，如果没有设置手机密码，会返回NO，如果启用了，会出现如下界面： 密码验证的提示信息，我们可以自定义设置。 进行指纹验证： 12345678910LAContext * con = [[LAContext alloc]init]; NSError * error; BOOL can = [con canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]; NSLog(@&quot;%d&quot;,can); if (can) &#123; [con evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@&quot;验证指纹&quot; reply:^(BOOL success, NSError * _Nullable error) &#123; NSLog(@&quot;%d,%@&quot;,success,error); &#125;]; &#125; 回调中的success用来判断是否验证成功： 通过这些验证方式，可以使用户的数据更加安全，在做敏感操作时，可以确保是手机的持有者。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之五——高级动画技巧","slug":"160iOS开发CoreAnimation解读之五——高级动画技巧","date":"2015-12-05T16:00:00.000Z","updated":"2021-07-05T08:10:41.632Z","comments":true,"path":"2015/12/06/160iOS开发CoreAnimation解读之五——高级动画技巧/","link":"","permalink":"http://huishao.cc/2015/12/06/160iOS开发CoreAnimation解读之五——高级动画技巧/","excerpt":"","text":"iOS开发CoreAnimation解读之五——高级动画技巧一、事务类CoreAnimation中还有一个非常重要的类：CATransaction事物类，这个可以同时设置多个layer层的动画效果。可以通过隐式和显式两种方式来进行动画操作。 二、CATransaction属性对layer层的属性操作，都会形成隐式动画，要使用隐式动画，需要关闭layer层的animation动画属性，使用下面的方法： 123//关闭animation动画效果，开启隐式动画+ (BOOL)disableActions;+ (void)setDisableActions:(BOOL)flag; CATransaction用类方式通过设置key-value来进行动画的属性设置： 12+ (nullable id)valueForKey:(NSString *)key;+ (void)setValue:(nullable id)anObject forKey:(NSString *)key; 支持的key值如下： 12345678//设置动画持续时间 NSString * const kCATransactionAnimationDuration; //设置停用animation类动画 NSString * const kCATransactionDisableActions; //设置动画时序效果 NSString * const kCATransactionAnimationTimingFunction; //设置动画完成后的回调 NSString * const kCATransactionCompletionBlock; 除了隐式的展示动画外，也可以显式的通过调用CATransaction的相关方法进行显示的提交动画： 123456789//动画开始+ (void)begin;//提交动画+ (void)commit;//立即进行动画渲染 一般不需调用+ (void)flush;//下面这两个方法用于动画事物的加锁与解锁 在多线程动画中，保证修改属性的安全+ (void)lock;+ (void)unlock; 示例如下： 1234 [CATransaction begin]; [CATransaction setValue:@1 forKey:kCATransactionAnimationDuration]; layer.backgroundColor = [UIColor blueColor].CGColor; [CATransaction commit]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之六——CATransform3D变换的应用","slug":"161iOS开发CoreAnimation解读之六——CATransform3D变换的应用","date":"2015-12-05T16:00:00.000Z","updated":"2021-07-05T08:11:32.943Z","comments":true,"path":"2015/12/06/161iOS开发CoreAnimation解读之六——CATransform3D变换的应用/","link":"","permalink":"http://huishao.cc/2015/12/06/161iOS开发CoreAnimation解读之六——CATransform3D变换的应用/","excerpt":"","text":"iOS开发CoreAnimation解读之五——CATransform3D变换的应用一、引言CATransform3D定义了一个变化矩阵，通过对矩阵参数的设置，我们可以改变layer的一些属性，这个属性的改变，可以产生动画的效果。首先，CATransform3D定义了一个4*4的矩阵，如下： 1234567struct CATransform3D&#123; CGFloat m11, m12, m13, m14; CGFloat m21, m22, m23, m24; CGFloat m31, m32, m33, m34; CGFloat m41, m42, m43, m44;&#125;; 从m11到m44定义的含义如下： m11：x轴方向进行缩放 m12：和m21一起决定z轴的旋转 m13:和m31一起决定y轴的旋转 m14: m21:和m12一起决定z轴的旋转 m22:y轴方向进行缩放 m23:和m32一起决定x轴的旋转 m24: m31:和m13一起决定y轴的旋转 m32:和m23一起决定x轴的旋转 m33:z轴方向进行缩放 m34:透视效果m34= -1/D，D越小，透视效果越明显，必须在有旋转效果的前提下，才会看到透视效果 m41:x轴方向进行平移 m42:y轴方向进行平移 m43:z轴方向进行平移 m44:初始为1 二、CATransform3D中的属性和方法12345678//初始化一个transform3D对象，不做任何变换const CATransform3D CATransform3DIdentity;//判断一个transform3D对象是否是初始化的对象bool CATransform3DIsIdentity (CATransform3D t);//比较两个transform3D对象是否相同bool CATransform3DEqualToTransform (CATransform3D a, CATransform3D b);//将两个 transform3D对象变换属性进行叠加，返回一个新的transform3D对象CATransform3D CATransform3DConcat (CATransform3D a, CATransform3D b); 1、平移变换1234//返回一个平移变换的transform3D对象 tx，ty，tz对应x，y，z轴的平移CATransform3D CATransform3DMakeTranslation (CGFloat tx, CGFloat ty, CGFloat tz);//在某个transform3D变换的基础上进行平移变换，t是上一个transform3D，其他参数同上CATransform3D CATransform3DTranslate (CATransform3D t, CGFloat tx, CGFloat ty, CGFloat tz); 例如： 123456789 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeTranslation(10, 200, 0); newImageView.layer.transform =trans; 效果如下： 2、缩放变换1234//x，y，z分别对应x轴，y轴，z轴的缩放比例CATransform3D CATransform3DMakeScale (CGFloat sx, CGFloat sy, CGFloat sz);//在一个transform3D变换的基础上进行缩放变换，其他参数同上CATransform3D CATransform3DScale (CATransform3D t, CGFloat sx, CGFloat sy, CGFloat sz); 例如： 123456789UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeScale(2, 1, 1); newImageView.layer.transform =trans; 效果如下： 3、旋转变换123456//angle参数是旋转的角度，为弧度制 0-2π//x，y，z决定了旋转围绕的中轴，取值为-1——1之间，例如（1，0，0）,则是绕x轴旋转（0.5，0.5，0），则是绕x轴与y轴中//间45度为轴旋转,依次进行计算CATransform3D CATransform3DMakeRotation (CGFloat angle, CGFloat x, CGFloat y, CGFloat z);//在一个transform3D的基础上进行旋转变换，其他参数如上CATransform3D CATransform3DRotate (CATransform3D t, CGFloat angle, CGFloat x, CGFloat y, CGFloat z); 例如： 123456789UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeRotation(M_PI/2, 0, 0, 1); newImageView.layer.transform =trans; 效果如下： 另外，当我们有垂直于z轴的旋转分量时，设置m34的值可以增加透视效果，也可以理解为景深效果，例如： 123456789101112 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; imageView.layer.transform = CATransform3DMakeRotation(M_PI/4, 0, 1, 0); [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DIdentity; trans.m34 = -1/100.0; trans = CATransform3DRotate(trans, M_PI/4, 0, 1, 0); newImageView.layer.transform =trans; 两个imageView都进行了y轴的旋转变换，第二个有透视效果，第一个没有，运行如下： 4、旋转翻转变换12//将一个旋转的效果进行翻转 CATransform3D CATransform3DInvert (CATransform3D t); 例如： 123456789101112 UIImageView * imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; imageView.layer.transform = CATransform3DMakeRotation(M_PI/4, 0, 0, 1); [self.view addSubview:imageView]; UIImageView * newImageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; newImageView.image=[UIImage imageNamed:@&quot;屏幕快照 2015-12-06 下午3.27.15.png&quot;]; [self.view addSubview:newImageView]; CATransform3D trans = CATransform3DMakeRotation(M_PI/4, 0, 0, 1); trans = CATransform3DInvert(trans); newImageView.layer.transform =trans; 效果如下： 5、CATransform3D与CGAffineTransform的转换CGAffineTransform是UIKit框架中一个用于变换的矩阵，其作用与CATransform类似，只是其可以直接作用于View，而不用作用于layer，这两个矩阵也可以进行转换，方法如下： 123456//将一个CGAffinrTransform转化为CATransform3DCATransform3D CATransform3DMakeAffineTransform (CGAffineTransform m);//判断一个CATransform3D是否可以转换为CAAffineTransformbool CATransform3DIsAffine (CATransform3D t);//将CATransform3D转换为CGAffineTransformCGAffineTransform CATransform3DGetAffineTransform (CATransform3D t); 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之四——Layer层动画内容","slug":"159iOS开发CoreAnimation解读之四——Layer层动画内容","date":"2015-12-04T16:00:00.000Z","updated":"2021-07-05T08:09:40.544Z","comments":true,"path":"2015/12/05/159iOS开发CoreAnimation解读之四——Layer层动画内容/","link":"","permalink":"http://huishao.cc/2015/12/05/159iOS开发CoreAnimation解读之四——Layer层动画内容/","excerpt":"","text":"iOS开发CoreAnimation解读之四——Layer层动画内容一、引言通过前几篇博客的介绍，我们可以了解到layer层可以设置许多与控件UI相关的属性，并且对于iOS开发，UIView层的属性是会映射到CALayer的，因此，可以通过UIKit和CoreAnimation两个框架来设置控件的UI相关属性，当属性发生变化时，我们可以使其展示一个动画效果。 二、CAAnimation动画体系的介绍CAAnimation是CoreAnimation框架中执行动画对象的基类，下面有一张图，是我手画的，不太美观，但是可以将与CAAnimation相关的几个动画类的关系表达清楚： 从上图中可以看到，从CAAnimation中继承出三个子类，分别是用于创建属性动画的CAPropertyAnimation，创建转场动画的CATransition和创建组合动画的CAAnimationGroup。 我们就先从根类开始探讨。 1.CAAnimation属性和方法CAAnimation作为动画对象的基类，其中封装了动画的基础属性，如下： 12345678//通过类方法创建一个CAAnimation对象+ (instancetype)animation;//动画执行的时序模式@property(nullable, strong) CAMediaTimingFunction *timingFunction;//代理@property(nullable, strong) id delegate;//是否动画完成时将动画对象移除掉@property(getter=isRemovedOnCompletion) BOOL removedOnCompletion; timingFunction定义了动画执行的时序效果，CAMediaTimingFunction的创建方式如下： 1234567891011121314/*name参数决定的执行的效果，可选参数如下//线性执行 NSString * const kCAMediaTimingFunctionLinear; //淡入 在动画开始时 淡入效果 NSString * const kCAMediaTimingFunctionEaseIn; //淡出 在动画结束时 淡出效果 NSString * const kCAMediaTimingFunctionEaseOut; //淡入淡出 NSString * const kCAMediaTimingFunctionEaseInEaseOut; //默认效果 NSString * const kCAMediaTimingFunctionDefault;*/+ (instancetype)functionWithName:(NSString *)name; CAAnimation的代理方法入如下几个： 1234//动画开始时执行的回调- (void)animationDidStart:(CAAnimation *)anim;//动画结束后执行的回调- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; 2.CAPropertyAnimation属性与方法CAPropertyAnimation是继承于CAAnimation专门用来创建与属性相关的动画的类： 12345678910111213//创建对象 参数中的path就是我们要执行动画的属性//例如，如果传入@&quot;backgroundColor&quot; 当layer的背景颜色改变时，就会执行我们设置的动画+ (instancetype)animationWithKeyPath:(nullable NSString *)path;//这个属性确定动画执行的状态是否叠加在控件的原状态上//默认设置为NO，如果我们执行两次位置移动的动画，会从同一位置执行两次//如果设置为YES，则会在第一次执行的基础上执行第二次动画@property(getter=isAdditive) BOOL additive;//这个属性对重复执行的动画有效果//默认为NO，重复执行的动画每次都是从起始状态开始//如果设置为yes，则为此执行都会在上一次执行的基础上执行@property(getter=isCumulative) BOOL cumulative;//这个属性和transfron属性的动画执行相关@property(nullable, strong) CAValueFunction *valueFunction; 上面这些属性中，只有一个需要我们注意，valueFunction是专门为了transform动画而设置的，因为我们没有办法直接改变transform3D中的属性，通过这个参数，可以帮助我们直接操作transfrom3D属性变化产生动画效果，举例如下，一个绕Z轴旋转的动画： 123456789101112 //绕z轴旋转的动画 CABasicAnimation * ani = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;]; //从0度开始 ani.fromValue = @0; //旋转到180度 ani.toValue = [NSNumber numberWithFloat:M_PI]; //时间2S ani.duration = 2; //设置为z轴旋转 ani.valueFunction = [CAValueFunction functionWithName:kCAValueFunctionRotateZ]; //执行动画 [layer addAnimation:ani forKey:@&quot;&quot;]; 实际上，使用点的方式也是可以访问到相应属性的，如果不设置valueFunction，使用如下方法也是可以进行绕Z轴旋转的： 12345678910//绕z轴旋转的动画 CABasicAnimation * ani = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;]; //从0度开始 ani.fromValue = @0; //旋转到180度 ani.toValue = [NSNumber numberWithFloat:M_PI]; //时间2S ani.duration = 2; //执行动画 [layer addAnimation:ani forKey:@&quot;&quot;]; 3.CABasicAnimation属性CABasicAnimaton是CAPropertyAnimation分出来的一个子类，创建基础的属性变化动画，例如我们上面的示例代码，其中属性如下： 123@property(nullable, strong) id fromValue;@property(nullable, strong) id toValue;@property(nullable, strong) id byValue; 上面三个属性都是来确定动画的起始与结束位置，有如下的含义： fromValue和toValue不为空：动画的值由fromValue变化到toValue fromValue和byValue不为空：动画的值由fromValue变化到fromValue+byValue byValue和toValue不为空：动画的值由toValue-byValue变化到toValue 只有fromValue不为空：动画的值由fromValue变化到layer的当前状态值 只有toValue不为空：动画的值由layer当前的值变化到toValue 只有byValue不为空：动画的值由layer当前的值变化到layer当前的值+byValue 4.CAKeyframeAnimation关键帧动画CAKeyframeAnimation也是继承与CAPropertyAnimation的一个子类，其与CABasicAnimation的不同之处在于虽然其都是改变layer层属性的动画，但是CABasicAnimation只能设置初始与结束状态，这之间我们没办法控制，而CAKeyframeAnimation可以让我们设置一些关键帧再整个动画的过程中。属性方法如下： 1234567891011121314151617//关键帧的值数组 例如我们想让控件沿某个路径移动，这里面存放每个移动的点@property(nullable, copy) NSArray *values;//直接设置路径，作用域values类似@property(nullable) CGPathRef path;//设置每一帧执行的时间长短 这个的取值为0-1，代表占用时间的比例@property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes;//每一帧执行过程中的时序效果 上面有提过@property(nullable, copy) NSArray&lt;CAMediaTimingFunction *&gt; *timingFunctions;/*设置帧的中间值如何计算 NSString * const kCAAnimationLinear; NSString * const kCAAnimationDiscrete; NSString * const kCAAnimationPaced; NSString * const kCAAnimationCubic; NSString * const kCAAnimationCubicPaced;*/@property(copy) NSString *calculationMode; 示例如下： 1234 CAKeyframeAnimation * ani = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; ani.values = @[[NSValue valueWithCGPoint:CGPointMake(100, 100)],[NSValue valueWithCGPoint:CGPointMake(120, 100)],[NSValue valueWithCGPoint:CGPointMake(120, 200)],[NSValue valueWithCGPoint:CGPointMake(200, 200)]]; ani.duration = 3; [layer addAnimation:ani forKey:@&quot;&quot;]; 5.CASpringAnimation阻尼动画通过CASpringAnimation，可以帮助开发者很轻松的创建出有弹簧效果的动画，主要属性如下： 12345678910//这个属性设置弹簧重物的质量 会影响惯性 必须大于0 默认为1@property CGFloat mass;//设置弹簧的刚度系数，必须大于0 默认为100 这个越大 则回弹越快@property CGFloat stiffness;//阻尼系数 默认为10 必须大于0 这个值越大 回弹的幅度越小@property CGFloat damping;//初始速度@property CGFloat initialVelocity;//获取动画停下来需要的时间@property(readonly) CFTimeInterval settlingDuration; 6.CATransition转场动画CATransition和CAPropertyAnimation的不同之处在于当layer层出现时，会产生动画效果，而并不是属性改变时，属性如下： 123456789101112131415161718192021222324/*设置动画类型//淡入 NSString * const kCATransitionFade; //移入 NSString * const kCATransitionMoveIn; //压入 NSString * const kCATransitionPush; //溶解 NSString * const kCATransitionReveal;*/@property(copy) NSString *type;/*设置动画的方向//从右侧进 NSString * const kCATransitionFromRight; //从左侧进 NSString * const kCATransitionFromLeft; //从上侧进 NSString * const kCATransitionFromTop; //从下侧进 NSString * const kCATransitionFromBottom;*/@property(nullable, copy) NSString *subtype; 其实，关于type定义的动画效果，出来官方定义的，我们还可以使用一些私有的参数，如下： 12345pageCurl 翻页rippleEffect 滴水效果suckEffect 收缩效果，如一块布被抽走cube 立方体效果oglFlip 上下翻转效果 例如： 1234 CATransition * ani = [CATransition animation]; ani.type = @&quot;pageCurl&quot;; ani.subtype = kCATransitionFromRight; [layer addAnimation:ani forKey:@&quot;&quot;]; 7.CAAnimationGroup动画组CAAnimationGroup本身并没有定义动画，他可以将我们上面提到的相关动画进行组合： 1@property(nullable, copy) NSArray&lt;CAAnimation *&gt; *animations; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS运用runtime全局修改UILabel的默认字体","slug":"158iOS运用runtime全局修改UILabel的默认字体","date":"2015-12-01T16:00:00.000Z","updated":"2021-07-05T08:08:43.463Z","comments":true,"path":"2015/12/02/158iOS运用runtime全局修改UILabel的默认字体/","link":"","permalink":"http://huishao.cc/2015/12/02/158iOS运用runtime全局修改UILabel的默认字体/","excerpt":"","text":"iOS运用runtime全局修改UILabel的默认字体一、需求背景介绍在项目比较成熟的基础上，遇到了这样一个需求，应用中需要引入新的字体，需要更换所有Label的默认字体，但是同时，对于一些特殊设置了字体的label又不需要更换。乍看起来，这个问题确实十分棘手，首先项目比较大，一个一个设置所有使用到的label的font工作量是巨大的，并且在许多动态展示的界面中，可能会漏掉一些label，产生bug。其次，项目中的label来源并不唯一，有用代码创建的，有xib和storyBoard中的，这也将浪费很大的精力。这种情况下，我们可能会有下面两种处理方式。 二、处理方式1、使用框架创建我们自己的BaseLabel类，在其中进行默认字体的设置，并且并不影响在使用过程中特殊设置字体的label，这种方式可以满足我们的需求，但是并不适于我们的场景，项目已经成熟，重建一个label基类，来让所有的UILabel都换成它的工作量不会比重新设置所有label字体的工作量小太多。但这也是有优势的，至少如果下次再换字体，我们就不用麻烦了。 2、使用runtime替换UILabel初始化方法这是最简单方便的方法，我们可以使用runtime机制替换掉UILabel的初始化方法，在其中对label的字体进行默认设置。因为Label可以从initWithFrame、init和nib文件三个来源初始化，所以我们需要将这三个初始化的方法都替换掉。 首先，我们创建一个UILabel的类别： 12345#import &lt;UIKit/UIKit.h&gt;@interface UILabel (YHBaseChangeDefaultFont)@end 在其中加入如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#import &quot;UILabel+YHBaseChangeDefaultFont.h&quot;#import &lt;objc/runtime.h&gt;@implementation UILabel (YHBaseChangeDefaultFont)/** *每个NSObject的子类都会调用下面这个方法 在这里将init方法进行替换，使用我们的新字体 *如果在程序中又特殊设置了字体 则特殊设置的字体不会受影响 但是不要在Label的init方法中设置字体 *从init和initWithFrame和nib文件的加载方法 都支持更换默认字体 */+(void)load&#123; //只执行一次这个方法 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); //替换三个方法 SEL originalSelector = @selector(init); SEL originalSelector2 = @selector(initWithFrame:); SEL originalSelector3 = @selector(awakeFromNib); SEL swizzledSelector = @selector(YHBaseInit); SEL swizzledSelector2 = @selector(YHBaseInitWithFrame:); SEL swizzledSelector3 = @selector(YHBaseAwakeFromNib); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method originalMethod2 = class_getInstanceMethod(class, originalSelector2); Method originalMethod3 = class_getInstanceMethod(class, originalSelector3); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); Method swizzledMethod2 = class_getInstanceMethod(class, swizzledSelector2); Method swizzledMethod3 = class_getInstanceMethod(class, swizzledSelector3); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); BOOL didAddMethod2 = class_addMethod(class, originalSelector2, method_getImplementation(swizzledMethod2), method_getTypeEncoding(swizzledMethod2)); BOOL didAddMethod3 = class_addMethod(class, originalSelector3, method_getImplementation(swizzledMethod3), method_getTypeEncoding(swizzledMethod3)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; if (didAddMethod2) &#123; class_replaceMethod(class, swizzledSelector2, method_getImplementation(originalMethod2), method_getTypeEncoding(originalMethod2)); &#125;else &#123; method_exchangeImplementations(originalMethod2, swizzledMethod2); &#125; if (didAddMethod3) &#123; class_replaceMethod(class, swizzledSelector3, method_getImplementation(originalMethod3), method_getTypeEncoding(originalMethod3)); &#125;else &#123; method_exchangeImplementations(originalMethod3, swizzledMethod3); &#125; &#125;); &#125;/** *在这些方法中将你的字体名字换进去 */- (instancetype)YHBaseInit&#123; id __self = [self YHBaseInit]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; return __self;&#125;-(instancetype)YHBaseInitWithFrame:(CGRect)rect&#123; id __self = [self YHBaseInitWithFrame:rect]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; return __self;&#125;-(void)YHBaseAwakeFromNib&#123; [self YHBaseAwakeFromNib]; UIFont * font = [UIFont fontWithName:@&quot;这里输入你的字体名字&quot; size:self.font.pointSize]; if (font) &#123; self.font=font; &#125; &#125;@end 在上面的方法中写入我们想要UILabel默认显示的字体，我们分别从init，initWithFrame和nib文件创建一个UILabel添加到视图上，不做任何其他的操作： 1234567UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(20, 100, 280, 30)]; label.text = @&quot;你是从initWithFrame来的label&quot;; UILabel * label2 = [[UILabel alloc]init]; label2.frame= CGRectMake(20, 200, 280, 30); label2.text = @&quot;你是从init来的label&quot;; [self.view addSubview:label]; [self.view addSubview:label2]; 运行效果如下，可以看出，字体全部换掉了： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之三——几种常用Layer的使用解析","slug":"157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析","date":"2015-11-30T16:00:00.000Z","updated":"2021-07-05T08:07:52.920Z","comments":true,"path":"2015/12/01/157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析/","link":"","permalink":"http://huishao.cc/2015/12/01/157iOS开发CoreAnimation解读之三——几种常用Layer的使用解析/","excerpt":"","text":"iOS开发CoreAnimation解读之三——几种常用Layer的使用解析一、CAEmitterLayerCAEmitterLayer是CoreAnimation框架中的粒子发射层，在以前的一片博客中有详细的介绍和范例，这里不再重复，地址如下： 粒子效果的应用和火焰范例：http://my.oschina.net/u/2340880/blog/485095 二、CAGradientLayerCAGradientLayer是用于色彩梯度展示的layer图层，通过CAGradientLayer，我们可以很轻松的创建出有过渡效果的色彩图。其中属性如下： 1234567891011121314151617181920/*颜色数组，设置我们需要过的的颜色，必须是CGColor对象*/@property(nullable, copy) NSArray *colors;/*颜色开始进行过渡的位置这个数组中的元素是NSNumber类型，单调递增的，并且在0——1之间例如，如果我们设置两个颜色进行过渡，这个数组中写入0.5，则第一个颜色会在达到layer一半的时候开始向第二个颜色过渡*/@property(nullable, copy) NSArray&lt;NSNumber *&gt; *locations;/*下面两个参数用于设置渲染颜色的起点和终点 取值范围均为0——1默认起点为（0.5 ，0） 终点为（0.5 ，1）,颜色的过渡范围就是沿y轴从上向下*/@property CGPoint startPoint;@property CGPoint endPoint;/*渲染风格 iOS中只支持一种默认的kCAGradientLayerAxial，我们无需手动设置*/@property(copy) NSString *type; 用如下代码创建一个度过视图的效果： 12345678 CAGradientLayer * layer = [CAGradientLayer layer]; layer.colors = @[(id)[UIColor redColor].CGColor,(id)[UIColor blueColor].CGColor,(id)[UIColor greenColor].CGColor]; layer.locations = @[@0.1,@0.7,@1]; layer.bounds = CGRectMake(0, 0, 100, 100); layer.position = CGPointMake(100, 100); layer.startPoint = CGPointMake(0, 0); layer.endPoint = CGPointMake(1, 1); [self.view.layer addSublayer:layer]; 效果如下： 三、CAReplicatorLayerCAReplocatorLayer是拷贝视图容器，我们可以通过它，将其中的子layer进行拷贝，并进行一些差异处理，其中常用属性方法如下： 12345678910111213141516//拷贝的次数@property NSInteger instanceCount;//是否开启景深效果@property BOOL preservesDepth;//当CAReplicatorLayer的子Layer层进行动画的时候，拷贝的副本执行动画的延时@property CFTimeInterval instanceDelay;//拷贝副本的3D变换@property CATransform3D instanceTransform;//拷贝副本的颜色变换@property(nullable) CGColorRef instanceColor;//每个拷贝副本的颜色偏移参数@property float instanceRedOffset;@property float instanceGreenOffset;@property float instanceBlueOffset;//每个拷贝副本的透明度偏移参数@property float instanceAlphaOffset; 例如，通过拷贝一个色块，使其产生平移排列： 1234567891011121314 CAReplicatorLayer *reLayer = [CAReplicatorLayer layer]; reLayer.position = CGPointMake(0, 0); CALayer * layer= [CALayer layer]; [reLayer addSublayer:layer]; [self.view.layer addSublayer:reLayer]; layer.bounds = CGRectMake(0, 0, 20, 20); layer.position = CGPointMake(30, 100); layer.backgroundColor = [UIColor redColor].CGColor; //每个副本向右平移25px reLayer.instanceTransform=CATransform3DMakeTranslation(25, 0, 0); //如果进行动画，副本延时一秒执行 reLayer.instanceDelay = 1; //拷贝十个副本 reLayer.instanceCount = 10; 效果如下： 四、CAShapeLayerCAShapeLayer是图形layer层，我们可以自定义这个层的形状。先来看其中我们可以使用的属性和方法： 1@property(nullable) CGPathRef path; path属性为CAShapeLayer设置一个边界路径，例如我们可以创建一个三角形的路径通过如下代码： 12345678 CAShapeLayer * layer = [CAShapeLayer layer]; layer.position=CGPointMake(0,0); CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, 0, 100, 100); CGPathAddLineToPoint(path, 0, 300, 100); CGPathAddLineToPoint(path, 0, 200, 200); CGPathAddLineToPoint(path, 0, 100, 100); layer.path=path; 仅仅有路径，不能将我们想要的形状画出来，下面一些属性可以对图形的一些基础属性进行设置： 12345678910111213141516171819202122232425262728293031323334353637383940//设置图形的填充颜色@property(nullable) CGColorRef fillColor;/*设置图形的填充规则 选项如下：非零填充 NSString *const kCAFillRuleNonZero; 奇偶填充 NSString *const kCAFillRuleEvenOdd;*/@property(copy) NSString *fillRule;//设置线条颜色@property(nullable) CGColorRef strokeColor;//设置线条的起点与终点 0-1之间@property CGFloat strokeStart;@property CGFloat strokeEnd;//设置线条宽度@property CGFloat lineWidth;//设置两条线段相交时锐角斜面长度@property CGFloat miterLimit;/*设置线条首尾的外观可选参数如下无形状 NSString *const kCALineCapButt; 圆形 NSString *const kCALineCapRound; 方形 NSString *const kCALineCapSquare;*/@property(copy) NSString *lineCap;/*设置线段的链接方式棱角 NSString *const kCALineJoinMiter; 平滑 NSString *const kCALineJoinRound; 折线 NSString *const kCALineJoinBevel;*/@property(copy) NSString *lineJoin; 修改一下上面的代码，如下： 1234567891011121314151617CAShapeLayer * layer = [CAShapeLayer layer]; layer.position=CGPointMake(0,0); CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, 0, 100, 100); CGPathAddLineToPoint(path, 0, 300, 100); CGPathAddLineToPoint(path, 0, 200, 200); CGPathAddLineToPoint(path, 0, 100, 100); layer.path=path; layer.fillColor= [UIColor redColor].CGColor; layer.fillRule = kCAFillRuleEvenOdd; layer.strokeColor = [UIColor blueColor].CGColor; layer.strokeStart =0; layer.strokeEnd =0.5; layer.lineWidth = 5; layer.miterLimit = 1; layer.lineJoin = kCALineJoinMiter; [self.view.layer addSublayer:layer]; 效果如下： 除此之外，我们还可以设置边界的线条为虚线，通过下面两个属性： 1234567 //设置线段的宽度为5px 间距为10px /* 这个数组中还可以继续添加，会循环进行设置 例如 5 2 1 3 则第一条线段5px，间距2px，第二条线段1px 间距3px再开始第一条线段 */ layer.lineDashPattern = @[@05,@10]; //设置从哪个位置开始 layer.lineDashPhase =5; 如下： 五、CATextLayerCATextLayer可以进行文本的绘制，属性方法如下： 123456789101112131415161718192021222324252627282930//渲染的文字字符串@property(nullable, copy) id string;//设置字体@property(nullable) CFTypeRef font;//设置字号@property CGFloat fontSize;//设置文字颜色@property(nullable) CGColorRef foregroundColor;//是否换行@property(getter=isWrapped) BOOL wrapped;/*设置截断模式 NSString * const kCATruncationNone; 截断前部分 NSString * const kCATruncationStart; 截断后部分 NSString * const kCATruncationEnd; 截断中间 NSString * const kCATruncationMiddle;*/@property(copy) NSString *truncationMode;/*设置文字对齐模式 NSString * const kCAAlignmentNatural; NSString * const kCAAlignmentLeft; NSString * const kCAAlignmentRight; NSString * const kCAAlignmentCenter; NSString * const kCAAlignmentJustified;*/@property(copy) NSString *alignmentMode; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之二——对CALayer的分析","slug":"156iOS开发CoreAnimation解读之二——对CALayer的分析","date":"2015-11-25T16:00:00.000Z","updated":"2021-07-05T08:06:55.510Z","comments":true,"path":"2015/11/26/156iOS开发CoreAnimation解读之二——对CALayer的分析/","link":"","permalink":"http://huishao.cc/2015/11/26/156iOS开发CoreAnimation解读之二——对CALayer的分析/","excerpt":"","text":"iOS开发CoreAnimation解读之二——对CALayer的分析一、UIView中的CALayer属性1.Layer专门负责view的视图渲染每一个UIView的对象中都有一个layer这样的属性，并且layer会负责view中有关图形绘制的相关操作，例如我们设置view的背景颜色和设置layer的背景颜色都是有效的，并且，设置view的背景色依然是通过layer来展示的，我们可以写如下的测试代码： 1234567 UIView * view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; view.backgroundColor = [UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(100, 300, 100, 100)]; view2.layer.backgroundColor = view.layer.backgroundColor; [self.view addSubview:view]; [self.view addSubview:view2]; 可以看出，我们设置view的backgroundColor属性其实起作用的也是layer的backgroundColor。 2.自定义view默认layer属性的类UIView是很多视图类的父类，根据功能不同，会分出UIImageView，UIScrollerView，UITableView等，CALayer也相似，其也可以根据功能分出许多子类，还可以根据我们的需求自定义一个Layer类。UIView其中的layer默认是CALyer类，我们也可以通过重写View中的如下方法来使其创建我们需要的layer类： 12+(Class)layerClass&#123;&#125; 例如我们自定义一个View类，在自定义一个Layer类，是的自定义的View默认创建的layer是自定义的layer： 在MyView中重写上述方法： 123+(Class)layerClass&#123; return [MyLayer class];&#125; 在MyLayer中进行一些自定义： 12345678- (instancetype)init&#123; self = [super init]; if (self) &#123; self.backgroundColor = [UIColor redColor].CGColor; &#125; return self;&#125; 之后我们使用这个MyView的对象时，layer层的背景色就是红色的了。 二、几种系统的Layer类前边说过，和UIView相似，CALayer也很据功能衍生出许多子类，系统系统给我们可以使用的有如下几种： 1.CAEmitterLayerCoreAnimation框架中的CAEmitterLayer是一个粒子发射器系统，负责粒子的创建和发射源属性。通过它，我们可以轻松创建出炫酷的粒子效果。 2.CAGradientLayerCAGradientLayer可以创建出色彩渐变的图层效果，如下： 3.CAEAGLLayerCAEAGLLayer可以通过OpenGL ES来进行界面的绘制。 4.CAReplicatorLayerCAReplicatorLayer是一个layer容器，会对其中的subLayer进行复制和属性偏移，通过它，可以创建出类似倒影的效果，也可以进行变换复制，如下： 5.CAScrollLayerCAScrollLayer可以支持其上管理的多个子层进行滑动，但是只能通过代码进行管理，不能进行用户点按触发。 6.CAShapeLayerCAShapeLayer可以让我们在layer层是直接绘制出自定义的形状。 7.CATextLayerCATextLayer可以通过字符串进行文字的绘制。 8.CATiledLayerCATiledLayer类似瓦片视图，可以将绘制分区域进行，常用于一张大的图片的分不分绘制。 9.CATransformLayerCATransformLayer用于构建一些3D效果的图层。 三、设置与调整Layer层的内容设置层的内容有下面三种方式： 1.可以通过设置CGImage为layer的内容。 2.可以通过代理方法来动态修改或者绘制层的内容。 3.通过自定义CALayer对象来创建层的内容。 当你设置了Layer的内容后，例如设置了一张图片，内容的尺寸不一定会刚好和layer的尺寸合适，我们可以对其位置的调整，使其达到我们想要的效果，contentsGravity属性决定了内容对齐与填充方式，它可以分为两个方面： 1.不改变内容的原始大小 这种模式中不会改变内容的原始大小，如果层的尺寸小于内容的尺寸，则内容会被切割，如果层的尺寸大于内容的尺寸，多出的部分将会显示层的背景颜色。下面的这些设置方式为这种模式： 123456789101112131415161718CA_EXTERN NSString * const kCAGravityCenter __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTop __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottom __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTopLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityTopRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottomLeft __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityBottomRight __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0); 每个参数对应的对其模式如下图： 2.改变内容的尺寸大小 这种模式设置的实际上是一种填充方式，参数如下： 123456CA_EXTERN NSString * const kCAGravityResize __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityResizeAspect __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0);CA_EXTERN NSString * const kCAGravityResizeAspectFill __OSX_AVAILABLE_STARTING (__MAC_10_5, __IPHONE_2_0); 四、CALayer的接口应用总结1、创建与初始化layer相关123456//通过类方法创建并初始化一个layer+ (instancetype)layer;//初始化方法- (instancetype)init;//通过一个layer创建一个副本- (instancetype)initWithLayer:(id)layer; 2、渲染层layer与模型层layer在CALayer中，有如下两个属性，他们都返回一个CALayer的对象： 1234//渲染层layer- (nullable id)presentationLayer;//模型层layer- (id)modelLayer; 对于presentationLayer，这个属性不一定总会返回一个实体对象，只有当进行动画或者其他渲染的操作时，这个属性会返回一个在当前屏幕上的layer，不且每一次执行，这个对象都会不同，它是原layer的一个副本presentationLayer的modelLayer就是其实体layer层。 对于modelLayer，它会返回当前的存储信息的Layer，也是当前的layer对象，始终唯一。 3.一些属性与方法1+ (nullable id)defaultValueForKey:(NSString *)key; 上面这个属性用于设置layer中默认属性的值，我们可以在子类中重写这个方法来改变默认创建的layer的一些属性，例如如下代码，我们创建出来的layer就默认有红色的背景颜色： 123456+(id)defaultValueForKey:(NSString *)key&#123; if ([key isEqualToString:@&quot;backgroundColor&quot;]) &#123; return (id)[UIColor redColor].CGColor; &#125; return [super defaultValueForKey:key];&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//这个方法也只使用在子类中重写，用于设置在某些属性改变时是否进行layer重绘+ (BOOL)needsDisplayForKey:(NSString *)key;//子类重写这个方法设置属性是否可以被归档- (BOOL)shouldArchiveValueForKey:(NSString *)key;/*********************************************///设置layer尺寸@property CGRect bounds;//设置layer位置@property CGPoint position;//设置其在父layer中的层次，默认为0，这个值越大，层次越靠上@property CGFloat zPosition;//锚点@property CGPoint anchorPoint;//在Z轴上的锚点位置 3D变换时会有很大影响@property CGFloat anchorPointZ;//进行3D变换@property CATransform3D transform;//获取和设置CGAffineTransform变换- (CGAffineTransform)affineTransform;- (void)setAffineTransform:(CGAffineTransform)m;//设置layer的frame@property CGRect frame;//设置是否隐藏@property(getter=isHidden) BOOL hidden;//每个layer层有两面，这个属性确定是否两面都显示@property(getter=isDoubleSided) BOOL doubleSided;//是否进行y轴的方向翻转@property(getter=isGeometryFlipped) BOOL geometryFlipped;//获取当前layer内容y轴方向是否被翻转了- (BOOL)contentsAreFlipped;//父layer视图@property(nullable, readonly) CALayer *superlayer;//从其父layer层上移除- (void)removeFromSuperlayer;//所有子layer数组@property(nullable, copy) NSArray&lt;CALayer *&gt; *sublayers;//添加一个字layer- (void)addSublayer:(CALayer *)layer;//插入一个子layer- (void)insertSublayer:(CALayer *)layer atIndex:(unsigned)idx;//将一个子layer插入到最下面- (void)insertSublayer:(CALayer *)layer below:(nullable CALayer *)sibling;//将一个子layer插入到最上面- (void)insertSublayer:(CALayer *)layer above:(nullable CALayer *)sibling;//替换一个子layer- (void)replaceSublayer:(CALayer *)layer with:(CALayer *)layer2;//对其子layer进行3D变换@property CATransform3D sublayerTransform;//遮罩层layer@property(nullable, strong) CALayer *mask;//舍否进行bounds的切割，在设置圆角属性时会设置为YES@property BOOL masksToBounds;//下面这些方法用于坐标转换- (CGPoint)convertPoint:(CGPoint)p fromLayer:(nullable CALayer *)l;- (CGPoint)convertPoint:(CGPoint)p toLayer:(nullable CALayer *)l;- (CGRect)convertRect:(CGRect)r fromLayer:(nullable CALayer *)l;- (CGRect)convertRect:(CGRect)r toLayer:(nullable CALayer *)l;//返回包含某一点的最上层的子layer- (nullable CALayer *)hitTest:(CGPoint)p;//返回layer的bounds内是否包含某一点- (BOOL)containsPoint:(CGPoint)p;//设置layer的内容，一般会设置为CGImage的对象@property(nullable, strong) id contents;//获取内容的rect尺寸@property CGRect contentsRect;//设置内容的填充和对其方式，具体上面有说@property(copy) NSString *contentsGravity;//设置内容的缩放@property CGFloat contentsScale; 下面这个属性和内容拉伸相关： 1@property CGRect contentsCenter; 这个属性确定一个矩形区域，当内容进行拉伸或者缩放的时候，这一部分的区域是会被形变的，例如默认设置为(0,0,1,1)，则整个内容区域都会参与形变。如果我们设置为(0.25,0.25,0.5,0.5),那么只有中间0.5*0.5比例宽高的区域会被拉伸，四周都不会。 下面这两个属性用来设置缩放或拉伸的模式： 12345678910111213//设置缩小的模式@property(copy) NSString *minificationFilter;//设置放大的模式@property(copy) NSString *magnificationFilter;//缩放因子@property float minificationFilterBias;//模式参数如下//临近插值NSString * const kCAFilterNearest;//线性拉伸NSString * const kCAFilterLinear;//瓦片复制拉伸NSString * const kCAFilterTrilinear; 1234567891011121314151617//设置内容是否完全不透明@property(getter=isOpaque) BOOL opaque;//重新加载绘制内容- (void)display;//设置内容为需要重新绘制- (void)setNeedsDisplay;//设置某一区域内容需要重新绘制- (void)setNeedsDisplayInRect:(CGRect)r;//获取是否需要重新绘制- (BOOL)needsDisplay;//如果需要，进行内容重绘- (void)displayIfNeeded;//这个属性设置为YES，当内容改变时会自动调用- (void)setNeedsDisplay函数@property BOOL needsDisplayOnBoundsChange;//绘制与读取内容- (void)drawInContext:(CGContextRef)ctx;- (void)renderInContext:(CGContextRef)ctx; 1234567891011121314151617181920//设置背景颜色@property(nullable) CGColorRef backgroundColor;//设置圆角半径@property CGFloat cornerRadius;//设置边框宽度@property CGFloat borderWidth;//设置边框颜色@property(nullable) CGColorRef borderColor;//设置透明度@property float opacity;//设置阴影颜色@property(nullable) CGColorRef shadowColor;//设置阴影透明度@property float shadowOpacity;//设置阴影偏移量@property CGSize shadowOffset;//设置阴影圆角半径@property CGFloat shadowRadius;//设置阴影路径@property(nullable) CGPathRef shadowPath; 12345678910//添加一个动画对象 key值起到id的作用，通过key值，可以取到这个动画对象- (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key;//移除所有动画对象- (void)removeAllAnimations;//移除某个动画对象- (void)removeAnimationForKey:(NSString *)key;//获取所有动画对象的key值- (nullable NSArray&lt;NSString *&gt; *)animationKeys;//通过key值获取动画对象- (nullable CAAnimation *)animationForKey:(NSString *)key; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程","slug":"155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程","date":"2015-11-24T16:00:00.000Z","updated":"2021-07-05T08:05:08.423Z","comments":true,"path":"2015/11/25/155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程/","link":"","permalink":"http://huishao.cc/2015/11/25/155iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程/","excerpt":"","text":"iOS开发CoreAnimation解读之一——初识CoreAnimation核心动画编程一、引言众所周知，绚丽动画效果是iOS系统的一大特点，通过UIView层封装的动画，基本已经可以满足我们应用开发的所有需求，但若需要更加自由的控制动画的展示，我们就需要使用CoreAnimation框架中的一些类与方法。这里先附上前几篇与动画相关的博客地址，这一系列，我们抽出其中的CoreAnimation框架来详细解读。 UIViewAnimation动画的使用：http://my.oschina.net/u/2340880/blog/484457 UIView动画执行的另一种方式：http://my.oschina.net/u/2340880/blog/484538 UIView转场动画：http://my.oschina.net/u/2340880/blog/484669 CoreAnimation隐式动画的应用：http://my.oschina.net/u/2340880/blog/484793 粒子效果的使用：http://my.oschina.net/u/2340880/blog/485095 二、初识CoreAnimationCoreAnimation框架是基于OpenGL与CoreGraphics图像处理框架的一个跨平台的动画框架。简单来说，它使帮助我们将图像读取成位图，通过硬件的处理，实现动画效果。文档中的一张图片十分形象的描述了CoreAnimation与UIKit框架的关系： 在CoreAnimation中，大部分的动画效果都是通过Layer层来实现的，通过CALayer，我们可以组织复杂的层级结构。 在CoreAnimation中，大多数的动画效果是添加在图层属性的变化上，例如，改变图层的位置，大小，颜色，圆角半径等。Layer层并不决定视图的展现，它只是存储了视图的几何属性状态。 三、锚点对几何属性的影响关于Layer层，我们需要了解一个有关锚点的概念，锚点决定了图层的绘制位置以及动画展示时其参照的点，锚点的取值范围为0-1，锚点有两个地方在应用中会有很大影响： 1.layer层的position参照点始终和锚点重合 通过position决定了layer所在的位置，在Layer中，虽然也有frame这样的属性，但我们很少使用，一般我们会使用bounds和position确定Layer层的大小和位置。 2.锚点决定进行动作的参照点 例如一个旋转动作，锚点决定了层旋转的中心点，对于放大缩小的动作，锚点决定了放大或者缩小参照的中心点。 可以来看下边一组图： 上面两个矩形，frame和bounds都是一样的，第一个矩形的锚点位置为(0.5,0.5)，第二个为(0,0), 因此，两个矩形的position点是不同的，第一个是(100,100),第二个是(40,60)。再看当产生动作时锚点的影响： 现在就很好理解了，锚点的不同直接影响了动作产生的参照点。 通过CALayer的如下属性，我们可以设置锚点，注意x，y的取值范围都是0~1，代表所占宽度和高度的比例： 1@property CGPoint anchorPoint; 四、Layer与View之间的关系Layer是专门用于辅助我们绘制图像的层，它使支持三维坐标系的绘制的，通过每个坐标点与转换矩阵的运算，来决定最后绘制的状态，并且，Layer可以更高帧率的绘制动画效果。然而Layer与View依然有很大不同，首先，我们不可能只通过Layer来开发应用程序，Layer并没有接收事件和处理用户交互的能力，这些依然需要View来完成，每一个View中，都有一个Layer的属性来辅助进行图形的绘制。并且Layer是可以层级嵌套的，开发中，我们可以根据需求灵活选择。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS9新特性——堆叠视图UIStackView","slug":"154iOS9新特性——堆叠视图UIStackView","date":"2015-11-16T16:00:00.000Z","updated":"2021-07-05T08:03:07.184Z","comments":true,"path":"2015/11/17/154iOS9新特性——堆叠视图UIStackView/","link":"","permalink":"http://huishao.cc/2015/11/17/154iOS9新特性——堆叠视图UIStackView/","excerpt":"","text":"iOS9新特性——堆叠视图UIStackView一、引言随着autolayout的推广开来，更多的app开始使用自动布局的方式来构建自己的UI系统，autolayout配合storyBoard和一些第三方的框架，对于创建约束来说，已经十分方便，但是对于一些动态的线性布局的视图，我们需要手动添加的约束不仅非常多，而且如果我们需要插入或者移除其中的一些UI元素的时候，我们又要做大量的修改约束的工作，UIStackView正好可以解决这样的问题。 二、在storyBoard上初识StackViewUIStackView是一个管理一组堆叠视图的控制器类视图，所谓堆叠视图时一种平铺式的线性布局方式，不可重叠，布局方向也不可交错，如果你做过watchOS的开发，你会发现，其实StackView与watchOS中的group十分能相似。 例如，我们如果需要一个如下效果的布局，在屏幕的中间摆放几个大小一致的色块，无论屏幕朝向如何，其位置都不会变化，并且可以向其中添加和移除色块的数量： 首先，我们在ViewController中拉入一个stackView： 将一些属性设置如下： Axis是设置布局的方向，有水平和垂直两种方式，一个StackView只能选择一种布局模式。 Alignment是选择其管理视图的对齐模式，我们这里选择充满。 Distribution是设置其管理视图的排列方式，我们选择等宽充满。 Spacing是设置视图之间的间距，设置为10. 之后有一点需要注意，stackView用于布局其内部管理的视图，对于它本身，我们还需要添加一些约束，将它约束在屏幕的中间。 我们向其中拖入任意数量的view，设置不同的颜色，就实现了我们想要的效果，并且可以随意动态删除和添加其中的view数量，不需要改变约束。 三、从代码学习UIStackView通过代码创建一个UIStackView也非常简单，首先，我们先通过代码实现上面的效果： 123456789101112131415161718 NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i =0 ; i&lt;5; i++) &#123; UIView * view = [[UIView alloc]init]; view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [array addObject:view]; &#125; UIStackView * stackView = [[UIStackView alloc]initWithArrangedSubviews:array]; [self.view addSubview:stackView]; [stackView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(self.view.mas_centerX); make.centerY.equalTo(self.view.mas_centerY); make.leading.equalTo(self.view.mas_leading).offset(20); make.trailing.equalTo(self.view.mas_trailing).offset(-20); make.size.height.equalTo(@100); &#125;]; stackView.axis = UILayoutConstraintAxisHorizontal; stackView.distribution = UIStackViewDistributionFillEqually; stackView.alignment = UIStackViewAlignmentFill; 效果图如下： 我们的布局没有问题，并且可以动态的改变其中view的个数，使用如下方法添加一个view： 123 UIView * newView = [[UIView alloc]init]; newView.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [stackView addArrangedSubview:newView]; 与之相对，我们可以使用下面的方法移除一个view： 12 UIView * view = [stackView arrangedSubviews].lastObject; [stackView removeArrangedSubview:view]; 特别注意：addArrangedSubview和addSubview有很大的区别，使用前者是将试图添加进StackView的布局管理，后者只是简单的加在试图的层级上，并不接受StackView的布局管理。 技巧：因为StackView继承于UIView，因此在布局改变的时候，我们可以使用UIView层的动画，如下： 12345 //在添加view的时候会有动画效果，移除的时候没有 [stackView addArrangedSubview:newView]; [UIView animateWithDuration:1 animations:^&#123; [stackView layoutIfNeeded]; &#125;]; 四、再来深入理解下UIStackView通过上面的介绍，我们已经基本了解了StackView的使用和特点，下面我们再来仔细介绍一下与其相关的属性和方法的使用，使我们能够更加得心应手。 有关被管理视图的添加与移除： 12345678910//初始化方法，通过数组传入被管理的视图- (instancetype)initWithArrangedSubviews:(NSArray&lt;__kindof UIView *&gt; *)views; //获取被管理的所有视图@property(nonatomic,readonly,copy) NSArray&lt;__kindof UIView *&gt; *arrangedSubviews;//添加一个视图进行管理- (void)addArrangedSubview:(UIView *)view;//移除一个被管理的视图- (void)removeArrangedSubview:(UIView *)view;//在指定位置插入一个被管理的视图- (void)insertArrangedSubview:(UIView *)view atIndex:(NSUInteger)stackIndex; 与StackView布局设置相关： 1.布局模式： 1@property(nonatomic) UILayoutConstraintAxis axis; 上面这个属性用于设置布局的模型，枚举如下： 1234567//stackView只有两种布局模式 水平和竖直typedef NS_ENUM(NSInteger, UILayoutConstraintAxis) &#123; //水平布局 UILayoutConstraintAxisHorizontal = 0, //竖直布局 UILayoutConstraintAxisVertical = 1&#125;; 2.对齐模式： 1@property(nonatomic) UIStackViewAlignment alignment; 这个属性用于设置控件的对其模式，枚举如下： 123456789101112131415161718typedef NS_ENUM(NSInteger, UIStackViewAlignment) &#123; //水平布局时为高度充满，竖直布局时为宽度充满 UIStackViewAlignmentFill, //前边对其 UIStackViewAlignmentLeading, //顶部对其 UIStackViewAlignmentTop = UIStackViewAlignmentLeading, //第一个控件文字的基线对其 水平布局有效 UIStackViewAlignmentFirstBaseline, //中心对其 UIStackViewAlignmentCenter, //后边对其 UIStackViewAlignmentTrailing, //底部对其 UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing, //基线对其，水平布局有效 UIStackViewAlignmentLastBaseline, &#125; NS_ENUM_AVAILABLE_IOS(9_0); 在上面的例子中，我们设置了对其方式为充满，这样的话，我们就不需要再做过多控件尺寸的约束，如果我们被管理的控件高度或者宽度不一，我们可以设置中心对其，这样的话，我们还需要为每个控件添加一个宽度或者高度的约束，如下： 12345678910111213141516171819202122 NSMutableArray * array = [[NSMutableArray alloc]init]; for (int i =0 ; i&lt;5; i++) &#123; UIView * view = [[UIView alloc]init]; view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; float height = arc4random()%90+10; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo([NSNumber numberWithFloat:height]); &#125;]; [array addObject:view]; &#125; stackView = [[UIStackView alloc]initWithArrangedSubviews:array]; [self.view addSubview:stackView]; [stackView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(self.view.mas_centerX); make.centerY.equalTo(self.view.mas_centerY); make.leading.equalTo(self.view.mas_leading).offset(20); make.trailing.equalTo(self.view.mas_trailing).offset(-20); make.size.height.equalTo(@100); &#125;]; stackView.axis = UILayoutConstraintAxisHorizontal; stackView.distribution = UIStackViewDistributionFillEqually; stackView.alignment = UIStackViewAlignmentCenter; 效果如下： 这样，参差不齐的控件布局我们也可以轻松完成。 3.排列方式 1@property(nonatomic) UIStackViewDistribution distribution; 排列方式的枚举如下： 123456789101112typedef NS_ENUM(NSInteger, UIStackViewDistribution) &#123; //充满，当只有一个控件时可以使用 UIStackViewDistributionFill = 0, //平分充满，每个控件占据相同尺寸排列充满 UIStackViewDistributionFillEqually, //会优先按照约束的尺寸进行排列，如果没有充满，会拉伸最后一个排列的控件充满 UIStackViewDistributionFillProportionally, //等间距排列 UIStackViewDistributionEqualSpacing, //中心距离相等 UIStackViewDistributionEqualCentering,&#125; NS_ENUM_AVAILABLE_IOS(9_0); 注意，除了我们选择fill属性时不需约束控件视图的尺寸，其他都需要进行约束，例如如果我们选择等间距，我把改成如下代码： 123456 [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo([NSNumber numberWithFloat:height]); make.width.equalTo(@50); &#125;]; stackView.distribution = UIStackViewDistributionEqualSpacing; 效果如下： 4.其他 123456//设置最小间距@property(nonatomic) CGFloat spacing;//设置布局时是否参照基线@property(nonatomic,getter=isBaselineRelativeArrangement) BOOL baselineRelativeArrangement;//设置布局时是否以控件的LayoutMargins为标准，默认为NO，是以控件的bounds为标准@property(nonatomic,getter=isLayoutMarginsRelativeArrangement) BOOL layoutMarginsRelativeArrangement; 五、UIStackView的嵌套一个StackView不允许我们进行水平和竖直的交叉布局，但是我们可以通过嵌套的方式来实现复杂的布局效果，比如我们实现一个类似电影表标签，可以使用水平布局的StackView中嵌套一个竖直布局的StackView： 十分轻松就可以实现如下的效果： 看到了吧，通过StackView，我们没有添加过多的约束，使我们布局起来更加轻松了。如果你常常使用storyBoard进行开发，还有一个小技巧可以方便的将两个控件整合到一个StackView中，按住command，选中两个控件，之后点击右下角的如下图标，系统会自动帮我们生成一个StackView，将选中的两个控件整合进去，很酷吧！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发中标签控制器的使用——UITabBarController","slug":"153iOS开发中标签控制器的使用——UITabBarController","date":"2015-11-12T16:00:00.000Z","updated":"2021-07-05T08:02:08.233Z","comments":true,"path":"2015/11/13/153iOS开发中标签控制器的使用——UITabBarController/","link":"","permalink":"http://huishao.cc/2015/11/13/153iOS开发中标签控制器的使用——UITabBarController/","excerpt":"","text":"iOS开发中标签控制器的使用——UITabBarController一、引言与导航控制器相类似，标签控制器也是用于管理视图控制器的一个UI控件，在其内部封装了一个标签栏，与导航不同的是，导航的管理方式是纵向的，采用push与pop切换控制器，标签的管理是横向的，通过标签的切换来改变控制器，一般我们习惯将tabBar作为应用程序的根视图控制器，在其中添加导航，导航中在对ViewController进行管理。 二、创建一个标签控制器通过如下的步骤，我们可以很简便的创建一个TabBarController： 12345678910111213UITabBarController * tabBar= [[UITabBarController alloc]init]; NSMutableArray * controllerArray = [[NSMutableArray alloc]init]; for (int i=0; i&lt;4; i++) &#123; UIViewController * con = [[UIViewController alloc]init]; [con loadViewIfNeeded]; con.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; con.tabBarItem.image = [UIImage imageNamed:@&quot;btn_publish_face_a.png&quot;]; con.tabBarItem.title=[NSString stringWithFormat:@&quot;%d&quot;,i+1]; con.title = [NSString stringWithFormat:@&quot;%d&quot;,i+1]; [controllerArray addObject:con]; &#125; tabBar.viewControllers = controllerArray; [self presentViewController:tabBar animated:YES completion:nil]; 通过点击下面的标签按钮，可以很方便的切换控制器。如果我们的控制器数超过4个，系统会被我们创建一个more的导航，并且可以通过系统自带的编辑来调整控制器的顺序，如下： 三、UITabBarController的属性和方法123456789101112131415//管理的viewController数组@property(nullable, nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;- (void)setViewControllers:(NSArray&lt;__kindof UIViewController *&gt; * __nullable)viewControllers animated:(BOOL)animated;//选中的ViewControlle@property(nullable, nonatomic, assign) __kindof UIViewController *selectedViewController;//通过编号设置选中ViewController@property(nonatomic) NSUInteger selectedIndex;//当viewController大于4个时，获取&quot;更多&quot;标签的导航控制器@property(nonatomic, readonly) UINavigationController *moreNavigationController; //这个属性设置的是可以进行自定义排列顺序的视图控制器，如上面第二张图中的，默认是全部@property(nullable, nonatomic, copy) NSArray&lt;__kindof UIViewController *&gt; *customizableViewControllers;//标签控制器中分装的标签栏@property(nonatomic,readonly) UITabBar *tabBar NS_AVAILABLE_IOS(3_0);//代理@property(nullable, nonatomic,weak) id&lt;UITabBarControllerDelegate&gt; delegate; 四、关于标签栏TabBar通过自定义标签栏的一些属性，使我们可以更加灵活的使用tabBar。 1、UITabBar属性和方法设置标签： 1234@property(nullable,nonatomic,copy) NSArray&lt;UITabBarItem *&gt; *items; //设置选中的标签 @property(nullable,nonatomic,assign) UITabBarItem *selectedItem; - (void)setItems:(nullable NSArray&lt;UITabBarItem *&gt; *)items animated:(BOOL)animated; 设置自定义标签顺序： 123456//调用这个方法会弹出一个类似上面第二张截图的控制器，我们可以交换标签的布局顺序- (void)beginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //完成标签布局- (BOOL)endCustomizingAnimated:(BOOL)animated; //是否正在自定义标签布局- (BOOL)isCustomizing; 设置tabBar颜色相关： 1234//设置渲染颜色，会影响选中字体和图案的渲染@property(null_resettable, nonatomic,strong) UIColor *tintColor;//设置导航栏的颜色@property(nullable, nonatomic,strong) UIColor *barTintColor; 设置背景图案： 123456//设置导航栏背景图案@property(nullable, nonatomic,strong) UIImage *backgroundImage;//设置选中一个标签时，标签背后的选中提示图案 这个会出现在设置的item图案的后面@property(nullable, nonatomic,strong) UIImage *selectionIndicatorImage;//设置阴影的背景图案@property(nullable, nonatomic,strong) UIImage *shadowImage TabBar中标签的宏观属性： 123456789101112//设置标签item的位置模式@property(nonatomic) UITabBarItemPositioning itemPositioning;//枚举如下typedef NS_ENUM(NSInteger, UITabBarItemPositioning) &#123; UITabBarItemPositioningAutomatic,//自动 UITabBarItemPositioningFill,//充满 UITabBarItemPositioningCentered,//中心&#125; NS_ENUM_AVAILABLE_IOS(7_0);//设置item宽度@property(nonatomic) CGFloat itemWidth;//设置item间距@property(nonatomic) CGFloat itemSpacing; 与导航栏类似，也可以设置tabBar的风格和透明效果： 1234//风格 分黑白两种@property(nonatomic) UIBarStyle barStyle;//是否透明效果@property(nonatomic,getter=isTranslucent) BOOL translucent; 2、UITabBarDelegate123456789//选中标签时调用- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item;//将要开始编辑标签时- (void)tabBar:(UITabBar *)tabBar willBeginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //已经开始编辑标签时 - (void)tabBar:(UITabBar *)tabBar didBeginCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items; //将要进入编辑状态时- (void)tabBar:(UITabBar *)tabBar willEndCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items changed:(BOOL)changed; //已经进入编辑状态时- (void)tabBar:(UITabBar *)tabBar didEndCustomizingItems:(NSArray&lt;UITabBarItem *&gt; *)items changed:(BOOL)changed; 五、再看UITabBarItem和NavigationItem类似，标签栏上的item也可以自定义，一些方法如下。 初始化方法： 12345//通过标题和图案进行创建- (instancetype)initWithTitle:(nullable NSString *)title image:(nullable UIImage *)image tag:(NSInteger)tag;- (instancetype)initWithTitle:(nullable NSString *)title image:(nullable UIImage *)image selectedImage:(nullable UIImage *)selectedImage;//创建系统类型的- (instancetype)initWithTabBarSystemItem:(UITabBarSystemItem)systemItem tag:(NSInteger)tag; UITabBarSystemItem的枚举如下： 1234567891011121314typedef NS_ENUM(NSInteger, UITabBarSystemItem) &#123; UITabBarSystemItemMore,//更多图标 UITabBarSystemItemFavorites,//最爱图标 UITabBarSystemItemFeatured,//特征图标 UITabBarSystemItemTopRated,//高级图标 UITabBarSystemItemRecents,//最近图标 UITabBarSystemItemContacts,//联系人图标 UITabBarSystemItemHistory,//历史图标 UITabBarSystemItemBookmarks,//图书图标 UITabBarSystemItemSearch,//查找图标 UITabBarSystemItemDownloads,//下载图标 UITabBarSystemItemMostRecent,//记录图标 UITabBarSystemItemMostViewed,//全部查看图标&#125;; UITabBarItem常用属性： 12//设置选中图案@property(nullable, nonatomic,strong) UIImage *selectedImage; 下面这个属性可以设置item的头标文字： 1 con.tabBarItem.badgeValue = @&quot;1&quot;; 12//设置标题的位置偏移@property (nonatomic, readwrite, assign) UIOffset titlePositionAdjustment; 由于UITabBarItem是继承于UIBarItem，还有下面这个属性可以设置使用： 12345678910111213//标题@property(nullable, nonatomic,copy) NSString *title; //图案 @property(nullable, nonatomic,strong) UIImage *image; //横屏时的图案 @property(nullable, nonatomic,strong) UIImage *landscapeImagePhone;//图案位置偏移@property(nonatomic) UIEdgeInsets imageInsets; //横屏时的图案位置偏移@property(nonatomic) UIEdgeInsets landscapeImagePhoneInsets ;//设置和获取标题的字体属性- (void)setTitleTextAttributes:(nullable NSDictionary&lt;NSString *,id&gt; *)attributes forState:(UIControlState)state;- (nullable NSDictionary&lt;NSString *,id&gt; *)titleTextAttributesForState:(UIControlState)state; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS自定义的emoji表情键盘","slug":"152iOS自定义的emoji表情键盘","date":"2015-11-10T16:00:00.000Z","updated":"2021-07-05T07:59:54.443Z","comments":true,"path":"2015/11/11/152iOS自定义的emoji表情键盘/","link":"","permalink":"http://huishao.cc/2015/11/11/152iOS自定义的emoji表情键盘/","excerpt":"","text":"iOS自定义的表情键盘一、关于emoji表情随着iOS系统版本的升级，对原生emoji表情的支持也越来越丰富。emoji表情是unicode码中为表情符号设计的一组编码，当然，还有独立于unicode的另一套编码SBUnicode，在OS系统中，这两种编码都有很好的支持。UI系统会自动帮我们将编码转义成表情符号，例如用SBUnicode如下代码： 1234 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; label.font = [UIFont systemFontOfSize:25]; label.text = @&quot;\\uE056&quot;; [self.view addSubview:label]; 就会在屏幕上出现一个笑脸： 二、开发表情键盘的思路首先为了实现跨平台，无论iOS端，andorid端还是web端，都要有一个相同的标准，这个标准就可以是国际Unicode编码，我们的思路是将表情文字进行unicode编码后再进行传输，因此，有两中方式，一种是通过自定义一套表情切图，将其与unicode码一一对应，在转码的时候，我们一一遍历，转换成unicode后进行传输，这样的好处是我们可以保证所有平台所能使用的表情统一。在iOS端，可以有另一种方式，通过上面我们知道，通过SBUnicode码我们可以在客户端显示表情符号，并且这个码的排列是十分有规律的，通过这个特点，我们可以通过遍历SBUnicode码的范围进行表情的创建，省去的图片素材的麻烦。 iOS中可用的表情unicode范围是：0xE001~0xE05A,0xE101~0xE15A, 0xE201~0xE253,0xE401~0xE44C,0xE501~0xE537。 我们可以通过遍历的方法，将其都加入数据源数组中： 1234567891011int emojiRangeArray[10] = &#123;0xE001,0xE05A,0xE101,0xE15A,0xE201,0xE253,0xE401,0xE44C,0xE501,0xE537&#125;; for (int j = 0 ; j&lt;10 ; j+=2 ) &#123; int startIndex = emojiRangeArray[j]; int endIndex = emojiRangeArray[j+1]; for (int i = startIndex ; i&lt;= endIndex ; i++ ) &#123; //添加到数据源数组 [dataArray addObject:[NSString stringWithFormat:@&quot;%C&quot;, (unichar)i]]; &#125; &#125; 键盘的摆放，可以通过collectionView来做，十分方便： 1234567891011121314151617181920212223242526 //为了摆放分页控制器，创建一个背景view bgView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 200)]; //分页控制器 pageControlBottom = [[UIPageControl alloc]initWithFrame:CGRectMake(0, 170, [UIScreen mainScreen].bounds.size.width, 20)]; [bgView addSubview:pageControlBottom]; //collectionView布局 UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; //水平布局 layout.scrollDirection=UICollectionViewScrollDirectionHorizontal; //设置每个表情按钮的大小为30*30 layout.itemSize=CGSizeMake(30, 30); //计算每个分区的左右边距 float xOffset = (kscreenWidth-7*30-10*6)/2; //设置分区的内容偏移 layout.sectionInset=UIEdgeInsetsMake(10, xOffset, 10, xOffset); scrollView = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, 160) collectionViewLayout:layout]; //打开分页效果 scrollView.pagingEnabled = YES; //设置行列间距 layout.minimumLineSpacing=10; layout.minimumInteritemSpacing=5; scrollView.delegate=self; scrollView.dataSource=self; scrollView.backgroundColor = bgView.backgroundColor; [bgView addSubview:scrollView]; 在collectionView的回调方法中，处理如下： 1234567891011121314151617181920212223242526272829303132333435363738//每页28个表情-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; if (((dataArray.count/28)+(dataArray.count%28==0?0:1))!=section+1) &#123; return 28; &#125;else&#123; return dataArray.count-28*((dataArray.count/28)+(dataArray.count%28==0?0:1)-1); &#125; &#125;//返回页数-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return (dataArray.count/28)+(dataArray.count%28==0?0:1);&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;biaoqing&quot; forIndexPath:indexPath]; for (int i=cell.contentView.subviews.count; i&gt;0; i--) &#123; [cell.contentView.subviews[i-1] removeFromSuperview]; &#125; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; label.font = [UIFont systemFontOfSize:25]; label.text =dataArray[indexPath.row+indexPath.section*28] ; [cell.contentView addSubview:label]; return cell;&#125;-(void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath&#123; NSString * str = dataArray[indexPath.section*28+indexPath.row]; //这里手动将表情符号添加到textField上 &#125;//翻页后对分页控制器进行更新-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat contenOffset = scrollView.contentOffset.x; int page = contenOffset/scrollView.frame.size.width+((int)contenOffset%(int)scrollView.frame.size.width==0?0:1); pageControlBottom.currentPage = page;&#125; 三、切换系统键盘和自定义的表情键盘UITextField和UITextView都会有下面这个属性和方法： 12@property (nullable, readwrite, strong) UIView *inputView; - (void)reloadInputViews; inputView我们可以设置textView和textField成为第一响应时的弹出附件，如果我们不设置或者设置为nil，则会弹出系统键盘，reloadInputView方法可以使我们刷新这个附件视图，通过这两个，我们可以非常轻松的实现键盘的切换，比如我们在一个出发方法中如下处理： 1234567891011121314151617-(void)imageViewTap&#123; if (![_publishContent isFirstResponder]) &#123; return; &#125; if (isEmoji==NO) &#123; isEmoji=YES; //呼出表情 _textView.inputView=bgView; [_textView reloadInputViews]; &#125;else&#123; isEmoji=NO; _textView.inputView=nil; [_textView reloadInputViews]; &#125; &#125; 效果如下： 追注：测试上面的SBUnicode码在模拟器上可以正常显示，真机并不能识别，可以通过将表情符全部添加到一个plist文件中，通过文件读取来创建键盘的方式进行真机上的开发。plist文件地址如下： http://pan.baidu.com/s/1o6AdkBw 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列四——导航控制器UINavigationController","slug":"151iOS开发UINavigation系列四——导航控制器UINavigationController","date":"2015-11-09T16:00:00.000Z","updated":"2021-07-05T07:57:48.864Z","comments":true,"path":"2015/11/10/151iOS开发UINavigation系列四——导航控制器UINavigationController/","link":"","permalink":"http://huishao.cc/2015/11/10/151iOS开发UINavigation系列四——导航控制器UINavigationController/","excerpt":"","text":"iOS开发UINavigation系列四——导航控制器UINavigationController一、引言在前面的博客中，我么你介绍了UINavigationBar，UINavigationItem和UIToolBar，UINavigationController是将这些控件和UIViewController紧密的结合了起来，使用导航，我们的应用程序层次会更加分明，对controller的管理也更加方便。前几篇博客地址如下： UINavigationBar：http://my.oschina.net/u/2340880/blog/527706 UINavigationItem：http://my.oschina.net/u/2340880/blog/527781 UIToolBar：http://my.oschina.net/u/2340880/blog/528168 二、导航控制器的创建和controller的管理导航控制器是一个堆栈结构，只是其中管理的对象是controller，通过push与pop进行controller的切换，我们有两种方式可以创建导航控制器： 1234//通过一个自定义的导航栏和工具栏创建导航控制器- (instancetype)initWithNavigationBarClass:(nullable Class)navigationBarClass toolbarClass:(nullable Class)toolbarClass;//使用系统默认的导航栏和工具栏，通过一个根视图创建导航控制器- (instancetype)initWithRootViewController:(UIViewController *)rootViewController; 通过以下方法对视图控制器进行管理操作： 12345678910//设置管理的视图控制器- (void)setViewControllers:(NSArray&lt;UIViewController *&gt; *)viewControllers animated:(BOOL)animated;//压入新的视图控制器- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;//弹出一个视图控制器 返回的是pop的controller- (nullable UIViewController *)popViewControllerAnimated:(BOOL)animated;//弹出到某个视图控制器 返回所有pop的controller- (nullable NSArray&lt;__kindof UIViewController *&gt; *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated; //直接pop到根视图控制器，返回所有被pop的controller- (nullable NSArray&lt;__kindof UIViewController *&gt; *)popToRootViewControllerAnimated:(BOOL)animated; 三、导航控制器中的常用方法和属性1234//返回栈顶的controller@property(nullable, nonatomic,readonly,strong) UIViewController *topViewController; //返回显示的controller@property(nullable, nonatomic,readonly,strong) UIViewController *visibleViewController; 上面两个方法的区别在于，topViewController是返回被push出的最后一个controller，但是如果之后又有present进行莫泰跳转，visibleViewController会返回当前显示的controller。例如A-push-B-present-C，则topViewController会返回B，visibleViewController会返回C。 123456789101112131415//返回堆栈中所有的controller@property(nonatomic,copy) NSArray&lt;__kindof UIViewController *&gt; *viewControllers;//设置隐藏导航栏@property(nonatomic,getter=isNavigationBarHidden) BOOL navigationBarHidden;- (void)setNavigationBarHidden:(BOOL)hidden animated:(BOOL)animated;//导航栏对象，只读属性@property(nonatomic,readonly) UINavigationBar *navigationBar;//隐藏状态栏@property(nonatomic,getter=isToolbarHidden) BOOL toolbarHidden NS_AVAILABLE_IOS(3_0);- (void)setToolbarHidden:(BOOL)hidden animated:(BOOL)animated;//状态栏对象@property(null_resettable,nonatomic,readonly) UIToolbar *toolbar;//导航中的返回手势对象//iOS7之后，在导航中右划会进行pop操作，设置这个的enable可以控制设置手势是否失效@property(nullable, nonatomic, readonly) UIGestureRecognizer *interactivePopGestureRecognizer; 四、iOS8后导航的新特性1234567891011121314//这个方法是为了iOS方法的命名统一，在导航中，其作用和push一样- (void)showViewController:(UIViewController *)vc sender:(nullable id)sender;//弹出键盘的时候隐藏导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsWhenKeyboardAppears;//屏幕滑动的时候隐藏导航栏，常用于tableView,上滑隐藏导航栏，下滑显示，带动画效果@property (nonatomic, readwrite, assign) BOOL hidesBarsOnSwipe;//滑动隐藏导航栏的手势@property (nonatomic, readonly, strong) UIPanGestureRecognizer *barHideOnSwipeGestureRecognizer;//横屏的时候隐藏导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsWhenVerticallyCompact;//敲击屏幕可以隐藏与显示导航栏@property (nonatomic, readwrite, assign) BOOL hidesBarsOnTap;//敲击屏幕的手势@property (nonatomic, readonly, assign) UITapGestureRecognizer *barHideOnTapGestureRecognizer; iOS8中增加的这些方法，不得不说着实在用户体验生进了一大步，从中也可以看出apple对于用户体验度的用心。 五、UINavigationDelegate导航控制器还提供了一些代理回调方法，如下： 1234567891011//视图将要展示时调用的方法- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated;//视图已经展示时调用的方法- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated;//设置方法设置导航控制器支持的设备方向- (UIInterfaceOrientationMask)navigationControllerSupportedInterfaceOrientations:(UINavigationController *)navigationController NS_AVAILABLE_IOS(7_0);//这个方法设置导航控制器的首选设备方向- (UIInterfaceOrientation)navigationControllerPreferredInterfaceOrientationForPresentation:(UINavigationController *)navigationController NS_AVAILABLE_IOS(7_0);//下面两个方法可以对导航的转场动画进行设置- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController;- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC ; 六、与UIViewController相关当一个controller被添加到导航中后，系统会为它分配一些属性，如下： 123456//当前controller对应的导航项@property(nonatomic,readonly,strong) UINavigationItem *navigationItem;//push的时候隐藏底部栏，如push后隐藏tabbar@property(nonatomic) BOOL hidesBottomBarWhenPushed;//管理它的导航控制器@property(nullable, nonatomic,readonly,strong) UINavigationController *navigationController; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列三——工具栏UIToolBar","slug":"150iOS开发UINavigation系列三——工具栏UIToolBar","date":"2015-11-08T16:00:00.000Z","updated":"2021-07-05T07:56:21.743Z","comments":true,"path":"2015/11/09/150iOS开发UINavigation系列三——工具栏UIToolBar/","link":"","permalink":"http://huishao.cc/2015/11/09/150iOS开发UINavigation系列三——工具栏UIToolBar/","excerpt":"","text":"iOS开发UINavigation系列三——工具栏UIToolBariOS中除了UINavinationBar之外，还有工具栏UIToolBar可以供我们使用，工具栏和导航栏十分类似，只是功能更加简单，工具栏中也有UIBarButtonItem按钮，在前两篇博客中，对导航栏和导航项都进行的讨论，地址如下： UINavigationBar：http://my.oschina.net/u/2340880/blog/527706 UINavigationItem:http://my.oschina.net/u/2340880/blog/527781 导航栏一般会出现在视图的头部，与之相对，工具栏一般会出现在视图的的底部，上面可以填充一些按钮，提供给用户一些操作。创建一个工具栏如下： 123 self.view.backgroundColor = [UIColor grayColor]; UIToolbar * tool = [[UIToolbar alloc]initWithFrame:CGRectMake(0, self.view.frame.size.height-40, 320, 40)]; [self.view addSubview:tool]; 下面是UIToolBar中的一些方法，其中大部分在UINavigationBar中都有涉及，这里只做简单的介绍： 1234567891011121314151617//工具栏的风格，和导航栏类似，有黑白两种@property(nonatomic) UIBarStyle barStyle; //设置工具栏上按钮数组@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *items; //设置工具栏是否透明@property(nonatomic,assign,getter=isTranslucent) BOOL translucent; //设置工具栏按钮- (void)setItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated; //设置item风格颜色@property(null_resettable, nonatomic,strong) UIColor *tintColor;//设置工具栏背景色@property(nullable, nonatomic,strong) UIColor *barTintColor;//设置工具栏背景和阴影图案- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;- (nullable UIImage *)backgroundImageForToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;- (void)setShadowImage:(nullable UIImage *)shadowImage forToolbarPosition:(UIBarPosition)topOrBottom;- (nullable UIImage *)shadowImageForToolbarPosition:(UIBarPosition)topOrBottom; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列一——导航栏UINavigtionBar","slug":"148iOS开发UINavigation系列一——导航栏UINavigtionBar","date":"2015-11-07T16:00:00.000Z","updated":"2021-07-05T07:53:24.699Z","comments":true,"path":"2015/11/08/148iOS开发UINavigation系列一——导航栏UINavigtionBar/","link":"","permalink":"http://huishao.cc/2015/11/08/148iOS开发UINavigation系列一——导航栏UINavigtionBar/","excerpt":"","text":"iOS开发UINavigation系列一——导航栏UINavigtionBar一、导航栏的使用在iOS开发中，我们通常会使用导航控制器，导航控制器中封装了一个UINavigationBar，实际上，我们也可以在不使用导航控制器的前提下，单独使用导航栏，在UINavigationBar中，也有许多我们可以定制的属性，用起来十分方便。 二、UINavigationBar的创建和风格类型导航栏继承于UIView，所以我们可以像创建普通视图那样创建导航栏，比如我们创建一个高度为80的导航栏，将其放在ViewController的头部，代码如下： 12UINavigationBar *bar = [[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 80)];[self.view addSubview:bar]; 效果如下： 我们也可以设置导航栏的风格属性，从iOS6之后，UINavigationBar默认为半透明的样式，从上面也可以看出，白色的导航栏下面透出些许背景的红色。导航栏的风格属性可以通过下面的属性来设置： 1@property(nonatomic,assign) UIBarStyle barStyle; UIBarStyle是一个枚举，其中大部分的样式都已弃用，有效果的只有如下两个： 1234typedef NS_ENUM(NSInteger, UIBarStyle) &#123; UIBarStyleDefault = 0,//默认 UIBarStyleBlack = 1,//黑色&#125; 默认的风格就是我们上面看到的白色的风格，黑色的风格效果瑞如下： 三、导航栏常用属性和方法从上面我们可以看到，iOS6后导航栏默认都是半透明的，我们可以通过下面的bool值来设置这个属性，设置为NO，则导航栏不透明，默认为YES： 1@property(nonatomic,assign,getter=isTranslucent) BOOL translucent; 下面一些方法用于设置NavigationBar及上面item的颜色相关属性： 1@property(null_resettable, nonatomic,strong) UIColor *tintColor; tintColor这个属性会影响到导航栏上左侧pop按钮的图案颜色和字体颜色，系统默认是如下颜色： 1@property(nullable, nonatomic,strong) UIColor *barTintColor; BarTintColor用于设置导航栏的背景色，这个属性被设置后，半透明的效果将失效： 12- (void)setBackgroundImage:(nullable UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;- (nullable UIImage *)backgroundImageForBarMetrics:(UIBarMetrics)barMetrics; 上面两个方法用于设置和获取导航栏的背景图案，这里需要注意，默认背景图案是不做缩放处理的，所以我们使用的图片尺寸要和导航栏尺寸匹配，这里面还有一个UIBarMetrics参数，这个参数设置设备的状态，如下： 1234typedef NS_ENUM(NSInteger, UIBarMetrics) &#123; UIBarMetricsDefault,//正常竖屏状态 UIBarMetricsCompact,//横屏状态&#125;; 1234//设置导航栏的阴影图片@property(nullable, nonatomic,strong) UIImage *shadowImage;//设置导航栏的标题字体属性@property(nullable,nonatomic,copy) NSDictionary&lt;NSString *,id&gt; *titleTextAttributes; 标题字体属性会影响到导航栏的中间标题，如下： 1 bar.titleTextAttributes = @&#123;NSForegroundColorAttributeName:[UIColor redColor]&#125;; 我们也可以通过下面的属性设置导航栏标题的竖直位置偏移： 12- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics;- (CGFloat)titleVerticalPositionAdjustmentForBarMetrics:(UIBarMetrics)barMetrics; 还有一个细节，导航栏左侧pop按钮的图案默认是一个箭头，我们可以使用下面的方法修改： 12@property(nullable,nonatomic,strong) UIImage *backIndicatorImage;@property(nullable,nonatomic,strong) UIImage *backIndicatorTransitionMaskImage; 四、导航栏中item的push与pop操作UINavigationBar上面不只是简单的显示标题，它也将标题进行了堆栈的管理，每一个标题抽象为的对象在iOS系统中是UINavigationItem对象，我们可以通过push与pop操作管理item组。 123456789101112//向栈中添加一个item，上一个item会被推向导航栏的左侧，变为pop按钮，会有一个动画效果- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;//pop一个item- (nullable UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; //当前push到最上层的item@property(nullable, nonatomic,readonly,strong) UINavigationItem *topItem;//仅次于最上层的item，一般式被推向导航栏左侧的item@property(nullable, nonatomic,readonly,strong) UINavigationItem *backItem;//获取堆栈中所有item的数组@property(nullable,nonatomic,copy) NSArray&lt;UINavigationItem *&gt; *items;//设置一组item- (void)setItems:(nullable NSArray&lt;UINavigationItem *&gt; *)items animated:(BOOL)animated; 五、UINavigationBarDelegate在UINavigationBar中，还有如下一个属性： 1@property(nullable,nonatomic,weak) id&lt;UINavigationBarDelegate&gt; delegate; 通过代理，我们可以监控导航栏的一些push与pop操作： 12345678//item将要push的时候调用，返回NO，则不能push- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item; //item已经push后调用- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item; //item将要pop时调用，返回NO，不能pop - (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item; //item已经pop后调用 - (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UINavigation系列二——UINavigationItem","slug":"149iOS开发UINavigation系列二——UINavigationItem","date":"2015-11-07T16:00:00.000Z","updated":"2021-07-05T07:54:50.311Z","comments":true,"path":"2015/11/08/149iOS开发UINavigation系列二——UINavigationItem/","link":"","permalink":"http://huishao.cc/2015/11/08/149iOS开发UINavigation系列二——UINavigationItem/","excerpt":"","text":"iOS开发UINavigation系列二——UINavigationItem一、引言UINavigationItem是导航栏上用于管理导航项的类，在上一篇博客中，我们知道导航栏是通过push与pop的堆栈操作来对item进行管理的，同样，每一个Item自身也有许多属性可供我们进行自定制。这篇博客，主要讨论UINavigationItem的使用方法。 UINavigationBar：http://my.oschina.net/u/2340880/blog/527706。 二、来说说UINavigationItemItem，从英文上来理解，它可以解释为一个项目，因此，item不是一个简单的label标题，也不是一个简单的button按钮，它是导航栏中管理的一个项目的抽象。说起来有些难于理解，通过代码，我们就能很好的理解Item的意义。 首先，我们创建一个item，用UINavigationBar导航栏push出来： 123 UINavigationItem * item = [[UINavigationItem alloc]initWithTitle:@&quot;title&quot;]; UINavigationBar * bar = [[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 64)]; [bar pushNavigationItem:item animated:YES]; 我们可以看到，在导航栏上的中间，有title这样一个item： 除了创建一个标题item，我们也可以创建一个View类型的item： 123 UIView * view = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; view.backgroundColor = [UIColor brownColor]; item.titleView = view; 效果如下： 通过下面的属性，可以给这个Item添加一个说明文字，这段文字会显示在item的上方： 1item.prompt= @&quot;我是navigationItem的说明文字&quot;; 上面我们看到的这些，实际上只是一个item的一部分，item还有许多其他的附件，如果我们使导航栏再push出一个item，这时导航栏的左边会出现一个返回按钮，这个返回按钮实际上是数据第一个item的，我们做如下的设置： 12345 UINavigationItem * item = [[UINavigationItem alloc]initWithTitle:@&quot;title&quot;]; UINavigationItem * item2 = [[UINavigationItem alloc]initWithTitle:@&quot;title2&quot;]; item.backBarButtonItem = [[UIBarButtonItem alloc]initWithTitle:@&quot;title1&quot; style:nil target:nil action:nil]; [bar pushNavigationItem:item animated:YES]; [bar pushNavigationItem:item2 animated:YES]; 可以看出，虽然当前push出来的item是item2，但是左边的返回按钮是属于item的。这里有一点需要注意，虽然backBarButtonItem的标题我们可以自定义，但是方法和其他属性我们都不能定制，是系统实现好的。 当然，我们也可以设置在push出来新的item的时候，隐藏前面的返回按钮，使用如下属性： 12@property(nonatomic,assign) BOOL hidesBackButton;- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated; 默认为NO，设置为YES将会隐藏返回按钮。 三、关于UIBarButtonItem一个UINavigationItem中，还可以包含许多BarButtonItem，BarButtonItem是一系列的按钮，会出现在导航栏的左侧或者右侧。例如： 12 UIBarButtonItem * button = [[UIBarButtonItem alloc]initWithTitle:@&quot;按钮&quot; style:UIBarButtonItemStyleDone target:self action:@selector(click)]; item.leftBarButtonItem = button; 这个barButtonItem是一个按钮，可以触发一个方法，这有时候对我们来说十分有用。但是有一个你一定发现了，如果继续push出来Item，原来的返回按钮不见了，是否隐藏返回按钮，由下面这个属性控制： 1item.leftItemsSupplementBackButton=YES; 我们也可以通过下面的方法设置右边的按钮，或者直接设置一组按钮： 123456789@property(nullable, nonatomic,strong) UIBarButtonItem *leftBarButtonItem;@property(nullable, nonatomic,strong) UIBarButtonItem *rightBarButtonItem;- (void)setLeftBarButtonItem:(nullable UIBarButtonItem *)item animated:(BOOL)animated;- (void)setRightBarButtonItem:(nullable UIBarButtonItem *)item animated:(BOOL)animated;@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *leftBarButtonItems;@property(nullable,nonatomic,copy) NSArray&lt;UIBarButtonItem *&gt; *rightBarButtonItems;- (void)setLeftBarButtonItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated;- (void)setRightBarButtonItems:(nullable NSArray&lt;UIBarButtonItem *&gt; *)items animated:(BOOL)animated; 四、再看UIBarButtonItem上面我们了解到了，一个NavigationItem基本上是有三大部分组成的，当前显示的部分，返回按钮部分，和ButtonItem部分，同样对于创建和设置UIBarButoonItem，也有很多方法供我们使用。 首先是创建与初始化的方法： 1- (instancetype)initWithTitle:(nullable NSString *)title style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action; 这个方法通过一个标题创建ButtonItem，其中style参数可以设置一个风格，枚举如下： 1234typedef NS_ENUM(NSInteger, UIBarButtonItemStyle) &#123; UIBarButtonItemStylePlain, UIBarButtonItemStyleDone,&#125;; 这两种风格差别并不大，如下是效果，Done风格的字体加粗一些： 我们因为可以通过一个图片来创建BarButtonItem： 12- (instancetype)initWithImage:(nullable UIImage *)image style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action;- (instancetype)initWithImage:(nullable UIImage *)image landscapeImagePhone:(nullable UIImage *)landscapeImagePhone style:(UIBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action; 上面这两个方法中，第一个方法与使用文字创建的方法类似，第二个方法多了一个landscapeImagePhone的参数，这个参数可以设置设备横屏时的图片。 我们也可以使用自定义的View来创建BarButtonItem： 1- (instancetype)initWithCustomView:(UIView *)customView; 除了上面一些自定义的创建方法外，对于BarButtonItem这个对象，系统也封装好了许多原生的可以供我们使用，创建的时候使用如下方法： 1UIBarButtonItem * button = [[UIBarButtonItem alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemCamera target:self action:nil]; 上面的SystemItem是系统为我们做好的许多buttonItem的类型，枚举如下： 1234567891011121314151617181920212223242526typedef NS_ENUM(NSInteger, UIBarButtonSystemItem) &#123; UIBarButtonSystemItemDone,//显示完成 UIBarButtonSystemItemCancel,//显示取消 UIBarButtonSystemItemEdit, //显示编辑 UIBarButtonSystemItemSave, //显示保存 UIBarButtonSystemItemAdd,//显示加号 UIBarButtonSystemItemFlexibleSpace,//什么都不显示，占位一个空间位置 UIBarButtonSystemItemFixedSpace,//和上一个类似 UIBarButtonSystemItemCompose,//显示写入按钮 UIBarButtonSystemItemReply,//显示循环按钮 UIBarButtonSystemItemAction,//显示活动按钮 UIBarButtonSystemItemOrganize,//显示组合按钮 UIBarButtonSystemItemBookmarks,//显示图书按钮 UIBarButtonSystemItemSearch,//显示查找按钮 UIBarButtonSystemItemRefresh,//显示刷新按钮 UIBarButtonSystemItemStop,//显示停止按钮 UIBarButtonSystemItemCamera,//显示相机按钮 UIBarButtonSystemItemTrash,//显示移除按钮 UIBarButtonSystemItemPlay,//显示播放按钮 UIBarButtonSystemItemPause,//显示暂停按钮 UIBarButtonSystemItemRewind,//显示退后按钮 UIBarButtonSystemItemFastForward,//显示前进按钮 UIBarButtonSystemItemUndo,//显示消除按钮 UIBarButtonSystemItemRedo ,//显示重做按钮 UIBarButtonSystemItemPageCurl ,//在tool上有效&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用","slug":"147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用","date":"2015-11-05T16:00:00.000Z","updated":"2021-07-05T07:49:46.146Z","comments":true,"path":"2015/11/06/147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用/","link":"","permalink":"http://huishao.cc/2015/11/06/147iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用/","excerpt":"","text":"iOS开发中的手势体系——UIGestureRecognizer分析及其子类的使用一、引言在iOS系统中，手势是进行用户交互的重要方式，通过UIGestureRecognizer类，我们可以轻松的创建出各种手势应用于app中。关于UIGestureRecognizer类，是对iOS中的事件传递机制面向应用的封装，将手势消息的传递抽象为了对象。有关消息传递的一些讨论，在前面的博客中有提到： iOS事件响应控制：http://my.oschina.net/u/2340880/blog/396161。 二、手势的抽象类——UIGestureRecognizerUIGestureRecognizer将一些和手势操作相关的方法抽象了出来，但它本身并不实现什么手势，因此，在开发中，我们一般不会直接使用UIGestureRecognizer的对象，而是通过其子类进行实例化，iOS系统给我们提供了许多用于我们实例的子类，这些我们后面再说，我们先来看一下，UIGestureRecognizer中抽象出了哪些方法。 1、统一的初始化方法UIGestureRecognizer类为其子类准备好了一个统一的初始化方法，无论什么样的手势动作，其执行的结果都是一样的：触发一个方法，可以使用下面的方法进行统一的初始化： 1- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action; 当然，如果我们使用alloc-init的方式，也是可以的，下面的方法可以为手势添加触发的selector： 1- (void)addTarget:(id)target action:(SEL)action; 与之相对应的，我们也可以将一个selector从其手势对象上移除： 1- (void)removeTarget:(nullable id)target action:(nullable SEL)action; 上面两个方法是十分有意思的，因为addTarget方式的存在，iOS系统允许一个手势对象可以添加多个selector触发方法，并且触发的时候，所有添加的selector都会被执行，我们以点击手势示例如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)]; [ges addTarget:self action:@selector(haha)]; [self.view addGestureRecognizer:ges];&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;); &#125;-(void)haha&#123; NSLog(@&quot;haha&quot;);&#125; 运行后点击屏幕，打印如下，说明两个方法都触发了： 2、手势状态UIgestureRecognizer类中有如下一个属性，里面枚举了一些手势的当前状态: 1@property(nonatomic,readonly) UIGestureRecognizerState state; 枚举值如下： 123456789typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; UIGestureRecognizerStatePossible, // 默认的状态，这个时候的手势并没有具体的情形状态 UIGestureRecognizerStateBegan, // 手势开始被识别的状态 UIGestureRecognizerStateChanged, // 手势识别发生改变的状态 UIGestureRecognizerStateEnded, // 手势识别结束，将会执行触发的方法 UIGestureRecognizerStateCancelled, // 手势识别取消 UIGestureRecognizerStateFailed, // 识别失败，方法将不会被调用 UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded &#125;; 3、常用属性和方法123456789101112//设置代理，具体的协议后面会说@property(nullable,nonatomic,weak) id &lt;UIGestureRecognizerDelegate&gt; delegate; //设置手势是否有效@property(nonatomic, getter=isEnabled) BOOL enabled;//获取手势所在的view@property(nullable, nonatomic,readonly) UIView *view; //获取触发触摸的点- (CGPoint)locationInView:(nullable UIView*)view; //设置触摸点数- (NSUInteger)numberOfTouches; //获取某一个触摸点的触摸位置- (CGPoint)locationOfTouch:(NSUInteger)touchIndex inView:(nullable UIView*)view; 下面的几个BOOL值的属性，对于手势触发的控制也十分重要： （1）1@property(nonatomic) BOOL cancelsTouchesInView; 上面的属性默认为YES，当这个属性设置为YES时，如果识别到了手势，系统将会发送touchesCancelled:withEvent:消息在其时间传递链上，终止触摸事件的传递，设置为NO，则不会终止事件的传递，举个例子来说，可能会更加清楚一些如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; UIPanGestureRecognizer * ges = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];; [self.view addGestureRecognizer:ges]; ges.cancelsTouchesInView=NO;&#125;-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;123&quot;);&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;);&#125; 上面我们使用了拖拽手势和touchesMoved两个触发方式，当我们把cancelTouchesInView设置为NO时，在屏幕上滑动，会发现两种方式都在触发，打印如下： 如果我们将cancelTouchesInView改为YES，当手势触发时，将取消触摸消息的触发： （2）1@property(nonatomic) BOOL delaysTouchesBegan; 通过上面的例子，我们知道，在一个手势触发之前，是会一并发消息给事件传递链的，delaysTouchesBgan属性用于控制这个消息的传递时机，默认这个属性为NO，此时在触摸开始的时候，就会发消息给事件传递链，如果我们设置为YES，在触摸没有被识别失败前，都不会给事件传递链发送消息。 （3）1@property(nonatomic) BOOL delaysTouchesEnded; 这个属性设置手势识别结束后，是立刻发送touchesEnded消息到事件传递链或者等待一个很短的时间后，如果没有接收到新的手势识别任务，再发送。 4、手势间的互斥处理有一点需要注意，同一个View上是可以添加多个手势对象的，默认这个手势是互斥的，一个手势触发了就会默认屏蔽其他相似的手势动作，例如： 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UITapGestureRecognizer * ges = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click:)];; //view.backgroundColor = [UIColor redColor]; //ges.delegate=self; [self.view addGestureRecognizer:ges]; UITapGestureRecognizer * ges2 = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(click1:)];// ges2.delegate=self; [self.view addGestureRecognizer:ges2];&#125;-(void)click:(UIGestureRecognizer *)ges&#123; NSLog(@&quot;第一个手势的触发方法&quot;); &#125;-(void)click1:(UIGestureRecognizer *)ges1&#123; NSLog(@&quot;第二个手势的触发方法&quot;); &#125; 我们添加的两个手势都是单机手势，会产生冲突，触发是很随机的，如果我们想设置一下当手势互斥时要优先触发的手势，可以使用如下的方法： 1- (void)requireGestureRecognizerToFail:(UIGestureRecognizer *)otherGestureRecognizer; 这个方法中第一个参数是需要时效的手势，第二个是生效的手势。 三、UIGestureRecognizerDelegate前面我们提到过关于手势对象的协议代理，通过代理的回调，我们可以进行自定义手势，也可以处理一些复杂的手势关系，其中方法如下： 1234567891011//手指触摸屏幕后回调的方法，返回NO则不再进行手势识别，方法触发等- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;//开始进行手势识别时调用的方法，返回NO则结束，不再触发手势- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;//是否支持多时候触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;//下面这个两个方法也是用来控制手势的互斥执行的//这个方法返回YES，第一个手势和第二个互斥时，第一个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);//这个方法返回YES，第一个和第二个互斥时，第二个会失效- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0); 四、点击手势——UITapGestureRecognizer点击手势十分简单，支持单击和多次点击，在我们手指触摸屏幕并抬起手指时会进行触发，其中有如下两个属性我们可以进行设置： 1234//设置点击次数，默认为单击@property (nonatomic) NSUInteger numberOfTapsRequired; //设置同时点击的手指数@property (nonatomic) NSUInteger numberOfTouchesRequired; 五、捏合手势——UIPinchGestureRecognizer捏合手势是当我们双指捏合和扩张会触发动作的手势，我们可以设置的属性如下： 1234//设置缩放比例@property (nonatomic) CGFloat scale; //设置捏合速度@property (nonatomic,readonly) CGFloat velocity; 六、拖拽手势——UIPanGestureRecognzer当我们点中视图进行慢速拖拽时会触发拖拽手势的方法。 12345678910//设置触发拖拽的最少触摸点，默认为1@property (nonatomic) NSUInteger minimumNumberOfTouches; //设置触发拖拽的最多触摸点@property (nonatomic) NSUInteger maximumNumberOfTouches; //获取当前位置- (CGPoint)translationInView:(nullable UIView *)view; //设置当前位置- (void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;//设置拖拽速度- (CGPoint)velocityInView:(nullable UIView *)view; 七、滑动手势——UISwipeGestureRecognizer滑动手势和拖拽手势的不同之处在于滑动手势更快，拖拽比较慢。 1234567891011//设置触发滑动手势的触摸点数@property(nonatomic) NSUInteger numberOfTouchesRequired; //设置滑动方向@property(nonatomic) UISwipeGestureRecognizerDirection direction; //枚举如下typedef NS_OPTIONS(NSUInteger, UISwipeGestureRecognizerDirection) &#123; UISwipeGestureRecognizerDirectionRight = 1 &lt;&lt; 0, UISwipeGestureRecognizerDirectionLeft = 1 &lt;&lt; 1, UISwipeGestureRecognizerDirectionUp = 1 &lt;&lt; 2, UISwipeGestureRecognizerDirectionDown = 1 &lt;&lt; 3&#125;; 八、旋转手势——UIRotationGestureRecognizer进行旋转动作时触发手势方法。 1234//设置旋转角度@property (nonatomic) CGFloat rotation;//设置旋转速度 @property (nonatomic,readonly) CGFloat velocity; 九、长按手势——UILongPressGestureRecognizer进行长按的时候触发的手势方法。 12345678//设置触发前的点击次数@property (nonatomic) NSUInteger numberOfTapsRequired; //设置触发的触摸点数@property (nonatomic) NSUInteger numberOfTouchesRequired; //设置最短的长按时间@property (nonatomic) CFTimeInterval minimumPressDuration; //设置在按触时时允许移动的最大距离 默认为10像素@property (nonatomic) CGFloat allowableMovement; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中UITableViewController自带的刷新控件","slug":"146iOS中UITableViewController自带的刷新控件","date":"2015-11-04T16:00:00.000Z","updated":"2021-07-05T07:47:23.177Z","comments":true,"path":"2015/11/05/146iOS中UITableViewController自带的刷新控件/","link":"","permalink":"http://huishao.cc/2015/11/05/146iOS中UITableViewController自带的刷新控件/","excerpt":"","text":"iOS中UITableViewController自带的刷新控件一、引言在iOS开发中，使用tableView的界面，大多会用到一个下拉刷新的的控件，第三方库中，我们一般会选择比较好用的MJRefresh，其实，在iOS6之后，系统为我们提供了一个原生的刷新控件，使用起来非常方便，只是制定性不强，如果我们没有复杂的需求，使用UIRefreshControl也是不错的一个选择。 二、UITableViewController相对于UIViewController，UITableViewController只是在内部为我们封装好了一个UITableView，并且遵守好了相关的协议，我们只需要在其中实现方法即可。UITableViewController更多的方面之处是在于下面的这个属性： 1@property (nonatomic) BOOL clearsSelectionOnViewWillAppear; 这是一个bool值，设置为yes后每当当前controller调用ViewWillAppare的时候，都会将cell的选中状态取消，这十分有用，我们在通过点击cell跳转界面后，pop回来不需要在手动修改cell的选中状态了。 除此之后，TableViewController中还封装了这样一个属性： 1@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl; 这个UIRefreshControl类是iOS6之后引入的一个简单的刷新控件，我们如果设置了它，在tableView下拉的时候，系统会提供给我们一个下拉刷新的效果。 三、UIRefreshControl这个类也十分简单，通过简单的设置可以展现一个小巧的刷新效果，但是制定性不强，其中主要属性如下： 1234567891011//获取刷新状态@property (nonatomic, readonly, getter=isRefreshing) BOOL refreshing;//设置控件颜色@property (null_resettable, nonatomic, strong) UIColor *tintColor;//设置控件文字@property (nullable, nonatomic, strong) NSAttributedString *attributedTitle UI_APPEARANCE_SELECTOR;// 手动开始刷新- (void)beginRefreshing NS_AVAILABLE_IOS(6_0);// 结束刷新- (void)endRefreshing NS_AVAILABLE_IOS(6_0); 需要注意的是，UIRefreshControl是继承于UIControl的，下拉唤醒刷新状态后，会触发UIControleEventValueChange事件，我们可以在其中进行刷新的数据逻辑操作。 例如： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; self.refreshControl = [[UIRefreshControl alloc]init]; self.refreshControl.tintColor = [UIColor greenColor]; self.refreshControl.attributedTitle = [[NSAttributedString alloc]initWithString:@&quot;下拉刷新了~~&quot;]; self.clearsSelectionOnViewWillAppear = YES; self.navigationItem.rightBarButtonItem = self.editButtonItem; [self.refreshControl addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged];&#125;-(void)change:(UIRefreshControl*)con&#123; self.refreshControl.attributedTitle = [[NSAttributedString alloc]initWithString:@&quot;开始刷新了~~&quot;];&#125; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之四——使用第三方库Masonry进行autolayout布局","slug":"145iOS界面布局之四——使用第三方库Masonry进行autolayout布局","date":"2015-11-01T16:00:00.000Z","updated":"2021-07-05T07:46:35.018Z","comments":true,"path":"2015/11/02/145iOS界面布局之四——使用第三方库Masonry进行autolayout布局/","link":"","permalink":"http://huishao.cc/2015/11/02/145iOS界面布局之四——使用第三方库Masonry进行autolayout布局/","excerpt":"","text":"iOS界面布局之四——使用第三方库Masonry进行autolayout布局一、引言在前面博客，我们讨论了使用iOS原生的框架代码来进行autolayout布局。在使用中，我们会发现，无论是代码量还是结构的清晰度，都十分不能让我们满意，在storyBoard中只需要几条线就可以搞定的事情，用代码缺要写冗余的一大堆。并且有些时候，故事版并不能解决所有问题，某些控件必须我们手写，这样的话，我们就不得不进行代码的autolayout布局，幸运的是，Masonry可以帮助我们轻松愉快的完成这一任务。 使用代码进行autolayout布局：http://my.oschina.net/u/2340880/blog 。 二、使用Masonry这里说的大部分内容均来自Masonry和官方gitHub，将其内容进行了翻译和解释，源地址如下：[https://github.com/SnapKit/Masonry](https://github.com/SnapKit/Masonry)。 1、布局的控件属性对照无论是用storyBoard还是代码，在设置控件之间layout关系的时候，我们都需要设置控件的位置属性。在下面的方法中，这个位置属性就是NSLayoutAttribute对象，他决定的控件对象的参照位置： 12345+(instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 在Masonry中，有一系列的属性与之成对应关系，对照如下： 2、3个方法让你玩转Masonry约束操作Masonry在UIView的类别中，有3个全局的操作约束的方法，通过他们我们可以自由的进行autolayout的设置。 添加约束： 1- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block; 这个方法用于我们在最开始时为控件设置的约束，在block中进行约束条件的设置，例如我们创建一个label，将其尺寸设置为50*50，放在屏幕中间，使用如下代码： 注意：在添加约束前，必须将视图添加到其父视图上。 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UILabel * label = [[UILabel alloc]init]; [self.view addSubview:label]; [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self.view); make.height.equalTo(@50); make.width.equalTo(@50); &#125;]; label.backgroundColor = [UIColor redColor];&#125; 效果如下： 更新约束： 当我们需要配合布局改变或者动画效果的时候，我们可能需要将已经添加的约束进行更新操作，使用如下的方法： 1234[label mas_updateConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.width.equalTo(@100); &#125;]; 更新约束的作用在于更新已经添加的某些约束，并不会移除掉原有的约束，如果我们需要添加新的约束，可以使用下面的重设约束的方法。 重设约束： 123456[label mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view.mas_left).offset(10); make.top.equalTo(self.view.mas_top).offset(100); make.height.equalTo(@100); make.width.equalTo(@100); &#125;]; 3、约束值相关在添加具体约束的时候，我们不仅可以将约束值设置为绝对的相等关系，也可以设置一些值域的关系，在Masonry中，有如下三种： 123456//绝对相等- (MASConstraint * (^)(id attr))equalTo;//大于等于- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;//小于等于- (MASConstraint * (^)(id attr))lessThanOrEqualTo; 对于约束的优先级，使用如下几个量： 12345678//手动设置一个优先级参数- (MASConstraint * (^)(MASLayoutPriority priority))priority;//优先级低- (MASConstraint * (^)())priorityLow;//优先级中等- (MASConstraint * (^)())priorityMedium;//优先级高- (MASConstraint * (^)())priorityHigh; 写法如下： 123456[label mas_remakeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.view.mas_left).offset(10); make.top.equalTo(self.view.mas_top).offset(100); make.height.equalTo(@100).priority(1000); make.width.equalTo(@100).priorityHigh(); &#125;]; 三、Masonry设置约束的几个示例1、设置视图与其父视图的边距约束12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. label = [[UILabel alloc]init]; [self.view addSubview:label]; [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.view).insets(UIEdgeInsetsMake(20, 20, 20, 20)); &#125;]; label.backgroundColor = [UIColor redColor];&#125; 设置上下左右与其父视图边距为20px，效果如下： 2、约束控件的尺寸为固定值12345[label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@200); make.width.equalTo(@200); make.center.equalTo(self.view); &#125;]; 位置约束设置在了屏幕的中间，效果如下： 3、约束控件之间的尺寸123456789101112 [label mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.width.equalTo(label2); make.right.equalTo(label2.mas_left).offset(-100); make.leading.equalTo(self.view.mas_leading).offset(20); make.centerY.equalTo(self.view); &#125;]; [label2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(@100); make.centerY.equalTo(label); make.trailing.equalTo(self.view.mas_trailing).offset(-20); &#125;]; 设置了两个label宽度一致，相距100px,分别距离左右边距20px，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS对UIViewController生命周期和属性方法的解析","slug":"144iOS对UIViewController生命周期和属性方法的解析","date":"2015-10-31T16:00:00.000Z","updated":"2021-07-05T07:45:25.659Z","comments":true,"path":"2015/11/01/144iOS对UIViewController生命周期和属性方法的解析/","link":"","permalink":"http://huishao.cc/2015/11/01/144iOS对UIViewController生命周期和属性方法的解析/","excerpt":"","text":"iOS对UIViewController生命周期和属性方法的解析一、引言作为MVC设计模式中的C，Controller一直扮演着项目开发中最重要的角色，它是视图和数据的桥梁，通过它的管理，将数据有条有理的展示在我们的View层上。iOS中的UIViewController是UIKit框架中最基本的一个类。从第一个UI视图到复杂完整项目，都离不开UIViewController作为基础。基于UIViewController的封装和扩展，也能够出色的完成各种复杂界面逻辑。这篇博客，旨在讨论UIViewController的生命周期和属性方法，在最基础的东西上，往往会得到意想不到的惊喜。 二、UIViewController的生命周期要了解UIViewController，先要弄清楚其生命周期。在面向对象的语言中，是对象，就一定要有生命周期，UIViewController也不例外，生命周期管理Controller的作用范围和时间，也管理其内对象的作用范围和时间。首先，UIViewController中与其生命周期有关的几个函数如下： 1234567891011121314151617181920212223242526//类的初始化方法+ (void)initialize;//对象初始化方法- (instancetype)init;//从归档初始化- (instancetype)initWithCoder:(NSCoder *)coder;//加载视图-(void)loadView;//将要加载视图- (void)viewDidLoad;//将要布局子视图-(void)viewWillLayoutSubviews;//已经布局子视图-(void)viewDidLayoutSubviews;//内存警告- (void)didReceiveMemoryWarning;//已经展示-(void)viewDidAppear:(BOOL)animated;//将要展示-(void)viewWillAppear:(BOOL)animated;//将要消失-(void)viewWillDisappear:(BOOL)animated;//已经消失-(void)viewDidDisappear:(BOOL)animated;//被释放-(void)dealloc; 上面这么多的函数，乍一看什么复杂，其实关系什么明朗，除了initialize,init和initWithCoder不是存在所有对象的声明周期中，其他函数都会在UIViewController的声明周期中有序的被调用。那么具体的调用顺序是怎样的呢，最好的办法是实践一下，通过编号打印，结果如下： 这是一个ViewController完整的声明周期，其实里面还有好多地方需要我们注意一下： 1：initialize函数并不会每次创建对象都调用，只有在这个类第一次创建对象时才会调用，做一些类的准备工作，再次创建这个类的对象，initalize方法将不会被调用，对于这个类的子类，如果实现了initialize方法，在这个子类第一次创建对象时会调用自己的initalize方法，之后不会调用，如果没有实现，那么它的父类将替它再次调用一下自己的initialize方法，以后创建也都不会再调用。因此，如果我们有一些和这个相关的全局变量，可以在这里进行初始化。 2：init方法和initCoder方法相似，只是被调用的环境不一样，如果用代码进行初始化，会调用init，从nib文件或者归档进行初始化，会调用initCoder。 3：loadView方法是开始加载视图的起始方法，除非手动调用，否则在ViewController的生命周期中没特殊情况只会被调用一次。 4：viewDidLoad方法是我们最常用的方法的，类中成员对象和变量的初始化我们都会放在这个方法中，在类创建后，无论视图的展现或消失，这个方法也是只会在将要布局时调用一次。 5：viewWillAppear：视图将要展现时会调用。 6：viewWillLayoutSubviews：在viewWillAppear后调用，将要对子视图进行布局。 7：viewDidLayoutSubviews：已经布局完成子视图。 8：viewDidAppare：视图完成显示时调用。 9：viewWillDisappear：视图将要消失时调用。 10：viewDidDisappear：视图已经消失时调用。 11：dealloc：controller被释放时调用。 注意：经过测试，从nib文件加载的controller，只要不释放，在每次viewWillAppare时都会调用layoutSubviews方法，有时甚至会在viewDidAppare后在调用一次layoutSubviews，而重点是从代码加载的则只会在开始调用一次，之后都不会，所以注意，在layoutSubviews中写相关的布局代码十分危险。 三、从storyBoard加载UIViewController实例的传值陷阱我们知道，当我们从StoryBoard中加载ViewController时，我们在Controller中拖拽的视图是可以被初始化的，这里面有一点需要我们注意，如果我们需要向controller中视图进行传值设置，通过以下方法得到的Controller中，视图还没有被初始化创建出来： 1 ViewController2 * viewController2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:@&quot;ViewController2&quot;]; 我们可以在ViewController2的storyBoard中拉一个label，然后关联到头文件中，如下打印，会发现我们得到controller时，里面的视图对象并没有进行创建: 123ViewController2 * viewController2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:@&quot;ViewController2&quot;]; NSLog(@&quot;%@&quot;,viewController2.label); [self presentViewController:viewController2 animated:YES completion:nil]; 打印如下： 可以想象，如果我们这时候需要对label进行一些属性设置，必然失败。有人提出可以在创建后，手动调以下loadView方法，我们试一下，结果如下： 可以看到，手动调用loadView后，label是被创建了出来，但是暴漏了一个更严重的问题，系统不在调用ViewDidLoad方法，这是十分有风险的，因为我们大部分的初始化代码都会放在这个方法里，所以手动调用loadView是一种错误的方法，apple文档声明对于loadView方法，我们从来都不要手动直接调用，那么我们如何实现创建后对成员对象进行传值设置呢，iOS9中增加了这样一个方法： 1- (void)loadViewIfNeeded NS_AVAILABLE_IOS(9_0); 这个方法十分有用，调用这个方法，会将视图创建出来，并且不会忽略viewDidLoad的调用。 在iOS9中，UIViewController还增加了下面一个布尔值的属性，可以同来判断controller的view是否已经加载完成： 1@property(nullable, nonatomic, readonly, strong) UIView *viewIfLoaded NS_AVAILABLE_IOS(9_0); 四、UIViewController与StroyBoard的相关相互方法对于ViewConroller，我们一般有两种方式创建，一种是用纯代码的方式，一种是与StoryBoard关联，在UIViewController中，有许多方法方便我们与StoryBoard进行交互联系。 1、ViewController直接在StoryBoard中进行跳转的传值在StoryBoard中进行界面跳转是十分方便的，我们在StoryBoard中拉入两个ViewController，在一个上面添加一个按钮，点住按钮按住control，将鼠标拉到第二个controller上，会出现如下的跳转选项： 我们选择一个后，就会在两个controller之间建立一个跳转连接。当我们运行点击按钮后，会自动从第一个controller跳转到第二个controller。在UIViewController中有如下方法可以对是否跳转进行控制： 1- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(6_0); 这个方法如果返回NO，自动跳转将不能进行，会被拒绝，需要注意的是，这个方法只会在自动的跳转时被调用，我们手动使用代码跳转StoryBoard中的连接关系时是不会被调用的，我们后面讨论。 在执行过上述方法后，如果返回YES，系统还会在执行如下一个方法，作为跳转前的准备，我们可以在这个方法中进行一些传值操作，这个方法无论使我们手动进行跳转还是storyboard中自动跳转，都会被执行： 1- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(nullable id)sender NS_AVAILABLE_IOS(5_0); sugur对象中封装了相关的ViewController，可以使用segue.destinationViewController获取。 segue在StoryBoard中除了用来自动正向跳转外，我们还可以进行反向的跳转，类似pop和dismiss方法，这种segue被称为unwind sugue。例如，我们有一个controller1和一个controllert2，要使用unwind segue从2返回1，我们需要在2中实现如下格式的方法： 123- (IBAction)unwindSegueToViewController:(UIStoryboardSegue *)segue &#123; NSLog(@&quot;unwindSegueToViewController&quot;);&#125; 这个方法中的返回值必须为IBAction，参数必须是UIStoryboardSegue，方法名我们可以自己定义，之后在StoryBoard中的ViewController1中的Exit选项中，我们会发现多了一个这样的方法： 我们可以把它连接到viewController2中的一个按钮上： 这样，当我们点击viewController2中的按钮时，就会返回到我们第一个ViewController1中了。 当然，在使用unwind segue方法时，也是会有一些回调帮助我们进行跳转前的设置和传值，UIViewController如下方法会在跳转前调用，返回NO，则不能进行跳转： 1234-(BOOL)canPerformUnwindSegueAction:(SEL)action fromViewController:(UIViewController *)fromViewController withSender:(id)sender&#123; NSLog(@&quot;canPerformUnwindSegueAction&quot;); return YES;&#125; 之后会执行我们自定义的unwindSegue方法，这个方法中我们可以什么都不写，模式是会进行跳转的。 2、使用代码跳转Storyboard中的controller我们除了在Storyboard中拉拉扯扯可以进行控制器的跳转外，我们也可以使用代码来跳转Storyboard中segue连接关系。 在Storyboard中两个控制器间建立一个segue联系，我们可以取一个名字： 在触发跳转的方法中，使用如下方法进行跳转，这里面的参数id就是我们取得segue的id： 1- (void)performSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(5_0); 下面三个属性我们可以获取controller的nib文件名，其storyBoard和其Bundle: 123@property(nullable, nonatomic, readonly, copy) NSString *nibName; @property(nullable, nonatomic, readonly, strong) NSBundle *nibBundle; @property(nullable, nonatomic, readonly, strong) UIStoryboard *storyboard NS_AVAILABLE_IOS(5_0); 五、UIViewController之间的一些从属关系这部分的内容和方法可能我们接触用到的并不多，但是在某些情况下，使用这些方法可以大大的方便某些逻辑。 1、parentViewControllerUIViewController里面封装了一个数组，可以存放其子ViewController，系统中使用的例子就是导航和tabBar这类的控制器，我们使用如下方法可以直接访问这些父的controller： 1@property(nullable,nonatomic,weak,readonly) UIViewController *parentViewController; 2、模态跳转中Controller的从属在我们进行控制器的跳转时，只要控制器没有被释放，我们都可以顺藤摸瓜的找到它，使用如下两个方法： 1234//其所present的contller，比如，A和B两个controller，A跳转到B，那么A的presentedViewController就是B@property(nullable, nonatomic,readonly) UIViewController *presentedViewController NS_AVAILABLE_IOS(5_0);//和上面的方法刚好相反，比如，A和B两个controller，A跳转到B，那么B的presentingViewController就是A@property(nullable, nonatomic,readonly) UIViewController *presentingViewController NS_AVAILABLE_IOS(5_0); 了解了上面方法我们可以知道，对于反向传值这样的问题，我们根本不需要代理，block，通知等这样的复杂手段，只需要获取跳转到它的Controller，直接设置即可。举个例子，我们需要在第二个界面消失后，改变第一个界面的颜色，在第二个controller中只需要下面的代码即可实现 ： 12 self.presentingViewController.view.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; [self dismissViewControllerAnimated:YES completion:nil]; 六、UIViewController的模态跳转及动画特效单纯的UIViewController中，我们使用最多的是如下的两个方法，一个向前跳转，一个向后返回: 12- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0);- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0); 从方法中，我们可以看到，有animated这个参数，来选择是否有动画特效，默认的动画特效是像抽屉一样从手机屏幕的下方向上弹起，当然，这个效果我们可以进行设置，UIViewController有如下一个属性来设置动画特效： 1@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle NS_AVAILABLE_IOS(3_0); 注意，这个要设置的是将要跳转到的controller，枚举如下： 123456typedef NS_ENUM(NSInteger, UIModalTransitionStyle) &#123; UIModalTransitionStyleCoverVertical = 0,//默认的，从下向上覆盖 UIModalTransitionStyleFlipHorizontal ,//水平翻转 UIModalTransitionStyleCrossDissolve,//溶解 UIModalTransitionStylePartialCurl ,从下向上翻页&#125;; 除了跳转的效果，还有一个属性可以设置弹出的controler的填充效果，但是这个属性只在pad上有效，在iphone上无效，都是填充到整个屏幕： 12345678910111213@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle NS_AVAILABLE_IOS(3_2);//枚举如下typedef NS_ENUM(NSInteger, UIModalPresentationStyle) &#123; UIModalPresentationFullScreen = 0,//填充整个屏幕 UIModalPresentationPageSheet,//留下状态栏 UIModalPresentationFormSheet,//四周留下变暗的空白 UIModalPresentationCurrentContext ,//和跳转到它的控制器保持一致 UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),//自定义 UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0), UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0), UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED, UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1, &#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之三——纯代码的autoLayout及布局动画","slug":"143iOS界面布局之三——纯代码的autoLayout及布局动画","date":"2015-10-29T16:00:00.000Z","updated":"2021-07-05T05:59:11.854Z","comments":true,"path":"2015/10/30/143iOS界面布局之三——纯代码的autoLayout及布局动画/","link":"","permalink":"http://huishao.cc/2015/10/30/143iOS界面布局之三——纯代码的autoLayout及布局动画/","excerpt":"","text":"iOS界面布局之三——纯代码的autoLayout及布局动画一、引言关于界面布局，apple的策略已经趋于成熟，autolayout的优势在开发中也已经展现的淋漓尽致。除了使用storyBoard进行布局约束的拖拽，有时我们也需要在代码中进行autolayout的布局设置，Masonry库可以方便的创建约束属性，实际上，我们也没有必要再使用系统原生的代码来创建和设置约束，这篇博客只作为使用的方法备忘。前几篇布局介绍的链接如下： 使用autoresizing进行界面布局：http://my.oschina.net/u/2340880/blog/423357 初识autolayout布局模型：http://my.oschina.net/u/2340880/blog/423500 二、了解一个类用代码来做视图间的相关约束，那么就一定要将“约束”也进行对象化，在iOS6之后，引入了autolayout这个概念，相应的也增加了NSLayoutConstraint这个对象，这个对象就是专门用来进行约束布局的设置对象。通过这个对象，我们可以设置类似视图对象之间的间距，约束的宽高，比例等属性。创建NSLayoutConstraint对象的方法有两种，下面我们分别介绍： 1、使用Objective-C风格的方法创建约束对象所谓Objective-C风格的方法，就是通过原生枚举和一些属性设置来创建NSLayoutConstraint对象。使用NSLayoutConstraint类的如下方法： 1+(instancetype)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(nullable id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c; 先来介绍下方法中的参数都是什么意义，我们应该怎么用他们： view1：要添加约束的视图对象。 attr1：要约束的对象属性，这个就是一些枚举，如下： 123456789101112131415161718192021222324252627typedef NS_ENUM(NSInteger, NSLayoutAttribute) &#123; NSLayoutAttributeLeft = 1,//左 NSLayoutAttributeRight,//右 NSLayoutAttributeTop,//上 NSLayoutAttributeBottom,//下 NSLayoutAttributeLeading,//起始边，类似左，只在某些从右向左排列的语言中和NSLayoutAttributeLeft有大区别 NSLayoutAttributeTrailing,//结束边 NSLayoutAttributeWidth,//宽度 NSLayoutAttributeHeight,//高度 NSLayoutAttributeCenterX,//x中心 NSLayoutAttributeCenterY,//y中心 NSLayoutAttributeBaseline,//基线 NSLayoutAttributeLastBaseline = NSLayoutAttributeBaseline, NSLayoutAttributeFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0), //下面的属性是设置的边距 意义和上面类似 对应左，右等边距 NSLayoutAttributeLeftMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeRightMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeTopMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeBottomMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeLeadingMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeTrailingMargin NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeCenterXWithinMargins NS_ENUM_AVAILABLE_IOS(8_0), NSLayoutAttributeCenterYWithinMargins NS_ENUM_AVAILABLE_IOS(8_0), //无，后面会说应用场景 NSLayoutAttributeNotAnAttribute = 0&#125;; relation：约束的选项，对应&lt;=,==,&gt;=这些，枚举如下： 12345typedef NS_ENUM(NSInteger, NSLayoutRelation) &#123; NSLayoutRelationLessThanOrEqual = -1,//&lt;= NSLayoutRelationEqual = 0,//== NSLayoutRelationGreaterThanOrEqual = 1,//&gt;=&#125;; view2:与之对应添加约束的视图对象，例如，如过我要设置view1的上边距离父视图的上边一定间距，这个view2就是view1的父视图，如果我要设置view1与另一个视图一定距离，这个view2就是另一个视图。 attr2：view2的要约束的属性，和attr1含义一样。 multiplie:约束的比例，比如view1的宽是view2的宽的两倍，这个multiplie就是2. C：这是具体的约束值 对于这些属性，文档上有这样的解释：view1.attr1 = view2.attr2 * multiplier + constant 例如，我们创建一个label，将它的宽高固定为100*100，位置放在屏幕的中央，我们可以使用如下的约束代码： 12345678910111213141516UILabel * label = [[UILabel alloc]init]; label.numberOfLines = 0; //使用代码布局 需要将这个属性设置为NO label.translatesAutoresizingMaskIntoConstraints = NO; label.backgroundColor = [UIColor redColor]; //创建x居中的约束 NSLayoutConstraint * constraintx = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1 constant:0]; //创建y居中的约束 NSLayoutConstraint * constrainty = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterY multiplier:1 constant:0]; //创建宽度约束 NSLayoutConstraint * constraintw = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:100]; //创建高度约束 NSLayoutConstraint * constrainth = [NSLayoutConstraint constraintWithItem:label attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:100]; //添加约束之前，必须将视图加在父视图上 [self.view addSubview:label]; [self.view addConstraints:@[constraintx,constrainty,constrainth,constraintw]]; 效果如下： 可以发现，一个如此简单的约束方式，我们用这样的代码要写这么一大坨，麻烦而且不直观。于是，apple又提供给我们下面一种方式。 2.使用ASCLL字符创造艺术般的格式化字符串约束看到这个小标题是不是眼前一亮，这个标题不是我凭空想象出来的，apple的文档上就是这么写的。十分可爱，对吧。相对于NSLayoutConstraint中的创建方法如下： 1+ (NSArray&lt;__kindof NSLayoutConstraint *&gt; *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(nullable NSDictionary&lt;NSString *,id&gt; *)metrics views:(NSDictionary&lt;NSString *, id&gt; *)views; 那么我们先来看，什么是格式化的字符串约束。 说到格式化的字符串约束，要先提一个东西VFL：visual format language——格式化约束语言，这又是什么鬼？确实，这个东西写出来第一眼看上去真的不知道是什么鬼，就比如要设置一个label，距离上边100，左边20，宽高都为100，代码如下： 12345678910 label.numberOfLines = 0; label.translatesAutoresizingMaskIntoConstraints = NO; label.backgroundColor = [UIColor redColor]; //label.text=@&quot;12332322132131233213213&quot;; [self.view addSubview:label]; NSArray * constraintArray = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-20-[label(100@1000)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(label)]; NSArray * constraintArray2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-100-[label(100)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(label)]; [self.view addConstraints:constraintArray]; [self.view addConstraints:constraintArray2]; 效果如下： 代码少了很多，对吧，但是中间那部分字符串什么玩意？下面我们来解释一下。 VFL语言我个人而言，他很类似于古代的象形文字(不知道是否apple的工程师从其中得到灵感)，对布局的约束设置是直观的用符号表达出来的，例如： 1H:|-20-[label(100@1000)] 前面的H代表是水平的布局还是垂直的布局，H代表水平，V表示垂直，|表示父视图的边沿，-20-表示距离20px，[]内是要布局摆放的视图对象名，()中是约束的尺寸，H下则为宽度，V下则为高度,@后面的数字代表优先级。 创建方法中的options参数，用来设置对齐模式，不需要可以写0： 1234567891011121314151617181920212223typedef NS_OPTIONS(NSUInteger, NSLayoutFormatOptions) &#123; NSLayoutFormatAlignAllLeft = (1 &lt;&lt; NSLayoutAttributeLeft), NSLayoutFormatAlignAllRight = (1 &lt;&lt; NSLayoutAttributeRight), NSLayoutFormatAlignAllTop = (1 &lt;&lt; NSLayoutAttributeTop), NSLayoutFormatAlignAllBottom = (1 &lt;&lt; NSLayoutAttributeBottom), NSLayoutFormatAlignAllLeading = (1 &lt;&lt; NSLayoutAttributeLeading), NSLayoutFormatAlignAllTrailing = (1 &lt;&lt; NSLayoutAttributeTrailing), NSLayoutFormatAlignAllCenterX = (1 &lt;&lt; NSLayoutAttributeCenterX), NSLayoutFormatAlignAllCenterY = (1 &lt;&lt; NSLayoutAttributeCenterY), NSLayoutFormatAlignAllBaseline = (1 &lt;&lt; NSLayoutAttributeBaseline), NSLayoutFormatAlignAllLastBaseline = NSLayoutFormatAlignAllBaseline, NSLayoutFormatAlignAllFirstBaseline NS_ENUM_AVAILABLE_IOS(8_0) = (1 &lt;&lt; NSLayoutAttributeFirstBaseline), NSLayoutFormatAlignmentMask = 0xFFFF, /* choose only one of these three */ NSLayoutFormatDirectionLeadingToTrailing = 0 &lt;&lt; 16, // default NSLayoutFormatDirectionLeftToRight = 1 &lt;&lt; 16, NSLayoutFormatDirectionRightToLeft = 2 &lt;&lt; 16, NSLayoutFormatDirectionMask = 0x3 &lt;&lt; 16, &#125;; metrics参数是属性替换字典，例如我们上边用到的距离左边界20，如果这个20是一个变量width,我们可以将20的地方换成width，然后配置这个字典：@{@”width”:@20}，这样，在布局时，系统会把width换成20。 views是对象的映射字典，原理也是将字符串中的对象名label映射成真实的对象，NSDictionaryOfVariableBindings会帮我们生成这样的字典，我们只需要想对象传进去即可，如果要手动创建这字典，格式如下：@{@”label”：label}. 三、使用aotulayout设计一个聊天界面的输入框仔细观察QQ或者其他聊天工具的app上的输入框，会发现他非常智能，宽度会随着我们输入文字的行数进行自适应，并且这个宽度不是无限增大的，当我们文字多到一定行数，宽度会保持不变，文本框可以进行内容滑动，如果不用autolayout，这个功能会比较棘手一些，但是使用它，会发现这是如此的容易： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@interface ViewController ()&lt;UITextViewDelegate&gt;&#123; UITextView * textView ; NSArray * array1; NSArray * array2;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. textView = [[UITextView alloc]init]; textView.layer.borderColor = [[UIColor grayColor]CGColor]; textView.layer.borderWidth = 1; textView.translatesAutoresizingMaskIntoConstraints = NO; textView.delegate=self; [self.view addSubview:textView]; array1 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-100-[textView]-100-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; array2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-150-[textView(30)]&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; [self.view addConstraints:array1]; [self.view addConstraints:array2]; &#125;-(BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text&#123; //当文本高度大于textView的高度并且小于100时，更新约束 if (textView.contentSize.height&gt;textView.frame.size.height&amp;&amp;textView.contentSize.height&lt;100) &#123; float hight =textView.contentSize.height; //将以前的移除掉 [self.view removeConstraints:array1]; [self.view removeConstraints:array2]; array1 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:|-100-[textView]-100-|&quot; options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]; array2 = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-150-[textView(hight)]&quot; options:0 metrics:@&#123;@&quot;hight&quot;:[NSNumber numberWithFloat:hight]&#125; views:NSDictionaryOfVariableBindings(textView)]; [self.view addConstraints:array1]; [self.view addConstraints:array2]; &#125; //更新约束 [self.view updateConstraintsIfNeeded]; return YES;&#125; 现在，当我们进行输入的时候，textView的高度可以自适应文字行数了。 四、通过动画改善更新约束时的效果这一点非常coll，上面我们已经实现了textView随文本的行数高度进行自适应，但是变化的效果十分生硬，还要apple的动画框架支持autolayout，把刚才调用更新约束的地方进行如下修改： 123[UIView animateWithDuration:1 animations:^&#123; [self.view layoutIfNeeded]; &#125;]; 试试看，变换的效果已经非常平滑了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列七——三维中的球型布局","slug":"142iOS流布局UICollectionView系列七——三维中的球型布局","date":"2015-10-28T16:00:00.000Z","updated":"2021-07-03T12:45:53.847Z","comments":true,"path":"2015/10/29/142iOS流布局UICollectionView系列七——三维中的球型布局/","link":"","permalink":"http://huishao.cc/2015/10/29/142iOS流布局UICollectionView系列七——三维中的球型布局/","excerpt":"","text":"iOS流布局UICollectionView系列七——三维中的球型布局一、引言通过6篇的博客，从平面上最简单的规则摆放的布局，到不规则的瀑布流布局，再到平面中的圆环布局，我们突破了线性布局的局限，在后面，我们将布局扩展到了空间，在Z轴上进行了平移，我们实现了一个类似UIPickerView的布局模型，其实我们还可以再进一步，类比于平面布局，picKerView只是线性排列布局在空间上的旋转与平移，这次，我们更加充分了利用一下空间的尺寸，来设计一个圆球的布局模型。以下是前几篇博客地址： 1.初识与简单实用UICollectionView：http://my.oschina.net/u/2340880/blog/522613 2.UICollectionView的代理方法：http://my.oschina.net/u/2340880/blog/522682 3.实用FlowLayout进行更灵活布局：http://my.oschina.net/u/2340880/blog/522748 4.自定义FlowLayout进行瀑布流布局：http://my.oschina.net/u/2340880/blog/522806 5.平面圆环布局的实现：http://my.oschina.net/u/2340880/blog/523064 6.将布局从平面应用到空间：http://my.oschina.net/u/2340880/blog/523341 二、将布局扩展为空间球型在viewController中先实现一些准备代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; //这里设置的偏移量是为了无缝进行循环的滚动，具体在上一篇博客中有解释 collect.contentOffset = CGPointMake(320, 400); [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;//我们返回30的标签-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 30;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 30, 30)]; label.text = [NSString stringWithFormat:@&quot;%ld&quot;,(long)indexPath.row]; [cell.contentView addSubview:label]; return cell;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;//这里对滑动的contentOffset进行监控，实现循环滚动-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.y&lt;200) &#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y+10*400); &#125;else if(scrollView.contentOffset.y&gt;11*400)&#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x, scrollView.contentOffset.y-10*400); &#125; if (scrollView.contentOffset.x&lt;160) &#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x+10*320,scrollView.contentOffset.y); &#125;else if(scrollView.contentOffset.x&gt;11*320)&#123; scrollView.contentOffset = CGPointMake(scrollView.contentOffset.x-10*320,scrollView.contentOffset.y); &#125;&#125; 这里面的代码比较上一篇博客中的并没有什么大的改动，只是做了横坐标的兼容。 在我们的layout类中，将代码修改成如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-(void)prepareLayout&#123; [super prepareLayout]; &#125;//返回的滚动范围增加了对x轴的兼容-(CGSize)collectionViewContentSize&#123; return CGSizeMake( self.collectionView.frame.size.width*([self.collectionView numberOfItemsInSection:0]+2), self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2));&#125;-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES;&#125;-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //获取item的个数 int itemCounts = (int)[self.collectionView numberOfItemsInSection:0]; atti.center = CGPointMake(self.collectionView.frame.size.width/2+self.collectionView.contentOffset.x, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y); atti.size = CGSizeMake(30, 30); CATransform3D trans3D = CATransform3DIdentity; trans3D.m34 = -1/900.0; CGFloat radius = 15/tanf(M_PI*2/itemCounts/2); //根据偏移量 改变角度 //添加了一个x的偏移量 float offsety = self.collectionView.contentOffset.y; float offsetx = self.collectionView.contentOffset.x; //分别计算偏移的角度 float angleOffsety = offsety/self.collectionView.frame.size.height; float angleOffsetx = offsetx/self.collectionView.frame.size.width; CGFloat angle1 = (float)(indexPath.row+angleOffsety-1)/itemCounts*M_PI*2; //x，y的默认方向相反 CGFloat angle2 = (float)(indexPath.row-angleOffsetx-1)/itemCounts*M_PI*2; //这里我们进行四个方向的排列 if (indexPath.row%4==1) &#123; trans3D = CATransform3DRotate(trans3D, angle1, 1.0,0, 0); &#125;else if(indexPath.row%4==2)&#123; trans3D = CATransform3DRotate(trans3D, angle2, 0, 1, 0); &#125;else if(indexPath.row%4==3)&#123; trans3D = CATransform3DRotate(trans3D, angle1, 0.5,0.5, 0); &#125;else&#123; trans3D = CATransform3DRotate(trans3D, angle1, 0.5,-0.5,0); &#125; trans3D = CATransform3DTranslate(trans3D, 0, 0, radius); atti.transform3D = trans3D; return atti;&#125;-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray * attributes = [[NSMutableArray alloc]init]; //遍历设置每个item的布局属性 for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123; [attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]]; &#125; return attributes;&#125; 布局效果如下： 滑动屏幕，这个圆球是可以进行滚动的。 TIP：这里我们只平均分配了四个方向上的布局，如果item更加小也更加多，我们可以分配到更多的方向上，使球体更加充实。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列五——圆环布局的实现","slug":"140iOS流布局UICollectionView系列五——圆环布局的实现","date":"2015-10-27T16:00:00.000Z","updated":"2021-07-03T12:41:16.436Z","comments":true,"path":"2015/10/28/140iOS流布局UICollectionView系列五——圆环布局的实现/","link":"","permalink":"http://huishao.cc/2015/10/28/140iOS流布局UICollectionView系列五——圆环布局的实现/","excerpt":"","text":"iOS流布局UICollectionView系列五——圆环布局的实现一、引言前边的几篇博客，我们了解了UICollectionView的基本用法以及一些扩展，在不定高的瀑布流布局中，我们发现，可以通过设置具体的布局属性类UICollectionViewLayoutAttributes来设置设置每个item的具体位置，我们可以再扩展一下，如果位置我们可以自由控制，那个布局我们也可以更加灵活，就比如创建一个如下的circleLayout： 这种布局方式在apple的官方文档中也有介绍，是UICollectionView的一个应用示例。 二、设计一个圆环布局接着我们以前的想法，依然时候随机颜色的色块来表达我们的item，先自定义一个layout类，这个类继承于UICollectionViewLayout，UICollectionLayout是一个布局抽象基类，我们要使用自定义的布局方式，必须将其子类化，可能你还记得，我们在进行瀑布流布局的时候使用过UICollectionViewFlowLayout类，这个类就是继承于UICollectionViewLayout类，系统为我们实现好的一个布局方案。 1234@interface MyLayout : UICollectionViewLayout//这个int值存储有多少个item@property(nonatomic,assign)int itemCount;@end 我们需要重写这个类的三个方法，来进行圆环布局的设置，首先是prepareLayout，为布局做一些准备工作，使用collectionViewContentSize来设置内容的区域大小，最后使用layoutAttributesForElementsInRect方法来返回我们的布局信息字典，这个前面瀑布流布局的思路是一样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@implementation MyLayout&#123; NSMutableArray * _attributeAttay;&#125;-(void)prepareLayout&#123; [super prepareLayout]; //获取item的个数 _itemCount = (int)[self.collectionView numberOfItemsInSection:0]; _attributeAttay = [[NSMutableArray alloc]init]; //先设定大圆的半径 取长和宽最短的 CGFloat radius = MIN(self.collectionView.frame.size.width, self.collectionView.frame.size.height)/2; //计算圆心位置 CGPoint center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2); //设置每个item的大小为50*50 则半径为25 for (int i=0; i&lt;_itemCount; i++) &#123; UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]; //设置item大小 attris.size = CGSizeMake(50, 50); //计算每个item的圆心位置 /* . . . . . r . . ......... */ //计算每个item中心的坐标 //算出的x y值还要减去item自身的半径大小 float x = center.x+cosf(2*M_PI/_itemCount*i)*(radius-25); float y = center.y+sinf(2*M_PI/_itemCount*i)*(radius-25); attris.center = CGPointMake(x, y); [_attributeAttay addObject:attris]; &#125; &#125;//设置内容区域的大小-(CGSize)collectionViewContentSize&#123; return self.collectionView.frame.size;&#125;//返回设置数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return _attributeAttay;&#125; 在viewController中代码如下： 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.layer.masksToBounds = YES; cell.layer.cornerRadius = 25; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 如上非常简单的一些逻辑控制，我们就实现哦圆环布局，随着item的多少，布局会自动调整，如果不是UICollectionView的功劳，实现这样的功能，我们可能要写上一阵子了^_^。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列六——将布局从平面应用到空间","slug":"141iOS流布局UICollectionView系列六——将布局从平面应用到空间","date":"2015-10-27T16:00:00.000Z","updated":"2021-07-03T12:42:34.298Z","comments":true,"path":"2015/10/28/141iOS流布局UICollectionView系列六——将布局从平面应用到空间/","link":"","permalink":"http://huishao.cc/2015/10/28/141iOS流布局UICollectionView系列六——将布局从平面应用到空间/","excerpt":"","text":"iOS流布局UICollectionView系列六——将布局从平面应用到空间一、引言前面，我们将布局由线性的瀑布流布局扩展到了圆环布局，这使我们使用UICollectionView的布局思路大大迈进了一步，这次，我们玩的更加炫一些，想办法将布局应用的空间，你是否还记得，在管理布局的item的具体属性的类UICollectionViewLayoutAttributrs类中，有transform3D这个属性，通过这个属性的设置，我们真的可以在空间的坐标系中进行布局设计。iOS系统的控件中，也并非没有这样的先例，UIPickerView就是很好的一个实例，这篇博客，我们就通过使用UICollectionView实现一个类似系统的UIPickerView的布局视图，来体会UICollectionView在3D控件布局的魅力。系统的pickerView效果如下： 二、先来实现一个炫酷的滚轮空间布局万丈的高楼也是由一砖一瓦堆砌而成，在我们完全模拟系统pickerView前，我们应该先将视图的布局摆放这一问题解决。我们依然来创建一个类，继承于UICollectionViewLayout： 123@interface MyLayout : UICollectionViewLayout@end 对于.m文件的内容，前几篇博客中我们都是在prepareLayout中进行布局的静态设置，那是因为我们前几篇博客中的布局都是静态的，布局并不会随着我们的手势操作而发生太大的变化，因此我们全部在prepareLayout中一次配置完了。而我们这次要讨论的布局则不同，pickerView会随着我们手指的拖动而进行滚动，因此UICollectionView中的每一个item的布局是在不断变化的，所以这次，我们采用动态配置的方式，在layoutAttributesForItemAtIndexPath方法中进行每个item的布局属性设置。 至于layoutAttributesForItemAtIndexPath方法，它也是UICollectionViewLayout类中的方法，用于我们自定义时进行重写，至于为什么动态布局要在这里面配置item的布局属性，后面我们会了解到。 在编写我们的布局类之前，先做好准备工作，在viewController中，实现如下代码： 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect];&#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(0, 0, 250, 80)]; label.text = [NSString stringWithFormat:@&quot;我是第%ld行&quot;,(long)indexPath.row]; [cell.contentView addSubview:label]; return cell;&#125; 上面我创建了10个Item，并且在每个Item上添加了一个标签，标写是第几行。 在我们自定义的布局类中重写layoutAttributesForElementsInRect，在其中返回我们的布局数组： 12345678-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray * attributes = [[NSMutableArray alloc]init]; //遍历设置每个item的布局属性 for (int i=0; i&lt;[self.collectionView numberOfItemsInSection:0]; i++) &#123; [attributes addObject:[self layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForItem:i inSection:0]]]; &#125; return attributes;&#125; 之后，在我们布局类中重写layoutAttributesForItemAtIndexPath方法： 12345678910111213-(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath&#123; //创建一个item布局属性类 UICollectionViewLayoutAttributes * atti = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; //获取item的个数 int itemCounts = (int)[self.collectionView numberOfItemsInSection:0]; //设置每个item的大小为260*100 atti.size = CGSizeMake(260, 100); /* 后边介绍的代码添加在这里 */ return atti;&#125; 上面的代码中，我们什么都没有做，下面我们一步步来实现3D的滚轮效果。 首先，我们先将所有的item的位置都设置为collectionView的中心： 1atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2); 这时，如果我们运行程序的话，所有item都将一层层贴在屏幕的中央，如下： 很丑对吧，之后我们来设置每个item的3D效果,在上面的布局方法中添加如下代码: 12345678910111213141516 //创建一个transform3D类 //CATransform3D是一个类似矩阵的结构体 //CATransform3DIdentity创建空得矩阵 CATransform3D trans3D = CATransform3DIdentity; //这个值设置的是透视度，影响视觉离投影平面的距离 trans3D.m34 = -1/900.0; //下面这些属性 后面会具体介绍 //这个是3D滚轮的半径 CGFloat radius = 50/tanf(M_PI*2/itemCounts/2); //计算每个item应该旋转的角度 CGFloat angle = (float)(indexPath.row)/itemCounts*M_PI*2; //这个方法返回一个新的CATransform3D对象，在原来的基础上进行旋转效果的追加 //第一个参数为旋转的弧度，后三个分别对应x，y，z轴，我们需要以x轴进行旋转 trans3D = CATransform3DRotate(trans3D, angle, 1.0, 0, 0); //进行设置 atti.transform3D = trans3D; 对于上面的radius属性，运用了一些简单的几何和三角函数的知识。如果我们将系统的pickerView沿着y轴旋转90°，你会发现侧面的它是一个规则的正多边形，这里的radius就是这个多边形中心到其边的垂直距离，也是内切圆的半径，所有的item拼成了一个正多边形，示例如下： 通过简单的数学知识，h/2弦对应的角的弧度为2*pi/(边数)/2，在根据三角函数相关知识可知，这个角的正切值为h/2/radius，这就是我们radius的由来。 对于angle属性，它是每一个item的x轴旋转度数，如果我们将所有item的中心都放在一点，通过旋转让它们散开如下图所示： 每个item旋转的弧度就是其索引/(2*pi)。 通过上面的设置，我们再运行代码，效果如下： 仔细观察我们可以发现，item以x中轴线进行了旋转平均布局，侧面的效果就是我们上面的简笔画那样，下面要进行我们的第三步了，将这个item，全部沿着其Z轴向前拉，就可以成为我们滚轮的效果，示例图如下： 我们继续在刚才的代码后面添加这行代码： 12 //这个方法也返回一个transform3D对象，追加平移效果，后面三个参数，对应平移的x，y，z轴，我们沿z轴平移 trans3D = CATransform3DTranslate(trans3D, 0, 0, radius); 再次运行，效果如下： 布局的效果我们已经完成了，离成功很近了对吧，只是现在的布局是静态的，我们不能滑动这个滚轮，我们还需要用动态滑动做一些处理。 三、让滚轮滑动起来 通过上面的努力，我们已经静态布局出了一个类似pickerView的滚轮，现在我们再来添加滑动滚动的效果 首先，我们需要给collectionView一个滑动的范围，我们以一屏collectionView的滑动距离来当做滚轮滚动一下的参照，我们在布局类中的如下方法中返回滑动区域： 123-(CGSize)collectionViewContentSize&#123; return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*[self.collectionView numberOfItemsInSection:0]);&#125; 这时我们的collectionView已经可以进行滑动，但是并不是我们想要的效果，滚轮并没有滚动，而是随着滑动出了屏幕，因此，我们需要在滑动的时候不停的动态布局，将滚轮始终固定在collectionView的中心，先需要在布局类中实现如下方法： 12345//返回yes，则一有变化就会刷新布局-(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds&#123; return YES; &#125; 将上面的布局的中心点设置加上一个动态的偏移量： 1 atti.center = CGPointMake(self.collectionView.frame.size.width/2, self.collectionView.frame.size.height/2+self.collectionView.contentOffset.y); 现在在运行，会发现滚轮会随着滑动始终固定在中间，但是还是不如人意，滚轮并没有转动起来，我们还需要动态的设置每个item的旋转角度，这样连续看起来，滚轮就转了起来，在上面设置布局的方法中，我们在添加一些处理： 12345 //获取当前的偏移量 float offset = self.collectionView.contentOffset.y; //在角度设置上，添加一个偏移角度 float angleOffset = offset/self.collectionView.frame.size.height; CGFloat angle = (float)(indexPath.row+angleOffset)/itemCounts*M_PI*2; 再看看效果，没错，就是这么简单，滚轮已经转了起来。 四、让其循环滚动的逻辑我们再进一步，如果滚动可以循环，这个控件将更加炫酷，添加这样的逻辑也很简单，通过监测scrollView的偏移量，我们可以对齐进行处理，因为collectionView继承于scrollView，我们可以直接在ViewController中实现其代理方法，如下： 123456789-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //小于半屏 则放到最后一屏多半屏 if (scrollView.contentOffset.y&lt;200) &#123; scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y+10*400); //大于最后一屏多一屏 放回第一屏 &#125;else if(scrollView.contentOffset.y&gt;11*400)&#123; scrollView.contentOffset = CGPointMake(0, scrollView.contentOffset.y-10*400); &#125;&#125; 因为咱们的环状布局，上面的逻辑刚好可以无缝对接，但是会有新的问题，一开始运行，滚轮就是出现在最后一个item的位置，而不是第一个，并且有些相关的地方，我们也需要一些适配： 在viewController中： 12//一开始将collectionView的偏移量设置为1屏的偏移量collect.contentOffset = CGPointMake(0, 400); 在layout类中： 1234//将滚动范围设置为(item总数+2)*每屏高度 -(CGSize)collectionViewContentSize&#123; return CGSizeMake(self.collectionView.frame.size.width, self.collectionView.frame.size.height*([self.collectionView numberOfItemsInSection:0]+2));&#125; 12//将计算的具体item角度向前递推一个CGFloat angle = (float)(indexPath.row+angleOffset-1)/itemCounts*M_PI*2; OK，我们终于大功告成了，可以发现，实现这样一个布局效果炫酷的控件，代码其实并没有多少，相比，数学逻辑要比编写代码本身困难，这十分类似数学中的几何问题，如果你弄清了逻辑，解决是分分钟的事，我们可以通过这样的一个思路，设计更多3D或者平面特效的布局方案，抽奖的转动圆盘，书本的翻页，甚至立体的标签云，UICollectionView都可以实现，这篇博客中的代码在下面的连接中，疏漏之处，欢迎指正！ http://pan.baidu.com/s/1jGCmbKM 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局","slug":"139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局","date":"2015-10-26T16:00:00.000Z","updated":"2021-07-03T12:40:20.507Z","comments":true,"path":"2015/10/27/139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局/","link":"","permalink":"http://huishao.cc/2015/10/27/139iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局/","excerpt":"","text":"iOS流布局UICollectionView系列四——自定义FlowLayout进行瀑布流布局一、引言前几篇博客从UICollectionView的基础应用到设置UICollectionViewFlowLayout更加灵活的进行布局，但都限制在系统为我们准备好的布局框架中，还是有一些局限性，例如，如果我要进行瀑布流似的不定高布局，前面的方法就很难满足我们的需求了，如下： 这种布局无疑在app的应用中更加广泛，商品的展示，书架书目的展示，都会倾向于采用这样的布局方式，当然，通过自定义FlowLayout，我们也很容易实现。 二、进行自定义瀑布流布局首先，我们新建一个文件继承于UICollectionViewFlowLayout： 1@interface MyLayout : UICollectionViewFlowLayout 为了演示的方面，这里我不错更多的封装，添加一个属性，直接让外界将item个数传递进来，我们把重心方法重写布局的方法上： 123@interface MyLayout : UICollectionViewFlowLayout@property(nonatomic,assign)int itemCount;@end 前面说过，UICollectionViewFlowLayout是一个专门用来管理collectionView布局的类，因此，collectionView在进行UI布局前，会通过这个类的对象获取相关的布局信息，FlowLayout类将这些布局信息全部存放在了一个数组中，数组中是UICollectionViewLayoutAttributes类，这个类是对item布局的具体设置，以后咱们在讨论这个类。总之，FlowLayout类将每个item的位置等布局信息放在一个数组中，在collectionView布局时，会调用FlowLayout类layoutAttributesForElementsInRect：方法来获取这个布局配置数组。因此，我们需要重写这个方法，返回我们自定义的配置数组，另外，FlowLayout类在进行布局之前，会调用prepareLayout方法，所以我们可以重写这个方法，在里面对我们的自定义配置数据进行一些设置。 简单来说，自定义一个FlowLayout布局类就是两个步骤： 1、设计好我们的布局配置数据 prepareLayout方法中 2、返回我们的配置数组 layoutAttributesForElementsInRect方法中 示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@implementation MyLayout&#123; //这个数组就是我们自定义的布局配置数组 NSMutableArray * _attributeAttay;&#125;//数组的相关设置在这个方法中//布局前的准备会调用这个方法-(void)prepareLayout&#123; _attributeAttay = [[NSMutableArray alloc]init]; [super prepareLayout]; //演示方便 我们设置为静态的2列 //计算每一个item的宽度 float WIDTH = ([UIScreen mainScreen].bounds.size.width-self.sectionInset.left-self.sectionInset.right-self.minimumInteritemSpacing)/2; //定义数组保存每一列的高度 //这个数组的主要作用是保存每一列的总高度，这样在布局时，我们可以始终将下一个Item放在最短的列下面 CGFloat colHight[2]=&#123;self.sectionInset.top,self.sectionInset.bottom&#125;; //itemCount是外界传进来的item的个数 遍历来设置每一个item的布局 for (int i=0; i&lt;_itemCount; i++) &#123; //设置每个item的位置等相关属性 NSIndexPath *index = [NSIndexPath indexPathForItem:i inSection:0]; //创建一个布局属性类，通过indexPath来创建 UICollectionViewLayoutAttributes * attris = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:index]; //随机一个高度 在40——190之间 CGFloat hight = arc4random()%150+40; //哪一列高度小 则放到那一列下面 //标记最短的列 int width=0; if (colHight[0]&lt;colHight[1]) &#123; //将新的item高度加入到短的一列 colHight[0] = colHight[0]+hight+self.minimumLineSpacing; width=0; &#125;else&#123; colHight[1] = colHight[1]+hight+self.minimumLineSpacing; width=1; &#125; //设置item的位置 attris.frame = CGRectMake(self.sectionInset.left+(self.minimumInteritemSpacing+WIDTH)*width, colHight[width]-hight-self.minimumLineSpacing, WIDTH, hight); [_attributeAttay addObject:attris]; &#125; //设置itemSize来确保滑动范围的正确 这里是通过将所有的item高度平均化，计算出来的(以最高的列位标准) if (colHight[0]&gt;colHight[1]) &#123; self.itemSize = CGSizeMake(WIDTH, (colHight[0]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing); &#125;else&#123; self.itemSize = CGSizeMake(WIDTH, (colHight[1]-self.sectionInset.top)*2/_itemCount-self.minimumLineSpacing); &#125; &#125;//这个方法中返回我们的布局数组-(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect&#123; return _attributeAttay;&#125;@end 自定义完成FlowLayout后，我们在ViewController中进行使用： 123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MyLayout * layout = [[MyLayout alloc]init]; layout.scrollDirection = UICollectionViewScrollDirectionVertical; layout.itemCount=100; UICollectionView * collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect]; &#125;-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 100;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 运行效果就是我们引言中的截图。 三、UICollectionViewLayoutAttributes类中我们可以配置的属性通过上面的例子，我们可以了解，collectionView的item布局其实是LayoutAttributes类具体配置的，这个类可以配置的布局属性不止是frame这么简单，其中还有许多属性： 12345678910111213141516171819202122232425262728//配置item的布局位置@property (nonatomic) CGRect frame;//配置item的中心@property (nonatomic) CGPoint center;//配置item的尺寸@property (nonatomic) CGSize size;//配置item的3D效果@property (nonatomic) CATransform3D transform3D;//配置item的bounds@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);//配置item的旋转@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0);//配置item的alpha@property (nonatomic) CGFloat alpha;//配置item的z坐标@property (nonatomic) NSInteger zIndex; // default is 0//配置item的隐藏@property (nonatomic, getter=isHidden) BOOL hidden; //item的indexpath@property (nonatomic, strong) NSIndexPath *indexPath;//获取item的类型@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;@property (nonatomic, readonly, nullable) NSString *representedElementKind; //一些创建方法+ (instancetype)layoutAttributesForCellWithIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath *)indexPath; 通过上面的属性，可以布局出各式各样的炫酷效果，正如一句话：没有做不到，只有想不到。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列二——UICollectionView的代理方法","slug":"137iOS流布局UICollectionView系列二——UICollectionView的代理方法","date":"2015-10-26T16:00:00.000Z","updated":"2021-07-03T12:38:52.119Z","comments":true,"path":"2015/10/27/137iOS流布局UICollectionView系列二——UICollectionView的代理方法/","link":"","permalink":"http://huishao.cc/2015/10/27/137iOS流布局UICollectionView系列二——UICollectionView的代理方法/","excerpt":"","text":"iOS流布局UICollectionView系列二——UICollectionView的代理方法一、引言在上一篇博客中，介绍了最基本的UICollectionView的使用和其中我们常用的属性和方法，也介绍了瀑布流布局的过程与思路，这篇博客是上一篇的补充，来讨论关于UICollectionView的代理方法的使用。博客地址： UICollectionView的简介和简单使用：http://my.oschina.net/u/2340880/blog/522613 二、UICollectionViewDataSource协议这个协议主要用于collectionView相关数据的处理，包含方法如下： 首先，有两个方法是我们必须实现的： 设置每个分区的Item个数 - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section; 设置返回每个item的属性 - (UICollectionViewCell )collectionView:(UICollectionView )collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath; 下面的方法是可选实现的： 虽然这个方法是可选的，一般我们都会去实现，设置分区数 - (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView; 对头视图或者尾视图进行设置 - (UICollectionReusableView )collectionView:(UICollectionView )collectionView viewForSupplementaryElementOfKind:(NSString )kind atIndexPath:(NSIndexPath )indexPath; 设置某个item是否可以被移动，返回NO则不能移动 - (BOOL)collectionView:(UICollectionView )collectionView canMoveItemAtIndexPath:(NSIndexPath )indexPath NS_AVAILABLE_IOS(9_0); 移动item的时候，会调用这个方法 - (void)collectionView:(UICollectionView )collectionView moveItemAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath*)destinationIndexPath； 三、UICollectionViewDelegate协议这个协议用来设置和处理collectionView的功能和一些逻辑，所有方法都是可选实现： 是否允许某个Item的高亮，返回NO，则不能进入高亮状态 - (BOOL)collectionView:(UICollectionView )collectionView shouldHighlightItemAtIndexPath:(NSIndexPath )indexPath; 当item高亮时触发的方法 - (void)collectionView:(UICollectionView )collectionView didHighlightItemAtIndexPath:(NSIndexPath )indexPath; 结束高亮状态时触发的方法 - (void)collectionView:(UICollectionView )collectionView didUnhighlightItemAtIndexPath:(NSIndexPath )indexPath; 是否可以选中某个Item，返回NO，则不能选中 - (BOOL)collectionView:(UICollectionView )collectionView shouldSelectItemAtIndexPath:(NSIndexPath )indexPath; 是否可以取消选中某个Item - (BOOL)collectionView:(UICollectionView )collectionView shouldDeselectItemAtIndexPath:(NSIndexPath )indexPath; 已经选中某个item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didSelectItemAtIndexPath:(NSIndexPath )indexPath; 取消选中某个Item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didDeselectItemAtIndexPath:(NSIndexPath )indexPath; 将要加载某个Item时调用的方法 - (void)collectionView:(UICollectionView )collectionView willDisplayCell:(UICollectionViewCell )cell forItemAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(8_0); 将要加载头尾视图时调用的方法 - (void)collectionView:(UICollectionView )collectionView willDisplaySupplementaryView:(UICollectionReusableView )view forElementKind:(NSString )elementKind atIndexPath:(NSIndexPath )indexPath NS_AVAILABLE_IOS(8_0); 已经展示某个Item时触发的方法 - (void)collectionView:(UICollectionView )collectionView didEndDisplayingCell:(UICollectionViewCell )cell forItemAtIndexPath:(NSIndexPath *)indexPath; 已经展示某个头尾视图时触发的方法 - (void)collectionView:(UICollectionView )collectionView didEndDisplayingSupplementaryView:(UICollectionReusableView )view forElementOfKind:(NSString )elementKind atIndexPath:(NSIndexPath )indexPath; 这个方法设置是否展示长按菜单 - (BOOL)collectionView:(UICollectionView )collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath )indexPath; 长按菜单中可以触发一下类复制粘贴的方法，效果如下： 这个方法用于设置要展示的菜单选项 - (BOOL)collectionView:(UICollectionView )collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath )indexPath withSender:(nullable id)sender; 这个方法用于实现点击菜单按钮后的触发方法,通过测试，只有copy，cut和paste三个方法可以使用 - (void)collectionView:(UICollectionView )collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath )indexPath withSender:(nullable id)sender; 通过下面的方式可以将点击按钮的方法名打印出来： 123-(void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender&#123; NSLog(@&quot;%@&quot;,NSStringFromSelector(action));&#125; collectionView进行重新布局时调用的方法 - (nonnull UICollectionViewTransitionLayout )collectionView:(UICollectionView )collectionView transitionLayoutForOldLayout:(UICollectionViewLayout )fromLayout newLayout:(UICollectionViewLayout )toLayout; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列一——初识与简单使用UICollectionView image解决方法","slug":"136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView","date":"2015-10-26T16:00:00.000Z","updated":"2021-07-03T12:38:08.953Z","comments":true,"path":"2015/10/27/136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView/","link":"","permalink":"http://huishao.cc/2015/10/27/136iOS流布局UICollectionView系列一——初识与简单使用UICollectionView/","excerpt":"","text":"iOS流布局UICollectionView系列一——初识与简单使用UICollectionView一、简介UICollectionView是iOS6之后引入的一个新的UI控件，它和UITableView有着诸多的相似之处，其中许多代理方法都十分类似。简单来说，UICollectionView是比UITbleView更加强大的一个UI控件，有如下几个方面： 1、支持水平和垂直两种方向的布局 2、通过layout配置方式进行布局 3、类似于TableView中的cell特性外，CollectionView中的Item大小和位置可以自由定义 4、通过layout布局回调的代理方法，可以动态的定制每个item的大小和collection的大体布局属性 5、更加强大一点，完全自定义一套layout布局方案，可以实现意想不到的效果 这篇博客，我们主要讨论CollectionView使用原生layout的方法和相关属性，其他特点和更强的制定化，会在后面的博客中介绍 二、先来实现一个最简单的九宫格类布局在了解UICollectionView的更多属性前，我们先来使用其进行一个最简单的流布局试试看，在controller的viewDidLoad中添加如下代码： 123456789101112131415 //创建一个layout布局类 UICollectionViewFlowLayout * layout = [[UICollectionViewFlowLayout alloc]init]; //设置布局方向为垂直流布局 layout.scrollDirection = UICollectionViewScrollDirectionVertical; //设置每个item的大小为100*100 layout.itemSize = CGSizeMake(100, 100); //创建collectionView 通过一个布局策略layout来创建 UICollectionView * collect = [[UICollectionView alloc]initWithFrame:self.view.frame collectionViewLayout:layout]; //代理设置 collect.delegate=self; collect.dataSource=self; //注册item类型 这里使用系统的类型 [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; [self.view addSubview:collect]; 这里有一点需要注意，collectionView在完成代理回调前，必须注册一个cell，类似如下: 1[collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; 这和tableView有些类似，又有些不同，因为tableView除了注册cell的方法外，还可以通过临时创建来做： 12345//tableView在从复用池中取cell的时候，有如下两种方法//使用这种方式如果复用池中无，是可以返回nil的，我们在临时创建即可- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;//6.0后使用如下的方法直接从注册的cell类获取创建，如果没有注册 会崩溃- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); 我们可以分析：因为UICollectionView是iOS6.0之前的新类，因此这里统一了从复用池中获取cell的方法，没有再提供可以返回nil的方式，并且在UICollectionView的回调代理中，只能使用从复用池中获取cell的方式进行cell的返回，其他方式会崩溃，例如： 1234567891011121314//这是正确的方法-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125;//这样做会崩溃-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123;// UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath];// cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; UICollectionViewCell * cell = [[UICollectionViewCell alloc]init]; return cell;&#125; 上面错误的方式会崩溃，信息如下，让我们使用从复用池中取cell的方式： 上面的设置完成后，我们来实现如下几个代理方法： 这里与TableView的回调方式十分类似 1234567891011121314//返回分区个数-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;//返回每个分区的item个数-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 10;&#125;//返回每个item-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 效果如下： 同样，如果内容的大小超出一屏，和tableView类似是可以进行视图滑动的。 还有一点细节，我们在上面设置布局方式的时候设置了垂直布局： 123layout.scrollDirection = UICollectionViewScrollDirectionVertical;//这个是水平布局//layout.scrollDirection = UICollectionViewScrollDirectionHorizontal; 这样系统会在一行充满后进行第二行的排列，如果设置为水平布局，则会在一列充满后，进行第二列的布局，这种方式也被称为流式布局 三、UICollectionView中的常用方法和属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//通过一个布局策略初识化CollectionView- (instancetype)initWithFrame:(CGRect)frame collectionViewLayout:(UICollectionViewLayout *)layout;//获取和设置collection的layout@property (nonatomic, strong) UICollectionViewLayout *collectionViewLayout;//数据源和代理@property (nonatomic, weak, nullable) id &lt;UICollectionViewDelegate&gt; delegate;@property (nonatomic, weak, nullable) id &lt;UICollectionViewDataSource&gt; dataSource;//从一个class或者xib文件进行cell(item)的注册- (void)registerClass:(nullable Class)cellClass forCellWithReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forCellWithReuseIdentifier:(NSString *)identifier;//下面两个方法与上面相似，这里注册的是头视图或者尾视图的类//其中第二个参数是设置 头视图或者尾视图 系统为我们定义好了这两个字符串//UIKIT_EXTERN NSString *const UICollectionElementKindSectionHeader NS_AVAILABLE_IOS(6_0);//UIKIT_EXTERN NSString *const UICollectionElementKindSectionFooter NS_AVAILABLE_IOS(6_0);- (void)registerClass:(nullable Class)viewClass forSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier;- (void)registerNib:(nullable UINib *)nib forSupplementaryViewOfKind:(NSString *)kind withReuseIdentifier:(NSString *)identifier;//这两个方法是从复用池中取出cell或者头尾视图- (__kindof UICollectionViewCell *)dequeueReusableCellWithReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;- (__kindof UICollectionReusableView *)dequeueReusableSupplementaryViewOfKind:(NSString *)elementKind withReuseIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;//设置是否允许选中 默认yes@property (nonatomic) BOOL allowsSelection;//设置是否允许多选 默认no@property (nonatomic) BOOL allowsMultipleSelection;//获取所有选中的item的位置信息- (nullable NSArray&lt;NSIndexPath *&gt; *)indexPathsForSelectedItems; //设置选中某一item，并使视图滑动到相应位置，scrollPosition是滑动位置的相关参数，如下：/*typedef NS_OPTIONS(NSUInteger, UICollectionViewScrollPosition) &#123; //无 UICollectionViewScrollPositionNone = 0, //垂直布局时使用的 对应上中下 UICollectionViewScrollPositionTop = 1 &lt;&lt; 0, UICollectionViewScrollPositionCenteredVertically = 1 &lt;&lt; 1, UICollectionViewScrollPositionBottom = 1 &lt;&lt; 2, //水平布局时使用的 对应左中右 UICollectionViewScrollPositionLeft = 1 &lt;&lt; 3, UICollectionViewScrollPositionCenteredHorizontally = 1 &lt;&lt; 4, UICollectionViewScrollPositionRight = 1 &lt;&lt; 5&#125;;*/- (void)selectItemAtIndexPath:(nullable NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UICollectionViewScrollPosition)scrollPosition;//将某一item取消选中- (void)deselectItemAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;//重新加载数据- (void)reloadData;//下面这两个方法，可以重新设置collection的布局，后面的方法多了一个布局完成后的回调，iOS7后可以用//使用这两个方法可以产生非常炫酷的动画效果- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated;- (void)setCollectionViewLayout:(UICollectionViewLayout *)layout animated:(BOOL)animated completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);//下面这些方法更加强大，我们可以对布局更改后的动画进行设置//这个方法传入一个布局策略layout，系统会开始进行布局渲染，返回一个UICollectionViewTransitionLayout对象//这个UICollectionViewTransitionLayout对象管理动画的相关属性，我们可以进行设置- (UICollectionViewTransitionLayout *)startInteractiveTransitionToCollectionViewLayout:(UICollectionViewLayout *)layout completion:(nullable UICollectionViewLayoutInteractiveTransitionCompletion)completion NS_AVAILABLE_IOS(7_0);//准备好动画设置后，我们需要调用下面的方法进行布局动画的展示，之后会调用上面方法的block回调- (void)finishInteractiveTransition NS_AVAILABLE_IOS(7_0);//调用这个方法取消上面的布局动画设置，之后也会进行上面方法的block回调- (void)cancelInteractiveTransition NS_AVAILABLE_IOS(7_0);//获取分区数- (NSInteger)numberOfSections;//获取某一分区的item数- (NSInteger)numberOfItemsInSection:(NSInteger)section;//下面两个方法获取item或者头尾视图的layout属性，这个UICollectionViewLayoutAttributes对象//存放着布局的相关数据，可以用来做完全自定义布局，后面博客会介绍- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath;//获取某一点所在的indexpath位置- (nullable NSIndexPath *)indexPathForItemAtPoint:(CGPoint)point;//获取某个cell所在的indexPath- (nullable NSIndexPath *)indexPathForCell:(UICollectionViewCell *)cell;//根据indexPath获取cell- (nullable UICollectionViewCell *)cellForItemAtIndexPath:(NSIndexPath *)indexPath;//获取所有可见cell的数组- (NSArray&lt;__kindof UICollectionViewCell *&gt; *)visibleCells;//获取所有可见cell的位置数组- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleItems;//下面三个方法是iOS9中新添加的方法，用于获取头尾视图- (UICollectionReusableView *)supplementaryViewForElementKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(9_0);- (NSArray&lt;UICollectionReusableView *&gt; *)visibleSupplementaryViewsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);- (NSArray&lt;NSIndexPath *&gt; *)indexPathsForVisibleSupplementaryElementsOfKind:(NSString *)elementKind NS_AVAILABLE_IOS(9_0);//使视图滑动到某一位置，可以带动画效果- (void)scrollToItemAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UICollectionViewScrollPosition)scrollPosition animated:(BOOL)animated;//下面这些方法用于动态添加，删除，移动某些分区获取items- (void)insertSections:(NSIndexSet *)sections;- (void)deleteSections:(NSIndexSet *)sections;- (void)reloadSections:(NSIndexSet *)sections;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;- (void)insertItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)deleteItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)reloadItemsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths;- (void)moveItemAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局","slug":"138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局","date":"2015-10-26T16:00:00.000Z","updated":"2021-07-03T12:39:40.831Z","comments":true,"path":"2015/10/27/138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局/","link":"","permalink":"http://huishao.cc/2015/10/27/138iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局/","excerpt":"","text":"iOS流布局UICollectionView系列三——使用FlowLayout进行更灵活布局一、引言前面的博客介绍了UICollectionView的相关方法和其协议中的方法，但对布局的管理类UICollectionViewFlowLayout没有着重探讨，这篇博客介绍关于布局的相关设置和属性方法。 UICollectionView的简单使用：http://my.oschina.net/u/2340880/blog/522613 UICollectionView相关协议方法：http://my.oschina.net/u/2340880/blog/522613 通过layout的设置，我们可以编写更加灵活的布局效果。 二、将九宫格式的布局进行升级在第一篇博客中，通过UICollectionView，我们很轻松的完成了一个九宫格的布局，但是如此中规中矩的布局方式，有时候并不能满足我们的需求，有时我们需要每一个Item展示不同的大小，代码如下： 123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init]; layout.scrollDirection = UICollectionViewScrollDirectionVertical; UICollectionView *collect = [[UICollectionView alloc]initWithFrame:CGRectMake(0, 0, 320, 400) collectionViewLayout:layout]; collect.delegate=self; collect.dataSource=self; [collect registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;cellid&quot;]; ; [self.view addSubview:collect]; &#125;//设置每个item的大小，双数的为50*50 单数的为100*100-(CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; if (indexPath.row%2==0) &#123; return CGSizeMake(50, 50); &#125;else&#123; return CGSizeMake(100, 100); &#125;&#125;//代理相应方法-(NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView&#123; return 1;&#125;-(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 100;&#125;-(UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell * cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;cellid&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; return cell;&#125; 效果如下： 现在的布局效果是不是炫酷了许多。 三、UICollectionViewFlowLayout相关属性方法UICollectionViewFlowLayout是系统提供给我们一个封装好的流布局设置类，其中有一些布局属性我们可以进行设置： 设置行与行之间的间距最小距离 @property (nonatomic) CGFloat minimumLineSpacing; 设置列与列之间的间距最小距离 @property (nonatomic) CGFloat minimumInteritemSpacing; 设置每个item的大小 @property (nonatomic) CGSize itemSize; 设置每个Item的估计大小，一般不需要设置 @property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); 设置布局方向 @property (nonatomic) UICollectionViewScrollDirection scrollDirection; 这个UICollectionViewScrollDirection的枚举如下： 1234typedef NS_ENUM(NSInteger, UICollectionViewScrollDirection) &#123; UICollectionViewScrollDirectionVertical,//水平布局 UICollectionViewScrollDirectionHorizontal//垂直布局&#125;; 设置头视图尺寸大小 @property (nonatomic) CGSize headerReferenceSize; 设置尾视图尺寸大小 @property (nonatomic) CGSize footerReferenceSize; 设置分区的EdgeInset @property (nonatomic) UIEdgeInsets sectionInset; 这个属性可以设置分区的偏移量，例如我们在刚才的例子中添加如下设置： 1 layout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20); 效果如下，会看到分区的边界闪出了20像素 下面这两个方法设置分区的头视图和尾视图是否始终固定在屏幕上边和下边 @property (nonatomic) BOOL sectionHeadersPinToVisibleBounds NS_AVAILABLE_IOS(9_0); @property (nonatomic) BOOL sectionFootersPinToVisibleBounds NS_AVAILABLE_IOS(9_0); 四、动态的配置layout的相关属性UICollectionViewDelegateFlowLayout上面的方法在创建FlowLayout时静态的进行设置，如果我们需要动态的设置这些属性，就像我们例子中的，每个item的大小会有差异，我们可以通过代理来实现。 UICollectionViewDelegateFlowLayout是UICollectionViewDelegate的子协议，其中常用方法如下，我们只需要实现我们需要的即可： 动态设置每个Item的尺寸大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath; 动态设置每个分区的EdgeInsets - (UIEdgeInsets)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout insetForSectionAtIndex:(NSInteger)section; 动态设置每行的间距大小 - (CGFloat)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout minimumLineSpacingForSectionAtIndex:(NSInteger)section; 动态设置每列的间距大小 - (CGFloat)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout minimumInteritemSpacingForSectionAtIndex:(NSInteger)section; 动态设置某个分区头视图大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout referenceSizeForHeaderInSection:(NSInteger)section; 动态设置某个分区尾视图大小 - (CGSize)collectionView:(UICollectionView )collectionView layout:(UICollectionViewLayout)collectionViewLayout referenceSizeForFooterInSection:(NSInteger)section; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Xcode真机测试could not find developer disk image解决方法","slug":"135Xcode真机测试could not find developer disk image解决方法","date":"2015-10-24T16:00:00.000Z","updated":"2021-07-03T12:37:13.275Z","comments":true,"path":"2015/10/25/135Xcode真机测试could not find developer disk image解决方法/","link":"","permalink":"http://huishao.cc/2015/10/25/135Xcode真机测试could not find developer disk image解决方法/","excerpt":"","text":"Xcode真机测试could not find developer disk image解决方法在使用Xcode进行真机调试的时候，有时根据真机的系统不同，会出现could not find developer disk image 错误，这是由于真机系统过高或者过低，Xcode中没有匹配的配置包文件，我们可以通过这个路径进入配置包的存放目录： /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 里面有类似这样的一些文件夹，如果这些文件夹中没有包含我们真机的系统，则不能进行真机测试。但是我们可以通过将相应的配置包添加入这个文件夹来解决问题： 说了解决的方法，不提供文件，会让大家觉得坑爹，下面给大家一个链接，里面有从iOS4.2到9.1所有版本的配置包，大家各取所需，不用感谢我： http://pan.baidu.com/s/1qYIQWjE。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"watchOS中进行异步图片加载和缓存的策略","slug":"134watchOS中进行异步图片加载和缓存的策略","date":"2015-10-23T16:00:00.000Z","updated":"2021-07-03T12:33:30.631Z","comments":true,"path":"2015/10/24/134watchOS中进行异步图片加载和缓存的策略/","link":"","permalink":"http://huishao.cc/2015/10/24/134watchOS中进行异步图片加载和缓存的策略/","excerpt":"","text":"watchOS中进行异步图片加载和缓存的策略一、引言iWatch是智能手表的一次革命。iWatch的应用也将会越来越多，基于watch的一些特点，watchOS的开发者需要更加精益的把握watch的UI和性能。运用watchOS自带的缓存体系进行数据的缓存，是增强用户体验度的一种方式，这篇博客，介绍在watchOS中进行异步加载图片和缓存的方法，愿与志同道合的朋友，一起交流。 关于watchOS中的缓存框架，在这里：http://my.oschina.net/u/2340880/blog/519023 。 二、存储的命名规则在进行设计之前，我们应该先了解，watchOS的缓存容量为最大20M，因为有限，我们更应该认真的利用每一份空间，因此，缓存我们不仅可以存，在即将装满的时候，我们还要有办法从缓存中删去一些东西，让出空间，那么应该删除哪些东西了，我们应该都可以想到，当然是旧的了，把最早的缓存删掉，所以，在存的时候，我们要设计一种规则，可以保存存入的时间，并且不影响我寻找这个缓存文件。我的方法是通过格式化的命名： 1234567891011121314//这是一个规范缓存命名的方法func checkString(str:NSString)-&gt;NSString&#123; let result:NSMutableString=NSMutableString() //先将所有的非字母和数字剔除掉 for var i=0 ; i&lt;str.length ; i++ &#123; if (str.characterAtIndex(i)&gt;=48&amp;&amp;str.characterAtIndex(i)&lt;=57)||(str.characterAtIndex(i)&gt;=65&amp;&amp;str.characterAtIndex(i)&lt;=90)||(str.characterAtIndex(i)&gt;=97&amp;&amp;str.characterAtIndex(i)&lt;=122)&#123; result.appendFormat(&quot;%c&quot;,str.characterAtIndex(i)) &#125; &#125; //拼接上当前时间戳 let date:Double = NSDate().timeIntervalSince1970 result.appendFormat(&quot;?%.0f&quot;,date) return result&#125; 通过？符号将名称和时间戳进行了拼接。 二、进行异步加载图片和缓存这一步是如下的设计思路：通过图片url从缓存的路径中进行寻找，如果有，直接取出图片，如果没有，开启一个线程进行异步加载，完成后刷新主线程UI并将图片文件规范命名后进行缓存： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//进行存取缓存的操作//取出watchOS的缓存目录let imagedic:NSDictionary = WKInterfaceDevice().cachedImages as NSDictionary //取图片存储的名称 let imageUrl:NSMutableString=NSMutableString() //这里的url是外界传进来的图片地址url，进行去掉特殊字符 for var i=0 ; i&lt;url?.length ; i++ &#123; if (url?.characterAtIndex(i)&gt;=48&amp;&amp;url?.characterAtIndex(i)&lt;=57)||(url?.characterAtIndex(i)&gt;=65&amp;&amp;url?.characterAtIndex(i)&lt;=90)||(url?.characterAtIndex(i)&gt;=97&amp;&amp;url?.characterAtIndex(i)&lt;=122)&#123; imageUrl.appendFormat(&quot;%c&quot;,(url?.characterAtIndex(i))!) &#125; &#125; //查找缓存中是否有图片 //遍历watchOS的缓存目录 for var i=0 ; i&lt;imagedic.allKeys.count ; i++ &#123; //通过规定好的？进行分割 let str:NSArray = imagedic.allKeys[i].componentsSeparatedByString(&quot;?&quot;) if str[0].isEqualToString(imageUrl as String) &#123; //找到图片 view是要设置的interfaceImage view.setImageNamed(imagedic.allKeys[i] as? String) return; &#125; &#125; //设置缺省图片 这里是外界传进来的缺省图片，如果需要下载，先设置缺省图片 if defaultImage != nil &#123; view.setImageNamed(defaultImage as? String) &#125; //进行下载和存储 let dispath = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) //在新的线程中下载 dispatch_async(dispath, &#123; () -&gt; Void in let imgURL:NSURL = NSURL(string: url as! String)! let imageData:NSData? = NSData(contentsOfURL: imgURL) if imageData != nil &#123; //主线程中刷新 dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in view.setImageData(imageData!) &#125;) //写缓存 如果缓存满了 就删掉时间戳最早的一张缓存 //这个方法会返回bool值，判断是否存入成功 while !WKInterfaceDevice().addCachedImageWithData(imageData!, name: checkString(url!) as String) &#123; //如果存入失败，删去时间戳最早的缓存 var temp:NSString? //保存最早的缓存名称 var result:NSString? for var i=0 ; i&lt;imagedic.allKeys.count ; i++ &#123; let str:NSArray = imagedic.allKeys[i].componentsSeparatedByString(&quot;?&quot;) if temp == nil &#123; temp = str[1] as? NSString result = imagedic.allKeys[i] as! String break &#125; if str[1].doubleValue &lt; temp?.doubleValue &#123; //找到更早的缓存 temp = str[1] as? NSString result = imagedic.allKeys[i] as! String &#125; &#125; //删掉缓存 WKInterfaceDevice().removeCachedImageWithName(result as! String) &#125; &#125; &#125;) 上面的代码和注释，已经介绍了所有的思路，有错误之处或者更好的方式，还望多多指点。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门九——Watch帧动画的实现","slug":"133AppleWatch开发入门九——Watch帧动画的实现","date":"2015-10-18T16:00:00.000Z","updated":"2021-07-03T12:31:44.420Z","comments":true,"path":"2015/10/19/133AppleWatch开发入门九——Watch帧动画的实现/","link":"","permalink":"http://huishao.cc/2015/10/19/133AppleWatch开发入门九——Watch帧动画的实现/","excerpt":"","text":"AppleWatch开发入门九——Watch帧动画的实现动画一直是iOS系统的一大亮点，CoreAnimation和粒子效果的支持，开发者可以很容易的做出效果炫酷的动画特效。在watchOS中，由于性能和屏幕尺寸的限制，对于动画，并没有强大的框架支持，但是这并不是说开发者就没办法在watch上添加动画的特效了。在watchOS中唯一可以让开发者用于动画操作的就是帧动画。 和iOS类似，watchOS中的真动画也是通过UIImage对象的合集来展示的。只是设置和用法略有不同。 首先，watchOS中帧动画的操作被单独封装成了一个协议，当然，WKInterfaceImage类是遵守了这个协议的： 12345678public protocol WKImageAnimatable : NSObjectProtocol &#123; //从默认帧开始播放动画 public func startAnimating() //播放一个指定范围的帧动画 NSRange是帧的范围，durtion是播放一遍的时间，repeatCount是重复播放次数，0为无限循环 public func startAnimatingWithImagesInRange(imageRange: NSRange, duration: NSTimeInterval, repeatCount: Int) //停止播放动画 public func stopAnimating()&#125; 创建帧动画的步骤与一些注意： 1、关联一个视图中的WKInterfaceImage对象 2、所有帧动画的图片帧必须有统一的格式：比如image1.png，image2.png等等 3、给WKInterfaceImage对象设置帧前缀： 1imageInterface.setImageNamed(&quot;image&quot;) 注意：这里使用的方法和设置图片的方法一样，但是参数有别，图片的设置需要完整的图片名，动画帧前缀的设置只要设置帧图片的前缀。 4、开始动画： 1 imageInterface.startAnimatingWithImagesInRange(NSRange(location: 1, length: 3), duration: 3, repeatCount: 0) 注意：素材帧必须放入watchKit App这个Target中，才可以使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门七——watchOS中通知的应用","slug":"131AppleWatch开发入门七——watchOS中通知的应用","date":"2015-10-18T16:00:00.000Z","updated":"2021-07-03T12:30:06.427Z","comments":true,"path":"2015/10/19/131AppleWatch开发入门七——watchOS中通知的应用/","link":"","permalink":"http://huishao.cc/2015/10/19/131AppleWatch开发入门七——watchOS中通知的应用/","excerpt":"","text":"AppleWatch开发入门七——watchOS中通知的应用一、引言在iOS系统中，支持的通知有两种类型：本地通知和远程通知。本地通知多用于计时类通知，远程的又称推送，多用于一些提示动态的提示信息。这里有相关通知的一些知识总结： 本地推送：http://my.oschina.net/u/2340880/blog/405491。 远程推送：http://my.oschina.net/u/2340880/blog/413584。 在watch中，通知是和iphone同步的，在iphone上的App收到通知的同时，会默认也推送到watch上，基于watch的穿戴性，对用户来说，它上面的通知信息将比iphone更加及时。 二、WatchOS通知概览首先，watch上的通知分为两部分：short-look和long-lock。简而言之，short-look，可以理解为一个简单的通知预览，它会将通知发起的APP和主要标题等信息展示给你，让你一目了然，当用户抬起手腕，查看这个通知一定时间，这个短通知就会转换为long-look通知。short-look的通知界面我们不能够自定义，系统为我们设计好了模样，如下： 长通知的界面我们是可以进行一定程度上的自定义的，并且可以添加按钮等逻辑操作。 long-look也分为两种界面，静态界面和动态界面。这个也好理解，静态界面是我们在写程序时就定义好的界面，在通知发送到watch上时，界面会自动匹配通知内容进行显示。动态的界面则是当收到通知时，会先执行我们相应的配置代码，之后在进行通知界面的展示。一个long-look界面大致如下： 在long-lock中，界面定义为三个部分，头部标题栏，自定义视图栏和按钮交互区。头部的标题栏我们不能自定义，它是一个半透明的上面有App图标和名字的横栏。其下面是我们可以自定义的区域，我们可以在storyBoard中拉入文本和图片。最下面是一些交互按钮，其名称等配置信息在推送的文件中定义。 三、如何在模拟器上模拟远程推送在watchOS模拟器上，Xcode为我们准备好了一种可以模拟测试推送的方式。如果我们创建项目时，选择了NotifacationScene,则Xcode会默认为我们创建一个apns文件： 这个文件就是模拟推送的相关配置文件，如果没有，我们也可以手动来创建： 文件中的内容格式如下： 12345678910111213141516171819&#123; &quot;aps&quot;: &#123; &quot;alert&quot;: &#123; &quot;body&quot;: &quot;通知&quot;, &quot;title&quot;: &quot;通知来了&quot; &#125;, &quot;category&quot;: &quot;myCategory&quot; &#125;, &quot;WatchKit Simulator Actions&quot;: [ &#123; &quot;title&quot;: &quot;First Button&quot;, &quot;identifier&quot;: &quot;firstButtonAction&quot; &#125; ], &quot;customKey&quot;: &quot;Use this file to define a testing payload for your notifications. The aps dictionary specifies the category, alert text and title. The WatchKit Simulator Actions array can provide info for one or more action buttons in addition to the standard Dismiss button. Any other top level keys are custom payload. If you have multiple such JSON files in your project, you&apos;ll be able to select them when choosing to debug the notification interface of your Watch App.&quot;&#125; 这是一些json格式的数据，其中alert是对推送内容的设置，body会显示在long-look的标题栏，title会显示在short-look的标题栏，Actions数组中是对按钮就行配置，每一个按钮可以设置一个标题和id，标题用于在推送界面显示，id用于处理点击按钮后触发的逻辑。 创建好这个，我们可以来试着测试一下推送的界面，选择推送工程，运行即可： 四、long-look的静态界面和动态界面上面提到过，long-look分为静态界面和动态界面两种，当我们在storyBoard中拉入一个Notification Interface Controller的时候，可以选择同时创建动态界面，勾选 Has Dynamic Interface： 这时，在storyBoard中是如下模样： 我们在创建一个文件，继承于WKUserNotificationInterfaceController，并将storyBoard中动态的的推送controller的class设置为我们创建的类： 注意，这里设置的是动态的Interface，也就是上面右边的controller。之后运行，你会发现效果并没有什么改变，那是因为系统默认会从静态界面加载推送界面，我们需要在NotifacationController代码中做一些操作： 1234567891011121314151617//在NotificationController中重写下面两个方法//这个用于本地推送override func didReceiveLocalNotification(localNotification: UILocalNotification, withCompletion completionHandler: ((WKUserNotificationInterfaceType) -&gt; Void)) &#123; //在这里做一些动态界面的加载操作，比如可以根据推送的数据 设置图片 文字等 //下面这个方法决定是加载静态的界面还是动态的界面 //Custom是加载动态界面 //default是加载静态界面 completionHandler(.Custom) &#125; //设个用于远程推送 和上面方法类似override func didReceiveRemoteNotification(remoteNotification: [NSObject : AnyObject], withCompletion completionHandler: ((WKUserNotificationInterfaceType) -&gt; Void)) &#123; completionHandler(.Custom) &#125; 五、触发推送点击事件首先，我们多配置几个点击按钮，在apns文件中如下配置： 1234567891011121314151617&quot;WatchKit Simulator Actions&quot;: [ &#123; &quot;title&quot;: &quot;第一&quot;, &quot;identifier&quot;: &quot;one&quot; &#125;, &#123; &quot;title&quot;: &quot;第二&quot;, &quot;identifier&quot;: &quot;two&quot; &#125;, &#123; &quot;title&quot;: &quot;第三&quot;, &quot;identifier&quot;: &quot;three&quot; &#125; ], 在我们watch App的InterfaceController中实现如下的方法： 12345678910//重写下面两个方法来响应点击事件//远程推送的方法override func handleActionWithIdentifier(identifier: String?, forRemoteNotification remoteNotification: [NSObject : AnyObject]) &#123; //通过我们配置的按钮id来区分点击的按钮 处理响应的逻辑 print(identifier) &#125;//本地推送的方法override func handleActionWithIdentifier(identifier: String?, forLocalNotification localNotification: UILocalNotification) &#123; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门八——Watch中图片缓存的处理","slug":"132AppleWatch开发入门八——Watch中图片缓存的处理","date":"2015-10-18T16:00:00.000Z","updated":"2021-07-03T12:30:58.537Z","comments":true,"path":"2015/10/19/132AppleWatch开发入门八——Watch中图片缓存的处理/","link":"","permalink":"http://huishao.cc/2015/10/19/132AppleWatch开发入门八——Watch中图片缓存的处理/","excerpt":"","text":"AppleWatch开发入门八——Watch中图片缓存的处理由于iWatch在存储和性能上都和iPhone有着很大的差距，这就要求开发者对程序有更高的性能优化，下载与传输图像，在Watch操作中是一个非时的过程，因此，watchOS中为我们提供了一个缓存图片的框架，并且接口和使用都非常简单。 WatchOS中缓存图片的方法封装在WKInterfaceDevice这个类中，其中添加图片进入缓存的方法如下： 12345//添加一个UIImage对象进入缓存目录，设置name，当我们设置图片时，可以直接通过name进行设置public func addCachedImage(image: UIImage, name: String) -&gt; Bool//添加一个Data图片进入缓存目录，设置name，当我们设置图片时，可以直接通过name进行设置public func addCachedImageWithData(imageData: NSData, name: String) -&gt; Bool//上面两个方法的返回值用于判断缓存是否成功，因为watch缓存目录的大小有限，可能会失败 同样，我们也可以将已经缓存的图片数据删除掉： 1234 //根据name删除一个图片数据 public func removeCachedImageWithName(name: String) //删除缓存目录中所有的图片数据 public func removeAllCachedImages() 我们也可以通过下面的方法获取所有缓存图片的name值： 12//下面这个函数返回一个字典，string为缓存图片的name值，NSNumber为相应的图片大小，单位为bpublic var cachedImages: [String : NSNumber] &#123; get &#125; 注意：系统缓存目录的大小为20M，如果缓存失败，可以尝试删掉旧的缓存。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"iOS8统一的系统提示控件——UIAlertController","slug":"130iOS8统一的系统提示控件——UIAlertController","date":"2015-10-16T16:00:00.000Z","updated":"2021-07-03T12:29:15.019Z","comments":true,"path":"2015/10/17/130iOS8统一的系统提示控件——UIAlertController/","link":"","permalink":"http://huishao.cc/2015/10/17/130iOS8统一的系统提示控件——UIAlertController/","excerpt":"","text":"iOS8统一的系统提示控件——UIAlertController一、引言相信在iOS开发中，大家对UIAlertView和UIActionSheet一定不陌生，这两个控件在UI设计中发挥了很大的作用。然而如果你用过，你会发现这两个控件的设计思路有些繁琐，通过创建设置代理来进行界面的交互，将代码逻辑分割了，并且很容易形成冗余代码。在iOS8之后，系统吸引了UIAlertController这个类，整理了UIAlertView和UIActionSheet这两个控件，在iOS中，如果你扔使用UIAlertView和UIActionSheet，系统只是会提示你使用新的方法，iOS9中，这两个类被完全弃用，但这并不说明旧的代码将不能使用，旧的代码依然可以工作很好，但是会存在隐患，UIAlertController，不仅系统推荐，使用更加方便，结构也更加合理，作为开发者，使用新的警示控件，我们何乐而不为呢。这里有旧的代码的使用方法： UIAlertView使用：http://my.oschina.net/u/2340880/blog/408873。 UIActionSheet使用：http://my.oschina.net/u/2340880/blog/409907。 二、UIAlertController的使用从这个类的名字我们就可以看出，对于警示控件，设计的思路不再是View而是Controller。通过present和push进行呼出，而不是以前的show方法。另一个机制改变的地方是，其中按钮的触发方法不再通过代理处理，而是将按钮封装成了类:UIAlertAction。详细方法及使用如下： 12345 UIAlertController * con = [UIAlertController alertControllerWithTitle:@&quot;新的&quot; message:@&quot;看看样子&quot; preferredStyle:UIAlertControllerStyleAlert]; [con addAction:[UIAlertAction actionWithTitle:@&quot;仔细看&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; //按钮触发的方法 &#125;]]; [self presentViewController:con animated:YES completion:nil]; 上面的代码，会在屏幕上呼出警告框，如下： 初始化方法中的preferref参数是一个枚举，决定是提示框或者抽屉列表： 1234typedef NS_ENUM(NSInteger, UIAlertControllerStyle) &#123; UIAlertControllerStyleActionSheet = 0,//抽屉 UIAlertControllerStyleAlert//警告框&#125; 上面的addAction方法添加了一个封装了方法的按钮，UIAlertAction类的构造十分简单，如下： 12345678//初始化方法+ (instancetype)actionWithTitle:(nullable NSString *)title style:(UIAlertActionStyle)style handler:(void (^ __nullable)(UIAlertAction *action))handler;//获取标题@property (nullable, nonatomic, readonly) NSString *title;//获取风格@property (nonatomic, readonly) UIAlertActionStyle style;//设置是否有效@property (nonatomic, getter=isEnabled) BOOL enabled; AlertAction的风格是如下的枚举： 12345typedef NS_ENUM(NSInteger, UIAlertActionStyle) &#123; UIAlertActionStyleDefault = 0,//默认的风格 UIAlertActionStyleCancel,//取消按钮的风格 UIAlertActionStyleDestructive//警告的风格&#125; 风格效果如下： 三、UIAlertController其他属性和方法@property (nonatomic, readonly) NSArray *actions; 获取所有AlertAction @property (nonatomic, strong, nullable) UIAlertAction *preferredAction NS_AVAILABLE_IOS(9_0); iOS9后新增加的属性，可以使某个按钮更加突出，只能设置已经在actions数组中的AkertAction，会使设置的按钮更加显眼，如下： - (void)addTextFieldWithConfigurationHandler:(void (^ __nullable)(UITextField *textField))configurationHandler; 添加一个textField，以前的相关控件，虽然也可以添加textField，但是定制化能力非常差，这个新的方法中有一个configurationHandler代码块，可以将textField的相关设置代码放入这个代码块中，并且这个方法添加的textField个数不再限制于2个： 123456789 [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第1个&quot;; &#125;]; [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第2个&quot;; &#125;]; [con addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) &#123; textField.placeholder=@&quot;第3个&quot;; &#125;]; @property (nullable, nonatomic, readonly) NSArray *textFields; 获取所有textField的数组 @property (nullable, nonatomic, copy) NSString *title; 设置警示控件的标题 @property (nullable, nonatomic, copy) NSString *message; 设置警示控件的信息 @property (nonatomic, readonly) UIAlertControllerStyle preferredStyle; 获取警示控件的风格 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"AppleWatch开发入门六——Glance(预览)扩展的应用","slug":"129AppleWatch开发入门六——Glance(预览)扩展的应用","date":"2015-10-15T16:00:00.000Z","updated":"2021-07-03T12:28:10.990Z","comments":true,"path":"2015/10/16/129AppleWatch开发入门六——Glance(预览)扩展的应用/","link":"","permalink":"http://huishao.cc/2015/10/16/129AppleWatch开发入门六——Glance(预览)扩展的应用/","excerpt":"","text":"AppleWatch开发入门六——Glance(预览)扩展的应用一、简介Glance是watchOS中类似iOS的today插件一样的预览扩展。提供了Glance功能的WatchApp可以在手表主页上唤起Glance，展示app相关信息，然而这个扩展只能作为展示作用，并不能进行太多的交互，界面的布局也有很大的限制，因此，Glance的应用主要在于展示备忘信息等。特点如下： 1、扩展的样式布局我们并不能完全个性化，只能通过系统模板来布局。 2、扩展中不能添加交互功能，只能展示信息，点击界面间唤起WatchApp。 3、一个app只能享有一个Glance界面，并且是单屏的不可滑动。 二、创建一个Glance在我们创建WatchApp的时候，可以勾选创建Glance： 同样，如果这里没有勾选，我们也可以在storyBoard中拉入一个Glance界面： 可以发现，这里面的布局样式，我们不能做修改，只能使用系统提供的一些模板： 我们创建一个模板，可以将其中元素与文件关联，进行代码的动态设置。 在Xcode7中，在Scream中选择Glance项目，进行运行： 模拟器效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门五——菜单控件的使用","slug":"128AppleWatch开发入门五——菜单控件的使用","date":"2015-10-14T16:00:00.000Z","updated":"2021-07-03T12:26:47.796Z","comments":true,"path":"2015/10/15/128AppleWatch开发入门五——菜单控件的使用/","link":"","permalink":"http://huishao.cc/2015/10/15/128AppleWatch开发入门五——菜单控件的使用/","excerpt":"","text":"AppleWatch开发入门五——菜单控件的使用一、简介菜单也是WatchOS中一个重要的交互方式，限于Watch的屏幕尺寸，若将所有用户交互控件都紧密的排列进展示的UI中，那样难免会使用户操作困难，也会影响界面布局的简洁美观。因此，WatchOS的菜单机制是一层覆盖在屏幕上的交互界面，有如下的特点： 1、菜单是内置于InterfaceController中的，不需显式处理，只需对齐菜单项进行添加设置。 2、菜单最多可以容乃四个选项按钮。 3、通过重按可以呼出和隐藏菜单。 二、创建菜单的两种方式1、通过storyBoard创建在storyBoard中，我们可以将一个菜单控件拖入到interfaceController中： 在Menu中可以添加一些item，每个item都可以设置图片和文字： 图片的设置分为，自定义和系统两种，我们可以使用自己的图片作为菜单的图片，也可以使用系统为我们提供的一些图片，系统的图片参数是一个枚举，值如下： 12345678910111213141516171819public enum WKMenuItemIcon : Int &#123; case Accept // checkmark case Add // &apos;+&apos; case Block // circle w/ slash case Decline // &apos;x&apos; case Info // &apos;i&apos; case Maybe // &apos;?&apos; case More // &apos;...&apos; case Mute // speaker w/ slash case Pause // pause button case Play // play button case Repeat // looping arrows case Resume // circular arrow case Share // share icon case Shuffle // swapped arrows case Speaker // speaker icon case Trash // trash icon&#125; 这些枚举中提供了一些我们常用的功能图标。 菜单按钮的触发方法，我们可以通过拖拽Action的方式来添加，在Xcode7的模拟器中，我们使用command+shift+2可以切换到重按模式，模拟器效果如下： 2、通过代码来添加菜单选项前面提到过，菜单是内含于InterfaceController中的一个控件，在Interface中我们可以调用一些方法来添加菜单按钮，相关方法如下： 1234567 //添加一个菜单按钮，图片自定义 public func addMenuItemWithImage(image: UIImage, title: String, action: Selector) public func addMenuItemWithImageNamed(imageName: String, title: String, action: Selector) //添加一个系统图片的按钮 public func addMenuItemWithItemIcon(itemIcon: WKMenuItemIcon, title: String, action: Selector) //清除所有按钮 public func clearAllMenuItems() 示例代码如下： 1234567891011121314151617override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) self.addMenuItemWithItemIcon(WKMenuItemIcon.Share, title: &quot;分享&quot;, action:Selector(&quot;share&quot;)) self.addMenuItemWithItemIcon(WKMenuItemIcon.Decline, title: &quot;取消&quot;, action: Selector(&quot;cancle&quot;)) self.addMenuItemWithItemIcon(WKMenuItemIcon.Add, title: &quot;添加&quot;, action:Selector(&quot;add&quot;)) &#125; func share()&#123; print(&quot;分享&quot;) &#125; func add()&#123; print(&quot;add&quot;) &#125; func cancle()&#123; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门四——Table视图的应用","slug":"127AppleWatch开发入门四——Table视图的应用","date":"2015-10-14T16:00:00.000Z","updated":"2021-07-03T12:25:54.796Z","comments":true,"path":"2015/10/15/127AppleWatch开发入门四——Table视图的应用/","link":"","permalink":"http://huishao.cc/2015/10/15/127AppleWatch开发入门四——Table视图的应用/","excerpt":"","text":"AppleWatch开发入门四——Table视图的应用一、Watch上的TableWatchOS中的TableView和iOS中的TableView还是有很大的区别，在开发之前，首先我们应该明白WatchOS中的Table有哪些局限性和特点。下面几点是我总结WatchOS中Table的特殊之处： 1、Table只有行的概念，没有分区的概念，没有头尾视图的概念。 2、可以通过创建多个Table，来实现分区的效果。 3、因为Watch上是通过Gruop进行布局适应的，所以没有行高等设置。 4、Table没有代理，所有行的数据都是采用静态配置的方式，后面会介绍。 5、点击Table中的行触发的方法，是通过重写Interface中的方法来实现的。 二、创建一个Table在storyBoard中拖入你的Table，如下： 在Table上拉两个label： 每一个Table中包含一个TableRowController，实际上我们Table上的控件都是通过这个TableRowController进行管理的，因此如果我们需要在代码中控制TableRow上的内容，我们需要创建一个文件作为Table的TableRowController： 将storyBoard中TableRowController的类修改为我们创建的类并指定一个identifier： 然后，我们将两个label关联到TableRowController中： 123456import WatchKitclass TableRowController: NSObject &#123; @IBOutlet var numberLabel: WKInterfaceLabel! @IBOutlet var titleLabel: WKInterfaceLabel!&#125; 将Table关联到interfaceController中： 12345class InterfaceControllerMain: WKInterfaceController &#123; @IBOutlet var Table: WKInterfaceTable!&#125; 下面，我们开始在interface中对Table做相关配置，首先我们可以先观察一下WKInterfaceTable中有哪些方法和属性： 1234567891011121314151617181920public class WKInterfaceTable : WKInterfaceObject &#123; //设置行的类型，数组中对应存放行的类型，数组元素的个数，就是行数 /* 通过这个方法，我们可以创建每一行样式都不同的table，行的类型 实际上就是我们刚才用到的TableRowController，我们可以进行自定义 */ public func setRowTypes(rowTypes: [String]) //设置行数和类型 用于创建单一行类型的table public func setNumberOfRows(numberOfRows: Int, withRowType rowType: String) // repeating row name //这个get方法获取行数，用于我们遍历table中的行，进行内容设置 public var numberOfRows: Int &#123; get &#125; //这个方法会返回某一行，我们可以获取到后进行内容设置 public func rowControllerAtIndex(index: Int) -&gt; AnyObject? //插入一行 public func insertRowsAtIndexes(rows: NSIndexSet, withRowType rowType: String) //删除一行 public func removeRowsAtIndexes(rows: NSIndexSet) //滑动到某一行 public func scrollToRowAtIndex(index: Int)&#125; 了解了上面的方法，可以看出，WatchOS的Table配置非常简单易用，例如我们如下配置： 1234567891011121314151617@IBOutlet var Table: WKInterfaceTable! override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) let dic:Dictionary&lt;String,String&gt; = [&quot;中国建设银行&quot;:&quot;￥1000&quot;,&quot;中国农业银行&quot;:&quot;￥5000&quot;,&quot;中国银行&quot;:&quot;20000&quot;,&quot;招商银行&quot;:&quot;￥401&quot;,&quot;中国邮政储蓄&quot;:&quot;1100&quot;] //设置行数与类型 Table.setNumberOfRows(dic.count, withRowType: &quot;TableRowController&quot;) //遍历进行设置 let titleArray:Array&lt;String&gt; = Array(dic.keys) for var i=0 ; i &lt; dic.count ; i++ &#123; let row:TableRowController = Table.rowControllerAtIndex(i) as! TableRowController row.titleLabel.setText(titleArray[i]) row.numberLabel.setText(dic[titleArray[i]]) row.numberLabel.setTextColor(UIColor.grayColor()) &#125; // Configure interface objects here. &#125; 这样一个展示银行卡余额的界面我们就创建完成了，效果如下： 三、关于Table的点击事件上面我们提到，Table没有所谓代理方法，点击row的时候，我们也是通过两种方式进行逻辑跳转的，一种是在storyBoard中，我们通过拉线跳转，这时如需传值，我们需在interface中实现如下方法： 1 public func contextForSegueWithIdentifier(segueIdentifier: String, inTable table: WKInterfaceTable, rowIndex: Int) -&gt; AnyObject? 另一种方式，我们可以重写实现InterfaceController中的如下方法，来处理Table的点击事件： 1public func table(table: WKInterfaceTable, didSelectRowAtIndex rowIndex: Int) 无论哪种方式，我们都可以通过参数table和rowIndex来确认点击的具体是那个table和哪一行，进行传值和处理我们的逻辑。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门三——代码交互与控制器生命周期","slug":"126AppleWatch开发入门三——代码交互与控制器生命周期","date":"2015-10-13T16:00:00.000Z","updated":"2021-07-03T12:25:13.911Z","comments":true,"path":"2015/10/14/126AppleWatch开发入门三——代码交互与控制器生命周期/","link":"","permalink":"http://huishao.cc/2015/10/14/126AppleWatch开发入门三——代码交互与控制器生命周期/","excerpt":"","text":"AppleWatch开发入门三——代码交互与控制器生命周期一、引言在前两篇博客中，讨论了关于watch开发中框架与界面布局相关，然而主要的逻辑，终究还是要通过代码来实现的，在我们创建了项目之后，就会生成InterfaceController这个文件，它就是我们storyBoard中的入口视图控制器。 二、代码交互与控制器声明周期storyBoard中的控件我们可以通过拖拽的方式关联到文件中，Action和Outlet两种关联方式基本可以达到我们修改控件和处理业务逻辑的需求。 WKInterfaceController类似于iOS中的ViewController，是watch中主要用于展示界面的controller，我们的控件也都是基于这个容器中显示。在模板中，系统为我们提供了三个函数，这三个函数体现了watch一个界面的声明周期，如下： 123456789101112131415 //这个函数在初始化界面时会触发，通过context可以实现界面的传值 override func awakeWithContext(context: AnyObject?) &#123; super.awakeWithContext(context) &#125; //这个函数在界面即将展现时触发 类似于iOS中的ViewWillApear override func willActivate() &#123; // This method is called when watch view controller is about to be visible to user super.willActivate() &#125; //这个函数在界面消失后触发，类似于iOS中的ViewDidDisAppear override func didDeactivate() &#123; // This method is called when watch view controller is no longer visible super.didDeactivate() &#125; 三、watch中的界面跳转与传值与iOS类似，watchOS的界面跳转也有两种方式：model和push。同样，我们也可以通过storyBoard或者代码来进行跳转。 1、通过代码跳转与传值我们创建两个InterfaceController，界面如下： 通过代码跳转，我们需要给第二个controller设置一个id标识符： 在按钮触发的方法中，如下跳转： 12345 @IBAction func `switch`(value: Bool) &#123; //这里的context是传值的上下文 //在awakeWithContext方法中会将这个值取到 pushControllerWithName(&quot;InterfaceControllerTwo&quot;, context: &quot;我是传的值&quot;) &#125; 2、在storyBoard中设置跳转关系我们也可以直接在storyBoard中设置界面的跳转，按住control，拖拽按钮到要跳转的controller，会出现push和model菜单，选择后，当我们触发按钮方法时，就会跳转： 通过这种方式进行的跳转，在执行跳转之前，会执行如下这个函数： 123override func contextForSegueWithIdentifier(segueIdentifier: String) -&gt; AnyObject? &#123; return &quot;我是值&quot; &#125; 这个设置的返回值就是context上下文传递的值。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门二——界面布局","slug":"125AppleWatch开发入门二——界面布局","date":"2015-10-13T16:00:00.000Z","updated":"2021-07-03T12:24:34.928Z","comments":true,"path":"2015/10/14/125AppleWatch开发入门二——界面布局/","link":"","permalink":"http://huishao.cc/2015/10/14/125AppleWatch开发入门二——界面布局/","excerpt":"","text":"AppleWatch开发入门二——界面布局一、简介在iphone开发中，最基本的布局方式是通过frame，将控件的位置和大小固定在屏幕上，后来，由于手机屏幕的尺寸有了略微变化，有了autoresizing的布局框架，我们可以设置子视图随父视图的改变做一些相应的变化，再后来，iphone的尺寸与分辨率也越来越多，适配各个屏幕也成为了iOS开发者遇到的新的问题，幸运的是，autolayout机制的出现，大大减小了开发者在适配方面的成本。以上提到的两种布局方式，在以前博客中有讨论： 使用autoresizing进行动态布局：http://my.oschina.net/u/2340880/blog/423357 使用autolayout进行动态布局：http://my.oschina.net/u/2340880/blog/423500 在watch的布局方式中，我们需要抛弃iphone里的思路，重新接受一套新的布局框架。 首先，watch的屏幕不大，目前只有38mm和42mm两个尺寸，我们不可能在这个有限的空间里做非常复杂的界面效果，因此，在界面开发中，应该遵循便于使用和一目了然的原则。watch上的布局方式采用的是一种平面堆放的方式，不再有frame，也不再有约束，控件的布局方式只是一个挨着一个的平面堆放，也不可重叠。但在watch中，提供了group这样一种布局方式，可以让我们在布局中体现自由与个性的方面。 二、最基础的堆放布局我们在不使用group的时候，watch的布局采用的是最基础的堆放方式，从上到下依次排开，例如，我们添加四个label，效果如下： 通过改变label的添加顺序，可以改变其上下位置： 这种方式的布局高度并没有限制，我们可以一直往下排列，在watch上，会出现滑动的效果： 三、使用Group进行复杂的界面布局通过上面的布局方式，我们只能进行纵向的排列布局，这并不能达到我们的需求，WatchKit中提供那一套布局的模型：Group。 可以这样理解，group就是将屏幕分成了几各分区，我们可以设置各个分区的排列方式，例如水平或者垂直，通过这样的思路，完成复杂的watch界面布局，例如下面的效果： 这样效果的一个界面，就是将在屏幕中添加了三个Group，最上面的Gorup设置为水平排列模式，在其中添加了两个按钮和一个分割线，中间一个Group是垂直排列模式，放入了一个选择器和一个按钮，最下面一个Group也是水平排列模式，放入了一个按钮和一个时间栏。 扩展：所谓GroupGroup在界面布局上，不仅可以起到分区屏幕的作用，其还可以设置一些属性来使布局更加漂亮。在storyBoard右侧的设置菜单中，我们可以对这些属性进行操作： Layout：设置布局模式，分为水平布局和垂直布局两种 insert：可以设置内容区域偏移量，通过这个属性，我们可以使其中填充的控件四周留白 Spacing：其中填充的控件的间距 BackGround：设置Group的背景图案 Mode：设置背景图案的填充方式 Animate：出现时带动画 color：设置Group的背景颜色 Radius：设置Group的圆角度 四、布局中控件的位置和尺寸设置在iphone中，我们使用frame或者约束来控制控件的位置和尺寸，在watch中则简单很多，尺寸和位置都是固定的模式，我们只需要做一些设置即可。 1、控件尺寸的控制对于控件的尺寸，有三种模式，控件的width和Height都是通过这三个模式设置的： Relative to Container：自身的尺寸是按照容器的尺寸比例设置的。例如设置为0.5的话，当前控件的尺寸就是容纳其Group的一半。 Size To Fit Content:自身的尺寸与自身内容相关，例如，label中字数的多少决定了label的尺寸。 Fixed：手动设置一个固定的值。 2、控件位置的控制因为watch的界面十分简洁，对于控件的位置设置，是通过水平和垂直两个维度来设置的，通过设置每个维度的属性来控制其在容纳它的Group中的位置： Horizontal：left（左），center（中心），right（右） Vertical：top（上），center（中心），bottom（下） 一点注意:关于图片素材，你可以发现，在Extension和App文件夹中各有一个Assets.xcasssets组，只有将素材放入APP文件夹下的这个组watch才能使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"AppleWatch开发入门一——Watch的开发思路与应用框架","slug":"124AppleWatch开发入门一——Watch的开发思路与应用框架","date":"2015-10-12T16:00:00.000Z","updated":"2021-07-03T12:23:42.516Z","comments":true,"path":"2015/10/13/124AppleWatch开发入门一——Watch的开发思路与应用框架/","link":"","permalink":"http://huishao.cc/2015/10/13/124AppleWatch开发入门一——Watch的开发思路与应用框架/","excerpt":"","text":"AppleWatch开发入门一——Watch的开发思路与应用框架一、引言Apple Watch无疑是apple在智能手表领域的一次革命，如何在Watch上开发出实用且具有美感的应用，是iOS开发者们开始思考的一个问题，由于watch的随身性和快捷性，在某些方面，它有比iphone更加大的优势，要抓住watch的这些特点，开发出淋漓尽致的应用，就需要改变一些在iphone开发的思路，正如一句话：只有忘掉经验，才会有意想不到的突破。 这一系列博客，首先是总结我在公司watch项目开发中的一些经验，其次，还会加入一些我的理解和想法，如有错误，欢迎指正，如果对你有帮助，也欢迎撒花，😄。 二、开发前我们需要准备什么如果你没有开发过iphone，直接来做watch，我建议你不要这么做，不是不可以，而是目前所有的第三方应用都必须基于iphone的扩展，原生的watch应用，苹果目前还没有开放给开发者，因此实际上，我们在watch上可以做的事情十分有限，或许后续apple会开放更多接口，但是目前，我们必须放弃iphone开发的思路，从新开始。 1、watch应用的架构如上所说，完全脱离iphone的原生watch应用，我们目前还不能开发，所有第三方的watch应用必须基于一个iphone的host app。我们可以通过创建一个watch应用来观察一下，首先，在Xcode6.3后虽然支持watch的开发，但watch模拟器并不十分好用，Xcode7进行了优化，通过模拟器，基本可以完成我们的开发。用Xcode新建一个项目，之后我们在Xcode菜单中创建一个target： 选择apple Watch中的项目： 在如下的设置中，我们先将include Notification和Include Glance都勾选上，他们也是watch应用的一种表现方式，后面我们再说： 之后可以看到，我们的项目中会多了这样的几个文件夹： 我们只需要关注下结尾为Extension和App的这两个，从目录结构我们也可以看到，App文件夹中有Storyboard这个文件，Extension文件夹中主要是一些代码文件，这也正是我们需要了解的watch app的机制，实际运行与我们手表上的是App文件夹中的界面，而逻辑的代码实际上是运行在我们的手机中的，作为iphone App的扩展而存在，通过手机与手表的交互，来达到watch上的一些操作。 由此，我们可以理解，目前的第三方watch应用，watch类似于一个UI容器，通过与iphone的交互来达到一些逻辑和效果。 2、三种watch应用方式的用途在我们创建watch的扩展时，我们勾选了两个Scene，从字面我们也可以理解的差不多，这里加上我的理解，不是官方的解释： watch app：watch应用的主体，可以通过watch上的图标进入，可以与iphone进行交互与数据共享。 Notification：watch通知，会和iphone通知同步，包括本地的和远程的，这里和iphone不同在于有长通知和短通知的分别，在实际开发中，我们可以通过在后台添加参数来区分。在storyboard中的界面如下： Glance：预览界面，没有复杂的交互能力，也不能滑动，只能在单屏展示一些数据，点击后会进入主体watchApp中： 3、在模拟器上运行一个watch app选中我们的watch App工程，在Xcode7中运行如下： 如果你是以前版本的Xcode，可能需要在模拟器的Hardware中将其调出。 运行后，我们可以在watch模拟器上使用command+H来回到watch的主界面。 三、几点watch app的开发思路1、优秀的watch app无疑必须是简单，朴素，快捷而时效的。 2、watch上不能自定义手势，我们可以使用的只有滑动，点击和长按 3、必须改变iphone布局的思想，完全接受新的watch布局特点，进行创新 4、iphone的特点是界面的绚丽，watch则是简约 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}],"tags":[],"keywords":[{"name":"Apple Watch开发手记","slug":"Apple-Watch开发手记","permalink":"http://huishao.cc/categories/Apple-Watch开发手记/"}]},{"title":"iOS在应用中添加自定义字体","slug":"123iOS在应用中添加自定义字体","date":"2015-10-09T16:00:00.000Z","updated":"2021-07-03T12:22:07.449Z","comments":true,"path":"2015/10/10/123iOS在应用中添加自定义字体/","link":"","permalink":"http://huishao.cc/2015/10/10/123iOS在应用中添加自定义字体/","excerpt":"","text":"iOS在应用中添加自定义字体一、在应用中添加自定义字体的步骤1、网上提供的字体库有很多，下载完成后，将其导入工程中，一般为ttf格式。 2、注意Build Phases中的Copy Bundle Resources中是否导入了文件： 3、在项目的info.plist文件中添加字体键值如下： 这个数组中可以添加多个元素，多个字体库。 4、这时实际上我们已经将字体添加进了工程中，但是在在使用这个字体时，字体的名字有时和文件名是不一样的，我们需要知道真实的字体名称，通常情况下，我们会讲所有字体名称打印出来： 12345 for (NSString * name in [UIFont familyNames]) &#123; for (NSString * fo in [UIFont fontNamesForFamilyName:name]) &#123; NSLog(@&quot;%@&quot;,fo); &#125; &#125; 5、找到我们需要的字体，如下使用即可： 1 UIFont * font = [UIFont fontWithName:@&quot;yuweij&quot; size:14]; 二、如何快速的找到新添加的字体名字如果你将所有字体都打印了出来，在其中找到新的字体名称是身份困难的，尤其是当这个字体的名称和文件名相差甚远的时候，这是一件非常痛苦的事情。 为了在以后使用自定义字体的时候不必一次一次的经历这样的痛苦，在Xcode6.3的环境下，我将所有的系统字体获取后写入了plist文件，将这个plist文件导入项目中，通过如下方法，可以只打印出新增加的字体： 12345678910111213141516171819 NSString *paths=[[NSBundle mainBundle]pathForResource:@&quot;font&quot; ofType:@&quot;plist&quot;]; //得到完整的文件名 NSDictionary * rootDic = [NSDictionary dictionaryWithContentsOfFile:paths]; //遍历当前所有字体 for (NSString * name in [UIFont familyNames]) &#123; NSArray * fontArray = [rootDic objectForKey:name]; BOOL tip = NO; for (NSString * fo in [UIFont fontNamesForFamilyName:name]) &#123; for (NSString * tmp in fontArray) &#123; if ([tmp isEqualToString:fo]) &#123; tip=YES; break; &#125; &#125; if (!tip) &#123; NSLog(@&quot;%@&quot;,fo); &#125; &#125; &#125; 如果你也需要，字体集plist文件的地址：https://github.com/ZYHshao/YHBaseFoundationTest/tree/master/YHBase/BaseSouce。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective—C语言的新魅力——Nullability、泛型集合与类型延拓","slug":"122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓","date":"2015-10-08T16:00:00.000Z","updated":"2021-07-03T12:21:11.317Z","comments":true,"path":"2015/10/09/122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓/","link":"","permalink":"http://huishao.cc/2015/10/09/122Objective—C语言的新魅力——Nullability、泛型集合与类型延拓/","excerpt":"","text":"Objective—C语言的新魅力一、引言在Xcode7中，iOS9的SDK已经全面兼容了Objective-C的一些新特性和新功能。这些功能都只作用于编译期，对程序的运行并没有影响，因此，它可以很好的向下进行兼容，无缝的衔接低版本的iOS系统，那么这些特性有什么样的用处呢，作为开发者，我保证你一定会爱上他们，如果你可以将这些新特性都应用于你的开发，你的开发效率和代码质量，相比之前，会有一个很大的提升。 二、Nullability检测的支持在swift语言中，通过!和?可以将对象声明成Optional，用于在开发中标记这个对象是否可以为空。在OC中，以前是没有这样的功能的，因此我们在开发中会经常遇到因为某个函数应该返回实例而返回了空导致的崩溃。Nullability的主要用武之地，就是在这里，它可以起到提示开发者做是否为空得判断的提示。 打开Xcode7，系统的框架中已经支持了Nullability，如下： 12@property (nullable, nonatomic, readonly) ObjectType firstObject;@property (nullable, nonatomic, readonly) ObjectType lastObject; 这是NSArray中的两个属性，其中nullable关键字说明了这里可能返回空的值。 如果仅仅是在返回值中给开发者一些提示，你可能觉得应用并不大，是的，对开发者最大的帮助是这一特性可以用于函数的参数中，这样我们在调用函数时起到的提示作用，将是非常重要的，越是多人合作的项目，作用也越大。 例如： 123-(void)setValue:(NSNumber * _Nonnull )number&#123; &#125; 我们在调用函数时，如果传入了空值，编译器会给我们警告： 注意： 这一特性在Xcode6.3中就已经支持，但在Xcode7中又做了一些写法上的小改动，例如，在Xcode6.3中这样写： 123-(void)setValue:( nonnull NSNumber * )number&#123; &#125; 而在Xcode7中提倡我们使用第一种写法。 与之相关的几个关键字如下： 修饰参数 nonnull：不可为空 nullable: 可以为空 null_unspecified:不确定是否可以为空(极少情况) 在属性的声明中，还会有如下一个修饰符： null_resettable:set方法可以为nil，get方法不可返回nil 一点提示： 你可以发现，iOS9的SDK中已经完全兼容使用了这些特性，并且nonnull的使用会比nullable广泛的多，因此，系统提供了这样一对宏： #define NS_ASSUME_NONNULL_BEGIN _Pragma(“clang assume_nonnull begin”) #define NS_ASSUME_NONNULL_END _Pragma(“clang assume_nonnull end”) 我们在这对宏之间定义的变量都会加上nonnull的修饰符，只有我们特殊声明nullable的才需要手动写。 三、泛型集合的支持这一特性和Nullability一样，只作用于编译期，是为我们开发者服务的另一重要特性。还记得，在Xcode7之前，依然是为了方便多人开发，我经常会在框架中写这样的一个空得宏： 在开发时如下使用，做到提示伙伴我这个数组中是什么东西的作用： 12345@interface ViewController ()&#123; NSArray __TYPE__FIT_TO__CLASS(NSString) * array;&#125;@end 当然，所有这些都是我自己的自导自演，编译器并不会鸟我，我在这个数组中加其他的东西，它也不会介意，所有这些只是我和我的伙伴们约定的一种一厢情愿。所以，当我看到Xcode7中的集合类型时，我着实兴奋了一下。 1、有类型约定的集合在Xcode7中，我们可以给集合类型添加一个泛型的约定，如下： 1 NSMutableArray&lt;NSString *&gt; *array = [[NSMutableArray alloc]init]; 声明了这样一个数组后，就好比我告诉了编译器，这个数组中的数据类型都是NSString*类型的，现在非常好，如果我这个数组中元素的方法，会出现如下的提示： 激动吧，使用点语法可以访问到数组中泛型的方法了，还有更加诱人的： 在我们向这个数组中追加元素的时候，编译器将元素的类型提示了出来，并且将FromArray方法中需要的元素类型也提示了出来。 同样，如果我们向这个数组中追加类型不匹配的元素，如下： 12 NSMutableArray&lt;NSString *&gt; *array = [[NSMutableArray alloc]init]; [array addObject:@1]; 编译器会给我们一个这样的警告： 2、关于一个类型通配符观察Xcode7中iOS系统的类，我们可以发现这么一个好玩的东西：ObjectType。它既不是一个类型，也不是关键字，然而却大量存在，如下是系统的NSMutableArray的头文件： 12345678910@interface NSMutableArray&lt;ObjectType&gt; : NSArray&lt;ObjectType&gt;- (void)addObject:(ObjectType)anObject;- (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;- (void)removeLastObject;- (void)removeObjectAtIndex:(NSUInteger)index;- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(ObjectType)anObject;- (instancetype)init NS_DESIGNATED_INITIALIZER;- (instancetype)initWithCapacity:(NSUInteger)numItems NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;@end 这个ObjectType其实只是一个类型标识符，它具体怎么写并不重要，只是系统中都约定使用了ObjectType，你也可以在自己的类中按自己的喜好来命名，这个东西有怎样的用处，我用文字描述不清楚，我们可以通过自己来定义一个集合类来理解： 创建一个类，继承于NSObject，我取名叫MyArray： 123456//这个类型通配符只能在interfave里使用，作用域为@interface到@end之间//这里我使用Type来做这个通配符@interface MyArray&lt;Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;-(void)addObject:(nonnull Type)obj;@end 实现如下： 123456789101112131415161718- (instancetype)init&#123; self = [super init]; if (self) &#123; _array = [[NSMutableArray alloc]init]; &#125; return self;&#125;-(void)addObject:(id)obj&#123; [_array addObject:obj];&#125;-(NSString *)description&#123; NSMutableString * str = [[NSMutableString alloc]init]; for (int i=0; i&lt;_array.count; i++) &#123; [str appendString:[NSString stringWithFormat:@&quot;%@\\n&quot;,_array[i]]]; &#125; return str;&#125; 我们在使用这个自定义的集合类型时，就会有和系统一样的效果了： 3、关于多参数的泛型集合多参数的泛型集合，有一个非常好的例子，就是NSDictionary，在Xcode7中我们可以这样写字典： 可以看到，字典键值的类型编译器为我们提示了出来，结合上面类型通配符的使用，对于多参的集合，将参数类型用“,”隔开即可。 4、协变性与逆变性因为有了泛型集合的概念，相比之前，我们的类型实际上更加复杂了，比如还拿我们自定义的集合类型来举例： 12 MyArray&lt;NSString *&gt; * array; MyArray&lt;NSMutableString *&gt;*muArray; array和muArray在编译器看来已经是不同的类型，如果我们强行转换，会报如下的警告： 因此，就有了逆变和协变这个概念： __covariant :子类型指针可以向父类型指针转换 __contravariant:父类型指针可以向子类型转换 上面的情况，我们将自定义的类做如下修改，就不会出现警告： 1234@interface MyArray&lt;__covariant Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;-(void)addObject:(nonnull Type)obj;@end 四、类型延拓符的应用在开发中，开发者经常会遇到这样的情况，例如通过tag获取某些UI控件时，viewWithTag方法通常会返回给我们一个UIView类型的指针，这就需要开发者手动的强转一下，十分麻烦。新增加的__kindof修饰符可以帮助我们解除这个烦恼。我们还从自定义的那个数组类开刀，对其添加一个属性： 12345@interface MyArray&lt;__covariant Type&gt; : NSObject@property(nonatomic,strong,nonnull)NSMutableArray&lt;Type&gt; *array;@property(nonnull,strong,nonatomic)NSMutableArray&lt;UIView *&gt; * viewArray;-(void)addObject:(nonnull Type)obj;@end 创建一个自定义的数组对象，并向其中添加一个UIButton，我们会看到有如下一个警告： 这也是我们开发中常遇到的问题，对吧，以前需要强转。但是以后就不需要了，我们在声明这个数组时加上一个__kindof修饰符： 1@property(nonnull,strong,nonatomic)NSMutableArray&lt;__kindof UIView *&gt; * viewArray; 警告就消失了，很cool吧。 这个修饰符就是告诉编译器，这里可以返回UIView的子类指针。 五、结语虽然这些优点在swift中早有体现，但就我个人而言，我对OC的感情会更深一些，也更加愿意接受OC的改变和成长，大家都说swift的趋势势在必行，我只想说，swift很优秀，OC亦然。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS数据持久化之二——归档与设计可存储化的数据模型基类","slug":"121iOS数据持久化之二——归档与设计可存储化的数据模型基类","date":"2015-10-07T16:00:00.000Z","updated":"2021-07-03T12:19:50.756Z","comments":true,"path":"2015/10/08/121iOS数据持久化之二——归档与设计可存储化的数据模型基类/","link":"","permalink":"http://huishao.cc/2015/10/08/121iOS数据持久化之二——归档与设计可存储化的数据模型基类/","excerpt":"","text":"iOS数据持久化之二——归档与设计可存储化的数据模型基类一、引言在上一篇博客中，我们介绍了用plist文件进行数据持久化的方法。虽然简单易用，但随着开发的深入，你会发现，这种方式还是有很大的局限性。试想，如果我们可以将用户的登录返回信息模型，游戏中角色的属性信息模型进行直接的持久化存取，那是不是非常爽的事，幸运的是，我们可以通过归档，来设计一个这样的数据模型。 二、先来精通归档吧归档也是iOS提供给开发者的一种数据存储的方式，事实上，几乎所有的数据类型都可以通过归档来进行存取。其存储与读取的过程，主要封装在两个类中：NSKeyedArchiver和NSKeyedUnarchiver。 1、归档的原理归档是将一种或者多种数据类型进行序列化，解归档的过程就是将序列化的数据进行反序列化的解码，这里需要注意一点，归档的核心并非是数据的持久化处理，而是数据的序列化处理，持久化的处理依然是通过文件存取来实现的。因此，被归档的数据类型都必须遵守一个相同的协议，才能在这个协议的约束下进行正确的归档与解归档，这个协议就是NSCoding协议，我们可以先来看一下NSCoding中的内容： 123456@protocol NSCoding- (void)encodeWithCoder:(NSCoder *)aCoder;- (id)initWithCoder:(NSCoder *)aDecoder;@end 这个协议非常简单，一个init的归档方法，一个encode的解归档方法，NSCoder就是归档对象。原则上说，无论是什么数据类型的对象，系统的或者是我们自定义的，都可以通过实现这个协议中的方法来支持归档操作。 2、几种归档与解归档的应用（1）通过类方法来对rootKey进行归档这种方式，我个人理解，很类似于NSUserDefaults中的standardUserDefaults，只是后者是系统为我们创建的一个默认plist文件，而rootKey是系统为我们创建的一个默认的归档键值。说起来比较复杂，举个例子就十分清晰了： 12345678910111213 NSString *homeDictionary = NSHomeDirectory();//获取根目录 NSString *homePath = [homeDictionary stringByAppendingPathComponent:@&quot;atany.archiver&quot;];//添加储存的文件名 //方式一：通过data数据归档，在将数据写入文件 NSData *data= [NSKeyedArchiver archivedDataWithRootObject:@&quot;123&quot;]; [data writeToFile:homePath atomically:YES]; //方式二：直接写入文件 [NSKeyedArchiver archiveRootObject:@&quot;456&quot; toFile:homePath]; //方式一和方式二的效果完全一样 只是解归档的时候不同 //方式一的解归档:先获取data数据，在进行data数据的解归档 NSLog(@&quot;%@&quot;,[NSKeyedUnarchiver unarchiveObjectWithData:data]); //方式二的解归档：直接解文件中的归档 NSLog(@&quot;%@&quot;,[NSKeyedUnarchiver unarchiveObjectWithFile:homePath]); 上面的示例是对字符串类型进行的归档，是对单一的数据对象进行的归档，当然，这里的对象是支持数组、字典等集合的，但集合其中的对象，也必须全部支持归档操作。 （2）通过构造新的archiver对象，对多个对象进行归档除了上面的类方法，我们还可以自己构造一个归档对象，来对多种不同的对象进行归档： 123456789101112131415161718192021 NSString *homeDictionary = NSHomeDirectory();//获取根目录 NSString *homePath = [homeDictionary stringByAppendingPathComponent:@&quot;atany.archiver&quot;];//添加储存的文件名 //这里创建一个可变的data对象作为归档的容器 NSMutableData * data = [[NSMutableData alloc]init]; //创建一个归档对象，归档后写入data数据 NSKeyedArchiver * archiver = [[NSKeyedArchiver alloc]initForWritingWithMutableData:data]; //对下面的字符串和int值进行归档序列化 [archiver encodeObject:@&quot;jaki&quot; forKey:@&quot;name&quot;]; [archiver encodeInt:24 forKey:@&quot;age&quot;]; //写入data [archiver finishEncoding]; //写入文件 [data writeToFile:homePath atomically:YES]; //创建解归档的反序列化对象 NSKeyedUnarchiver * unarchiver = [[NSKeyedUnarchiver alloc]initForReadingWithData:data]; //进行反序列化 NSString * name = [unarchiver decodeObjectForKey:@&quot;name&quot;]; int age = [unarchiver decodeIntForKey:@&quot;age&quot;]; //打印信息 NSLog(@&quot;\\nname:%@\\nage:%d&quot;,name,age); 结果如下： （3）进行自定义对象的归档上面介绍中有提到，原则上，任何遵守了NSCoding协议的类都可以进行归档操作，那么对于我们自定义的对象，我们该如何来做呢？ 首先，我们新建一个类： 仿照上面的例子，我们写一个这样的类： 1234@interface MyObject : NSObject@property(nonatomic,strong)NSString * name;@property(nonatomic,assign)int age;@end 对其进行归档： 12345678 //进行归档 MyObject * obj = [[MyObject alloc]init]; obj.name = @&quot;jaki&quot;; obj.age = 24; NSData * data = [NSKeyedArchiver archivedDataWithRootObject:obj]; //进行解档 MyObject * obj2 = [NSKeyedUnarchiver unarchiveObjectWithData:data]; NSLog(@&quot;\\nname:%@\\nage:%d&quot;,obj2.name,obj2.age); 直接运行，程序会崩溃掉，打印如下： 可以看出，正是我们前边说过的，必须遵守归档协议的对象，才可以被归档，我们在MyObject类中实现如下两个方法： 12345678910111213141516//解档方法- (instancetype)initWithCoder:(NSCoder *)coder&#123; if (self=[super init]) &#123; _name = [coder decodeObjectForKey:@&quot;name&quot;]; _age = [coder decodeIntForKey:@&quot;age&quot;]; &#125; return self;&#125;//归档方法- (void)encodeWithCoder:(NSCoder *)coder&#123; [coder encodeObject:_name forKey:@&quot;name&quot;]; [coder encodeInt:_age forKey:@&quot;age&quot;];&#125; 添加了上面两个方法，我们自定义的对象就可以自由归档存取，并可以写入本地，非常cool吧。 三、设计可以归档存取的数据模型基类1、动机与初衷通过上面对归档的介绍，我们可以发现归档一个十分有潜力的应用：可以自由存取自定义的数据对象。这个特性的优势是毫无疑问的，除了可以使我们的数据用起来更加方便，无需多次解析数据外，安全性也更好。但是也带来了一个缺陷，每个类都需要实现NSCoding中的两个方法是十分繁琐的，并且类越复杂，这个步骤越繁琐，如果在之后的修改和优化中类做了改变，相应的方法也要做改变，这将增加很大的工作量并且埋下潜在bug的风险。 所以我们会想，能否设计一个这样的model基类，来使需要存储的model都继承于它，使我们的model不需要实现NSCoding方法的同时可以支持归档呢，通过runtime和OC语言特性的一些小技巧，我们是可以做到的。 2、基类模型的设计我们新建一个BaseModel类，核心方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//归档与解归档的方法- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super init]; if (self) &#123; //获取所有属性 NSArray * porpertyArray = [self getAllPropertys]; for (NSString * name in porpertyArray) &#123; //去掉属性名前面的_ NSString * key = [name substringFromIndex:1]; //约定好的键值对 c+key [self setValue:[coder decodeObjectForKey:[NSString stringWithFormat:@&quot;c%@&quot;,key]] forKey:key]; &#125; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)coder&#123; //获取所有属性 NSArray * porpertyArray = [self getAllPropertys]; for (NSString * name in porpertyArray) &#123; //去掉属性名前面的_ NSString * key = [name substringFromIndex:1]; //约定好的键值对 c+key [coder encodeObject:[self valueForKey:key] forKey:[NSString stringWithFormat:@&quot;c%@&quot;,key]]; &#125;&#125;//获取model所有属性-(NSArray *)getAllPropertys&#123; NSMutableArray * array = [[NSMutableArray alloc]init]; unsigned int * count = malloc(sizeof(unsigned int)); //调用runtime的方法 //Ivar：方法返回的对象内容对象，这里将返回一个Ivar类型的指针 //class_copyIvarList方法可以捕获到类的所有变量，将变量的数量存在一个unsigned int的指针中 Ivar * mem = class_copyIvarList([self class], count); //进行遍历 for (int i=0; i&lt; *count ; i++) &#123; //通过移动指针进行遍历 Ivar var = * (mem+i); //获取变量的名称 const char * name = ivar_getName(var); NSString * str = [NSString stringWithCString:name encoding:NSUTF8StringEncoding]; [array addObject:str]; &#125; //释放内存 free(count); //注意处理野指针 count=nil; return array;&#125; 通过这样的一个runtime机制，我们可以很方便的是新建的model继承于这个基类，无需其他处理直接支持归档，修改与优化都不受影响。 四、为志同道合的朋友分享这个model集成在了我的一个开源的开发框架中，当然，那里面也综合和许多许多这样方便开发者使用的功能，如果你感兴趣，可以在[https://github.com/ZYHshao/YHBaseFoundationTest](https://github.com/ZYHshao/YHBaseFoundationTest)上面看到。如果你发现了一些bug或者可以添加或者优化的地方，请务必告知我，十分你感谢。QQ：316045346 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS数据持久化之一——plist文件","slug":"120iOS数据持久化之一——plist文件","date":"2015-10-07T16:00:00.000Z","updated":"2021-07-02T06:54:46.547Z","comments":true,"path":"2015/10/08/120iOS数据持久化之一——plist文件/","link":"","permalink":"http://huishao.cc/2015/10/08/120iOS数据持久化之一——plist文件/","excerpt":"","text":"iOS数据持久化之一——plist文件iOS开发中，我们时常会将一些简单的数据进行持久化的存储，方便我们保存程序的一些配置和用户的一些数据，plist文件就是我们保存这些数据的最佳选择。 一、何为plistplist是一种文件格式，其内容规则是xml文件，后缀为.plist，因此，我们更习惯于成它问plist文件，在iOS开发中，这种文件常用来保存一些简单的配置数据，例如项目中的info.plist。 通过plist文件编辑器，我们可以很方便的查看和编辑层次清晰的plist文件。 二、通过操作plist文件进行数据持久化的几种方式1、操作系统为我们准备的用户配置文件——NSUserDefaults对于NSUserDefaults，具体用法和一些小技巧在以前的一篇博客中有详细的描述，一般的用户配置信息，我们都会选择通过这种方式来进行持久化，地址如下：[http://my.oschina.net/u/2340880/blog/411344](http://my.oschina.net/u/2340880/blog/411344)。 2、在项目包中手动创建一个plist文件，通过代码对其进行操作这种方式创建的plist文件非常自由且直观，我们可以创建多个根据功能进行分类存储，并且可以通过Xcode的可视化工具进行可视化的修改。 首先，我们新创建一个文件，在Resource中选择 Property List文件： 之后，我们通过Xcode，在其中添加一些数据： 通过代码，我们来获取这些数据： 1234 //获取myInfo文件地址 NSString * path = [[NSBundle mainBundle]pathForResource:@&quot;myInfo&quot; ofType:@&quot;plist&quot;]; NSMutableDictionary * dic =[NSMutableDictionary dictionaryWithContentsOfFile:path]; NSLog(@&quot;%@&quot;,dic); 打印结果如下： 这种方式添加的plist文件，我们只能在xcode中配置好，然后再程序中读取使用，但是不能在程序中修改这些数据，可以应用于一些固定的数据的存储，例如地图shu xing列表等。 3、在沙盒目录中创建和使用plist文件我们还可以通过代码在沙盒中创建我们自己的plist文件，进行数据的存储。同时可以支持add，delete，replace，find等操作。 123456789101112 //获取沙盒目录 NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES); NSString *plistPath1 = [paths objectAtIndex:0]; //得到完整的文件名 NSString *filename=[plistPath1 stringByAppendingPathComponent:@&quot;my.plist&quot;]; NSDictionary * dic = @&#123;@&quot;my&quot;:@&quot;haha&quot;&#125;; [dic writeToFile:filename atomically:YES]; //取数据 NSDictionary * getDic = [NSDictionary dictionaryWithContentsOfFile:filename]; NSLog(@&quot;%@&quot;,getDic); 打印如下： 这种方式无疑会更加安全，存取也更加自由。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS9系列专题6——iOS9其他适配注意点","slug":"119iOS9系列专题6——iOS9其他适配注意点","date":"2015-10-06T16:00:00.000Z","updated":"2021-07-02T06:53:41.264Z","comments":true,"path":"2015/10/07/119iOS9系列专题6——iOS9其他适配注意点/","link":"","permalink":"http://huishao.cc/2015/10/07/119iOS9系列专题6——iOS9其他适配注意点/","excerpt":"","text":"iOS9适配注意点一、后台定位类app适配点在iOS8中，APP的定位服务apple就做了一些修改，需要用户申请相应的权限，并在info.plist文件中添加对应的键值。具体的做法在这篇博客中有详细的讲解：[http://my.oschina.net/u/2340880/blog/414760](http://my.oschina.net/u/2340880/blog/414760)。 在iOS9系统中，定位服务的做法基本没有改变，对于前台的定位没有影响，但app中如果需要后台定位，那么还需要多做一些操作，例如： 123456789 manager = [[CLLocationManager alloc]init]; //申请后台定位权限 [manager requestAlwaysAuthorization]; manager.delegate=self; //======================================= //下面这个是iOS9中新增的方法 开启后台定位 manager.allowsBackgroundLocationUpdates = YES; //====================================== [manager startUpdatingLocation]; 通过上面简单的配置直接运行的话，程序会崩溃掉，还需要在plist文件中做一些配置，两种方式： 方式一：直接在plist文件中配置如下： 方式二：在项目中设置 打开background Models选项，勾选其中的Location updates。 二、安装不受信任的开发者应用我们知道，在Xcode7后，开发者可以不用花99dollars去购买开发者账号而可以在自己的iphone上进行测试。在安装这些应用时，iOS9系统不再向以前那样，再安装时提示一个信任的按钮，而是做如下的提示： 在设置中，选择描述文件： 之后选择开发者对应的appleId，选择信任即可： 三、BitCode的配置BitCode是app的一种中间形式，在iOS9系列专题的前几篇，有对其的简单介绍，举个例子，我们可以在提交app时提交app的bitcode形式，如此一来，apple会对我们的app进行二次优化，在用户下载时根据所需再进行编译打包。在Xocde7中，新建的项目是默认开启BitCode的，如果我们用Xcode7编译提交应用，这里有需要注意适配的地方。 如果要支持BitCode，需要保证所有的SDK都支持BitCode，如果要更新旧的SDK，只需要在Xcode7上开启BitCode重新制作一遍即可。 如果不能使所有SDK都支持BitCode，可以在项目中关闭BitCode，在building Setting中搜索BitCode，将enable设置为NO，如下： 四、URL Scheme白名单在iOS9中，apple引入了白名单这个概念，其好处是对app应用内安全进行了加强。在iOS9的适配中，如果我们用到canOpenURL这样的方法，则需要配置白名单。 首先，我们创建一个测试工程，什么都不用做，只需要添加一个URL Scheme： 在另一个工程中，我们写如下代码： 123 BOOL can= [[UIApplication sharedApplication]canOpenURL:[NSURL URLWithString:@&quot;TEST://&quot;]]; NSLog(@&quot;%d&quot;,can); [[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;TEST://&quot;]]; 在没有配置白名单之前，打印如下： 可以看到，bool值返回的是NO。虽然这样也可以跳转相应的APP，但是canOpenURL这个方法相当于失效了，我们不能用它来判断用户到底装没装这个app。 适配时，我们在plist文件中添加如下键值： 这时再次运行程序，canOpenURL的判断就会准确了。 注意：白名单添加上限为50个。 五、label默认字体不同产生的BUGiOS9的另一变化是label的默认字体产生了变化，我们打印iOS9中label的字体如下： iOS8中的label默认字体如下： 这两种字体的最大差异是字间距不同，例如如下一段代码： 12345 UILabel * label = [[UILabel alloc]init]; label.frame=CGRectMake(100, 100, 100, 30); [self.view addSubview:label]; label.backgroundColor= [UIColor redColor]; label.text=@&quot;1111111111111&quot;; 这段代码在iOS9上是刚好可以正常显示的，在iOS8上则不行，如下： iOS9： iOS8： 适配注意点： 1、可以通过动态计算来获取label的宽度，进行设置label的宽度 2、一个更简单的方法是通过设置一个确定的字体，来进行适配 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题五——全新的联系人与联系人UI框架","slug":"118iOS9系列专题五——全新的联系人与联系人UI框架","date":"2015-09-27T16:00:00.000Z","updated":"2021-07-02T06:50:00.556Z","comments":true,"path":"2015/09/28/118iOS9系列专题五——全新的联系人与联系人UI框架/","link":"","permalink":"http://huishao.cc/2015/09/28/118iOS9系列专题五——全新的联系人与联系人UI框架/","excerpt":"","text":"iOS9全新的联系人相关框架——Contacts Framework一、引言在以前iOS开发中，涉及联系人相关的编程，代码都非常繁琐，并且框架的设计也不是Objective-C风格的，这使开发者用起来非常的难受。在iOS9中，apple终于解决了这个问题，全新的Contacts Framework将完全替代AddressBookFramework，AddressBookFramework也将成为历史被弃用。至于AddressBookFramework的相关api如何繁琐，在以前的博客中有记录，地址如下： 联系人信息相关编程：http://my.oschina.net/u/2340880/blog/407347。 联系人UI界面相关编程：http://my.oschina.net/u/2340880/blog/407973。 这一新的框架是iOS9新特性中十分受欢迎的一个。apple的Objective—C体系也更加完善与强大。 二、让我们来添加一个联系人新的框架的整体思路是通过配置与请求来管理联系人，这样做有一个非常大的好处，逻辑简单，代码层次清晰。如下，通过添加一个联系人来向大家做演示： 1、联系人对象：CNContact这个对象是用来配置联系人信息的，有可变的CNMutaleContact和CNContact，区别用来读取和创建联系人。CNContact对象中有许多属性，对应联系人的一些信息。 首先，创建CNMutableContact对象： 1 CNMutableContact * contact = [[CNMutableContact alloc]init]; 设置联系人头像： 1contact.imageData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;Icon-114.png&quot;]); 设置联系人姓名： 1234 //设置名字 contact.givenName = @&quot;jaki&quot;; //设置姓氏 contact.familyName = @&quot;zhang&quot;; 设置联系人邮箱： 123 CNLabeledValue *homeEmail = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:@&quot;316045346@qq.com&quot;]; CNLabeledValue *workEmail =[CNLabeledValue labeledValueWithLabel:CNLabelWork value:@&quot;316045346@qq.com&quot;]; contact.emailAddresses = @[homeEmail,workEmail]; 这里需要注意，emailAddresses属性是一个数组，数组中是才CNLabeledValue对象，CNLabeledValue对象主要用于创建一些联系人属性的键值对应，通过这些对应，系统会帮我们进行数据的格式化，例如CNLabelHome，就会将号码格式成家庭邮箱的格式，相应的其他键如下： 123456789101112131415//家庭CONTACTS_EXTERN NSString * const CNLabelHome NS_AVAILABLE(10_11, 9_0);//工作CONTACTS_EXTERN NSString * const CNLabelWork NS_AVAILABLE(10_11, 9_0);//其他CONTACTS_EXTERN NSString * const CNLabelOther NS_AVAILABLE(10_11, 9_0);// 邮箱地址CONTACTS_EXTERN NSString * const CNLabelEmailiCloud NS_AVAILABLE(10_11, 9_0);// url地址CONTACTS_EXTERN NSString * const CNLabelURLAddressHomePage NS_AVAILABLE(10_11, 9_0);// 日期CONTACTS_EXTERN NSString * const CNLabelDateAnniversary NS_AVAILABLE(10_11, 9_0); 设置联系人电话： 1contact.phoneNumbers = @[[CNLabeledValue labeledValueWithLabel:CNLabelPhoneNumberiPhone value:[CNPhoneNumber phoneNumberWithStringValue:@&quot;12344312321&quot;]]]; 联系人电话的配置方式和邮箱类似，键值如下： 1234567CONTACTS_EXTERN NSString * const CNLabelPhoneNumberiPhone NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberMobile NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberMain NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberHomeFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberWorkFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberOtherFax NS_AVAILABLE(10_11, 9_0);CONTACTS_EXTERN NSString * const CNLabelPhoneNumberPager NS_AVAILABLE(10_11, 9_0); 这里的CNPhoneNumber对象也是iOS9中的一个新的类，专门用来创建电话号码，之中方法如下： 12345678910@interface CNPhoneNumber : NSObject &lt;NSCopying, NSSecureCoding&gt;//通过类方法创建+ (instancetype)phoneNumberWithStringValue:(NSString *)stringValue;//通过初始化方法创建- (instancetype)initWithStringValue:(NSString *)string;@property (readonly, copy, NS_NONATOMIC_IOSONLY) NSString *stringValue;@end 设置联系人地址： 123456 CNMutablePostalAddress * homeAdress = [[CNMutablePostalAddress alloc]init]; homeAdress.street = @&quot;贝克街&quot;; homeAdress.city = @&quot;伦敦&quot;; homeAdress.state = @&quot;英国&quot;; homeAdress.postalCode = @&quot;221B&quot;; contact.postalAddresses = @[[CNLabeledValue labeledValueWithLabel:CNLabelHome value:homeAdress]]; 设置生日： 12345NSDateComponents * birthday = [[NSDateComponents alloc]init]; birthday.day=7; birthday.month=5; birthday.year=1992; contact.birthday=birthday; 2、创建添加联系人请求：CNSaveRequestCNSaveRequest是用于存储联系人的请求类，通过这个类，我们可以创建批量添加、修改或者删除联系人的请求，例如添加上面我们创建的联系人对象： 1234 //初始化方法 CNSaveRequest * saveRequest = [[CNSaveRequest alloc]init]; //添加联系人 [saveRequest addContact:contact toContainerWithIdentifier:nil]; 这个类中还有许多方便我们操作的方法： 123456789101112131415161718192021222324@interface CNSaveRequest : NSObject//添加一个联系人- (void)addContact:(CNMutableContact *)contact toContainerWithIdentifier:(nullable NSString *)identifier;//更新一个联系人- (void)updateContact:(CNMutableContact *)contact;//删除一个联系人- (void)deleteContact:(CNMutableContact *)contact;//添加一组联系人- (void)addGroup:(CNMutableGroup *)group toContainerWithIdentifier:(nullable NSString *)identifier;//更新一组联系人- (void)updateGroup:(CNMutableGroup *)group;//删除一组联系人- (void)deleteGroup:(CNMutableGroup *)group;//向组中添加子组- (void)addSubgroup:(CNGroup *)subgroup toGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA);//在组中删除子组- (void)removeSubgroup:(CNGroup *)subgroup fromGroup:(CNGroup *)group NS_AVAILABLE(10_11, NA);//向组中添加成员- (void)addMember:(CNContact *)contact toGroup:(CNGroup *)group;//向组中移除成员- (void)removeMember:(CNContact *)contact fromGroup:(CNGroup *)group;@end 3、进行联系人的写入操作:CNContactStoreCNContactStore是一个用于存取联系人的上下文桥梁，现在，把我们创建的添加联系人的请求写入： 12 CNContactStore * store = [[CNContactStore alloc]init]; [store executeSaveRequest:saveRequest error:nil]; 在模拟器上运行程序，打开联系人，效果如下： 联系人界面： 联系人详情： 三、获取格式化的联系人信息iOS9中，ContactFramework也为开发者提供了非常方便的格式化信息的方法，还拿我们上面创建的联系人对象举例： 1、获取格式化的联系人姓名12 NSString * foematter =[CNContactFormatter stringFromContact:contact style:CNContactFormatterStyleFullName]; NSLog(@&quot;%@&quot;,foematter); 这个运行后会打印出jaki zhang，其中style风格枚举如下： 1234567typedef NS_ENUM(NSInteger, CNContactFormatterStyle)&#123; //获取全名 CNContactFormatterStyleFullName, //获取拼音全名 CNContactFormatterStylePhoneticFullName,&#125; NS_ENUM_AVAILABLE(10_11, 9_0); 2、获取格式化的联系人地址12 NSString * foematter =[CNPostalAddressFormatter stringFromPostalAddress:homeAdress style:CNPostalAddressFormatterStyleMailingAddress]; NSLog(@&quot;%@&quot;,foematter); 打印如下： 四、提取联系人在开发中，提取联系人的使用率要远远高于创建联系人，ContactFramework提取联系人的方式，类似于数据库的检索方式，通过配置条件，提取出我们需要的数据，例如： 12345 CNContactStore * stroe = [[CNContactStore alloc]init]; //检索条件，检索所有名字中有zhang的联系人 NSPredicate * predicate = [CNContact predicateForContactsMatchingName:@&quot;zhang&quot;]; //提取数据 NSArray * contacts = [stroe unifiedContactsMatchingPredicate:predicate keysToFetch:@[CNContactGivenNameKey] error:nil]; keysToFetch是设置提取联系人的哪些数据，如上则只提取出检索联系人的名字。 同样，也可以通过请求的方式来对联系人进行遍历： 12345 CNContactStore * stroe = [[CNContactStore alloc]init]; CNContactFetchRequest * request = [[CNContactFetchRequest alloc]initWithKeysToFetch:@[CNContactPhoneticFamilyNameKey]]; [stroe enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSLog(@&quot;%@&quot;,contact); &#125;]; 五、ContactFramework UI相关iOS9中，系统也为我们封装好了一套联系人的UI界面，用起来也十分方便，主要新增的controller有两个： CNContactPickerViewController：展示联系人列表的controller CNContactViewController：展示联系人详细信息的controller 示例如下： 弹出联系人列表： 12 CNContactPickerViewController * con = [[CNContactPickerViewController alloc]init]; [self presentViewController:con animated:YES completion:nil]; 效果如下： 联系人逻辑的相关处理主要在CNContactPickerDelegate中完成： 1234567//视图取消时 调用的方法- (void)contactPickerDidCancel:(CNContactPickerViewController *)picker;//选中与取消选中时调用的方法- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContact:(CNContact *)contact;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContactProperty:(CNContactProperty *)contactProperty;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContacts:(NSArray&lt;CNContact*&gt; *)contacts;- (void)contactPicker:(CNContactPickerViewController *)picker didSelectContactProperties:(NSArray&lt;CNContactProperty*&gt; *)contactProperties; CNContactViewController则是用来显示具体联系人的详细信息的，比如： 12 CNContactViewController * con = [CNContactViewController viewControllerForContact:contact]; [self presentViewController:con animated:YES completion:nil]; 相关代理回调函数如下： 123//将要展示联系人信息与已经展示联系人信息的回调- (BOOL)contactViewController:(CNContactViewController *)viewController shouldPerformDefaultActionForContactProperty:(CNContactProperty *)property;- (void)contactViewController:(CNContactViewController *)viewController didCompleteWithContact:(nullable CNContact *)contact; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"Xcode多版本的dmg文件下载方式","slug":"117Xcode多版本的dmg文件下载方式","date":"2015-09-27T16:00:00.000Z","updated":"2021-07-02T06:49:15.605Z","comments":true,"path":"2015/09/28/117Xcode多版本的dmg文件下载方式/","link":"","permalink":"http://huishao.cc/2015/09/28/117Xcode多版本的dmg文件下载方式/","excerpt":"","text":"Xcode多版本的dmg文件下载方式在iOS开发中，有时我们想保有当前版本的Xcode的同时，体验新版本或者兼容旧版本，在apple官网上，是提供给我们下载地址的： 1.访问https://developer.apple.com。 2.选择Resources： 3.选择Xcode，点击download： 4.在网页下方点击additional tools，需要用appid登录： 之后会出现apple的工具列表，选择我们需要的下载即可： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"iOS9系列专题四——APP传输安全","slug":"116iOS9系列专题四——APP传输安全","date":"2015-09-27T16:00:00.000Z","updated":"2021-07-02T06:48:21.752Z","comments":true,"path":"2015/09/28/116iOS9系列专题四——APP传输安全/","link":"","permalink":"http://huishao.cc/2015/09/28/116iOS9系列专题四——APP传输安全/","excerpt":"","text":"APP Transport Security——加密传输方式随着ios9的推出和Xcode的升级，apple将默认开发者使用https的传输方式，相比http的传输协议，这无疑会增加一些安全性，对于开发者而言，一下子将http协议全部升级为https协议，不是一件容易的事，我们可以通过Xcode的一些配置，使其支持http的传输协议。 如果在Xcode7上运行http协议的应用，会出现如下信息： 这个信息也很清晰，需要我们在info.plist文件中配置一些参数来支持http。 首先，在项目的Info.plist中加入NSAppTransportSecurity这个键，类型为Dictionary,在字典中添加一对键值，键为Boolen类型的NSAllowsArbitraryLoads，值为YES，如下： 这时再运行项目，就可以正常取到数据了。 几点注意： 1.总有朋友说plist文件中配置了依然没有效果，一开始我很奇怪，后来发现了原因，info.plist文件有两个，一个是正式项目中的，一个是测试项目中的，一定要配置在正式项目中。 2.可能Xcode的还有些缺陷，这些键值不能通过自动补全提示出来，需要我们无误的手打。 后续：Xcode7.1中已经支持自动补全的功能。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题三——应用瘦身","slug":"115iOS9系列专题三——应用瘦身","date":"2015-09-26T16:00:00.000Z","updated":"2021-07-02T06:47:35.408Z","comments":true,"path":"2015/09/27/115iOS9系列专题三——应用瘦身/","link":"","permalink":"http://huishao.cc/2015/09/27/115iOS9系列专题三——应用瘦身/","excerpt":"","text":"更小，更快——iOS9的App Thinningapple在iOS9中引入了一套新的app瘦身方案，通过一些优化策略，将尽可能的减小app安装包的体积。这部分的大多工作是由app store来完成，开发者并不需要付出太多额外的开销。这篇博客将这部分内容做了简单的介绍，详细信息在[App Thinning](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35)。 App的瘦身策略主要包括三部分： 一、slicing这部分的主要原理是不同的设备下载安装不同的app包，各个app包副本中包含相应尺寸的素材。在xcode中，使用asset catalog管理素材文件，在我们提交应用市场后，会自动帮我们生成各个尺寸包得app副本。 二、BitCode字节码文件是app程序的一种中间形式，苹果会对包含字节码的app进行二次的优化，来进行相应的瘦身。 三、On-Demand Resources这是一种多级应用的设计思路，例如一个游戏，开发者可以将其分为一个大小各异的资源包，用户只需下载一个小的引导程序，在程序内加载相应资源包。这样，可以大大加快应用的安装速度。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题二——全新的搜索功能api","slug":"114iOS9系列专题二——全新的搜索功能api","date":"2015-09-26T16:00:00.000Z","updated":"2021-07-02T06:46:31.479Z","comments":true,"path":"2015/09/27/114iOS9系列专题二——全新的搜索功能api/","link":"","permalink":"http://huishao.cc/2015/09/27/114iOS9系列专题二——全新的搜索功能api/","excerpt":"","text":"更加智能的搜索方案——iOS9搜索功能新api一、引言iOS9中为我们提供了许多新的api，搜索功能的加强无疑是其中比较显眼的一个。首先，我们先设想一下：如果在你的app中定义一种标识符，在siri和搜索中，可以用过这个标识符搜索到你的app，是不是很棒？不，这还差得远，你可以定义任意的数据，使其在搜索和siri中可以快速检索到，这样的搜索功能是不是非常酷？不，还有更cool的，你甚至可以在你的网站中添加一些标志，使apple的爬虫可以检索到，那样，即使用户没有安装你的app，也可以在搜索中获取到相应的信息，这太强大了，对吧。 二、3种全新的搜索模式‍1、NSUserActivity‍我们可以在项目中使用相应的函数来添加一些用户的活跃元素，使我们可以在搜索中通过搜索这样的活跃元素展现我们的app。例如： 12345678910 //创建一个对象，这里的type用于区分搜索的类型 NSUserActivity *userActivity = [[NSUserActivity alloc] initWithActivityType: @&quot;myapp&quot;]; //显示的标题 userActivity.title = @&quot;我的app&quot;; // 搜索的关键字 userActivity.keywords = [NSSet setWithArray: @[@&quot;sea&quot;,@&quot;rch&quot;]]; // 支持Search userActivity.eligibleForSearch = YES; //提交设置 [userActivity becomeCurrent]; 在下面的函数中，我们可以处理用户点击搜索后的回调： 123456789101112- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:&#123; NSString *activityType = userActivity.activityType; if ([activityType isEqual: @&quot;myapp&quot;])&#123; // Handle restoration for values provided in userInfo // do something return YES; &#125; return NO; //处理回调&#125; TIP：这种方式添加的关键字搜索，必须创建全局变量，否则无法进行搜索: 2、CoreSpotlightCoreSpotlight是一种更加自由的搜索方式，可以通过添加类似item的模型，将app中的数据展示在搜索栏中，CoreSpotlight框架类似提供了一些增、删、改、查的操作，可是使我们自由的进行搜索属性的设置。 （1）认识3个类在iOS9中，新增加了3个类，通过对这三个类的操作与配合，我们可以轻易的在app中添加CoreSpotlight搜索的功能。 CSSearchableItemAttributeSet：设置类，这个类用于设置搜索标签里的icon，内容，图片等。主要用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142//这个类的核心方法只有一个init方法，通过一个类型字符串进行创建，字符串用于在回调中区分@interface CSSearchableItemAttributeSet : NSObject &lt;NSCopying,NSSecureCoding&gt;- (instancetype)initWithItemContentType:(nonnull NSString *)itemContentType;@end//更多的属性设置在其扩展类中，例如：@interface CSSearchableItemAttributeSet (CSGeneral)//展示的名称@property(nullable, copy) NSString *displayName;//名称数组@property(nullable, copy) NSArray&lt;NSString*&gt; *alternateNames;//完整的路径@property(nullable, copy) NSString *path;//链接url@property(nullable, strong) NSURL *contentURL;//图片链接的url@property(nullable, strong) NSURL *thumbnailURL;//设置图片数据@property(nullable, copy) NSData *thumbnailData;//设置一个标识符@property(nullable, copy) NSString *relatedUniqueIdentifier;@property(nullable, strong) NSDate *metadataModificationDate;//内容类型@property(nullable, copy) NSString *contentType;@property(nullable, copy) NSArray&lt;NSString*&gt; *contentTypeTree;//搜索的关键字数组@property(nullable, copy) NSArray&lt;NSString*&gt; *keywords;//标题信息@property(nullable, copy) NSString *title;@end CSSearchableItem：搜索标签类，通过这个类，来创建响应的搜索标签。主要内容如下： 12345678910111213141516//这个类主要用于创建搜索的标签@interface CSSearchableItem : NSObject &lt;NSSecureCoding, NSCopying&gt;//init方法- (instancetype)initWithUniqueIdentifier:(nullable NSString *)uniqueIdentifier //Can be null, one will be generated domainIdentifier:(nullable NSString *)domainIdentifier attributeSet:(CSSearchableItemAttributeSet *)attributeSet;//相应 的属性@property (copy) NSString *uniqueIdentifier;@property (copy, nullable) NSString *domainIdentifier;@property (copy, null_resettable) NSDate * expirationDate;@property (strong) CSSearchableItemAttributeSet *attributeSet;@end CSSearchableIndex：这个类，我个人理解，类似一个manager的作用，通过它对标签进行增、删、改、查等操作： 123456789101112131415161718192021222324@interface CSSearchableIndex : NSObject@property (weak,nullable) id&lt;CSSearchableIndexDelegate&gt; indexDelegate;//判断设备是否支持+ (BOOL)isIndexingAvailable;//取系统的searchIndex管理者+ (instancetype)defaultSearchableIndex;//一般情况下，我们不需要重新创建对象- (instancetype)initWithName:(NSString *)name;- (instancetype)initWithName:(NSString *)name protectionClass:(nullable NSString *)protectionClass;//设置索引标签- (void)indexSearchableItems:(NSArray&lt;CSSearchableItem *&gt; *)items completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//删除指定id索引标签- (void)deleteSearchableItemsWithIdentifiers:(NSArray&lt;NSString *&gt; *)identifiers completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;- (void)deleteSearchableItemsWithDomainIdentifiers:(NSArray&lt;NSString *&gt; *)domainIdentifiers completionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;//删除所有索引标签- (void)deleteAllSearchableItemsWithCompletionHandler:(void (^ __nullable)(NSError * __nullable error))completionHandler;@end （2）一个小例子下面，我们通过一个小例子来应用下CoreSpotlight的搜索功能。 首先，需要在项目中导入如下库： 实现如下代码： 12345678910 //进行标签设置 CSSearchableItemAttributeSet * itemSet = [[CSSearchableItemAttributeSet alloc]initWithItemContentType:@&quot;myApp&quot;]; itemSet.title = @&quot;我的APP&quot;; itemSet.keywords = @[@&quot;haha&quot;,@&quot;123&quot;]; itemSet.contentDescription = @&quot;这是搜索到得内容&quot;; itemSet.thumbnailData = UIImagePNGRepresentation([UIImage imageNamed:@&quot;Icon-114.png&quot;]); CSSearchableItem * item = [[CSSearchableItem alloc]initWithUniqueIdentifier:@&quot;1&quot; domainIdentifier:@&quot;1&quot; attributeSet:itemSet]; [[CSSearchableIndex defaultSearchableIndex]indexSearchableItems:@[item] completionHandler:nil]; 我们在搜索中输入haha或者123效果如下： CoreSpotlight的搜索回调和NSUserActivaty一样，只是区分id的方式有所不同： 1234567891011- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:&#123; NSString *activityType = userActivity.activityType; //先取CSSearchableItemActionType if ([activityType isEqual: CSSearchableItemActionType]) &#123; NSString *uniqueIdentifier = [userActivity.userInfo objectForKey:CSSearchableItemActivityIdentifier]; // do something return YES; &#125; return NO;&#125; 3、Web Markup这个功能与我们app开发关系不大，但是对我app的推广却至关重要，这项技术可以让我们的app关联一个网站，apple通过爬虫来获取我们规定的一些标签值，无论用户是否安装了app，在搜索时，都可以展示出相关信息，因为这项功能主要关联前端技术，需要了解的可以参看：[App Search Programming Guide](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/WebContent.html#//apple_ref/doc/uid/TP40016308-CH8)。 三、结语在我参考的许多相关文章中，都一致建议，iOS9的搜索功能固然强大，然而滥用会造成垃圾信息的泛滥，这样的结果一定会适得其反，作为开发者，我们需要将最合适，最简洁的信息推送到用户的面前。另外，文章有疏漏和错误之处，欢迎指正。 欢迎转载 请注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS9系列专题一——3D Touch","slug":"113iOS9系列专题一——3D Touch","date":"2015-09-25T16:00:00.000Z","updated":"2021-07-02T06:45:37.379Z","comments":true,"path":"2015/09/26/113iOS9系列专题一——3D Touch/","link":"","permalink":"http://huishao.cc/2015/09/26/113iOS9系列专题一——3D Touch/","excerpt":"","text":"新的触摸体验——iOS9的3D Touch一、引言在iphone6s问世之后，很多果粉都争先要体验3D Touch给用户带来的额外维度上的交互，这个设计之所以叫做3D Touch，其原理上是增加了一个压力的感触，通过区分轻按和重按来进行不同的用户交互。 二、在模拟器上学习和测试3D Touch3D Touch是一个很新颖的设计，可是苹果文档有言： With Xcode 7.0 you must develop on a device that supports 3D Touch. Simulator in Xcode 7.0 does not support 3D Touch. 看到这句话心是不是凉了一半，是的，xcode7是支持3D Touch开发的，可是模拟器并不支持这个手势，我们只能在真机上进行学习与测试，但是在IT的世界，从来都不缺拯救世界的人物，github上有人为我们提供了这样的一个插件，可以让我们在模拟器上进行3D Touch的效果测试： git地址：https://github.com/DeskConnect/SBShortcutMenuSimulator。 附.SBShortcutMenuSimulator的安装和使用其实安装和使用并不需要怎么介绍，git主页里介绍的很清楚，这里在记录一遍，其中只有一点需要注意，如果你像我一样，电脑中装有Xcode6和Xcode7两个版本，那个Xcode的编译路径，需要做一下修改。 安装： 在终端中一次运行如下指令： 123git clone https://github.com/DeskConnect/SBShortcutMenuSimulator.gitcd SBShortcutMenuSimulatormake 如果电脑中有多个Xcode版本，先做如下操作，如果只有Xcode7，则可以跳过 1sudo xcode-select -switch /Applications/Xcode2.app/Contents/Developer/ 注意：上面命令中，Xcode2.app是你电脑中Xcode的名字，这里如要特别注意，如果名字中有空格，需要修改一下，把空格去掉，否则会影响命令的执行。 之后在SBShortcutMenuSimulator的目录中执行如下操作： 12xcrun simctl spawn booted launchctl debug system/com.apple.SpringBoard --environment DYLD_INSERT_LIBRARIES=$PWD/SBShortcutMenuSimulator.dylibxcrun simctl spawn booted launchctl stop com.apple.SpringBoard 如果没有报错，我们可以通过向指定端口发送消息的方法来在模拟器上模拟3D Touch的效果： 1echo &apos;com.apple.mobilecal&apos; | nc 127.0.0.1 8000 其中，com.apple.mobilecal是应用的Bundle ID ，如果要测试我们的应用，将其改为我们应用的BundleID即可，上面的示例应用是系统日历，可以看到模拟器的效果如下： 三、3D Touch的主要应用文档给出的应用介绍主要有两块： 1.A user can now press your Home screen icon to immediately access functionality provided by your app. 2.Within your app, a user can now press views to see previews of additional content and gain accelerated access to features. 第一部分的应用是我们可以通过3D手势，在主屏幕上的应用Icon处，直接进入应用的响应功能模块。这个功能就例如我们上面的日历示例，会在Icon旁边出现一个菜单，点击菜单我们可以进入相应的功能单元。 我个人理解，这个功能，push消息功能加上iOS8推出的扩展today功能，这三个机制使iOS应用变得无比灵活方便，用户可以不需付出寻找的时间成本来快速使用自己需要的功能。 第二部分是对app的一个优化，用户可以通过3D Touch手势在view上来预览一些预加载信息，这样的设计可以使app更加简洁大方，交互性也更强。 四、3D Touch的三大模块在我们的app中使用3D Touch功能，主要分为以下三个模块： 1、Home Screen Quick Actions通过主屏幕的应用Icon，我们可以用3D Touch呼出一个菜单，进行快速定位应用功能模块相关功能的开发。如上面的日历。 2、peek and pop这个功能是一套全新的用户交互机制，在使用3D Touch时，ViewController中会有如下三个交互阶段： （1）提示用户这里有3D Touch的交互，会使交互控件周围模糊 （2）继续深按，会出现预览视图 （3）通过视图上的交互控件进行进一步交互 这个模块的设计可以在网址连接上进行网页的预览交互。 3.Force PropertiesiOS9为我们提供了一个新的交互参数:力度。我们可以检测某一交互的力度值，来做相应的交互处理。例如，我们可以通过力度来控制快进的快慢，音量增加的快慢等。 五、Home Screen Quick Action使用与相关api详解iOS9为我们提供了两种屏幕标签，分别是静态标签和动态标签。 1、静态标签静态标签是我们在项目的配置plist文件中配置的标签，在用户安装程序后就可以使用，并且排序会在动态标签的前面。 我们先来看静态标签的配置： 首先，在info.plist文件中添加如下键值（我在测试的时候，系统并没有提示，只能手打上去）： 先添加了一个UIApplicationShortcutItems的数组，这个数组中添加的元素就是对应的静态标签，在每个标签中我们需要添加一些设置的键值： 必填项（下面两个键值是必须设置的）： UIApplicationShortcutItemType 这个键值设置一个快捷通道类型的字符串 UIApplicationShortcutItemTitle 这个键值设置标签的标题 选填项（下面这些键值不是必须设置的）： UIApplicationShortcutItemSubtitle 设置标签的副标题 UIApplicationShortcutItemIconType 设置标签Icon类型 UIApplicationShortcutItemIconFile 设置标签的Icon文件 UIApplicationShortcutItemUserInfo 设置信息字典(用于传值) 我们如上截图设置后，运行程序，用我们前面的方法进行测试，效果如下： 2、动态标签动态标签是我们在程序中，通过代码添加的，与之相关的类，主要有三个： UIApplicationShortcutItem 创建3DTouch标签的类 UIMutableApplicationShortcutItem 创建可变的3DTouch标签的类 UIApplicationShortcutIcon 创建标签中图片Icon的类 因为这些类是iOS9中新增加的类，所以其api的复杂程度并不大，下面我们来对其中方法与属性进行简要讲解： 12345678910@interface UIApplicationShortcutItem : NSObject &lt;NSCopying, NSMutableCopying&gt;//下面是两个初始化方法 通过设置type，title等属性来创建一个标签，这里的icon是UIApplicationShortcutIcon对象，我们后面再说- (instancetype)initWithType:(NSString *)type localizedTitle:(NSString *)localizedTitle localizedSubtitle:(nullable NSString *)localizedSubtitle icon:(nullable UIApplicationShortcutIcon *)icon userInfo:(nullable NSDictionary *)userInfo NS_DESIGNATED_INITIALIZER;- (instancetype)initWithType:(NSString *)type localizedTitle:(NSString *)localizedTitle;//下面这是一些只读的属性，获取相应的属性值@property (nonatomic, copy, readonly) NSString *type;@property (nonatomic, copy, readonly) NSString *localizedTitle;@property (nullable, nonatomic, copy, readonly) NSString *localizedSubtitle;@property (nullable, nonatomic, copy, readonly) UIApplicationShortcutIcon *icon;@property (nullable, nonatomic, copy, readonly) NSDictionary&lt;NSString *, id &lt;NSSecureCoding&gt;&gt; *userInfo; 123456789//这个类继承于 UIApplicationShortcutItem，创建的标签可变@interface UIMutableApplicationShortcutItem : UIApplicationShortcutItem@property (nonatomic, copy) NSString *type;@property (nonatomic, copy) NSString *localizedTitle;@property (nullable, nonatomic, copy) NSString *localizedSubtitle;@property (nullable, nonatomic, copy) UIApplicationShortcutIcon *icon;@property (nullable, nonatomic, copy) NSDictionary&lt;NSString *, id &lt;NSSecureCoding&gt;&gt; *userInfo;@end 1234567//这个类创建标签中的icon@interface UIApplicationShortcutIcon : NSObject &lt;NSCopying&gt;//创建系统风格的icon+ (instancetype)iconWithType:(UIApplicationShortcutIconType)type;//创建自定义的图片icon+ (instancetype)iconWithTemplateImageName:(NSString *)templateImageName;@end 创建好标签后，将其添加如application的hortcutItems数组中即可，示例如下： 12345678- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建 UIApplicationShortcutItem * item = [[UIApplicationShortcutItem alloc]initWithType:@&quot;two&quot; localizedTitle:@&quot;第二个标签&quot; localizedSubtitle:@&quot;看我哦&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypePlay] userInfo:nil]; 添加 [UIApplication sharedApplication].shortcutItems = @[item];&#125; 效果如下： 这里，将系统风格icon的枚举列举如下： 123456789typedef NS_ENUM(NSInteger, UIApplicationShortcutIconType) &#123; UIApplicationShortcutIconTypeCompose,//编辑的图标 UIApplicationShortcutIconTypePlay,//播放图标 UIApplicationShortcutIconTypePause,//暂停图标 UIApplicationShortcutIconTypeAdd,//添加图标 UIApplicationShortcutIconTypeLocation,//定位图标 UIApplicationShortcutIconTypeSearch,//搜索图标 UIApplicationShortcutIconTypeShare//分享图标&#125; NS_ENUM_AVAILABLE_IOS(9_0); 3、响应标签的行为类似推送，当我们点击标签进入应用程序时，也可以进行一些操作，我们可以看到，在applocation中增加了这样一个方法： - (void)application:(UIApplication )application performActionForShortcutItem:(UIApplicationShortcutItem )shortcutItem completionHandler:(void(^)(BOOL succeeded))completionHandler NS_AVAILABLE_IOS(9_0); 当我们通过标签进入app时，就会在appdelegate中调用这样一个回调，我们可以获取shortcutItem的信息进行相关逻辑操作。 这里有一点需要注意：我们在app的入口函数： - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions; 也需要进行一下判断，在launchOptions中有UIApplicationLaunchOptionsShortcutItemKey这样一个键，通过它，我们可以区别是否是从标签进入的app，如果是则处理结束逻辑后，返回NO，防止处理逻辑被反复回调。 几点注意： 1、快捷标签最多可以创建四个，包括静态的和动态的。 2、每个标签的题目和icon最多两行，多出的会用…省略 六、结语关于3DTouch在UIView中的预览功能和UITouch中新增加的力度属性的应用，因为不好演示，这里就不再总结，大家可以通过头文件中相应的类和属性来了解他们，最后，如有疏漏和错误之处，欢迎指正。 欢迎转载 请注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}],"tags":[],"keywords":[{"name":"iOS9专题","slug":"iOS9专题","permalink":"http://huishao.cc/categories/iOS9专题/"}]},{"title":"iOS中UISearchBar(搜索框)使用总结","slug":"112iOS中UISearchBar(搜索框)使用总结","date":"2015-09-21T16:00:00.000Z","updated":"2021-07-01T11:26:06.410Z","comments":true,"path":"2015/09/22/112iOS中UISearchBar(搜索框)使用总结/","link":"","permalink":"http://huishao.cc/2015/09/22/112iOS中UISearchBar(搜索框)使用总结/","excerpt":"","text":"iOS中UISearchBar(搜索框)使用总结初始化：UISearchBar继承于UIView，我们可以像创建View那样创建searchBar 12 UISearchBar * bar = [[UISearchBar alloc]initWithFrame:CGRectMake(20, 100, 250, 40)]; [self.view addSubview:bar]; @property(nonatomic) UIBarStyle barStyle; 这个属性可以设置searchBar的搜索框的风格，枚举如下： 1234567typedef NS_ENUM(NSInteger, UIBarStyle) &#123; UIBarStyleDefault = 0,//默认风格 白色搜索框，多出的背景为灰色 UIBarStyleBlack = 1,//黑色风格，黑色的搜索框 //下面两个枚举已经被禁用，作用和黑色风格一样 UIBarStyleBlackOpaque = 1, // Deprecated. Use UIBarStyleBlack UIBarStyleBlackTranslucent = 2, // Deprecated. Use UIBarStyleBlack and set the translucent property to YES&#125;; @property(nonatomic,copy) NSString *text; 设置搜索框中的文字 @property(nonatomic,copy) NSString *prompt; 这个属性的官方解释是在搜索框顶部显示一行文字，其实就是背景文字，上图说明： 12 bar.prompt = @&quot;搜索框&quot;; bar.text=@&quot;321111111111111111111111111&quot; 效果如下： @property(nonatomic,copy) NSString *placeholder; 和其他文本输入控件的placeholder相同，在输入文字时就会消失 @property(nonatomic) BOOL showsBookmarkButton; 是否在搜索框右侧显示一个图书的按钮，默认为NO，YES的效果如下： @property(nonatomic) BOOL showsCancelButton; 是否显示取消按钮，默认为NO，YES的效果如下： @property(nonatomic) BOOL showsSearchResultsButton; 是否显示搜索结果按钮，默认为NO，YES效果如下： @property(nonatomic, getter=isSearchResultsButtonSelected) BOOL searchResultsButtonSelected ; 设置搜索结果按钮的选中状态 - (void)setShowsCancelButton:(BOOL)showsCancelButton animated:(BOOL)animated; 设置显示取消按钮 @property(nonatomic,retain) UIColor *tintColor; 设置这个颜色值会影响搜索框中的光标的颜色 @property(nonatomic,retain) UIColor *barTintColor; 设置这个颜色会影响搜索框的背景颜色 @property (nonatomic) UISearchBarStyle searchBarStyle; 设置搜索框整体的风格，枚举如下： 12345typedef NS_ENUM(NSUInteger, UISearchBarStyle) &#123; UISearchBarStyleDefault, // currently UISearchBarStyleProminent UISearchBarStyleProminent, // 显示背景 UISearchBarStyleMinimal // 不显示背景&#125; NS_ENUM_AVAILABLE_IOS(7_0); @property(nonatomic,assign,getter=isTranslucent) BOOL translucent; 设置是否半透明 @property(nonatomic) BOOL showsScopeBar ; 是否显示搜索栏的附件选择按钮试图，要想显示这个试图，首先要将这个属性设置为YES，之后给按钮数组中添加按钮，使用下面这个属性： @property(nonatomic,copy) NSArray *scopeButtonTitles ； 设置选择按钮试图的按钮标题 @property(nonatomic) NSInteger selectedScopeButtonIndex; 设置一个默认的选中按钮 123 bar = [[UISearchBar alloc]initWithFrame:CGRectMake(20, 100, 250, 200)]; bar.showsScopeBar=YES; bar.scopeButtonTitles = @[@&quot;12&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;]; @property (nonatomic, readwrite, retain) UIView *inputAccessoryView; 键盘的附属试图 @property(nonatomic,retain) UIImage *backgroundImage; 设置搜索框的背景图案 @property(nonatomic,retain) UIImage *scopeBarBackgroundImage; 设置附属选择按钮视图的背景图案 - (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics ; - (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics 这一对方法可以设置和获取某个状态枚举下的搜索框的背景图案 - (void)setSearchFieldBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; - (UIImage *)searchFieldBackgroundImageForState:(UIControlState)state; 这一对方法用于设置和获取搜索框中TextField的背景图案 - (void)setImage:(UIImage *)iconImage forSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state ; - (UIImage *)imageForSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state ; 这一对方法用于获取和设置搜索栏icon图片的图案 - (void)setScopeBarButtonBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; - (UIImage *)scopeBarButtonBackgroundImageForState:(UIControlState)state; 这一对方法用于设置和获取搜索框的附加选择按钮视图的背景图案 - (void)setScopeBarButtonDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; - (UIImage *)scopeBarButtonDividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; 这一对方法用于获取和设置附加选择按钮视图中切换按钮的图案 - (void)setScopeBarButtonTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state; - (NSDictionary *)scopeBarButtonTitleTextAttributesForState:(UIControlState)state; 这一对方法用于设置和获取切换按钮标题文字的字体属性字典 @property(nonatomic) UIOffset searchFieldBackgroundPositionAdjustment; 搜索文字在搜索框中的位置偏移 @property(nonatomic) UIOffset searchTextPositionAdjustment; textfield在搜索框中的位置偏移 - (void)setPositionAdjustment:(UIOffset)adjustment forSearchBarIcon:(UISearchBarIcon)icon; - (UIOffset)positionAdjustmentForSearchBarIcon:(UISearchBarIcon)icon; 设置搜索栏中图片的位置偏移，图片的枚举如下： 123456typedef NS_ENUM(NSInteger, UISearchBarIcon) &#123; UISearchBarIconSearch, //搜索图标 UISearchBarIconClear, // 清除图标 UISearchBarIconBookmark, // 书本图标 UISearchBarIconResultsList, // 结果列表图标&#125;; 下面是搜索框控件的一些代理方法： - (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar; 将要开始编辑时的回调，返回为NO，则不能编辑 - (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar; 已经开始编辑时的回调 - (BOOL)searchBarShouldEndEditing:(UISearchBar *)searchBar; 将要结束编辑时的回调 - (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar; 已经结束编辑的回调 - (void)searchBar:(UISearchBar )searchBar textDidChange:(NSString )searchText; 编辑文字改变的回调 - (BOOL)searchBar:(UISearchBar )searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString )text ; 编辑文字改变前的回调，返回NO则不能加入新的编辑文字 - (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar; 搜索按钮点击的回调 - (void)searchBarBookmarkButtonClicked:(UISearchBar *)searchBar; 书本按钮点击的回调 - (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar; 取消按钮点击的回调 - (void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar; 搜索结果按钮点击的回调 - (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope; 搜索栏的附加试图中切换按钮触发的回调 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"mac端的优秀抓包工具——Charles使用","slug":"111mac端的优秀抓包工具——Charles使用","date":"2015-09-19T16:00:00.000Z","updated":"2021-07-01T11:20:23.087Z","comments":true,"path":"2015/09/20/111mac端的优秀抓包工具——Charles使用/","link":"","permalink":"http://huishao.cc/2015/09/20/111mac端的优秀抓包工具——Charles使用/","excerpt":"","text":"mac端的优秀抓包工具——Charles使用一、简介Charles是mac端的一款截取与分析网络请求的工具，在网络开发中使用其作分析，可以大大提高我们的开发效率。Charles是收费软件，一般可以试用三十天，但是可以通过相应的破解来获取服务（这里只做演示使用，希望大家购买正版软件）。Charles软件和破解包下载地址：[http://pan.baidu.com/s/1ySsUy](http://pan.baidu.com/s/1ySsUy)。 二、安装与使用下载好压缩包后，解压打开，将软件包拖入应用程序文件夹中，这时候一个原版的软件就可以让我们使用，只是有一个试用期，右键单击我们的Charles应用，显示包内容： 将如下文件夹中的jar包替换为我们破解文件夹中的jar包： 三、使用Charles在mac上进行抓包分析在软件安装完成后，我们已经可以在mac上截取一般的网络请求了，打开软件，将Proxy设置中的Mac OS X Proxy勾选，设置为网络代理，这时候如果发生网络请求，就可以被Charles截获到 如果我们需要截取SSL协议的网络请求，这时候我们还需要安装一个证书：http://yun.baidu.com/s/1o6J2Crg。注意将证书权限设置为始终信任。 抓获信息的界面如下： 软件的功能十分强大，Structure是将请求按域名排序，Sequence是将请求时间排序，下面的Request和Response分别为请求的数据包和返回的数据包，如果是json数据，还会自动帮我们解析格式。 注意：如果iOS模拟器上抓不到请求包，重启模拟器即可。 四、在移动设备上进行抓包导入证书的过程和在mac上一样，在移动设备上访问[http://yun.baidu.com/s/1o6J2Crg](http://yun.baidu.com/s/1o6J2Crg)。进行证书下载，安装： 在移动设备上截获网络请求，我们的移动设备必须和电脑在同一网段，在我们电脑的网络设置中查看IP地址，然后在移动设备上点击我们连接的电脑上的网络，在代理一栏中，选择手动，将我们刚才查看的ip地址填写在这里，并且设置一个端口号。 在Charles中的Proxy setting中如下勾选并配置端口号 我们在设备上再访问网络，请求包就可以被我们抓取到。 五、Charles的更多应用1、过滤网络请求有时候我们只想抓取某个主机的网络请求，我们可以设置过滤网络，在Proxy菜单中的Recording Setting中，我们选择include标签，可以在里面添加一个白名单，这样Charles就只截取在这个主机下的请求： 2、模拟限速网络很多时候，我们需要测试在网络不佳时应用请求的相关数据，我们可以模拟设置限速网络，在Proxy菜单中的Throttle Settings中将，Enable Throttling勾选，并可以在下面进行网路设置，only for selected host可以设置一个指定的主机访问进行限制网络。 3、修改网络信息，多次请求在测试接口时，有时候我们需要反复进行不同参数的接口请求，Charles也支持我们进行请求参数的修改和多次请求，在请求上点击右键，现则edit： 其中的参数，请求类型等我们都可以修改，之后点击execute进行重新请求 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}],"tags":[],"keywords":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}]},{"title":"工厂设计模式的探讨——iOS类簇的应用分析","slug":"110工厂设计模式的探讨——iOS类簇的应用分析","date":"2015-09-17T16:00:00.000Z","updated":"2021-07-01T11:18:02.308Z","comments":true,"path":"2015/09/18/110工厂设计模式的探讨——iOS类簇的应用分析/","link":"","permalink":"http://huishao.cc/2015/09/18/110工厂设计模式的探讨——iOS类簇的应用分析/","excerpt":"","text":"工厂设计模式的探讨——iOS类簇的应用分析一、何为设计模式什么是设计模式，先来看段度娘的话： 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 其实我们不需要这么专业，在我的理解，设计模式就是一种规范化的编程习惯，养成了这样的思想与习惯，对我们的代码，总是有好处了。 二、工厂设计模式首先，工厂设计模式是创建对象的一种设计模式，一个严格意义上的工厂设计模式应该是一个纯虚的构造方法。由子类进行具体对象的创建，我们可以这样理解：现在有一个珲少牌制造工厂，这个工厂可以制造多种交通工具，我大胆一些，假设它可以制造飞机，轮船。小汽车，公交车，出租出和自行车，那么，这些不同的车种虽然功能和大类别统一，但是他们的个体差异也是天地之别，就比如我飞机一小时可以飞5000公里，自行车拼死了劲也不一定能骑20公里。所以，如果珲少这个大工厂要生产他们，也不可能把他们放在一起生产。一个比较明智的决定是，开立分厂，比如珲少飞机工厂专门生产飞机，珲少自行车工厂专门生产自行车。 好了，如果将我们这种人类世界的思维运用于程序世界，那么我们可以通过工厂的这种思维方式来将一些大类抽象为工厂，通过定义接口或者说是定义虚函数来规范这个大工厂的生产规模和流程，由其子类来具体实现这些方法，也就是由一个个小的分厂来明确的生产我们需要的东西。这就是工厂设计模式的基本思路。 三、工厂的设计模式有什么用许多开发者或许并不在意设计模式这个东西，我们可能会想，我实现我的功能就可以了，你管我怎么设计呢。在这篇博客的开头就说到，在我理解中，设计模式就是一种编程习惯和规范，更是一种众多开发者摸索出来的经验，这就像农业上的套种间种和你随便种，哪一种效率高，收成好，不言而喻。那么在软件设计中，工厂模式的应用在哪呢？ 我们先来体验一下在iOS开发中，一些使用工厂设计模式的系统类为我们带来的便捷之处： 1、认识一个名词 类簇在iOS的Foundation框架中，类簇是一种常用的设计模式，他将一些相近的，私有的，具体的子类组合在一个实体的抽象类下面，我称这个抽象类为实体的，是因为和我们交互的接口承载者，就是这个抽象大类。我们平时常用的三大类，NSString,NSArray,NSDictionary都是类簇，我们通过他们创建的对象都是其子类对象的实例化，并不是他本身的实例化，我们还通过上面的例子来理解，我买了一辆珲少小汽车，这两汽车的生产实际是在珲少汽车工厂生产的，但是我个人会依然认为，这是珲少工厂出产的汽车。我们可以通过打印类名来验证： 12NSString * str = [[NSString alloc]initWithCString:&quot;2&quot; encoding:0]; NSLog(@&quot;%@&quot;,[str class]); 结果如下： 可以看到，真实的对象是NSString的子类__NSCFString进行实例化的。 2.这样设计的优势在哪如果你通过NSString的事例还是无法体会到类簇，也就是工厂设计模式的优势，那么下面这个例子你一定经常遇到:NSNumber。我们在创建数字对象的时候，通常会这样考虑，如果是int值，我需要一个IntNumber的类，float值，我需要一个FloatNumber类，如果foundation框架真这么设计的话，那么你现在就痛苦了，你不仅要记住好多这样相似的类，调用方法时也要相应的对象调其内的方法，这使开发者的开发变得更加繁琐，并且对于开发者来说，我并不需要知道具体我创建了什么类，我只是想让他完成既定的方法。说的更通俗一点，还是上面的制造工厂，使用者并不在乎具体这个交通工具是哪个地方生产出来的，只要它价钱和速度都是使用者预期的结果就好了。 3.工厂设计模式的应用通过上面的分析，我们大致可以总结出工厂这种设计模式的应用场景： （1）当一个类并不知道要创建的具体对象是什么，交由子类处理 （2）当一些类有相似的行为和结构，只是具体实现不同时，可以抽象出工厂 （3）使用者并不在乎具体类型，只在乎接口约定的行为，并且这种行为有个体差异 四、在iOS中模拟一个工厂同样是上面的例子，我们来用代码模拟一下： 首先，我们创建一个抽象的工程类，在其中创建一些私有的子类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &lt;Foundation/Foundation.h&gt;//交通工具的枚举typedef enum &#123;car,boat,airport,bycicle,bus,taxi&#125;ToolsName;//代理@protocol TransPortationDelegate &lt;NSObject&gt;-(void)toHome:(Class)class;@end//抽象工厂类@interface TramsPortationFactory : NSObject+(TramsPortationFactory*)buyTool:(ToolsName)tool;//共有的方法接口-(int)shouldPayMoney;-(void)run;@property(nonatomic,strong)id&lt;TransPortationDelegate&gt;delegate;@end//具体实现的子类@interface CarFactory : TramsPortationFactory@end@interface BoatFactory : TramsPortationFactory@end@interface AirportFactory : TramsPortationFactory@end@interface BycicleFactory : TramsPortationFactory@end@interface TaxiFactory : TramsPortationFactory@end@interface BusFactory : TramsPortationFactory@end 实现文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#import &quot;TramsPortationFactory.h&quot;@implementation TramsPortationFactory//实现的创建方法+(TramsPortationFactory*)buyTool:(ToolsName)tool&#123; switch (tool) &#123; case car: return [[CarFactory alloc]init]; break; case airport: return [[AirportFactory alloc]init]; break; case bycicle: return [[BycicleFactory alloc]init]; break; case boat: return [[BoatFactory alloc]init]; break; case taxi: return [[TaxiFactory alloc]init]; break; case bus: return [[BusFactory alloc]init]; break; default: break; &#125;&#125;-(int)shouldPayMoney&#123; return 0;&#125;-(void)run&#123; [self.delegate toHome:[self class]];&#125;@end//各自类实现具体的行为@implementation CarFactory-(int)shouldPayMoney&#123; return 50;&#125;-(void)run&#123; [super run]; NSLog(@&quot;car to home&quot;);&#125;@end@implementation AirportFactory-(int)shouldPayMoney&#123; return 1000;&#125;-(void)run&#123; [super run]; NSLog(@&quot;fly to home&quot;);&#125;@end@implementation BoatFactory-(int)shouldPayMoney&#123; return 300;&#125;-(void)run&#123; [super run]; NSLog(@&quot;boat to home&quot;);&#125;@end@implementation BusFactory-(int)shouldPayMoney&#123; return 10;&#125;-(void)run&#123; [super run]; NSLog(@&quot;bus to home&quot;);&#125;@end@implementation BycicleFactory-(int)shouldPayMoney&#123; return 0;&#125;-(void)run&#123; [super run]; NSLog(@&quot;run to home&quot;);&#125;@end@implementation TaxiFactory-(int)shouldPayMoney&#123; return 100;&#125;-(void)run&#123; [super run]; NSLog(@&quot;go to home&quot;);&#125;@end 这样，我们的一个生产工厂就完成了，在外面，我们只需要知道一个类，我们的抽象父类，就可以实现个子类的行为，示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; TramsPortationFactory * tool = [TramsPortationFactory buyTool:car]; tool.delegate=self; [tool run]; NSLog(@&quot;花了:%d钱&quot;,[tool shouldPayMoney]); TramsPortationFactory * tool2 = [TramsPortationFactory buyTool:airport]; tool2.delegate=self; [tool2 run]; NSLog(@&quot;花了:%d钱&quot;,[tool2 shouldPayMoney]); &#125;-(void)toHome:(Class)class&#123; NSLog(@&quot;%@&quot;,NSStringFromClass(class));&#125; 可以看到，对于开发者，我们并不知晓CarFactory类的存在，我们只需要通过TramsPortationFactory类，就能够操作各种交通工具，达到我们的需求。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}],"tags":[],"keywords":[{"name":"设计模式两三谈","slug":"设计模式两三谈","permalink":"http://huishao.cc/categories/设计模式两三谈/"}]},{"title":"iOS生成标准的注释工具——VVDocumenter","slug":"109iOS生成标准的注释工具——VVDocumenter","date":"2015-09-15T16:00:00.000Z","updated":"2021-07-01T11:16:00.753Z","comments":true,"path":"2015/09/16/109iOS生成标准的注释工具——VVDocumenter/","link":"","permalink":"http://huishao.cc/2015/09/16/109iOS生成标准的注释工具——VVDocumenter/","excerpt":"","text":"iOS生成标准的注释工具——VVDocumenter在程序开发中，我们免不了要写许多注释，方便帮别人也方便我们自己以后检查我们的代码。然而，写注释是一件十分浪费我们时间与精力的事，要写符合文档格式的注释，更是会消耗我们很多的功夫，幸运的是，VVDocumenter可以帮我们很大的忙。 gitHub地址：[https://github.com/onevcat/VVDocumenter-Xcode](https://github.com/onevcat/VVDocumenter-Xcode)。 安装与使用方法：下载github源码，使用xcode打开工程，运行一下，如果成功，插件就安装好了，这时，我们必须将xcode重新启动一下，才可以使用。 重启xcode，在任意一个地方输入///，即会自动出现如下的注释模板，参数部分已经由占位符写好 123456/** * &lt;#Description#&gt; * * @param data &lt;#data description#&gt; */- (void)updateWithData:(id)data; 是不是写注释变成了一件非常有趣的事，你还可以对其进行一些设置，在xcode-&gt;window菜单栏中，有VVDocumenter这个标签，里面可以对生成注释的模板进行一些设置，比如生成注释的快捷键，注释的对齐模式，注释显示创建者和时间等。例如如下设置就会生成这样的注释： 12345678/** * @author Elephant, 15-09-16 13:09:28 * * @brief &lt;#Description#&gt; * * @param data &lt;#data description#&gt; */ - (void)updateWithData:(id)data; 最后，推荐这款小插件给你，祝你写代码愉快O(∩_∩)O。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}],"tags":[],"keywords":[{"name":"小码工具","slug":"小码工具","permalink":"http://huishao.cc/categories/小码工具/"}]},{"title":"我的女神——简洁实用的iOS代码调试框架","slug":"108我的女神——简洁实用的iOS代码调试框架","date":"2015-09-09T16:00:00.000Z","updated":"2021-07-01T11:14:20.096Z","comments":true,"path":"2015/09/10/108我的女神——简洁实用的iOS代码调试框架/","link":"","permalink":"http://huishao.cc/2015/09/10/108我的女神——简洁实用的iOS代码调试框架/","excerpt":"","text":"我的女神——简洁实用的iOS代码调试框架一、引言这篇博客的起源是接手了公司的一个已经完成的项目，来做代码优化，项目工程很大，并且引入了很多公司内部的SDK，要搞清楚公司内部的这套框架，的确不是件容易的事，并且由于这个项目是多人开发的，在调试阶段会打印出巨量的调试信息，使得浏览有用信息变的十分困难，更加恐怖的是，很多信息是SDK中的调试打印，将这些都进行注销是非常费劲甚至不可能的事，于是便有了这样一些需求：首先，我需要清楚了解各个controller之间的跳转关系，需要快速的弄清每个stroyBoard中各个controller的来龙去脉，其次，我想在不改变其他人的调试代码的情况下，屏蔽冗余的log信息，让我的调试数据更加清晰明了。于是我想到了如下的解决方案，同样，如果你有更好的方案或者你知道的优秀的解决办法，请告知我，十分感谢。 二、追踪程序的跳转路径这是一个很容易解决的问题，我们都知道，一个controller，如果要展现出来，一定会走生命周期中的viewWillAppear这个方法，我们只需要在这个方法中做些手脚就可以了，实现有两种思路，一种是采用工厂的设计模式，建立工厂类Controller，在其viewWillAppear中加入我们的调试代码，但这对于我的项目并不实用，首先我不确定所有controller都会继承于一个父类，其次，在我没有找到源头时，这些类已经在公司的framework中了，我根本没办法操作源码。而第二种方案就是runtime，对的，运行时的OC，没有不可能。关于runtime的详细说明，在[http://my.oschina.net/u/2340880/blog/489072](http://my.oschina.net/u/2340880/blog/489072)中有介绍。思路是我们可以写一个方法，替换掉系统的viewWillAppear，在其中加入我们的调试代码，这个方法就是Method Swizzing，代码设计如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//新建一个conreoller的类别#import &quot;UIViewController+YHBaseTest.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIViewController (YHBaseTest)+ (void)load &#123; //只执行一次的线程 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); //创建两个选择器 分别指向 系统的和我们要替换的函数 SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(YHBaseViewWillAppear:); //获取方法实例 Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); //现将方法加入 BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); //进行方法替换 if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)YHBaseViewWillAppear:(BOOL)animated &#123;//这里是是我加的一个控制调试锁 后面会介绍 [self YHBaseViewWillAppear:animated]; YHBaseProcessLog(@&quot;YHBaseTest:ViewWillAppear: %@&quot;, self); &#125; 三、屏蔽冗余的log信息1、系统的NSLog是个什么玩意要战胜我们的敌人，首先应该了解我们的敌人，我们想要屏蔽NSLog的打印，先需要清楚NSLog到底是个什么玩意。 首先，NSLog的定义如下： 12FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2);FOUNDATION_EXPORT void NSLogv(NSString *format, va_list args) NS_FORMAT_FUNCTION(1,0); 这里面有两个函数，一个是使用多参的格式化字符串进行NSLog的打印，一个是通过参数指针进行打印。从这里我们可以看出，系统的NSLog是一个C风格的函数，所以，我们有思路了，我们可以通过定义一个NSLog宏来替换掉项目中所有的NSLog，如下： 12//...是省略参数的宏的写法，后面的__VA_ARGS__是系统定义好的一个宏，来声明不定参数#define NSLog(...) YHBaseTestLog(__VA_ARGS__) 2、实现我们自己的NSLog通过上面的方法，在没有动源码的情况下，我们已经可以替换掉程序中所有的打印，可能你会疑问，程序中怎么会允许我们有两个NSLog呢，其实这没什么神奇的，要知道宏是一种预编译的指令，所有这些操作是在代码编译之前完成的，实际上程序中已经将NSLog简单替换成了我们的函数调用，程序中只有一个NSLog，这就是宏的强大之处，狸猫换太子，不错吧。 下面我们来实现我们的这个函数，如下： 123456789101112//不要忘了在.h文件中声明void YHBaseTestLog(NSString *str,...)&#123;//参数列 va_list list; va_start(list, str); //这个地方是一个锁，后面会介绍 if (![YHBaseTestLock sharedTheSingletion]-&gt;_customLock) &#123; //进行打印 NSLogv(str, list); &#125; va_end(list);&#125; 这个函数中其实并没有做什么，加了一个锁的判断，仅此而已，核心的控制，就交给我们的锁吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//.h文件@interface YHBaseTestLock : NSObject&lt;YHSingletonProcotol&gt;&#123; @public BOOL _customLock; BOOL _precessLock;&#125;+(void)customLock;+(void)customUnLock;+(void)processLogLock;+(void)processLogUnLock;//.m//单例方法+(instancetype)sharedTheSingletion&#123; static YHBaseTestLock * sharedModel = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; sharedModel = [[YHBaseTestLock alloc] init]; &#125;); return sharedModel;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; //初始化 默认用户的打印都开起 _customLock=NO; //默认 我们加的controller的打印屏蔽 _precessLock=YES; &#125; return self;&#125;//响应的设置+(void)customLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_customLock=YES;&#125;+(void)customUnLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_customLock=NO;&#125;+(void)processLogLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_precessLock=YES;&#125;+(void)processLogUnLock&#123; [YHBaseTestLock sharedTheSingletion]-&gt;_precessLock=NO;&#125; 四、看看我们的杰作吧做完上面的工作后，我们在appdelegate中如如下的简单配置： 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //将用户打印加锁 [YHBaseTestLock customLock]; //将流程打印解锁 [YHBaseTestLock processLogUnLock]; return YES;&#125; 我们做如下测试： 1234567891011121314@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSLog(@&quot;111111111111111111111111111111111111111111111111111111111111111&quot;); [YHBaseTestLock customUnLock]; NSLog(@&quot;这个是有用的信息:%@==%d&quot;,@&quot;看我哦&quot;,__LINE__); [YHBaseTestLock customLock]; NSLog(@&quot;32123213123214412312312&quot;);&#125; 我在viewController中的有用信息前后，打印了一些干扰信息，并且可以看到，这个NSLog的格式和系统的完全兼容，在打印有用信息前后解锁和加锁，结果如下： 可以看到，我们将没用的打印都屏蔽了，并且打印了程序的跳转流程。最重要的是，我们对源码一个字符都没有修改，同时不会影响与冲突其他人的开发。 这篇博客开头，我称之为我的女神，真心实感，这个方法帮了我很大的忙，在我了解项目的结构框架前，每次调试打印都在控制区滚出一片片的信息着实让我头晕脑胀，现在一清凉，精神也清爽不少，^_^。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS开发一款小巧简洁的日历控件","slug":"107iOS开发一款小巧简洁的日历控件","date":"2015-09-06T16:00:00.000Z","updated":"2021-07-01T11:09:06.101Z","comments":true,"path":"2015/09/07/107iOS开发一款小巧简洁的日历控件/","link":"","permalink":"http://huishao.cc/2015/09/07/107iOS开发一款小巧简洁的日历控件/","excerpt":"","text":"iOS开发一款小巧简洁的日历控件一、引言日 历是iOS开发中有时会用到的一个UI控件，网上开源的代码也很多，我浏览过一些，大致有两种模式，一种是日历的逻辑由开发者自己实现，通过计算闰年与平 年来确定月份天数，另外一种模式是通过NSDate这个时间类，来获取日历的信息。我个人认为后一种更加安全，代码性能也会更加优质，下面就是我用这种模 式实现的一个日历控件。 二、设计思路1、先来看下效果吧 2、我们需要实现的功能（1）每行7天，对应星期，列数为将当前月显示完全 （2）今日标红 （3）点击的日期背景填充 （4）提供特殊标记，用于标记计划日，节日等 （5）左右无限翻页，直到世界起源和末日 3、设计步骤（1）设计一个日历模型 1234567#import &quot;YHBaseModel.h&quot;@interface YHBaseDateModel : YHBaseModel@property(nonatomic,strong)NSString * year;@property(nonatomic,strong)NSString * month;@property(nonatomic,strong)NSString * day;@end （2）向系统的NSDate类中添加一些扩展方法，便于我们使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//头文件部分@interface NSDate (YHBaseCalendar)/** *获取当前月的天数 */- (NSUInteger)YHBaseNumberOfDaysInCurrentMonth;/** *获取本月第一天 */- (NSDate *)YHBaseFirstDayOfCurrentMonth;//下面这些方法用于获取各种整形的数据/** *确定某天是周几 */-(int)YHBaseWeekly;/** *年月日 时分秒 */-(int)getYear;-(int)getMonth;-(int)getDay;-(int)getHour;-(int)getMinute;-(int)getSecond;@end//实现部分@implementation NSDate (YHBaseCalendar)-(NSUInteger)YHBaseNumberOfDaysInCurrentMonth&#123; return [[NSCalendar currentCalendar] rangeOfUnit:NSDayCalendarUnit inUnit:NSMonthCalendarUnit forDate:self].length; &#125;- (NSDate *)YHBaseFirstDayOfCurrentMonth&#123; NSDate *startDate = nil; BOOL ok = [[NSCalendar currentCalendar] rangeOfUnit:NSMonthCalendarUnit startDate:&amp;startDate interval:NULL forDate:self]; NSAssert1(ok, @&quot;Failed to calculate the first day of the month based on %@&quot;, self); return startDate;&#125;-(int)YHBaseWeekly&#123; return (int)[[NSCalendar currentCalendar] ordinalityOfUnit:NSDayCalendarUnit inUnit:NSWeekCalendarUnit forDate:self];&#125;-(int)getYear&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.year;&#125;-(int)getMonth&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.month;&#125;-(int)getDay&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.day;&#125;-(int)getHour&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.hour;&#125;-(int)getMinute&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.minute;&#125;-(int)getSecond&#123; NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate:self]; return (int)dateComponent.second;&#125;@end （3）设计我们的UI控件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//头文件部分@interface YHBaseCalendarView : YHBaseView@property(nonatomic,strong)NSDate * currentDate;//标记数组 用于标记特殊日期 这个数组中存放的必须是YHBaseDateModel 对象@property(nonatomic,strong)NSArray * markArray;@property(nonatomic,weak)id&lt;YHBaseCalendarViewDelegate&gt; delegate;@end//实现部分@interface YHBaseCalendarView()&lt;UIScrollViewDelegate&gt;&#123; //星期 UIView * _headView; //日历的展示 UIView * _bodyViewL; UIView * _bodyViewM; UIView * _bodyViewR; //滑动功能的支持 UIScrollView * _scrollView; NSDate * _today; YHBaseDateModel * _selectModel;&#125;@end@implementation YHBaseCalendarView-(void)reloadView&#123; _currentDate = [NSDate date]; _today = [NSDate date]; _selectModel = [[YHBaseDateModel alloc]init]; _selectModel.year = [NSString stringWithFormat:@&quot;%d&quot;,[_today getYear]]; _selectModel.month =[NSString stringWithFormat:@&quot;%d&quot;,[_today getMonth]]; _selectModel.day = [NSString stringWithFormat:@&quot;%d&quot;,[_today getDay]]; _scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(0, 30, self.frame.size.width, self.frame.size.height)]; _scrollView.contentSize = CGSizeMake(3*self.frame.size.width, 0); _scrollView.contentOffset = CGPointMake(self.frame.size.width, 0); _scrollView.pagingEnabled=YES; _scrollView.delegate=self; [self addSubview:_scrollView]; _bodyViewL = [[UIView alloc]initWithFrame:CGRectMake(0, 0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewL]; _bodyViewM = [[UIView alloc]initWithFrame:CGRectMake(_scrollView.frame.size.width,0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewM]; _bodyViewR = [[UIView alloc]initWithFrame:CGRectMake(_scrollView.frame.size.width*2, 0, _scrollView.frame.size.width, _scrollView.frame.size.height)]; [_scrollView addSubview:_bodyViewR]; //展示星期 _headView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, self.frame.size.width, 30)]; _headView.backgroundColor = [UIColor redColor]; NSArray * weekArray = @[@&quot;SUN&quot;,@&quot;MON&quot;,@&quot;TUES&quot;,@&quot;WED&quot;,@&quot;THUR&quot;,@&quot;FRI&quot;,@&quot;SAT&quot;]; for (int i=0; i&lt;7; i++) &#123; UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(self.frame.size.width/7*i, 0, self.frame.size.width/7, 30)]; if (i!=0&amp;&amp;i!=6) &#123; label.backgroundColor = [UIColor redColor]; &#125;else&#123; label.backgroundColor = [UIColor purpleColor]; &#125; label.text=weekArray[i]; label.textAlignment = NSTextAlignmentCenter; label.layer.borderWidth=1; label.layer.borderColor = [[UIColor grayColor]CGColor]; label.font = [UIFont boldSystemFontOfSize:16]; label.layer.borderColor=[[UIColor grayColor] CGColor]; label.textColor = [UIColor whiteColor]; label.layer.borderWidth = 1; [_headView addSubview:label]; &#125; [self addSubview:_headView]; [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR];&#125;//核心的构造方法-(void)creatViewWithData:(id)data onView:(UIView *)bodyView&#123; NSDate * currentDate = (NSDate *)data; //获取当前月有多少天 int monthNum = (int)[currentDate YHBaseNumberOfDaysInCurrentMonth]; //获取第一天的日期 NSDate * firstDate = [currentDate YHBaseFirstDayOfCurrentMonth]; //确定这一天是周几 int weekday = [firstDate YHBaseWeekly]; //确定创建多少行 int weekRow=0; int tmp=monthNum; if (weekday!=7) &#123; weekRow++; tmp=monthNum-(7-weekday); &#125; weekRow += tmp/7; weekRow += (tmp%7)?1:0; //开始创建按钮 /** *这里的逻辑是有问题的，应该设计成cell的复用机制，而不应该重复耗性能的创建 有时间在优化 */#warning 可以优化哦 NSArray * array = [bodyView subviews]; for (UIView * v in array) &#123; [v removeFromSuperview]; &#125; int nextDate = 1; //行 for (int i=0; i&lt;weekRow; i++) &#123; //列 for (int j=0; j&lt;7; j++) &#123; //先进行上个月余天的创建 UIButton * btn; if (weekday!=7&amp;&amp;(i*7+j)&lt;weekday) &#123; //获取上个月有多少天 NSDate * preDate = [YHBaseDateTools getPreviousframDate:currentDate]; int preDays = (int)[preDate YHBaseNumberOfDaysInCurrentMonth]; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,preDays-weekday+j+1] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125;else if((i*7+j+1-(weekday==7?0:weekday))&lt;=monthNum)&#123; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,(i*7+j+1-(weekday==7?0:weekday))] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125;else&#123; btn =[[UIButton alloc]initWithFrame:CGRectMake(self.frame.size.width/7*j, self.frame.size.width/7*i, self.frame.size.width/7, self.frame.size.width/7)]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,nextDate++] forState:UIControlStateNormal]; [btn setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; [bodyView addSubview:btn]; &#125; //将今天的日期标出 if ([currentDate getYear]==[_today getYear]&amp;&amp;[currentDate getMonth]==[_today getMonth]&amp;&amp;[btn.titleLabel.text intValue]==[_today getDay]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal]; &#125; //是否进行自定义标记 /** *if中的颜色比较 是为了让上月与下月的余日不产生bug */ if (_markArray!=nil) &#123; for (int i=0; i&lt;_markArray.count; i++) &#123; YHBaseDateModel * model = _markArray[i]; if ([currentDate getYear]==[model.year intValue]&amp;&amp;[currentDate getMonth]==[model.month intValue]&amp;&amp;[btn.titleLabel.text intValue]==[model.day intValue]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; btn.layer.borderColor = [[UIColor grayColor]CGColor]; btn.layer.borderWidth=1; &#125; &#125; &#125; //是否进行选中标记 if ([_selectModel.year intValue]==[currentDate getYear]&amp;&amp;[_selectModel.month intValue]==[currentDate getMonth]&amp;&amp;[_selectModel.day intValue]==[btn.titleLabel.text intValue]&amp;&amp;!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; btn.backgroundColor = [UIColor cyanColor]; &#125; if (!CGColorEqualToColor([btn.titleLabel.textColor CGColor], [[UIColor grayColor] CGColor])) &#123; //添加点击事件 [btn addTarget:self action:@selector(clickBtn:) forControlEvents:UIControlEventTouchUpInside]; &#125; &#125; &#125; &#125;//这个方法中进行重构-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; if (scrollView.contentOffset.x==0) &#123;//向前翻页了 _currentDate = [YHBaseDateTools getPreviousframDate:_currentDate]; _scrollView.contentOffset=CGPointMake(scrollView.frame.size.width, 0); [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; &#125;else if (scrollView.contentOffset.x==scrollView.frame.size.width)&#123; &#125;else if (scrollView.contentOffset.x==scrollView.frame.size.width*2)&#123; _currentDate = [YHBaseDateTools getNextMonthframDate:_currentDate]; _scrollView.contentOffset=CGPointMake(scrollView.frame.size.width, 0); [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; &#125; scrollView.userInteractionEnabled=YES; if ([self.delegate respondsToSelector:@selector(YHBaseCalendarViewScrollEndToDate:)]) &#123; YHBaseDateModel * model = [[YHBaseDateModel alloc]init]; model.year = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getYear]]; model.month = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getMonth]]; model.day = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getDay]]; [self.delegate YHBaseCalendarViewScrollEndToDate:model]; &#125;&#125;-(void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; scrollView.userInteractionEnabled=NO;&#125;//点击事件-(void)clickBtn:(UIButton *)btn&#123; _selectModel.year = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getYear]]; _selectModel.month = [NSString stringWithFormat:@&quot;%d&quot;,[_currentDate getMonth]]; _selectModel.day = btn.titleLabel.text; [self creatViewWithData:_currentDate onView:_bodyViewM]; [self creatViewWithData:[YHBaseDateTools getPreviousframDate:_currentDate] onView:_bodyViewL]; [self creatViewWithData:[YHBaseDateTools getNextMonthframDate:_currentDate] onView:_bodyViewR]; if ([self.delegate respondsToSelector:@selector(YHBaseCalendarViewSelectAtDateModel:)]) &#123; [self.delegate YHBaseCalendarViewSelectAtDateModel:_selectModel]; &#125; &#125;@end （4）为用户交互设计的协议 1234@protocol YHBaseCalendarViewDelegate&lt;NSObject&gt;-(void)YHBaseCalendarViewSelectAtDateModel:(YHBaseDateModel *)dateModel;-(void)YHBaseCalendarViewScrollEndToDate:(YHBaseDateModel *)dateModel;@end 三、插个小广告控件的源码在[https://github.com/ZYHshao/YHBaseFoundationTest.git](https://github.com/ZYHshao/YHBaseFoundationTest.git)中，这是我封装的一套基于Cocoa与Foundation的更易用的开发框架，其中也对AFN，CRLabel，SDImage,MJRefresh进行了集成，有易用的下载框架，缓存框架，错误处理框架，皮肤管理框架等，也有支持加载HTML并且异步缓存图片的view，边下边播并做缓存的AVAudioPlayer，以及各种自定义性能很强的view控件，如用block创建的按钮，提示框以及对json和模型做相关映射的处理类，如果这些东西有帮到你，我很开心，如果你发现一些问题或者优化建议，请一定告知我，我将十分感激，QQ316045346 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C使用位运算设计可复选的枚举","slug":"106Objective-C使用位运算设计可复选的枚举","date":"2015-09-02T16:00:00.000Z","updated":"2021-07-01T11:08:01.742Z","comments":true,"path":"2015/09/03/106Objective-C使用位运算设计可复选的枚举/","link":"","permalink":"http://huishao.cc/2015/09/03/106Objective-C使用位运算设计可复选的枚举/","excerpt":"","text":"使用位运算设计可复选的枚举一、枚举使用的一个小例子在软件开发中，枚举是我们会经常会用到的一种编程方式，通过枚举，可以使我们的代码更具可读性与统一性。通常情况下，我们会通过typedef来定义一种枚举的类型来使用。例如： 12345typedef enum &#123; para1, para2, para3&#125;myEnum; 我们可以在函数的参数中来使用它： 123456789101112131415161718192021-(void)testEunm:(myEnum)para&#123; switch (para) &#123; case para1: &#123; NSLog(@&quot;para%d&quot;,1); &#125; break; case para2: &#123; NSLog(@&quot;para%d&quot;,2); &#125; break; case para3: &#123; NSLog(@&quot;para%d&quot;,3); &#125; break; default: break; &#125;&#125; 我们在调用调用这样的一个函数的时候，通过传入一个枚举类型，可以分流执行我们想要的操作。 二、枚举到底是个什么东西枚举并不是一种奇怪的类型，起实质是整型的另一个名字，如果没有附加的操作，枚举中的第一个参数默认就是整型0，之后依次递加，当然，我们也可以认为的控制这个数值，例如： 12345typedef enum &#123; para1=7, para2, para3=1000&#125;myEnum; 可以这么理解，我在传参的时候，传7和para1是完全一样的效果，但是后者明显更具可读性。 三、可复选的枚举属性如果熟悉iOS的开发，你会发现系统很多的枚举类型都是可以复选的，例如视图的拉伸模式，json的解析属性等等，这不仅使代码可读性优化，也更加简便了一些选项设置的代码。当我们理解了枚举就是整型之后，会发现其实很容易做到这一点： 首先，我们给定义的枚举参数设置一个有规律的值： 12345typedef enum &#123; para1=1&lt;&lt;1, para2=1&lt;&lt;2, para3=1&lt;&lt;3&#125;myEnum; &lt;&lt;符号是位运算中的左移运算符，将1进行1位，2位，3位的左移后，我们得到的二进制数如下： 123000100100100 现在我们有了一个大致思路了，用当前位的0和1来标识当前属性是否设置，如果有几个属性的复选，只需要将我们的相应枚举进行或的位运算，在取的时候检测相应位是否为1即可，这正是与运算可以做到的： 1234567891011-(void)testEunm:(myEnum)para&#123; if (para&amp;1&lt;&lt;1) &#123; NSLog(@&quot;para1&quot;); &#125; if (para&amp;1&lt;&lt;2) &#123; NSLog(@&quot;para2&quot;); &#125; if (para&amp;1&lt;&lt;3) &#123; NSLog(@&quot;para3&quot;); &#125;&#125; 我们通过如下方式调用： 1[self testEunm:para2|para3]; 打印结果如下： 这种位运算的枚举在官方sdk中被广泛使用，能够有效的简化代码和提高代码的可读性。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计","slug":"105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计","date":"2015-08-29T16:00:00.000Z","updated":"2021-07-01T07:33:15.989Z","comments":true,"path":"2015/08/30/105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计/","link":"","permalink":"http://huishao.cc/2015/08/30/105扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计/","excerpt":"","text":"扩展于RCLabel的支持异步加载网络图片的富文本引擎的设计在iOS开发中，图文混排一直都是UI编程的一个核心点，也有许多优秀的第三方引擎，其中很有名的一套图文混排的框架叫做DTCoreText。但是在前些日的做的一个项目中，我并没有采用这套框架，原因有二，一是这套框架体积非常大，而项目的需求其实并不太高；二是要在这套框架中修改一些东西，难度也非常大，我最终采用的是一个叫做RCLabel的第三方控件，经过一些简单的优化和完善，达到了项目的要求。 先来介绍一下我项目中的图文混排的需求：首先我从服务器中取到的数据是字符串，但是其中穿插图片的位置是一个HTML的图片标签，标签里的资源路径就是图片的请求地址。需要达到的要求是这些数据显示出来后，图片的位置要空出来，然后通过异步的网络请求获取图片的数据，再将图片插入文字中。 要自己实现一套这样的引擎确实会比较麻烦，幸运的是RCLabel可以完美的帮我们解析带有HTML标签的数据，进行图文混排，我们先来看一下这个东西怎么用，下面是我封装的一个展示html数据的view： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@interface YHBaseHtmlView()&lt;YHRTLabelImageDelegate&gt;&#123; //RCLabel对象 RCLabel * _rcLabel; //保存属性 用于异步加载完成后刷新 RTLabelComponentsStructure * _origenComponent; //含html标签的数据字符串 NSString * _srt;&#125;@end@implementation YHBaseHtmlView/*// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect &#123; // Drawing code&#125;*/- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super initWithCoder:coder]; if (self) &#123; //将rclabel初始化 _rcLabel = [[RCLabel alloc]init]; [self addSubview:_rcLabel]; &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; _rcLabel = [[RCLabel alloc]initWithFrame:frame]; [self addSubview:_rcLabel]; &#125; return self;&#125;-(void)reSetHtmlStr:(NSString *)htmlStr&#123; _srt = htmlStr; //这个代理是我额外添加的 后面解释 _rcLabel.imageDelegate=self; //设置frame _rcLabel.frame=CGRectMake(0, 0, self.frame.size.width, 0); //设置属性 _origenComponent = [RCLabel extractTextStyle:htmlStr IsLocation:NO withRCLabel:_rcLabel]; _rcLabel.componentsAndPlainText = _origenComponent; //获取排版后的size CGSize size = [_rcLabel optimumSize]; //重新设置frame _rcLabel.frame=CGRectMake(0, 0, _rcLabel.frame.size.width, size.height); self.frame=CGRectMake(self.frame.origin.x, self.frame.origin.y, _rcLabel.frame.size.width, size.height);&#125;//这是我额外添加的代理方法的实现-(void)YHRTLabelImageSuccess:(RCLabel *)label&#123; _origenComponent = [RCLabel extractTextStyle:_srt IsLocation:NO withRCLabel:_rcLabel]; _rcLabel.componentsAndPlainText = _origenComponent; CGSize size = [_rcLabel optimumSize]; _rcLabel.frame=CGRectMake(0, 0, _rcLabel.frame.size.width, size.height); self.frame=_rcLabel.frame; if ([self.delegate respondsToSelector:@selector(YHBaseHtmlView:SizeChanged:)]) &#123; [self.delegate YHBaseHtmlView:self SizeChanged:self.frame.size]; &#125;&#125; RCLabel的用法很简单，总结来说只有三步： 1.初始化并设置frame 2.通过带html标签的数据进行属性的初始化 3.将属性进行set设置并重设视图frame RCLabel是很强大，并且代码很简练，但是其中处理图片的部分必须是本地的图片，即图片html标签中的路径必须是本地图片的名字，其内部是通过[UIImage ImageNamed:]这个方法进行图片的渲染的，所以要达到我们的需要，我们需要对其进行一些简单的扩展： 1、在属性设置方法中添加一个参数，来区分本地图片与网络图片： 12//我在这个方法中添加了location这个bool值，实际上rclabel这个参数也是我添加的，是为了后面代理使用的+ (RTLabelComponentsStructure*)extractTextStyle:(NSString*)dataimage IsLocation:(BOOL)location withRCLabel:(RCLabel *)rcLabel; 2、在实现方法中添加如下代码，因为原文件有1900多行，在其中弄清楚逻辑关系也确实费了我不小的力气，我这里只将我添加的代码贴过来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#warning 这里进行了兼容性处理 if (location) &#123; //本地图片的渲染 if (tempURL) &#123; UIImage *tempImg = [UIImage imageNamed:tempURL]; component.img = tempImg; &#125; &#125;else&#123;//这里做远程图片数据的处理 //这里我进行了缓存的操作，这个缓存中心是我封装的框架中的另一套东西，这里可以不用在意 //先读缓存 NSData * ceche = [[YHBaseCecheCenter sharedTheSingletion] readCecheFile:tempURL fromPath:YHBaseCecheImage]; if (ceche) &#123; UIImage * tempImg = [UIImage imageWithData:ceche]; component.img=tempImg; &#125;else&#123; //在分线程中进行图片数据的获取 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; if (tempURL) &#123; NSData * data = [YHBaseData getDataWithUrl:tempURL]; if (data) &#123; //获取完成后村缓存 //做缓存 [[YHBaseCecheCenter sharedTheSingletion]writeCecheFile:data withFileID:tempURL toPath:YHBaseCecheImage]; //赋值 回调代理 UIImage * tempImg = [UIImage imageWithData:data]; component.img=tempImg; //这里代理是我添加的，当图片下载完成后 通知视图重新排版 if ([[rcLabel imageDelegate]respondsToSelector:@selector(YHRTLabelImageSuccess:)]) &#123; //在主线程中执行回调 //这个地方要在主线程中执行，否则刷新会有延时 dispatch_async(dispatch_get_main_queue(), ^&#123; [[rcLabel imageDelegate] YHRTLabelImageSuccess:rcLabel]; &#125;); &#125; &#125; &#125;; &#125;); &#125; &#125; 通过如上简单的扩展，基本达到了项目中的需求，这里把我的一些想法和思路分享给大家，有更好的解决方案，或者同是开发爱好者，欢迎指点与交流，我的QQ是316045346。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"iOS程序框架设计之皮肤切换功能","slug":"104iOS程序框架设计之皮肤切换功能","date":"2015-08-20T16:00:00.000Z","updated":"2021-07-01T07:30:50.086Z","comments":true,"path":"2015/08/21/104iOS程序框架设计之皮肤切换功能/","link":"","permalink":"http://huishao.cc/2015/08/21/104iOS程序框架设计之皮肤切换功能/","excerpt":"","text":"iOS程序框架设计之皮肤切换功能一、引言移动应用的开发中，有时我们会需要例如更换皮肤此类的功能，andorid采用xml配置UI的方式，这个问题或许还容易解决些，iOS的主要UI逻辑则是在代码中控制的，如果没有一个强大的框架方案，这个问题将变得非常棘手。网上也有很多诸如此类功能的优秀案例与框架，在这篇博客中，我与大家分享下我的解决方案，其中如果有不恰或者糟糕之处，希望与高人一起交流。 二、设计思路与框架首先我的设计思路是采用通知的方式，原理可以如下理解为以下几步： 1、在系统的通知中心注册一个通知 2、所有需要更改皮肤功能的controller作为这个通知的监听者 3、设计一个皮肤的model类 4、将controller中有关皮肤设置的属性从model中取 5、在切换皮肤前更改皮肤model 6、发送更改皮肤的通知 上面的6个步骤是这整个框架的基本逻辑，框架无非是将这些逻辑进行优化与封装。下面这张图很烂，但是思路很清晰： 首先最上面是我设计的一个切换主题的manager，我这里的设计有个缺陷，我将manager和主题配置相关的model混合在了一起，写的时候简单了些，可这给框架的逻辑上带来了混乱，所以我在图中使用曲线和虚椭圆将其分离，manager来控制切换model的属性，我们在controller中取model的属性进行配置，这个manager的逻辑位置是交互时间与通知中心的桥梁。manager中的核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//单例方法+(instancetype)sharedTheSingletion&#123; static YHTopicColorManager * sharedModel = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; sharedModel = [[YHTopicColorManager alloc] init]; &#125;); return sharedModel;&#125;//这个方法应该分离在model中，从本地读取当前的主题模式，更改后我们只需要更改本地数据 然后重新调用这个方法即可-(void)getTopicModel&#123; //从本地读取 int tp = [YHSASystemSettingManager sharedTheSingletion].topic; if (tp==0) &#123; //默认为白天主题 tp=dayTime; [YHSASystemSettingManager sharedTheSingletion].topic = tp; &#125; switch (tp) &#123; //这里是我定义的一些枚举，拿白天和夜间模式示范 case dayTime://白天模式 &#123; //这里面定义一些白天模式下 控件的颜色属性 也可以定义其他 _navColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _bgColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _btnColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _textColor=[UIColor colorWithRed:0 green:0 blue:0 alpha:1]; _btnTextColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _navTextColor= [UIColor whiteColor]; &#125; break; case nightTime://夜间模式 &#123; //这里面定义夜间模式下的相关控件的颜色属性 _navColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _bgColor=[UIColor colorWithRed:0 green:0 blue:0 alpha:1]; _btnColor=[UIColor colorWithRed:10/255.0 green:85/255.0 blue:160/255.0 alpha:1]; _textColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _btnTextColor=[UIColor colorWithRed:1 green:1 blue:1 alpha:1]; _navTextColor= [UIColor whiteColor]; &#125; break; default: break; &#125;&#125;//发送更改主题的消息+(void)postTopicChangeMessage&#123; [[NSNotificationCenter defaultCenter]postNotificationName:YHTopicChangeTopicNotication object:nil];&#125; 在manager调用通知中心发送通知后，我们要让所有需要改变主题的视图控制器都接收到通知，最简便的做法是，我们设计一个父类，让父类监听通知，所有需要有主题更改功能的控制器继承于它即可，这个father controller的核心代码如下： 1234567891011121314151617//移除监听-(void)dealloc&#123; [[NSNotificationCenter defaultCenter]removeObserver:self];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. //添加监听主题更换的通知 [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(useYHTopicToCreatViewWithModel) name:YHTopicChangeTopicNotication object:nil]; //协议中的方法，加载主题 一会再说 [self useYHTopicToCreatViewWithModel];&#125;//子类实现如下方法-(void)useYHTopicToCreatViewWithModel&#123; &#125; 到目前，我们已经可以顺利接收到主题切换的通知，可是要所有子类都步伐一致的执行相同一个操作，我们可以通过一个协议来约定，这就是图中的主框架的protocol，这个协议中规定一个特定的方法，我们在父类中调用，子类中实现，当收到通知时，所有子类都将重新加载这个方法，如果我们将皮肤设置部分在这个方法中实现，那么正是我们想要的效果，所有皮肤设置都被重新加载了。协议如下： 12345678910111213/** *这里定义主题的风格 */typedef enum &#123; dayTime=1,//白天 nightTime//夜间&#125;YHTopicModel;@protocol YHTopicProcotol &lt;NSObject&gt;//所有可以更换主题的界面必须遵守这个协议调用并实现如下方法//将视图中控件的颜色摄住部分全部放在这个方法中@required-(void)useYHTopicToCreatViewWithModel;@end 这时，就剩下我们这套逻辑的最后一步了，我们只需要将控件的颜色设置写在子类的协议方法中，并且，这些设置的数据来源于model这个模型，整个体系就完成了，子类实现方法如下： 1234567891011121314151617-(void)useYHTopicToCreatViewWithModel&#123;//获取到模型 YHTopicColorManager * model = [YHTopicColorManager sharedTheSingletion]; //加载模型数据 [model getTopicModel]; //进行设置 self.view.backgroundColor = model.bgColor; _schoolLabel.textColor = model.textColor; _phoneLabel.textColor = model.textColor; _secertLabel.textColor = model.textColor; _reWriteSecretLabel.textColor = model.textColor; _questionLabel.textColor = model.textColor; _answerLabel.textColor = model.textColor; _registBtn.backgroundColor = model.btnColor; [_registBtn setTitleColor:model.btnTextColor forState:UIControlStateNormal]; &#125; 我简单写了一些界面，不论任何地方切换皮肤，所有界面效果都会改变： 切换夜间模式前： 开启夜间模式后： 三、补充自己的思路实现更换主题的一种方法，真诚的想与志同道合的朋友交流开发经验，如果你想批评，点拨，交流或者是借鉴我的代码，Q316045346随时欢迎。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}],"tags":[],"keywords":[{"name":"代码灵魂","slug":"代码灵魂","permalink":"http://huishao.cc/categories/代码灵魂/"}]},{"title":"Xcode创建可复用的代码块","slug":"102Xcode创建可复用的代码块","date":"2015-08-12T16:00:00.000Z","updated":"2021-07-01T07:28:01.268Z","comments":true,"path":"2015/08/13/102Xcode创建可复用的代码块/","link":"","permalink":"http://huishao.cc/2015/08/13/102Xcode创建可复用的代码块/","excerpt":"","text":"Xcode创建可复用的代码块在各种程序开发中，编写代码的效率是非常重要的一个问题，各种优秀的编译器也都有相应的插件用于提高程序员的编码速度。在xcode中，可以通过定义代码块的方式将常用的一部分代码进行快捷呼出，首先xcode中为我们定义好了许多代码块，例如： 在使用这些代码模板时，我们只需要将其拖入我们的代码中，或者直接键入快捷键即可，十分的方便，当然，我们也可以将我们自己常用的代码块包装成模板，便于我们复用。 例如，我写如下的代码段： 1@property(nonatomic,copy)NSString * str; 将其选中，长按左键，直到鼠标变成箭头模样，然后将其拖入右下方的代码块模板区，会弹出如下设置菜单： title用来设置我们的代码块名称。 platform用来设置代码块可以使用的平台。 Language用来设置支持的编程语言。 completion用来设置快捷键入的快捷键，比如我们设置为pro 如果我们需要将其中的某些参数进行，替换，比如上面的NSString和str,我们想在编码时自定义他们，我们这样写： &lt;#NSString#&gt;*&lt;#str#&gt; 这时，界面就变成了如下这样： 我们点击Done后，在代码中输入pro会自动提示出这段代码段，变成方便了许多。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}],"tags":[],"keywords":[{"name":"日常技巧","slug":"日常技巧","permalink":"http://huishao.cc/categories/日常技巧/"}]},{"title":"iOS中RunLoop机制浅探","slug":"103iOS中RunLoop机制浅探","date":"2015-08-12T16:00:00.000Z","updated":"2021-07-01T07:29:41.399Z","comments":true,"path":"2015/08/13/103iOS中RunLoop机制浅探/","link":"","permalink":"http://huishao.cc/2015/08/13/103iOS中RunLoop机制浅探/","excerpt":"","text":"iOS中RunLoop机制浅探一、浅识RunLoopRunLoop这个家伙在iOS开发中，我们一直在用，却从未注意过他，甚至都不从见过他的面孔，那个这个神秘的家伙究竟是做什么的？首先，我们先来观察一下我们的程序运行机制。 无论是面向对象的语言或是面向过程的语言，代码的执行终究是面向过程的。线程也一样，一个线程从开始代码执行，到结束代码销毁。就像HELLO WORLD程序，打印出字符串后程序就结束了，那么，我们的app是如何实现如下这样的机制的呢：app从运行开始一直处于待命状态，接收到类似点击事件等用户交互后执行相应操作，完成后继续等待交互响应，直到我们将程序杀死。通过这个过程的分析，我们可能会猜到，我们执行的主线程一定是在一个死循环中，没有任务的时候进行休眠，接收到任务后被激活执行任务。现在我们可以理解了，这样一个管理线程执行任务的机制就是RunLoop机制，线程在执行中的休眠与激活就是由RunLoop对象进行管理的。 二、RunLoop与线程的关系上面我们说到，RunLoop是用来管理线程的，那么他们直接有着怎样的关系，又是怎样进行交互的呢。事实上，每一个线程中都有一个Runloop对象，可以通过具体方法获得。这里有一点需要我们注意，官方文档上描述，虽然每一个线程中都可以获取RunLoop对象，但是并不是每一个线程中都有这个实例对象，我们可以这样理解：如果我们不获取runloop，这个runloop就不存在，我们获取时，如果不存在，就会去创建。在主线程中，这个MainRunLoop是默认创建并运行激活的。 三、认识NSRunLoopNSRunLoop是Cocoa框架中的类，与之对应，在Core Fundation中是CFRunLoopRef类。这两者的区别是前者不是线程安全的，而后者是线程安全的。我们这里只来讨论NSRunLoop的属性和方法： + (NSRunLoop *)currentRunLoop; 获取当前线程的RunLoop：有则获取，无则创建 + (NSRunLoop *)mainRunLoop ; 获取主线程的RunLoop @property (readonly, copy) NSString *currentMode; 获取当前runloop的执行模式，两种模式如下： NSString * const NSDefaultRunLoopMode; 默认模式，接收大部分输入源的响应 NSString * const NSRunLoopCommonModes; 多种模式的集合 - (CFRunLoopRef)getCFRunLoop; 获取RunLoop的CFRunLoopRef对象 - (void)addTimer:(NSTimer )timer forMode:(NSString )mode; 将定时器添加到runloop中 - (void)addPort:(NSPort )aPort forMode:(NSString )mode; 添加输入源端口到runloop中，NSPort对象可以理解为详细的载体，会传递消息与其代理。 - (void)removePort:(NSPort )aPort forMode:(NSString )mode; 将某个输入源端口移除 - (NSDate )limitDateForMode:(NSString )mode; 获取下个响应时间 解释：例如定时器的执行，其并不是按时间的间隔进行调用方法，而是在定时器注册到runloop中后，runloop会设置一个一个的时间点进行调用，比如10，20，30。如果错过了某个时间点，定时器并不会延时调用，而是直接等待下一个时间点调用，所以定时器并不是精准的。 - (void)acceptInputForMode:(NSString )mode beforeDate:(NSDate )limitDate; 在某个时间期限前接收响应 - (void)run;开始运行 - (void)runUntilDate:(NSDate *)limitDate; 到某个时间点运行 - (BOOL)runMode:(NSString )mode beforeDate:(NSDate )limitDate; 在某个期限前运行 四、RunLoop的应用正如前面所说，我们一直在使用他，却很少见到他。并且，我们在大多数情况下，都不需要显式的创建或者启动RunLoop，有两种情况，我们却必须手动设置它： 1、在分线程中使用定时器定时器的实现便是基于runloop的，平时我们使用定时器你或许并没有对runloop做什么操作，那是因为主线程的runloop默认是开启运行的，如果我们在分线程中也需要重复执行某一动作，如下： 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(time) userInfo:nil repeats:YES]; &#125;); &#125;-(void)time&#123; NSLog(@&quot;run&quot;);&#125; 你会发现，程序运行后并没有打印任何信息，方法并没有被调用，我们必须在线程中手动的执行如下代码： 1 [[NSRunLoop currentRunLoop] run]; 定时器才能正常工作。 2、当你在线程中使用如下方法时某些延时函数和选择器在分线程中的使用，我们也必须手动开启runloop，这些方法如下： @interface NSObject (NSDelayedPerforming) - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes; - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay; + (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(id)anArgument; + (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget; - (void)performSelector:(SEL)aSelector target:(id)target argument:(id)arg order:(NSUInteger)order modes:(NSArray *)modes; - (void)cancelPerformSelector:(SEL)aSelector target:(id)target argument:(id)arg;- (void)cancelPerformSelectorsWithTarget:(id)target; 五、补充RunLoop更强大的地方在于对消息的监听，因为CFRunLoopRef的线程安全优势，我们通常会更多使用后者。 细心的你可能会发现，输入源被注册进Runloop中时会有方法进行remove，但是定时器却没有，但是定时器中的invalidate方法可以将其从runloop中移除，正如官方文档的说明：invalidate是重要也是唯一的可以将定时器从runloop的注销的方法，所以如果我们创建了定时器，就一定要在不使用时调用invalidate方法。我不知道apple为何将定时器的方法分离开来，可能的原因是让开发者更少的显式调用runloop的方法，你若是知道原因，恳请留言指导。 关于定时器的问题，在另一篇博客中有介绍：[http://my.oschina.net/u/2340880/blog/398598](http://my.oschina.net/u/2340880/blog/398598)。 学习使用 欢迎转载 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中制作可复用的框架Framework","slug":"101iOS中制作可复用的框架Framework","date":"2015-08-11T16:00:00.000Z","updated":"2021-07-01T07:27:21.399Z","comments":true,"path":"2015/08/12/101iOS中制作可复用的框架Framework/","link":"","permalink":"http://huishao.cc/2015/08/12/101iOS中制作可复用的框架Framework/","excerpt":"","text":"iOS中制作可复用的框架Framework在iOS开发中，我们时常会使用一些我们封装好的管理类，框架类，方法类等，我们在实现这些文件时，可能还会依赖一些第三方库或者系统库。如果每次我们复用这些代码时，都要将关联的这些东西进行导入，甚至还要进行arc和mrc的编译设置，会浪费我们很大的精力。除此之外，如果项目需要多人合作，你可能也并不希望你的源代码暴漏在所有人的面前，这个时候，我们就可以使用静态库或者动态库的方式来对我们的代码进行包装，便于复用。静态库的制作方法在一篇旧的博客中有描述：[http://my.oschina.net/u/2340880/blog/398887](http://my.oschina.net/u/2340880/blog/398887)。相比静态库文件，动态库的效率会更高且封装性更好，这里主要讨论动态库的制作。 xcode6后支持在xcode中制作动态库，并且过程也十分简单。 新建一个项目，选择framework： 之后我们在里面编写我们的代码，比如我们创建一个MyObject类： 123456789@interface MyObject : NSObject-(void)myLog;@end@implementation MyObject-(void)myLog&#123; NSLog(@&quot;framework&quot;);&#125;@end 和静态库类似，如果我们不做任何处理，打包出来的库文件只能在模拟器或者只能在真机上使用，为了方便我们调试，我们可以添加一个脚本命令，是的生成一个同时支持模拟器和真机的framework： 新建target： 选择Aggregate： 之后，我们在target的Build Phases中点击加号： 添加一个Run Script： 在里面添加如下的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556set -eset +u# Avoid recursively calling this script.if [[ $SF_MASTER_SCRIPT_RUNNING ]]thenexit 0fiset -uexport SF_MASTER_SCRIPT_RUNNING=1SF_TARGET_NAME=$&#123;PROJECT_NAME&#125;SF_EXECUTABLE_PATH=&quot;$&#123;SF_TARGET_NAME&#125;.framework/$&#123;SF_TARGET_NAME&#125;&quot;SF_WRAPPER_NAME=&quot;$&#123;SF_TARGET_NAME&#125;.framework&quot;if [[ &quot;$SDK_NAME&quot; =~ ([A-Za-z]+) ]]thenSF_SDK_PLATFORM=$&#123;BASH_REMATCH[1]&#125;elseecho &quot;Could not find platform name from SDK_NAME: $SDK_NAME&quot;exit 1fiif [[ &quot;$SDK_NAME&quot; =~ ([0-9]+.*$) ]]thenSF_SDK_VERSION=$&#123;BASH_REMATCH[1]&#125;elseecho &quot;Could not find sdk version from SDK_NAME: $SDK_NAME&quot;exit 1fiif [[ &quot;$SF_SDK_PLATFORM&quot; = &quot;iphoneos&quot; ]]thenSF_OTHER_PLATFORM=iphonesimulatorelseSF_OTHER_PLATFORM=iphoneosfiif [[ &quot;$BUILT_PRODUCTS_DIR&quot; =~ (.*)$SF_SDK_PLATFORM$ ]]thenSF_OTHER_BUILT_PRODUCTS_DIR=&quot;$&#123;BASH_REMATCH[1]&#125;$&#123;SF_OTHER_PLATFORM&#125;&quot;elseecho &quot;Could not find platform name from build products directory: $BUILT_PRODUCTS_DIR&quot;exit 1firm -rf buildProductsmkdir buildProducts# Build the other platform.xcrun xcodebuild -project &quot;$&#123;PROJECT_FILE_PATH&#125;&quot; -target &quot;$&#123;TARGET_NAME&#125;&quot; -configuration &quot;$&#123;CONFIGURATION&#125;&quot; -sdk $&#123;SF_OTHER_PLATFORM&#125;$&#123;SF_SDK_VERSION&#125; BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; OBJROOT=&quot;$&#123;OBJROOT&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; SYMROOT=&quot;$&#123;SYMROOT&#125;&quot; $ACTION# Smash the two static libraries into one fat binary and store it in the .frameworkxcrun lipo -create &quot;$&#123;BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework/$PRODUCT_NAME&quot; &quot;$&#123;SF_OTHER_BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework/$PRODUCT_NAME&quot; -output &quot;$&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME&quot;cp -rf $&#123;BUILT_PRODUCTS_DIR&#125;/$PRODUCT_NAME.framework $&#123;PROJECT_DIR&#125;/buildProductsmv $&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME $&#123;PROJECT_DIR&#125;/buildProducts/$PRODUCT_NAME.framework 接着，我们需要将给外界的接口文件暴露出来，将其移动到public下即可： 之后我们运行程序，需要注意的一点事，如果要支持64位，需要在编译选项中设置，如下： 到此时，我们的framework库文件就制作完成，在xcode的window-&gt;projects中选中我们的这个项目，点击进入文件夹的小箭头： 在build-&gt;product中便可以找到我们的framework文件，我们将其赋值出来即可以使用。 我们测试一下，新建一个工程，将刚才制作的静态库导入，如下加入头文件，调用方法，可以使用。 123#import &lt;MyFramework/MyObject.h&gt; MyObject * obj = [[MyObject alloc]init]; [obj myLog]; 两个技巧： 一、如果你运行程序出现类似Reason: image not found!的崩溃信息，可能的原因是动态库文件中的某些文件你的项目中已经包含了，在Build Phases中将required改成optional即可。 二、一个优秀且完整的框架可能会包含相当多的文件，包括框架自己的和其他第三方的，为了使用的方便，我们可以将头文件都导入一个的头文件中，这里有一个地方我们需要注意，我们直接在framework工程中添加的头文件是不会编译的，我的解决方案是通过建一个OC的类，在这个类中导入这个总的头文件，将这个类隐藏成私有的，就可以解决问题了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"iOS多线程开发之深入GCD","slug":"100iOS多线程开发之深入GCD","date":"2015-08-10T16:00:00.000Z","updated":"2021-07-01T07:22:45.752Z","comments":true,"path":"2015/08/11/100iOS多线程开发之深入GCD/","link":"","permalink":"http://huishao.cc/2015/08/11/100iOS多线程开发之深入GCD/","excerpt":"","text":"iOS多线程开发之深入GCD一、前言在以前的一些系列博客中，对iOS中线程的管理做了总结，其中涵盖了GCD的相关基础知识：[http://my.oschina.net/u/2340880/blog/417746](http://my.oschina.net/u/2340880/blog/417746)。那里面将GCD的线程管理能力，列队组能力，通过信号和消息控制程序流程的能力都有介绍，这里，我们继续深入GCD的功能，通过GCD来处理一些逻辑更加复杂的代码功能。 二、延时追加任务当我们在程序中处理延时任务的时候，我们一般会通过两种方式，一种是通过定时器进行延时执行，另外一种是通过如下的函数： - (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay; 然而，如果我们需要在多线程中进行延时操作，上面两种方式会显得十分麻烦，并且徒增代码的复杂度。GCD为我们提供了一种方式： void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block); 这个方法有三个参数，第一个参数延时的时间，第二个参数为将任务加入的队列，第三个block为要执行的任务。示例如下： 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;1233&quot;); &#125;); 这里通过dispatch_time来创建时间对象，将打印信息的方法在3S后加入主线程队列。需要注意的是，这里只是将任务延时加入队列，并不是执行，如果是加入同步队列中，则会进入等待状态。 三、数据存取的线程安全问题在进行多线程编程时，或许总会遇到一类问题，数据的竞争与线程的安全。这些问题如果我们通过程序手动来控制难度将会非常大。GCD同样为我们简单的解决了这样的问题。 首先，如果只是在读取数据，而不对数据做任何修改时，我们并不需要处理安全问题，可以让多个任务同时进行读取，可是如果要对数据进行写的操作，那么在同一时间，我们就必须只能有一个任务在写，GCD中有一个方法帮我们完美的解决了这个问题，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839//创建一个队列dispatch_queue_t queue = dispatch_queue_create(&quot;oneQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //几个任务同时读操作 dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read1:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read2:%d&quot;,i); &#125; &#125;); //此处进行写操作 /* 下面这个函数在加入队列时不会执行，会等待已经开始的异步执行全部完成后再执行，并且在执行时，会阻塞其他任务 执行完成后，其他任务重新进入异步执行 */ dispatch_barrier_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;write:%d&quot;,i); &#125; &#125;); //继续进行异步读操作 dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read3:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read4:%d&quot;,i); &#125; &#125;); dispatch_async(queue, ^&#123; for (int i=0; i&lt;5; i++) &#123; NSLog(@&quot;read5:%d&quot;,i); &#125; &#125;); 打印信息如下： 可以看出，读操作是异步进行的，写操作是等待后阻塞任务队列独立进行，结束后队列恢复异步执行读操作，这正是我们需要的效果。 四、GCD模式的单例通常情况下，我们的单例会是如下的样子： 1234567+(instancetype)shared&#123; static Auto * obj; if (obj==nil) &#123; obj = [[Auto alloc]init]; &#125; return obj;&#125; 这种通过读取静态变量的方式在大多数情况下是没问题的，可是并不能保证程序百分百的安全，因为在多线程的操作中，会有可能初始化多个对象，在GCD中，我们可以使用如下方式： 12345678910+(instancetype)shared&#123; static Auto * obj; //dispatch_once_t对象可以只保证执行一次 static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; obj = [[Auto alloc]init]; &#125;); return obj; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS视频功能模块的开发","slug":"99iOS视频功能模块的开发","date":"2015-08-09T16:00:00.000Z","updated":"2021-07-01T07:21:37.500Z","comments":true,"path":"2015/08/10/99iOS视频功能模块的开发/","link":"","permalink":"http://huishao.cc/2015/08/10/99iOS视频功能模块的开发/","excerpt":"","text":"iOS视频功能模块的开发一、使用MPMoviePlayerController进行视频播放MPMoviePlayerController是iOS中进行视频播放开发的一个控制类，里面涵盖了视频播放中大部分的需求功能，在使用这个框架时，需要导入头文件&lt;MediaPlayer/MediaPlayer.h&gt;。 1、初始化方法MPMoviePlayerController可以播放网络视频，也可以播放本地视频，通过不同的URL来进行初始化，例如本地视频的初始化如下： 123456//视频文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;mp4&quot;]; //视频URL NSURL *url = [NSURL fileURLWithPath:path]; //视频播放对象 MPMoviePlayerController * movie = [[MPMoviePlayerController alloc] initWithContentURL:url]; 初始化和完成相关配置后，我们需要将MPMoviePlayerController对象的View添加在我们需要的UI视图上，这个控制器只提供的控制的相关功能，外部的UI并没有为我们提供好。 2、相关属性与方法@property (nonatomic, copy) NSURL *contentURL; 视频文件的url地址 @property (nonatomic, readonly) UIView *view; 播放器view，在使用之前，必须设置frame大小，然后将其添加在我们的UI视图上 @property (nonatomic, readonly) UIView *backgroundView; 播放器背景颜色 @property (nonatomic, readonly) MPMoviePlaybackState playbackState; 播放器的当前播放状态，枚举定义如下： 12345678typedef NS_ENUM(NSInteger, MPMoviePlaybackState) &#123; MPMoviePlaybackStateStopped,//停止播放 MPMoviePlaybackStatePlaying,//正在播放 MPMoviePlaybackStatePaused,//暂停播放 MPMoviePlaybackStateInterrupted,//中断播放 MPMoviePlaybackStateSeekingForward,//快进 MPMoviePlaybackStateSeekingBackward//快退&#125;; @property (nonatomic, readonly) MPMovieLoadState loadState; 播放器的网络缓存状态，枚举定义如下： 123456typedef NS_OPTIONS(NSUInteger, MPMovieLoadState) &#123; MPMovieLoadStateUnknown = 0,//状态未知 MPMovieLoadStatePlayable = 1 &lt;&lt; 0,//缓存数据足够开始播放，但是视频并没有缓存完全 MPMovieLoadStatePlaythroughOK = 1 &lt;&lt; 1, //已经缓存完成，如果设置了自动播放，这时会自动播放 MPMovieLoadStateStalled = 1 &lt;&lt; 2, //数据缓存已经停止，播放将暂停&#125;; @property (nonatomic) MPMovieControlStyle controlStyle; 播放器风格，枚举如下: 1234567typedef NS_ENUM(NSInteger, MPMovieControlStyle) &#123; MPMovieControlStyleNone, // 无控制器 MPMovieControlStyleEmbedded, // 嵌入视频风格 MPMovieControlStyleFullscreen, // 全屏播放风格 MPMovieControlStyleDefault = MPMovieControlStyleEmbedded&#125;; @property (nonatomic) MPMovieRepeatMode repeatMode; 播放器的循环模式，枚举如下： 1234typedef NS_ENUM(NSInteger, MPMovieRepeatMode) &#123; MPMovieRepeatModeNone,//播放结束后不循环 MPMovieRepeatModeOne//循环&#125;; @property (nonatomic) BOOL shouldAutoplay; 是否开启自动播放 @property (nonatomic, getter=isFullscreen) BOOL fullscreen; 设置是否充满屏幕 - (void)setFullscreen:(BOOL)fullscreen animated:(BOOL)animated; 设置是否充满屏幕，带动画效果 @property (nonatomic) MPMovieScalingMode scalingMode; 设置播放器的填充方式，枚举定义如下： 123456typedef NS_ENUM(NSInteger, MPMovieScalingMode) &#123; MPMovieScalingModeNone, // 无缩放 MPMovieScalingModeAspectFit, // 适应大小模式 MPMovieScalingModeAspectFill, // 充满可视范围，可能会被裁剪 MPMovieScalingModeFill // 缩放到充满视图&#125;; @property (nonatomic, readonly) BOOL readyForDisplay NS_AVAILABLE_IOS(6_0); 返回YES说明数据栈已经缓存好数据，返回NO则没有缓存好 @property (nonatomic, readonly) MPMovieMediaTypeMask movieMediaTypes; 数据文件的格式，枚举如下： 12345typedef NS_OPTIONS(NSUInteger, MPMovieMediaTypeMask) &#123; MPMovieMediaTypeMaskNone = 0,//格式未知 MPMovieMediaTypeMaskVideo = 1 &lt;&lt; 0,//音频格式 MPMovieMediaTypeMaskAudio = 1 &lt;&lt; 1//视频格式&#125;; @property (nonatomic) MPMovieSourceType movieSourceType; 视频的数据类型，枚举如下： 12345typedef NS_ENUM(NSInteger, MPMovieSourceType) &#123; MPMovieSourceTypeUnknown,//类型未知 MPMovieSourceTypeFile, // 文件类型 MPMovieSourceTypeStreaming // 数据流&#125;; @property (nonatomic, readonly) NSTimeInterval duration; 视频文件的时长 @property (nonatomic, readonly) NSTimeInterval playableDuration; 缓存完成能够播放的时长 @property (nonatomic, readonly) CGSize naturalSize; 视频的原始大小 @property (nonatomic) NSTimeInterval initialPlaybackTime; 播放器开始播放的时间 @property (nonatomic) NSTimeInterval endPlaybackTime; 播放器结束播放的时间 @property (nonatomic) BOOL allowsAirPlay; 是否允许云端播放 - (void)requestThumbnailImagesAtTimes:(NSArray *)playbackTimes timeOption:(MPMovieTimeOption)optio; 获取视频某一些时间点的缩略图，参数枚举如下，生成缩略图的数据回调在后面的通知中详说： 1234typedef NS_ENUM(NSInteger, MPMovieTimeOption) &#123; MPMovieTimeOptionNearestKeyFrame,//使用最近的关键帧生成缩略图 MPMovieTimeOptionExact//使用精确的当前帧生成缩略图&#125;; 与播放控制相关的方法如下： 1234567891011121314151617181920//调用这个方法进行播放视频的准备工作- (void)prepareToPlay;//获取播放器的准备工作是否就绪@property(nonatomic, readonly) BOOL isPreparedToPlay;//调用此方法进行视频的播放- (void)play;//调用此方法进行视频播放的暂停操作- (void)pause;//调用此方法停止视频播放- (void)stop;//当前视频已播放的时间@property(nonatomic) NSTimeInterval currentPlaybackTime;//当前视频的播放速度@property(nonatomic) float currentPlaybackRate;//调用此方法进行快进操作- (void)beginSeekingForward;//调用此方法进行快退操作- (void)beginSeekingBackward;//调用此方法结束快进或者快退操作- (void)endSeeking; 3、系统相关通知MPMoviePlayerController的系统回调并没有采用代理的设计模式，而是采用的系统发通知，我们注册观察者，接收我们需要的通知。举例几种常用通知如下： NSString * const MPMoviePlayerScalingModeDidChangeNotification; 播放器缩放产生改变时发送的通知 NSString * const MPMoviePlayerPlaybackDidFinishNotification; 播放结束时发送的通知 NSString * const MPMoviePlayerPlaybackStateDidChangeNotification; 播放状态改变时发送的通知 NSString * const MPMoviePlayerLoadStateDidChangeNotification; 缓冲状态改变时发送的通知 NSString * const MPMoviePlayerNowPlayingMovieDidChangeNotification; 当前播放的视频改变时发送的通知 NSString * const MPMoviePlayerWillEnterFullscreenNotification; 将要进入全屏模式时发送的通知 NSString * const MPMoviePlayerDidEnterFullscreenNotification; 已经进入全屏时发送的通知 NSString * const MPMoviePlayerWillExitFullscreenNotification; 将要退出全屏时发送的通知 NSString * const MPMoviePlayerDidExitFullscreenNotification; 已经退出全屏时发送的通知 NSString * const MPMoviePlayerThumbnailImageRequestDidFinishNotification; 获取缩略图完成时发送的通知 二、MPMoviePlayerViewController视频视图控制器如果你很熟悉MVC，你可能会觉得MPMoviePlayerController的设计模式非常蹩脚，强行要求你将控制器的视图分离出来加在另外的UI上，徒增的代码逻辑的混乱，那么你想的没错，MPMoviePlayerViewController可能就是为了解决这个问题。 MPMoviePlayerViewController将视图封装在了一起，其中有一个成员对象是MPMoviePlayerController类型，类似C++中的has-a逻辑，我们只需要对MPMoviePlayerViewController进行的简单的初始化后，对其中MPMoviePlayerController进行其他配置，之后通过模态跳转切换控制器即可。 方法如下： - (instancetype)initWithContentURL:(NSURL *)contentURL; 初始化方法，和上面类似 @property (nonatomic, readonly) MPMoviePlayerController *moviePlayer; 播放器对象 - (void)presentMoviePlayerViewControllerAnimated:(MPMoviePlayerViewController *)moviePlayerViewController; - (void)dismissMoviePlayerViewControllerAnimated; viewController的模态跳转方法，也可以通过导航push与pop 代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@interface ViewController2 ()@property(nonatomic,strong)MPMoviePlayerController * movie;@property(nonatomic,strong)MPMoviePlayerViewController * viewController;@end@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self playMovie:@&quot;111&quot;];&#125;-(void)playMovie:(NSString *)fileName&#123; //视频文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:fileName ofType:@&quot;mp4&quot;]; //视频URL NSURL *url = [NSURL fileURLWithPath:path]; //视频播放对象 _viewController = [[MPMoviePlayerViewController alloc]initWithContentURL:url]; _movie=_viewController.moviePlayer; // 注册一个播放结束的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(myMovieFinishedCallback:) name:MPMoviePlayerPlaybackDidFinishNotification object:_movie]; _movie.fullscreen=YES;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_movie play]; [self presentViewController:_viewController animated:YES completion:nil];&#125;-(void)myMovieFinishedCallback:(NSNotification*)notify&#123; //视频播放对象 MPMoviePlayerController* theMovie = [notify object]; //销毁播放通知 [[NSNotificationCenter defaultCenter] removeObserver:self name:MPMoviePlayerPlaybackDidFinishNotification object:theMovie]; [theMovie.view removeFromSuperview]; &#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C中runtime机制的应用","slug":"98Objective-C中runtime机制的应用","date":"2015-08-06T16:00:00.000Z","updated":"2021-07-01T07:20:43.324Z","comments":true,"path":"2015/08/07/98Objective-C中runtime机制的应用/","link":"","permalink":"http://huishao.cc/2015/08/07/98Objective-C中runtime机制的应用/","excerpt":"","text":"Objective-C中runtime机制的应用一、初识runtimeObjective-C是一种动态语言，所谓动态语言，是在程序执行时动态的确定变量类型，执行变量类型对应的方法的。因此，在Object-C中常用字符串映射类的技巧来动态创建类对象。因为OC的动态语言特性，我们可以通过一些手段，在程序运行时动态的更改对象的变量甚至方法，这就是我们所说的runtime机制。 二、你还有什么办法操作这样的变量么？首先，我们先来看一个例子，这里有我创建的一个MyObject类： 1234567891011121314151617181920212223242526272829303132//.h===========================@interface MyObject : NSObject&#123; @private int privateOne; NSString * privateTow;;&#125;@end//=============================//.m===========================@interface MyObject()&#123; @private NSString * privateThree;&#125;@end@implementation MyObject- (instancetype)init&#123; self = [super init]; if (self) &#123; privateOne=1; privateTow=@&quot;Tow&quot;; privateThree=@&quot;Three&quot;; &#125; return self;&#125;-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;one=%d\\ntow=%@\\nthree=%@\\n&quot;,privateOne,privateTow,privateThree];&#125;@end//============================= 这个类是相当的安全，首先，在头文件中没有提供任何的方法接口，我们没有办法使用点语法做任何操作，privateOne和PrivateTow两个变量虽然声明在了头文件中，却是私有类型的，通过指针的方式我们虽然可以看到他们，却不能做任何读取修改的操作，xcode中的提示如下： 他会告诉我们，这是一个私有的变量，我们不能使用。对于privateThree，我们更是束手无策，不仅不能使用，我们甚至都看不到它的存在。那么对于这种情况，你有什么办法操作这些变量么？对，是时候展现真正的技术了：runtime! 三、通过runtime获取对象的变量列表要操作对象的变量，我们首先应该要捕获这些变量，让他们无处遁形。无论声明在头文件或是实现文件，无论类型是公开的还是私有的，只要声明了这个变量，系统就会为其分配空间，我们就可以通过runtime机制捕获到它，代码如下： 123456789101112131415161718192021222324252627282930313233343536#import &quot;ViewController.h&quot;#import &quot;MyObject.h&quot;//包含runtime头文件#import &lt;objc/runtime.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //我们先声明一个unsigned int型的指针，并为其分配内存 unsigned int * count = malloc(sizeof(unsigned int)); //调用runtime的方法 //Ivar：方法返回的对象内容对象，这里将返回一个Ivar类型的指针 //class_copyIvarList方法可以捕获到类的所有变量，将变量的数量存在一个unsigned int的指针中 Ivar * mem = class_copyIvarList([MyObject class], count); //进行遍历 for (int i=0; i&lt; *count ; i++) &#123; //通过移动指针进行遍历 Ivar var = * (mem+i); //获取变量的名称 const char * name = ivar_getName(var); //获取变量的类型 const char * type = ivar_getTypeEncoding(var); NSLog(@&quot;%s:%s\\n&quot;,name,type); &#125; //释放内存 free(count); //注意处理野指针 count=nil;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 打印结果如下，其中i表示int型： 是不是小吃惊了一下，无论变量在哪里，只要它在，就让它无处遁形。 四、让我找到你，就让我改变你！仅仅能够获得变量的类型和名字或许并没有什么卵用，没错，我们获取变量的目的不是为了观赏，而是为了操作它，这对runtime来说，也是小事一碟。代码如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; //获取变量 unsigned int count; Ivar * mem = class_copyIvarList([MyObject class],&amp;count); //创建对象 MyObject * obj = [[MyObject alloc]init]; NSLog(@&quot;before runtime operate:%@&quot;,obj); //进行变量的设置 object_setIvar(obj, mem[0],10); object_setIvar(obj, mem[1], @&quot;isTow&quot;); object_setIvar(obj, mem[2], @&quot;isThree&quot;); NSLog(@&quot;after runtime operate:%@&quot;,obj); &#125; Tip:在修改int型变量的时候，你或许会遇到一个问题，ARC下，编译器不允许你将int类型的值赋值给id，在buildset中将Objective-C Automatic Reference Counting修改为No即可。 打印效果如下： 可以看到，那些看似非常安全的变量被我们修改了。 五、让我看看你的方法吧变量通过runtime机制我们可以取到和改变值，那么我们再大胆一点，试试那些私有的方法，首先我们在MyObject类中添加一些方法，我们只实现，并不声明他们： 1234567891011121314151617181920212223242526@interface MyObject()&#123; @private NSString * privateThree;&#125;@end@implementation MyObject- (instancetype)init&#123; self = [super init]; if (self) &#123; privateOne=1; privateTow=@&quot;Tow&quot;; privateThree=@&quot;Three&quot;; &#125; return self;&#125;-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;one=%d\\ntow=%@\\nthree=%@\\n&quot;,privateOne,privateTow,privateThree];&#125;-(NSString *)method1&#123; return @&quot;method1&quot;;&#125;-(NSString *)method2&#123; return @&quot;method2&quot;;&#125; 这样的方法我们在外面是无法调用他们的，和操作变量的思路一样，我们先要捕获这些方法： 12345678 //获取所有成员方法 Method * mem = class_copyMethodList([MyObject class], &amp;count); //遍历 for(int i=0;i&lt;count;i++)&#123; SEL name = method_getName(mem[i]); NSString * method = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@\\n&quot;,method); &#125; 打印如下： 得到了这些方法名，我们大胆的调用即可： 12 MyObject * obj = [[MyObject alloc]init]; NSLog(@&quot;%@&quot;,[obj method1]); Tip:这里编译器不会给我们方法提示，放心大胆的调用即可。 六、动态的为类添加方法这个runtime机制最强大的部分要到了，试想，如果我们可以动态的向类中添加方法，那将是一件多么令人激动的事情，注意，这里是动态的添加，和类别的最大不同在于这种方式是运行时才决定是否添加方法的。 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; //添加一个新的方法，第三个参数是返回值的类型v是void,i是int，：是SEL，对象是@等 class_addMethod([MyObject class], @selector(method3), (IMP)logHAHA, &quot;v&quot;); unsigned int count = 0; Method * mem = class_copyMethodList([MyObject class], &amp;count); for(int i=0;i&lt;count;i++)&#123; SEL name = method_getName(mem[i]); NSString * method = [NSString stringWithCString:sel_getName(name) encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@\\n&quot;,method); &#125; MyObject * obj = [[MyObject alloc]init]; //运行这个方法 [obj performSelector:@selector(method3)]; &#125;//方法的实现void logHAHA()&#123; NSLog(@&quot;HAHA&quot;);&#125; 运行结果如下： 从前五行可以看出，方法已经加进去了，从最后一行可以看出，执行没有问题。 七、做点小手脚程序员总是得寸进尺的，现在，我们要做点事情，用我们的函数替换掉类中的函数： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; MyObject * obj = [[MyObject alloc]init]; //替换之前的方法 NSLog(@&quot;%@&quot;, [obj method1]); //替换 class_replaceMethod([MyObject class], @selector(method1), (IMP)logHAHA, &quot;v&quot;); [obj method1]; &#125;void logHAHA()&#123; NSLog(@&quot;HAHA&quot;);&#125; 打印如下： 这次够cool吧，通过这个方法，我们可以把系统的函数都搞乱套。当然，runtime还有许多很cool的方法： id object_copy(id obj, size_t size) 拷贝一个对象 id object_dispose(id obj) 释放一个对象 const char *object_getClassName(id obj) 获取对象的类名 ive void method_exchangeImplementations(Method m1, Method m2)交换两个方法的实现 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Cocos2d-x-v3中3D网格特效动画的应用","slug":"97Cocos2d-x-v3中3D网格特效动画的应用","date":"2015-08-05T16:00:00.000Z","updated":"2021-07-01T07:14:42.655Z","comments":true,"path":"2015/08/06/97Cocos2d-x-v3中3D网格特效动画的应用/","link":"","permalink":"http://huishao.cc/2015/08/06/97Cocos2d-x-v3中3D网格特效动画的应用/","excerpt":"","text":"Cocos2d-x-v3中3D网格特效动画的应用一、网格特效的使用原理基础的动作是对节点整体进行移动，变形等操作，网格特效的原理是将节点分割成多个尺寸相同的网格，根据改变每个网格块的属性使整体节点产生3D的效果。 二、网格特效的基本用法在cocos2d-x中，v3的版本新引入了一个类NodeGrid，专门用来包装网格的特效，示例如下： 12345678910111213141516 //获取屏幕尺寸 Size visibleSize = Director::getInstance()-&gt;getVisibleSize(); Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin(); //加载精灵 auto sprite = Sprite::create(&quot;HelloWorld.png&quot;); sprite-&gt;setPosition(Vec2(visibleSize.width/2+origin.x, visibleSize.height/2+origin.y)); //创建网格特效包装类 NodeGrid * nodeg = NodeGrid::create(); nodeg-&gt;setPosition(Vec2::ZERO); //添加播放特效的精灵 nodeg-&gt;addChild(sprite); this-&gt;addChild(nodeg); //参数的含义 分别是 执行时间，切分的网格大小，波浪次数，波浪大小 Waves3D * ani3d = Waves3D::create(2, Size(15, 15), 6, 4); //执行特效 nodeg-&gt;runAction(ani3d); 三、系统提供的网格特效static Waves3D* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude); 创建波浪3D效果，参数含义为：执行时间，网格尺寸，波浪次数，波浪大小 static FlipX3D* create(float duration); 以x为轴进行翻转 static FlipY3D* create(float duration); 以y为轴进行翻转 static Lens3D* create(float duration, const Size&amp; gridSize, const Vec2&amp; position, float radius); 创建镜头的3D效果，参数为：执行时间，网格大小，镜头中心，镜头半径 static Ripple3D* create(float duration, const Size&amp; gridSize, const Vec2&amp; position, float radius, unsigned int waves, float amplitude); 创建波纹特效，参数为：执行时间，网格大小，波纹中心，波纹半径，波纹计数，振幅 static Shaky3D* create(float initWithDuration, const Size&amp; gridSize, int range, bool shakeZ); 创建震动特效，参数为：执行时间，网格大小，震动范围，是否波动z轴 static Liquid* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude); 创建液体特效，参数为：执行时间，网格尺寸，流动次数，幅度 static Waves* create(float duration, const Size&amp; gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical); 创建平面波纹特效，参数为：执行时间，网格尺寸，波纹次数，波纹振幅，开关横向波纹，开关纵向波纹 static Twirl* create(float duration, const Size&amp; gridSize, Vec2 position, unsigned int twirls, float amplitude);创建扭曲旋转的特效，参数为：执行时间，网格尺寸，扭曲旋转中心，旋转次数，旋转幅度 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Cocos2d-x-v3动作体系","slug":"95Cocos2d-x-v3动作体系","date":"2015-08-04T16:00:00.000Z","updated":"2021-06-30T11:57:44.554Z","comments":true,"path":"2015/08/05/95Cocos2d-x-v3动作体系/","link":"","permalink":"http://huishao.cc/2015/08/05/95Cocos2d-x-v3动作体系/","excerpt":"","text":"Cocos2d-x-v3动作体系cocos2d-x-v3版本v2的版本有的很大的改动，最直观的是在一些函数的改动和类名的改动上，首先以CC开头的类，都不再使用CC。在我个人的理解上，原来的cocos2d-x是完全从iphone的框架cocos2d移植过来的，代码的风格和编程的思想都及类似于Object-C，除了语法是C++的外，其他就像是OC版的翻译，新的版本更好的体现了跨平台的特性，也更多的运用了C++的一些编码思想和语言特点，更易于各平台的开发者使用。这篇博客的主要内容，是总结cocos2d中行为动作的处理方法和相关函数。 一、瞬时动作 这类行为只能称为动作，不能称作动画，其执行是瞬时的，没有可是化的过程。 cocos2d中常用的瞬时动作有如下几种： FlipX：关于x轴做镜像变换。 FlipY：关于y轴做镜像变换。 Hide：隐藏。 Show：显示。 ToggleVisibility：切换隐藏和显示。 Place：将对象放置在某个位置。 二、延时动作延时动作就是动画，将动作的过程展现出来，cocos2d引擎中的几种延时动作如下： 1\\. MoveTo:将对象移动到某一位置，是绝对位置，移动后不会记录对象的原始位置，动作不能进行反转。例如： 12auto action = MoveTo::create(2, Vec2(100, 100));//2S时间移动到(100,100) label-&gt;runAction(action);//执行动作 2.MoveBy:将对象相对现在的位置移动某个距离，这个移动是相对对象当前位置的，可以反转。 3.JumpTo:和MoveTo类似，对象跳动到某一位置，例如： 1label-&gt;runAction(JumpTo::create(2, Vec2(100, 100), 30, 3));//对象在2S内跳三次，每次高度为30像素，跳到(100,100)点 4.JumpBy:和MoveBy类似。 5.BezierTo:以贝塞尔曲线的方式移动到某一位置，例如： 123456ccBezierConfig config; config.controlPoint_1=Vec2(300, 300); config.controlPoint_2=Vec2(200,200); config.endPosition=Vec2(100, 100);//设置两个中间点和一个终点 label-&gt;runAction(BezierTo::create(2, config));//2S时间通过贝塞尔曲线方式移动 6.BezierBy:以贝塞尔曲线的方式进行相对移动。 7.ScaleTo:相对原始大小缩放到某一尺度。 8.ScaleBy:相对目前大小进行缩放。 9.RotateTo:相对原始状态旋转到某一角度。 10.RotateBy：相对目前转台旋转某个角度。 11.Blink:闪烁动画。 12.TintTo：颜色转化到某一色值 13.TintBy:相对目前色值，颜色相对转变某一色值。 14.FadeTo:变暗到某一透明度 15.FadeIn:淡入动作 16.FadeOut：淡出动作 三、动作的组合方式 cocos2d中不仅为我们提供的各种动作方式，也为我们提供了相关的类用于管理这些动作： 1.动作序列Sequence：这个类可以创建一个动作序列，按序列中动作的顺序依次执行动作，如下： 12 Sequence * sq= Sequence::create(TintTo::create(2, Color3B(123, 123, 123)),RotateTo::create(2, 30), NULL); label-&gt;runAction(sq);//创建动作序列，使对象执行先变颜色，在旋转的动画 2.同步动作组Spawn：这个类和Sequence类似，只是他里面的动画会同时一起执行。 3.有限次的循环动作Repeat：这个类可以使某一动作循环执行数次，例如： 12Repeat * re = Repeat::create(RotateBy::create(2, 30), 5);//旋转5次30度 label-&gt;runAction(re); 4.无限次循环动作RepeatForever： 12RepeatForever * ref = RepeatForever::create(RotateBy::create(2, 30)); label-&gt;runAction(ref); 5.帧动画 cocos2d中同样提供了对帧动画的支持： 12345678910111213141516 //创建设置精灵 Sprite * spr = Sprite::create( &quot;CloseNormal.png&quot;); spr-&gt;setPosition(Vec2(100, 100)); //创建两帧精灵图片 SpriteFrame * frame1 = SpriteFrame::create(&quot;CloseNormal.png&quot;, Rect(0, 0, 50, 50)); SpriteFrame * frame2 = SpriteFrame::create(&quot;CloseSelected.png&quot;, Rect(0, 0, 50, 50)); Vector&lt;SpriteFrame *&gt; arr; arr.pushBack(frame1); arr.pushBack(frame2); //创建动画体 第一个参数是帧容器，第二个是每一帧的播放时间，第三个是循环次数 Animation * ani = Animation::createWithSpriteFrames(arr, 1, 1); //创建动作 Animate *ant = Animate::create(ani); RepeatForever * ref = RepeatForever::create(ant); spr-&gt;runAction(ref); this-&gt;addChild(spr); 6.反转动画 可以通过reverse方法获取动作的反转动作，例如： 12345auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/arial.ttf&quot;, 24); MoveBy * move = MoveBy::create(3, Vec2(100, 100)); Sequence * sq = Sequence::create(move,move-&gt;reverse(), NULL); label-&gt;runAction(sq); //label 会先相对移动(100,100)，再反移动回来 7.动作的速度控制 通过一些速度相关的类，cocos2d可以很轻松的创建出各种线性与非线性的动作。例如： 12345auto label = Label::createWithTTF(&quot;Hello World&quot;, &quot;fonts/arial.ttf&quot;, 24); MoveTo * move = MoveTo::create(3, Vec2(-200, -200)); EaseIn* an = EaseIn::create(move, 5); label-&gt;runAction(an);//label的运动会先慢后快，速度差为5倍 EaseIn:由慢变快，线性 EaseOut：由快变慢，线性 EaseInOut：由慢变快再由快变慢 EaseSineIn:由慢变快，正弦规律 EaseSineOut:由快变慢，正弦规律 EaseSineInOut：由慢变快再由快变慢，正弦规律 EaseExponentialIn:由慢变快,指数规律 EaseExponentialOut:由快变慢,指数规律 EaseExponentialInOut:由慢变快再由快变慢,指数规律 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Xcode中修改变量名、类名及字符串的替换操作","slug":"94Xcode中修改变量名、类名及字符串的替换操作","date":"2015-08-04T16:00:00.000Z","updated":"2021-06-30T11:27:50.184Z","comments":true,"path":"2015/08/05/94Xcode中修改变量名、类名及字符串的替换操作/","link":"","permalink":"http://huishao.cc/2015/08/05/94Xcode中修改变量名、类名及字符串的替换操作/","excerpt":"","text":"Xcode中修改变量名、类名及字符串的替换操作在做iOS开发代码优化的工作时，优化代码结构之前，我们应该先整理好工程的外貌，将文件和类的命名进行规范，在Xcode中为我们提供了方便而强大的名称修改功能。 第一步：修改类名 将鼠标点击放在类的名称上，选择Xcode工具栏中的edit-&gt;refactor-&gt;rename： 之后，将类名更改为我们需要的模式点击preview，记得将下面的关联文件勾选： Xcode会为我们检测出需要更改的地方，浏览无误后点击save。 第二步 修改相关字符串： 通过第一步，我们的类的文件名，类名都已经更改，但并不全面，因为某些注释，字符串动态创建类对象以及类函数创建类对象时的类名并没有更改，我们需要做这一步，将更改前的类名在Xcode左侧的搜索栏中搜索： ![](http://static.oschina.net/uploads/space/2015/0805/093235_ZPfC_2340880.png) 将Find改选为Replace： 这里面有四个选项，意义如下： Containing:检索出包涵检索条件的对象 Matching:检索出等于检索条件的对象 Start With：检索出以检索条件开头的对象 Ending with:检索出以检索条件结尾的对象 我们选择Matching，进行检索，将检索出来的地方进行Replace替换，通过这一步，我们可以替换代码中的注释，字符串，类方法以及xib和StoryBoard文件中关联的id，cell复用符等。 第三步：修改文件中变量名 在文件中，我们也可以通过command+F换出搜索框，将Find改选为Replace检索进行我们想要的变量替换。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}],"tags":[],"keywords":[{"name":"代码优化","slug":"代码优化","permalink":"http://huishao.cc/categories/代码优化/"}]},{"title":"Cocos2d-x-v3场景切换","slug":"96Cocos2d-x-v3场景切换","date":"2015-08-04T16:00:00.000Z","updated":"2021-07-01T06:51:02.057Z","comments":true,"path":"2015/08/05/96Cocos2d-x-v3场景切换/","link":"","permalink":"http://huishao.cc/2015/08/05/96Cocos2d-x-v3场景切换/","excerpt":"","text":"Cocos2d-x-v3场景切换cocos2d中场景的切换采用的是包装的思想，通过创建一个专场效果类，将需要专场的场景进行包装。代码示例如下： 12 auto * scene = OtherScene::createScene();//创建一个场景 Director::getInstance()-&gt;replaceScene(TransitionFlipX::create(1, scene));//进行包装切换，第一个参数为切换时间，第二个为切换的场景 引擎为我们封装的特效有很多，函数方法如下： static TransitionRotoZoom create(float t, Scene scene); 旧的场景旋转缩小到中心点后再将新的场景旋转放大完成切换 static TransitionJumpZoom create(float t, Scene scene); 旧场景弹跳缩小移出，新场景弹跳方法完成切换 static TransitionMoveInL create(float t, Scene scene); 新的场景从左边切入(覆盖) static TransitionMoveInR create(float t, Scene scene); 新的场景从右边切入(覆盖) static TransitionMoveInT create(float t, Scene scene); 新的场景从上边切入(覆盖) static TransitionMoveInB create(float t, Scene scene); 新的场景从下边切入(覆盖) static TransitionSlideInL create(float t, Scene scene); 新的场景从左边推入 static TransitionSlideInR create(float t, Scene scene); 新的场景从右边推入 static TransitionSlideInT create(float t, Scene scene); 新的场景从上边推入 static TransitionSlideInB create(float t, Scene scene); 新的场景从下边推入 static TransitionShrinkGrow create(float t, Scene scene); 新的场景从后向前进行替换 static TransitionFlipX create(float t, Scene s, Orientation o); 场景以X为轴进行翻转切换，第三个参数为翻转的方向 static TransitionFlipY create(float t, Scene s, Orientation o); 场景以Y为轴进行翻转切换，第三个参数为翻转的方向 static TransitionFlipAngular create(float t, Scene s, Orientation o); 场景以对角线为轴进行翻转切换，第三个参数为翻转的方向 static TransitionZoomFlipX create(float t, Scene s, Orientation o); 场景以X轴进行翻转，带缩放效果 static TransitionZoomFlipY create(float t, Scene s, Orientation o); 场景以Y轴进行翻转，带缩放效果 static TransitionZoomFlipAngular create(float t, Scene s, Orientation o); 场景以对角线为轴进行翻转，带缩放效果 static TransitionFade create(float duration, Scene scene, const Color3B&amp; color); 场景以颜色过渡进行切换 static TransitionCrossFade create(float t, Scene scene); 场景淡出过渡切换 static TransitionTurnOffTiles create(float t, Scene scene); 场景瓦片溶解切换 static TransitionSplitCols create(float t, Scene scene); 场景纵向切割切换 static TransitionSplitRows create(float t, Scene scene); 场景横向切割切换 static TransitionFadeTR create(float t, Scene scene); 场景向右上角过滤切换 static TransitionFadeBL create(float t, Scene scene); 场景向左下角过滤切换 static TransitionFadeUp create(float t, Scene scene); 场景向上过滤切换 static TransitionFadeDown create(float t, Scene scene); 场景向下过滤切换 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"Cocos2d-x-v3坐标体系","slug":"93Cocos2d-x-v3坐标体系","date":"2015-08-02T16:00:00.000Z","updated":"2021-06-30T11:25:57.887Z","comments":true,"path":"2015/08/03/93Cocos2d-x-v3坐标体系/","link":"","permalink":"http://huishao.cc/2015/08/03/93Cocos2d-x-v3坐标体系/","excerpt":"","text":"Cocos2d-x坐标体系cocos2d引擎是一款非常优秀的扩平台的游戏开发引擎，在apple游戏榜上，有很多排名靠前的游戏都是由他创造出来的，他也有一套十分方便的坐标体系。 一、UI坐标体系UI坐标体系相对于移动开发人员来说再熟悉不过了，在iOS系统中，它就是frame体系，即坐标(0,0)点位于屏幕的左上角，向右x增大，向下y增大。 二、OpenGL坐标体系OpenGL坐标系是cocos2d中使用的坐标系，它更接近于数学上的坐标系，即(0,0)点位于屏幕的左下角，往左x增大，往上y增大。这套坐标系统也更符合物理世界的逻辑，便于游戏的开发。当然，这并不是说cocos2d中所有的坐标都是采用这个体系标准的，在手指点击事件层，接收到点击坐标点的坐标就是采用UI坐标系表示的。 三、世界坐标系简单的理解，世界坐标系就是绝对坐标系，在cocos2d中，精灵的坐标是相对于其父视图而言的，是相对的坐标，世界坐标则是统一绝对的坐标，在项目中是固定的。 四、相对坐标系最常用的坐标体系，任何类设置的坐标都是相对于其父视图原点的坐标。 五、坐标系的转换由于UI坐标系与OpenGL坐标系的差异，在开发中，我们有时需要其两个标准的相互转化，cocos2d中也未我们提供了相应的方法： Vec2 Director::convertToGL(const Vec2&amp; uiPoint); 这个方法将UI坐标系转换为OpenGL坐标系。 Vec2 Director::convertToUI(const Vec2&amp; glPoint); 这个方法将OpenGL坐标系转换为UI坐标系。 Vec2 Node::convertToWorldSpace(const Vec2&amp; nodePoint) const; 这个方法将物体的相对坐标 Vec2 Node::convertToNodeSpace(const Vec2&amp; worldPoint) const; 这个方法将世界坐标转化为某一节点的相对坐标。 还有两个转化的方法与上面类似，只有一点不同，这两个方法参照的原点不是系统默认的，而是我们设置的节点的锚点： Vec2 Node::convertToNodeSpaceAR(const Vec2&amp; worldPoint) const; Vec2 Node::convertToWorldSpaceAR(const Vec2&amp; nodePoint) const; 六、锚点锚点的概念可以理解为参照点，其设置范围为0-1，系统默认的节点锚点为(0,0)。在UI坐标系中，(0,0)点就是节点的左上角，在OpenGL坐标系中，(0,0)点就是节点的左下角。例如，如果我将锚点设置为(0.5,0.5),则在UI和OpenGL坐标系中，(0,0)点都是节点的中心点。又如，我将锚点设置为(1,1)，则在UI坐标系中，原点为右下角，在OpenGL坐标系中，原点为右上角，锚点的用处就是更改参考点，在另一种情形下，锚点对程序也会产生很大的影响，就是当我们设置一个节点旋转或者缩放时，节点会以锚点位置为中心进行旋转或缩放。 cocos2d中通过下面方法分别来设置和获取锚点： void Sprite::setAnchorPoint(const Vec2&amp; anchor); 设置锚点 const Vec2&amp; Node::getAnchorPoint() const; 获取锚点 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}],"tags":[],"keywords":[{"name":"COCOS2D","slug":"COCOS2D","permalink":"http://huishao.cc/categories/COCOS2D/"}]},{"title":"iOS8新特性扩展(Extension)应用之四——自定义键盘控件","slug":"92iOS8新特性扩展(Extension)应用之四——自定义键盘控件","date":"2015-07-30T16:00:00.000Z","updated":"2021-06-30T11:23:25.803Z","comments":true,"path":"2015/07/31/92iOS8新特性扩展(Extension)应用之四——自定义键盘控件/","link":"","permalink":"http://huishao.cc/2015/07/31/92iOS8新特性扩展(Extension)应用之四——自定义键盘控件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之四——自定义键盘控件iOS8系统的开放第三方键盘，使得用户在输入法的选择上更加自主灵活，也更加贴近不同语言的输入风格。这篇博客，将介绍如何开发一个第三方的键盘控件。 一、了解UIInputViewController类UIInputViewController是系统扩展支持键盘扩展的一个类，通过这个类，我们可以自定义一款我们自己的键盘提供给系统使用。 首先，我们先来看一下这个类中的一些属性和方法： @property (nonatomic, retain) UIInputView *inputView; 键盘的输入视图，我们可以自定义这个视图。 @property (nonatomic, readonly) NSObject *textDocumentProxy; 实现了UITextDocumentProxy协议的一个对象，后面会介绍这个协议。 @property (nonatomic, copy) NSString *primaryLanguage; 系统为我们准备了一些本地化的语言字符串 - (void)dismissKeyboard; 收键盘的方法 - (void)advanceToNextInputMode; 切换到下一输入法的方法 UITextDocumentProxy协议内容如下： 123456789@protocol UITextDocumentProxy &lt;UIKeyInput&gt;//输入的上一个字符@property (nonatomic, readonly) NSString *documentContextBeforeInput;//即将输入的一个字符@property (nonatomic, readonly) NSString *documentContextAfterInput;//将输入的字符移动到某一位置- (void)adjustTextPositionByCharacterOffset:(NSInteger)offset;@end 而UITextDocumentProxy这个协议继承与UIKeyInput协议，UIKeyInput协议中提供的两个方法用于输入字符和删除字符： - (void)insertText:(NSString *)text;- (void)deleteBackward; 二、创建一款最简单的数字输入键盘创建一个项目，作为宿主APP，接着我们File-&gt;new-&gt;target-&gt;customKeyBoard: 系统要求我们对键盘的布局要使用autolayout，并且只可以采用代码布局的方式，我们这里为了简单演示，将坐标写死： 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)viewDidLoad &#123; [super viewDidLoad]; // 设置数字键盘的UI //数字按钮布局 for (int i=0; i&lt;10; i++) &#123; UIButton * btn = [UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20+45*(i%3), 20+45*(i/3), 40, 40); btn.backgroundColor=[UIColor greenColor]; [btn setTitle:[NSString stringWithFormat:@&quot;%d&quot;,i] forState:UIControlStateNormal]; btn.tag=101+i; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; &#125; //创建切换键盘按钮 UIButton * change = [UIButton buttonWithType:UIButtonTypeSystem]; change.frame=CGRectMake(200,20, 80, 40) ; NSLog(@&quot;%f,%f&quot;,self.view.frame.size.height,self.view.frame.size.width); [change setBackgroundColor:[UIColor blueColor]]; [change setTitle:@&quot;切换键盘&quot; forState:UIControlStateNormal]; [change addTarget:self action:@selector(change) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:change]; //创建删除按钮 UIButton * delete = [UIButton buttonWithType:UIButtonTypeSystem]; delete.frame=CGRectMake(200, 120, 80, 40); [delete setTitle:@&quot;delete&quot; forState:UIControlStateNormal]; [delete setBackgroundColor:[UIColor redColor]]; [delete addTarget:self action:@selector(delete) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:delete];&#125;//删除方法-(void)delete&#123; if (self.textDocumentProxy.documentContextBeforeInput) &#123; [self.textDocumentProxy deleteBackward]; &#125;&#125;//切换键盘方法-(void)change&#123; [self advanceToNextInputMode];&#125;//点击数字按钮 将相应数字输入-(void)click:(UIButton *)btn&#123; [self.textDocumentProxy insertText:[NSString stringWithFormat:@&quot;%ld&quot;,btn.tag-101]];&#125; 运行后，在使用之前，我们需要先加入这个键盘：在模拟器系统设置中general-&gt;keyboard-&gt;keyboards-&gt;addNowKeyboard 选中我们自定义的键盘，之后运行浏览器，切换到我们的键盘，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之三——照片编辑插件","slug":"91iOS8新特性扩展(Extension)应用之三——照片编辑插件","date":"2015-07-29T16:00:00.000Z","updated":"2021-06-30T11:20:59.694Z","comments":true,"path":"2015/07/30/91iOS8新特性扩展(Extension)应用之三——照片编辑插件/","link":"","permalink":"http://huishao.cc/2015/07/30/91iOS8新特性扩展(Extension)应用之三——照片编辑插件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之三——照片编辑插件 通过前几篇博客的介绍，我们了解到扩展给app提供的更加强大的交互能力，这种强大的交互能力另一方面体现在照片编辑插件的应用。 和通常一样，我们先创建一个工程，然后新建一个Target，选择photo editing： 从模板中，我们可以看到系统为我们创建了一个controller，这个controller就是用于处理照片的controller，其中方法如下： 123456789101112131415161718192021222324252627282930- (BOOL)canHandleAdjustmentData:(PHAdjustmentData *)adjustmentData &#123; // Inspect the adjustmentData to determine whether your extension can work with past edits. // (Typically, you use its formatIdentifier and formatVersion properties to do this.) return NO;&#125;//这个函数用于从系统相册获取到选中的照片，contentEditingInput对象中存有响应的数据类型和image对象- (void)startContentEditingWithInput:(PHContentEditingInput *)contentEditingInput placeholderImage:(UIImage *)placeholderImage &#123; //我们可以在这里将取到的数据进行展示等等 self.input = contentEditingInput;&#125;//结束编辑照片时的方法- (void)finishContentEditingWithCompletionHandler:(void (^)(PHContentEditingOutput *))completionHandler &#123; // Update UI to reflect that editing has finished and output is being rendered. // Render and provide output on a background queue. dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // Create editing output from the editing input. PHContentEditingOutput *output = [[PHContentEditingOutput alloc] initWithContentEditingInput:self.input]; //我们可以在这里将新的图片数据写入到输出流中 // output.adjustmentData = &lt;#new adjustment data#&gt;; // NSData *renderedJPEGData = &lt;#output JPEG#&gt;; // [renderedJPEGData writeToURL:output.renderedContentURL atomically:YES]; // Call completion handler to commit edit to Photos. completionHandler(output); // Clean up temporary files, etc. &#125;);&#125; 在当前扩展执行结束编辑之前，我们可以自由渲染我们得到的图片，例如添加相框，文字等等，输出时将渲染后的图片进行输出即可。 这里还有一个地方需要我们注意，此类扩展有一个功能，如果我们中途退出编辑，系统会为我们保存我们扩展的处理状态，为了区分多个类似功能的扩展，在输出数据的对象中有一个PHAdjustmentData类型的对象，这个对象专门用于负责版本的记录，这个对象中有如下两个属性用于区分版本： @property (readonly, copy) NSString *formatIdentifier; @property (readonly, copy) NSString *formatVersion; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之二——分享插件","slug":"90iOS8新特性扩展(Extension)应用之二——分享插件","date":"2015-07-29T16:00:00.000Z","updated":"2021-06-30T11:17:41.233Z","comments":true,"path":"2015/07/30/90iOS8新特性扩展(Extension)应用之二——分享插件/","link":"","permalink":"http://huishao.cc/2015/07/30/90iOS8新特性扩展(Extension)应用之二——分享插件/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之二——分享插件 在上一篇博客中，介绍了iOS8新特性扩展功能之一的Today功能：[http://my.oschina.net/u/2340880/blog/485533](http://my.oschina.net/u/2340880/blog/485533)，这里我们再介绍一下分享的扩展功能。 在iOS8之前，除了一些主流的社交平台，例如苹果支持内容分享外，其他开发者的应用若要加入分享的功能，将会十分的复杂。在iOS8的新特性中，apple为我们准备了这样的扩展功能。 首先创建工程，在我们的工程中新建一个Target： 之后，模板中会为我们创建一个controller类，这个controller用于控制我们的分享插件，里面内容： 1234567891011121314151617181920@implementation ShareViewController//这个函数用于判断分享内容的可用性，我们在其中获取分享的内容进行检查- (BOOL)isContentValid &#123; // Do validation of contentText and/or NSExtensionContext attachments here return YES;&#125;//点击post按钮后出发的方法，我们可以在这里将分享的内容进行上传等操作- (void)didSelectPost &#123; // This is called after the user selects Post. Do the upload of contentText and/or NSExtensionContext attachments. // Inform the host that we&apos;re done, so it un-blocks its UI. Note: Alternatively you could call super&apos;s -didSelectPost, which will similarly complete the extension context. [self.extensionContext completeRequestReturningItems:@[] completionHandler:nil];&#125;//这里用于设置分享插件的附件按钮- (NSArray *)configurationItems &#123; // To add configuration options via table cells at the bottom of the sheet, return an array of SLComposeSheetConfigurationItem here. return @[];&#125;@end 除此之外，还有一些常用的属性： - (void)presentationAnimationDidFinish; 弹出视图动画结束后执行的方法 @property (readonly, NS_NONATOMIC_IOSONLY) NSString *contentText; 分享的内容文字 @property (copy, NS_NONATOMIC_IOSONLY) NSString *placeholder; 默认显示的提示文字 - (void)didSelectCancel; 取消按钮执行的方法 我们在代码中如下添加后运行： 1234567891011@implementation ShareViewController-(NSString *)placeholder&#123; return @&quot;提示文字&quot;;&#125;- (NSArray *)configurationItems &#123; // To add configuration options via table cells at the bottom of the sheet, return an array of SLComposeSheetConfigurationItem here. SLComposeSheetConfigurationItem * item =[[SLComposeSheetConfigurationItem alloc]init]; item.title=@&quot;地点&quot;; item.value=@&quot;城门&quot;; return @[item];&#125; 我们用系统的相册做测试，点击相片的分享按钮： 点击MORE，添加我们的扩展插件。 这时分享栏中多了一个我们的插件，点击效果如下： 还有一点我们需要了解，在这个扩展的plist文件中，有这样一个键：NSExtensionAttributes，里面有一个NSExtensionActivationRule的字典，其中可以设置一些键值，对分享插件的属性进行控制。 这些键的写法在官方文档中的介绍如下： 这些键的意义，文档中介绍的很清楚，我们可以根据需要进行设置。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS8新特性扩展(Extension)应用之一——Today扩展","slug":"89iOS8新特性扩展(Extension)应用之一——Today扩展","date":"2015-07-29T16:00:00.000Z","updated":"2021-06-30T11:16:34.998Z","comments":true,"path":"2015/07/30/89iOS8新特性扩展(Extension)应用之一——Today扩展/","link":"","permalink":"http://huishao.cc/2015/07/30/89iOS8新特性扩展(Extension)应用之一——Today扩展/","excerpt":"","text":"iOS8新特性扩展(Extension)应用之一——Today扩展一、理解扩展1、简介基于iOS系统的安全性考虑，其应用的数据存储是通过沙盒模式进行的，要实现应用之间的数据共享十分困难，功能共享就更加棘手。在iOS8系统中，apple为我们提供了一个革命性的功能：扩展。我们可以通过扩展来使app间数据甚至功能进行共享。 2、几种扩展模式（1）今日视图扩展:today这个扩展也被叫做 widget。该扩展可以将今日发生的简短消息放到消息中心的「今日」视图里。这个功能类似于安卓系统中的小控件，只是安卓的可以直接放在桌面上，更加自由。示例如下： （2）分享功能扩展该扩展允许应用向在线服务上传照片、链接或者其他文件。在以前版本中，我们若要实现分享功能，必须进行复杂的操作。 （3）个性操作通过这个功能，可以实现两个APP中共享一些内容，例如编辑文字中的图片，翻译网页中的文字。 （4）照片操作这个类型的扩展可以允许我们在ipone相机中拍摄的照片使用其他图片编辑软件进行编辑。 （5）文件分享该扩展可以让软件将文件保存在各种云存储服务商。 （6）自定义键盘允许用户使用第三方的键盘输入法。 二、ToDay扩展的创建扩展是一个独立的构成，和其有关的两个概念是宿主APP和主机APP，宿主APP是扩展存放的地方，与扩展可以实现资源共享，主机APP是扩展运行的程序，例如ToDay扩展有抽屉中的Today应用进行运行。要创建一个ToDay扩展，首先我们需要创建一个宿主APP： 新建一个工程： 选择xcode工具栏中的File-&gt;new-&gt;target 在Application Extension中有上面提到的6中扩展，我们选择Today。 这是我们的项目中会多了一个扩展的文件夹： 这个文件夹中有一个ViewController，我们可以在里面进行布局，还有一个plist文件，可是配置扩展的一些属性。 我们创建一个按钮： 123 UIButton * btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 30)]; [btn setTitle:@&quot;231&quot; forState:UIControlStateNormal]; [self.view addSubview:btn]; 之后我们运行这个扩展： xcode会让我们选择运行扩展的主机程序，因为这是一个today类型的扩展，我们选择Today： 运行后，在系统的通知抽屉中，就会出现我们的这个扩展： 同样，我们可以创建tableView，imageView以及其他复杂的视图效果，我们也可以编写很多逻辑功能，跳转APP等。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之五——炫酷的粒子效果","slug":"88iOS动画开发之五——炫酷的粒子效果","date":"2015-07-28T16:00:00.000Z","updated":"2021-06-30T11:15:00.406Z","comments":true,"path":"2015/07/29/88iOS动画开发之五——炫酷的粒子效果/","link":"","permalink":"http://huishao.cc/2015/07/29/88iOS动画开发之五——炫酷的粒子效果/","excerpt":"","text":"iOS动画开发之五——炫酷的粒子效果在上几篇博客中，我们对UIView层的动画以及iOS的核心动画做了介绍，基本已经可以满足iOS应用项目中所有的动画需求，如果你觉得那些都还不够炫酷，亦或是你灵光一现，想用UIKit框架写出一款炫酷的休闲游戏，那个有一个东西可以帮到你：iOS的粒子效果引擎。 一、粒子发射器iOS中的粒子效果有两部分组成，一部分为发射器，设置例子发射的宏观属性，另一部分是粒子单元，用于设置相应的粒子属性。粒子发射器是基于Layer层，没错，又是Layer，他的全名叫做： CAEmitterLayer。其中常用的属性如下： @property(copy) NSArray *emitterCells; 粒子单元数组，例如你在绘制火焰的效果时，你可以创建两个单元，一个单元负责烟雾，一个单元负责火苗。 @property float birthRate; 粒子的创建速率，默认为1/s。 @property float lifetime; 粒子的存活时间。默认为1S。 @property CGPoint emitterPosition; 发射器在xy平面的中心位置 @property CGFloat emitterZPosition; 发射器在Z平面的位置 @property CGSize emitterSize; 发射器的尺寸大小 @property CGFloat emitterDepth; 发射器的深度，在某些模式下会产生立体效果 @property(copy) NSString *emitterShape; 发射器的形状，这个参数的几个系统字符串如下： 123456789101112CA_EXTERN NSString * const kCAEmitterLayerPoint __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0); //点的形状，粒子从一个点发出CA_EXTERN NSString * const kCAEmitterLayerLine __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//线的形状，粒子从一条线发出CA_EXTERN NSString * const kCAEmitterLayerRectangle __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//矩形形状，粒子从一个矩形中发出CA_EXTERN NSString * const kCAEmitterLayerCuboid __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//立方体形状，会影响Z平面的效果CA_EXTERN NSString * const kCAEmitterLayerCircle __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//圆形，粒子会在圆形范围发射CA_EXTERN NSString * const kCAEmitterLayerSphere __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//球型 @property(copy) NSString *emitterMode; 发射器的发射模式，参数如下： 12345678CA_EXTERN NSString * const kCAEmitterLayerPoints __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器中发出CA_EXTERN NSString * const kCAEmitterLayerOutline __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器边缘发出CA_EXTERN NSString * const kCAEmitterLayerSurface __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器表面发出CA_EXTERN NSString * const kCAEmitterLayerVolume __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//从发射器中点发出 @property(copy) NSString *renderMode; 发射器渲染模式，参数如下： 12345678910CA_EXTERN NSString * const kCAEmitterLayerUnordered __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，粒子是无序出现的，多个发射源将混合CA_EXTERN NSString * const kCAEmitterLayerOldestFirst __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，声明久的粒子会被渲染在最上层CA_EXTERN NSString * const kCAEmitterLayerOldestLast __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，年轻的粒子会被渲染在最上层CA_EXTERN NSString * const kCAEmitterLayerBackToFront __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式下，粒子的渲染按照Z轴的前后顺序进行CA_EXTERN NSString * const kCAEmitterLayerAdditive __OSX_AVAILABLE_STARTING (__MAC_10_6, __IPHONE_5_0);//这种模式会进行粒子混合 @property BOOL preservesDepth; 是否开启三维空间效果 @property float velocity; 粒子的运动速度 @property float scale; 粒子的缩放大小 @property float spin; 粒子的旋转位置 @property unsigned int seed; 初始化随机的粒子种子 二、粒子单元设置好了粒子发射器，我们还需要初始化一些粒子单元，设置具体粒子的属性，我们使用到的类是CAEmitterCell这个类。 + (instancetype)emitterCell; 类方法创建发射单元 @property(copy) NSString *name; 设置发射单元的名称 @property(getter=isEnabled) BOOL enabled; 是否允许发射器渲染 @property float birthRate; 粒子的创建速率 @property float lifetime; 粒子的生存时间 @property float lifetimeRange; 粒子的生存时间容差 @property CGFloat emissionLatitude; 粒子在Z轴方向的发射角度 @property CGFloat emissionLongitude; 粒子在xy平面的发射角度 @property CGFloat emissionRange; 粒子发射角度的容差 @property CGFloat velocity; 粒子的速度 @property CGFloat velocityRange; 粒子速度的容差 @property CGFloat xAcceleration; @property CGFloat yAcceleration; @property CGFloat zAcceleration; x，y，z三个方向的加速度 @property CGFloat scale; @property CGFloat scaleRange; @property CGFloat scaleSpeed; 缩放大小，缩放容差和缩放速度 @property CGFloat spin; @property CGFloat spinRange; 旋转度与旋转容差 @property CGColorRef color; 粒子的颜色 @property float redRange; @property float greenRange; @property float blueRange; @property float alphaRange; 粒子在rgb三个色相上的容差和透明度的容差 @property float redSpeed; @property float greenSpeed; @property float blueSpeed; @property float alphaSpeed; 粒子在RGB三个色相上的变化速度和透明度的变化速度 @property(strong) id contents; 渲染粒子，可以设置为一个CGImage的对象 @property CGRect contentsRect; 渲染的范围 三、让我们来“火”一把通过上面的介绍，我们来应用这些创造一团火，代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@interface ViewController ()&#123; CAEmitterLayer * _fireEmitter;//发射器对象&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.view.backgroundColor=[UIColor blackColor]; //设置发射器 _fireEmitter=[[CAEmitterLayer alloc]init]; _fireEmitter.emitterPosition=CGPointMake(self.view.frame.size.width/2,self.view.frame.size.height-20); _fireEmitter.emitterSize=CGSizeMake(self.view.frame.size.width-100, 20); _fireEmitter.renderMode = kCAEmitterLayerAdditive; //发射单元 //火焰 CAEmitterCell * fire = [CAEmitterCell emitterCell]; fire.birthRate=800; fire.lifetime=2.0; fire.lifetimeRange=1.5; fire.color=[[UIColor colorWithRed:0.8 green:0.4 blue:0.2 alpha:0.1]CGColor]; fire.contents=(id)[[UIImage imageNamed:@&quot;Particles_fire.png&quot;]CGImage]; [fire setName:@&quot;fire&quot;]; fire.velocity=160; fire.velocityRange=80; fire.emissionLongitude=M_PI+M_PI_2; fire.emissionRange=M_PI_2; fire.scaleSpeed=0.3; fire.spin=0.2; //烟雾 CAEmitterCell * smoke = [CAEmitterCell emitterCell]; smoke.birthRate=400; smoke.lifetime=3.0; smoke.lifetimeRange=1.5; smoke.color=[[UIColor colorWithRed:1 green:1 blue:1 alpha:0.05]CGColor]; smoke.contents=(id)[[UIImage imageNamed:@&quot;Particles_fire.png&quot;]CGImage]; [fire setName:@&quot;smoke&quot;]; smoke.velocity=250; smoke.velocityRange=100; smoke.emissionLongitude=M_PI+M_PI_2; smoke.emissionRange=M_PI_2; _fireEmitter.emitterCells=[NSArray arrayWithObjects:smoke,fire,nil]; [self.view.layer addSublayer:_fireEmitter]; &#125; 效果如下： 看到效果了么？这次够炫酷了吧，改改其它属性，尽情的玩吧！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之四——核心动画编程(CoreAnimation)","slug":"87iOS动画开发之四——核心动画编程(CoreAnimation)","date":"2015-07-27T16:00:00.000Z","updated":"2021-06-30T11:13:16.770Z","comments":true,"path":"2015/07/28/87iOS动画开发之四——核心动画编程(CoreAnimation)/","link":"","permalink":"http://huishao.cc/2015/07/28/87iOS动画开发之四——核心动画编程(CoreAnimation)/","excerpt":"","text":"iOS动画开发之四——核心动画编程(CoreAnimation)一、引言前几篇博客详细介绍了有关UIView层的动画使用与相关的效果，然而这些动画是UIKit为我们封装好的核心动画层的方法，通过这些方法，我们可以用的更加简便，当然功能也十分强大，基本能达到我们项目的大多需求。但是如果你想更加自由的通过动画操作视图的属性，你就需要跳过UIKit的封装，使用CoreAnimation核心动画层的方法来实现动画。 二、开始前的准备1、认识一个的朋友在开始介绍核心动画的内容前，我们需要先搞明白一个东西：Layer。你可能很少听说他，可是他却无处不在，在iOS的UI开发中，任何一个View包括继承于UIView的子类上面都会有一个Layer，可以理解为Layer为单独的一层，专门负责视图的显示，而view除此之外更多负责触摸时间等逻辑处理。因此，iOS也将所有动画的操作都交给你Layer来负责。 2、Layer层可以做到的事Layer如此神秘，那他究竟可以做到哪些事？他确实可以做很多view做不了的事情. (1)设置view的圆角属性12345 view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; view.layer.masksToBounds=YES;//设置layer层的切割属性 view.layer.cornerRadius=10;//设置layer层的圆角半径 效果如下： (2)设置view的边框123456view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; CALayer *layer=view.layer; layer.borderWidth=10;//设置边框的宽度 layer.borderColor=[[UIColor magentaColor]CGColor];//设置边框的颜色 注意：因为CoreAnimation层是UI层的底层，所以这里的颜色为CGColor对象。 效果如下： (3)设置视图阴影12345678 view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; CALayer *layer=view.layer; layer.shadowOffset=CGSizeMake(30, 30);//设置阴影方向 layer.shadowColor=[[UIColor blackColor] CGColor];//设置阴影颜色 layer.shadowOpacity=0.5;//设置阴影透明度 layer.shadowRadius=10;//设置阴影圆角 效果如下： 这样的立体效果是否已经很酷了？NO，在加上动画才对。 三、CoreAnimation的使用1、基础属性相关的动画CABasicAnimationCABasicAnimation是核心动画中对属性操作需要用到了一个动画类，示例如下： 1234567 CALayer *layer=view.layer; CABasicAnimation * ani= [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];//创建对象，参数关键字为layer的属性 ani.duration=3;//设置执行时间 ani.repeatCount=1;//设置执行次数 ani.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];//设置线性效果 [layer addAnimation:ani forKey:@&quot;test&quot;];//添加动画 layer.opacity=0;//透明度改变时执行动画动作 通过上面的示例，我们可以发现，layer的属性都可以来进行动画动作，这样，我们对动画的操作就自由的很多。 2、关键帧动画CAKeyframeAnimation关键帧动画除了动画改变layer的属性外，可以设置几个关键帧点，通过这些点，可以实现路径更加负责的动画，例如： 12345CALayer *layer=view.layer; CAKeyframeAnimation * ani = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];//创建一个关键帧动画对象 ani.duration=3; ani.values=@[@1,@0,@1];//传入三个关键帧，动画会将试图先慢慢隐藏，再慢慢展现 [layer addAnimation:ani forKey:@&quot;test&quot;]; 类比如上代码，我们还可以通过关键帧让试图按照我们预定的路线移动，同时我们还可以设置两个数组，分别为keyTimes和timingFunctions。这两个数组中的值可以设置动画每一段的运动线性特征和每一段的运动时间比例。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之三——UIView的转场切换","slug":"86iOS动画开发之三——UIView的转场切换","date":"2015-07-27T16:00:00.000Z","updated":"2021-06-30T11:12:12.076Z","comments":true,"path":"2015/07/28/86iOS动画开发之三——UIView的转场切换/","link":"","permalink":"http://huishao.cc/2015/07/28/86iOS动画开发之三——UIView的转场切换/","excerpt":"","text":"iOS动画开发之三——UIView的转场切换前两篇博客中，我们分别介绍了UIView动画的两种使用方式，分别为，带block的方式：[**http://my.oschina.net/u/2340880/blog/484457**](http://my.oschina.net/u/2340880/blog/484457) ,传统的属性配置的方式：[http://my.oschina.net/u/2340880/blog/484538](http://my.oschina.net/u/2340880/blog/484538)。通过UIView动画的类方法，我们可以十分方便的使View某些属性改变的同时拥有动画效果。这篇博客主要讨论View切换的动画操作。 两个方法： + (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 通过这个方法，我们可以重绘View视图，任何其子视图的改变或者其自身的改变都会触发转场动画的效果， 系统提供的转场效果在第一篇博客中已经介绍过。 这个方法常用于类似小说软件的翻页效果。 + (void)transitionFromView:(UIView )fromView toView:(UIView )toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion; 这个方法会作用于fromView的父视图，用于切换两个view，通过执行这个方法，会将formView从其父视图上移除，将toView重新粘在其父视图上，展现一个动画效果。 通过使用上述两个方法，你会发现某些效果会非常突兀，比如想要改变视图的颜色，它会在转场动画播放完成后，颜色突然的变化，要改善这一效果，我们需要设置options参数包含：UIViewAnimationOptionAllowAnimatedContent这个枚举。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之二——UIView动画执行的另一种方式","slug":"85iOS动画开发之二——UIView动画执行的另一种方式","date":"2015-07-27T16:00:00.000Z","updated":"2021-06-30T11:10:14.027Z","comments":true,"path":"2015/07/28/85iOS动画开发之二——UIView动画执行的另一种方式/","link":"","permalink":"http://huishao.cc/2015/07/28/85iOS动画开发之二——UIView动画执行的另一种方式/","excerpt":"","text":"iOS动画开发之二——UIView动画执行的另一种方式 上一篇博客中介绍了UIView的一些常用动画，通过block块，我们可以很方便简洁的创建出动画效果：[http://my.oschina.net/u/2340880/blog/484457](http://my.oschina.net/u/2340880/blog/484457)，这篇博客再介绍一种更加传统的执行UIView的动画的方法。 这种方式相比如block的方式，显得要麻烦一些，apple官方也推荐我们使用带block的创建动画的方式，我们可以将编程重心更多的放在动画逻辑的实现上。使用begin和commit方式主要分为三个步骤： 一、设置动画开始 1[UIView beginAnimations:@&quot;test&quot; context:nil]; 这个函数中的两个参数，第一个用于设置一个动画的标识id，通常第二个参数写为nil。 二、动画执行的参数设置 + (void)setAnimationDelegate:(id)delegate; 设置这个动画的代理，用于执行动画开始或者结束后的动作 + (void)setAnimationWillStartSelector:(SEL)selector; 设置动画开始时执行的回调 + (void)setAnimationDidStopSelector:(SEL)selector; 设置动画结束后执行的回调 + (void)setAnimationDuration:(NSTimeInterval)duration; 设置动画执行的时间 + (void)setAnimationDelay:(NSTimeInterval)delay; 设置延时执行的延时 + (void)setAnimationStartDate:(NSDate *)startDate; 给动画设置一个启示时间 + (void)setAnimationCurve:(UIViewAnimationCurve)curve; 设置动画播放的线性效果，UIViewAnimationCurve的枚举如下： 123456typedef NS_ENUM(NSInteger, UIViewAnimationCurve) &#123; UIViewAnimationCurveEaseInOut, // 淡入淡出 UIViewAnimationCurveEaseIn, // 淡入 UIViewAnimationCurveEaseOut, // 淡出 UIViewAnimationCurveLinear //线性&#125; + (void)setAnimationRepeatCount:(float)repeatCount; 设置动画循环播放次数 + (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses; 设置动画逆向执行 三、提交动画 + (void)commitAnimations; 例如： 1234567UIView * view = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; [self.view addSubview:view]; view.backgroundColor=[UIColor redColor]; [UIView beginAnimations:@&quot;test&quot; context:nil]; [UIView setAnimationDuration:3]; view.backgroundColor=[UIColor orangeColor]; [UIView commitAnimations];//执行commit后，动画即开始执行 一点建议：这种创建UIView动画的方式和上一篇博客中的block方式效果相同，然而效率并不高，写的代码也会繁琐冗长，在开发中，如果没有特殊的兼容要求，使用block的方式会更高效方便。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS动画开发之一——UIViewAnimation动画的使用","slug":"84iOS动画开发之一——UIViewAnimation动画的使用","date":"2015-07-26T16:00:00.000Z","updated":"2021-06-30T11:06:09.856Z","comments":true,"path":"2015/07/27/84iOS动画开发之一——UIViewAnimation动画的使用/","link":"","permalink":"http://huishao.cc/2015/07/27/84iOS动画开发之一——UIViewAnimation动画的使用/","excerpt":"","text":"iOS动画开发之一——UIViewAnimation动画的使用一、简介一款APP的成功与否，除了完善的功能外，用户体验也占有极大的比重，动画的合理运用，可以很好的增强用户体验。iOS开发中，常用的动画处理有UIView动画编程和核心动画编程，其中UIView动画使用简便，开发中应用十分广泛。这篇博客，主要讨论UIView的动画使用。 二、UIView动画的几个方法+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations; 这个是参数最少的一个方法，我们可以通过设置一个时间和block块来完成动画，时间参数是动画执行的时长，block块中为要执行的动画动作，具体可以执行那些动作，我们会在后面说。例如在1S内将view渐变透明： 123[UIView animateWithDuration:1 animations:^&#123; _myView.alpha=0; &#125;]; + (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数会带两个block块，用法和第一个函数相似，设置一个执行时间和一个执行动作，第二个block块中可以添加一个动画执行结束后的动作，作为补充，例如下面代码的效果，在1S内将view渐变为透明，动画结束后，view在瞬间变回不透明： 1234567[UIView animateWithDuration:1 animations:^&#123; _myView.alpha=0; &#125; completion:^(BOOL finished) &#123; if (finished) &#123; _myView.alpha=1; &#125; &#125;]; + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数除了上面的属性外，可以设置延时执行，同时可以设置一个动画效果参数，这个参数是个枚举，它可以影响动画的执行效果，后面会再总结。 + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 这个函数是iOS7之后的一个新函数，通过这个函数，我们可以方便的制作出效果炫酷的动画，这个函数的核心是两个阻尼参数，参数dampingRatio可以理解为弹簧效果的强弱，设置1则没有回弹效果，设置0则会剧烈的阻尼回弹。velocity参数用于设置弹簧的初始速度。 三、UIView动画可以操作的视图属性通过上面的介绍，我们了解了几个使用动画的函数，那么那些属性可以产生动画效果呢？ 官方文档告诉我们这些属性是可以通过上述方法进行动画的： 四、动画执行选项设置 在UIView执行动画的相关函数中，有UIViewAnimationOptions这个参数可以对动画的执行效果进行设置，这个枚举非常多，可分为三部分，如下： 123456789101112131415161718192021222324252627enum &#123; //这部分是基础属性的设置 UIViewAnimationOptionLayoutSubviews = 1 &lt;&lt; 0,//设置子视图随父视图展示动画 UIViewAnimationOptionAllowUserInteraction = 1 &lt;&lt; 1,//允许在动画执行时用户与其进行交互 UIViewAnimationOptionBeginFromCurrentState = 1 &lt;&lt; 2,//允许在动画执行时执行新的动画 UIViewAnimationOptionRepeat = 1 &lt;&lt; 3,//设置动画循环执行 UIViewAnimationOptionAutoreverse = 1 &lt;&lt; 4,//设置动画反向执行，必须和重复执行一起使用 UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt; 5,//强制动画使用内层动画的时间值 UIViewAnimationOptionOverrideInheritedCurve = 1 &lt;&lt; 6,//强制动画使用内层动画曲线值 UIViewAnimationOptionAllowAnimatedContent = 1 &lt;&lt; 7,//设置动画视图实时刷新 UIViewAnimationOptionShowHideTransitionViews = 1 &lt;&lt; 8,//设置视图切换时隐藏，而不是移除 UIViewAnimationOptionOverrideInheritedOptions = 1 &lt;&lt; 9,// //这部分属性设置动画播放的线性效果 UIViewAnimationOptionCurveEaseInOut = 0 &lt;&lt; 16,//淡入淡出 首末减速 UIViewAnimationOptionCurveEaseIn = 1 &lt;&lt; 16,//淡入 初始减速 UIViewAnimationOptionCurveEaseOut = 2 &lt;&lt; 16,//淡出 末尾减速 UIViewAnimationOptionCurveLinear = 3 &lt;&lt; 16,//线性 匀速执行 //这部分设置UIView切换效果 UIViewAnimationOptionTransitionNone = 0 &lt;&lt; 20, UIViewAnimationOptionTransitionFlipFromLeft = 1 &lt;&lt; 20,//从左边切入 UIViewAnimationOptionTransitionFlipFromRight = 2 &lt;&lt; 20,//从右边切入 UIViewAnimationOptionTransitionCurlUp = 3 &lt;&lt; 20,//从上面立体进入 UIViewAnimationOptionTransitionCurlDown = 4 &lt;&lt; 20,//从下面立体进入 UIViewAnimationOptionTransitionCrossDissolve = 5 &lt;&lt; 20,//溶解效果 UIViewAnimationOptionTransitionFlipFromTop = 6 &lt;&lt; 20,//从上面切入 UIViewAnimationOptionTransitionFlipFromBottom = 7 &lt;&lt; 20,//从下面切入&#125;; 提示：1，属性可以使用|进行多项合并。 2，这类的动画可以进行嵌套，其中有一点需要注意，内层动画的执行时间和曲线模式会默认继承外层动的，若要强制使用新的参数，使用如下的两个参数： 12UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt; 5,//强制动画使用内层动画的时间值 UIViewAnimationOptionOverrideInheritedCurve = 1 &lt;&lt; 6,//强制动画使用内层动画曲线值 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发技巧之查看模拟器沙盒文件","slug":"83iOS开发技巧之查看模拟器沙盒文件","date":"2015-07-18T16:00:00.000Z","updated":"2021-06-30T11:03:57.806Z","comments":true,"path":"2015/07/19/83iOS开发技巧之查看模拟器沙盒文件/","link":"","permalink":"http://huishao.cc/2015/07/19/83iOS开发技巧之查看模拟器沙盒文件/","excerpt":"","text":"iOS开发技巧之查看模拟器沙盒文件iOS开发中，在对数据库进行操作时，有时我们需要直观的查看数据库的内容，那么我们如何找到沙盒中的这个文件呢，步骤很简单： 1.点击Finder选项栏上的前往菜单： 2.选择前往文件夹选项： 前往的文件路径为：/Users/username/Library/Application Support/iPhone Simulator/ 其中username为当前mac电脑的用户名。 3.界面类似如下模样，选择一个版本的模拟器，应用的沙盒文件就在Applications中。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美十——用户交互元素","slug":"82标签之美十——用户交互元素","date":"2015-07-01T16:00:00.000Z","updated":"2021-06-30T11:02:01.459Z","comments":true,"path":"2015/07/02/82标签之美十——用户交互元素/","link":"","permalink":"http://huishao.cc/2015/07/02/82标签之美十——用户交互元素/","excerpt":"","text":"标签之美——用户交互元素任何一个网页都会提供用户交互的功能，包括账号密码的提交，留言板等用户信息的的获取。 一、用户交互表单的属性表单使用来创建。 1、跳转链接属性表单的跳转是在提交数据后跳转到指定的URL，使用action属性，如下： 12&lt;form action=&quot;http://&quot;&gt;&lt;/form&gt; 2、传递数据的方式表单跳转传递数据时可以设置一个传递方式，使用method可以设置方式为get或者post,delate,put： 12&lt;form action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;/form&gt; 3、表单名称表单可是设置一个名称，通过name属性来设置： 12&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;/form&gt; 二、输入表单输入表单使用创建，必须在表单元素中 123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input/&gt;&lt;/form&gt; 效果如下： 1、输入文本框输入表单有type属性可以用来设置类型： 123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;文本框&lt;input type=&quot;text&quot; name=&quot;文本框&quot;/&gt;&lt;!--name:表单名称--&gt;&lt;/form&gt; 效果如下： 2、密码输入框123&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;密码框&lt;input type=&quot;password&quot; name=&quot;密码框&quot;/&gt;&lt;!--name:表单名称--&gt;&lt;/form&gt; 效果如下： 3、输入单选框设置type=radio可以创建单选框，单选框需要设置几个属性，同一系列的单选框必须有相同的name值，不相同的value值，可以通过添加checked键值来设置默认选中，示例如下： 12345&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;性别&quot; value=&quot;男&quot; checked/&gt;男&lt;br/&gt;&lt;input type=&quot;radio&quot; name=&quot;性别&quot; value=&quot;女&quot;/&gt;女&lt;/form&gt; 效果如下： 4、输入复选框和单选框相似，可以使用type=checkbox创建复选框: 1234567&lt;body&gt;&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;/form&gt; 效果如下： 5、提交按钮使用type=submit来创建提交按钮，value值为按钮显示的文字： 1234567&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; 效果如下： 6、重置按钮123456&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;HTML&quot; checked/&gt;HTML&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;iOS&quot;/&gt;iOS&lt;br/&gt;&lt;input type=&quot;checkbox&quot; name=&quot;爱好&quot; value=&quot;android&quot;/&gt;android&lt;br/&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt; 效果如下： 点击重置按钮后，输入的内容会被重置。 7、图像按钮图像按钮和普通按钮的用法相似，设置type=image可以创建图像按钮，只是这个按钮多了一个src的属性用来设置图片的路径地址。 三、下拉列表通过和标签来设置下拉菜单和其中的选项，示例如下： 1234567&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;select name=&quot;下拉框&quot;&gt;&lt;option value=&quot;爱好&quot; selected&gt;HTML&lt;/option&gt;&lt;option value=&quot;爱好&quot;&gt;iOS&lt;/option&gt;&lt;option value=&quot;爱好&quot;&gt;android&lt;/option&gt;&lt;/select&gt;&lt;/form&gt; 效果如下： 四、文本输入框使用来设置文本输入框，属性rows和clos可以分别设置输入框的行数和列数，示例如下： 1234&lt;form name=&quot;my&quot; action=&quot;http://&quot; method=&quot;get&quot;&gt;&lt;textarea name=&quot;文本输入框&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt;&lt;/form&gt; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"Swift学习第二练——Swift项目时光电影","slug":"80Swift学习第二练——Swift项目时光电影","date":"2015-06-27T16:00:00.000Z","updated":"2021-06-30T10:59:21.664Z","comments":true,"path":"2015/06/28/80Swift学习第二练——Swift项目时光电影/","link":"","permalink":"http://huishao.cc/2015/06/28/80Swift学习第二练——Swift项目时光电影/","excerpt":"","text":"Swift学习第二练——Swift项目时光电影很早以前的一个OC的练习项目，用swift重新写了一遍，因为xcode版本的更新对swift的兼容度也在不断改变，此版本适用于xcode6.1。 这个项目中，用swift将iOS官方SDK中的HTTP进行了封装，使用了swift编写的异步加载网络图片的方法。练习了用swift操作界面布局，跳转界面等的方法。 下面是封装的下载类的核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private var httpConnection:NSURLConnection?class ZYHHttpRequset: NSObject,NSURLConnectionDataDelegate&#123; var requestUrl:String? var downloadData:NSMutableData=NSMutableData() var isDownloadSuccess:Bool? var delegate:ZYHHttpRequestDelegate? class func requestFormUrl(url:NSString)-&gt;ZYHHttpRequset&#123; var oldRequest:ZYHHttpRequset?=ZYHHttpRequestManager.sharedHttpRequestManager().requestForKey(url) if (oldRequest != nil)&#123; println(&quot;该任务存在&quot;) return oldRequest! &#125; //新建下载任务 var request:ZYHHttpRequset=ZYHHttpRequset() request.requestUrl=url request.startRequestUrl(url) ZYHHttpRequestManager.sharedHttpRequestManager().addTask(request, key: url) return request &#125; func stop()&#123; if httpConnection != nil &#123; httpConnection?.cancel() httpConnection = nil &#125; &#125; //开始下载请求 private func startRequestUrl(url:NSString)&#123; if httpConnection != nil &#123; httpConnection!.cancel() httpConnection==nil &#125; //创建连接对象 var request=NSURLRequest(URL: NSURL(string: url)!) httpConnection=NSURLConnection(request: request, delegate: self) &#125; //重写协议中的方法 func connection(connection: NSURLConnection, didReceiveResponse response: NSURLResponse) &#123; downloadData.length=0 &#125; func connection(connection: NSURLConnection, didReceiveData data: NSData) &#123; downloadData.appendData(data) &#125; func connectionDidFinishLoading(connection: NSURLConnection) &#123; isDownloadSuccess = true delegate!.ZYHHttpRequestSuccsee(self) ZYHHttpRequestManager.sharedHttpRequestManager().removeTaskFromUrl(self.requestUrl!) &#125; func connection(connection: NSURLConnection, didFailWithError error: NSError) &#123; println(&quot;加载失败&quot;) println(error) self.isDownloadSuccess=false ZYHHttpRequestManager.sharedHttpRequestManager().removeTaskFromUrl(self.requestUrl!) &#125; &#125;protocol ZYHHttpRequestDelegate&#123; func ZYHHttpRequestSuccsee(request:ZYHHttpRequset)&#125; 项目部分截图： github源码地址：https://github.com/ZYHshao/SwiftMovie 其中错误之处，欢迎指教，希望在交流中，不断进步！ 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"标签之美九——列表","slug":"81标签之美九——列表","date":"2015-06-27T16:00:00.000Z","updated":"2021-06-30T11:00:26.230Z","comments":true,"path":"2015/06/28/81标签之美九——列表/","link":"","permalink":"http://huishao.cc/2015/06/28/81标签之美九——列表/","excerpt":"","text":"标签之美——列表列表是网页排序中时常会用到的一个元素。 一、无序列表1、无序列表的标签无序列表使用来定义标签的开始和结束。使用来设置标签项，示例如下： 12345&lt;body&gt;&lt;ul&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 效果如下： 2、无序列表标签的样式标签的type属性可以设置其样式： 实心圆样式：disc这个样式就是默认的样式，效果如上图 空心圆样式：circle示例如下： 12345&lt;body&gt;&lt;ul type=&quot;circle&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 效果如下： 方块样式：square效果如下： 二、有序列表1、有序列表的标签有序列表的开始和结束使用来定义，同样使用来定义列表项，示例如下： 12345&lt;body&gt;&lt;ol type=&quot;square&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt; 效果如下： 2、有序列表的样式数字标号的样式：type=1这个样式为默认的样式，效果如上。 大写字母的标签：type=A效果如下： 小写字母样式：type=a 大写罗马数字样式：type=I 小写罗马数字样式：type=i 三、列表的嵌套列表可以进行嵌套，形式如下： 123456789&lt;body&gt;&lt;ol type=&quot;i&quot;&gt;&lt;li&gt;title1&lt;/li&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;subTitle1&lt;/li&gt;&lt;li&gt;subTitle2&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;title2&lt;/li&gt;&lt;li&gt;title3&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS开发swift版异步加载网络图片(带缓存和缺省图片)","slug":"79iOS开发swift版异步加载网络图片(带缓存和缺省图片)","date":"2015-06-24T16:00:00.000Z","updated":"2021-06-30T10:01:36.971Z","comments":true,"path":"2015/06/25/79iOS开发swift版异步加载网络图片(带缓存和缺省图片)/","link":"","permalink":"http://huishao.cc/2015/06/25/79iOS开发swift版异步加载网络图片(带缓存和缺省图片)/","excerpt":"","text":"iOS开发之swift版异步加载网络图片与SDWebImage异步加载网络图片的功能相似，只是代码比较简单，功能没有SD的完善与强大，支持缺省添加图片，支持本地缓存。 异步加载图片的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 func setZYHWebImage(url:NSString?, defaultImage:NSString?, isCache:Bool)&#123; var ZYHImage:UIImage? if url == nil &#123; return &#125; //设置默认图片 if defaultImage != nil &#123; self.image=UIImage(named: defaultImage!) &#125; //是否进行缓存处理 if isCache &#123; //缓存管理类 var data:NSData?=ZYHWebImageChcheCenter.readCacheFromUrl(url!) if data != nil &#123; ZYHImage=UIImage(data: data!) self.image=ZYHImage &#125;else&#123; //获取异步线程 var dispath=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) dispatch_async(dispath, &#123; () -&gt; Void in var URL:NSURL = NSURL(string: url!)! var data:NSData?=NSData(contentsOfURL: URL) if data != nil &#123; ZYHImage=UIImage(data: data!) //写缓存 ZYHWebImageChcheCenter.writeCacheToUrl(url!, data: data!) //主线程中刷新UI dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in //刷新主UI self.image=ZYHImage &#125;) &#125; &#125;) &#125; &#125;else&#123; var dispath=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0) dispatch_async(dispath, &#123; () -&gt; Void in var URL:NSURL = NSURL(string: url!)! var data:NSData?=NSData(contentsOfURL: URL) if data != nil &#123; ZYHImage=UIImage(data: data!) //写缓存 dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in //刷新主UI self.image=ZYHImage &#125;) &#125; &#125;) &#125; &#125; &#125; 缓存的处理这里采用的是写文件的方式，通过文件名来对缓存进行管理，这个框架还不完善，后面会加入缓存清除等功能。缓存的核心代码如下： 123456789101112131415161718192021222324252627282930313233343536373839class func readCacheFromUrl(url:NSString)-&gt;NSData?&#123; var data:NSData? var path:NSString=ZYHWebImageChcheCenter.getFullCachePathFromUrl(url) if NSFileManager.defaultManager().fileExistsAtPath(path) &#123; data=NSData.dataWithContentsOfMappedFile(path) as? NSData &#125; return data &#125; class func writeCacheToUrl(url:NSString, data:NSData)&#123; var path:NSString=ZYHWebImageChcheCenter.getFullCachePathFromUrl(url) println(data.writeToFile(path, atomically: true)) &#125; //设置缓存路径 class func getFullCachePathFromUrl(url:NSString)-&gt;NSString&#123; var chchePath=NSHomeDirectory().stringByAppendingString(&quot;/Library/Caches/MyCache&quot;) var fileManager:NSFileManager=NSFileManager.defaultManager() fileManager.fileExistsAtPath(chchePath) if !(fileManager.fileExistsAtPath(chchePath)) &#123; fileManager.createDirectoryAtPath(chchePath, withIntermediateDirectories: true, attributes: nil, error: nil) &#125; //进行字符串处理 var newURL:NSString newURL=ZYHWebImageChcheCenter.stringToZYHString(url) chchePath=chchePath.stringByAppendingFormat(&quot;/%@&quot;, newURL) return chchePath &#125; class func stringToZYHString(str:NSString)-&gt;NSString&#123; var newStr:NSMutableString=NSMutableString() for var i:NSInteger=0; i &lt; str.length; i++ &#123; var c:unichar=str.characterAtIndex(i) if (c&gt;=48&amp;&amp;c&lt;=57)||(c&gt;=65&amp;&amp;c&lt;=90)||(c&gt;=97&amp;&amp;c&lt;=122)&#123; newStr.appendFormat(&quot;%c&quot;, c) &#125; &#125; return newStr.copy() as NSString &#125; 框架的github地址，欢迎指正与扩展：https://github.com/ZYHshao/swift-ZYHWebImage 因xcode的版本不同，swift语言语法随环境时常会变化，此版本在6.1中可用，更高版本中需要修改少部分即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS中UIWebView的使用详解","slug":"78iOS中UIWebView的使用详解","date":"2015-06-22T16:00:00.000Z","updated":"2021-06-30T10:00:15.618Z","comments":true,"path":"2015/06/23/78iOS中UIWebView的使用详解/","link":"","permalink":"http://huishao.cc/2015/06/23/78iOS中UIWebView的使用详解/","excerpt":"","text":"iOS中UIWebView的使用详解一、初始化与三种加载方式UIWebView继承与UIView，因此，其初始化方法和一般的view一样，通过alloc和init进行初始化，其加载数据的方式有三种： 第一种： - (void)loadRequest:(NSURLRequest *)request; 这是加载网页最常用的一种方式，通过一个网页URL来进行加载，这个URL可以是远程的也可以是本地的，例如我加载百度的主页： 123 UIWebView * view = [[UIWebView alloc]initWithFrame:self.view.frame]; [view loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]]]; [self.view addSubview:view]; 会得到如下的效果： 第二种： - (void)loadHTMLString:(NSString )string baseURL:(NSURL )baseURL; 这个方法需要将httml文件读取为字符串，其中baseURL是我们自己设置的一个路径，用于寻找html文件中引用的图片等素材。 第三种： - (void)loadData:(NSData )data MIMEType:(NSString )MIMEType textEncodingName:(NSString )textEncodingName baseURL:(NSURL )baseURL; 这个方式使用的比较少，但也更加自由，其中data是文件数据，MIMEType是文件类型，textEncodingName是编码类型，baseURL是素材资源路径。 二、一些常用的属性和变量@property (nonatomic, assign) id &lt;UIWebViewDelegate> delegate; 设置webView的代理 @property (nonatomic, readonly, retain) UIScrollView *scrollView; 内置的scrollView @property (nonatomic, readonly, retain) NSURLRequest *request; URL请求 - (void)reload; 重新加载数据 - (void)stopLoading; 停止加载数据 - (void)goBack; 返回上一级 - (void)goForward; 跳转下一级 @property (nonatomic, readonly, getter=canGoBack) BOOL canGoBack; 获取能否返回上一级 @property (nonatomic, readonly, getter=canGoForward) BOOL canGoForward; 获取能否跳转下一级 @property (nonatomic, readonly, getter=isLoading) BOOL loading; 获取是否正在加载数据 - (NSString )stringByEvaluatingJavaScriptFromString:(NSString )script; 通过javaScript操作web数据 @property (nonatomic) BOOL scalesPageToFit; 设置是否缩放到适合屏幕大小 @property (nonatomic) UIDataDetectorTypes dataDetectorTypes NS_AVAILABLE_IOS(3_0); 设置某些数据变为链接形式，这个枚举可以设置如电话号，地址，邮箱等转化为链接 @property (nonatomic) BOOL allowsInlineMediaPlayback NS_AVAILABLE_IOS(4_0); 设置是否使用内联播放器播放视频 @property (nonatomic) BOOL mediaPlaybackRequiresUserAction NS_AVAILABLE_IOS(4_0); 设置视频是否自动播放 @property (nonatomic) BOOL mediaPlaybackAllowsAirPlay NS_AVAILABLE_IOS(5_0); 设置音频播放是否支持ari play功能 @property (nonatomic) BOOL suppressesIncrementalRendering NS_AVAILABLE_IOS(6_0); 设置是否将数据加载如内存后渲染界面 @property (nonatomic) BOOL keyboardDisplayRequiresUserAction NS_AVAILABLE_IOS(6_0); 设置用户交互模式 三、iOS7中的一些新特性下面这些属性是iOS7之后才有的，通过他们可以设置更加有趣的web体验 @property (nonatomic) UIWebPaginationMode paginationMode NS_AVAILABLE_IOS(7_0); 这个属性用来设置一种模式，当网页的大小超出view时，将网页以翻页的效果展示，枚举如下： 1234567typedef NS_ENUM(NSInteger, UIWebPaginationMode) &#123; UIWebPaginationModeUnpaginated,//不使用翻页效果 UIWebPaginationModeLeftToRight,//将网页超出部分分页，从左向右进行翻页 UIWebPaginationModeTopToBottom,//将网页超出部分分页，从上向下进行翻页 UIWebPaginationModeBottomToTop,//将网页超出部分分页，从下向上进行翻页 UIWebPaginationModeRightToLeft//将网页超出部分分页，从右向左进行翻页&#125;; @property (nonatomic) CGFloat pageLength NS_AVAILABLE_IOS(7_0); 设置每一页的长度 @property (nonatomic) CGFloat gapBetweenPages NS_AVAILABLE_IOS(7_0); 设置每一页的间距 @property (nonatomic, readonly) NSUInteger pageCount NS_AVAILABLE_IOS(7_0); 获取分页数 四、webView协议中的方法- (BOOL)webView:(UIWebView )webView shouldStartLoadWithRequest:(NSURLRequest )request navigationType:(UIWebViewNavigationType)navigationType; 准备加载内容时调用的方法，通过返回值来进行是否加载的设置 - (void)webViewDidStartLoad:(UIWebView *)webView; 开始加载时调用的方法 - (void)webViewDidFinishLoad:(UIWebView *)webView; 结束加载时调用的方法 - (void)webView:(UIWebView )webView didFailLoadWithError:(NSError )error; 加载失败时调用的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Swift学习第一练——用Swift实现的FlappyBird小游戏","slug":"77Swift学习第一练——用Swift实现的FlappyBird小游戏","date":"2015-06-10T16:00:00.000Z","updated":"2021-06-30T09:59:10.108Z","comments":true,"path":"2015/06/11/77Swift学习第一练——用Swift实现的FlappyBird小游戏/","link":"","permalink":"http://huishao.cc/2015/06/11/77Swift学习第一练——用Swift实现的FlappyBird小游戏/","excerpt":"","text":"用Swift实现的FlappyBird小游戏 伴随着apple公司对swift的推广态度深入，swift火的很快，并且swift精简便捷的语法和强大的功能，对于使用Object—C开发iOS的开发者来说，也有必要了解学习一下swift。这篇博客跳过swift干涩的语法，直接从一个小游戏项目开始使用swift，将其中收获总结如下： FlappyBird是前段时间很火的一款小游戏，通过手指点击屏幕平衡小鸟通过障碍。我是将以前OC版的项目拿来改成了swift，所以整体的思路还是OC的开发思路。 首先，我需要定义两个宏，一个用来模拟重力加速度G，一个用来便捷获取设备屏幕尺寸。因为这个游戏非常简单，开发起来也只需要几个小时，所以我们只需要在一个文件中写代码：viewController.swift。 swift中没有一般语言中的宏定义，但是可以通过定义常量的形式实现宏的效果： 123//用常量的形式代理OC中的宏定义let G:Float=9.8let SCREEN_SIZE = UIScreen.mainScreen().bounds 我们需要定义一些成员变量，如下： 12345678910class ViewController: UIViewController &#123; var timer:NSTimer?//背景移动的定时器 var i:Int=0//背景移动的速度 var timer2:NSTimer?//柱子和地面移动的定时器 var timer3:NSTimer?//小鸟移动的定时器 var bird:UIImageView? var t:Float=0.0//小鸟下落的速度 var isDowm:Bool=false//标记小鸟是否在下落 var isGameOver:Bool=false//标记是否游戏结束&#125; 对于？和！号的理解，网上概念很多，简单理解声明变量时如果不初始化系统是不会给变量赋nil的，会报错，？的作用就是告诉系统这里如果没有初始化就是nil。同理，在用这类变量的时候，也需要加上？解包，如果加！就是强制解包，可以理解为让系统认为这个变量一定不是nil。 对于UI的创建等部分函数和OC一样，只是调用的方式略有不同，后面会附上源码。 在控制小鸟下落的部分代码如下，其中有一点需要注意，在swift中没有隐式转换这个概念，比如你要使用int a + float b 你必须手动将int转为float:(Float)(a)+b 12345678910111213141516171819func birdMove()&#123; if !isDowm&#123; if bird?.frame.origin.y &lt; SCREEN_SIZE.height-100&#123; var rant:CGRect=bird!.frame rant.origin.y += (CGFloat)(G*(t*t/2)) bird?.frame=rant t+=0.025 &#125; &#125;else&#123; if t&lt;0.24&#123; var rant = bird?.frame rant?.origin.y -= 4.9-(CGFloat)(G*t*t/2) bird?.frame=rant! t+=0.025 &#125;else&#123; isDowm=false &#125; &#125; &#125; 游戏效果图如下： 我相信，实践是学习的必经途径，希望与志同道合的朋友，一起进步。 项目github地址：https://github.com/ZYHshao/swiftFlappyBird 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}],"tags":[],"keywords":[{"name":"COME ON SWIFT","slug":"COME-ON-SWIFT","permalink":"http://huishao.cc/categories/COME-ON-SWIFT/"}]},{"title":"iOS选择器视图控件(UIPickerView)使用方法总结","slug":"76iOS选择器视图控件(UIPickerView)使用方法总结","date":"2015-06-09T16:00:00.000Z","updated":"2021-06-30T09:57:24.304Z","comments":true,"path":"2015/06/10/76iOS选择器视图控件(UIPickerView)使用方法总结/","link":"","permalink":"http://huishao.cc/2015/06/10/76iOS选择器视图控件(UIPickerView)使用方法总结/","excerpt":"","text":"iOS中UIPickerView使用总结UIPickerView是iOS中的原生选择器控件，使用方便，用法简单，效果漂亮。 @property(nonatomic,assign) id&lt;UIPickerViewDataSource> dataSource; @property(nonatomic,assign) id&lt;UIPickerViewDelegate> delegate; 设置数据源和代理 @property(nonatomic) BOOL showsSelectionIndicator; 是否显示选择框，在iOS7之后这个属性没有任何效果 @property(nonatomic,readonly) NSInteger numberOfComponents; 获取分区数 - (NSInteger)numberOfRowsInComponent:(NSInteger)component; 获取某一分区的行数 - (CGSize)rowSizeForComponent:(NSInteger)component; 获取某一分区行的尺寸 - (UIView *)viewForRow:(NSInteger)row forComponent:(NSInteger)component; 获取某一分区某一行的视图 - (void)reloadAllComponents; 重载所有分区 - (void)reloadComponent:(NSInteger)component; 重载某一分区 - (void)selectRow:(NSInteger)row inComponent:(NSInteger)component animated:(BOOL)animated; 设置选中某一分区某一行 - (NSInteger)selectedRowInComponent:(NSInteger)component; 返回某一分区选中的行 数据源代理中的方法： - (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView; 设置分区数 - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component; 根据分区设置行数 代理中的方法： - (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component; 设置分区宽度 - (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component; 设置分区行高 - (NSString )pickerView:(UIPickerView )pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component; 设置某一行显示的标题 - (NSAttributedString )pickerView:(UIPickerView )pickerView attributedTitleForRow:(NSInteger)row forComponent:(NSInteger)component; 通过属性字符串设置某一行显示的标题 - (UIView )pickerView:(UIPickerView )pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view; 设置某一行显示的view视图 - (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component; 选中某一行时执行的回调 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UI之日期控件的使用（UIDatePicker）","slug":"75iOS开发UI之日期控件的使用（UIDatePicker）","date":"2015-06-08T16:00:00.000Z","updated":"2021-06-29T08:16:53.639Z","comments":true,"path":"2015/06/09/75iOS开发UI之日期控件的使用（UIDatePicker）/","link":"","permalink":"http://huishao.cc/2015/06/09/75iOS开发UI之日期控件的使用（UIDatePicker）/","excerpt":"","text":"iOS日期控件UIDatePicker用法总结@property (nonatomic) UIDatePickerMode datePickerMode; 设置控件模式，枚举如下： 123456typedef NS_ENUM(NSInteger, UIDatePickerMode) &#123; UIDatePickerModeTime, //时间模式，显示时分和上下午 UIDatePickerModeDate, //日期模式显示年月日 UIDatePickerModeDateAndTime, //时间和日期模式，显示月日星期，时分上下午 UIDatePickerModeCountDownTimer, //计时模式，显示时和分&#125;; @property (nonatomic, retain) NSLocale *locale; 设置本地化环境 @property (nonatomic, copy) NSCalendar *calendar; 设置日历 @property (nonatomic, retain) NSTimeZone *timeZone; 设置时区 @property (nonatomic, retain) NSDate *date; 设置当前时间 @property (nonatomic, retain) NSDate *minimumDate; 设置最小时间点 @property (nonatomic, retain) NSDate *maximumDate; 设置最大时间点 @property (nonatomic) NSTimeInterval countDownDuration; 只适用于计时模式，设置时间 @property (nonatomic) NSInteger minuteInterval;设置每一格的时间差 - (void)setDate:(NSDate *)date animated:(BOOL)animated; 设置到一个时间，有动画效果 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中UITextView方法解读","slug":"73iOS中UITextView方法解读","date":"2015-06-03T16:00:00.000Z","updated":"2021-06-29T08:06:24.440Z","comments":true,"path":"2015/06/04/73iOS中UITextView方法解读/","link":"","permalink":"http://huishao.cc/2015/06/04/73iOS中UITextView方法解读/","excerpt":"","text":"iOS中UITextView方法解读常用属性解读： @property(nonatomic,assign) id&lt;UITextViewDelegate> delegate; 设置代理属性 @property(nonatomic,copy) NSString *text; textView上的文本 @property(nonatomic,retain) UIFont *font; 设置文本字体 @property(nonatomic,retain) UIColor *textColor; 设置文本颜色 @property(nonatomic) NSTextAlignment textAlignment; 设置文本对齐模式 @property(nonatomic) NSRange selectedRange; 设置选中的文本范围(只有当textView是第一响应时才有效) @property(nonatomic,getter=isEditable) BOOL editable; 设置是否可以编辑 @property(nonatomic,getter=isSelectable) BOOL selectable; 设置是否可以选中 @property(nonatomic) UIDataDetectorTypes dataDetectorTypes; 这个属性可以将本文中的电话，邮件等变为链接，长按会调用响应响应的程序(textView必须为不可编辑状态)，属性的枚举如下： 12345678typedef NS_OPTIONS(NSUInteger, UIDataDetectorTypes) &#123; UIDataDetectorTypePhoneNumber = 1 &lt;&lt; 0, // 电话变为链接 UIDataDetectorTypeLink = 1 &lt;&lt; 1, // 网址变为链接 UIDataDetectorTypeAddress = 1 &lt;&lt; 2, // 地址变为链接 UIDataDetectorTypeCalendarEvent = 1 &lt;&lt; 3, // 日历变为链接 UIDataDetectorTypeNone = 0, // 无连接 UIDataDetectorTypeAll = NSUIntegerMax // 所有类型链接&#125;; @property(nonatomic) BOOL allowsEditingTextAttributes; 设置是否允许编辑属性字符串文本 @property(nonatomic,copy) NSAttributedString *attributedText; 设置属性字符串文本 @property(nonatomic,copy) NSDictionary *typingAttributes; 设置属性字符串文本属性字典 - (void)scrollRangeToVisible:(NSRange)range; 滚动textView使其显示在本一段文本 @property (readwrite, retain) UIView *inputView; 设置成为第一响应时弹出的视图，键盘视图 @property (readwrite, retain) UIView *inputAccessoryView; 设置成为第一响应时弹出的副视图，副键盘视图 @property(nonatomic) BOOL clearsOnInsertion; 设置是否显示删除按钮 UITextViewDelegate中的方法 - (BOOL)textViewShouldBeginEditing:(UITextView *)textView; 是否开始编辑 - (BOOL)textViewShouldEndEditing:(UITextView *)textView; 是否结束编辑 - (void)textViewDidBeginEditing:(UITextView *)textView; 开始编辑时触发的方法 - (void)textViewDidEndEditing:(UITextView *)textView; 结束编辑时触发的方法 - (BOOL)textView:(UITextView )textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString )text; 是否允许字符改变 - (void)textViewDidChange:(UITextView *)textView; 字符内容改变触发的方法 - (void)textViewDidChangeSelection:(UITextView *)textView; 选中内容改变触发的方法 - (BOOL)textView:(UITextView )textView shouldInteractWithURL:(NSURL )URL inRange:(NSRange)characterRange; 当文本中的URL进行链接时触发的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发UIScrollView使用详解","slug":"74iOS开发UIScrollView使用详解","date":"2015-06-03T16:00:00.000Z","updated":"2021-06-29T08:13:08.130Z","comments":true,"path":"2015/06/04/74iOS开发UIScrollView使用详解/","link":"","permalink":"http://huishao.cc/2015/06/04/74iOS开发UIScrollView使用详解/","excerpt":"","text":"iOS开发UIScrollView使用详解一、ScrollView常用方法和属性@property(nonatomic)CGPoint contentOffset; 设置滚动的偏移量 @property(nonatomic)CGSize contentSize; 设置滑动区域 @property(nonatomic,assign) id delegate; 设置UIScrollView的代理 @property(nonatomic,getter=isDirectionalLockEnabled) BOOL directionalLockEnabled; 设置是否锁定，这个属性很有意思，默认为NO，当设置为YES时，你的滚动视图只能同一时间在一个方向上滚动，但是当你从对角线拖动时，是时刻在水平和竖直方向同时滚动的。 @property(nonatomic) BOOL bounces; 设置是否开启回弹效果 @property(nonatomic) BOOL alwaysBounceVertical; 是否开启垂直方向的回弹效果 @property(nonatomic) BOOL alwaysBounceHorizontal; 是否开启水平方向的回弹效果 @property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled; 是否开启翻页效果 @property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled; 设置是否可以滑动 @property(nonatomic) BOOL showsHorizontalScrollIndicator; 设置是否显示水平滑动条 @property(nonatomic) BOOL showsVerticalScrollIndicator; 设置是否显示竖直滑动条 @property(nonatomic) UIEdgeInsets scrollIndicatorInsets; 设置滑动条的位置 @property(nonatomic) UIScrollViewIndicatorStyle indicatorStyle; 设置滑动条风格，枚举如下： 12345typedef NS_ENUM(NSInteger, UIScrollViewIndicatorStyle) &#123; UIScrollViewIndicatorStyleDefault, //默认 UIScrollViewIndicatorStyleBlack, //黑色风格 UIScrollViewIndicatorStyleWhite //白色风格&#125;; @property(nonatomic) CGFloat decelerationRate; 设置滑动速度 - (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated; 设置滚动视图内容的偏移量，可以带动画效果 - (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated; 设置滚动视图滚动到某个可见区域，可以带动画效果 - (void)flashScrollIndicators; 显示一个短暂的滚动指示器 @property(nonatomic,readonly,getter=isTracking) BOOL tracking; 获取用户是否触及视图内容 @property(nonatomic,readonly,getter=isDragging) BOOL dragging; 获取用户是否开始拖动视图 @property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating; 获取视图是否开始减速（用户停止拖动但视图仍在滚动） @property(nonatomic) BOOL delaysContentTouches; 设置视图是否延迟处理触摸事件（会将消息传递给子视图） @property(nonatomic) BOOL canCancelContentTouches; 设置是否给子视图传递取消动作的消息（默认设置为YES，当scrollView触发事件的时候，其子视图不能触发，如果设置为NO，则子视图会继续触发事件） - (BOOL)touchesShouldBegin:(NSSet )touches withEvent:(UIEvent )event inContentView:(UIView *)view; - (BOOL)touchesShouldCancelInContentView:(UIView *)view; 重写这两个方法可以控制起子视图的事件响应 @property(nonatomic) CGFloat minimumZoomScale; 设置内容最小缩放比例 @property(nonatomic) CGFloat maximumZoomScale; 设置内容最大缩放比例 @property(nonatomic) CGFloat zoomScale; 设置缩放比例 - (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated; 设置缩放比例，可以带动画效果 - (void)zoomToRect:(CGRect)rect animated:(BOOL)animated; 设置缩放显示到某个区域，可以带动画效果 @property(nonatomic) BOOL bouncesZoom; 设置是否可以缩放回弹 @property(nonatomic,readonly,getter=isZooming) BOOL zooming; 获取是否正在缩放模式 @property(nonatomic,readonly,getter=isZoomBouncing) BOOL zoomBouncing; 获取是否当前的缩放比例超出设置的峰值 @property(nonatomic) BOOL scrollsToTop; 设置是否点击状态栏滚动到scrollView的最上端 @property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode; 设置键盘消失的模式，枚举如下： 12345typedef NS_ENUM(NSInteger, UIScrollViewKeyboardDismissMode) &#123; UIScrollViewKeyboardDismissModeNone, UIScrollViewKeyboardDismissModeOnDrag, //手指滑动视图键盘就会消失 UIScrollViewKeyboardDismissModeInteractive, //手指滑动视图后可以与键盘交互，上下滑动键盘会跟随手指上下移动&#125;; 二、ScrollViewDelegata中常用方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView; 视图已经开始滑动时触发的方法 - (void)scrollViewDidZoom:(UIScrollView *)scrollView; 视图已经开始缩放时触发的方法 - (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView; 视图开始拖动时触发的方法 - (void)scrollViewWillEndDragging:(UIScrollView )scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint )targetContentOffset; - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate; 视图拖动结束时触发的方法 - (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; 视图开始减速时触发的方法 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; 视图减速结束时触发的方法 - (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; 视图动画结束时触发的方法，使用set方法设置偏移量后回触发 - (UIView )viewForZoomingInScrollView:(UIScrollView )scrollView; 返回进行缩放的视图 - (void)scrollViewWillBeginZooming:(UIScrollView )scrollView withView:(UIView )view; 视图内容将要开始缩放时触发的方法 - (void)scrollViewDidEndZooming:(UIScrollView )scrollView withView:(UIView )view atScale:(CGFloat)scale; 视图内容结束缩放时触发的方法 - (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; 返回yes，开启快捷滚动回顶端，将要滚动时调用 - (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; 视图快捷滚动回顶端开始动作时调用 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中UIImageView用法总结","slug":"72iOS中UIImageView用法总结","date":"2015-06-02T16:00:00.000Z","updated":"2021-06-29T08:04:47.244Z","comments":true,"path":"2015/06/03/72iOS中UIImageView用法总结/","link":"","permalink":"http://huishao.cc/2015/06/03/72iOS中UIImageView用法总结/","excerpt":"","text":"iOS中UIImageView用法总结- (instancetype)initWithImage:(UIImage *)image; 通过一个图片UIImage对象进行初始化 - (instancetype)initWithImage:(UIImage )image highlightedImage:(UIImage )highlightedImage; 通过一个正常状态下的图片和高亮状态下的图片初始化对象 @property(nonatomic,retain) UIImage *image; 设置正常状态下的图片 @property(nonatomic,retain) UIImage *highlightedImage; 设置高亮状态下的图片 @property(nonatomic,getter=isUserInteractionEnabled) BOOL userInteractionEnabled; 设置是否开启用户交互 @property(nonatomic,getter=isHighlighted) BOOL highlighted; 设置是否为高亮状态 @property(nonatomic,copy) NSArray *animationImages; 设置正常状态下的动画图片数组 @property(nonatomic,copy) NSArray *highlightedAnimationImages; 设置高亮状态下的动画图片数组 @property(nonatomic) NSTimeInterval animationDuration; 设置动画播放时长 默认频率为30帧每秒 @property(nonatomic) NSInteger animationRepeatCount; 设置动画循环播放次数 默认为无限循环 - (void)startAnimating; 开始播放帧动画 - (void)stopAnimating; 停止播放帧动画 - (BOOL)isAnimating; 是否正在播放动画 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"获取iOS应用的URL Schemes","slug":"71获取iOS应用的URL Schemes","date":"2015-06-01T16:00:00.000Z","updated":"2021-06-29T08:00:08.638Z","comments":true,"path":"2015/06/02/71获取iOS应用的URL Schemes/","link":"","permalink":"http://huishao.cc/2015/06/02/71获取iOS应用的URL Schemes/","excerpt":"","text":"获取任意App的系统配置文件这是一个小技巧，无需设备越狱，可以获取到任意App系统配置文件。 1、在mac上的AppStore商店搜索相应App。 2、下载获取此App。 3、打开iTunes，查看应用程序，选中相应的应用程序点击右键，选择在Finder中显示，然后解压ipa文件，得到一个文件夹。 4、进入文件夹，找到扩展名为app的文件，右键选择显示包内容。info.plist文件就在里面。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS系统关于URL Schemes的漏洞探究","slug":"70iOS系统关于URL Schemes的漏洞探究","date":"2015-06-01T16:00:00.000Z","updated":"2021-06-29T07:51:09.032Z","comments":true,"path":"2015/06/02/70iOS系统关于URL Schemes的漏洞探究/","link":"","permalink":"http://huishao.cc/2015/06/02/70iOS系统关于URL Schemes的漏洞探究/","excerpt":"","text":"iOS系统关于URL Schemes的漏洞探究一、何为URL Schemes我想这个东西的设计的目的是为了方便App之间的相互调用与通讯，你可以在自己的App中使用OpenURL方法来唤起其他的App。比如微信的URL Schemes是wiexin，我们新建一个工程，实现如下代码后运行程序： 1[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;weixin://]]; 这时你会发现，你的应用启动后很快就调起了微信的客户端。 二、由URL Schemes引发的漏洞的根源1、一个小问题引起的漏洞根源如上所说，通过URL Schemes可以在应用间相互唤起，而产生漏洞的根源在于这个URL并非是应用唯一的。apple并没有任何限制或者审核这个URL的任何措施，也就是说，如果两个App有着相同的URL Schemes，那么系统唤起的App可能并不是你想唤起的。 2、URL Schemes的优先级如何确定由于相同的URL Scheme可能同时被多个App使用，再如果这些App都安装在了同一个设备上，那么系统究竟会唤起哪一个呢？这个我也不能十分的确定，只有一点可以肯定：如果有和系统应用的URL Scheme相同，那么系统一定会唤起系统自己的应用，在这里系统的应用有着最高的优先级（苹果这里做的好像很不厚道，将自己的应用保护了起来，而把广大其他开发者的应用放在漏洞前置之不理）。如果没有和系统耦合的，那么系统会唤起哪一个App就看运气了。不过，这也不是无章可循，经过测试，优先级和App的Bundle identifier有关，更准确说和Bundle identifier的字母排序有关，如果精心设计这个id，我们就可以做到截获其他应用的URL。 3、这个漏洞会引发什么问题么？仅仅通过上面的叙述，你可能还看不出这个漏洞会引发什么样的后果。可是如果你仔细观察，你会发现，各种iPhone上的第三方调用，例如QQ音乐快捷登录，腾讯的各种游戏，甚至包括调用支付宝钱包的支付功能，都是通过这样的原理实现的。如果这些回调的数据被截获，那么就等于说登录信息，用户信息甚至支付订单信息都会暴漏在他人眼下，对于截获者来说，他可以用你的信息进行登录，可以替你完成支付，也可以盗取你登陆后的用户信息。 三、利用URL Scheme漏洞进行远程登录下面，就用一个实例来演示一下我如何通过一个伪装App登录天天炫斗账号。 天天炫斗是腾讯的一款十分火爆的格斗游戏，像其他腾讯游戏一样，支持QQ和微信登录，这里我拿微信登录为例。 首先，我们需要做一个伪装的App来截取用户的登录信息，新建一个项目，在plist文件中添加一个和天天炫斗微信登录相同的URL Scheme： 这里的wx63124814f356e266就是微信登录天天炫斗的URL Scheme，这里将Bundle id设置为A，使它有比天天炫斗更高的优先级。 在AppDelegate中添加如下代码： 1234-(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; NSLog(@&quot;%@&quot;,url); return YES;&#125; 这个函数是在App被通过URL唤起时首先调用的函数，这里传入的URL就是用户的登录验证信息，我们可以在这里将这个信息发送回来。 将伪装好的程序跑一遍后，运行天天炫斗，然后使用微信登录，会发现在微信验证成功后跳转后并没有跳转回天天炫斗应用，而是跳转到了我们伪装的这个Demo。这时xcode调试区会打印出如下的信息： 之后，来开始做我们的侵入程序，这个其实更加简单，新建一个工程，只需要添加一行代码： 1[[UIApplication sharedApplication]openURL:[NSURL URLWithString:@&quot;wx63124814f356e266://oauth?code=0118aa2f2b99d8a9e0e76a7176b2bd4E&amp;state=weixin&quot;]]; 这里的URL就是我们截获的带参的URL，在另一个装有天天炫斗的手机上跑这个程序（在同一个手机上测试的话要将刚才的伪装App删去，不然它也会将我们的侵入程序一起骗了）。会发现登录天天炫斗成功，角色信息完全一致。 同样的做法，还可以远程登录QQ音乐，天天飞车等等各种通过微信，QQ，微博快捷登录的应用。 四、要战胜你的敌人，必须要了解你的敌人不了解apple为什么一直不对URL Scheme做限制，或许需要或许不需要。但是这一点建议总是好的：在你的App使用快捷登录的时候，最好同时将设备号或者某个本地保存的标志绑定，防止恶意的第三方借此获取用户的信息。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS界面布局之二——初识autolayout布局模型","slug":"69iOS界面布局之二——初识autolayout布局模型","date":"2015-05-31T16:00:00.000Z","updated":"2021-06-29T07:50:01.480Z","comments":true,"path":"2015/06/01/69iOS界面布局之二——初识autolayout布局模型/","link":"","permalink":"http://huishao.cc/2015/06/01/69iOS界面布局之二——初识autolayout布局模型/","excerpt":"","text":"iOS界面布局之二——初识autolayout布局模型一、引言 在上一篇博客中介绍了传统的布局方式：autoresizing。随着iphone型号的越来越多，屏幕的标准也更加多样化，通过autoresizing已经不能满足开发的需求，而进行两套布局或者动态代码控制又大大增加了开发者的工作量，autolayout的出现拯救个这一切，它让动态布局变的十分简单便捷。 autoresizing介绍：[http://my.oschina.net/u/2340880/blog/423357](http://my.oschina.net/u/2340880/blog/423357)。 二、autolayout的设计思想正如storyboard的设计目的是为了让开发者将更多的精力投入到逻辑实现而不是界面布局一样。autolayout的设计思想是让开发者将布局上更多的精力放在控件关系上而不是坐标。我们只需要关心控件之间的摆放关系，而并不需要关心这是如何实现的。因此你使用autolayout进行布局时，就是在添加一个一个的约束。控件与控件之间的约束，控件与父视图之间的约束。 1、了解几种约束点击xcode的storyboard文件，在xcode的导航栏上点击Edito，然后选择Pin，可以看到如图，其中是可以添加的约束类型。 Width：对视图宽度的约束 Height：对视图高度的约束 Horizontal Spacing：对视图间水平距离的约束 Vertical Spacing：对视图间垂直距离的约束 Leading Space to Superview：与父视图左边界的约束 Trailing Space to Superview：与父视图右边界的约束 Top Space to Superview：与父视图上边界的约束 Bottom Space to Superview：与父视图下边界的约束 Widehs Equally：视图等宽约束 Heights Equally：视图等高约束 2、网上的一个很简单的约束例子了解了上面的几种约束，现在我们来实现一个效果，借用网上关于autolayout自动布局的一个小例子。我们在storyboard中拖入三个label，使它们如下效果： 然后我们将屏幕横过来，会发现这时的效果并不是我们想得到的结果： 在进行添加约束之前，我们先来理清这三个视图之间的关系，将上面两个视图编号为1.2，下面那个视图编号为3. （1）1和2的宽和高相等 （2）1距离父视图左边20px （3）2距离父视图右边20px （4）3距离父视图左边20px，右边20px （5）1和2水平间距20px （6）1与3垂直间距20px （7）1和2距离父视图上边距50px （8）3距离父视图下边距20px （9）3与1和2的高度一样 通过上面的约束，所有视图的位置都将被相对的固定，下面我们只需要按照顺序一一添加即可。 （1）选中1和2视图（按住cmd键可以多选），然后点击Editor-&gt;Pin之后选择Widehs Equally，重复上面的过程，选择Heights Equally。我们会看到如下的效果： 几点注意： *线是橙色代表警告，我们没有添加足够的约束来确定位置或者约束有矛盾。 *如果线的中间显示的不是等号，而是数字，则是因为视图1和2的尺寸设置的不等，约束有矛盾。 （2）选中1.重复上面步骤，选择Leading Space to Superview。这时1的左边又会增加一条线： 点击这条线，在右边的设置去将约束值设置为20： （3）重复上面步骤，选中视图2，添加Trailing Space to Superview约束。 （4）选中视图3，重复上面步骤。 （5）选中1和2，添加Horizontal Spacing，设置为20. （6）选中1和3，添加Vertical Spacing，设置为20. （7）为1和2分别添加Top Space to Superview约束。 （8）为3添加Bottom Space to Superview约束。 （9）选中1和3，添加Heights Equally约束。 上面的过程虽然繁琐，但是逻辑性十分清晰，这时你会发现所有的线都变成了蓝色，约束已经添加完整，我们再次运行后横屏，效果如下： 这就是我们想要的结果了。 3、自动布局的几种对其方式在xcode导航的Editor菜单中，还有一个子菜单，Align，这里面的选项可以为控件添加对其约束： Left Edges：控件左对齐 Right Edges：控件右对齐 Top Edges：控件上对齐 Bottom Edges：控件下对齐 Horizontal Centers：控件水平中心对齐 Vertical Centers：控件垂直水平对齐 Horizontal Center in Container：控件与其父视图水平中心对齐 Vertical Center in Container：控件与其父视图垂直中心对齐 三、几点小感悟到此为止，基本上已经可以使用autolayout自动布局解决复杂的布局需求了，但是切记，正式因为aotulayout的强大使它会隐藏更多的坑，下面是我的几点感悟，再次分享： 1、autolayout的精髓在于足够多的约束，autolayout之所以比autoresizing强大，就在于其布局的精确性，而精确性正是由约束来提供的。 2、切莫画蛇添足，矛盾的约束会使xcode晕掉，所以在添加约束前，我建议将试图间的布局关系先整理出来。 3、应该转变你的思路，如果你已经习惯了使用CGRect、Point等传统的坐标布局模式，那么你应该稍微转变一下，autolayout倡导的是一个相对的概念，你需要将更多的关注放在视图间的关系，比如A和B距离10，A和C右对齐等。具体的坐标会有autolayout帮你算。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS界面布局之一——使用autoresizing进行动态布局","slug":"68iOS界面布局之一——使用autoresizing进行动态布局","date":"2015-05-31T16:00:00.000Z","updated":"2021-06-29T07:46:40.535Z","comments":true,"path":"2015/06/01/68iOS界面布局之一——使用autoresizing进行动态布局/","link":"","permalink":"http://huishao.cc/2015/06/01/68iOS界面布局之一——使用autoresizing进行动态布局/","excerpt":"","text":"iOS界面布局之一——使用autoresizing进行动态布局autoresizing是iOS中传统的界面自动布局方式，通过它，当父视图frame变换时，子视图会自动的做出相应的调整。 一、通过代码进行布局任何一个view都有autoresizingMask这个属性，通过这个属性可以设置当前view与其父视图的相对关系。我们先来看UIViewAutoresizing这个枚举： 123456789typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123; UIViewAutoresizingNone = 0,//默认 UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,//与父视图右边间距固定，左边可变 UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,//视图宽度可变 UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,//与父视图左边间距固定，右边可变 UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3,//与父视图下边间距固定，上边可变 UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4,//视图高度可变 UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5//与父视图上边间距固定，下边可变&#125;; 下面我们通过效果来看这些属性的作用： 先创建两个view，为了区分，设置不同的背景色： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(20, 40, 200, 200)]; view1.backgroundColor=[UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(10, 10, 100, 100)]; view2.backgroundColor=[UIColor greenColor]; [view1 addSubview:view2]; [self.view addSubview:view1];&#125; 设置view2的自动布局属性如下： 1 view2.autoresizingMask=UIViewAutoresizingFlexibleBottomMargin; 这时的效果如下： 改变view1的frame如下： 1UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(20, 40, 300, 300)]; 效果如下： 这时view2的下边距离相对父视图是可变的。 设置如下： 1 view2.autoresizingMask=UIViewAutoresizingFlexibleHeight; 效果如下： 可以看出，这时子视图的高度是随父视图变化而自动改变的。 如下设置： 1view2.autoresizingMask=UIViewAutoresizingFlexibleLeftMargin; 效果如下： 这时子视图的左边是随父视图变化而可变的。 同理，UIViewAutoresizingFlexibleRightMargin将使子视图右边与父视图的距离可变。 UIViewAutoresizingFlexibleTopMargin将使子视图上边与父视图距离可变。UIViewAutoresizingFlexibleWidth将使子视图的宽度可变。 注意：这些自动布局的属性是可以叠加的，比如保持视图与父视图边距不变，如下设置： 1view2.autoresizingMask=UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight; 效果如下： 二、nib文件中可视化设置自动布局在storyboard中我们可以更加轻松的进行autoresizing自动布局。在view设置栏中有autoresizing这个设置，点中相应的箭头，就是刚才我们探讨的设置选项。并且我们把鼠标放在这个上面的时候，右侧会自动为我们预览效果。 如果你觉得autoresizing很强大，那么你就太容易满足了，autoresizing可以满足大部分简单的自动布局需求，可是它有一个致命的缺陷，它只能设置子视图相对于父视图的变化，却不能精确这个变化的度是多少，因此对于复杂的精准的布局需求，它就力不从心了。但是有一个好消息告诉你，iOS6之后的autolayout自动布局方案，正是解决复杂布局的好帮手，我们在下一遍博客中再进行详细讨论。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS开发音频播放基础——AVAudioPlayer的应用","slug":"66iOS开发音频播放基础——AVAudioPlayer的应用","date":"2015-05-25T16:00:00.000Z","updated":"2021-06-29T07:04:17.883Z","comments":true,"path":"2015/05/26/66iOS开发音频播放基础——AVAudioPlayer的应用/","link":"","permalink":"http://huishao.cc/2015/05/26/66iOS开发音频播放基础——AVAudioPlayer的应用/","excerpt":"","text":"iOS音频开发——AVAudioPlayer应用AVAudioPlayer是系统提供给我们的一个音频播放类，在AVFoundation框架下，通过它，我们可以实现一个功能强大的音乐播放器。首先，在项目中我们需要导入AVFoundation这个框架。 一、AVAudioPlayer方法与属性详解初始化方法有两种，通过音频的路径或者音频data数据初始化player对象 12- (instancetype)initWithContentsOfURL:(NSURL *)url error:(NSError **)outError;- (instancetype)initWithData:(NSData *)data error:(NSError **)outError; 注意：支持的音频格式有:AAC,ALAC,HE-AAC,iLBC,IMA4,MP3. 准备播放音频，返回值标志是否解析成功，是否可以播放。 1- (BOOL)prepareToPlay; 开始播放音频 1- (BOOL)play; 在一段时间间隔后播放 1- (BOOL)playAtTime:(NSTimeInterval)time; 暂停播放，并且准备好继续播放 1- (void)pause; 停止播放，不再准备好继续播放 1- (void)stop; 获取是否正在播放 1@property(readonly, getter=isPlaying) BOOL playing; 获取当前音频声道数 1@property(readonly) NSUInteger numberOfChannels; 获取当前音频时长 1@property(readonly) NSTimeInterval duration; 获取创建时的音频路径 1@property(readonly) NSURL *url; 获取创建时的音频数据 1@property(readonly) NSData *data; 设置声道偏移量，0为中心，-1为只有左声道，1为只有右声道 1@property float pan; 设置音频音量，取值为0-1之间 1@property float volume; 设置是否可以改变播放速度 1@property BOOL enableRate; 注意:设置这个属性前必须先调用prepareToPlay这个方法。 设置播放速度，1为正常，0.5为一半速度，2.0为2倍速度 1@property float rate; 设置当前播放的时间点 1@property NSTimeInterval currentTime; 设置音频播放循环次数 1@property NSInteger numberOfLoops; 获取音频设置字典 1@property(readonly) NSDictionary *settings; 是否开启仪表计数功能 1@property(getter=isMeteringEnabled) BOOL meteringEnabled; 更新仪表计数的值 1- (void)updateMeters; 获取指定声道音频峰值 1- (float)peakPowerForChannel:(NSUInteger)channelNumber; 获取指定声道音频平均值 1- (float)averagePowerForChannel:(NSUInteger)channelNumber; 二、AVAudioPlayerDelegate方法详解音频播放结束后调用的函数 1- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag; 播放遇到错误时调用的函数 1- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError *)error; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS后台音频播放及锁屏界面显示音频信息用","slug":"67iOS后台音频播放及锁屏界面显示音频信息","date":"2015-05-25T16:00:00.000Z","updated":"2021-06-29T07:45:33.360Z","comments":true,"path":"2015/05/26/67iOS后台音频播放及锁屏界面显示音频信息/","link":"","permalink":"http://huishao.cc/2015/05/26/67iOS后台音频播放及锁屏界面显示音频信息/","excerpt":"","text":"iOS后台播放音乐及用户交互处理后台播放是任何一个音频软件都支持的功能，在上一篇博客中，详细介绍了使用AVAudioPlayer播放音频的方法，这篇博客将对后台的处理做介绍，关于播放与设置音频的博客地址：http://my.oschina.net/u/2340880/blog/420129。 一、设置后台播放iOS设置后台音频播放的步骤非常简单，首先需要在系统设置的plist文件中添加一个键Required background modes，值为App plays audio or streams audio/video using AirPlay，如下： 然后进行如下代码设置： 123 AVAudioSession *session = [AVAudioSession sharedInstance]; [session setActive:YES error:nil]; [session setCategory:AVAudioSessionCategoryPlayback error:nil]; 此时播放音频时我们点击HOME回到主页面，会发现音频不会停，已经实现后台播放的功能。 二、设置后台用户交互在appDelegate中，我们需要先注册响应后台控制： 1[[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; 然后在appDelegate中我们实现如下函数处理后台传递给我们的信息： 12345-(void)remoteControlReceivedWithEvent:(UIEvent *)event&#123; if (event.type==UIEventTypeRemoteControl) &#123; NSLog(@&quot;%ld&quot;,event.subtype); &#125;&#125; event中的subtype是操作类型，我们打开系统桌面抽屉，可以看到如下的控制键： subtype中的枚举便是点击这些控制键后传递给我们的消息，我们可以根据这些消息在app内做逻辑处理。枚举如下，其中只有100之后的在音频控制中对我们有效： 12345678910111213141516171819202122232425262728typedef NS_ENUM(NSInteger, UIEventSubtype) &#123; // available in iPhone OS 3.0 UIEventSubtypeNone = 0, // for UIEventTypeMotion, available in iPhone OS 3.0 UIEventSubtypeMotionShake = 1, //这之后的是我们需要关注的枚举信息 // for UIEventTypeRemoteControl, available in iOS 4.0 //点击播放按钮或者耳机线控中间那个按钮 UIEventSubtypeRemoteControlPlay = 100, //点击暂停按钮 UIEventSubtypeRemoteControlPause = 101, //点击停止按钮 UIEventSubtypeRemoteControlStop = 102, //点击播放与暂停开关按钮(iphone抽屉中使用这个) UIEventSubtypeRemoteControlTogglePlayPause = 103, //点击下一曲按钮或者耳机中间按钮两下 UIEventSubtypeRemoteControlNextTrack = 104, //点击上一曲按钮或者耳机中间按钮三下 UIEventSubtypeRemoteControlPreviousTrack = 105, //快退开始 点击耳机中间按钮三下不放开 UIEventSubtypeRemoteControlBeginSeekingBackward = 106, //快退结束 耳机快退控制松开后 UIEventSubtypeRemoteControlEndSeekingBackward = 107, //开始快进 耳机中间按钮两下不放开 UIEventSubtypeRemoteControlBeginSeekingForward = 108, //快进结束 耳机快进操作松开后 UIEventSubtypeRemoteControlEndSeekingForward = 109,&#125;; 三、设置后台信息显示及锁屏界面设置设置锁屏界面显示信息的原理是通过设置一个系统的字典，当音频开始播放时，系统会自动从这个字典中读取要显示的信息，如果需要动态显示，我们只需要不断更新这个字典即可。首先需要添加&lt;MediaPlayer/MediaPlayer.h&gt;这个头文件。 代码示例如下： 1234567891011121314151617 NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; //设置歌曲题目 [dict setObject:@&quot;题目&quot; forKey:MPMediaItemPropertyTitle]; //设置歌手名 [dict setObject:@&quot;歌手&quot; forKey:MPMediaItemPropertyArtist]; //设置专辑名 [dict setObject:@&quot;专辑&quot; forKey:MPMediaItemPropertyAlbumTitle]; //设置显示的图片 UIImage *newImage = [UIImage imageNamed:@&quot;43.png&quot;]; [dict setObject:[[MPMediaItemArtwork alloc] initWithImage:newImage] forKey:MPMediaItemPropertyArtwork]; //设置歌曲时长 [dict setObject:[NSNumber numberWithDouble:300] forKey:MPMediaItemPropertyPlaybackDuration]; //设置已经播放时长 [dict setObject:[NSNumber numberWithDouble:150] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; //更新字典 [[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:dict]; 效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美八——网页框架","slug":"65标签之美八——网页框架","date":"2015-05-24T16:00:00.000Z","updated":"2021-06-29T01:59:00.691Z","comments":true,"path":"2015/05/25/65标签之美八——网页框架/","link":"","permalink":"http://huishao.cc/2015/05/25/65标签之美八——网页框架/","excerpt":"","text":"标签之美——网页框架的应用一、框架集框架集用来设置框架的属性，修饰框架的总体效果。 1、框架宽度cols属性用来设置框架的宽度，示例如下： 12345678&lt;body&gt;&lt;frameset cols=&quot;30%,30%,30%,10%&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 其中属性设置的值可以是百分比，可以是固定值，*符号表示除了已经分配后的剩余空间。上面代码中每个html文件设置不同的背景颜色，效果如下： 2、框架高度使用rows属性可是设置框架的高度。其用法和cols属性类似，示例如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 注意：宽度和高度这两个属性，不能同时使用，只能二选一。 3、边框宽度可以通过border属性设置框架边框的宽度，如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot; border=&quot;10&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 4、边框颜色和其他属性类似，通过bordercolor可以设置边框的颜色。 5、设置是否显示边框通过设置frameborder可以显示和隐藏边框，其值可取0或者1。隐藏效果如下： 12345678&lt;body&gt;&lt;frameset rows=&quot;30%,30%,30%,10%&quot; frameborder=&quot;0&quot;&gt;&lt;frame src=&quot;1.html&quot;&gt;&lt;frame src=&quot;2.html&quot;&gt;&lt;frame src=&quot;3.html&quot;&gt;&lt;frame src=&quot;4.html&quot;&gt;&lt;/frameset&gt;&lt;/body&gt; 二、框架框架和框架集是可以嵌套的。可以在一个框架中继续嵌套框架集。 1、设置框架大小不可调节使用的框架，默认当鼠标点击拉动时是可以调节大小的，可以设置nosize=”nosize”来设置不可调节。 2、设置框架的滚动条scrolling属性可以设置框架是否显示滚动条,可以设置yes或者no。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS多线程编程之三——GCD的应用","slug":"64iOS多线程编程之三——GCD的应用","date":"2015-05-20T16:00:00.000Z","updated":"2021-06-29T01:57:52.855Z","comments":true,"path":"2015/05/21/64iOS多线程编程之三——GCD的应用/","link":"","permalink":"http://huishao.cc/2015/05/21/64iOS多线程编程之三——GCD的应用/","excerpt":"","text":"iOS多线程编程之三——GCD的应用一、引言在软件开发中使用多线程可以大大的提升用户体验度，增加工作效率。iOS系统中提供了多种分线程编程的方法，在前两篇博客都有提及： NSThread类进行多线程编程：http://my.oschina.net/u/2340880/blog/416524。 NSOperation进行多线程操作编程：http://my.oschina.net/u/2340880/blog/416782。 上两个进行多线程编程的机制都是封装于Object-C的类与方法。这篇博客将讨论的Grand Central Dispatch(GCD)机制，则是基于C语言的，相比上面两种机制，GCD更加高效，并且线程有系统管理，会自动运用多核运算。因为这些优势，GCD是apple推荐我们使用的多线程解决方案。 二、GCD的调度机制GCD机制中一个很重要的概念是调度队列，我们对线程的操作实际上是由调度队列完成的。我们只需要将要执行的任务添加到合适的调度队列中即可。 1、调度队列的类型调度队列有三种类型： （1）主队列 其中的任务在主线程中执行，因为其会阻塞主线程，所以这是一个串行的队列。可以通过dispatch_get_main_queue()方法得到。 （2）全局并行队列 队列中任务的执行方式是严格按照先进先出的模式进行了。如果是串行的队列，则当一个任务结束后，才会开启另一个任务，如果是并行队列，则任务的开启顺序是和添加顺序一致的。系统为iOS应用自动创建了四个全局共享的并发队列。使用如下函数获得： dispatch_get_global_queue(long identifier, unsigned long flags); 其中第一个参数是这个队列的id，系统的四个全局队列默认的优先级不同，这个参数可填的定义如下： 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2//优先级最高的全局队列#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0//优先级中等的全局队列#define DISPATCH_QUEUE_PRIORITY_LOW (-2)//优先级低的全局队列#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN//后台的全局队列 优先级最低 这个函数的第二个参数，按照官方文档的说法是有待未来使用，现在我们都填0即可。 （3）自定义队列 上面的两种队列都是系统为我们创建好的，我们只需要获取到他们，将任务添加即可。当然，我们可可以创建我们自己的队列，包括串行的和并行的。使用如下方法创建： 1dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL); 其中，第一个参数是这个队列的名字，第二个参数决定创建的是串行的还是并行的队列。填写DISPATCH_QUEUE_SERIAL或者NULL创建串行队列，填写DISPATCH_QUEUE_CONCURRENT创建并行队列。 2、添加任务到队列中使用dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)函数或者dispatch_async(dispatch_queue_t queue, dispatch_block_t block)函数来同步或者异步的执行任务，示例如下： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; NSLog(@&quot;%@:1&quot;,[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;%@:2&quot;,[NSThread currentThread]); &#125;);&#125; 打印结果如下： 可以看出第一个任务在主线程中执行，第二个在分线程中执行。 三、队列调度机制的更多技巧通过上面的演示，我们已经可以运用队列进行多线程的执行任务，但是GCD的强大之处远远不止如此。 1、使用队列组如果有这样三个任务，A与B是没有关系的，他们可以并行执行，C必须在A,B结束之后才能执行，当然，实现这样的逻辑并不困难，使用KVO就可以实现，但是使用队列组处理这样的逻辑，代码会更加清晰简单。 可以使用dispatch_group_create()创建一个队列组，使用如下函数将队列添加到队列组中： 123void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 队列组中的队列是异步执行的，示例如下： 1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个队列组 dispatch_group_t group=dispatch_group_create(); 创建一个异步队列 dispatch_queue_t queue=dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); //阻塞线程直到队列任务完成 dispatch_group_wait(group,DISPATCH_TIME_FOREVER); for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;over:%d&quot;,i); &#125;&#125; 打印出来的信息如下： 可以看出，队列中的任务是异步执行的，并且等待队列组中队列任务全部执行后才执行后面的任务。这样的做法在实际应用中我们很少使用，通常我们会把后续的任务在放在异步中执行，做法如下： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个队列组 dispatch_group_t group=dispatch_group_create(); //创建一个队列 dispatch_queue_t queue=dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); //添加队列任务到队列组 dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); dispatch_group_async(group, queue, ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@:%d&quot;,[NSThread currentThread],i); &#125; &#125;); //队列组任务执行完后执行的任务 dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;over:%d&quot;,i); &#125; &#125;); for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;Finish:%d&quot;,i); &#125; &#125; 打印信息如下： 可以看出GCD的强大了吧，复杂的任务逻辑关系因为GCD变得十分清晰简单。 2、循环机制一开始我们就提到，GCD相比NSOperation的优势在于多核心的应用，更深得挖掘出了硬件的性能。GCD在多核方面的一个明显的特点就是循环机制。 123 dispatch_apply(10, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t i) &#123; NSLog(@&quot;%@:%zu&quot;,[NSThread currentThread],i); &#125;); 打印结果如下： 可以看出，程序的运行效率又会高许多。 3、消息传递机制dispatch_source_t类型的对象可以用来传递和接受某个消息，然后执行block方法，示例如下： 123456789101112131415- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个数据对象，DISPATCH_SOURCE_TYPE_DATA_ADD的含义表示数据变化时相加 dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue()); //创建接收数据变化的句柄 dispatch_source_set_event_handler(source, ^&#123; NSLog(@&quot;%lu&quot;,dispatch_source_get_data(source)); &#125;); //启动 dispatch_resume(source); //设置数据 dispatch_source_merge_data(source, 1); //这步执行完之后会执行打印方法&#125; 4、发送和等待信号GCD中还有一个重要的概念是信号量。它的用法法消息的传递有所类似，通过代码来解释： 1234567 //创建一个信号，其中的参数为信号的初始值 dispatch_semaphore_t singer = dispatch_semaphore_create(0); //发送信号，使信号量+1 dispatch_semaphore_signal(singer); //等待信号，当信号量大于0时执行后面的方法，否则等待，第二个参数为等待的超时时长，下面设置的为一直等待 dispatch_semaphore_wait(singer, DISPATCH_TIME_FOREVER); NSLog(@&quot;123&quot;); 通过发送信号，可以试信号量+1，每次执行过等待信号后，信号量会-1；如此，我们可以很方便的控制不同队列中方法的执行流程。 5、挂起和开启任务队列GCD还提供了暂停与开始任务的方法，使用 void dispatch_suspend(dispatch_object_t object); 可以将队列或者队列组进行暂时的挂起，使用 void dispatch_resume(dispatch_object_t object); 将队列或者队列组重新开启。 需要注意的是，暂停队列时，队列中正在执行的任务并不会被中断，会挂起未开启的任务。 四、关于内存管理GCD虽然是基于C语言封装的框架，使用了面向对象的思想。因此，它的内存管理是需要我们注意的，不论是ARC或者MRC，我们都应该手动去处理这些对象。还好，GCD的内存管理思路和Object—C是兼容的，我们使用dispatch_retain()和dispatch_release()来将引用对象的计数进行加减。这一点十分重要，切记切记。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美七——为网页添加音乐","slug":"63标签之美七——为网页添加音乐","date":"2015-05-19T16:00:00.000Z","updated":"2021-06-29T01:56:51.181Z","comments":true,"path":"2015/05/20/63标签之美七——为网页添加音乐/","link":"","permalink":"http://huishao.cc/2015/05/20/63标签之美七——为网页添加音乐/","excerpt":"","text":"标签之美——为网页添加音乐一、添加音乐为网页添加音乐可以使用这个标签。其用法和插入图片类似。 标签的几个属性设置如下： src：音频路径 autostart：可是设置为ture或者false，代表是否自动播放。 loop：设置是否循环播放 hidden：是否隐藏播放界面 二、插入背景音乐使用标签插入背景音乐，其中插入路径的写法和插入图片类似。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS多线程编程之二——NSOperation与NSOperationQueue","slug":"62iOS多线程编程之二——NSOperation与NSOperationQueue","date":"2015-05-18T16:00:00.000Z","updated":"2021-06-29T01:55:36.085Z","comments":true,"path":"2015/05/19/62iOS多线程编程之二——NSOperation与NSOperationQueue/","link":"","permalink":"http://huishao.cc/2015/05/19/62iOS多线程编程之二——NSOperation与NSOperationQueue/","excerpt":"","text":"iOS多线程编程之二——NSOperation与NSOperationQueue一、NSOperation解析NSOperation是基于Objective-C封装的一套管理与执行线程操作的类。这个类是一个抽象类，通常情况下，我们会使用NSInvocationOperation和NSBlockOperation这两个子类进行多线程的开发，当然我们也可以写继承于NSOperation的类，封装我们自己的操作类。 1、NSOperation抽象类中提供的逻辑方法操作开始执行 1- (void)start; 在子类中可以重写这个方法，实现执行的方法 1- (void)main; 取消执行 1- (void)cancel; 获取当操作状态的几个属性 12345@property (readonly, getter=isCancelled) BOOL cancelled;//当前操作是否取消执行@property (readonly, getter=isExecuting) BOOL executing;//当前操作是否正在执行@property (readonly, getter=isFinished) BOOL finished;//当前操作是否执行结束@property (readonly, getter=isAsynchronous) BOOL asynchronous;//当前操作是否在异步线程中@property (readonly, getter=isReady) BOOL ready;//当前操作是否已经准备好 阻塞当前线程直到操作完成 1- (void)waitUntilFinished; 设置在操作队列中的优先级 1@property NSOperationQueuePriority queuePriority; 其中NSOperationQueuePriority的枚举如下： 1234567typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L,//优先级很低 NSOperationQueuePriorityLow = -4L,//优先级低 NSOperationQueuePriorityNormal = 0,//优先级普通 NSOperationQueuePriorityHigh = 4,//优先级高 NSOperationQueuePriorityVeryHigh = 8//优先级非常高&#125;; 设置操作完成后的回调block 1@property (copy) void (^completionBlock)(void); 设置操作的优先级 1@property double threadPriority; 设置操作的名称 1@property (copy) NSString *name; 2、带block的操作类实例——NSBlockOperationNSBlockOperation是NSOperation的一个子类，其可以异步的执行多个block，当所有的block都完成时，这个操作才算完成。 初始化方法： 1+ (instancetype)blockOperationWithBlock:(void (^)(void))block; 在操作中添加block 1- (void)addExecutionBlock:(void (^)(void))block; 添加进去的block的数组 1@property (readonly, copy) NSArray *executionBlocks; 示例如下： 1234567891011NSBlockOperation * opera = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;]; [opera addExecutionBlock:^&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;]; [opera start]; 打印情况如下，可以看出，两个block块的执行是异步的： 3、使用NSInvocationOperation调用方法根据选择器创建一个对象 1- (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(id)arg; 通过Invocation创建一个对象 1- (instancetype)initWithInvocation:(NSInvocation *)inv; 这个类执行的操作是与调用它的线程同步的，示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSInvocationOperation * operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(log) object:nil]; [operation start]; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125; &#125;-(void)log&#123; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 通过打印结果可以看出其执行的同步性。 二、操作之间的依赖关系依赖关系和优先级的作用很像，却也不同。如果一个操作A依赖于另一个操作B，那么只有当B操作完成后，A操作才会执行。操作添加依赖的 添加一个依赖： 1- (void)addDependency:(NSOperation *)op; 删除一个依赖 1- (void)removeDependency:(NSOperation *)op; 原则上说，一个操作对象的依赖可以添加多个，并且当所有依赖都执行完成后才会执行这个操作。 三、NSOperationQueue操作队列NSOperationQueue是操作队列类，通过上面的介绍，我们已经可以理解操作，并且操作默认的执行方式是串行的，尽管NSBlockOperation中的block块间是并行执行的，但其和外部操作依然是串行的。如果将操作放入操作队列中，则默认为并行执行的。 示例如下： 12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. NSOperationQueue * queue = [[NSOperationQueue alloc]init]; NSInvocationOperation * op1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(log) object:nil]; [queue addOperation:op1]; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125;-(void)log&#123; for (int i=0; i&lt;10; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 打印信息如下： 可以看出来，队列的操作是在一个新的线程中执行的，并且操作队列之中的操作也都是异步执行的。 在操作队列中添加一个操作任务： 1- (void)addOperation:(NSOperation *)op; 在队列中插入一组操作任务，后面的参数设置是否队列中得任务都执行完成后再执行这一组操作： 1- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 在队列中添加一个block操作 1- (void)addOperationWithBlock:(void (^)(void))block; 获取操作队列中的所有操作的数组 1@property (readonly, copy) NSArray *operations; 获取操作队列中操作的个数 1@property (readonly) NSUInteger operationCount; 设置队列最大并行操作数量 1@property NSInteger maxConcurrentOperationCount; 设置是否暂停队列任务执行 1@property (getter=isSuspended) BOOL suspended; 设置队列名字 1@property (copy) NSString *name; 设置队列的优先级别（iOS8后支持） 1@property NSQualityOfService qualityOfService; 取消队列中所有操作任务 1- (void)cancelAllOperations; 阻塞当前线程，直到队列中所有任务完成 1- (void)waitUntilAllOperationsAreFinished; 获取当前执行的队列 1+ (NSOperationQueue *)currentQueue; 获取主线程中的操作队列 1+ (NSOperationQueue *)mainQueue; 四、队列中操作的执行顺序法则1、决定于依赖关系，只有当这个操作的依赖全部执行完成后，它才会被执行。 2、影响于优先级，优先级高的会先执行。 如有疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS多线程编程之一——NSThread线程管理","slug":"61iOS多线程编程之一——NSThread线程管理","date":"2015-05-18T16:00:00.000Z","updated":"2021-06-28T12:09:56.310Z","comments":true,"path":"2015/05/19/61iOS多线程编程之一——NSThread线程管理/","link":"","permalink":"http://huishao.cc/2015/05/19/61iOS多线程编程之一——NSThread线程管理/","excerpt":"","text":"iOS多线程编程之一——NSThread线程管理NSTread是iOS中进行多线程开发的一个类，其结构逻辑清晰，使用十分方便，但其封装度和性能不高，线程周期，加锁等需要手动处理。 一、NSThread类方法总结获取当前线程 1+ (NSThread *)currentThread; 这个方法通过开启一个新的线程执行选择器方法 1+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; 线程用法示例如下： 12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [NSThread detachNewThreadSelector:@selector(log) toTarget:self withObject:nil]; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125;-(void)log&#123; for (int i=0; i&lt;100; i++) &#123; NSLog(@&quot;%@=%d&quot;,[NSThread currentThread],i); &#125;&#125; 运行后的打印信息： 可以清晰的看出来，新启的线程和主线程是异步的。 程序是否是多线程执行 1+ (BOOL)isMultiThreaded; 线程字典，我们可以为特殊的线程设置键值对 1@property (readonly, retain) NSMutableDictionary *threadDictionary; 线程在某个时间执行 1+ (void)sleepUntilDate:(NSDate *)date; 线程在等待一个时间间隔后执行 1+ (void)sleepForTimeInterval:(NSTimeInterval)ti; 结束线程 1+ (void)exit; 设置线程的优先级，取值的范围为0-1，1的优先级最高 12+ (double)threadPriority;+ (BOOL)setThreadPriority:(double)p; 这个属性是iOS8之后的新特性，将优先级更人性化的封装了起来 1@property NSQualityOfService qualityOfService; NSQualityOfService的枚举如下： 123456789101112typedef NS_ENUM(NSInteger, NSQualityOfService) &#123; //刷新UI级别的线程 NSQualityOfServiceUserInteractive = 0x21, //用户请求的无需精确的任务的线程，例如点击加载邮件 NSQualityOfServiceUserInitiated = 0x19, //周期性的任务线程，例如定时刷新 NSQualityOfServiceUtility = 0x11, //后台任务的线程 NSQualityOfServiceBackground = 0x09, //优先级未知的线程，优先级介于UserInteractive和Utility之间 NSQualityOfServiceDefault = -1&#125;; 判断是否是主线程 1+ (BOOL)isMainThread; 获取主线程 1+ (NSThread *)mainThread; 二、属性与成员方法总结初始化方法，选择器可以带一个参数 1- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; 线程是否正在执行 1@property (readonly, getter=isExecuting) BOOL executing; 线程是否已经执行结束 1@property (readonly, getter=isFinished) BOOL finished; 线程是否已经取消执行 1@property (readonly, getter=isCancelled) BOOL cancelled; 三、隐式的通过NSThread进行多线程编程NSObject的一个类别中提供了支持多线程的方法，如下： 这个函数指定在主线程执行一个选择器，arg是参数，wait是是否立即执行，如果YES，则会阻塞当前主线程的任务，NO则会等待当前任务结束后执行。 1- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait; 这个函数指定在某个线程执行选择器 1- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; 指定在后台线程中执行选择器 1- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发进阶——使用导航和附近兴趣点检索","slug":"60iOS原生地图开发进阶——使用导航和附近兴趣点检索","date":"2015-05-17T16:00:00.000Z","updated":"2021-06-25T02:25:06.638Z","comments":true,"path":"2015/05/18/60iOS原生地图开发进阶——使用导航和附近兴趣点检索/","link":"","permalink":"http://huishao.cc/2015/05/18/60iOS原生地图开发进阶——使用导航和附近兴趣点检索/","excerpt":"","text":"iOS原生地图开发进阶——使用导航和附近兴趣点检索iOS中的mapKit框架对国际化的支持非常出色。在前些篇博客中，对这个地图框架的基础用法和标注与覆盖物的添加进行了详细的介绍，这篇博客将介绍两个更加实用的功能的开发：线路导航与兴趣点搜索。前几篇博客的链接如下： 地图基础用法详解：http://my.oschina.net/u/2340880/blog/415360。 添加大头针与自定义标注：http://my.oschina.net/u/2340880/blog/415441。 添加地图覆盖物：http://my.oschina.net/u/2340880/blog/415611。 一、线路导航1、从几个类的关系说起(1)MKPlacemark 一个地点信息类，如下： 1234567@interface MKPlacemark : CLPlacemark &lt;MKAnnotation&gt;//初始化方法，通过给定一个经纬度和地点信息字典- (instancetype)initWithCoordinate:(CLLocationCoordinate2D)coordinate addressDictionary:(NSDictionary *)addressDictionary;//国家编码@property (nonatomic, readonly) NSString *countryCode;@end (2)MKMapItem 地点节点类，包含此节点的许多地点信息，如下： 1234567891011121314151617@interface MKMapItem : NSObject//当前节点的地点信息对象@property (nonatomic, readonly) MKPlacemark *placemark;//是否是当前位置@property (nonatomic, readonly) BOOL isCurrentLocation;//节点名称@property (nonatomic, copy) NSString *name;//电话号码@property (nonatomic, copy) NSString *phoneNumber;//网址@property (nonatomic, strong) NSURL *url;//将当前位置创建为节点+ (MKMapItem *)mapItemForCurrentLocation;//由一个位置信息创建节点- (instancetype)initWithPlacemark:(MKPlacemark *)placemark;@end (3)MKDirectionsRequest 导航请求类 123456789@interface MKDirectionsRequest : NSObject//起点节点- (MKMapItem *)source NS_AVAILABLE(10_9, 6_0);- (void)setSource:(MKMapItem *)source NS_AVAILABLE(10_9, 7_0);//目的地节点- (MKMapItem *)destination NS_AVAILABLE(10_9, 6_0);- (void)setDestination:(MKMapItem *)destination NS_AVAILABLE(10_9, 7_0);@end 这个类还有一些扩展的设置属性： @property (nonatomic) MKDirectionsTransportType transportType; 设置路线检索类型，枚举如下： 12345typedef NS_OPTIONS(NSUInteger, MKDirectionsTransportType) &#123; MKDirectionsTransportTypeAutomobile = 1 &lt;&lt; 0,//适合驾车时导航 MKDirectionsTransportTypeWalking = 1 &lt;&lt; 1,//适合步行时导航 MKDirectionsTransportTypeAny = 0x0FFFFFFF//任何情况&#125;; @property (nonatomic) BOOL requestsAlternateRoutes; 设置是否搜索多条线路 @property (nonatomic, copy) NSDate *departureDate; 设置出发日期 @property (nonatomic, copy) NSDate *arrivalDate; 设置到达日期 （4）MKDirections 从apple服务器获取数据的连接类 123456789101112@interface MKDirections : NSObject//初始化方法- (instancetype)initWithRequest:(MKDirectionsRequest *)request NS_DESIGNATED_INITIALIZER;//开始计算线路信息- (void)calculateDirectionsWithCompletionHandler:(MKDirectionsHandler)completionHandler;//开始计算时间信息- (void)calculateETAWithCompletionHandler:(MKETAHandler)completionHandler;//取消- (void)cancel;//是否正在计算@property (nonatomic, readonly, getter=isCalculating) BOOL calculating;@end (5)MKDirectionsResponse 线路信息结果类 12345@interface MKDirectionsResponse : NSObject@property (nonatomic, readonly) MKMapItem *source;//起点@property (nonatomic, readonly) MKMapItem *destination;//终点@property (nonatomic, readonly) NSArray *routes; //线路规划数组@end (6)MKETResponse 时间信息结果类 123456@interface MKETAResponse : NSObject@property (nonatomic, readonly) MKMapItem *source;//起点@property (nonatomic, readonly) MKMapItem *destination;//终点@property (nonatomic, readonly) NSTimeInterval expectedTravelTime;//耗时@end (7)MKRoute 线路信息类，导航的线路结果是这个类型的对象 12345678910111213@interface MKRoute : NSObject@property (nonatomic, readonly) NSString *name; //线路名称@property (nonatomic, readonly) NSArray *advisoryNotices; //注意事项@property (nonatomic, readonly) CLLocationDistance distance; //距离@property (nonatomic, readonly) NSTimeInterval expectedTravelTime;//耗时@property (nonatomic, readonly) MKDirectionsTransportType transportType; //检索的类型@property (nonatomic, readonly) MKPolyline *polyline; // 线路覆盖物@property (nonatomic, readonly) NSArray *steps; // 线路详情数组@end （8）MKRouteStep 线路详情信息类，线路中每一步的信息都是这个类的对象 123456789101112@interface MKRouteStep : NSObject@property (nonatomic, readonly) NSString *instructions; // 节点信息@property (nonatomic, readonly) NSString *notice; // 注意事项@property (nonatomic, readonly) MKPolyline *polyline; //线路覆盖物@property (nonatomic, readonly) CLLocationDistance distance; // 距离@property (nonatomic, readonly) MKDirectionsTransportType transportType; // 导航类型@end 看到上面如此多的类，你可能会觉得一头雾水，那么不用着急，类虽然繁杂，但他们之间的逻辑非常清晰，下面就通过一个例子来进行线路导航。 2、进行线路导航12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667- (void)viewDidLoad &#123; [super viewDidLoad]; //地图初始化设置 mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(5, 5)); mapView.mapType=MKMapTypeStandard; mapView.delegate=self; [self.view addSubview:mapView]; //导航设置 CLLocationCoordinate2D fromcoor=CLLocationCoordinate2DMake(39.26, 116.3); CLLocationCoordinate2D tocoor = CLLocationCoordinate2DMake(33.33, 113.33); //创建出发点和目的点信息 MKPlacemark *fromPlace = [[MKPlacemark alloc] initWithCoordinate:fromcoor addressDictionary:nil]; MKPlacemark *toPlace = [[MKPlacemark alloc]initWithCoordinate:tocoor addressDictionary:nil]; //创建出发节点和目的地节点 MKMapItem * fromItem = [[MKMapItem alloc]initWithPlacemark:fromPlace]; MKMapItem * toItem = [[MKMapItem alloc]initWithPlacemark:toPlace]; //初始化导航搜索请求 MKDirectionsRequest *request = [[MKDirectionsRequest alloc]init]; request.source=fromItem; request.destination=toItem; request.requestsAlternateRoutes=YES; //初始化请求检索 MKDirections *directions = [[MKDirections alloc]initWithRequest:request]; //开始检索，结果会返回在block中 [directions calculateDirectionsWithCompletionHandler:^(MKDirectionsResponse *response, NSError *error) &#123; if (error) &#123; NSLog(@&quot;error:%@&quot;,error); &#125;else&#123; //提取导航线路结果中的一条线路 MKRoute *route =response.routes[0]; //将线路中的每一步详情提取出来 NSArray * stepArray = [NSArray arrayWithArray:route.steps]; //进行遍历 for (int i=0; i&lt;stepArray.count; i++) &#123; //线路的详情节点 MKRouteStep * step = stepArray[i]; //在此节点处添加一个大头针 MKPointAnnotation * point = [[MKPointAnnotation alloc]init]; point.coordinate=step.polyline.coordinate; point.title=step.instructions; point.subtitle=step.notice; [mapView addAnnotation:point]; //将此段线路添加到地图上 [mapView addOverlay:step.polyline]; &#125; &#125; &#125;]; &#125;//地图覆盖物的代理方法-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKPolylineRenderer *renderer = [[MKPolylineRenderer alloc] initWithPolyline:overlay]; renderer.strokeColor = [UIColor redColor]; renderer.lineWidth = 4.0; return renderer;&#125;//标注的代理方法-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; MKPinAnnotationView * view= [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;anno&quot;]; view.canShowCallout=YES; return view;&#125; 效果如下： 二、附近兴趣点检索兴趣点检索的逻辑和导航线路检索的逻辑相似，直接通过代码来演示： 1234567891011121314151617181920212223 //创建一个位置信息对象，第一个参数为经纬度，第二个为纬度检索范围，单位为米，第三个为经度检索范围，单位为米 MKCoordinateRegion region = MKCoordinateRegionMakeWithDistance(tocoor, 5000, 5000); //初始化一个检索请求对象 MKLocalSearchRequest * req = [[MKLocalSearchRequest alloc]init]; //设置检索参数 req.region=region; //兴趣点关键字 req.naturalLanguageQuery=@&quot;hotal&quot;; //初始化检索 MKLocalSearch * ser = [[MKLocalSearch alloc]initWithRequest:req]; //开始检索，结果返回在block中 [ser startWithCompletionHandler:^(MKLocalSearchResponse *response, NSError *error) &#123; //兴趣点节点数组 NSArray * array = [NSArray arrayWithArray:response.mapItems]; for (int i=0; i&lt;array.count; i++) &#123; MKMapItem * item=array[i]; MKPointAnnotation * point = [[MKPointAnnotation alloc]init]; point.title=item.name; point.subtitle=item.phoneNumber; point.coordinate=item.placemark.coordinate; [mapView addAnnotation:point]; &#125; &#125;]; 效果如下： 如果疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南再续——地图覆盖物的应用","slug":"59iOS原生地图开发指南再续——地图覆盖物的应用","date":"2015-05-15T16:00:00.000Z","updated":"2021-06-25T02:23:37.847Z","comments":true,"path":"2015/05/16/59iOS原生地图开发指南再续——地图覆盖物的应用/","link":"","permalink":"http://huishao.cc/2015/05/16/59iOS原生地图开发指南再续——地图覆盖物的应用/","excerpt":"","text":"iOS原生地图开发指南再续——地图覆盖物的应用一、引言在前两篇博客中，将iOS系统的地图框架MapKit中地图的设置与应用以及关于添加大头针和自定义大头针的相关操作做了详细的介绍。链接如下：http://my.oschina.net/u/2340880/blog/415360、http://my.oschina.net/u/2340880/blog/415441。这篇博客中将进一步讨论关于地图添加覆盖物的使用方法。 二、添加地图覆盖物的逻辑原理地图覆盖物其实就是在地图上画一些东西，例如路径，范围等等。添加地图覆盖物的逻辑原理其实和添加大头针很相似。首先所有可以成为覆盖物的对象必须遵守MKOverlay这个协议，通过 - (void)addOverlay:(id )overlay; 将覆盖物添加在地图上，然后地图会调用代理方法 -(MKOverlayRenderer )mapView:(MKMapView )mapView rendererForOverlay:(id)overlay; 对覆盖物进行绘制，我们可以在这个方法中设置覆盖物，例如线宽，颜色等，注意，必须实现这个方法，覆盖物才会显示。 1、添加折线覆盖物12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //初始化地图对象 MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; //设置地图 _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); //设置代理 _mapView.delegate=self; //下面是C的语法，创建一个结构体数组 CLLocationCoordinate2D *coor; coor = malloc(sizeof(CLLocationCoordinate2D)*5); for (int i=0; i&lt;5; i++) &#123; CLLocationCoordinate2D po = CLLocationCoordinate2DMake(33.23+i*0.01, 113.112); coor[i]=po; &#125; //创建一个折线对象 MKPolyline * line = [MKPolyline polylineWithCoordinates:coor count:5]; [_mapView addOverlay:line]; [self.view addSubview:_mapView];&#125;//覆盖物绘制的代理-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; //折线覆盖物提供类 MKPolylineRenderer * render = [[MKPolylineRenderer alloc]initWithPolyline:overlay]; //设置线宽 render.lineWidth=3; //设置颜色 render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 2、添加圆形覆盖物1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); _mapView.delegate=self; //创建圆形覆盖物对象 MKCircle * cirle = [MKCircle circleWithCenterCoordinate:CLLocationCoordinate2DMake(33.23, 113.122) radius:500]; [_mapView addOverlay:cirle]; [self.view addSubview:_mapView];&#125;-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKCircleRenderer * render=[[MKCircleRenderer alloc]initWithCircle:overlay]; render.lineWidth=3; //填充颜色 render.fillColor=[UIColor greenColor]; //线条颜色 render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 3、添加多边形覆盖物1234567891011121314151617181920212223- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. MKMapView * _mapView = [[MKMapView alloc]initWithFrame:self.view.frame]; _mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(33.23, 113.122), MKCoordinateSpanMake(10, 10)); _mapView.delegate=self; CLLocationCoordinate2D *coor; coor = malloc(sizeof(CLLocationCoordinate2D)*6); for (int i=0; i&lt;5; i++) &#123; CLLocationCoordinate2D po = CLLocationCoordinate2DMake(33.23+i*0.01, 113.112+((i/2==0)?0.01:-0.01)); coor[i]=po; &#125; coor[5]=CLLocationCoordinate2DMake(33.23, 113.112); MKPolygon * gon = [MKPolygon polygonWithCoordinates:coor count:6]; [_mapView addOverlay:gon]; [self.view addSubview:_mapView];&#125;-(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id&lt;MKOverlay&gt;)overlay&#123; MKPolygonRenderer * render = [[MKPolygonRenderer alloc]initWithPolygon:overlay]; render.lineWidth=3; render.strokeColor=[UIColor redColor]; return render;&#125; 效果如下： 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南续——大头针与自定义标注","slug":"58iOS原生地图开发指南续——大头针与自定义标注","date":"2015-05-14T16:00:00.000Z","updated":"2021-06-25T02:22:30.328Z","comments":true,"path":"2015/05/15/58iOS原生地图开发指南续——大头针与自定义标注/","link":"","permalink":"http://huishao.cc/2015/05/15/58iOS原生地图开发指南续——大头针与自定义标注/","excerpt":"","text":"iOS原生地图开发指南续——大头针与自定义标注在上一篇博客中http://my.oschina.net/u/2340880/blog/415360系统总结了iOS原生地图框架MapKit中主体地图的设置与应用。这篇是上一篇的一个后续，总结了系统的大头针视图以及自定义标注视图的方法。 一、先来认识一个协议MKAnnotation官方文档告诉我们，所有标注的类必须遵守这个协议。所以可以了解，标注这个概念在逻辑属性和视图上是分开的。先来看下这个协议声明了哪些方法： 123456789@protocol MKAnnotation &lt;NSObject&gt;@property (nonatomic, readonly) CLLocationCoordinate2D coordinate;//地理坐标位置@optional@property (nonatomic, readonly, copy) NSString *title;//标题@property (nonatomic, readonly, copy) NSString *subtitle;//副标题//拖动时调用- (void)setCoordinate:(CLLocationCoordinate2D)newCoordinate;@end 二、创建一个系统标注大头针123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化地图 mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; //设置代理 mapView.delegate=self; //设置位置 mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(1.8, 1)); mapView.mapType=MKMapTypeStandard; //初始化一个大头针类 MKPointAnnotation * ann = [[MKPointAnnotation alloc]init]; //设置大头针坐标 ann.coordinate=CLLocationCoordinate2DMake(39.26, 116.3); ann.title=@&quot;我&quot;; ann.subtitle=@&quot;看这里&quot;; [mapView addAnnotation:ann]; [self.view addSubview:mapView];&#125; 效果如下： 重绘大头针视图，大头针渲染时会调用地图代理的方法，我们可以重写这个方法进行大头针的重绘，来更改其颜色： 123456-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; //创建一个系统大头针对象 MKPinAnnotationView * view = [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;pin&quot;]; view.pinColor=MKPinAnnotationColorGreen;//设置颜色为绿色 return view;&#125; 效果如下： MKAnnotationView是标注的视图类，一会我们通过它来自定义我们自己的标注，先来看MKPinAnnotationView这个类，这个类继承于MKAnnotationView，是一个大头针视图类。这个类根简单，只有一下两个属性： @property (nonatomic) MKPinAnnotationColor pinColor; 设置大头针的颜色，枚举如下： 12345typedef NS_ENUM(NSUInteger, MKPinAnnotationColor) &#123; MKPinAnnotationColorRed = 0,//红色 MKPinAnnotationColorGreen,//绿色 MKPinAnnotationColorPurple//紫色&#125;; @property (nonatomic) BOOL animatesDrop; 设置添加时是否显示降落动画 三、自定义标注视图123456789101112131415161718-(MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; MKAnnotationView * view = [[MKAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;annotation&quot;]; //设置标注的图片 view.image=[UIImage imageNamed:@&quot;保温车0.png&quot;]; //点击显示图详情视图 必须MKPointAnnotation对象设置了标题和副标题 view.canShowCallout=YES; //创建了两个view UIView * view1 = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 50, 50)]; view1.backgroundColor=[UIColor redColor]; UIView * view2 = [[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 50)]; view2.backgroundColor=[UIColor blueColor]; //设置左右辅助视图 view.leftCalloutAccessoryView=view1; view.rightCalloutAccessoryView=view2; //设置拖拽 可以通过点击不放进行拖拽 view.draggable=YES; return view;&#125; 效果如下： 四、标注视图类MKAnnotationView的其他常用属性解读@property (nonatomic) CGPoint centerOffset; 视图中心的偏移量 @property (nonatomic) CGPoint calloutOffset; 点击后弹出视图的偏移量 @property (nonatomic, getter=isEnabled) BOOL enabled; 设置是否有效 @property (nonatomic, getter=isHighlighted) BOOL highlighted; 是否高亮状态 @property (nonatomic) CGPoint leftCalloutOffset; 设置左辅助视图的偏移量 @property (nonatomic) CGPoint rightCalloutOffset; 设置右辅助视图的偏移量 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS原生地图开发指南","slug":"57iOS原生地图开发指南","date":"2015-05-14T16:00:00.000Z","updated":"2021-06-25T02:21:13.139Z","comments":true,"path":"2015/05/15/57iOS原生地图开发指南/","link":"","permalink":"http://huishao.cc/2015/05/15/57iOS原生地图开发指南/","excerpt":"","text":"iOS原生地图开发详解 在上一篇博客中:http://my.oschina.net/u/2340880/blog/414760。对iOS中的定位服务进行了详细的介绍与参数说明，在开发中，地位服务往往与地图框架结合使用，这篇博客主要对iOS官方的地图框架MapKit.framework进行介绍。 一、初始化地图视图与相关属性方法介绍1、初始化地图视图地图视图的展示依赖于MKMapView这个类，这个类继承于UIView，因此和其他View的使用方法类似。在我们需要展现地图的地方： 12345- (void)viewDidLoad &#123; [super viewDidLoad]; MKMapView * mapView =[[MKMapView alloc]initWithFrame:self.view.frame]; [self.view addSubview:mapView];&#125; 运行发现，一张世界地图就在我们的设备上了，apple内置的地图数据是由高德提供的。 2、系统提供的三种地图样式可以通过MKMapView的mapType这个属性设置地图的模式： @property (nonatomic) MKMapType mapType; 枚举如下： 12345typedef NS_ENUM(NSUInteger, MKMapType) &#123; MKMapTypeStandard = 0,//标准式的行政地图(会显示城市，街道等) MKMapTypeSatellite,//标准的卫星地图 MKMapTypeHybrid//混合地图(在卫星图上显示街道等名称)&#125;; 3、设置地图的中心和比例尺在百度地图等第三方地图服务的SDK中，都会提供一个类似zoomLevel比例尺的属性。通过官方的API设置这个属性有些麻烦，但是也更加灵活。首先，设置地图的中心位置和比例尺是通过region这个属性实现的。region结构体如下： 1234typedef struct &#123; CLLocationCoordinate2D center;//地图中心的经纬度 MKCoordinateSpan span;//地图显示的经纬度范围&#125; MKCoordinateRegion; 这个结构体中包含了两个结构体，其中CLLocationCoordinate2D很好理解，就是简单的经纬度，解释如下： 1234typedef struct &#123; CLLocationDegrees latitude;//纬度，北纬为正，南纬为负 CLLocationDegrees longitude;//经度，东经为正，西经为负&#125; CLLocationCoordinate2D; MKCoordinateSpan这个结构体比较复杂，如下： 1234typedef struct &#123; CLLocationDegrees latitudeDelta;//纬度范围 CLLocationDegrees longitudeDelta;//经度范围&#125; MKCoordinateSpan; 这个结构体定义的应该是一个范围，因为北纬南纬加起来180°，所以纬度范围的取值应为0-180。同理，经度范围的取值范围为0-360。 通过上面的介绍，我们举个例子，将北京市设为地图的中心区域，并且比例设置为显示北京大小。通过百度，首先知道北京市界的地理坐标为：北纬39”26’至41”03’，东经115”25’至 117”30’。北京市区坐标为：北纬39.9”，东经116. 3”。代码如下： 1mapView.region=MKCoordinateRegionMake(CLLocationCoordinate2DMake(39.26, 116.3), MKCoordinateSpanMake(1.8, 2.05)); 运行后可以看到，北京市基本上是在地图中心的，效果如下： 注意：MKCoordinateSpan的显示范围是取决于大的一边的，比如如果我们这样写： 1MKCoordinateSpanMake(1.8, 360); 最后依然会显示整个世界地图。 - (void)setRegion:(MKCoordinateRegion)region animated:(BOOL)animated; 这个方法可以在设置后给地图加上动画效果 @property (nonatomic) CLLocationCoordinate2D centerCoordinate; 设置地图的中心点位置 - (void)setCenterCoordinate:(CLLocationCoordinate2D)coordinate animated:(BOOL)animated; 设置地图的中心点位置，并附带动画效果 4、坐标转换方法- (CGPoint)convertCoordinate:(CLLocationCoordinate2D)coordinate toPointToView:(UIView *)view; 将经纬度转换为视图上的坐标 - (CLLocationCoordinate2D)convertPoint:(CGPoint)point toCoordinateFromView:(UIView *)view; 将视图上的坐标转换为经纬度 - (CGRect)convertRegion:(MKCoordinateRegion)region toRectToView:(UIView *)view; 将地理显示的区域转换为视图上的坐标区域 - (MKCoordinateRegion)convertRect:(CGRect)rect toRegionFromView:(UIView *)view;将视图上的坐标区域转换为地理区域 5、MKMapView常用方法和属性@property (nonatomic, getter=isZoomEnabled) BOOL zoomEnabled; 设置是否允许捏合手势进行地图缩放 @property (nonatomic, getter=isScrollEnabled) BOOL scrollEnabled; 设置是否允许滑动 @property (nonatomic, getter=isRotateEnabled) BOOL rotateEnabled; 设置是否允许旋转地图 @property (nonatomic, getter=isPitchEnabled) BOOL pitchEnabled; 设置是否支持3D效果 @property (nonatomic) BOOL showsPointsOfInterest; 设置是否显示兴趣点，例如学校，医院等 @property (nonatomic) BOOL showsBuildings; 设置是否显示建筑物轮廓，只在标准的地图中有效 @property (nonatomic) BOOL showsUserLocation; 是否显示用户位置 @property (nonatomic) MKUserTrackingMode userTrackingMode; - (void)setUserTrackingMode:(MKUserTrackingMode)mode animated:(BOOL)animated; 设置更新用户位置的模式,当显示用户位置设置为YES，这个方法也设置了后，地图框架为我们直接集成了定位，地图上就会显示我们的位置，模式的枚举如下： 12345typedef NS_ENUM(NSInteger, MKUserTrackingMode) &#123; MKUserTrackingModeNone = 0, // 不跟踪用户位置 MKUserTrackingModeFollow, // 跟踪用户位置 MKUserTrackingModeFollowWithHeading, // 当方向改变时跟踪用户位置&#125; @property (nonatomic, readonly) MKUserLocation *userLocation; 获取用户位置的标注 @property (nonatomic, readonly, getter=isUserLocationVisible) BOOL userLocationVisible; 获取用户位置是否可见 - (void)addAnnotation:(id )annotation; 在地图上添加一个标注 - (void)addAnnotations:(NSArray *)annotations;在地图上添加一组标注- (void)removeAnnotation:(id )annotation; 移除一个标注 - (void)removeAnnotations:(NSArray *)annotations; 移除一组标注 @property (nonatomic, readonly) NSArray *annotations; 获取所有标注数组 - (MKAnnotationView *)viewForAnnotation:(id )annotation; 获取标注的视图 - (MKAnnotationView )dequeueReusableAnnotationViewWithIdentifier:(NSString )identifier; 获取复用的标注 - (void)selectAnnotation:(id )annotation animated:(BOOL)animated; 选中一个标注 - (void)deselectAnnotation:(id )annotation animated:(BOOL)animated; 取消选中一个标注 @property (nonatomic, copy) NSArray *selectedAnnotations; 选中标注的数组 - (void)addOverlay:(id )overlay level:(MKOverlayLevel)level; 添加一个地图覆盖物，level是设置一个层级，枚举如下： 1234typedef NS_ENUM(NSInteger, MKOverlayLevel) &#123; MKOverlayLevelAboveRoads = 0, // 覆盖物位于道路之上 MKOverlayLevelAboveLabels//覆盖物位于标签之上&#125; - (void)addOverlays:(NSArray *)overlays level:(MKOverlayLevel)level; 添加一组地图覆盖物 - (void)removeOverlay:(id )overlay; 移除一个地图覆盖物 - (void)removeOverlays:(NSArray *)overlays; 移除一组地图覆盖物 - (void)insertOverlay:(id )overlay atIndex:(NSUInteger)index level:(MKOverlayLevel)level; 在索引处插入一个地图覆盖物 - (void)insertOverlay:(id )overlay aboveOverlay:(id )sibling; 将一个地图覆盖物插在到某个覆盖物之上 - (void)insertOverlay:(id )overlay belowOverlay:(id )sibling; 将一个地图覆盖物插入到某个覆盖物之下 - (void)exchangeOverlay:(id )overlay1 withOverlay:(id )overlay2; 替换一个地图覆盖物 @property (nonatomic, readonly) NSArray *overlays; 地图覆盖物数组 - (NSArray *)overlaysInLevel:(MKOverlayLevel)level; 层级属性下的东土覆盖物数组 二、MKMapViewDelegate相关方法解读- (void)mapView:(MKMapView *)mapView regionWillChangeAnimated:(BOOL)animated; 地图显示位置将要改变时调用的方法 - (void)mapView:(MKMapView *)mapView regionDidChangeAnimated:(BOOL)animated; 地图显示位置已经改变时调用的方法 - (void)mapViewWillStartLoadingMap:(MKMapView *)mapView; 地图将要加载时调用的方法 - (void)mapViewDidFinishLoadingMap:(MKMapView *)mapView; 地图加载完成时执行的方法 - (void)mapViewDidFailLoadingMap:(MKMapView )mapView withError:(NSError )error; 地图加载失败时执行的方法 - (MKAnnotationView )mapView:(MKMapView )mapView viewForAnnotation:(id )annotation; 渲染标注视图时调用的方法，可以通过这个方法自定义标注视图 - (void)mapView:(MKMapView )mapView didAddAnnotationViews:(NSArray )views; 标注添加完成后调用的方法 - (void)mapView:(MKMapView )mapView didSelectAnnotationView:(MKAnnotationView )view; 选中标注时调用的方法 - (void)mapView:(MKMapView )mapView didDeselectAnnotationView:(MKAnnotationView )view; 取消选中标注时调用的方法 - (void)mapViewWillStartLocatingUser:(MKMapView *)mapView; 将要开始定位用户位置时调用的方法 - (void)mapViewDidStopLocatingUser:(MKMapView *)mapView; 停止定位用户位置时调用的方法 - (void)mapView:(MKMapView )mapView didUpdateUserLocation:(MKUserLocation )userLocation; 更新用户位置时调用的方法 - (void)mapView:(MKMapView )mapView didFailToLocateUserWithError:(NSError )error; 更新用户位置失败时调用的方法 - (void)mapView:(MKMapView )mapView annotationView:(MKAnnotationView )view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState; 标注拖动状态改变调用的方法，MKAnnotationViewDragState的枚举如下： 1234567typedef NS_ENUM(NSUInteger, MKAnnotationViewDragState) &#123; MKAnnotationViewDragStateNone = 0, // 初始状态 MKAnnotationViewDragStateStarting, // 开始拖动时 MKAnnotationViewDragStateDragging, // 正在拖动 MKAnnotationViewDragStateCanceling, // 取消拖动 MKAnnotationViewDragStateEnding // 结束拖动&#125;; - (void)mapView:(MKMapView *)mapView didChangeUserTrackingMode:(MKUserTrackingMode)mode animated:(BOOL)animated; 定位用户位置模式改变时调用的方法 - (MKOverlayView )mapView:(MKMapView )mapView viewForOverlay:(id )overlay; 渲染覆盖物视图时调用的方法，可以自定义覆盖物视图 - (void)mapView:(MKMapView )mapView didAddOverlayViews:(NSArray )overlayViews; 添加完成覆盖物数组执行的方法 备注：在iOS9中，地图类型的枚举又添加了两种： 1234567typedef NS_ENUM(NSUInteger, MKMapType) &#123; MKMapTypeStandard = 0,//标准 MKMapTypeSatellite,//卫星 MKMapTypeHybrid,//混合 MKMapTypeSatelliteFlyover NS_ENUM_AVAILABLE(10_11, 9_0),//立体卫星 MKMapTypeHybridFlyover NS_ENUM_AVAILABLE(10_11, 9_0),//立体混合&#125; NS_ENUM_AVAILABLE(10_9, 3_0) __WATCHOS_PROHIBITED; 注：因篇幅限制，关于系统大头针和自定义标注的应用、地图覆盖物的应用将在下一篇博客中讨论。 疏漏之处 欢迎指正 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美六——滚动字幕的应用","slug":"56标签之美六——滚动字幕的应用","date":"2015-05-13T16:00:00.000Z","updated":"2021-06-25T02:20:03.143Z","comments":true,"path":"2015/05/14/56标签之美六——滚动字幕的应用/","link":"","permalink":"http://huishao.cc/2015/05/14/56标签之美六——滚动字幕的应用/","excerpt":"","text":"标签之美——滚动字幕的应用在网页中，我们经常可以看到一些滚动出现的字幕，按钮等内容。滚动字幕的应用会使网页的内容更加生动紧凑。 1、滚动标签 将滚动显示的文字放在这个标签内，就可以实现滚动字幕。这个标签有一个behavior属性，可以设置滚动方式： scroll：循环滚动，默认的滚动方式 slide：只滚动一次 alternate：左右来回滚动 2、设置字幕背景颜色 123&lt;body&gt;&lt;marquee behavior=&quot;alternate&quot; bgcolor=&quot;#F4070B&quot;&gt;这里是滚动字幕&lt;/marquee&gt;&lt;/body&gt; 3、设置字幕滚动方向：direction属性，可以设置的值有：left，right，up，down。分别表示从右向左滚动，从左向右滚动，从下向上滚动，从上向下滚动。 4、设置字幕的滚动速度 通过设置scrollamount属性来更改字幕的滚动速度，数值越大，速度越快。 5、设置字幕滚动时间间隔 scrolldelay可以来设置字幕的停顿时间间隔，单位是毫秒。效果和速度属性相似。 6、设置滚动次数 loop属性可以设置滚动次数，-1则为循环滚动。 7、设置鼠标滑过时停止滚动，移开时继续滚动： 123&lt;body&gt;&lt;marquee direction=&quot;down&quot; onMouseOver=&quot;this.stop()&quot; onMouseOut=&quot;this.start()&quot;&gt;这里是滚动字幕&lt;/marquee&gt;&lt;/body&gt; 滚动字幕也支持图片的滚动，将文字换位图片即可。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS定位服务的应用","slug":"55IOS定位服务的应用","date":"2015-05-13T16:00:00.000Z","updated":"2021-06-25T02:19:06.778Z","comments":true,"path":"2015/05/14/55IOS定位服务的应用/","link":"","permalink":"http://huishao.cc/2015/05/14/55IOS定位服务的应用/","excerpt":"","text":"iOS定位服务的应用一、授权的申请与设置在IOS8之后，IOS的定位服务做了优化，若要使用定位服务，必须先获取用户的授权。 首先需要在info.plist文件中添加一个键：NSLocationAlwaysUsageDescription或者NSLocationWhenInUseUsageDescription。其中NSLocationAlwaysUsageDescription是要始终使用定位服务，NSLocationWhenInUseUsageDescription是只在前台使用定位服务。 IOS8中CLLocationManager新增的两个新方法： - (void)requestAlwaysAuthorization; - (void)requestWhenInUseAuthorization; 这两个方法对应上面的两个键值，用于在代码中申请定位服务权限。 二、定位服务相关方法IOS的定位服务在CoreLocation.framework框架内，首先引入这个框架： 开启定位服务的代码非常简单，示例如下： 12345678910111213141516171819#import &quot;ViewController.h&quot;#import &lt;CoreLocation/CoreLocation.h&gt;@interface ViewController ()&lt;CLLocationManagerDelegate&gt;//定位服务的代理@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; CLLocationManager* manager = [[CLLocationManager alloc]init];//初始化一个定位管理对象 [manager requestWhenInUseAuthorization];//申请定位服务权限 manager.delegate=self;//设置代理 [manager startUpdatingLocation];//开启定位服务&#125;//定位位置改变后调用的函数-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations&#123; NSLog(@&quot;%@&quot;,locations);&#125;@end CLLocationManager相关方法解读： + (BOOL)locationServicesEnabled; 判断设备是否支持定位服务 + (BOOL)headingAvailable; 判断设备是否支持航向信息功能(海拔，速度，方向等传感器的支持) + (BOOL)significantLocationChangeMonitoringAvailable; 判断设备是否支持更新位置信息 + (BOOL)isMonitoringAvailableForClass:(Class)regionClass; 判断设备是否支持区域检测，regionClass是地图框架中的类。 + (BOOL)isRangingAvailabl; 判断设备是否支持蓝牙测距 + (CLAuthorizationStatus)authorizationStatus; 获得定位服务的授权状态，CLAuthorizationStatus的枚举如下： 1234567typedef NS_ENUM(int, CLAuthorizationStatus) &#123; kCLAuthorizationStatusNotDetermined = 0,//用户还没有做选择 kCLAuthorizationStatusRestricted,//应用拒接使用定位服务 kCLAuthorizationStatusDenied,//用户拒绝授权 kCLAuthorizationStatusAuthorizedAlways,//8.0后可用，始终授权位置服务 kCLAuthorizationStatusAuthorizedWhenInUse,//8.0后可用，只在前台授权位置服务&#125;; @property(assign, nonatomic) CLActivityType activityType; 这个属性用来设置位置更新的模式，枚举如下： 123456typedef NS_ENUM(NSInteger, CLActivityType) &#123; CLActivityTypeOther = 1,//未知模式，默认为此 CLActivityTypeAutomotiveNavigation, //车辆导航模式 CLActivityTypeFitness, //行人模式 CLActivityTypeOtherNavigation //其他交通工具模式&#125;; 模式的应用可以起到节省电量的作用，例如车辆导航模式，当汽车停止时，位置更新服务会暂停。 @property(assign, nonatomic) CLLocationDistance distanceFilter; 设置位置更新的敏感范围，单位为米。 @property(assign, nonatomic) CLLocationAccuracy desiredAccuracy; 设置定位服务的精确度，系统定义好的几个参数如下： kCLLocationAccuracyBestForNavigation;//导航最高精确kCLLocationAccuracyBest;//高精确kCLLocationAccuracyNearestTenMeters;//10米kCLLocationAccuracyHundredMeters;//百米kCLLocationAccuracyKilometer;//千米kCLLocationAccuracyThreeKilometers;//三公里 @property(assign, nonatomic) BOOL pausesLocationUpdatesAutomatically; 设置位置更新是否自动暂停 @property(readonly, nonatomic, copy) CLLocation *location; 最后一次更新的位置信息，只读属性 @property(assign, nonatomic) CLLocationDegrees headingFilter; 相关航向更新的敏感范围 @property(assign, nonatomic) CLDeviceOrientation headingOrientation; 定位航向时的参照方向默认为正北，枚举如下： 123456789typedef NS_ENUM(int, CLDeviceOrientation) &#123; CLDeviceOrientationUnknown = 0,//方向未知 CLDeviceOrientationPortrait,//纵向模式 CLDeviceOrientationPortraitUpsideDown,//纵向倒置模式 CLDeviceOrientationLandscapeLeft,//左向横向模式 CLDeviceOrientationLandscapeRight,//右向横向模式 CLDeviceOrientationFaceUp,//水平屏幕向上模式 CLDeviceOrientationFaceDown//水平屏幕下模式&#125;; @property(readonly, nonatomic, copy) CLHeading *heading; 最后一个定位得到的航向信息 - (void)startUpdatingLocation; 开启定位服务 - (void)stopUpdatingLocation; 停止定位服务 - (void)startUpdatingHeading; 开启航向地理信息服务 - (void)stopUpdatingHeading; 停止航向地理信息服务 三、定位服务代理的相关方法- (void)locationManager:(CLLocationManager )manager didUpdateLocations:(NSArray )locations； 位置更新后调用的方法，数组中是所有定位到的位置信息，最后一个是最新的。 - (void)locationManager:(CLLocationManager )manager didUpdateHeading:(CLHeading )newHeading； 航向信息更新后调用的方法 - (void)locationManager:(CLLocationManager )manager didFailWithError:(NSError )error; 定位异常时调用的方法 四、定位服务获取到的位置对象上面也提到，定位后返回的数组中存放的都是CLLocation对象，这里面有很详细的位置信息，属性如下： @property(readonly, nonatomic) CLLocationCoordinate2D coordinate; 经纬度属性，CLLocationCoordinate2D是一个结构体，如下： 1234typedef struct &#123; CLLocationDegrees latitude;//纬度 CLLocationDegrees longitude;//经度&#125; CLLocationCoordinate2D; @property(readonly, nonatomic) CLLocationDistance altitude; 海拔高度，浮点型 @property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy; 水平方向的容错半径 @property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy; 竖直方向的容错半径 @property(readonly, nonatomic) CLLocationDirection course; 设备前进的方向，取值范围为0-359.9，相对正北方向 @property(readonly, nonatomic) CLLocationSpeed speed; 速度，单位为m/s @property(readonly, nonatomic, copy) NSDate *timestamp; 定位时的时间戳 五、航标定位得到的航标信息对象CLHeading对象的属性信息： @property(readonly, nonatomic) CLLocationDirection magneticHeading; 设备朝向航标方向，0为北磁极。 @property(readonly, nonatomic) CLLocationDirection trueHeading; 设备朝向真实方向，0被地理上的北极 @property(readonly, nonatomic) CLLocationDirection headingAccuracy; 方向偏差 @property(readonly, nonatomic) CLHeadingComponentValue x; x轴的方向值 @property(readonly, nonatomic) CLHeadingComponentValue y; y轴方向值 @property(readonly, nonatomic) CLHeadingComponentValue z; z轴方向值 @property(readonly, nonatomic, copy) NSDate *timestamp; 方向定位时间戳 如有疏漏 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美五——网页表格的设计","slug":"54标签之美五——网页表格的设计","date":"2015-05-12T16:00:00.000Z","updated":"2021-06-25T02:16:52.682Z","comments":true,"path":"2015/05/13/54标签之美五——网页表格的设计/","link":"","permalink":"http://huishao.cc/2015/05/13/54标签之美五——网页表格的设计/","excerpt":"","text":"标签之美——网页表格的使用通过表格，可以使网页排版更加清晰，形式更加简洁漂亮。 一、表格布局中三个重要的标签1、：表格的开始和结束标签，行列的布局都在标签内。 2、行标签的开始和结束 3、列标签的开始和结束 行标签在列标签的外层，不能单独使用，其中必须至少有一列。示例如下： 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;!--为了便于观察，设置一个边框--&gt;&lt;tr&gt;&lt;td&gt;表格的内容&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 效果如下： 二、单元格设置的相关标签1、单元格表头 这个标签用来设置表格的表头，作用和列标签相似，只是字体是加黑的。 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 2、表格宽度属性和高度属性width,height 这两个属性可以设置在标签里，也可以设置在和中，作用域会不同。 1234567&lt;body&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th width=&quot;200&quot;&gt;1&lt;/th&gt;&lt;th width=&quot;100&quot;&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 3、设置表格背景图片background 这个属性和尺寸属性用法一样，写在相应的标签里，就是相应的背景图案，设置的是图片的路径。 4、设置表格行列间距cellspacing 1234567&lt;body&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;20&quot;&gt;&lt;tr&gt;&lt;th width=&quot;200&quot;&gt;1&lt;/th&gt;&lt;th width=&quot;100&quot;&gt;2&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 5、设置单元格内容偏移量 cellpadding 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 三、表格的边框属性和对齐模式灵活的应用边框，可以使表格看起来更加整洁有序。 1、边框宽度属性border 2、边框的颜色属性bordercolor 3、不显示外边框frame=”void” 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;void&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 4、设置frame=”hsides”则只显示上下外边框 12345&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 5、设置frame=”vsides”则只显示左右外边框 6、单独显示边框的frame值分别为： 上：above 下：below 左：lhs 右：rhs 7、设置表格对齐模式： 水平对齐模式：align 表格的align属性可以设置对齐模式，center,left,right分别对应居中，左对齐，右对齐。 垂直对齐模式：valign 和水平对齐模式相似，这个属性的值为：middle，top，bottom对应了中间对齐，上对齐和下对齐。 四、表格行和列的操作1、行的合并：rowspan 12345678910&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;第一行&lt;/td&gt;&lt;td&gt;第一行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第二行&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 2、列的合并colspan 12345678910&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;第一列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 3、表格的标题标签 1234567891011&lt;body&gt;&lt;table cellpadding=&quot;50&quot; border=&quot;5&quot; frame=&quot;hsides&quot; &gt;&lt;caption&gt;标题&lt;/caption&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;第一列&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一列&lt;/td&gt;&lt;td&gt;第二列&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"分分钟搞定IOS远程消息推送","slug":"53分分钟搞定IOS远程消息推送","date":"2015-05-11T16:00:00.000Z","updated":"2021-06-25T02:13:59.786Z","comments":true,"path":"2015/05/12/53分分钟搞定IOS远程消息推送/","link":"","permalink":"http://huishao.cc/2015/05/12/53分分钟搞定IOS远程消息推送/","excerpt":"","text":"分分钟搞定IOS远程消息推送一、引言IOS中消息的推送有两种方式，分别是本地推送和远程推送，本地推送在http://my.oschina.net/u/2340880/blog/405491这篇博客中有详细的介绍，这里主要讨论远程推送的流程与配置过程。 二、远程推送机制的原理1、从一张很火的图说起搜索IOS远程推送，你总能看到一张如下的流程示意图，因为这张图确实很火，所以我也将它引用在此： 这张图示意的很清晰，大致意思是这样：你的应用服务端将消息发送到apple的APNS服务器，APNS服务器将消息推送到指定的Iphone，最后由Iphone负责将消息推送至你的APP。在此先不说这个过程是如何实现的，仅仅看这个流程，你可能会觉得，在你们服务端和客户端之间增加了一个apple的APNS，不是增加开发者的负担么？其实结果恰恰相反，因为apple对推送的统一管理，使我们开发者的工作变得异常简单。 2、服务端如何连接到客户端的如果你是做android开发的，你一定非常了解长链接与心跳包。事实上，大部分的android应用的推送也确实是通过长链接来实现的。因为android系统的开放性，APP是很容易做到自启动和后台长链接的，而心跳验证，就是始终保证长链接属于接通状态，然后由服务端直接推送消息。如果IOS开发者也采用这种思路，就十分困难了，在IOS中想要保持一个APP服务始终不被系统杀死，我只能说太难了。通过上面的流程图，对比android的推送思路，我们很容易明白，IOS中其实也始终有一个长链接，那就是系统本身，这个长链接始终与APNS服务器相连，然后统一管理所有应用程序的推送。 3、这是IOS推送机制的优势？下面的这些，只是我个人的一些看法。系统并无优劣，优劣在于个人喜好。 1、因为推送的服务端是appleID的验证用户，推送可靠性会高。 2、所有推送消息由APNS统一管理，效率高。 3、在客户端只需系统维护一个长链接，节省了用户流量消耗和手机的性能消耗，并且提高了安全性，使得有恶意推送和流氓软件的几率降低。 三、分分钟让你的APP收到远程推送1、工欲善其事、必先利其器——创建推送证书(1)请求CSR文件 在MAC应用程序中找到钥匙串访问，打开它。 点击选项栏中的钥匙串访问中的证书助理： 选择从证书颁发机构申请证书: 填写电子邮件和名称，选择储存到磁盘，然后继续。 这时，我们存储的地方有了这样一个文件：CertificateSigningRequest.certSigningRequest。 (2)导出密钥文件 打开钥匙串，会发现多了一对密钥，名字就是上面你填写的常用名称。 我们选择专用密钥进行导出，然后设置一个我们自己的密码： 这时候我们又有了一个后缀名为.p12的文件。 (3)创建AppId 到https://developer.apple.com的member Center： 用你付过费的开发者appleID登陆后，选择Certificates: 如果你的项目已经创建了APP id，则可以不用重新创建，但是你创建的APP id必须要支持远程推送。如果还没有创建，点击加号，创建一个： 之后的界面中APP ID有两种类型：Explicit和Wildcard，分别是特殊的和通配的，我们需要推送功能，这个ID不能是通配的，所以我们选择第一个。 这里需要填的的Bundle ID必须和我们App中的一致： 在APP ID的服务设置中，将Push Notification勾选上，点击continue。 之后点击submit，最后点击Done。这时我们的APP IDs列表中会出现我们刚才创建的APP ID。 (4)创建证书 点击我们刚才创建的APP ID，你会看到Push Notification一行为未设定的。我们点击Edit。 在Push Notifications设置里是如下界面，development是开发证书，Production是产品证书，我们现在需要测试，所以用Development证书，上线时要使用Production证书。点击Create Certificate。 接着点击continue，如下界面会让我们选择一个CSR文件，我们第一步创建的文件在这里派上用场了，选择那个文件，点击Generate。 将创建好的证书下载到电脑中： 至此，我们已经有了三个文件了，分别是CSR文件，.p12文件，.cer文件。要将这三个文件放在同一个目录下。.cer文件分为测试和产品两个，需要哪个自行选择。写了这么多，我们的准备工作可算是做完了，不要灰心，其实你的推送工作基本上也就做完了。只是申请过程麻烦了一些，但工程的代码，我们几乎不用怎么配置。 2、兵马未动、粮草先行——服务端进行信息推送的设置(1)处理证书 打开终端cd到我们上面得到的三个文件所在的目录。 在终端执行如下命令： 1$ openssl x509 -in aps_development.cer -inform der -out PushCert.pem aps_development.cer是刚才生成的.cer文件的文件名。会在当前文件夹中生成一个pem文件，这是我们服务端对应的证书。 再执行如下命令： 1$ openssl pkcs12 -nocerts -out PushKey.pem -in key.p12 key.p12是上面生成的.p12文件的文件名。这时终端会让输入密码，这里的密码就是上面我们设置的密钥的密码。输入密码后回车，如果密码正确，会让我们输入新密码(一定切记)，输入两次后，终端会提示成功创建PushKey.pem文件。 最后一步，将我们生成的两个pem文件和成为一个： 1$ cat PushCert.pem PushKey.pem &gt; ck.pem (2)测试证书是否可用 在终端执行下面的命令： 1$ telnet gateway.sandbox.push.apple.com 2195 等一小会，如果终端显示下面的情形，则证书正常。 然后执行如下命令： 1openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert PushChatCert.pem -key PushKey.pem 输入密码后回车显示如下的结果则连接成功： 3、天涯海角、一步之遥——应用程序中的配置在我们项目的AppDelegate中添加如下代码： 12345678910111213141516171819202122- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;double version = [[UIDevice currentDevice].systemVersion doubleValue];//判定系统版本。if(version&gt;=8.0f)&#123; UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:(UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound|UIRemoteNotificationTypeAlert) categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; &#125;else&#123; UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes]; &#125;&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; // 处理推送消息 NSLog(@&quot;userinfo:%@&quot;,userInfo); NSLog(@&quot;收到推送消息:%@&quot;,[[userInfo objectForKey:@&quot;aps&quot;] objectForKey:@&quot;alert&quot;]);&#125;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *) error &#123; NSLog(@&quot;Registfail%@&quot;,error);&#125;-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123; NSLog(@&quot;%@&quot;,deviceToken);//这里的Token就是我们设备要告诉服务端的Token码&#125; 下面是网上搜的PHP服务端的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php//这里填写设备的Token码$deviceToken = &apos;74314cc9e8f747e2fa96c2c1585c830cdf994de6b453ce9fa1c09ba396b2f9e9&apos;;//这里是密钥密码$passphrase = &apos;abcabc&apos;;//推送的消息$message = &apos;这是一条推送消息&apos;;////////////////////////////////////////////////////////////////////////////////$ctx = stream_context_create();stream_context_set_option($ctx, &apos;ssl&apos;, &apos;local_cert&apos;, &apos;ck.pem&apos;);//ck文件stream_context_set_option($ctx, &apos;ssl&apos;, &apos;passphrase&apos;, $passphrase);// Open a connection to the APNS server$fp = stream_socket_client( &apos;ssl://gateway.sandbox.push.apple.com:2195&apos;, $err, $errstr, 60, STREAM_CLIENT_CONNECT|STREAM_CLIENT_PERSISTENT, $ctx);if (!$fp) exit(&quot;Failed to connect: $err $errstr&quot; . PHP_EOL);echo &apos;Connected to APNS&apos; . PHP_EOL;// Create the payload body$body[&apos;aps&apos;] = array( &apos;alert&apos; =&gt; $message, &apos;sound&apos; =&gt; &apos;default&apos; );// Encode the payload as JSON$payload = json_encode($body);// Build the binary notification$msg = chr(0) . pack(&apos;n&apos;, 32) . pack(&apos;H*&apos;, $deviceToken) . pack(&apos;n&apos;, strlen($payload)) . $payload;// Send it to the server$result = fwrite($fp, $msg, strlen($msg));if (!$result) echo &apos;Message not delivered&apos; . PHP_EOL;else echo &apos;Message successfully delivered&apos; . PHP_EOL;// Close the connection to the serverfclose($fp); ?&gt; 把上面的PHP文件和我们的ck文件放在同一目录下。在终端的当前目录下，执行如下命令： 1$php push.php 如果我们的设备王略正常，就可收到推送的消息了： 四、几点注意1、如果终端发送信息时提示密钥不可访问之类的错误，请检查是否cd到了当前目录，如果还存在问题，将密钥部分从新生成一次。 2、注意PHP代码中的字符为英文字符。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美四——为网页添加绚丽多彩的图像","slug":"52标签之美四——为网页添加绚丽多彩的图像","date":"2015-05-10T16:00:00.000Z","updated":"2021-06-25T02:12:36.825Z","comments":true,"path":"2015/05/11/52标签之美四——为网页添加绚丽多彩的图像/","link":"","permalink":"http://huishao.cc/2015/05/11/52标签之美四——为网页添加绚丽多彩的图像/","excerpt":"","text":"标签之美——图像的使用一、设置网页背景图片12&lt;body background=&quot;1.jpg&quot;&gt;&lt;/body&gt; 这里图片路径的写法和本地超链接的写法是一样的，可以参考上一篇博客中关于本地路径的地方：http://my.oschina.net/u/2340880/blog/412934。 注意：如果图片大小不能充满网页，图片将会被复制平铺。 二、图片标签的应用是图片插入标签。其中图片路径的写法和超链接路径的写法一样。示例如下： 123&lt;body&gt;&lt;img src=&quot;2.png&quot;/&gt;&lt;/body&gt; 效果如下： 标签的alt属性可以为图片添加缺省文字，当图片不存在或者无法显示时，会有提示效果。示例如下： 123&lt;body&gt;&lt;img src=&quot;3.png&quot; alt=&quot;图片不存在&quot;/&gt;&lt;/body&gt; 设置图片的尺寸属性：width，height 123&lt;body&gt;&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;&lt;!--设置宽高为200像素--&gt;&lt;/body&gt; 三、图片的对齐模式align是图片标签的对齐属性，对齐模式有5种属性值，下面一一对其进行介绍： 1、bottom:底部对其1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;bottom&quot;/&gt;的图片 效果如下： 2、left:左部对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;left&quot;/&gt;的图片 3、right:右部对其1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;right&quot;/&gt;的图片 效果如下： 4、middle:居中对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;middle&quot;/&gt;的图片 效果如下： 5、top:上部对齐1底部对齐的示例&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;top&quot;/&gt;的图片 效果如下： 四、设置图片边框和边距通过border属性可以给图片添加边框。属性的值为边框的宽度。 1&lt;img src=&quot;1.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; align=&quot;top&quot; border=&quot;4&quot;/&gt; 效果如下，图片被加上了黑色的边框： 也可以给图片设置一个间距，间距的效果和透明的边框是一样的。 1这里是图片&lt;img src=&quot;1.png&quot; align=&quot;middle&quot; hspace=&quot;20&quot;&gt;内容 其中，hspace是设置水平边框的宽度，还有一个属性vspace是设置垂直边框的宽度，上面代码效果如下： 五、插入视频的相关操作插入视频的原理和图像是一样的，只是路径使用的时dynsrc，可以使用loop属性来设置循环次数，start属性来设置播放方式，这里，只将start属性说明一下，有两种方式，fileopen是网页加载就开始播放，mouseover是鼠标移动到视频位置后开始播放。 1&lt;img dynsrc=&quot;2.wmv&quot; start=&quot;fileopen&quot; loop=&quot;1&quot;&gt; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美三——超链接的嵌入","slug":"51标签之美三——超链接的嵌入","date":"2015-05-09T16:00:00.000Z","updated":"2021-06-25T02:11:41.747Z","comments":true,"path":"2015/05/10/51标签之美三——超链接的嵌入/","link":"","permalink":"http://huishao.cc/2015/05/10/51标签之美三——超链接的嵌入/","excerpt":"","text":"标签之美——超链接标签一、创建超链接通常的超链接有两种方式，一种是链接到另一个文件，另一种是链接到当前文件的某个位置。这两种方式都是通过标签来创建，其中href属性用来指定链接的目标地址。 1、链接到当前页面指定位置被链接的地方需要使用标签的name属性标记，示例如下： 1234&lt;a href=&quot;#last&quot;&gt;链接到本页最后&lt;/a&gt;&lt;!--创建一个超链接--&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=&quot;last&quot;&gt;最后&lt;/a&gt;&lt;!--链接的标记名--&gt;&lt;/body&gt; 2、链接到本地相对路径文件相对路径是以当前\b文件所在的路径为参考的。示例如下： 12345678&lt;body&gt;&lt;!--同级链接：所链接到得文件与当前文件在同一目录下，直接链接文件名即可--&gt;&lt;a href=&quot;nwe.html&quot;&gt;同级链接&lt;/a&gt;&lt;!--下级链接：所链接的文件在当前文件所在目录的子目录下--&gt;&lt;a href=&quot;thml/new.html&quot;&gt;下级链接&lt;/a&gt;&lt;!--上级链接：所链接文件在当前文件所在的上级目录--&gt;&lt;a href=&quot;../new.html&quot;&gt;上级链接&lt;/a&gt;&lt;/body&gt; 3、链接到网址URL这种方式通常会用在友情链接中。例如如下链接到百度： 123&lt;body&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/body&gt; 二、链接的打开方式标签中的target属性可以设置标签的打开方式，一共有四种方式，分别是_blank,_parent,_self,_top。 1、_blank打开方式会让浏览器在新的窗口中打开标签。 2、_parent打开方式在父窗口中打开，当前页面会被覆盖。 3、_self打开方式在当前窗口打开，当前窗口会被覆盖。 4、_top打开方式在最上层窗体中打开。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"标签之美二——文本标签","slug":"50标签之美二——文本标签","date":"2015-05-07T16:00:00.000Z","updated":"2021-06-24T11:32:33.037Z","comments":true,"path":"2015/05/08/50标签之美二——文本标签/","link":"","permalink":"http://huishao.cc/2015/05/08/50标签之美二——文本标签/","excerpt":"","text":"标签之美–HTML文本标签属性详解1、使用标题标签 是标题的开始和结束标签，html提供6级标题划分，示例如下： 123&lt;body&gt;&lt;!--设置背景为蓝色--&gt;&lt;h1&gt;这是一级标题&lt;/h1&gt;&lt;h2&gt;这是二级标题&lt;/h&gt;&lt;h6&gt;这是六级标题&lt;/h6&gt;&lt;/body&gt; 2、使用字体标签 用于定义字体，其中详细属性如下： 定义字体大小：size 例如设置其中文字字号为4。 设置字体：face 其中可以填写多个字体名称，浏览器会按顺序寻找。 3、使用文本布局标签 缩进标签，可以让内容布局更加清晰，效果如下： 1234&lt;body&gt;这是没有使用索引的内容&lt;br&gt;&lt;blockquote&gt;这里使用了标签的内容&lt;/blockquote&gt;&lt;/body&gt; 手动格式化布局标签这个标签可以不通过代码进行空格和换行的控制，而是直接将文本中的布局显示。效果如下： 1234&lt;body&gt;&lt;pre&gt;手动的空格 与换行这里是第二行&lt;/pre&gt;&lt;/body&gt; 内联标签，这个标签的作用是将对象内联与某些内容，比如将鼠标悬停时展现的内容，示例如下： 123&lt;body&gt;&lt;span title=&quot;看这里&quot;&gt;标题&lt;/span&gt;&lt;/body&gt; 4、使用字体属性标签 为字体加粗： 使用斜体： 添加下划线： 添加标注： 与下划线形式相同 添加删除标记： 与 添加上标： 添加下表： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS有关内存管理的二三事","slug":"49iOS有关内存管理的二三事","date":"2015-05-06T16:00:00.000Z","updated":"2021-06-24T11:31:41.336Z","comments":true,"path":"2015/05/07/49iOS有关内存管理的二三事/","link":"","permalink":"http://huishao.cc/2015/05/07/49iOS有关内存管理的二三事/","excerpt":"","text":"iOS有关内存管理的二三事一、前引随着移动设备的内存越来越大，程序员也已经度过了为了那一两M的内存在系统的抽丝剥茧的年代，对于JAVA的开发者，对内存更是伸手即取，并且从不关心什么时候还回去。但是，程序的掌控度对程序员来说是至关重要的，任何语言的内存管理机制的初衷也是在有限的空间里完成最精致的逻辑。 二、Xcode工程设置ARCARC是xcode5中引入的自动引用计数，其原理与MRC是一样，只是系统帮助我们添加了retain和release。现在在xcode中新建的项目默认都是ARC的环境，我们可以通过设置其为MRC。 在BuildSettings中搜索ARC： 将下面的参数设置为NO，默认是YES。 这时项目工程的环境就变成了MRC。 三、项目中实现MRC和ARC混编现实中的许多旧的项目，还有一些比较老的第三方库，可能都是采用MRC环境编写的，我们在对其进行扩展或者做新项目的兼容的时候，可以在xcode中对其进行混编。 选择：target-&gt;build phases-&gt;compile sources 如果工程是ARC，要混编MRC的文件，我们选中compiler flags，后面设置为-fno-objc-arc 如果工程是MRC，要混编ARC文件，我们在后面设置-fobjc-arc 四、IOS内存管理机制基本原理无论你是只注重于代码逻辑，将内存交给ARC的新时代程序员，还是依然对apple的信任不足，依然事必躬亲的MRC古板程序员，我想你都应该了解IOS中内存管理的机制，尽管ARC机制很成熟也很可靠，可是依然会有很多应用存在循环应用，内存泄露等问题，要知道，ARC不是万能的，它仅仅只是帮你省去写一些繁琐的代码。 首先，在Object-C中创建对象返回的并不是对象本身，而是一个指针。比如我们使用alloc申请空间，会经常这样做： UIImage * image = [[UIImage alloc]init]; 这里，调用的alloc时，系统将给我们创建的类分配一块内存空间，并返回一个指向这个空间的指针。调用init时对对象进行初始化。如果此时，我们将image这个指针置为nil：image=nil;那样将造成内存泄露，系统分配给image的空间永远无法回收。所以，在我们不需要image这个对象时，我们会使用dealloc方法将其交还给系统：[image dealloc];然而这里，有将产生一个严重的问题，如果我们此时打印image的指针，会发现它现在成了一个危险东西，因为它指向的东西不存在了，而它却依然指向那个地方，这便是很多程序员的噩梦：野指针。为此，我们应该养成一个好习惯，不用的指针置为nil，所有对空指针进行的操作都被认为是安全的。 通过上面的理解，我们发现了一个非常麻烦的地方，我申请了一块内存空间，如果我将指针置空了而没有释放对象，则会内存泄露，如果我提前释放了对象，又很可能会有野指针的出现。并且如果有很多类都引用了这个对象，我甚至的不知道我应该什么时候释放它。因此，Object-C为我们引入了引用计数这种管理内存的方法，任何引用这个对象的地方，都应该让这个对象的引用计数加1。同样，任何不再需要这个对象的地方，也应该使它的引用计数减1，如此一来，对象内存便被统一的管理了起来。 五、内存管理的黄金法则引用计数内存管理的机制是对象的计数，每个对象至少会有一个引用者，如果没有了引用者，对象会被释放。 黄金法则： 1、当你使用alloc,new,copy,mutableCopy创建对象时，你才需要管理他们。 2、你可以使用retain给一个对象增加引用计数。 3、当你不再需要一个对象时，你必须调用release减少其引用计数。 4、你不能释放不属于你的对象的所有权。 上面就是黄金法则的所有内容，我译的可能不到位，总结为一点，也是至关重要的一点就是：谁创建了对象，谁释放掉对象。谁增加了引用计数，谁就在不用时减少计数。alloc，new，copy，mutableCopy，retain这些方法会使引用计数增加，release会使引用计数减少，当计数为0时，系统会调用dealloc释放内存。 六、自动释放池为了方便内存管理，避免我们频繁的调用release方法，Object-C中还为我们引用了一种机制：自动释放池。自动释放池的原理其实只是延时释放，它并没有帮我们做太多的工作。自动释放池的使用方式有两种： 1、MRC时： 123 NSAutoreleasePool * pool = [[NSAutoreleasePool alloc]init];//创建一个自动释放池，系统默认会为我们创建一个，我们也可以创建自己的。 UIImage * image = [[[UIImage alloc]init] autorelease];//在池内创建一些对象，会和最近的自动释放池匹配 [pool release];//这时自动释放池会向池子中的每一个对象发送release消息 2、ARC时： 123 @autoreleasepool &#123; UIImage * image = [[[UIImage alloc]init] autorelease]; &#125; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS开发遇到的屏幕上下闪出黑边的解决方法","slug":"48iOS开发遇到的屏幕上下闪出黑边的解决方法","date":"2015-05-06T16:00:00.000Z","updated":"2021-06-24T11:30:43.274Z","comments":true,"path":"2015/05/07/48iOS开发遇到的屏幕上下闪出黑边的解决方法/","link":"","permalink":"http://huishao.cc/2015/05/07/48iOS开发遇到的屏幕上下闪出黑边的解决方法/","excerpt":"","text":"iOS开发遇到的屏幕上下闪出黑边的解决方法在IOS开发时，使用的时IOS的模拟器，程序中任何有关坐标的地方也是根据屏幕获取的，而在IOS7的系统上运行，却发现屏幕小了一截，上下各闪出一块黑色区域。后经过查找原因，解决方法如下: 项目的App Icon and Launch Images设置中，本来是这样的： 点击Use Asset Catalog，之后点击Migrate，设置界面如下图模样： 这时在IOS7上就能充满屏幕了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"标签之美一——HTML基础元素","slug":"47标签之美一——HTML基础元素","date":"2015-05-05T16:00:00.000Z","updated":"2021-06-24T11:29:30.670Z","comments":true,"path":"2015/05/06/47标签之美一——HTML基础元素/","link":"","permalink":"http://huishao.cc/2015/05/06/47标签之美一——HTML基础元素/","excerpt":"","text":"标签之美–HTML基础标签使用总结HTML是一种标记语言，因此，标签便是HTML的核心，一些基础标签的用法总结如下： 1、 任何HTML文件都会有这样一个标签，标记网页的开始和结束。 2、 头部标签中可以包含许多网页的头信息。 3、 这个标签包含在头部标签内，其内容就是网页显示的标题，比如： 12345&lt;html&gt;&lt;head&gt;&lt;title&gt;我的HTML网页&lt;/title&gt;&lt;/head&gt;&lt;/html&gt; 结果如下： 4、 这是一个设置标签，也叫元信息标签，用于记录和设置网页的一些属性。 其中：name属性可以用来设置关键字，简要内容，网页生成工具及网页的制作者和网页链接查询权限，分别对应的字段为：Keywords、Description、Generator、Author、Robots。 每一个name的属性，后面都要用contect进行解释。对于Robots属性，contect权限的说明如下： all:文件和链接都可以被检索 none:都不可以被检索 index:文件被检索 follow:页面上的链接被检索 noindex：文件不被检索，链接可以被查询 标签的另一个属性值为http-equiv，它将告诉浏览器一些重要的信息，例如编码信息： 1&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;!--告诉浏览器编码格式--&gt; 定时跳转网页： 1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5;url=http://www.baidu.com&quot;&gt;&lt;!--5S后将跳转到百度网页--&gt; 5、 顾名思义，网页的主体内容写在这个标签里。 下面这些标签都是在标签下的： 6、 段落标签，示例如下： 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;我的HTML网页&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这是第一段&lt;/p&gt;&lt;p&gt;这是第二段&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 7、 换行标签，如下： 123&lt;body&gt;这是第一行&lt;br&gt;这是第二行&lt;/body&gt; 8、 水平分割线，示例如下： 123456789&lt;body&gt;这是第一行&lt;hr&gt;这是第二行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第三行&lt;hr width=&quot;200&quot;&gt;&lt;!--设置分割线的长度--&gt;这是第四行&lt;hr width=&quot;100&quot; align=&quot;left&quot;&gt;&lt;!--设置居左--&gt;&lt;/body&gt; 在设置分割线的颜色之前，我们先把HTML中颜色对应的代码总结如下： 123456789&lt;body&gt;这是第一行&lt;hr color=&quot;#0C2DEC&quot;&gt;这是第二行&lt;hr size=&quot;12&quot; color=&quot;#FF0000&quot;&gt;&lt;!--设置颜色--&gt;这是第三行&lt;hr width=&quot;200&quot; color=&quot;#730C0D&quot;&gt;这是第四行&lt;hr width=&quot;100&quot; align=&quot;left&quot; color=&quot;#158C4F&quot;&gt;&lt;/body&gt; 取消分割线阴影： 123456&lt;body&gt;这是第一行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第二行&lt;hr size=&quot;16&quot; noshade&gt;&lt;!--取消分割线阴影--&gt;&lt;/body&gt; 9、 注释标签，任何编程语言都会有注释语句，这个就无需多说了。形式如下： 10、设置网页背景色 标签中有一个属性，可以用来设置网页的背景颜色：bgcolor 123456&lt;body bgcolor=&quot;#002BF8&quot;&gt;&lt;!--设置背景为蓝色--&gt;这是第一行&lt;hr size=&quot;12&quot;&gt;&lt;!--设置分割线宽度--&gt;这是第二行&lt;hr size=&quot;16&quot; noshade&gt;&lt;!--取消分割线阴影--&gt;&lt;/body&gt; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}],"tags":[],"keywords":[{"name":"HTML学习笔记","slug":"HTML学习笔记","permalink":"http://huishao.cc/categories/HTML学习笔记/"}]},{"title":"iOS通过NSUserDefaults实现简单的应用间数据传递","slug":"46iOS通过NSUserDefaults实现简单的应用间数据传递","date":"2015-05-05T16:00:00.000Z","updated":"2021-06-24T11:27:18.667Z","comments":true,"path":"2015/05/06/46iOS通过NSUserDefaults实现简单的应用间数据传递/","link":"","permalink":"http://huishao.cc/2015/05/06/46iOS通过NSUserDefaults实现简单的应用间数据传递/","excerpt":"","text":"iOS中NSUserDefaults详解NSUserDefaults是用于保存应用程序设置，应用信息等轻量级数据的的一个类，其本质是将数据写为plist文件的形式保存在本地。在IOS中，系统为每一个应用程序都默认创建了一个NSUserDefaults对象。 一、常用方法总结+ (NSUserDefaults *)standardUserDefaults; 获取系统默认创建的应用程序设置表 + (void)resetStandardUserDefaults; 这个方法用于将默认的UserDefaults释放掉，并在下次使用时创建一个新的对象，需要注意的是，调用这个方法后，对原UserDefaults单例进行的KVO监听将失效。 - (instancetype)initWithSuiteName:(NSString *)suitename; 这个方法创建一个新的域：根据名字可以创建一些不同的域，分别存储几套设置信息。 - (id)objectForKey:(NSString *)defaultName; - (void)setObject:(id)value forKey:(NSString *)defaultName; - (void)removeObjectForKey:(NSString *)defaultName; 上面三个方法是对对象存储进行的操作，分别是存储，获取和删除。 - (NSString )stringForKey:(NSString )defaultName; 获取字符串数据 - (NSArray )arrayForKey:(NSString )defaultName; 获取数组数据 - (NSDictionary )dictionaryForKey:(NSString )defaultName; 获取字典数据 - (NSData )dataForKey:(NSString )defaultName; 获取data数据 - (NSArray )stringArrayForKey:(NSString )defaultName; 获取字符串数组数据 - (NSInteger)integerForKey:(NSString *)defaultName; 获取整型数据 - (float)floatForKey:(NSString *)defaultName; 获取浮点型数据 - (double)doubleForKey:(NSString *)defaultName; 获取双精度浮点型数据 - (BOOL)boolForKey:(NSString *)defaultName; 获取布尔诗句 - (NSURL )URLForKey:(NSString )defaultName; 获取网址数据 下面是一些对应的set方法 - (void)setInteger:(NSInteger)value forKey:(NSString *)defaultName; - (void)setFloat:(float)value forKey:(NSString *)defaultName; - (void)setDouble:(double)value forKey:(NSString *)defaultName; - (void)setBool:(BOOL)value forKey:(NSString *)defaultName; - (void)setURL:(NSURL )url forKey:(NSString )defaultName; - (void)registerDefaults:(NSDictionary *)registrationDictionary; 这个方法可以通过字典对数据表进行赋值 - (void)addSuiteNamed:(NSString *)suiteName; 添加一个域 - (void)removeSuiteNamed:(NSString *)suiteName; 移除一个域 - (NSDictionary *)dictionaryRepresentation; 返回系统设置的信息，也是NSGlobalDomain域中的信息。 @property (readonly, copy) NSArray *volatileDomainNames; 返回一个数组，其中是所有不稳定域的名字 - (NSDictionary )volatileDomainForName:(NSString )domainName; 根据名字获取不稳定域中的数据 - (void)setVolatileDomain:(NSDictionary )domain forName:(NSString )domainName; 根据名字设置不稳定域 - (void)removeVolatileDomainForName:(NSString *)domainName; 根据名字移除不稳定域 - (NSDictionary )persistentDomainForName:(NSString )domainName; 根据名字获取稳定域的数据 - (void)setPersistentDomain:(NSDictionary )domain forName:(NSString )domainName; 根据名字设置稳定域 - (void)removePersistentDomainForName:(NSString *)domainName; 根据名字移除稳定域 - (BOOL)synchronize; 对象的同步方法，将内存中的数据写入磁盘。 - (BOOL)objectIsForcedForKey:(NSString *)key; 判断某个键值的数据是否存在 - (BOOL)objectIsForcedForKey:(NSString )key inDomain:(NSString )domain; 判断某个域中某个键值的数据是否存在 注：目前的iOS版本已经不能通过下面的方法在应用间进行传值！！！ 二、三个特殊的域及实现简单的应用间信息传递我们应该了解到，在IOS中，因为沙盒模式的存在，应用间是不允许互相访问数据与传值通信的。这样做的好处显而易见： 1、保证了数据的安全性 2、数据的管理更加简洁 3、当我们删除数据时，只需要将沙盒删除。 在某些需求下，我们可能会需要应用程序间的传值与通信，当然除了通过网络外，对于非常小的数据量，比如验证另一应用从程序是否登录，是否安装并且开启过一次，我们也可以通过NSUserDefaults的一个全局的数据表来实现。 NSUserDefaults的三个特殊的系统域如下： NSString * const NSGlobalDomain; 这个是一个系统级别的全局的域，存储这系统配置信息，我们可以通过它实现应用程序间传值 NSString * const NSArgumentDomain; 这个是在本应用程序内可访问的域，存储着应用程序的信息 NSString * const NSRegistrationDomain; 这个是存放临时数据的域 代码示例如下： 首先在第一个工程中，我们写如下代码运运行一下： 123456789 //获取全局的域 NSDictionary * dic = [[NSUserDefaults standardUserDefaults]persistentDomainForName:NSGlobalDomain]; NSMutableDictionary * temDic = [NSMutableDictionary dictionaryWithDictionary:dic]; [temDic setObject:@&quot;传递的值&quot; forKey:@&quot;应用1&quot;]; //重设 [[NSUserDefaults standardUserDefaults]setPersistentDomain:temDic forName:NSGlobalDomain]; //同步 [NSUserDefaults resetStandardUserDefaults]; NSLog(@&quot;%@&quot;,dic); 打印的结果是许多系统信息。 在第二个工程中，我们这样做： 12 NSDictionary * dic = [[NSUserDefaults standardUserDefaults]persistentDomainForName:NSGlobalDomain]; NSLog(@&quot;%@\\n--------------\\n%@=%@&quot;,dic,@&quot;应用1&quot;,[dic objectForKey:@&quot;应用1&quot;]); 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657582015-05-06 15:48:49.897 321[4100:186745] &#123; AppleITunesStoreItemKinds = ( newsstand, podcast, &quot;itunes-u&quot;, artist, booklet, document, eBook, software, &quot;software-update&quot;, &quot;podcast-episode&quot; ); AppleLanguages = ( en, fr, de, &quot;zh-Hans&quot;, &quot;zh-Hant&quot;, ja, nl, it, es, &quot;es-MX&quot;, ko, pt, &quot;pt-PT&quot;, da, fi, nb, sv, ru, pl, tr, uk, ar, hr, cs, el, he, ro, sk, th, id, ms, &quot;en-GB&quot;, &quot;en-AU&quot;, ca, hu, vi, hi ); AppleLocale = &quot;en_US&quot;; MSVLoggingMasterSwitchEnabledKey = 0; &quot;\\U5e94\\U75281&quot; = &quot;\\U4f20\\U9012\\U7684\\U503c&quot;;&#125;--------------应用1=传递的值 这样，我们就简单实现了应用程序间的传值，但是建议最好不要轻易操作系统的这个域。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中KVC与KVO的应用解析","slug":"45iOS中KVC与KVO的应用解析","date":"2015-05-04T16:00:00.000Z","updated":"2021-06-24T11:26:23.274Z","comments":true,"path":"2015/05/05/45iOS中KVC与KVO的应用解析/","link":"","permalink":"http://huishao.cc/2015/05/05/45iOS中KVC与KVO的应用解析/","excerpt":"","text":"iOS中KVC与KVO的应用解析一、NSKeyValueCoding（KVC）1、从一个小例子引入KVC键值编码是Object-C为我们提供的一种对成员变量赋值的方法。在探讨其方法之前，我们先来看一个小例子： 首先，创建一个数据模型model类： 12345678//.h文件#import &lt;Foundation/Foundation.h&gt;@interface Model : NSObject&#123; @public//将成员变量设置为公有的 以便其他文件有访问权限 NSString * str;&#125;@end 我们在其他文件中有两种方法str进行赋值和取值： 12345 Model * model = [[Model alloc]init]; model-&gt;str=@&quot;312&quot;;//普通方法赋值 [model setValue:@&quot;321&quot; forKey:@&quot;str&quot;];//kvc赋值 NSLog(@&quot;%@&quot;,model-&gt;str);//普通方法取值 NSLog(@&quot;%@&quot;,[model valueForKey:@&quot;str&quot;]);//kvc取值 同样的，对于用@property声明的变量，使用kvc的效果和使用点语法，setter，getter方法的效果是一样的。 2、KVC有关函数方法详解通过上面的例子，我们已经可以简单了解KVC是干什么的了，下面是一些常用方法。 + (BOOL)accessInstanceVariablesDirectly; 这个方法类似一个开关，默认返回为YES，表示支持KVC方式赋值，也可以在子类中将其重写，如果返回为NO，则再进行KVC会抛出异常。 - (id)valueForKey:(NSString *)key; 通过键取值 - (void)setValue:(id)value forKey:(NSString *)key; 通过字符串键给成员变量赋值 - (BOOL)validateValue:(inout id )ioValue forKey:(NSString )inKey error:(out NSError **)outError; 系统默认实现的方法，验证一个键值是否有效 - (NSMutableArray )mutableArrayValueForKey:(NSString )key; 将取到的值放入一个可变数组中 - (NSMutableOrderedSet )mutableOrderedSetValueForKey:(NSString )key NS_AVAILABLE(10_7, 5_0); 将取到的值放入可变的有序集合中 - (NSMutableSet )mutableSetValueForKey:(NSString )key; 将取到的值放入可变的集合中 - (id)valueForKeyPath:(NSString )keyPath;- (void)setValue:(id)value forKeyPath:(NSString )keyPath; 上面这两个方法分别是通过路径赋值与取值，数据结构类似地图，比如在model类中有一个成员变量model2，在Model2类中有一个字符串，我们可以通过如下的方式赋值取值 123456789101112131415161718192021//Model.h#import &quot;Model2.h&quot;@interface Model : NSObject&#123; @public NSString * str; Model2 * model2;&#125;//Model2.h@interface Model2 : NSObject&#123;@public NSString * str2;&#125;@end//其他文件 Model * model = [[Model alloc]init]; Model2 * model2 = [[Model2 alloc]init]; model-&gt;model2=model2; [model setValue:@&quot;123&quot; forKeyPath:@&quot;model2.str2&quot;]; NSLog(@&quot;%@&quot;,[model valueForKeyPath:@&quot;model2.str2&quot;]); - (NSMutableArray )mutableArrayValueForKeyPath:(NSString )keyPath;- (NSMutableOrderedSet )mutableOrderedSetValueForKeyPath:(NSString )keyPath NS_AVAILABLE(10_7, 5_0);- (NSMutableSet )mutableSetValueForKeyPath:(NSString )keyPath; 上面三个方法与前面类似，只是是从路径取值的。 - (id)valueForUndefinedKey:(NSString *)key; 这个方法可以获取没有提前定义的成员变量的值，比如运行时创建的，下面这个方法是给未定义的成员变量赋值 - (void)setValue:(id)value forUndefinedKey:(NSString *)key; 注意：这两个方法默认的实现会抛出异常，子类必须重写才能使用。 - (void)setNilValueForKey:(NSString *)key; 将成员变量置为nil - (NSDictionary )dictionaryWithValuesForKeys:(NSArray )keys; 根据键值获取键值对字典 - (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues; 通过字典对成员变量同意赋值，经常使用 二、NSKeyValueObservingCustomization（KVO）KVO是一种消息监听机制，可以在某个量发生变化的时候将消息传送给监听者，因此广泛用于传值，界面低耦合等逻辑中。KVO机制的核心是以下三个方法： - (void)addObserver:(NSObject )observer forKeyPath:(NSString )keyPath options:(NSKeyValueObservingOptions)options context:(void *)context; 使用这个方法注册一个监听者，参数解释如下： observer：监听者对象 keyPath：监听的参数 options：监听选项 context：参数传递 监听的选项枚举如下： 12345678typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123; NSKeyValueObservingOptionNew = 0x01,//回调的字典中存放新值 NSKeyValueObservingOptionOld = 0x02,//回调的字典中存放旧值 NSKeyValueObservingOptionInitial ,//值改变前进行回调 NSKeyValueObservingOptionPrior//改变前后都进行回调&#125;;//回调字典后面会解释 - (void)removeObserver:(NSObject )observer forKeyPath:(NSString )keyPath context:(void )context ;- (void)removeObserver:(NSObject )observer forKeyPath:(NSString *)keyPath; 这两个方法都是用来移除监听者 - (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary )change context:(void *)context; 这个方法是监听对象数据改变时回调的方法，change是一个字典，字典中根据监听的选项不同，存放不同的值（新或者旧）。context是传递的参数。 代码示例： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. model = [[Model alloc]init]; //添加监听者 [model addObserver:self forKeyPath:@&quot;str&quot; options:NSKeyValueObservingOptionNew context:@&quot;321&quot;]; [model setValue:@&quot;qw&quot; forKey:@&quot;str&quot;];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if ([keyPath isEqualToString:@&quot;str&quot;]) &#123; NSLog(@&quot;%@&quot;,context); &#125;&#125; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UITableViewCell使用详解","slug":"44iOS UITableViewCell使用详解","date":"2015-05-03T16:00:00.000Z","updated":"2021-06-24T11:23:49.828Z","comments":true,"path":"2015/05/04/44iOS UITableViewCell使用详解/","link":"","permalink":"http://huishao.cc/2015/05/04/44iOS UITableViewCell使用详解/","excerpt":"","text":"iOS中UITableViewCell使用详解- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier; Cell的初始化方法，可以设置一个风格和标识符，风格的枚举如下： 123456typedef NS_ENUM(NSInteger, UITableViewCellStyle) &#123; UITableViewCellStyleDefault, // 默认风格，自带标题和一个图片视图，图片在左 UITableViewCellStyleValue1, // 只有标题和副标题 副标题在右边 UITableViewCellStyleValue2, // 只有标题和副标题，副标题在左边标题的下边 UITableViewCellStyleSubtitle // 自带图片视图和主副标题，主副标题都在左边，副标题在下&#125;; @property (nonatomic, readonly, retain) UIImageView *imageView; 图片视图，风格允许时才会创建 @property (nonatomic, readonly, retain) UILabel *textLabel; 标题标签 @property (nonatomic, readonly, retain) UILabel *detailTextLabel; 副标题标签 @property (nonatomic, readonly, retain) UIView *contentView; 容纳视图，任何cell的子视图都应该添加在这个上面 @property (nonatomic, retain) UIView *backgroundView; 背景视图 @property (nonatomic, retain) UIView *selectedBackgroundView; 选中状态下的背景视图 @property (nonatomic, retain) UIView *multipleSelectionBackgroundView; 多选选中时的背景视图 @property (nonatomic, readonly, copy) NSString *reuseIdentifier; cell的标识符 - (void)prepareForReuse; 当被重用的cell将要显示时，会调用这个方法，这个方法最大的用武之地是当你自定义的cell上面有图片时，如果产生了重用，图片可能会错乱（当图片来自异步下载时及其明显），这时我们可以重写这个方法把内容抹掉。 @property (nonatomic) UITableViewCellSelectionStyle selectionStyle; cell被选中时的风格，枚举如下： 123456typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123; UITableViewCellSelectionStyleNone,//无 UITableViewCellSelectionStyleBlue,//蓝色 UITableViewCellSelectionStyleGray,//灰色 UITableViewCellSelectionStyleDefault//默认 为蓝色&#125;; @property (nonatomic, getter=isSelected) BOOL selected; 设置cell是否选中状态 @property (nonatomic, getter=isHighlighted) BOOL highlighted; 设置cell是否高亮状态 - (void)setSelected:(BOOL)selected animated:(BOOL)animated; - (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated; 与上面的两个属性对应 @property (nonatomic, readonly) UITableViewCellEditingStyle editingStyle; 获取cell的编辑状态，枚举如下 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone,//无编辑 UITableViewCellEditingStyleDelete,//删除编辑 UITableViewCellEditingStyleInsert//插入编辑&#125;; @property (nonatomic) BOOL showsReorderControl; 设置是否显示cell自带的自动排序控件 注意：要让cell实现拖动排序的功能，除了上面设置为YES，还需实现代理中的如下方法： -(BOOL)tableView:(UITableView )tableView canMoveRowAtIndexPath:(NSIndexPath )indexPath{ return YES; } -(void)tableView:(UITableView )tableView moveRowAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{ } @property (nonatomic) BOOL shouldIndentWhileEditing; 设置编辑状态下是否显示缩进 @property (nonatomic) UITableViewCellAccessoryType accessoryType; 设置附件视图的风格(cell最右侧显示的视图) 枚举如下： 1234567typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123; UITableViewCellAccessoryNone, // 没有视图 UITableViewCellAccessoryDisclosureIndicator, // cell右侧显示一个灰色箭头 UITableViewCellAccessoryDetailDisclosureButton, // 显示详情符号和灰色箭头 UITableViewCellAccessoryCheckmark, // cell右侧显示蓝色对号 UITableViewCellAccessoryDetailButton // cell右侧显示一个详情符号&#125;; @property (nonatomic, retain) UIView *accessoryView; 附件视图 @property (nonatomic) UITableViewCellAccessoryType editingAccessoryType; cell编辑时的附件视图风格 @property (nonatomic, retain) UIView *editingAccessoryView; cell编辑时的附件视图 @property (nonatomic) NSInteger indentationLevel; 设置内容区域的缩进级别 @property (nonatomic) CGFloat indentationWidth; 设置每个级别的缩进宽度 @property (nonatomic) UIEdgeInsets separatorInset; 设置分割线的偏移量 @property (nonatomic, getter=isEditing) BOOL editing; - (void)setEditing:(BOOL)editing animated:(BOOL)animated; 设置是否编辑状态 @property(nonatomic, readonly) BOOL showingDeleteConfirmation; 返回是否目前正在显示删除按钮 - (void)willTransitionToState:(UITableViewCellStateMask)state; cell状态将要转换时调用的函数，可以在子类中重写 - (void)didTransitionToState:(UITableViewCellStateMask)state; cell状态已经转换时调用的函数，可以在子类中重写，状态枚举如下： 12345typedef NS_OPTIONS(NSUInteger, UITableViewCellStateMask) &#123; UITableViewCellStateDefaultMask = 0,//默认状态 UITableViewCellStateShowingEditControlMask = 1 &lt;&lt; 0,//编辑状态 UITableViewCellStateShowingDeleteConfirmationMask = 1 &lt;&lt; 1//确认删除状态&#125;; 注意：下面这些方法已经全部在IOS3.0后被废弃了，虽然还有效果，但是会被警告 @property (nonatomic, copy) NSString *text; 设置标题 @property (nonatomic, retain) UIFont *font; 设置字体 @property (nonatomic) NSTextAlignment textAlignment; 设置对其模式 @property (nonatomic) NSLineBreakMode lineBreakMode; 设置断行模式 @property (nonatomic, retain) UIColor *textColor; 设置字体颜色 @property (nonatomic, retain) UIColor *selectedTextColor; 设置选中状态下的字体颜色 @property (nonatomic, retain) UIImage *image; 设置图片 @property (nonatomic, retain) UIImage *selectedImage; 设置选中状态时的图片 @property (nonatomic) BOOL hidesAccessoryWhenEditing; 设置编辑的时候是否隐藏附件视图 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"Objective-C中编写省略参数的多参函数","slug":"43Objective-C中编写省略参数的多参函数","date":"2015-05-03T16:00:00.000Z","updated":"2021-06-24T11:22:42.493Z","comments":true,"path":"2015/05/04/43Objective-C中编写省略参数的多参函数/","link":"","permalink":"http://huishao.cc/2015/05/04/43Objective-C中编写省略参数的多参函数/","excerpt":"","text":"Objective-C中编写省略参数的多参数函数引语：在Object-C中，我们会遇到很多像NSLog这样的函数，其中参数的个数不确定，由程序员自由控制，在初始化数组，字典等方面应用广泛，那么，这类的函数是如何实现的呢？我们怎么编写我们自己的省略参数的函数呢？当然，这不是唯一的多参函数的处理方法，你也可以通过一个字典或者数组传递参数。但C为我们提供的这样的一种机制，无疑是最方便的。 一、了解几个概念va_list C语言中定义的一个指针，用于指向当前的参数。 va_start(ap,param) 这个宏是初始化参数列表，其中第一个参数是va_list对象，第二个参数是参数列表的第一个参数。 va_arg(ap, type) 一个用于取出参数的宏，这个宏的第一个参数是va_list对象，第二个参数是要取出的参数类型。 va_end(ap) 这个宏用于关闭取参列表 二、多参函数的取参原理在编写我们自己的多参函数之前，明白函数的取参原理是十分重要的，首先，函数的参数是被放入我们内存的栈段的，而且放入的顺序是从后往前放入，比如如果一个函数参数如下： void func(int a,int b,int c,int d) 那么传递参数的时候参数d先入栈，接着是c、b、a。如此这样，在取参的时候，根据堆栈的取值原则，则取值顺序为a、b、c、d。所以在原理上，只要我们知道第一个参数的地址和每个参数的类型，我们就可以将参数都取出来。而上面介绍的几个宏，就是帮助我们做这些的。 三、声明与实现省略参数的多参函数“…”这个符号就是我们用来实现省略参数函数的符号。例如我们模拟实现一个log函数如下： 12345678910-(void)myLog:(NSString *)str,...&#123;//省略参数的写法 va_list list;//创建一个列表指针对象 va_start(list, str);//进行列表的初始化，str为省略前的第一个参数，及...之前的那个参数 NSString * temStr = str; while (temStr!=nil) &#123;//如果不是nil，则继续取值 NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*);//返回取到的值，并且让指针指向下一个参数的地址 &#125; va_end(list);//关闭列表指针&#125; 注意，调用时，我们必须在参数的最后加上nil这个判断结束的条件： 1[self myLog:@&quot;312&quot;,@&quot;321&quot;, nil];//必须有nil 四、一点补充细心的你可能发现了，这里的nil是我们在调用函数时手动加上的，可是系统的许多函数在我们调用时，系统直接帮我们加上了参数结尾的那个nil，例如 NSArray * array = [NSArray arrayWithObjects:(id), nil] 这是如何做到的呢？我们只需要在函数的声明里加上一个宏，就可以实现这个功能，修改如下： 12345678910-(void)myLog:(NSString *)str,...NS_REQUIRES_NIL_TERMINATION&#123;//这里加上一个宏 va_list list; va_start(list, str); NSString * temStr = str; while (temStr!=nil) &#123; NSLog(@&quot;%@&quot;,temStr); temStr = va_arg(list, NSString*); &#125; va_end(list);&#125; 顾名思义，这个宏的作用就是在结束位置加上我们需要的nil。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中UIActionSheet使用详解","slug":"42IOS中UIActionSheet使用详解","date":"2015-05-02T16:00:00.000Z","updated":"2021-06-24T09:20:29.141Z","comments":true,"path":"2015/05/03/42IOS中UIActionSheet使用详解/","link":"","permalink":"http://huishao.cc/2015/05/03/42IOS中UIActionSheet使用详解/","excerpt":"","text":"IOS中UIActionSheet使用方法详解一、初始化方法- (instancetype)initWithTitle:(NSString )title delegate:(id)delegate cancelButtonTitle:(NSString )cancelButtonTitle destructiveButtonTitle:(NSString )destructiveButtonTitle otherButtonTitles:(NSString )otherButtonTitles, …; 参数说明： title：视图标题 delegate：设置代理 cancelButtonTitle：取消按钮的标题 destructiveButtonTitle：特殊标记的按钮的标题 otherButtonTitles：其他按钮的标题 二、常用方法和属性介绍@property(nonatomic,copy) NSString *title; 设置标题 @property(nonatomic) UIActionSheetStyle actionSheetStyle; 设置风格，枚举如下： 123456typedef NS_ENUM(NSInteger, UIActionSheetStyle) &#123; UIActionSheetStyleAutomatic = -1, UIActionSheetStyleDefault = UIBarStyleDefault, UIActionSheetStyleBlackTranslucent = UIBarStyleBlackTranslucent, UIActionSheetStyleBlackOpaque = UIBarStyleBlackOpaque,&#125;; - (NSInteger)addButtonWithTitle:(NSString *)title; 添加一个按钮，会返回按钮的索引 - (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex; 获取按钮标题 @property(nonatomic,readonly) NSInteger numberOfButtons; 获取按钮数量 @property(nonatomic) NSInteger cancelButtonIndex; 设置取消按钮的索引值 @property(nonatomic) NSInteger destructiveButtonIndex; 设置特殊标记 @property(nonatomic,readonly,getter=isVisible) BOOL visible; 视图当前是否可见 下面是几种弹出方式，会根据风格不同展现不同的方式 - (void)showFromToolbar:(UIToolbar *)view; - (void)showFromTabBar:(UITabBar *)view; - (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated ; - (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated ; - (void)showInView:(UIView *)view; - (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; 使用代码将视图收回 三、UIActionSheet代理方法- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex; 点击按钮时触发的方法 - (void)willPresentActionSheet:(UIActionSheet *)actionSheet; 视图将要弹出时触发的方法 - (void)didPresentActionSheet:(UIActionSheet *)actionSheet; 视图已经弹出式触发的方法 - (void)actionSheet:(UIActionSheet *)actionSheet willDismissWithButtonIndex:(NSInteger)buttonIndex; 点击按钮后，视图将要收回时触发的方法 - (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex; 点击按钮后，视图已经收回时触发的方法 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIAlertView（警告框）方法总结","slug":"41IOS UIAlertView（警告框）方法总结","date":"2015-04-30T16:00:00.000Z","updated":"2021-06-24T09:18:18.869Z","comments":true,"path":"2015/05/01/41IOS UIAlertView（警告框）方法总结/","link":"","permalink":"http://huishao.cc/2015/05/01/41IOS UIAlertView（警告框）方法总结/","excerpt":"","text":"IOS中UIAlertView(警告框)常用方法总结一、初始化方法- (instancetype)initWithTitle:(NSString )title message:(NSString )message delegate:(id //)delegate cancelButtonTitle:(NSString )cancelButtonTitle otherButtonTitles:(NSString )otherButtonTitles, …;这个方法通过设置一个标题，内容，代理和一些按钮的标题创建警告框，代码示例如下： 12 UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;我的警告框&quot; message:@&quot;这是一个警告框&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil]; [alert show]; 效果如下： 注意：如果按钮数超过两个，将会创建成如下样子： 如果按钮数量超出屏幕显示范围，则会创建类似tableView的效果。 二、属性与方法解析标题属性 @property(nonatomic,copy) NSString *title; 内容属性 @property(nonatomic,copy) NSString *message; 添加一个按钮，返回的是此按钮的索引值 - (NSInteger)addButtonWithTitle:(NSString *)title; 返回根据按钮索引按钮标题 - (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex; 获取按钮数量 @property(nonatomic,readonly) NSInteger numberOfButtons; 设置将某一个按钮设置为取消按钮 @property(nonatomic) NSInteger cancelButtonIndex; 返回其他类型按钮第一个的索引值 @property(nonatomic,readonly) NSInteger firstOtherButtonIndex; 警告框是否可见 @property(nonatomic,readonly,getter=isVisible) BOOL visible; 显现警告框 - (void)show; 代码模拟点击按钮消失触发方法 - (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated; 设置警告框风格 @property(nonatomic,assign) UIAlertViewStyle alertViewStyle; 风格的枚举如下 123456typedef NS_ENUM(NSInteger, UIAlertViewStyle) &#123; UIAlertViewStyleDefault = 0,//默认风格 UIAlertViewStyleSecureTextInput,//密码输入框风格 UIAlertViewStylePlainTextInput,//普通输入框风格 UIAlertViewStyleLoginAndPasswordInput//账号密码框风格&#125;; 这个方法设置文本输入框的索引 - (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex; 三、UIAlertViewDelegate中的方法点击按钮时触发的方法 - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex; 将要展现警告框时触发的方法 - (void)willPresentAlertView:(UIAlertView *)alertView; 已经展现警告框时触发的方法 - (void)didPresentAlertView:(UIAlertView *)alertView; 警告框将要消失时触发的方法 - (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex; 警告框已经消失时触发的方法 - (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex; 设置是否允许第一个按钮不是取消按钮 - (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS调用系统通讯录","slug":"39iOS调用系统通讯录","date":"2015-04-28T16:00:00.000Z","updated":"2021-06-22T03:16:44.607Z","comments":true,"path":"2015/04/29/39iOS调用系统通讯录/","link":"","permalink":"http://huishao.cc/2015/04/29/39iOS调用系统通讯录/","excerpt":"","text":"iOS调用系统通讯录上一篇博客详细介绍了在IOS开发中，我们如何获取通讯录联系人的信息，即对其进行增删改查的操作：http://my.oschina.net/u/2340880/blog/407347。而在一些开发项目中，如果没有特殊需求，并且我们只是需要一些通讯录信息，并不做修改操作，我们完全可以采取另一种更加方便的方式，直接调用系统的通讯录。 首先，导入这个头文件： 1#import &lt;AddressBookUI/AddressBookUI.h&gt; 注意：需要在项目中链接如下两个库： 只需简单的几句代码，就可以弹出系统的通讯录界面： 123 ABPeoplePickerNavigationController * con = [[ABPeoplePickerNavigationController alloc]init]; con.peoplePickerDelegate=self; [self presentViewController:con animated:YES completion:nil]; 点击联系人后执行的方法，我们只需要实现下面的代理方法即可 123-(void)peoplePickerNavigationController:(ABPeoplePickerNavigationController *)peoplePicker didSelectPerson:(ABRecordRef)person&#123; //person参数就是选择的联系人的引用 具体含义和数据获取，在上一篇博客中有详细介绍&#125; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中调用系统拨打电话与发送短信","slug":"40IOS中调用系统拨打电话与发送短信","date":"2015-04-28T16:00:00.000Z","updated":"2021-06-24T03:04:55.230Z","comments":true,"path":"2015/04/29/40IOS中调用系统拨打电话与发送短信/","link":"","permalink":"http://huishao.cc/2015/04/29/40IOS中调用系统拨打电话与发送短信/","excerpt":"","text":"IOS中调用系统拨打电话发送短信一、调用打电话界面[[UIApplication sharedApplication] openURL:[NSURL URLWithString:[NSString stringWithFormat:@”tel://%@”,_phoneNumber]]]; 二、发送短消息界面调用系统的发送短信的界面，需要引入以下头文件： #import &lt;MessageUI/MessageUI.h&gt; 系统短信界面的调用很简单，只需下面几句代码： 12345 MFMessageComposeViewController * con = [[MFMessageComposeViewController alloc]init]; if ([MFMessageComposeViewController canSendText]) &#123; con.recipients=@[_phoneNumber];//电话数组 con.messageComposeDelegate=self; [self presentViewController:con animated:YES completion:nil]; 下面将MessageUI的一些常用方法总结如下： + (BOOL)canSendText 判断是否支持发送文字 + (BOOL)canSendSubject; 判断是否支持发送主题信息 + (BOOL)canSendAttachments; 判断是否支持发送附件 + (BOOL)isSupportedAttachmentUTI:(NSString *)uti; 判断是否支持统一标示附件 - (void)disableUserAttachments; 禁止发送附件 @property(nonatomic,copy) NSArray *recipients; 联系人数组，会显示在发送人列表里 @property(nonatomic,copy) NSString *body; 信息主体内容 @property(nonatomic,copy) NSString *subject; 信息标题 @property(nonatomic,copy, readonly) NSArray *attachments; 信息附件数组 只读的 里面是字典 - (BOOL)addAttachmentURL:(NSURL )attachmentURL withAlternateFilename:(NSString )alternateFilename; 根据URL路径和添加附件，返回YES表示添加成功 - (BOOL)addAttachmentData:(NSData )attachmentData typeIdentifier:(NSString )uti filename:(NSString *)filename; 根据Data数据添加附件 - (void)messageComposeViewController:(MFMessageComposeViewController *)controller didFinishWithResult:(MessageComposeResult)result; MFMessageComposeViewControllerDelegate的代理方法，result会传回来一个结果，枚举如下： 12345678enum MessageComposeResult &#123; //取消发送 MessageComposeResultCancelled, //发送成功 MessageComposeResultSent, //发送失败 MessageComposeResultFailed&#125;; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS代码运行的磨刀石-预编译指令","slug":"37iOS代码运行的磨刀石-预编译指令","date":"2015-04-27T16:00:00.000Z","updated":"2021-06-21T08:37:21.077Z","comments":true,"path":"2015/04/28/37iOS代码运行的磨刀石-预编译指令/","link":"","permalink":"http://huishao.cc/2015/04/28/37iOS代码运行的磨刀石-预编译指令/","excerpt":"","text":"iOS中代码运行的磨刀石–预编译指令所谓预编译，就是程序代码在编译之前，开发工具为我们预先做的一些工作。不要小瞧这些指令，没有它们，我们的代码可能寸步难行。 一、文件包含相关预处理命令#include #include “header” C语言中使用的包含文件的指令””和&lt;&gt;的区别为，””是从当前目录开始寻找文件，&lt;&gt;是从系统库中寻找文件。这两个指令不能使头文件循环引入，也不能重复包含同一个头文件。 #import “header” #import 这两个指令和上面两个作用一样，只是更加智能，智能处理重复包含头文件的问题。 #include_next “header” #include_next 这两个指令是C中的指令，OC也支持，只是很少使用，它的作用是在找到名字匹配的头文件后跳过，寻找下一个相同名字的导入。 二、宏定义宏定义是开发中会经常用到的一个指令了，我们还会将许多简单的函数定义为宏，省去系统压栈的时间，提高代码效率。因为这篇博客的主题是预处理命令，所以宏的用法和高级用法就不再多写了，下次再讨论。 #define 参数1 参数2 定义一个简单的替换宏，不带参数，在预编译阶段，会把所有参数1的地方直接替换为参数2。 #define ADD(x) (x+x) 定义一个带参数的宏，类似带参函数的功能，但也是编译前做简单替换。 三、条件编译条件编译用于判断一个表达式是否成立，成立则进入条件编译。 方式一： #if 表达式 #else #endif 方式二： #if 表达式 #elif 表达式 #endif 方式三: #ifndef 如果没有定义一个宏进行编译 #ifdef 如果定义一个宏进行编译 四、错误，警告的预处理#error 错误 当程序检查到这里时会停止编译，这个命令的作用是在错误的地方禁止编译。 #warning 警告 这个命令并不会影响程序的编译和运行，但是会认为的在这里显示一条警告信息，提醒我们自己。 五、更改文件名和行号在OC中，有一个系统的定义的宏: __LINE__ 这个宏表示当前行的行号，可以打印。 #line number 改变当前行的行号，会影响下面所有的行 #line number “filename” 改变当前行号和编译后的文件名 六、编译器控制指令#pragma 参数 这个预编译指令是最复杂的，用于控制编译器的行为，一般我们开发应用APP是很少用到的，常用的有两种方式： #pragma mark - 信息 为代码加上标注 #pragma message(“信息”) 编译时提示信息 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS获取通讯录联系人信息","slug":"38iOS获取通讯录联系人信息","date":"2015-04-27T16:00:00.000Z","updated":"2021-06-21T08:41:05.248Z","comments":true,"path":"2015/04/28/38iOS获取通讯录联系人信息/","link":"","permalink":"http://huishao.cc/2015/04/28/38iOS获取通讯录联系人信息/","excerpt":"","text":"iOS获取系统通讯录联系人信息一、权限注册随着apple对用户隐私的越来越重视，IOS系统的权限设置也更加严格，在获取系统通讯录之前，我们必须获得用户的授权。权限申请代码示例如下： 12345678910111213141516171819202122232425262728293031 //这个变量用于记录授权是否成功，即用户是否允许我们访问通讯录 int __block tip=0; //声明一个通讯簿的引用 ABAddressBookRef addBook =nil; //因为在IOS6.0之后和之前的权限申请方式有所差别，这里做个判断 if ([[UIDevice currentDevice].systemVersion floatValue]&gt;=6.0) &#123; //创建通讯簿的引用 addBook=ABAddressBookCreateWithOptions(NULL, NULL); //创建一个出事信号量为0的信号 dispatch_semaphore_t sema=dispatch_semaphore_create(0); //申请访问权限 ABAddressBookRequestAccessWithCompletion(addBook, ^(bool greanted, CFErrorRef error) &#123; //greanted为YES是表示用户允许，否则为不允许 if (!greanted) &#123; tip=1; &#125; //发送一次信号 dispatch_semaphore_signal(sema); &#125;); //等待信号触发 dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); &#125;else&#123; //IOS6之前 addBook =ABAddressBookCreate(); &#125; if (tip) &#123; //做一个友好的提示 UIAlertView * alart = [[UIAlertView alloc]initWithTitle:@&quot;温馨提示&quot; message:@&quot;请您设置允许APP访问您的通讯录\\nSettings&gt;General&gt;Privacy&quot; delegate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil]; [alart show]; return; &#125; 几点注意：1、dispatch_semaphore_t三个相关的操作为 dispatch_semaphore_create 创建一个信号 dispatch_semaphore_signal 发送一个信号 dispatch_semaphore_wait 等待信号触发 dispatch_semaphore_create()创建一个信号，后面可以跟一个参数，表示信号量，当信号量正值时，dispatch_semaphore_wait后面的代码会被执行，否则程序将会一直等待在dispatch_semaphore_wait。 dispatch_semaphore_signal的作用是发送一个信号，会使信号量加1，相对的，dispatch_semaphore_wait执行后会使信号量减1. 2、因为是否被授权是在ABAddressBookRequestAccessWithCompletion的block回调中获取的，所以我们需要在外面做一个线程等待。 二、获取通讯录联系人详细信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 //获取所有联系人的数组 CFArrayRef allLinkPeople = ABAddressBookCopyArrayOfAllPeople(addBook); //获取联系人总数 CFIndex number = ABAddressBookGetPersonCount(addBook); //进行遍历 for (NSInteger i=0; i&lt;number; i++) &#123; //获取联系人对象的引用 ABRecordRef people = CFArrayGetValueAtIndex(allLinkPeople, i); //获取当前联系人名字 NSString*firstName=(__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); //获取当前联系人姓氏 NSString*lastName=(__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); //获取当前联系人中间名 NSString*middleName=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonMiddleNameProperty)); //获取当前联系人的名字前缀 NSString*prefix=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonPrefixProperty)); //获取当前联系人的名字后缀 NSString*suffix=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonSuffixProperty)); //获取当前联系人的昵称 NSString*nickName=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonNicknameProperty)); //获取当前联系人的名字拼音 NSString*firstNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonFirstNamePhoneticProperty)); //获取当前联系人的姓氏拼音 NSString*lastNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonLastNamePhoneticProperty)); //获取当前联系人的中间名拼音 NSString*middleNamePhoneic=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonMiddleNamePhoneticProperty)); //获取当前联系人的公司 NSString*organization=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonOrganizationProperty)); //获取当前联系人的职位 NSString*job=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonJobTitleProperty)); //获取当前联系人的部门 NSString*department=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonDepartmentProperty)); //获取当前联系人的生日 NSString*birthday=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonBirthdayProperty)); NSMutableArray * emailArr = [[NSMutableArray alloc]init]; //获取当前联系人的邮箱 注意是数组 ABMultiValueRef emails= ABRecordCopyValue(people, kABPersonEmailProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(emails); j++) &#123; [emailArr addObject:(__bridge NSString *)(ABMultiValueCopyValueAtIndex(emails, j))]; &#125; //获取当前联系人的备注 NSString*notes=(__bridge NSString*)(ABRecordCopyValue(people, kABPersonNoteProperty)); //获取当前联系人的电话 数组 NSMutableArray * phoneArr = [[NSMutableArray alloc]init]; ABMultiValueRef phones= ABRecordCopyValue(people, kABPersonPhoneProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(phones); j++) &#123; [phonerr addObject:(__bridge NSString *)(ABMultiValueCopyValueAtIndex(phones, j))]; &#125; //获取创建当前联系人的时间 注意是NSDate NSDate*creatTime=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonCreationDateProperty)); //获取最近修改当前联系人的时间 NSDate*alterTime=(__bridge NSDate*)(ABRecordCopyValue(people, kABPersonModificationDateProperty)); //获取地址 ABMultiValueRef address = ABRecordCopyValue(people, kABPersonAddressProperty); for (int j=0; j&lt;ABMultiValueGetCount(address); j++) &#123; //地址类型 NSString * type = (__bridge NSString *)(ABMultiValueCopyLabelAtIndex(address, j)); NSDictionary * temDic = (__bridge NSDictionary *)(ABMultiValueCopyValueAtIndex(address, j)); //地址字符串，可以按需求格式化 NSString * adress = [NSString stringWithFormat:@&quot;国家:%@\\n省:%@\\n市:%@\\n街道:%@\\n邮编:%@&quot;,[temDic valueForKey:(NSString*)kABPersonAddressCountryKey],[temDic valueForKey:(NSString*)kABPersonAddressStateKey],[temDic valueForKey:(NSString*)kABPersonAddressCityKey],[temDic valueForKey:(NSString*)kABPersonAddressStreetKey],[temDic valueForKey:(NSString*)kABPersonAddressZIPKey]]; &#125; //获取当前联系人头像图片 NSData*userImage=(__bridge NSData*)(ABPersonCopyImageData(people)); //获取当前联系人纪念日 NSMutableArray * dateArr = [[NSMutableArray alloc]init]; ABMultiValueRef dates= ABRecordCopyValue(people, kABPersonDateProperty); for (NSInteger j=0; j&lt;ABMultiValueGetCount(dates); j++) &#123; //获取纪念日日期 NSDate * data =(__bridge NSDate*)(ABMultiValueCopyValueAtIndex(dates, j)); //获取纪念日名称 NSString * str =(__bridge NSString*)(ABMultiValueCopyLabelAtIndex(dates, j)); NSDictionary * temDic = [NSDictionary dictionaryWithObject:data forKey:str]; [dateArr addObject:temDic]; &#125; 一点扩展：相同的方法，可以获取关联人信息，社交信息，邮箱信息，各种类型的电话信息，字段如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //相关人，组织字段const ABPropertyID kABPersonKindProperty; const CFNumberRef kABPersonKindPerson;const CFNumberRef kABPersonKindOrganization;// 电话相关字段AB_EXTERN const ABPropertyID kABPersonPhoneProperty;AB_EXTERN const CFStringRef kABPersonPhoneMobileLabel;AB_EXTERN const CFStringRef kABPersonPhoneIPhoneLabel AB_EXTERN const CFStringRef kABPersonPhoneMainLabel;AB_EXTERN const CFStringRef kABPersonPhoneHomeFAXLabel;AB_EXTERN const CFStringRef kABPersonPhoneWorkFAXLabel;AB_EXTERN const CFStringRef kABPersonPhoneOtherFAXLabelAB_EXTERN const CFStringRef kABPersonPhonePagerLabel;// 即时聊天信息相关字段AB_EXTERN const ABPropertyID kABPersonInstantMessageProperty; AB_EXTERN const CFStringRef kABPersonInstantMessageServiceKey; AB_EXTERN const CFStringRef kABPersonInstantMessageServiceYahoo;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceJabber;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceMSN;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceICQ;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceAIM;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceQQ AB_EXTERN const CFStringRef kABPersonInstantMessageServiceGoogleTalk;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceSkype;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceFacebook;AB_EXTERN const CFStringRef kABPersonInstantMessageServiceGaduGadu;AB_EXTERN const CFStringRef kABPersonInstantMessageUsernameKey; // 个人网页相关字段AB_EXTERN const ABPropertyID kABPersonURLProperty;AB_EXTERN const CFStringRef kABPersonHomePageLabel; //相关人姓名字段AB_EXTERN const ABPropertyID kABPersonRelatedNamesProperty; AB_EXTERN const CFStringRef kABPersonFatherLabel; // FatherAB_EXTERN const CFStringRef kABPersonMotherLabel; // MotherAB_EXTERN const CFStringRef kABPersonParentLabel; // ParentAB_EXTERN const CFStringRef kABPersonBrotherLabel; // BrotherAB_EXTERN const CFStringRef kABPersonSisterLabel; // SisterAB_EXTERN const CFStringRef kABPersonChildLabel; // ChildAB_EXTERN const CFStringRef kABPersonFriendLabel; // FriendAB_EXTERN const CFStringRef kABPersonSpouseLabel; // SpouseAB_EXTERN const CFStringRef kABPersonPartnerLabel; // PartnerAB_EXTERN const CFStringRef kABPersonAssistantLabel; // AssistantAB_EXTERN const CFStringRef kABPersonManagerLabel; // Manager 三、通讯录“写”的相关操作看到上面读取信息的代码，你可能觉得一阵目炫，其实只是字段比较长，逻辑还是很简单的，同样，写的操作与之类似，创建，修改，删除，是我们对通讯录“写”的常用操作。 1、创建一个联系人123456789101112131415161718192021222324252627 //创建一个联系人引用 ABRecordRef person = ABPersonCreate(); NSString *firstName = @&quot;哈&quot;; NSString *lastName = @&quot;哈&quot;; // 电话号码数组 NSArray *phones = [NSArray arrayWithObjects:@&quot;123&quot;,@&quot;456&quot;,nil]; // 电话号码对应的名称 NSArray *labels = [NSArray arrayWithObjects:@&quot;iphone&quot;,@&quot;home&quot;,nil]; //这里的字段和上面的字段完全相同 // 设置名字属性 ABRecordSetValue(person, kABPersonFirstNameProperty,(__bridge CFStringRef)firstName, NULL); // 设置姓氏属性 ABRecordSetValue(person, kABPersonLastNameProperty, (__bridge CFStringRef)lastName, NULL); // 设置生日属性 ABRecordSetValue(person, kABPersonBirthdayProperty,(__bridge CFDateRef)birthday, NULL); // 字典引用 ABMultiValueRef dic =ABMultiValueCreateMutable(kABMultiStringPropertyType); // 添加电话号码与其对应的名称内容 for (int i = 0; i &lt; [phones count]; i ++) &#123; ABMultiValueIdentifier obj = ABMultiValueAddValueAndLabel(dic,(__bridge CFStringRef)[phones objectAtIndex:i], (__bridge CFStringRef)[labels objectAtIndex:i], &amp;obj); &#125; // 设置phone属性 ABRecordSetValue(person, kABPersonPhoneProperty, dic, NULL); // 将新建的联系人添加到通讯录中 ABAddressBookAddRecord(addBook, person, NULL); // 保存通讯录数据 ABAddressBookSave(addBook, NULL); 2、修改联系人修改联系人的操作就是将获取和添加和在一起，先获取到相应的联系人引用，重设其属性字段即可。 3.删除联系人12345678910111213 //获取所有联系人 NSArray *array = (__bridge NSArray*)ABAddressBookCopyArrayOfAllPeople(addBook); // 遍历所有的联系人 for (id obj in array) &#123; ABRecordRef people = (__bridge ABRecordRef)obj; NSString *firstName = (__bridge NSString*)ABRecordCopyValue(people, kABPersonFirstNameProperty); NSString *lastName = (__bridge NSString*)ABRecordCopyValue(people, kABPersonLastNameProperty); if ([firstName isEqualToString:@&quot;哈&quot;] &amp;&amp;[lastName isEqualToString:@&quot;哈&quot;]) &#123; ABAddressBookRemoveRecord(addBook, people,NULL); &#125; &#125; // 保存修改的通讯录对象 ABAddressBookSave(addBook, NULL); 四、重中之重-关于内存管理上面的代码为了演示方便，创建的全部引用都没有释放，势必是造成内存泄露，在我们用ABAddressBookCreate()创建一个引用对象时，切记无论ARC还MRC，要用CFRelease()进行释放引用，例如上面的例子，我们需要加上这句代码 CFRelease(addBook); 如果你耐心的看到了这里，我想你一定明白了我为什么不在前边的代码里说明这个问题，因为在ARC项目普及的现在，这的确是重中之重。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS(CGGeometry)几何类方法总结","slug":"36iOS(CGGeometry)几何类方法总结","date":"2015-04-26T16:00:00.000Z","updated":"2021-06-21T08:32:55.866Z","comments":true,"path":"2015/04/27/36iOS(CGGeometry)几何类方法总结/","link":"","permalink":"http://huishao.cc/2015/04/27/36iOS(CGGeometry)几何类方法总结/","excerpt":"","text":"iOS开发几何类方法总结CGGeometry.h文件是用C语言实现的一个封装了许多常用几何方法的文件。 一、几个常用结构体struct CGPoint { CGFloat x; CGFloat y; }; 定义一个点，设置x坐标和y坐标 struct CGSize { CGFloat width; CGFloat height; }; 定义一个尺寸，设置宽度和高度 struct CGVector { CGFloat dx; CGFloat dy; }; 定义一个二维矢量 struct CGRect { CGPoint origin; CGSize size; }; 定义一个矩形 二、几个系统定义的量const CGPoint CGPointZero 零点，与CGPointMake(0, 0)等效 const CGSize CGSizeZero 零尺寸，与CGSizeMake(0, 0)等效 const CGRect CGRectZero 零矩形，与CGRectMake(0, 0, 0, 0)等效 const CGRect CGRectNull 空矩形，这个和零矩形并不相同，当我们返回两个不相交矩形的交集时，会返回空矩形。 const CGRect CGRectInfinite 无限的矩形 三、一些常用方法CGPoint CGPointMake(CGFloat x, CGFloat y); 创建一个点 CGSize CGSizeMake(CGFloat width, CGFloat height); 创建一个尺寸 CGVectorMake(CGFloat dx, CGFloat dy); 创建一个矢量 CGRect CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height); 创建一个矩形 CGFloat CGRectGetMinX(CGRect rect); 获得矩形最左边的x值 CGFloat CGRectGetMidX(CGRect rect); 获取矩形中点的x值 CGFloat CGRectGetMaxX(CGRect rect); 获取矩形最右端的x值 CGFloat CGRectGetMinY(CGRect rect); 获取矩形最上端的y值 CGFloat CGRectGetMidY(CGRect rect); 获取矩形中心点的y值 CGFloat CGRectGetMaxY(CGRect rect); 获取矩形最下端的y值 CGFloat CGRectGetWidth(CGRect rect); 获取矩形宽度 CGFloat CGRectGetHeight(CGRect rect); 获取矩形高度 bool CGPointEqualToPoint(CGPoint point1, CGPoint point2); 判断两个点是否相等 bool CGSizeEqualToSize(CGSize size1, CGSize size2); 判断两个尺寸是否相等 bool CGRectEqualToRect(CGRect rect1, CGRect rect2); 判断两个矩形是否相等 CGRect CGRectStandardize(CGRect rect); 根据一个矩形创建一个标准的矩形 bool CGRectIsEmpty(CGRect rect); 判断是否为零矩形 CGRectIsNull(CGRect rect); 判断是否为空矩形 bool CGRectIsInfinite(CGRect rect); 判断是否为无限矩形 CGRect CGRectInset(CGRect rect, CGFloat dx, CGFloat dy); 创建一个内嵌的矩形，中心和rect参数的中心一样，dx，dy对应内嵌的宽度和高度 比如：CGRect rect= CGRectInset(CGRectMake(0, 0, 100, 100), 10, 10); 会创建出的rect为（10，10，80，80），dx，dy也可以为负值，则是创建出来的矩形会大于原矩形范围。 CGRect CGRectIntegral(CGRect rect) 根据一个矩形，返回四个参数都是整数的矩形 CGRect CGRectUnion(CGRect r1, CGRect r2); 返回两个矩形的并集 CGRect CGRectIntersection(CGRect r1, CGRect r2); 返回两个矩形的交集，如果没有交集，返回空矩形 CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy); 返回一个矩形，偏移量相对于rect void CGRectDivide(CGRect rect, CGRect slice, CGRect remainder, CGFloat amount, CGRectEdge edge); 这个函数用来分割矩形，参数rect是源矩形，slice和remainder是分割后的两部分矩形，amount是分割线，edge是分割选项。 注意：1、edge是一个宏，定义了分割的方式如下： 12345678910typedef CF_ENUM(uint32_t, CGRectEdge) &#123; //从x的最小处进行垂直分割 CGRectMinXEdge, //从y的最小处进行水平分割 CGRectMinYEdge, //从x最大处进行垂直分割 CGRectMaxXEdge, //从y最大处进行水平分割 CGRectMaxYEdge&#125;; 2、slice和remainder是地址。 3、举例如下，将会分割出两个矩形分别为(40,0,60,100)(0,0,40,100); 1234CGRect rect = CGRectMake(0, 0, 100, 100); CGRect slice ; CGRect remainder; CGRectDivide(rect, &amp;slice, &amp;remainder, 60, CGRectMaxXEdge); bool CGRectContainsPoint(CGRect rect, CGPoint point); 判断点是否在矩形内 bool CGRectContainsRect(CGRect rect1, CGRect rect2); 判断矩形1是否包含矩形2 bool CGRectIntersectsRect(CGRect rect1, CGRect rect2); 判断矩形1和矩形2是否相交 CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point); 返回一个表示点的字典 bool CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point); 将字典转换为点 CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size); 返回一个表示尺寸的字典 bool CGSizeMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGSize *size) ; 将字典转换为尺寸 CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect); 返回一个表示矩形的字典 bool CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect); 将字典转化为矩形 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中JSON数据的解析","slug":"35iOS中JSON数据的解析","date":"2015-04-26T16:00:00.000Z","updated":"2021-06-21T08:23:28.466Z","comments":true,"path":"2015/04/27/35iOS中JSON数据的解析/","link":"","permalink":"http://huishao.cc/2015/04/27/35iOS中JSON数据的解析/","excerpt":"","text":"iOS中JSON数据解析官方为我们提供的解析JSON数据的类是NSJSONSerialization，首先我们先来看下这个类的几个方法： + (BOOL)isValidJSONObject:(id)obj; 判断一个数据对象是否可以转化为JSON数据 + (NSData *)dataWithJSONObject:(id)obj options:(NSJSONWritingOptions)opt error:(NSError **)error; 将JSON数据写为NSData数据，其中opt参数的枚举如下，这个参数可以设置，也可以不设置，如果设置，则会输出视觉美观的JSON数据，否则输出紧凑的JSON数据。 123typedef NS_OPTIONS(NSUInteger, NSJSONWritingOptions) &#123; NSJSONWritingPrettyPrinted = (1UL &lt;&lt; 0)&#125; + (id)JSONObjectWithData:(NSData *)data options:(NSJSONReadingOptions)opt error:(NSError **)error; 这个方法是解析中数据的核心方法，data是JSON数据对象，可以设置一个opt参数，具体用法如下： 12345678typedef NS_OPTIONS(NSUInteger, NSJSONReadingOptions) &#123; //将解析的数组和字典设置为可变对象 NSJSONReadingMutableContainers = (1UL &lt;&lt; 0), //将解析数据的子节点创建为可变字符串对象 NSJSONReadingMutableLeaves = (1UL &lt;&lt; 1), //允许解析对象的最上层不是字典或者数组 NSJSONReadingAllowFragments = (1UL &lt;&lt; 2)&#125; + (NSInteger)writeJSONObject:(id)obj toStream:(NSOutputStream *)stream options:(NSJSONWritingOptions)opt error:(NSError **)error; 将JSON数据写入到输出流，返回的是写入流的字节数 + (id)JSONObjectWithStream:(NSInputStream *)stream options:(NSJSONReadingOptions)opt error:(NSError **)error; 从输入流读取JSON数据 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中使用像素位图(CGImageRef)对图片进行处理","slug":"34iOS中使用像素位图(CGImageRef)对图片进行处理","date":"2015-04-25T16:00:00.000Z","updated":"2021-06-21T05:51:24.579Z","comments":true,"path":"2015/04/26/34iOS中使用像素位图(CGImageRef)对图片进行处理/","link":"","permalink":"http://huishao.cc/2015/04/26/34iOS中使用像素位图(CGImageRef)对图片进行处理/","excerpt":"","text":"iOS中对图片进行重绘处理的方法总结一、CGImageRef是什么CGImageRef是定义在QuartzCore框架中的一个结构体指针，用C语言编写。在CGImage.h文件中，我们可以看到下面的定义： 1typedef struct CGImage *CGImageRef; CGImageRef 和 struct CGImage * 是完全等价的。这个结构用来创建像素位图，可以通过操作存储的像素位来编辑图片。 QuartzCore这个框架是可移植的。 二、CGImageRef相关的一些方法解析CFTypeID CGImageGetTypeID(void) 这个方法返回的是一个编号，每个Core Foundation框架中得结构都会有一个这样的编号，CFTypeID定义如下： 1234567891011#if __LLP64__typedef unsigned long long CFTypeID;typedef unsigned long long CFOptionFlags;typedef unsigned long long CFHashCode;typedef signed long long CFIndex;#elsetypedef unsigned long CFTypeID;typedef unsigned long CFOptionFlags;typedef unsigned long CFHashCode;typedef signed long CFIndex;#endif 这个方法没有特殊的意义，只是一个标识符。 CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent); 通过这个方法，我们可以创建出一个CGImageRef类型的对象，下面分别对参数进行解释： sizt_t是定义的一个可移植性的单位，在64位机器中为8字节，32位位4字节。 width：图片宽度像素 height：图片高度像素 bitsPerComponent：每个颜色的比特数，例如在rgba-32模式下为8 bitsPerPixel：每个像素的总比特数 bytesPerRow：每一行占用的字节数，注意这里的单位是字节 space：颜色空间模式，例如const CFStringRef kCGColorSpaceGenericRGB 这个函数可以返回一个颜色空间对象。 bitmapInfo：位图像素布局，枚举如下： 1234567891011typedef CF_OPTIONS(uint32_t, CGBitmapInfo) &#123; kCGBitmapAlphaInfoMask = 0x1F, kCGBitmapFloatComponents = (1 &lt;&lt; 8), kCGBitmapByteOrderMask = 0x7000, kCGBitmapByteOrderDefault = (0 &lt;&lt; 12), kCGBitmapByteOrder16Little = (1 &lt;&lt; 12), kCGBitmapByteOrder32Little = (2 &lt;&lt; 12), kCGBitmapByteOrder16Big = (3 &lt;&lt; 12), kCGBitmapByteOrder32Big = (4 &lt;&lt; 12)&#125; provider：数据源提供者 decode[]：解码渲染数组 shouldInterpolate：是否抗锯齿 intent：图片相关参数 CGImageRef CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGDataProviderRef provider, const CGFloat decode\\[\\], bool shouldInterpolate) 这个方法用于创建mask图片图层，可以设置其显示部分与不显示部分达到特殊的效果，参数意义同上。 CGImageRef CGImageCreateCopy(CGImageRef image) 这个方法可以复制一个CGImageRef对象 CGImageRef CGImageCreateWithJPEGDataProvider(CGDataProviderRef source, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent) 通过JPEG数据源获取图像 CGImageRef CGImageCreateWithPNGDataProvider(CGDataProviderRef source, const CGFloat decode\\[\\], bool shouldInterpolate, CGColorRenderingIntent intent) 通过PNG数据源获取图像 CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect) 截取图像的一个区域重绘图像 CGImageRef CGImageCreateWithMask(CGImageRef image, CGImageRef mask) 截取mask图像的某一区域重绘 CGImageRef CGImageCreateWithMaskingColors(CGImageRef image, const CGFloat components\\[\\]) 通过颜色分量数组创建位图 CGImageRef CGImageCreateCopyWithColorSpace(CGImageRef image, CGColorSpaceRef space) 通过颜色空间模式复制位图 CGImageRef CGImageRetain(CGImageRef image) 引用+1 void CGImageRelease(CGImageRef image) 引用-1 bool CGImageIsMask(CGImageRef image) 返回是否为Mask图层 size_t CGImageGetWidth(CGImageRef image) 获取宽度像素 size_t CGImageGetHeight(CGImageRef image) 获取高度像素 下面这些方法分别获取相应属性 size_t CGImageGetBitsPerComponent(CGImageRef image) size_t CGImageGetBitsPerPixel(CGImageRef image) size_t CGImageGetBytesPerRow(CGImageRef image) CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)CG_EXTERN CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image) CGDataProviderRef CGImageGetDataProvider(CGImageRef image) const CGFloat *CGImageGetDecode(CGImageRef image) bool CGImageGetShouldInterpolate(CGImageRef image) CGColorRenderingIntent CGImageGetRenderingIntent(CGImageRef image) CGBitmapInfo CGImageGetBitmapInfo(CGImageRef image) 三、应用举例使用CGImageRef进行图片截取 12345678910 //原图片 UIImage * img = [UIImage imageNamed:@&quot;11.11.52.png&quot;]; //转化为位图 CGImageRef temImg = img.CGImage; //根据范围截图 temImg=CGImageCreateWithImageInRect(temImg, CGRectMake(0, 0, 100, 100)); //得到新的图片 UIImage *new = [UIImage imageWithCGImage:temImg]; //释放位图对象 CGImageRelease(temImg); 注意：最后必须要调用这个函数，否则会造成内存泄露 1 CGImageRelease(temImg) 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中通知中心(NSNotificationCenter)的使用总结","slug":"33iOS中通知中心(NSNotificationCenter)的使用总结","date":"2015-04-24T16:00:00.000Z","updated":"2021-06-21T03:05:07.652Z","comments":true,"path":"2015/04/25/33iOS中通知中心(NSNotificationCenter)的使用总结/","link":"","permalink":"http://huishao.cc/2015/04/25/33iOS中通知中心(NSNotificationCenter)的使用总结/","excerpt":"","text":"iOS中通知中心NSNotificationCenter应用总结一、了解几个相关的类1、NSNotification这个类可以理解为一个消息对象，其中有三个成员变量。 这个成员变量是这个消息对象的唯一标识，用于辨别消息对象。 @property (readonly, copy) NSString *name; 这个成员变量定义一个对象，可以理解为针对某一个对象的消息。 @property (readonly, retain) id object; 这个成员变量是一个字典，可以用其来进行传值。 @property (readonly, copy) NSDictionary *userInfo; NSNotification的初始化方法： - (instancetype)initWithName:(NSString )name object:(id)object userInfo:(NSDictionary )userInfo; + (instancetype)notificationWithName:(NSString *)aName object:(id)anObject; + (instancetype)notificationWithName:(NSString )aName object:(id)anObject userInfo:(NSDictionary )aUserInfo; 注意:官方文档有明确的说明，不可以使用init进行初始化 2、NSNotificationCenter这个类是一个通知中心，使用单例设计，每个应用程序都会有一个默认的通知中心。用于调度通知的发送的接受。 添加一个观察者，可以为它指定一个方法，名字和对象。接受到通知时，执行方法。 - (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject; 发送通知消息的方法 - (void)postNotification:(NSNotification *)notification; - (void)postNotificationName:(NSString *)aName object:(id)anObject; - (void)postNotificationName:(NSString )aName object:(id)anObject userInfo:(NSDictionary )aUserInfo; 移除观察者的方法 - (void)removeObserver:(id)observer; - (void)removeObserver:(id)observer name:(NSString *)aName object:(id)anObject; 几点注意： 1、如果发送的通知指定了object对象，那么观察者接收的通知设置的object对象与其一样，才会接收到通知，但是接收通知如果将这个参数设置为了nil，则会接收一切通知。 2、观察者的SEL函数指针可以有一个参数，参数就是发送的死奥西对象本身，可以通过这个参数取到消息对象的userInfo，实现传值。 二、通知的使用流程首先，我们在需要接收通知的地方注册观察者，比如： 1234 //获取通知中心单例对象 NSNotificationCenter * center = [NSNotificationCenter defaultCenter]; //添加当前类对象为一个观察者，name和object设置为nil，表示接收一切通知 [center addObserver:self selector:@selector(notice:) name:@&quot;123&quot; object:nil]; 之后，在我们需要时发送通知消息 1234 //创建一个消息对象 NSNotification * notice = [NSNotification notificationWithName:@&quot;123&quot; object:nil userInfo:@&#123;@&quot;1&quot;:@&quot;123&quot;&#125;]; //发送消息 [[NSNotificationCenter defaultCenter]postNotification:notice]; 我们可以在回调的函数中取到userInfo内容，如下： 123-(void)notice:(id)sender&#123; NSLog(@&quot;%@&quot;,sender);&#125; 打印结果如下： 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS7使用原生API进行二维码和条形码的扫描","slug":"32iOS7使用原生API进行二维码和条形码的扫描","date":"2015-04-23T16:00:00.000Z","updated":"2021-06-21T03:04:00.268Z","comments":true,"path":"2015/04/24/32iOS7使用原生API进行二维码和条形码的扫描/","link":"","permalink":"http://huishao.cc/2015/04/24/32iOS7使用原生API进行二维码和条形码的扫描/","excerpt":"","text":"使用iOS7原生API进行二维码条形码的扫描IOS7之前，开发者进行扫码编程时，一般会借助第三方库。常用的是ZBarSDK，IOS7之后，系统的AVMetadataObject类中，为我们提供了解析二维码的接口。经过测试，使用原生API扫描和处理的效率非常高，远远高于第三方库。 一、使用方法示例官方提供的接口非常简单，代码如下： 123456789101112131415161718192021222324252627282930313233343536@interface ViewController ()&lt;AVCaptureMetadataOutputObjectsDelegate&gt;//用于处理采集信息的代理&#123; AVCaptureSession * session;//输入输出的中间桥梁&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //获取摄像设备 AVCaptureDevice * device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; //创建输入流 AVCaptureDeviceInput * input = [AVCaptureDeviceInput deviceInputWithDevice:device error:nil]; //创建输出流 AVCaptureMetadataOutput * output = [[AVCaptureMetadataOutput alloc]init]; //设置代理 在主线程里刷新 [output setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()]; //初始化链接对象 session = [[AVCaptureSession alloc]init]; //高质量采集率 [session setSessionPreset:AVCaptureSessionPresetHigh]; [session addInput:input]; [session addOutput:output]; //设置扫码支持的编码格式(如下设置条形码和二维码兼容) output.metadataObjectTypes=@[AVMetadataObjectTypeQRCode,AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode128Code]; AVCaptureVideoPreviewLayer * layer = [AVCaptureVideoPreviewLayer layerWithSession:session]; layer.videoGravity=AVLayerVideoGravityResizeAspectFill; layer.frame=self.view.layer.bounds; [self.view.layer insertSublayer:layer atIndex:0]; //开始捕获 [session startRunning];&#125; 之后我们的UI上已经可以看到摄像头捕获的内容，只要实现代理中的方法，就可以完成二维码条形码的扫描： 12345678-(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection&#123; if (metadataObjects.count&gt;0) &#123; //[session stopRunning]; AVMetadataMachineReadableCodeObject * metadataObject = [metadataObjects objectAtIndex : 0 ]; //输出扫描字符串 NSLog(@&quot;%@&quot;,metadataObject.stringValue); &#125;&#125; 二、一些优化通过上面的代码测试，我们可以发现系统的解析处理效率是相当的高，IOS官方提供的API也确实非常强大，然而，我们可以做进一步的优化，将效率更加提高： 首先，AVCaptureMetadataOutput类中有一个这样的属性(在IOS7.0之后可用)： @property(nonatomic) CGRect rectOfInterest; 这个属性大致意思就是告诉系统它需要注意的区域，大部分APP的扫码UI中都会有一个框，提醒你将条形码放入那个区域，这个属性的作用就在这里，它可以设置一个范围，只处理在这个范围内捕获到的图像的信息。如此一来，可想而知，我们代码的效率又会得到很大的提高，在使用这个属性的时候。需要几点注意： 1、这个CGRect参数和普通的Rect范围不太一样，它的四个值的范围都是0-1，表示比例。 2、经过测试发现，这个参数里面的x对应的恰恰是距离左上角的垂直距离，y对应的是距离左上角的水平距离。 3、宽度和高度设置的情况也是类似。 3、举个例子如果我们想让扫描的处理区域是屏幕的下半部分，我们这样设置 1output.rectOfInterest=CGRectMake(0.5,0,0.5, 1); 具体apple为什么要设计成这样，或者是这个参数我的用法那里不对，还需要了解的朋友给个指导。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中使用本地通知为你的APP添加提示用户功能","slug":"31iOS中使用本地通知为你的APP添加提示用户功能","date":"2015-04-22T16:00:00.000Z","updated":"2021-06-21T02:28:44.460Z","comments":true,"path":"2015/04/23/31iOS中使用本地通知为你的APP添加提示用户功能/","link":"","permalink":"http://huishao.cc/2015/04/23/31iOS中使用本地通知为你的APP添加提示用户功能/","excerpt":"","text":"iOS中使用本地通知为你的APP添加提示用户功能首先，我们先要明白一个概念，这里的本地通知是UILocalNotification类，和系统的NSNotificationCenter通知中心是完全不同的概念。 一、我们可以通过本地通知做什么通知，实际上是由IOS系统管理的一个功能，比如某些后台应用做了某项活动需要我们处理、已经退出的应用在某个时间提醒我们唤起等等，如果注册了通知，系统都会在通知触发时给我们发送消息。由此，我们可以通过系统给我们的APP添加通知用户的功能，并且应用非常广泛。例如，闹种类应用，有按时签到相似功能的应用。下面，我们就来介绍如何注册并且设置一个本地通知。 二、了解UILocalNotification类顾名思义，这个类就是我们需要使用的本地通知类，先来看它的几个属性： 设置系统发送通知的时间(如果是过去的时间或者0，则会立刻发起通知) @property(nonatomic,copy) NSDate *fireDate; 设置时间的时区 @property(nonatomic,copy) NSTimeZone *timeZone; 设置周期性通知 @property(nonatomic) NSCalendarUnit repeatInterval; NSCalendarUnit对象是枚举，设定通知的周期 1234567891011typedef NS_OPTIONS(NSUInteger, NSCalendarUnit) &#123; NSCalendarUnitEra = kCFCalendarUnitEra, NSCalendarUnitYear = kCFCalendarUnitYear, NSCalendarUnitMonth = kCFCalendarUnitMonth, NSCalendarUnitDay = kCFCalendarUnitDay, NSCalendarUnitHour = kCFCalendarUnitHour, NSCalendarUnitMinute = kCFCalendarUnitMinute, NSCalendarUnitSecond = kCFCalendarUnitSecond, NSCalendarUnitWeekday = kCFCalendarUnitWeekday, NSCalendarUnitWeekdayOrdinal = kCFCalendarUnitWeekdayOrdinal, &#125; 设置周期性通知参照的日历表 @property(nonatomic,copy) NSCalendar *repeatCalendar; 下面这两个函数是IOS8的新功能，在用户进去或者离开某一区域时发送通知 @property(nonatomic,copy) CLRegion *region; 设置区域检测通知是否重复(如果为YES，则没次进去出来都会发送，否则只发送一次) @property(nonatomic,assign) BOOL regionTriggersOnce; 设置通知的主体内容 @property(nonatomic,copy) NSString *alertBody; 是否隐藏滑动启动按钮 @property(nonatomic) BOOL hasAction; 设置滑动打开的提示文字 @property(nonatomic,copy) NSString *alertAction; 设置点击通知后启动的启动图片 @property(nonatomic,copy) NSString *alertLaunchImage; 下面这个方法是IOS8的新方法，是iwatch的接口，通知的短标题 @property(nonatomic,copy) NSString *alertTitle; 收到通知时，播放的系统音 @property(nonatomic,copy) NSString *soundName; 设置应用程序Icon头标数字 @property(nonatomic) NSInteger applicationIconBadgeNumber; 用户字典，可用于传递通知消息参数 @property(nonatomic,copy) NSDictionary *userInfo; 注意：这个字符串是系统默认的提示音 NSString *const UILocalNotificationDefaultSoundName; 三、本地通知的设计流程首先，想让我们的APP实现本地通知功能，必须得到用户的授权，在Appdelegate中实现如下代码： 12345678910- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //如果已经得到授权，就直接添加本地通知，否则申请询问授权 if ([[UIApplication sharedApplication]currentUserNotificationSettings].types!=UIUserNotificationTypeNone) &#123; [self addLocalNotification]; &#125;else&#123; [[UIApplication sharedApplication]registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]]; &#125; return YES;&#125; 当用户点击允许或者不允许后，会执行如下代理方法，我们把处理逻辑在其中实现 12345-(void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings&#123; if (notificationSettings.types!=UIUserNotificationTypeNone) &#123; [self addLocalNotification]; &#125;&#125; 添加本地通知的方法： 12345678910111213-(void)addLocalNotification&#123; //定义本地通知对象 UILocalNotification *notification=[[UILocalNotification alloc]init]; //设置调用时间 notification.fireDate=[NSDate dateWithTimeIntervalSinceNow:0];//立即触发 //设置通知属性 notification.alertBody=@&quot;HELLO，我是本地通知哦!&quot;; //通知主体 notification.applicationIconBadgeNumber=1;//应用程序图标右上角显示的消息数 notification.alertAction=@&quot;打开应用&quot;; //待机界面的滑动动作提示 notification.soundName=UILocalNotificationDefaultSoundName;//收到通知时播放的声音，默认消息声音 //调用通知 [[UIApplication sharedApplication] scheduleLocalNotification:notification];&#125; 实现了上面三个步骤，本地通知的发出和接受基本都已完成，还有一些细节我们需要考虑： 应用进入前台后，将Icon上的头标清除： 123-(void)applicationWillEnterForeground:(UIApplication *)application&#123; [[UIApplication sharedApplication]setApplicationIconBadgeNumber:0];//进入前台取消应用消息图标&#125; 当不再需要这个通知时，清除它 1 [[UIApplication sharedApplication] cancelAllLocalNotifications]; 四、获取通知中的用户参数字典在上面，我们提到了一个参数 @property(nonatomic,copy) NSDictionary *userInfo; 我们可以在注册通知时将这个参数设置，然后在收到通知时使用get方法得到，但是这里有两种情况： 1、如果我们的APP在前台或者后台进入前台时-(void)application:(UIApplication )application didReceiveLocalNotification:(UILocalNotification )notification; 这个方法是APP在前台或者后台收到通知进入前台时调用的方法 2、如果我们的APP在关闭状态如果是这种情况，我们只能从下面函数的launchOptions中取到我们想要的参数 - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions; 代码示例如下： 123 //接收通知参数 UILocalNotification *notification=[launchOptions valueForKey:UIApplicationLaunchOptionsLocalNotificationKey]; NSDictionary *userInfo= notification.userInfo; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS UITableView代理方法详解","slug":"29iOS UITableView代理方法详解","date":"2015-04-21T16:00:00.000Z","updated":"2021-06-10T09:02:45.123Z","comments":true,"path":"2015/04/22/29iOS UITableView代理方法详解/","link":"","permalink":"http://huishao.cc/2015/04/22/29iOS UITableView代理方法详解/","excerpt":"","text":"iOS UITableView的代理方法详解一、补充在上一篇博客中，http://my.oschina.net/u/2340880/blog/404605，我将IOS中tableView(表视图)的一些常用方法总结了一下，这篇将tableView的代理方法作了总结，对上一篇博客进行了补充。 二、UITableViewDataSourc（数据源代理）1、必须实现的回调方法返回每个分区的行数 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; 返回每一行的cell - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; 2、可选实现的方法返回分区数(默认为1) - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; 返回每个分区头部的标题 - (NSString )tableView:(UITableView )tableView titleForHeaderInSection:(NSInteger)section; 返回每个分区的尾部标题 - (NSString )tableView:(UITableView )tableView titleForFooterInSection:(NSInteger)section; 设置某行是否可编辑 - (BOOL)tableView:(UITableView )tableView canEditRowAtIndexPath:(NSIndexPath )indexPath; 设置某行是否可以被移动 - (BOOL)tableView:(UITableView )tableView canMoveRowAtIndexPath:(NSIndexPath )indexPath; 设置索引栏标题数组（实现这个方法，会在tableView右边显示每个分区的索引） - (NSArray )sectionIndexTitlesForTableView:(UITableView )tableView; 设置索引栏标题对应的分区 - (NSInteger)tableView:(UITableView )tableView sectionForSectionIndexTitle:(NSString )title atIndex:(NSInteger)index tableView接受编辑时调用的方法 - (void)tableView:(UITableView )tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath )indexPath; 这个方法中的editingStyle参数是一个枚举，代表了cell被编辑的模式，如下： 12345typedef NS_ENUM(NSInteger, UITableViewCellEditingStyle) &#123; UITableViewCellEditingStyleNone,//没有编辑操作 UITableViewCellEditingStyleDelete,//删除操作 UITableViewCellEditingStyleInsert//插入操作&#125;; tableView的cell被移动时调用的方法 - (void)tableView:(UITableView )tableView moveRowAtIndexPath:(NSIndexPath )sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath; 三、UITableViewDelegate（tableView代理）cell将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath *)indexPath; 头视图将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayHeaderView:(UIView )view forSection:(NSInteger)section; 尾视图将要显示时调用的方法 - (void)tableView:(UITableView )tableView willDisplayFooterView:(UIView )view forSection:(NSInteger)section; 和上面的方法对应，这三个方法分别是cell，头视图，尾视图已经显示时调用的方法 - (void)tableView:(UITableView )tableView didEndDisplayingCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath*)indexPath; - (void)tableView:(UITableView )tableView didEndDisplayingHeaderView:(UIView )view forSection:(NSInteger)section; - (void)tableView:(UITableView )tableView didEndDisplayingFooterView:(UIView )view forSection:(NSInteger)section; 设置行高，头视图高度和尾视图高度的方法 - (CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath; - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section; 设置行高，头视图高度和尾视图高度的估计值(对于高度可变的情况下，提高效率) - (CGFloat)tableView:(UITableView )tableView estimatedHeightForRowAtIndexPath:(NSIndexPath )indexPath; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section; - (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section; 设置自定义头视图和尾视图 - (UIView )tableView:(UITableView )tableView viewForHeaderInSection:(NSInteger)section; - (UIView )tableView:(UITableView )tableView viewForFooterInSection:(NSInteger)section; 设置cell是否可以高亮 - (BOOL)tableView:(UITableView )tableView shouldHighlightRowAtIndexPath:(NSIndexPath )indexPath; cell高亮和取消高亮时分别调用的函数 - (void)tableView:(UITableView )tableView didHighlightRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView )tableView didUnhighlightRowAtIndexPath:(NSIndexPath )indexPath; 当即将选中某行和取消选中某行时调用的函数，返回一直位置，执行选中或者取消选中 - (NSIndexPath )tableView:(UITableView )tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath; - (NSIndexPath )tableView:(UITableView )tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath; 已经选中和已经取消选中后调用的函数 - (void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView )tableView didDeselectRowAtIndexPath:(NSIndexPath )indexPath; 设置tableView被编辑时的状态风格，如果不设置，默认都是删除风格 - (UITableViewCellEditingStyle)tableView:(UITableView )tableView editingStyleForRowAtIndexPath:(NSIndexPath )indexPath; 自定义删除按钮的标题 - (NSString )tableView:(UITableView )tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath; 下面这个方法是IOS8中的新方法，用于自定义创建tableView被编辑时右边的按钮，按钮类型为UITableViewRowAction。 - (NSArray )tableView:(UITableView )tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath ; 设置编辑时背景是否缩进 - (BOOL)tableView:(UITableView )tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath )indexPath; 将要编辑和结束编辑时调用的方法 - (void)tableView:(UITableView)tableView willBeginEditingRowAtIndexPath:(NSIndexPath )indexPath; - (void)tableView:(UITableView)tableView didEndEditingRowAtIndexPath:(NSIndexPath )indexPath; 移动特定的某行 - (NSIndexPath )tableView:(UITableView )tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath )sourceIndexPath toProposedIndexPath:(NSIndexPath )proposedDestinationIndexPath; 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITableView","slug":"UITableView","permalink":"http://huishao.cc/tags/UITableView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS8的新特性：简洁易用的毛玻璃效果","slug":"30iOS8的新特性：简洁易用的毛玻璃效果","date":"2015-04-21T16:00:00.000Z","updated":"2021-06-10T09:03:58.590Z","comments":true,"path":"2015/04/22/30iOS8的新特性：简洁易用的毛玻璃效果/","link":"","permalink":"http://huishao.cc/2015/04/22/30iOS8的新特性：简洁易用的毛玻璃效果/","excerpt":"","text":"探寻iOS8的新亮点：毛玻璃效果的简易实现IOS8之前，apple官方并不建议开发者使用类似毛玻璃的模糊效果，也并没有开放相关的接口，大部分的开发者是通过转化CGImage这个类来实现毛玻璃的模糊效果，并且实现的效果也很优秀。在IOS8之后，苹果官方新出了一个类UIVisualEffectView，通过这个类，实现毛玻璃效果变得轻而易举，而且效率非常之高，下面，我们来介绍下这个类的简单用法。 一、了解几个类1、UIVisualEffectView 这个类为我们提供了一个方便的接口，用来展示复杂的图像效果。 2、UIVisualEffect 官方对这个类的解释相当简单，它没有任何方法，只是充当一个帮助UIVisualEffectView创建的对象，是UIBlurEffect和UIVibrancyEffect的父类，或者可以理解，它的功能相当于一个抽象类。 3、UIBlurEffect 这个类是创建模糊效果，也就是毛玻璃效果的类，可以设置风格。 4、UIVibrancyEffect 从这个类的名字就可以看出，这个类是UIBlurEffect的扩展，可以创建出明亮的标签的按钮。 二、开始创建虚化的背景首先，初始化一个UIVisualEffectView对象： - (instancetype)initWithEffect:(UIVisualEffect *)effect; 这个方法里面的参数是UIVisuaEffect对象，我们先用UIBlueEffect的方式来创建： + (UIBlurEffect *)effectWithStyle:(UIBlurEffectStyle)style; 这个方法可以设置一个风格参数，风格枚举如下： 12345typedef NS_ENUM(NSInteger, UIBlurEffectStyle) &#123; UIBlurEffectStyleExtraLight,//高亮的风格 UIBlurEffectStyleLight,//亮化的风格 UIBlurEffectStyleDark//暗化的风格&#125; ; 这些都做好之后，我们需要给这个UIVisualEfffectView对象一个frame，然后直接加到我们想要虚化的背景上，总体代码如下： 123456789 UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleExtraLight]]; //设置虚化度 effectView.alpha=1.0; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 三、UIVisualEffectView的几个属性@property (nonatomic, retain, readonly) UIView *contentView; 这个参数和我们后面将要说的创建明亮的标签和按钮有关，这里先不多介绍。 @property (nonatomic, copy, readonly) UIVisualEffect *effect; 获得UIVissualEffect对象 @property(nonatomic) CGFloat alpha; 这个参数和虚化的程度有关 四、在虚化的背景上创建颜色绚丽的标签我们先来看一个效果，我们在刚才创建的虚化的背景上添加一个标签，代码如下： 12345678910111213UILabel * view2 = [[UILabel alloc]init]; view2.text=@&quot;注意看字体的颜色!&quot;; view2.font=[UIFont boldSystemFontOfSize:32]; view2.frame=CGRectMake(0, 0,300, 100); UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleExtraLight]]; [effectView addSubview:view2]; effectView.alpha=0.8; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 我们换另一种虚化效果来对背景进行虚化： 12345678910111213UILabel * view2 = [[UILabel alloc]init]; view2.text=@&quot;注意看字体的颜色!&quot;; view2.font=[UIFont boldSystemFontOfSize:32]; view2.frame=CGRectMake(0, 0,300, 100); UIImageView * view = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height)]; UIImage * img = [UIImage imageNamed:@&quot;1.jpg&quot;]; UIVisualEffectView * effectView = [[UIVisualEffectView alloc]initWithEffect:[UIVibrancyEffect effectForBlurEffect:[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]]]; [effectView.contentView addSubview:view2]; effectView.alpha=0.8; effectView.frame=CGRectMake(0, 0, self.view.frame.size.width, 200); view.image=img; [view addSubview:effectView]; [self.view addSubview:view]; 效果如下： 现在可以很明白的了解，UIBlurEffect是对整个背景进行虚化，UIVibrancyEffect是对添加的标签等附件进行背景虚化。注意，这些附件，必须加在UIVisualEffectView的contentView里，否则将不起任何作用。 五、一个小控件通过上面的介绍，我们可以发现，在IOS8中创建一个毛玻璃效果是如此的容易，apple官方提供的类也是如此的强大，我们很轻松就可以实现实时变化虚化程度的动画效果，这在以前是非常麻烦和低效的。但是apple还有一个忠告：莫要泛滥的使用虚化，导致很差的用户体验! 最后，和大家分享一个前两天写的小控件，实现的效果是仿IOS8中在桌面下拉会是背景渐变虚化，从顶部会滑出搜索框。如下：可以当做一个demo来参考。 链接地址：http://d.cocoachina.com/code/detail/297393。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS使用Xcode可视化图像编辑功能进行图片拉伸","slug":"27iOS使用xcode可视化图像编辑功能进行图片拉伸","date":"2015-04-20T16:00:00.000Z","updated":"2021-06-10T08:59:39.270Z","comments":true,"path":"2015/04/21/27iOS使用xcode可视化图像编辑功能进行图片拉伸/","link":"","permalink":"http://huishao.cc/2015/04/21/27iOS使用xcode可视化图像编辑功能进行图片拉伸/","excerpt":"","text":"iOS中可视化拉伸图片技巧一、补充在我的另一篇博客http://my.oschina.net/u/2340880/blog/403996中探讨了IOS拉伸图像(UIImage)的几种方法和一些小经验，这篇是一个补充，再将xcode中的另一种可视化拉伸图像的方法的使用介绍给大家。 二、如何使用IOS开发文档中的描述：https://developer.apple.com/library/ios/recipes/xcode_help-image_catalog-1.0/chapters/SlicinganImage.html 1、xcode5的新特性xcode5之后，IOS为我们提供了一个管理图片的新方法Asset Catalogs，简单说来，它相当于一个目录，专门用来管理我们项目中的图片素材，包括Icon和启动页，这样使项目管理更加方便也更加简洁。 创建一个AssetCatalogs：在xcode中新建一个文件，选择AssetCatalogs，如下： 然后我们点开这个包，将图片直接拖入工具区即可： 2、使用AssetCatalogs中的可视化工具进行图片拉伸完成了上面的步骤之后，我们可以对管理的图片进行处理，点击右下角的show Slicing按钮，我们就会进入可视化编辑区，如下： 如上图，有三条竖直线，其中边界的两条分别约束了图片两侧不被拉伸的区域范围，中间虚线和左侧虚线围成的部分，将是被复制拉伸的区域。水平方向的线同理。 很重要的一点：官方文档告诉我们，这个方法只能在iOS 7 或者 OS X v10.10之后使用。效果如下： 3、在xib文件中UIImage的拉伸在xib文件中的UIImageView，在上面加上图片后，可以设置stretching这个属性： 这个属性的四个值：X,Y,Width,Height的取值范围是0-1；X，Y，用来确定一个点，比如我们设置为X=0.1，Y=0.1，则这个点就是图片的左上角开始，水平1/10处和竖直1/10处，设置图片的拉伸点为从这个点开始。后两个参数分别设置图片拉伸区域的宽度和高度，比如我们这样设置：Width=0.8，Height=0.8，则图片拉伸时上下左右各1/10的宽度不会被拉伸，中间部分被拉伸，还是刚才的图片，效果如下： 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中表视图(UITableView)使用详解","slug":"28iOS中表视图(UITableView)使用详解","date":"2015-04-20T16:00:00.000Z","updated":"2021-06-10T09:01:26.033Z","comments":true,"path":"2015/04/21/28iOS中表视图(UITableView)使用详解/","link":"","permalink":"http://huishao.cc/2015/04/21/28iOS中表视图(UITableView)使用详解/","excerpt":"","text":"iOS中UITableView使用总结一、初始化方法- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style; 这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下： 1234typedef NS_ENUM(NSInteger, UITableViewStyle) &#123; UITableViewStylePlain, // 标准的表视图风格 UITableViewStyleGrouped // 分组的表视图风格&#125;; 二、常用属性获取表视图的风格(只读属性) @property (nonatomic, readonly) UITableViewStyle style; 设置表示图代理和数据源代理(代理方法后面讨论) @property (nonatomic, assign) id &lt;UITableViewDataSource> dataSource; @property (nonatomic, assign) id &lt;UITableViewDelegate> delegate; 设置表示图的行高(默认为44) @property (nonatomic)CGFloat rowHeight; 设置分区的头视图高度和尾视图高度(当代理方法没有实现时才有效) @property (nonatomic) CGFloat sectionHeaderHeight; @property (nonatomic) CGFloat sectionFooterHeight; 设置一个行高的估计值(默认为0，表示没有估计,7.0之后可用) @property (nonatomic) CGFloat estimatedRowHeight; 注意：这个属性官方的解释是如果你的tableView的行高是可变的，那么设计一个估计高度可以加快代码的运行效率。 下面这两个属性和上面相似，分别设置分区头视图和尾视图的估计高度(7.0之后可用) @property (nonatomic) CGFloat estimatedSectionHeaderHeight; @property (nonatomic) CGFloat estimatedSectionFooterHeight; 设置分割线的位置 @property (nonatomic) UIEdgeInsets separatorInset; 如果细心，你可能会发现系统默认的tableView的分割线左端并没有顶到边沿。通过这个属性，可以手动设置分割线的位置偏移，比如你向让tableView的分割线只显示右半边，可以如下设置： 12UITableView * tab = [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStylePlain];tab.separatorInset=UIEdgeInsetsMake(0, tab.frame.size.width/2, 0,0); 设置tableView背景view视图 @property(nonatomic, readwrite, retain) UIView *backgroundView; 三、常用方法详解重载tableView - (void)reloadData; 重载索引栏 - (void)reloadSectionIndexTitles; 这个方法常用语新加或者删除了索引类别而无需刷新整个表视图的情况下。 获取分区数 - (NSInteger)numberOfSections; 根据分区获取行数 - (NSInteger)numberOfRowsInSection:(NSInteger)section; 获取分区的大小(包括头视图，所有行和尾视图) - (CGRect)rectForSection:(NSInteger)section; 根据分区分别获取头视图，尾视图和行的高度 - (CGRect)rectForHeaderInSection:(NSInteger)section; - (CGRect)rectForFooterInSection:(NSInteger)section; - (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath; 获取某个点在tableView中的位置信息 - (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point; 获取某个cell在tableView中的位置信息 - (NSIndexPath )indexPathForCell:(UITableViewCell )cell; 根据一个矩形范围返回一个信息数组，数组中是每一行row的位置信息 - (NSArray *)indexPathsForRowsInRect:(CGRect)rect; 通过位置路径获取cell - (UITableViewCell )cellForRowAtIndexPath:(NSIndexPath )indexPath; 获取所有可见的cell - (NSArray *)visibleCells; 获取所有可见行的位置信息 - (NSArray *)indexPathsForVisibleRows; 根据分区获取头视图 - (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section; 根据分区获取尾视图 - (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section; 使表示图定位到某一位置(行) - (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated; 注意：indexPah参数是定位的位置，决定于分区和行号。animated参数决定是否有动画。scrollPosition参数决定定位的相对位置，它使一个枚举，如下： 123456typedef NS_ENUM(NSInteger, UITableViewScrollPosition) &#123; UITableViewScrollPositionNone,//同UITableViewScrollPositionTop UITableViewScrollPositionTop,//定位完成后，将定位的行显示在tableView的顶部 UITableViewScrollPositionMiddle,//定位完成后，将定位的行显示在tableView的中间 UITableViewScrollPositionBottom//定位完成后，将定位的行显示在tableView最下面&#125;; 使表示图定位到选中行 - (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated; 这个函数与上面的非常相似，只是它是将表示图定位到选中的行。 四、tableView操作刷新块的应用在介绍动画块之前，我们先看几个函数： 插入分区 - (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; animation参数是一个枚举，枚举的动画类型如下 12345678910typedef NS_ENUM(NSInteger, UITableViewRowAnimation) &#123; UITableViewRowAnimationFade,//淡入淡出 UITableViewRowAnimationRight,//从右滑入 UITableViewRowAnimationLeft,//从左滑入 UITableViewRowAnimationTop,//从上滑入 UITableViewRowAnimationBottom,//从下滑入 UITableViewRowAnimationNone, //没有动画 UITableViewRowAnimationMiddle, UITableViewRowAnimationAutomatic = 100 // 自动选择合适的动画&#125;; 删除分区 - (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; 重载一个分区 - (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation ; 移动一个分区 - (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection; 插入一些行 - (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 删除一些行 - (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 重载一些行 - (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 移动某行 - (void)moveRowAtIndexPath:(NSIndexPath )indexPath toIndexPath:(NSIndexPath )newIndexPath; 了解了上面几个函数，我们来看什么是操作刷新块： 当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，而然数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。 IOS为我们提供了下面两个函数解决这个问题： 开始块标志 - (void)beginUpdates; 结束快标志 - (void)endUpdates; 我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下： 1234[tab beginUpdates]; [tab deleteRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:1 inSection:0]] withRowAnimation:UITableViewRowAnimationLeft]; [dataArray removeObjectAtIndex:1]; [tab endUpdates]; 注意：不要在这个块中调用reloadData这个方法，它会使动画失效。 五、tableView的编辑操作设置是否是编辑状态(编辑状态下的cell左边会出现一个减号，点击右边会划出删除按钮) @property (nonatomic, getter=isEditing) BOOL editing; - (void)setEditing:(BOOL)editing animated:(BOOL)animated; 设置cell是否可以被选中(默认为YES) @property (nonatomic) BOOL allowsSelection; 设置cell编辑模式下是否可以被选中 @property (nonatomic) BOOL allowsSelectionDuringEditing; 设置是否支持多选 @property (nonatomic) BOOL allowsMultipleSelection; 设置编辑模式下是否支持多选 @property (nonatomic) BOOL allowsMultipleSelectionDuringEditing; 六、选中cell的相关操作获取选中cell的位置信息 - (NSIndexPath *)indexPathForSelectedRow; 获取多选cell的位置信息 - (NSArray *)indexPathsForSelectedRows; 代码手动选中与取消选中某行 - (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition; - (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated; 注意：这两个方法将不会回调代理中的方法。 七、tableView附件的相关方法设置索引栏最小显示行数 @property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount; 设置索引栏字体颜色 @property (nonatomic, retain) UIColor *sectionIndexColor; 设置索引栏背景颜色 @property (nonatomic, retain) UIColor *sectionIndexBackgroundColor; 设置索引栏被选中时的颜色 @property (nonatomic, retain) UIColor *sectionIndexTrackingBackgroundColor; 设置分割线的风格 @property (nonatomic) UITableViewCellSeparatorStyle separatorStyle; 这个风格是一个枚举，如下： 12345typedef NS_ENUM(NSInteger, UITableViewCellSeparatorStyle) &#123; UITableViewCellSeparatorStyleNone,//无线 UITableViewCellSeparatorStyleSingleLine,//有线 UITableViewCellSeparatorStyleSingleLineEtched &#125;; 设置分割线颜色 @property (nonatomic, retain) UIColor *separatorColor; 设置分割线毛玻璃效果(IOS8之后可用) @property (nonatomic, copy) UIVisualEffect *separatorEffect; 注意：这个属性是IOS8之后新的。 设置tableView头视图 @property (nonatomic, retain) UIView *tableHeaderView; 设置tableView尾视图 @property (nonatomic, retain) UIView *tableFooterView; 从复用池中取cell - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier; 获取一个已注册的cell - (id)dequeueReusableCellWithIdentifier:(NSString )identifier forIndexPath:(NSIndexPath )indexPath 从复用池获取头视图或尾视图 - (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier; 通过xib文件注册cell - (void)registerNib:(UINib )nib forCellReuseIdentifier:(NSString )identifier; 通过OC类注册cell - (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier 上面两个方法是IOS6之后的方法。 通过xib文件和OC类获取注册头视图和尾视图 - (void)registerNib:(UINib )nib forHeaderFooterViewReuseIdentifier:(NSString )identifier; - (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *) 关于tableView的代理方法，因为篇幅原因，总结在下一篇博客中。 错误之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS中图片(UIImage)拉伸技巧","slug":"26iOS中图片(UIImage)拉伸技巧","date":"2015-04-19T16:00:00.000Z","updated":"2021-06-10T08:58:17.409Z","comments":true,"path":"2015/04/20/26iOS中图片(UIImage)拉伸技巧/","link":"","permalink":"http://huishao.cc/2015/04/20/26iOS中图片(UIImage)拉伸技巧/","excerpt":"","text":"iOS中图片拉伸技巧与方法总结一、了解几个图像拉伸的函数和方法1、直接拉伸法简单暴力，却是最最常用的方法，直接将图片设置为ImageView的image属性，图片便会随UIImageView对象的大小做自动拉伸。这种拉伸的方法有一个致命的缺陷，它会使图像发生失真与形变。 2、像素点的拉伸- (UIImage *)stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight; 这个函数我们可以用来拉伸类似QQ，微信的聊天气泡背景图，它的两个参数分别leftCapWidth和topCapHeight，这两个参数给定一个坐标，比如： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img stretchableImageWithLeftCapWidth:1 topCapHeight:1]; 这段代码的意思是将图片从左起第2列，上起第2行，坐标为(2,2)的像素点进行复制。将图片进行拉伸。这个方法和上面的方法比起来似乎灵活性更多了，但其也有它的一些局限，如果被拉伸的图片中间也有需要拉伸的像素，这个方法就无能为力了，例如，如下的一张图片，我们需要将其拉伸放大： 便会出现这样的效果： 这明显和我们的意图是不符的，那么，我们可以使用下面的方法。 3、区域的拉伸- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets; 这个函数需要设置一个UIEdgeInsets参数，UIEdgeInsets结构体如下： 123typedef struct UIEdgeInsets &#123; CGFloat top, left, bottom, right; &#125; UIEdgeInsets; 它分别对用了图片进行拉伸的区域距离顶部、左部、下部、右部的像素。比如，一个10*10像素的图片，将UIEdgeInsets参数全部设置为1，则实际拉伸的部分就是中间的8*8的区域的像素。有一点需要注意，这个方法默认使用的拉伸模式是区域复制，比如还是上面的图案，如下代码拉伸： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(1, 1, 1, 1)]; 结果如下： 可以明显的看到中间的虚线，这便是区域复制的杰作。 那么问题又来了，如果某些图片中间有渐变，我们该怎么处理了，来看下一个函数。 4、拉伸模式的设置- (UIImage *)resizableImageWithCapInsets:(UIEdgeInsets)capInsets resizingMode:(UIImageResizingMode)resizingMode; 这个函数和上一个函数相比，唯一的差别是多了一个参数。这个参数是个枚举，如下： 1234typedef NS_ENUM(NSInteger, UIImageResizingMode) &#123; UIImageResizingModeTile,//进行区域复制模式拉伸 UIImageResizingModeStretch,//进行渐变复制模式拉伸&#125;; 现在就明了了，我们只需要设置一下模式，就可以实现渐变拉伸了： 12 UIImage * img= [UIImage imageNamed:@&quot;11.png&quot;]; img = [img resizableImageWithCapInsets:UIEdgeInsetsMake(1, 1, 1, 1) resizingMode:UIImageResizingModeStretch]; 来看一下效果： 二、拉伸的用武之地圆角按钮，空心按钮，渐变的背景，内容可变的标签，聊天气泡等等这样的素材在APP中很可能会多次出现，并且每次出现的尺寸可能还会略微有些差异，如果仅仅依靠美工的素材，恐怕不仅很难达到要求，也会额外增加软件的内存开销，这时，我们使用恰当的拉伸技巧，能使我们的代码更加健壮，APP更加高效。 三、一点小经验你是否注意观察过最细的线？ 看到上面的问句，你可能有些差异。最细的线不就是一像素么？确实，能绘图画出来的最细的实心线确实是一像素，但在一个项目中，我们优秀的美工察觉到无论她把线做的多么细，无论我怎样控制拉伸方法，绘制出的登录框总是没有QQ的细，QQ的框线看起来更加干脆利索。后来索性用绘图画出登录框，结果很不幸，我依然无法将线做到像QQ登录框那样细致。后来偶然试了一种方法，不知原理是否正确，效果总算达到了，当然这也要归功于我们的美工，她将一个图片做的很大，适配最大的分辨率，然后让我手动缩，如此一来，那线就变得非常细。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIImage","slug":"UIImage","permalink":"http://huishao.cc/tags/UIImage/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"iOS中正则表达式的使用","slug":"25iOS中正则表达式的使用","date":"2015-04-18T16:00:00.000Z","updated":"2021-06-10T08:54:22.001Z","comments":true,"path":"2015/04/19/25iOS中正则表达式的使用/","link":"","permalink":"http://huishao.cc/2015/04/19/25iOS中正则表达式的使用/","excerpt":"","text":"正则表达式在iOS开发中的应用正则表达式在字符串查找，替换，检测中的应用非常广泛，正则表达式是什么，有怎样的语法，我的另一篇博客中有详细的介绍：http://my.oschina.net/u/2340880/blog/403508。这里只简单说一下其概念 ，正则表达式是一种语法小巧简单的语言，用来约束一些过滤字符串条的条件。很多开发工具都有支持正则表达式的内容，IOS也不例外，在IOS中NSRegularExpression类就是一个专门来处理正则表达式的类。 一、初始化方法初始化NSRegularExpression的方法有两种，一个init方法和一个类方法。其作用基本是一样的 + (NSRegularExpression )regularExpressionWithPattern:(NSString )pattern options:(NSRegularExpressionOptions)options error:(NSError **)error; - (instancetype)initWithPattern:(NSString *)pattern options:(NSRegularExpressionOptions)options error:(NSError **)error 其中，pattern是正则表达式，options是参数。对于option参数，它是一个枚举，表示正则模式的设置，如下： 123456789typedef NS_OPTIONS(NSUInteger, NSRegularExpressionOptions) &#123; NSRegularExpressionCaseInsensitive = 1 &lt;&lt; 0, //不区分字母大小写的模式 NSRegularExpressionAllowCommentsAndWhitespace = 1 &lt;&lt; 1, //忽略掉正则表达式中的空格和#号之后的字符 NSRegularExpressionIgnoreMetacharacters = 1 &lt;&lt; 2, //将正则表达式整体作为字符串处理 NSRegularExpressionDotMatchesLineSeparators = 1 &lt;&lt; 3, //允许.匹配任何字符，包括换行符 NSRegularExpressionAnchorsMatchLines = 1 &lt;&lt; 4, //允许^和$符号匹配行的开头和结尾 NSRegularExpressionUseUnixLineSeparators = 1 &lt;&lt; 5, //设置\\n为唯一的行分隔符，否则所有的都有效。 NSRegularExpressionUseUnicodeWordBoundaries = 1 &lt;&lt; 6 //使用Unicode TR#29标准作为词的边界，否则所有传统正则表达式的词边界都有效&#125;; 注意：1、NSRegularExpressionCaseInsensitive模式下正则表达式 aBc 会匹配到abc. 2、NSRegularExpressionIgnoreMetacharacters模式下正则表达式a b c 会匹配到abc，正则表达式ab#c会匹配到ab。 3、NSRegularExpressionAllowCommentsAndWhitespace模式下正则表达式\\[a-z\\]，会匹配到\\[a-z\\]。 二、获取查询结果初始化完毕正则表达式的处理类后，我们需要进行正则表达式的查询，IOS官方提供了两种模式： 1、带block模式的方法：- (void)enumerateMatchesInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range usingBlock:(void (^)(NSTextCheckingResult \\result, NSMatchingFlags flags, BOOL *stop))block; 使用举例： 1234NSRegularExpression * regex = [[NSRegularExpression alloc]initWithPattern:@&quot;[a-z]&quot; options:NSRegularExpressionCaseInsensitive error:nil]; [regex enumerateMatchesInString:@&quot;124a&quot; options:NSMatchingReportProgress range:NSMakeRange(0, 4) usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) &#123; NSLog(@&quot;%@&quot;,result); &#125; ]; 注意：1、这个函数的一个参数options是一个枚举，设置回调的方式，如下： 1234567typedef NS_OPTIONS(NSUInteger, NSMatchingOptions) &#123; NSMatchingReportProgress = 1 &lt;&lt; 0, //找到最长的匹配字符串后调用block回调 NSMatchingReportCompletion = 1 &lt;&lt; 1, //找到任何一个匹配串后都回调一次block NSMatchingAnchored = 1 &lt;&lt; 2, //从匹配范围的开始出进行极限匹配 NSMatchingWithTransparentBounds = 1 &lt;&lt; 3, //允许匹配的范围超出设置的范围 NSMatchingWithoutAnchoringBounds = 1 &lt;&lt; 4 //禁止^和$自动匹配行还是和结束&#125;; 2、block回调中的flags枚举对应如下： 1234567typedef NS_OPTIONS(NSUInteger, NSMatchingFlags) &#123; NSMatchingProgress = 1 &lt;&lt; 0, //匹配到最长串是被设置 NSMatchingCompleted = 1 &lt;&lt; 1, //全部分配完成后被设置 NSMatchingHitEnd = 1 &lt;&lt; 2, //匹配到设置范围的末尾时被设置 NSMatchingRequiredEnd = 1 &lt;&lt; 3, //当前匹配到的字符串在匹配范围的末尾时被设置 NSMatchingInternalError = 1 &lt;&lt; 4 //由于错误导致的匹配失败时被设置 &#125;; 3、还有一点需要注意，就是那个bool值stop，我们可以在block块中设置它为YES，之后便会停止查找。 2、非block的方法这个方法会返回一个结果数组，将所有匹配的结果返回 - (NSArray )matchesInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法会返回匹配到得字符串的个数 - (NSUInteger)numberOfMatchesInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法会返回第一个查询到得结果，这个NSTextCheckingResult对象中有一个range属性，可以得到匹配到的字符串的范围。 - (NSTextCheckingResult )firstMatchInString:(NSString )string options:(NSMatchingOptions)options range:(NSRange)range; 这个方法直接返回匹配到得范围，NSRange。 - (NSRange)rangeOfFirstMatchInString:(NSString *)string options:(NSMatchingOptions)options range:(NSRange)range; 三、一个辅助方法在NSRegularExpression类中还提供了一个辅助方法： + (NSString )escapedPatternForString:(NSString )string; 它可以帮助我们将正则表达式加上”\\“进行保护，将元字符转化成字面值。 到此，在IOS中正则表达式的基本用法就介绍完了，希望正则表达式的应用，能为你的项目节省更多时间。 疏漏之处 欢迎指正 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"分分钟使用正则表达式","slug":"24分分钟使用正则表达式","date":"2015-04-18T16:00:00.000Z","updated":"2021-06-10T08:53:07.481Z","comments":true,"path":"2015/04/19/24分分钟使用正则表达式/","link":"","permalink":"http://huishao.cc/2015/04/19/24分分钟使用正则表达式/","excerpt":"","text":"正则表达式简单语法总结一、什么是正则表达式从概念上来说，正则表达式也是一门小巧而精炼的语言，它可以用来简化检索特定的字符串，替换特定字符等功能，有许多开发语言工具，都内嵌支持正则表达式。那么一个正则表达式，究竟是什么？其实它就是一个字符串，但这个字符串具有特定含义。 二、正则表达式的基础语法1、字面值所谓字面值，就是没有任何转义，查找的对象就是其本身，比如正则表达式 abc ，查找的结果就是返回要查找字符串中 a，b，c三个字母连在一起的字符串。又如，123 就是查找到123这个子串。 2、特殊字符（元字符）（1）句号“.”在正则表达式中表示匹配任意字符，很相似于通配符*。如果我们查找a.b这个正则表达式，我们可以找到所有开头和结尾为a，b，中间是任意字符的字符串，比如abc，adc，a2c等。 （2）字符类（[]）如果你在一个正则表达式中看到有一些字符被[]括号括起来，那么他们的含义将不再是简单的字面值，他们表示某一个被括号中属性约束的字符。比如[123456]，这个正则表达式表示找到1-6中的任意一个字符，又比如a[bd]c，这表示查找abc或者adc。 注意： 1.在字符类中字符的顺序和重复性都不是我们关心的。\\[123\\]和\\[2233111\\]，含义是一模一样的。 2.句号在字符类中表示的就是其本身，\\[.\\]就是查找一个句号。 （3）区间符号（-）如果我们需要查找一个数字，[0123456789]，这样做是可以达到目的的，但这写起非常麻烦，并不符合正则表达式小巧的特性，这时我们可以使用区间符号来简化，[0-9]和上面的式子意义完全一样。同样，我们可以[a-zA-Z]，表示任意一个字母。 注意： 1.区间的范围应该有意义，\\[a-1\\]这样的区间并无任何意义，尽管它在语法上可能没有错误。 2.区间左右两端对应的是字符，并不是数字，比如\\[2-41\\]，这个式子的含义是找到2-4的一个数字或者1，和\\[1-4\\]是一样的。 （4）取反符号（^）“^”在正则表达式中表示取反，这个很好理解，[^a]，表示找到除了a之外的任意字符。[^0-9]，表示找到一个非数字的字符。 注意： 1.^必须在中括号内，及字符类属性中使用。 2.^是将后面的整体作为取反条件的。 （5）简化的字符类某些符号具有和字符类相同的含义： \\d和[0-9]相同 \\w和[0-9A-Za-z_]相同 表示数字，字母或者下划线 \\s表示匹配空格，tab和换行等不可见符。 与此相对的\\D,\\W,\\S，则表示上述条件的取反情况。 （6）乘法集（{}）乘法集的最大用处也是简化正则表达式，用大括号表示。比如，a{2}，表示找到aa这个字符串。 注意： 乘法集是已前面整体为乘法条件的，比如\\[ab\\]{2}，不是简单的比配aa，bb，而是和\\[ab\\]\\[ab\\]含义是相同的，会匹配ab，ba，aa，bb。 （7）乘法集中的区间（,）乘法集和字符类相同，也可以用区间进行简化，但是符号不相同。a{1,3}，表示找到a，aa，aaa这三个字符串。a{0,1}是合法的，表示找到空字符，或者a。 注意： 1.乘法集的&quot;越长越好&quot;属性：乘法集具有这样的特点，比如a{2,4}，如果我搜索myaaaa，它不会找到aa后就停止，而是会找到aaaa。 2.乘法集的&quot;全部获取&quot;属性：比如a{2.4}，如果搜索myaayouaaaa，它会找到aa和aaaa。 3.乘法集支持开区间，a{1,}是合法的，表示找到任何a相连的字符串。 （8）判断符号（？）这个符号的含义和{0,1}完全相同，123?4，表示匹配1234或者124； （9）统配符号（*）这个符号的含义和{0,}相同，比如.* 表示通配一切字符串。 （10）+符号这个符号和{1,}相同。 （11）或符号（|）“|”符号表示或的关系，比如abc|edf，表示找到abc或者def （12）组合（()）小括号在正则表达式中表示组合，比如(a|b|c)d，表示找到ad，bd，cd，可以将小括号的作用理解为优先级。 （13）单词边界（\\b）\\b表示单词的边界，比如\\b[a-z]{3}\\b，表示匹配一个三个字母的小写单词。 （14）行边界（^ $）单单的一个^符号表示的是行的开头，$表示行的结束。 注意： \\[^\\]是非法的，\\[$\\]表示匹配一个$符号。 三、做些小总结上面说了这么多正则表达式的语法规则，我们现在来做下总结： 1、几个概念：1、字面值:直接查找的字符，比如123，avb。 2、字符类：描述字符的一些属性，比如[123],[a-z],\\d,\\w,\\s,.。 3、乘法集：简化表达式，比如{0,3},?,+,*。 4、或和组合：比如(a|b|v)。 5、单词，行的边界\\b ^ $ 2、元字符列表. \\ [ ] { } ? * + | ( ) ^ $ 3、字符类中元字符列表[ ] \\ - ^ 四、一个特别重要的字符最后，还有一个特别特别重要的字符我们没考虑到，如果我们要查找元字符怎么办，在正则表达式中还有一个转义字符”\\“，如果我们要查找. 只要查找\\. 同理\\[\\]是查找”[]“这个字符串。如果要查找”\\“，再加一个转义字符就好:\\\\。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://huishao.cc/categories/正则表达式/"}],"tags":[{"name":"编程珠玑","slug":"编程珠玑","permalink":"http://huishao.cc/tags/编程珠玑/"}],"keywords":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://huishao.cc/categories/正则表达式/"}]},{"title":"iOS 单例设计模式解读","slug":"22iOS 单例设计模式解读","date":"2015-04-16T16:00:00.000Z","updated":"2021-06-10T08:49:14.271Z","comments":true,"path":"2015/04/17/22iOS 单例设计模式解读/","link":"","permalink":"http://huishao.cc/2015/04/17/22iOS 单例设计模式解读/","excerpt":"","text":"iOS 中单例设计模式的解读与用法一、单例的作用顾名思义，单例，即是在整个项目中，这个类的对象只能被初始化一次。它的这种特性，可以广泛应用于某些需要全局共享的资源中，比如管理类，引擎类，也可以通过单例来实现传值。UIApplication、NSUserDefaults等都是IOS中的系统单例。 二、单例的写法单例的写法常用的有两种方式： 方式1、不考虑线程12345678static SingleCase *manager = nil; + (SingleCase *)defaultManager &#123; if (!manager)&#123; SingleCase = [[self alloc] init]; return manager; &#125;&#125; 方式2、考虑线程安全123456789+ (SingleCase *)sharedManager &#123; static SingleCase *ManagerInstance = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; ManagerInstance = [[self alloc] init]; &#125;); return ManagerInstance; &#125; 三、代码的优化通过上面的方法，我们已经可以使用类方法来得到这个单例，但很多时候，项目的工程量很大，还有可能会很多开发者同时参与一个项目的开发，为了安全与管理代码的方便，也为了给不是这个单例的创作者但会用到这个单例的开发人员一些提示，我们通常会重写一些方法： 首先我们自己实现一个alloc方法： 123+(instancetype)myAlloc&#123; return [super allocWithZone:nil];&#125; 将我们的单例实现方法略作修改： 1234567+(ZYHPayManager *)sharedMamager&#123; static ZYHPayManager * manager; if (manager==nil) &#123; manager=[[ZYHPayManager myAlloc]init]; &#125; return manager;&#125; 将一些视图实例化对象的方法重写： 1234567891011121314+(instancetype)alloc&#123; NSAssert(0, @&quot;这是一个单例对象，请使用+(ZYHPayManager *)sharedMamager方法&quot;); return nil;&#125;+(instancetype)allocWithZone:(struct _NSZone *)zone&#123; return [self alloc];&#125;-(id)copy&#123; NSLog(@&quot;这是一个单例对象，copy将不起任何作用&quot;); return self;&#125;+(instancetype)new&#123; return [self alloc];&#125; 注意：这里的alloc使用了断言，让任何视图通过alloc创建对象的程序段断在此处，给程序员提示。copy方法这里只是简单的返回了原对象，并未做任何处理，打印信息给程序员提示。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://huishao.cc/categories/设计模式/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://huishao.cc/categories/设计模式/"}]},{"title":"iOS description与debugDescription在调试程序中的应用","slug":"23iOS description与debugDescription在调试程序中的应用","date":"2015-04-16T16:00:00.000Z","updated":"2021-06-10T08:51:30.216Z","comments":true,"path":"2015/04/17/23iOS description与debugDescription在调试程序中的应用/","link":"","permalink":"http://huishao.cc/2015/04/17/23iOS description与debugDescription在调试程序中的应用/","excerpt":"","text":"iOS 中打印函数description与debugDescription的应用一、description和debugDescription是什么description和debugDescription是NSObject协议中的声明的两个方法，同时NSObject类也实现了这个方法，如果子类没有重写，则会调用父类的description和debugDescription方法。首先，这两个方法适用于程序代码的调试的，当我们调用打印Log时，会向对象发送一个这样的消息。 我们先来看声明部分的代码： 12+ (NSString *)description;+ (NSString *)debugDescription; 这里返回的字符串就是我们打印在控制台显示的信息。 二、NSObject基类中的description方法是如何实现的我们写如下的测试代码： 12 NSObject * objc = [[NSObject alloc]init]; NSLog(@&quot;objc:%@&quot;,objc); 控制台输出的信息如下： 可以看到，方法的实现大致是这样的： 123-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;&lt;%@:%p&gt;&quot;,[self class],&amp;self];&#125; 三、重写description方法通过上面的介绍，我们大致知道description方法的原理了，在程序调试时，我们可以充分利用这个方法带来的便利，大大缩减我们调试程序所需要的时间。例如：创建一个Test类，给它定义两个属性如下： Text.h 12345#import &lt;Foundation/Foundation.h&gt;@interface TestObject : NSObject@property(nonatomic,strong)NSString * name;@property(nonatomic,strong)NSString * age;@end 我们在.m文件中将description方法重写： 123456#import &quot;TestObject.h&quot;@implementation TestObject-(NSString *)description&#123; return [NSString stringWithFormat:@&quot;%@&quot;,@&#123;@&quot;name&quot;:_name,@&quot;age&quot;:_age&#125;];&#125;@end 重写的方法将Test类对象的属性打印了出来，这时我们在调用NSLog函数时，打印结果如下： 是不是很炫酷，如此一来，我们可以将我们基本不会用到的类名和地址转换成打印数据，极大的方便了我们代码的调试工作。 四、description与debugDescription的区别这两个方法的区别仅仅在于调试的位置不同，调用不同的函数。description是我们在程序中打Log会调用的方法，debugDescription则是我们在断点调试时，在控制台使用po命令打印会调用的方法，比如我们重写Test类的这个方法： 123-(NSString *)debugDescription&#123; return [NSString stringWithFormat:@&quot;&lt;%@:%p&gt;:%@&quot;,[self class],&amp;self,@&#123;@&quot;name&quot;:_name,@&quot;age&quot;:_age&#125;];&#125; 然后我们在程序中加个断点运行，在程序断掉之后，我们在调试区输入：po text，回车之后，会出现如下的信息： 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"}],"keywords":[{"name":"iOS逻辑初窥","slug":"iOS逻辑初窥","permalink":"http://huishao.cc/categories/iOS逻辑初窥/"}]},{"title":"Objective-C 中变量的作用域","slug":"21Objective-C 中变量的作用域","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-10T08:47:29.313Z","comments":true,"path":"2015/04/16/21Objective-C 中变量的作用域/","link":"","permalink":"http://huishao.cc/2015/04/16/21Objective-C 中变量的作用域/","excerpt":"","text":"iOS中，修饰变量的关键字有四个，分别是： 1 @public 被这个关键字修饰的变量是完全开放的，只要有这类的对象存在，就可以访问到这个变量。 2 @protected 被这个关键字修饰的变量是受保护的，只有在声明变量的这个类中和它的子类中，可以访问。 3 @private 被这个关键字修饰的变量是私有的，只能在声明这个变量的类中使用，子类也不能使用。 4 @package 这个关键字比较难理解，大致意思是被修饰的变量是封装的，在本框架内可以自由使用，效果和@public 相同，而在框架外不能使用，其子类也不能使用，效果又相当于@private。 因为@package的这种特点，它非常适用于franework框架。 一点扩展： 访问类中的变量，我们可以用-&gt;符号，它和点语法的区别在于，点语法实际上是调用的set与get方法，而-&gt;符号是直接访问变量。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://huishao.cc/tags/Objective-C/"}],"keywords":[{"name":"Objective-C浅探","slug":"Objective-C浅探","permalink":"http://huishao.cc/categories/Objective-C浅探/"}]},{"title":"iOS UIStepper(步进控件)使用总结","slug":"20iOS UIStepper(步进控件)使用总结","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:44:37.596Z","comments":true,"path":"2015/04/16/20iOS UIStepper(步进控件)使用总结/","link":"","permalink":"http://huishao.cc/2015/04/16/20iOS UIStepper(步进控件)使用总结/","excerpt":"","text":"iOS中步进控件的简单使用 初始化控件 1UIStepper * step = [[UIStepper alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器值是否连续触发变化 @property(nonatomic,getter=isContinuous) BOOL continuous; 若设置为YES，则长按会连续触发变化，若设置为NO，只有在按击结束后，才会触发。 设置长按是否一直触发变化 @property(nonatomic) BOOL autorepeat; 若设置为YES，则长按值会一直改变，若设置为NO，则一次点击只会改变一次值 设置控制器的值是否循环(到达边界后，重头开始，默认为NO) @property(nonatomic) BOOL wraps; 设置控制器的值 @property(nonatomic) double value; 设置控制器的最大值和最小值 @property(nonatomic) double minimumValue;//默认为0 @property(nonatomic) double maximumValue; //默认为100 设置控制器的步长 @property(nonatomic) double stepValue; 设置控制器风格颜色 @property(nonatomic,retain) UIColor *tintColor; 设置控制器背景图片 - (void)setBackgroundImage:(UIImage*)image forState:(UIControlState)state; 获取背景图片 - (UIImage*)backgroundImageForState:(UIControlState)state; 通过左右按钮的状态设置分割线的图片 - (void)setDividerImage:(UIImage*)image forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState; 获取分割线图片 - (UIImage*)dividerImageForLeftSegmentState:(UIControlState)state rightSegmentState:(UIControlState)state; 设置和获取加号按钮的图片 - (void)setIncrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)incrementImageForState:(UIControlState)state; 设置和获取减号按钮的图片 - (void)setDecrementImage:(UIImage *)image forState:(UIControlState)state; - (UIImage *)decrementImageForState:(UIControlState)state; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIStepper","slug":"UIStepper","permalink":"http://huishao.cc/tags/UIStepper/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIPageControl(分页控制器) 用法总结","slug":"19iOS UIPageControl(分页控制器) 用法总结","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:43:35.178Z","comments":true,"path":"2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/16/19iOS UIPageControl(分页控制器) 用法总结/","excerpt":"","text":"UIPageControll 是继承于UIControl的一个IOS系统UI控件，可以提供给开发者设计分页效果的功能。 初始化方法 UIPageControl * page = [[UIPageControl alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置控制器页数（默认为0） @property(nonatomic) NSInteger numberOfPages; 设置当前所在页码 @property(nonatomic) NSInteger currentPage; 设置当总页数为1时，是否自动隐藏控制器 @property(nonatomic) BOOL hidesForSinglePage; 设置是否延迟自动更新控制器的当前页码（默认为NO） @property(nonatomic) BOOL defersCurrentPageDisplay; 注意：这个属性如果设置为YES，点击时并不会改变控制器显示的当前页码点，必须手动调用 (void)updateCurrentPageDisplay; 这个方法，才会更新。 更新控制器当前页码 (void)updateCurrentPageDisplay; 通过页数得到控制器大小 (CGSize)sizeForNumberOfPages:(NSInteger)pageCount; 这个属性用于页数会变化的情况下进行大小动态处理 设置控制器页码点得颜色 @property(nonatomic,retain) UIColor *pageIndicatorTintColor; 设置控制器当前所在页码点的颜色 @property(nonatomic,retain) UIColor *currentPageIndicatorTintColor; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIPageControl","slug":"UIPageControl","permalink":"http://huishao.cc/tags/UIPageControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIProgressView控件用法","slug":"18iOS UIProgressView控件用法","date":"2015-04-15T16:00:00.000Z","updated":"2021-06-08T11:42:13.167Z","comments":true,"path":"2015/04/16/18iOS UIProgressView控件用法/","link":"","permalink":"http://huishao.cc/2015/04/16/18iOS UIProgressView控件用法/","excerpt":"","text":"进度条控件是IOS开发中一个简单的系统控件，使用总结如下： 初始化一个进度条： (instancetype)initWithProgressViewStyle:(UIProgressViewStyle)style; 注意：1.用这个方式初始化的进度条系统会默认给一个长度。 2.进度条的长度可以通过frame来设置，但是只有前三个参数有效。 3.风格枚举如下： typedef NS_ENUM(NSInteger, UIProgressViewStyle) { UIProgressViewStyleDefault, // 普通样式 UIProgressViewStyleBar, // 用于工具条的样式}; 设置进度条风格样式 @property(nonatomic) UIProgressViewStyle progressViewStyle; 设置进度条进度(0.0-1.0之间，默认为0.0) @property(nonatomic) float progress; 设置已走过进度的进度条颜色 @property(nonatomic, retain) UIColor* progressTintColor; 设置未走过进度的进度条颜色 @property(nonatomic, retain) UIColor* trackTintColor; 设置进度条已走过进度的背景图案和为走过进度的背景图案(IOS7后好像没有效果了) @property(nonatomic, retain) UIImage* progressImage; @property(nonatomic, retain) UIImage* trackImage; 设置进度条进度和是否动画显示(动画显示会平滑过渡) (void)setProgress:(float)progress animated:(BOOL)animated; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIProgressView","slug":"UIProgressView","permalink":"http://huishao.cc/tags/UIProgressView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISwitch 用法总结","slug":"16iOS UISwitch 用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:39:45.598Z","comments":true,"path":"2015/04/15/16iOS UISwitch 用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/16iOS UISwitch 用法总结/","excerpt":"","text":"iOS 系统开关控件简单使用总结： 初始化： (instancetype)initWithFrame:(CGRect)frame; 这个frame是没有意义的，系统的开关控件大小是确定的。 设置开关开启状态时的颜色 @property(nonatomic, retain) UIColor *onTintColor; 设置开关风格颜色 @property(nonatomic, retain) UIColor *tintColor; 设置开关按钮颜色 @property(nonatomic, retain) UIColor *thumbTintColor; 设置开关开启状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *onImage; 设置开关关闭状态时的图片（注意：在IOS7后不再起任何作用） @property(nonatomic, retain) UIImage *offImage; 开关的状态 @property(nonatomic,getter=isOn) BOOL on; 手动设置开关状态 (void)setOn:(BOOL)on animated:(BOOL)animated; 一点感想：iOS的系统的UISwitch控件虽然定制性很差，配合IOS7之后的扁平化和俭约的风格，在美观上确实不逊色于任何私人定制的开关控件，在没有特殊需求的情况下，对于开关逻辑，这是一个非常不错的UI交互选择。 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISwitch","slug":"UISwitch","permalink":"http://huishao.cc/tags/UISwitch/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISlider用法总结","slug":"15iOS UISlider用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:38:39.900Z","comments":true,"path":"2015/04/15/15iOS UISlider用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/15iOS UISlider用法总结/","excerpt":"","text":"UIslider滑块控件在IOS开发中会常用到，可用于调节音量，字体大小等UI方面的交互，用法总结如下： 初始化一个滑块： 1 UISlider * slider = [[UISlider alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; 设置滑块位置 @property(nonatomic) float value;这个值是介于滑块的最大值和最小值之间的，如果没有设置边界值，默认为0-1； 设置滑块最小边界值（默认为0） @property(nonatomic) float minimumValue; 设置滑块最大边界值（默认为1） @property(nonatomic) float maximumValue; 设置滑块最左端显示的图片： @property(nonatomic,retain) UIImage *minimumValueImage； 设置滑块最右端显示的图片： @property(nonatomic,retain) UIImage *maximumValueImage; 设置滑块值是否连续变化(默认为YES) @property(nonatomic,getter=isContinuous) BOOL continuous; 这个属性设置为YES则在滑动时，其value就会随时变化，设置为NO，则当滑动结束时，value才会改变。 设置滑块左边（小于部分）线条的颜色 @property(nonatomic,retain) UIColor *minimumTrackTintColor； 设置滑块右边（大于部分）线条的颜色 @property(nonatomic,retain) UIColor *maximumTrackTintColor； 设置滑块颜色（影响已划过一端的颜色） @property(nonatomic,retain) UIColor *thumbTintColor； 注意这个属性：如果你没有设置滑块的图片，那个这个属性将只会改变已划过一段线条的颜色，不会改变滑块的颜色，如果你设置了滑块的图片，又设置了这个属性，那么滑块的图片将不显示，滑块的颜色会改变（IOS7） 手动设置滑块的值： - (void)setValue:(float)value animated:(BOOL)animated; 设置滑块的图片： - (void)setThumbImage:(UIImage *)image forState:(UIControlState)state; 设置滑块划过部分的线条图案 - (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state; 设置滑块未划过部分的线条图案 - (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state; 对应的几个get方法 - (UIImage )thumbImageForState:(UIControlState)state;- (UIImage )minimumTrackImageForState:(UIControlState)state;- (UIImage *)maximumTrackImageForState:(UIControlState)state; 对应的设置当前状态的响应属性的方法 @property(nonatomic,readonly) UIImage currentThumbImage;@property(nonatomic,readonly) UIImage currentMinimumTrackImage;@property(nonatomic,readonly) UIImage* currentMaximumTrackImage; 添加触发事件 1[slider addTarget:self action:@selector(log:) forControlEvents:UIControlEventValueChanged]; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISlider","slug":"UISlider","permalink":"http://huishao.cc/tags/UISlider/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIActivityIndicatorView(指示控制器)用法总结","slug":"17iOS UIActivityIndicatorView(指示控制器)用法总结","date":"2015-04-14T16:00:00.000Z","updated":"2021-06-08T11:40:42.975Z","comments":true,"path":"2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","link":"","permalink":"http://huishao.cc/2015/04/15/17iOS UIActivityIndicatorView(指示控制器)用法总结/","excerpt":"","text":"对于UIActivityIndicatorView的使用，我们一般会创建一个背景View,设置一定的透明度，然后将UIActivityIndicatorView贴在背景View上，在我们需要的时候将这个view呼出。 初始化UIActivityIndicatorView (instancetype)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style; 这个风格是一个枚举，如下 typedef NS_ENUM(NSInteger, UIActivityIndicatorViewStyle) { //大号白色 UIActivityIndicatorViewStyleWhiteLarge, //白色 UIActivityIndicatorViewStyleWhite, //灰色 UIActivityIndicatorViewStyleGray,}; 初始化之后，还需要给它一个Frame，但是只有前两个位置参数有效，大小参数将没有任何影响。 设置指示器风格： @property(nonatomic) UIActivityIndicatorViewStyle activityIndicatorViewStyle; 设置指示器是否停止动画时隐藏 @property(nonatomic) BOOL hidesWhenStopped; 设置指示器颜色 @property (readwrite, nonatomic, retain) UIColor *color； 让指示器开始动画 (void)startAnimating; 让指示器停止动画 (void)stopAnimating; 获取指示器动画状态 (BOOL)isAnimating; 学习使用 欢迎转载 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIActivityIndicatorView","slug":"UIActivityIndicatorView","permalink":"http://huishao.cc/tags/UIActivityIndicatorView/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UITextField 使用与方法解读","slug":"14iOS UITextField 使用与方法解读","date":"2015-04-13T16:00:00.000Z","updated":"2021-06-02T08:38:34.799Z","comments":true,"path":"2015/04/14/14iOS UITextField 使用与方法解读/","link":"","permalink":"http://huishao.cc/2015/04/14/14iOS UITextField 使用与方法解读/","excerpt":"","text":"UITextField是IOS开发中用户交互中重要的一个控件，常被用来做账号密码框，输入信息框等。 初始化一个文字框： UITextField * textField = [[UITextField alloc]initWithFrame:CGRectMake(100, 30, 100, 100)]; 设置和获取文字框文字： @property(nonatomic,copy) NSString *text; 通过AttributedString创建和获取文字： @property(nonatomic,copy) NSAttributedString *attributedText； 设置字体颜色属性： @property(nonatomic,retain) UIColor *textColor; 设置字体属性： @property(nonatomic,retain) UIFont *font; 设置字体对齐格式： @property(nonatomic)NSTextAlignment textAlignment; 设置输入框风格： @property(nonatomic) UITextBorderStyle borderStyle; 这个风格是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextBorderStyle) { //没有任何边框 UITextBorderStyleNone, //线性边框 UITextBorderStyleLine, //阴影效果边框 UITextBorderStyleBezel, //原型效果边框 UITextBorderStyleRoundedRect}; 设置默认字体属性 @property(nonatomic,copy) NSDictionary *defaultTextAttributes； 这个属性的设置会影响到全部字体的属性。 设置缺省时显示的灰度字符串 @property(nonatomic,copy) NSString *placeholder; 通过AttributedString设置缺省字符串 @property(nonatomic,copy) NSAttributedString *attributedPlaceholder； 设置是否在开始编辑时清空输入框内容 @property(nonatomic) BOOL clearsOnBeginEditing; 设置字体大小是否随宽度自适应（默认为NO） @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 设置最小字体大小 @property(nonatomic) CGFloat minimumFontSize; 设置背景图片（会被拉伸） @property(nonatomic,retain) UIImage *background; 设置禁用时的背景图片 @property(nonatomic,retain) UIImage *disabledBackground; 是否正在编辑（只读属性） @property(nonatomic,readonly,getter=isEditing) BOOL editing; 是否允许更改字符属性字典 @property(nonatomic) BOOL allowsEditingTextAttributes； 设置属性字典 @property(nonatomic,copy) NSDictionary *typingAttributes； 设置清除按钮的显示模式 @property(nonatomic) UITextFieldViewMode clearButtonMode; 这是一个枚举，如下： typedef NS_ENUM(NSInteger, UITextFieldViewMode) { //从不显示 UITextFieldViewModeNever, //编辑的时候显示 UITextFieldViewModeWhileEditing, //非编辑的时候显示 UITextFieldViewModeUnlessEditing, //任何时候都显示 UITextFieldViewModeAlways}; 设置输入框左边的view @property(nonatomic,retain) UIView *leftView; 设置输入框左视图的显示模式 @property(nonatomic) UITextFieldViewMode leftViewMode; 设置输入框右边的view @property(nonatomic,retain) UIView *rightView; 设置输入框右视图的显示模式 @property(nonatomic) UITextFieldViewMode rightViewMode; 设置输入框成为第一响应时弹出的视图和辅助视图（类似键盘） @property (readwrite, retain) UIView inputView;@property (readwrite, retain) UIView inputAccessoryView; 这个属性设置是否允许再次编辑时在内容中间插入内容 @property(nonatomic) BOOL clearsOnInsertion； 注销第一响应（収键盘） (BOOL)endEditing:(BOOL)force; UITextFieldDelegate 代理中的方法 点击输入框时触发的方法，返回YES则可以进入编辑状态，NO则不能。 (BOOL)textFieldShouldBeginEditing:(UITextField *)textField; 开始编辑时调用的方法 (void)textFieldDidBeginEditing:(UITextField *)textField; 将要结束编辑时调用的方法，返回YES则可以结束编辑状态，NO则不能 (BOOL)textFieldShouldEndEditing:(UITextField *)textField; 结束编辑调用的方法 (void)textFieldDidEndEditing:(UITextField *)textField; 输入字符时调用的方法 (BOOL)textField:(UITextField )textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString )string; 点击清除按钮时调用的函数，返回YES则可以清除，点击NO则不能清除 (BOOL)textFieldShouldClear:(UITextField *)textField; 点击return键触发的函数 (BOOL)textFieldShouldReturn:(UITextField *)textField; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UITextField","slug":"UITextField","permalink":"http://huishao.cc/tags/UITextField/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UISegmentedControl","slug":"13iOS UISegmentedControl","date":"2015-04-12T16:00:00.000Z","updated":"2021-06-02T08:36:44.741Z","comments":true,"path":"2015/04/13/13iOS UISegmentedControl/","link":"","permalink":"http://huishao.cc/2015/04/13/13iOS UISegmentedControl/","excerpt":"","text":"SegmentedControl又被称作分段控制器，是IOS开发中经常用到的一个UI控件。 初始化方法：传入的数组可以是字符串也可以是UIImage对象的图片数组 (instancetype)initWithItems:(NSArray *)items; 设置控件风格： @property(nonatomic) UISegmentedControlStyle segmentedControlStyle 注意：这个属性已经废弃，不再起任何作用，它的枚举如下： typedef NS_ENUM(NSInteger, UISegmentedControlStyle) { UISegmentedControlStylePlain, // large plain UISegmentedControlStyleBordered, // large bordered UISegmentedControlStyleBar, // small button/nav bar style. tintable UISegmentedControlStyleBezeled, // DEPRECATED. Do not use this style.} NS_DEPRECATED_IOS(2_0, 7_0, “The segmentedControlStyle property no longer has any effect”); 设置是否保持选中状态： @property(nonatomic,getter=isMomentary) BOOL momentary; 注意：如果设置为YES，点击结束后，将不保持选中状态，默认为NO 获取标签个数：(只读) @property(nonatomic,readonly) NSUInteger numberOfSegments; 设置标签宽度是否随内容自适应： @property(nonatomic) BOOL apportionsSegmentWidthsByContent； 注意：如果设置为NO，则所有标签宽度一致，为最大宽度。 插入文字标签在index位置： (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated 插入图片标签在index位置 (void)insertSegmentWithImage:(UIImage *)image atIndex:(NSUInteger)segment animated:(BOOL)animated 根据索引删除标签 (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated; 删除所有标签 (void)removeAllSegments; 重设标签标题 (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment; 获取标签标题 (NSString *)titleForSegmentAtIndex:(NSUInteger)segment; 设置标签图片 (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment; 获取标签图片 (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment; 注意：标题的图片只能设置一个 根据索引设置相应标签宽度 (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;注意：如果设置为0.0，则为自适应，默认为此设置。 根据索引获取标签宽度 (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment; 设置标签内容的偏移量 (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment; 注意：这个偏移量指的是标签的文字或者图片 根据索引获取变标签内容的偏移量 (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment; 根据所以设置标签是否有效(默认有效) (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment; 根据索引获取当前标签是否有效 (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment; 设置和获取当前选中的标签索引 @property(nonatomic) NSInteger selectedSegmentIndex; 设置标签风格颜色 @property(nonatomic,retain) UIColor *tintColor; 注意：这个风格颜色会影响标签的文字和图片 设置特定状态下segment的背景图案 (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 注意：UIBarMetrics是一个枚举，如下：(defaulf风格会充满背景) typedef NS_ENUM(NSInteger, UIBarMetrics) { UIBarMetricsDefault, UIBarMetricsCompact, UIBarMetricsDefaultPrompt = 101, // Applicable only in bars with the prompt property, such as UINavigationBar and UISearchBar UIBarMetricsCompactPrompt, UIBarMetricsLandscapePhone NS_ENUM_DEPRECATED_IOS(5_0, 8_0, &quot;Use UIBarMetricsCompact instead&quot;) = UIBarMetricsCompact, UIBarMetricsLandscapePhonePrompt NS_ENUM_DEPRECATED_IOS(7_0, 8_0, &quot;Use UIBarMetricsCompactPrompt&quot;) = UIBarMetricsCompactPrompt, }; 获取背景图案 (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics 设置标签之间分割线的图案 (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 获取标签之间分割线的图案 (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetrics 通过Attribute字符串属性字典设置标签标题 (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state 获取Attribute字符串属性字典 (NSDictionary *)titleTextAttributesForState:(UIControlState)state 自行设置标签内容的偏移量 (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 注意：UIOffset为偏移量，这个结构体中又两个浮点数，分别表示水平量和竖直量；UISegmentedControlSegment类型参数是一个枚举，如下： typedef NS_ENUM(NSInteger, UISegmentedControlSegment) { UISegmentedControlSegmentAny = 0,//所有标签都受影响 UISegmentedControlSegmentLeft = 1, //只有左边部分受到影响 UISegmentedControlSegmentCenter = 2, // 只有中间部分受到影响 UISegmentedControlSegmentRight = 3, // 只有右边部分受到影响 UISegmentedControlSegmentAlone = 4, // 在只有一个标签的时候生效}; 获取自定义偏移量 (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics 添加点击事件 [segmentedControl addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged]; 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UISegmentedControl","slug":"UISegmentedControl","permalink":"http://huishao.cc/tags/UISegmentedControl/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UIButton解读","slug":"12iOS UIButton解读","date":"2015-04-10T16:00:00.000Z","updated":"2021-06-02T08:35:20.122Z","comments":true,"path":"2015/04/11/12iOS UIButton解读/","link":"","permalink":"http://huishao.cc/2015/04/11/12iOS UIButton解读/","excerpt":"","text":"UIButton控件是应用界面中常用的一个控件，用法总结： 一、初始化 UIButton的初始化一般使用其类方法，+ (id)buttonWithType:(UIButtonType)buttonType; 风格的枚举如下： typedef NS_ENUM(NSInteger, UIButtonType) { //用户自定义，无风格 UIButtonTypeCustom = 0, //系统默认风格 UIButtonTypeSystem NS_ENUM_AVAILABLE_IOS(7_0), //一下这三种创建出来的按钮一样，一个蓝色的圆圈，中间有个叹号 UIButtonTypeDetailDisclosure, UIButtonTypeInfoLight, UIButtonTypeInfoDark, //创建+号按钮 UIButtonTypeContactAdd, //废弃 UIButtonTypeRoundedRect = UIButtonTypeSystem,}; 二、属性设置 @property(nonatomic) UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR;//这个属性设置button里内容的偏移量，包括title和image，可以用如下方法设置btn.contentEdgeInsets=UIEdgeInsetsMake(20, 20, 0, 0); @property(nonatomic) UIEdgeInsets titleEdgeInsets;//这个属性设置标题的偏移量@property(nonatomic) BOOL reversesTitleShadowWhenHighlighted;//按钮高亮时，是否改变阴影效果@property(nonatomic) UIEdgeInsets imageEdgeInsets;//图片的偏移量@property(nonatomic)BOOL adjustsImageWhenHighlighted;//设置图片的绘制是否高亮时变暗@property(nonatomic)BOOL adjustsImageWhenDisabled;//设置图片是否轻绘制当按钮禁用时@property(nonatomic)BOOL showsTouchWhenHighlighted;//设置是否显示手指印在按钮高亮的时候@property(nonatomic,retain) UIColor *tintColor NS_AVAILABLE_IOS(5_0);//这个属性会作用于标题和图片，但是如果你是自定义风格的按钮，这个属性将不起任何作用，它只作用于系统的@property(nonatomic,readonly) UIButtonType buttonType;//设置button的风格 三、一些set方法 (void)setTitle:(NSString *)title forState:(UIControlState)state;//设置标题和显示当前标题的按钮状态 (void)setTitleColor:(UIColor *)color forState:(UIControlState)state;//设置标题颜色和显示当前颜色的按钮状态 (void)setTitleShadowColor:(UIColor *)color forState:(UIControlState)state;//设置标题阴影颜色及显示时的状态 (void)setImage:(UIImage *)image forState:(UIControlState)state;//设置按钮图片和显示当前图片时的状态 (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state;//设置按钮背景图片和显示图片时的状态 (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state NS_AVAILABLE_IOS(6_0);//通过AttributeString创建标题 注意：按钮图片设置和背景图片的不同在于： 1、设置图片，如果有标题会和标题并列显示 2、设置背景图片会出现在标题下面 3、图片的偏移量可以设置，背景图片不可以。 四、一些get方法，可以得到上述设置的属性 (NSString *)titleForState:(UIControlState)state; (UIColor *)titleColorForState:(UIControlState)state; (UIColor *)titleShadowColorForState:(UIControlState)state; (UIImage *)imageForState:(UIControlState)state; (UIImage *)backgroundImageForState:(UIControlState)state; (NSAttributedString *)attributedTitleForState:(UIControlState)state NS_AVAILABLE_IOS(6_0); 五、一些只读属性 @property(nonatomic,readonly,retain) NSString currentTitle;@property(nonatomic,readonly,retain) UIColor currentTitleColor;@property(nonatomic,readonly,retain) UIColor currentTitleShadowColor;@property(nonatomic,readonly,retain) UIImage currentImage;@property(nonatomic,readonly,retain) UIImage currentBackgroundImage;@property(nonatomic,readonly,retain) NSAttributedString currentAttributedTitle NS_AVAILABLE_IOS(6_0);//这两个参数需要注意，虽然他们是只读属性不能重新设置，但是我们可以设置label和imageView的相关属性@property(nonatomic,readonly,retain) UILabel titleLabel NS_AVAILABLE_IOS(3_0);@property(nonatomic,readonly,retain) UIImageView imageView NS_AVAILABLE_IOS(3_0); 六、下面这些函数，都会返回一个CGRect 矩形范围 (CGRect)backgroundRectForBounds:(CGRect)bounds;//返回背景大小 (CGRect)contentRectForBounds:(CGRect)bounds;//返回视图大小，包括标题和图片 (CGRect)titleRectForContentRect:(CGRect)contentRect;//返回标题大小 (CGRect)imageRectForContentRect:(CGRect)contentRect;//返回图片大小 关于触发事件，button是继承于UIControl,这里不再叙述。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UIButton","slug":"UIButton","permalink":"http://huishao.cc/tags/UIButton/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS 封装静态库(.a文件)","slug":"11iOS 封装静态库(.a文件)","date":"2015-04-10T16:00:00.000Z","updated":"2021-06-02T08:33:44.701Z","comments":true,"path":"2015/04/11/11iOS 封装静态库(.a文件)/","link":"","permalink":"http://huishao.cc/2015/04/11/11iOS 封装静态库(.a文件)/","excerpt":"","text":"iOS中导入外部文件，一种是将源码导入，一种是导入静态库，有很多第三方库都是以静态库的形式提供给我们使用的，如何制作一个静态库呢？ 一、xCode创建文件时，选择创建静态库文件：cacoaTouchStaticLibrary 创建完成后，我们在里面写我们的方法和实现： .h文件和.m文件 1234#import &lt;Foundation/Foundation.h&gt;@interface MyStaticLibrary : NSObject-(void)myLog;@end 123456#import &quot;MyStaticLibrary.h&quot;@implementation MyStaticLibrary-(void)myLog&#123; NSLog(@&quot;myLog&quot;);&#125;@end 二、生成静态库文件：这里需要将设备选成IOS Device然后 使用command+B进行编译，如果xcode报出这样的一个错误：我们需要在Peoject-&gt;Code Signing -&gt;Code Signing Identity 改成IOS Developer再次编译，成功。然后你会看到，Products中的.a文件由红色编程了黑色。我们右键show in finder，就可以看到编译成功的静态库文件了。 三、合并静态库 在文件夹中，我们看到有两个.a文件，分别用在模拟器调试和真机调试中，如果我们在开发时需要真机模拟器不停的切换，我们可以将这两个静态库文件合并成为一个： 在终端使用：lipo -create -output 命令： 这时，我们的静态库文件就做好了。 三、静态库文件的使用： 将.a和.h文件导入工程，在需要的文件中导入头文件，即可使用。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"静态库","slug":"静态库","permalink":"http://huishao.cc/tags/静态库/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSInvocation应用与理解","slug":"09iOS NSInvocation应用与理解","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:36:47.104Z","comments":true,"path":"2015/04/10/09iOS NSInvocation应用与理解/","link":"","permalink":"http://huishao.cc/2015/04/10/09iOS NSInvocation应用与理解/","excerpt":"","text":"IOS中有一个类型是SEL，它的作用很相似与函数指针，通过performSelector:withObject:函数可以直接调用这个消息。但是perform相关的这些函数，有一个局限性，其参数数量不能超过2个，否则要做很麻烦的处理，与之相对，NSInvocation也是一种消息调用的方法，并且它的参数没有限制。这两种直接调用对象消息的方法，在IOS4.0之后，大多被block结构所取代，只有在很老的兼容性系统中才会使用，简单用法总结如下： 一、初始化与调用 在官方文档中有明确说明，NSInvocation对象只能使用其类方法来初始化，不可使用alloc/init方法。它执行调用之前，需要设置两个方法：setSelector: 和setArgument:atIndex： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog); //创建一个函数签名，这个签名可以是任意的,但需要注意，签名函数的参数数量要和调用的一致。 NSMethodSignature * sig = [NSNumber instanceMethodSignatureForSelector:@selector(init)]; //通过签名初始化 NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; //设置target [invocatin setTarget:self]; //设置selecteor [invocatin setSelector:myMethod]; //消息调用 [invocatin invoke]; &#125;-(void)myLog&#123; NSLog(@&quot;MyLog&quot;);&#125; 注意：签名函数的参数数量要和调用函数的一致。测试后发现，当签名函数参数数量大于被调函数时，也是没有问题的。 调用多参数的方法，我们可以这样写： 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 注意：1、这里设置参数的Index 需要从2开始，因为前两个被selector和target占用。下面这样写也没有任何问题： 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); SEL myMethod2 = @selector(myLog); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; ViewController * view = self; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; [invocatin invoke];&#125;-(void)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c);&#125; 2、这里的传参方式必须是传递参数地址。 二、NSInvocation的返回值 NSInvocation对象，是可以有返回值的，然而这个返回值，并不是其所调用函数的返回值，需要我们手动设置： 1234567891011121314151617181920212223242526272829- (void)viewDidLoad &#123; [super viewDidLoad]; SEL myMethod = @selector(myLog:parm:parm:); NSMethodSignature * sig = [[self class] instanceMethodSignatureForSelector:myMethod]; NSInvocation * invocatin = [NSInvocation invocationWithMethodSignature:sig]; [invocatin setTarget:self]; [invocatin setSelector:myMethod2]; ViewController * view = self; int a=1; int b=2; int c=3; [invocatin setArgument:&amp;view atIndex:0]; [invocatin setArgument:&amp;myMethod2 atIndex:1]; [invocatin setArgument:&amp;a atIndex:2]; [invocatin setArgument:&amp;b atIndex:3]; [invocatin setArgument:&amp;c atIndex:4]; [invocatin retainArguments]; //我们将c的值设置为返回值 [invocatin setReturnValue:&amp;c]; int d; //取这个返回值 [invocatin getReturnValue:&amp;d]; NSLog(@&quot;%d&quot;,d); &#125;-(int)myLog:(int)a parm:(int)b parm:(int)c&#123; NSLog(@&quot;MyLog%d:%d:%d&quot;,a,b,c); return a+b+c;&#125; 注意：这里的操作传递的都是地址。如果是OC对象，也是取地址。 三、关于内存 可以注意到- (void)retainArguments;这个方法，它会将传入的所有参数以及target都retain一遍。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSInvocation","slug":"NSInvocation","permalink":"http://huishao.cc/tags/NSInvocation/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS NSTimer 定时器用法总结","slug":"10iOS NSTimer 定时器用法总结","date":"2015-04-09T16:00:00.000Z","updated":"2021-05-31T03:37:50.677Z","comments":true,"path":"2015/04/10/10iOS NSTimer 定时器用法总结/","link":"","permalink":"http://huishao.cc/2015/04/10/10iOS NSTimer 定时器用法总结/","excerpt":"","text":"NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下： 一、初始化方法：有五种初始化方法，分别是 + (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 123456789101112- (void)viewDidLoad &#123; [super viewDidLoad]; //初始化一个Invocation对象 NSInvocation * invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(init)]]; [invo setTarget:self]; [invo setSelector:@selector(myLog)]; NSTimer * timer = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES]; //加入主循环池中 [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; //开始循环 [timer fire];&#125; + (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo; 1 NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES]; + (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:NO] + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo; 1NSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:@&quot;123&quot; repeats:YES] - (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(id)ui repeats:(BOOL)rep 12 NSTimer * timer = [[NSTimer alloc]initWithFireDate:[NSDate distantPast] interval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode]; 注意：这五种初始化方法的异同： 1、参数repeats是指定是否循环执行，YES将循环，NO将只执行一次。 2、timerWithTimeInterval这两个类方法创建出来的对象如果不用 addTimer: forMode方法手动加入主循环池中，将不会循环执行。并且如果不手动调用fair，则定时器不会启动。 3、scheduledTimerWithTimeInterval这两个方法不需要手动调用fair，会自动执行，并且自动加入主循环池。 4、init方法需要手动加入循环池，它会在设定的启动时间启动。 二、成员变量 @property (copy) NSDate *fireDate; 这是设置定时器的启动时间，常用来管理定时器的启动与停止 1234 //启动定时器 timer.fireDate = [NSDate distantPast]; //停止定时器 timer.fireDate = [NSDate distantFuture]; @property (readonly) NSTimeInterval timeInterval; 这个是一个只读属性，获取定时器调用间隔时间。 @property NSTimeInterval tolerance; 这是7.0之后新增的一个属性，因为NSTimer并不完全精准，通过这个值设置误差范围。 @property (readonly, getter=isValid) BOOL valid; 获取定时器是否有效 @property (readonly, retain) id userInfo; 获取参数信息 三、关于内存释放 如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。所以我们需要这样做： 123456789101112131415161718-(void)dealloc&#123; NSLog(@&quot;dealloc:%@&quot;,[self class]);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; timer= [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog:) userInfo:nil repeats:YES]; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(btn) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn];&#125;-(void)btn&#123; if (timer.isValid) &#123; [timer invalidate]; &#125; timer=nil; [self dismissViewControllerAnimated:YES completion:nil];&#125; 在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSTimer","slug":"NSTimer","permalink":"http://huishao.cc/tags/NSTimer/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS 中block结构的简单用法","slug":"08iOS 中block结构的简单用法","date":"2015-04-08T16:00:00.000Z","updated":"2021-05-31T03:35:27.069Z","comments":true,"path":"2015/04/09/08iOS 中block结构的简单用法/","link":"","permalink":"http://huishao.cc/2015/04/09/08iOS 中block结构的简单用法/","excerpt":"","text":"自从block出现之后，很多API都开始采用这样的结构，由此可见，block确实有许多优势存在，这里将一些简单用法总结如下： 一、如何声明一个block变量 我们通过^符号来声明block类型，形式如下： void (^myBlock)(); 其中第一个void是返回值，可以是任意类型，中间括号中^后面的是这个block变量的名字，我把它命名为myBlock，最后一个括号中是参数，如果多参数，可以写成如下样式： int (^myBlock)(int,int); 同样，你也可以给参数起名字： int (^myBlock)(int a,int b); 很多时候，我们需要将我们声明的block类型作为函数的参数，也有两种方式： 1、-(void)func:(int (^)(int a,int b))block； 第二种方式是通过typedef定义一种新的类型，这也是大多数情况下采用的方式： 2、typedef int (^myBlock)(int a,int b) ; -(void)func:(myBlock)block ; 二、如何实现一个block 既然block可以被声明为变量，那么就一定可以实现它，就像其他类型变量的赋值。我自己对block的理解为它是一断代码块，所以给它赋值赋便是一段代码段： 1234567891011121314151617typedef int (^myBlock)(int,int) ;@interface ViewController ()&#123; myBlock block1;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. block1 =^(int a, int b)&#123; return a+b; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 这里打印的结果是2，从这里可以发现block和函数的功能很像。 注意：1、在上面的代码里 block1是一个对象，如果直接打印将打印对象地址 2、block()，加上后面的括号才是执行block语句块 三、block中访问对象的微妙关系 1、如果你在一个block块中仅仅访问对象，而不是对他进行修改操作，是没有任何问题的： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; int count= tem+1; return count; &#125;; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 而如果我在block块中直接修改，编译器会报错： 1234 block1 = ^(int a,int b)&#123; tem+=1; return tem+1; &#125;; 为什么会出现这样的情况，根据猜测，可能是block内部将访问的变量都备份了一份，如果我们在内部修改，外部的变量并不会被修改，我们可以通过打印变量的地址来证明这一点： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; int tem=2; NSLog(@&quot;%p&quot;,&amp;tem); block1 = ^(int a,int b)&#123; NSLog(@&quot;%p&quot;,&amp;tem); return tem+1; &#125;; NSLog(@&quot;%d&quot;,block1(1,1)); &#125; 打印结果如下： 可以看出，变量的地址已经改变。 2、__block 做了什么 为了可以在block块中访问并修改外部变量，我们常会把变量声明成__block类型，通过上面的原理，可以发现，其实这个关键字只做了一件事，如果在block中访问没有添加这个关键字的变量，会访问到block自己拷贝的那一份变量，它是在block创建的时候创建的，而访问加了这个关键字的变量，则会访问这个变量的地址所对应的变量。我们可以通过代码来证明： 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. int tem=2; block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; tem=4; NSLog(@&quot;%d&quot;,block1(1,1)); block1 = ^(int a,int b)&#123; return tem+a+b; &#125;; __block int tem2=2; tem2=4; NSLog(@&quot;%d&quot;,block1(1,1));&#125; 结果： 3、一点点扩展 由此，我们可以理解，如果block中操作的对象是指针，那么直接可以进行修改，这包括OC对象，如果不是，则需要用__block关键字修饰。 4、关于引用计数 在block中访问的对象，会默认retain： 1234567 UIImage * number; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 结果如下： 而添加__block的对象不会被retain; 注意：如果我们访问类的成员变量，或者通过类方法来访问对象，那么这些对象不会被retain，而类对象会被return，最常见的时self: 1234567891011121314151617181920212223242526272829303132typedef void(^myBlock)(int,int) ;@interface ViewController2 ()&#123; myBlock block1; __block UIImage * number; &#125;@end@implementation ViewController2-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number));&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); &#125;; //block1(1,1); NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 打印结果： 可以看出，UIImage对象没有被retain,而self也将循环引用，造成内存泄露。解决方法如下： 1234567 number = [[UIImage alloc]init] ; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); UIImage * im = number; block1 = ^(int a,int b)&#123; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)im)); &#125;; NSLog(@&quot;%ld&quot;,CFGetRetainCount((__bridge CFTypeRef)number)); 打印结果： 注意：根据这个机制，如果我们将block用来传值，在block不用时，务必要置为nil,而在实现block的方法里，务必要释放;我们通过代码来解释： 首先，创建三个ViewController，为ViewController1，ViewController2，ViewController3； 1、在ViewController1中创建一个按钮，跳转ViewController2 2、在ViewController2中： 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController2.h&quot;#import &quot;ViewController3.h&quot;@interface ViewController2 ()&#123; UIButton * im;&#125;@end@implementation ViewController3-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(300, 300, 100, 100); btn.backgroundColor=[UIColor redColor]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; im = [[UIButton alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; im.backgroundColor=[UIColor blackColor]; [im addTarget:self action:@selector(rele) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:im];&#125;-(void)rele&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController3 alloc]init]; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 3、在ViewController3中： 12345678910111213141516171819202122#import &quot;ViewController3.h&quot;void (^myBlock)();@implementation ViewController3-(void)setBlock:(void(^)())block&#123; myBlock = [block copy];&#125;-(void)dealloc&#123; NSLog(@&quot;dealloc %@&quot;,self.class);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor=[UIColor whiteColor]; myBlock(); UIButton * btn = [UIButton buttonWithType:UIButtonTypeCustom]; btn.frame=CGRectMake(100, 100, 100, 100); btn.backgroundColor=[UIColor redColor]; [self.view addSubview:btn]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside];&#125;-(void)click&#123; [self dismissViewControllerAnimated:YES completion:nil];&#125; 通过打印信息，我们会发现，ViewController2不被释放，原因是其成员变量im被block中retain没有释放，我们这样做： 1234567891011121314151617@interface ViewController2 ()&#123; UIButton * im; ViewController3 * tem;&#125;-(void)rele&#123; [tem setBlock:nil]; [self dismissViewControllerAnimated:YES completion:nil];&#125;-(void)click&#123; ViewController3 * con = [[ViewController2 alloc]init]; tem=con; [con setBlock:^&#123; im.backgroundColor=[UIColor colorWithRed:arc4random()%255/255.0 green:arc4random()%255/255.0 blue:arc4random()%255/255.0 alpha:1]; &#125;]; [self presentViewController:con animated:YES completion:nil];&#125; 这样就解决了内存问题。 四、关于block的作用域 应避免将花括号中的block用于外面，如果需要，你可以将这个block声明为全局的。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"Block","slug":"Block","permalink":"http://huishao.cc/tags/Block/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中使用NSAttributedString灵活创建标签","slug":"07iOS中使用NSAttributedString灵活创建标签","date":"2015-04-07T16:00:00.000Z","updated":"2021-05-31T03:33:47.188Z","comments":true,"path":"2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","link":"","permalink":"http://huishao.cc/2015/04/08/07iOS中使用NSAttributedString灵活创建标签/","excerpt":"","text":"灵活使用NSAttributedString可以更轻松的创建出内容复杂的标签。需要注意一点：如果一个label设置了这个属性，那它其他的设置都将失效。 首先，我们初始化一个NSMutableAttributedString对象。 12345678//通过字符串初始化//- (instancetype)initWithString:(NSString *)str;//通过字符串和属性字典直接初始化//- (instancetype)initWithString:(NSString *)str attributes:(NSDictionary *)attrs;//通过自身对象初始化//- (instancetype)initWithAttributedString:(NSAttributedString *)attrStr; NSMutableAttributedString * attribute = [[NSMutableAttributedString alloc]initWithString:@&quot;123!@#你好么QWE&quot;]; 可以通过下面两个函数对attrebute字符串进行设置与修改 123456//可以替换字符- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str;//属性设置- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range;//设置一定范围内字符属性- (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; 字典的键值对应如下： 123456789101112131415161718//kCTFontAttributeName 这个键是字体的名称 必须传入CTFont对象//kCTKernAttributeName 这个键设置字体间距 传入必须是数字对象 默认为0//kCTLigatureAttributeName 这个键设置连字方式 必须传入CFNumber对象//kCTParagraphStyleAttributeName 段落对其方式//kCTForegroundColorAttributeName 字体颜色 必须传入CGColor对象//kCTStrokeWidthAttributeName 笔画宽度 必须是CFNumber对象//kCTStrokeColorAttributeName 笔画颜色//kCTSuperscriptAttributeName 控制垂直文本定位 CFNumber对象//kCTUnderlineColorAttributeName 下划线颜色[attribute addAttribute:(NSString*)kCTKernAttributeName value:@5 range:NSMakeRange(0, 5)];[attribute addAttribute:(NSString *)kCTFontAttributeName value:(id)CFBridgingRelease(CTFontCreateWithName((CFStringRef)[UIFont boldSystemFontOfSize:14].fontName, 14, NULL)) range:NSMakeRange(0, 4)]; [attribute addAttribute:(NSString *)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; 通过测试，发现上面有些键值并没有作用，可以替换下面的方法，效果相同，不同的地方在于其传值的类型不同，下面的方法更加方便（使用UIFont UIColor NSString 和一些系统枚举） 1234567891011121314151617181920 NSParagraphStyleAttributeNameNSForegroundColorAttributeNameNSBackgroundColorAttributeNameNSLigatureAttributeNameNSKernAttributeNameNSStrikethroughStyleAttributeNameNSUnderlineStyleAttributeNameNSStrokeColorAttributeName NSStrokeWidthAttributeName NSShadowAttributeName NSTextEffectAttributeNameNSAttachmentAttributeName NSLinkAttributeName NSBaselineOffsetAttributeName NSUnderlineColorAttributeNameNSStrikethroughColorAttributeNameNSObliquenessAttributeName NSExpansionAttributeName NSWritingDirectionAttributeNameNSVerticalGlyphFormAttributeName 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"NSAttributedString","slug":"NSAttributedString","permalink":"http://huishao.cc/tags/NSAttributedString/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS UILabe及UIFont用法总结","slug":"06iOS UILabe及UIFont用法总结","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:32:56.548Z","comments":true,"path":"2015/04/07/06iOS UILabe及UIFont用法总结/","link":"","permalink":"http://huishao.cc/2015/04/07/06iOS UILabe及UIFont用法总结/","excerpt":"","text":"初始化一个UILabel对象，并初始化大小 UILabel * label = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; 设置显示的文字 label.text=@”123”; 和字体相关的一个类，字号大小默认17 @property(nonatomic,retain) UIFont*font; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//7.0之后可用 设置字体风格// NSString *const UIFontTextStyleHeadline; 用于标题的风格// NSString *const UIFontTextStyleSubheadline;用于副标题的风格// NSString *const UIFontTextStyleBody;用于正文的字体// NSString *const UIFontTextStyleFootnote;用于脚注的字体// NSString *const UIFontTextStyleCaption1;用于标准字幕字体// NSString *const UIFontTextStyleCaption2;用于替换字幕字体 label.font=[UIFont preferredFontForTextStyle:UIFontTextStyleCaption2];//说实话，没看出什么太大的差别//设置字体和字体大小+ (UIFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize;//返回所有字体的字体家族名称数组+ (NSArray *)familyNames;//按字体家族名称返回字体名称数组+ (NSArray *)fontNamesForFamilyName:(NSString *)familyName;//设置普通字体字号大小+ (UIFont *)systemFontOfSize:(CGFloat)fontSize;//设置加粗字体字号大小+ (UIFont *)boldSystemFontOfSize:(CGFloat)fontSize;//设置斜体字号大小+ (UIFont *)italicSystemFontOfSize:(CGFloat)fontSize;//一些只读属性//字体家族名称@property(nonatomic,readonly,retain) NSString *familyName;//字体名称@property(nonatomic,readonly,retain) NSString *fontName;//字号大小@property(nonatomic,readonly) CGFloat pointSize;//字体设计模型，表示距离最高点偏移余量@property(nonatomic,readonly) CGFloat ascender;//底部的模型偏移量@property(nonatomic,readonly) CGFloat descender;//字体模型的头高信息@property(nonatomic,readonly) CGFloat capHeight;//字体模型的xHeight信息@property(nonatomic,readonly) CGFloat xHeight;//字体行高@property(nonatomic,readonly) CGFloat lineHeight NS_AVAILABLE_IOS(4_0);//模型主体信息@property(nonatomic,readonly) CGFloat leading;//创建一个新字体与当前字体相同，除了指定的大小- (UIFont *)fontWithSize:(CGFloat)fontSize;//通过描述信息返回字体 7.0后可用+ (UIFont *)fontWithDescriptor:(UIFontDescriptor *)descriptor size:(CGFloat)pointSize NS_AVAILABLE_IOS(7_0);//返回字体的描述信息，7.0后可用- (UIFontDescriptor *)fontDescriptor NS_AVAILABLE_IOS(7_0); 设置字体颜色 label.textColor=[UIColor redColor]; 设置阴影偏移量 label.shadowOffset=CGSizeMake(20, 20); 设置阴影颜色 label.shadowColor=[UIColor blackColor]; 设置对齐模式 label.textAlignment=NSTextAlignmentJustified; 1234567891011enum &#123; //沿左边沿对齐文本 NSTextAlignmentLeft = 0, //中心对齐 NSTextAlignmentCenter = 1, //右边沿对齐 NSTextAlignmentRight = 2, //最后一行自然对齐 NSTextAlignmentJustified = 3, //默认对齐 NSTextAlignmentNatural = 4,&#125;;typedef NSInteger NSTextAlignment; 多行文本设置 label.lineBreakMode=NSLineBreakByCharWrapping; 12345678910111213enum &#123; //文本边缘处理 NSLineBreakByWordWrapping = 0, //提前处理不合适的字符 NSLineBreakByCharWrapping, //简单线性处理 NSLineBreakByClipping, //丢失的开头用省略号表示 NSLineBreakByTruncatingHead, //丢失的文本在末尾显示省略号 NSLineBreakByTruncatingTail, //丢失的文本在中间显示省略号 NSLineBreakByTruncatingMiddle &#125;;typedef NSUInteger NSLineBreakMode 使用attributedText绘制 @property(nonatomic,copy) NSAttributedString *attributedText 设置高亮的字体颜色 label.highlightedTextColor=[UIColor blueColor]; //设置是否高亮 label.highlighted=YES; 用户交互 默认关闭 label.userInteractionEnabled=NO; 是否有效，默认是YES，无效为灰色 label.enabled=NO; 显示的行数，0为无限 @property(nonatomic) NSInteger numberOfLines; 宽度自适应大小 默认是NO @property(nonatomic) BOOL adjustsFontSizeToFitWidth; 字符适应宽度：不赞成使用 @property(nonatomic) BOOL adjustsLetterSpacingToFitWidth 最小适应大小2.0-6.0 @property(nonatomic) CGFloat minimumFontSize 最小适应大小 6.0 之后 @property(nonatomic) CGFloat minimumScaleFactor 垂直方向的调整 @property(nonatomic) UIBaselineAdjustment baselineAdjustment; 1234567typedef enum &#123; //调整文本对应基线位置 UIBaselineAdjustmentAlignBaselines, //调整文本相对其边框的中心 UIBaselineAdjustmentAlignCenters, //调整文本相对于边界的左上角 默认的 UIBaselineAdjustmentNone,&#125; UIBaselineAdjustment; 返回文本绘制矩形 - (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines; 文本绘制函数 - (void)drawTextInRect:(CGRect)rect 文本自动布局参数 @property(nonatomic) CGFloat preferredMaxLayoutWidth 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"UILabel","slug":"UILabel","permalink":"http://huishao.cc/tags/UILabel/"},{"name":"UIFont","slug":"UIFont","permalink":"http://huishao.cc/tags/UIFont/"}],"keywords":[{"name":"iOS之UI控件","slug":"iOS之UI控件","permalink":"http://huishao.cc/categories/iOS之UI控件/"}]},{"title":"iOS6中横屏的处理方法","slug":"05iOS6中横屏的处理方法","date":"2015-04-06T16:00:00.000Z","updated":"2021-05-31T03:33:03.710Z","comments":true,"path":"2015/04/07/05iOS6中横屏的处理方法/","link":"","permalink":"http://huishao.cc/2015/04/07/05iOS6中横屏的处理方法/","excerpt":"","text":"IOS6以后，若想在项目中支持横屏，我们首先需要在plist文件中添加支持横屏的设置，否则有些代码设置将会失效。 有来那个方式设置： 1、在pilist的Supported interface orientations 字段中添加 2、在Xcode的设置中勾选 现在我们来看决定屏幕方向的几个函数： 在IOS6之前，我们只需通过一个函数 - (BOOL) shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation { return (toInterfaceOrientation == UIInterfaceOrientationLandscapeRight);} 就可以支持指定控制器的旋转。通过新的文档，我们可以看到： 1234// Applications should use supportedInterfaceOrientations and/or shouldAutorotate..- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation NS_DEPRECATED_IOS(2_0, 6_0);//这个方法在6.0之后被标记为过时的 我们通过下面两个方法来代替： //是否允许屏幕旋转 -(BOOL)shouldAutorotate{ return YES;}//支持的方向- (NSUInteger)supportedInterfaceOrientations { return UIInterfaceOrientationMaskLandscapeRight;}这是个枚举 123456789101112131415typedef NS_OPTIONS(NSUInteger, UIInterfaceOrientationMask) &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown=(1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125;; 通过这两个函数，如果我们需要某个控制器强制方向，我们可以设置支持单一的方向，即可达到目的。 注意： 如果你们项目中的RootViewController是导航，你会发现，你在Push出来的视图中添加刚才的代码并没有起作用，原因是导航，并没有进行设置，我们创建一个文件，继承于NavigationController。在里面重写刚才的方法，这么做后，屏幕确实横了过来，并且这个导航push的所有子界面都将横屏，这也不是我们想要的效果。我们想自由的控制每个push出来的界面的屏幕方向，可以在导航里这么做： 1234567-(BOOL)shouldAutorotate&#123; return [self.topViewController shouldAutorotate];&#125;//支持的方向- (NSUInteger)supportedInterfaceOrientations &#123; return [self.topViewController supportedInterfaceOrientations];;&#125; 我们还需要做一些处理，经过我的测试，导航必须在pop后才会重新调用这些函数，所以我的方法是这样做：弹出一个中间控制器后再POP回来 1234567@implementation ViewController2- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController pushViewController:[[ViewController3 alloc]init] animated:YES];&#125; 1234567@implementation ViewController3- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.navigationController popViewControllerAnimated:YES];&#125; 这样做，我们就可以自由的控制每个视图控制器的方向了。 同理，如果根视图控制器是tabBar，则我们需要在tabBar中做操作。 如果我们大多是的视图控制器都是一个方向的，只有偶尔的几个会不同，这时候，我们其实可以采取presentationController的方式，然后直接在弹出的控制器中写那两个方法即可。这是最简单的途径了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"横屏","slug":"横屏","permalink":"http://huishao.cc/tags/横屏/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS SEL的理解与使用","slug":"04iOS SEL的理解与使用","date":"2015-04-04T16:00:00.000Z","updated":"2021-05-28T10:11:35.356Z","comments":true,"path":"2015/04/05/04iOS SEL的理解与使用/","link":"","permalink":"http://huishao.cc/2015/04/05/04iOS SEL的理解与使用/","excerpt":"","text":"有很多人，认为block的推广可取代代理设计模式，其实block并不能取代代理，代理的模式可以让代码逻辑性更强，更整洁，也会有更高的可读性和可扩展性。相比之下，我觉得block更多的是取代了选择器@selector。 @selector是什么？我们要首先明白SEL，SEL并不是一种对象类型，我们通过xCode的字体颜色就可以判断出来，它是一个关键字，就像int，long一样，它声明了一种类型：类方法指针。其实就可以理解为一个函数指针。比如，我们生命一个叫myLog的函数指针： 1234567#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end 声明出了这个指针，我们该如何给它传递这个函数呢？有两种方式： 1、在编译时，使用@selector来取得函数 现在，我们应该明白@selector是什么了，它是一个编译标示，我们通过它来取到相应函数。 12345678910111213141516171819@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = @selector(myLogL); //通过performSelector来执行方法 [self performSelector:myLog];//打印 “myLog” &#125;-(void)myLogL&#123; NSLog(@&quot;myLog&quot;);&#125; 2、在运行时，通过NSSelectorFromString方法来取到相应函数： 12345678910111213141516171819202122#import &quot;ViewController.h&quot;@interface ViewController ()&#123; SEL myLog;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. myLog = NSSelectorFromString(@&quot;myLogN&quot;); [self performSelector:myLog]; &#125;-(void)myLogN&#123; NSLog(@&quot;myLog&quot;);&#125; 这两种方式的差别在于，编译时的方法如果没有找到相应函数，xcode会报错，而运行时的方法不会。 至于SEL的应用，我相信最广泛的便是target——action设计模式了。我们来简单模拟一下系统button的工作原理： 我们先创建一个继承于UIButton的类： .h文件： 12345#import &lt;UIKit/UIKit.h&gt;@interface Mybutton : UIButton-(void)addMyTarget:(id)target action:(SEL)action;@end .m文件 1234567891011121314151617#import &quot;Mybutton.h&quot;@implementation Mybutton&#123; SEL _action; id _target;&#125;-(void)addMyTarget:(id)target action:(SEL)action&#123; _target=target; _action=action;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; [_target performSelector:_action];&#125;@end 在外部： 1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; Mybutton * btn = [[Mybutton alloc]initWithFrame:CGRectMake(100, 100, 60, 60)]; btn.backgroundColor=[UIColor redColor]; [btn addMyTarget:self action:@selector(click)]; [self.view addSubview:btn];&#125;-(void)click&#123; NSLog(@&quot;点击了btn&quot;);&#125; 当然，如果要调用参数，系统提供的默认参数不超过两个，如果参数很多，一种是我们可以通过字典传参，另一种方法比较复杂，在这里先不讨论。 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"SEL","slug":"SEL","permalink":"http://huishao.cc/tags/SEL/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS事件响应控制","slug":"03iOS事件响应控制","date":"2015-04-03T16:00:00.000Z","updated":"2021-05-28T10:09:54.887Z","comments":true,"path":"2015/04/04/03iOS事件响应控制/","link":"","permalink":"http://huishao.cc/2015/04/04/03iOS事件响应控制/","excerpt":"","text":"以前遇到一个项目，一个UIImageView对象上面有一个UIButton对象，然而项目的需求需要在点击 button的同时，UIImageView也接收到点击事件，在不使用代理和通知方法的前提下，通过事件响应链的原理，我们也可以很便捷的解决这个问题。 在处理这个问题之前，我们应该先清楚IOS的事件响应机制到底是个什么样的原理。 首先，这个事件响应的机制是分为两个部分的。 1、先在视图层级关系中找到应该响应事件的那个视图。 这一步是什么意思，其实很简单，就是找到你所触摸点对应的那个最上层的视图，它的工作原理是这样的：当用户发出事件后，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中，UIApplication会取出队列中最前面的事件，发消息给UIWindow，然后UIWindow会对其所有子视图调用hitTest:withEvent:这个方法，这个方法会返回一个UIView的对象，这个方法在执行的时候，它会调用当前视图的pointInside:withEvent:这个方法，如果触摸事件在当前视图范围内，pointInside:withEvent:会返回YES，否则会返回NO；如果返回YES，则会遍历当前视图的所有子视图，统统发送hitTest:withEvent:这个消息，如果返回NO,则hitTest:withEvent:方法返回nil； 上面说起来有些绕，其实就是：hitTest:withEvent:方法会一层一层的向上找，若最上层响应的子视图pointInside:withEvent:返回YES，则返回此子视图，如果所有的都返回nil，则返回当前视图本身self。 例如：我们建两个文件，一个继承于UIButton，一个继承于UIImageView，我们在UIImageView里的代码如下： 12345678910111213141516171819#import &quot;MyImageView.h&quot;@implementation MyImageView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor=[UIColor redColor]; &#125; return self;&#125;//在这里，我们重写了这个方法，让它直接返回自身，而不是继续向下寻找应该响应事件的视图-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return self;&#125;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;点击了Image&quot;);&#125; 然后将他们创建在一个View上： 12345678910- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; // Do any additional setup after loading the view, typically from a nib.&#125; 我们运行，点击这个Btn，会打印如下的信息： 可以证明，在事件视图寻找中，UIImageView我们重写hitTest:withEvent:方法后，切断了寻找链，如果我们这个做： 123-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; return nil;&#125; 你会发现，UIImageView也不再接收事件。2、寻找到应该响应的视图后，会进行消息处理，这个处理的方式是通过消息处理链来做的。如果它自身不能处理消息，会通过nextResponder将消息传递给下一个处理者，默认只要有一个view将消息处理了，这个消息处理传递链将不再传递。 现在，我们把刚才UIimageView里重写的hitTest:withEvent:方法注释掉，给btn添加一个点击方法，同时将用户交互关闭： 12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; image.userInteractionEnabled=YES; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click&#123; NSLog(@&quot;btn被点击了&quot;);&#125; 这样，我们的UIImageView又可以响应事件了，原因是事件处理传递链向下传递了。 现在，在回到我们刚开始的问题，如何让btn响应的同时imageView也响应，我们这样做： 12345678910111213141516171819202122- (void)viewDidLoad &#123; [super viewDidLoad]; MyImageView * image = [[MyImageView alloc]initWithFrame:CGRectMake(60, 80, 200, 200)]; image.userInteractionEnabled=YES; MyButton * btn =[UIButton buttonWithType:UIButtonTypeSystem]; btn.frame=CGRectMake(20, 20, 40, 40); [btn setTitle:@&quot;button&quot; forState:UIControlStateNormal]; [image addSubview:btn]; [self.view addSubview:image]; [btn addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]; btn.userInteractionEnabled=NO; // Do any additional setup after loading the view, typically from a nib.&#125;-(void)click:(UIButton *)btn&#123; NSLog(@&quot;btn被点击了&quot;); //响应链继续传递 [btn.nextResponder touchesBegan:nil withEvent:nil]; &#125; 结果如下： 虽然最终，我们完成了这个需求，可是我建议你最好不要这么干，因为这样的逻辑是违背现实生活中人们的行为认知的，更重要的是，我们的项目最后也确实改掉了这样的逻辑~~~ 错误之处，欢迎指正 欢迎转载，注明出处 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"事件","slug":"事件","permalink":"http://huishao.cc/tags/事件/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"iOS中DES与MD5加密方案","slug":"02MD","date":"2015-04-02T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/03/02MD/","link":"","permalink":"http://huishao.cc/2015/04/03/02MD/","excerpt":"","text":"MD5算法和DES算法是常见的两种加密算法。 MD5：MD5是一种不可逆的加密算法，按我的理解，所谓不可逆，就是不能解密，那么它有什么用的，它的用处大了，大多数的登录功能都会使用到这种算法。后面根据我的项目经验来介绍。 DES：一种使用密钥加密的块算法，所以，使用它加密时，需要一个密钥，加上一些设置和你需要加密的文段。 在IOS中，使用这两种加密算法非常简单，系统的&lt;CommonCrypto/CommonCrypto.h&gt;库给我们提供的边界的接口。在很多移动项目中，安卓平台和IOS平台的后台服务是统一的，比如一个登录功能是这样的流程： 1、客户端向服务端请求密钥，请求的参数是双方约定好的一个MD5加密的字符串。我们可以通过下面的进行第一步加密： 1234567891011121314- (NSString *)MD5Digest&#123; //要进行UTF8的转码 const char* input = [self UTF8String]; unsigned char result[CC_MD5_DIGEST_LENGTH]; CC_MD5(input, (CC_LONG)strlen(input), result); NSMutableString *digest = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (NSInteger i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++) &#123; [digest appendFormat:@&quot;%02x&quot;, result[i]]; &#125; return digest;&#125; 通过这样的方法，我们可以很容易的得到一串MD5加密字符串，但是一定要和后台约定好，MD5加密的位数是16位还是32位，用上述方法加密出来的时32位，当然他们之间是有联系的，通过下面的方法可以将其转成16为： 1234567+(NSString *)trransFromMD532ToMD516:(NSString *)MD532&#123; NSString * string; for (int i=0; i&lt;24; i++) &#123; string=[MD532 substringWithRange:NSMakeRange(8, 16)]; &#125; return string;&#125; 还有一点需要注意，加密后的大小写也要对应。 2、服务端将得到的MD5串和以约定好的MD5串进行对比，如果一致，可以放行，返回密钥。 3、客户端取到密钥，将密钥再进行一次MD5加密，然后通过DES将要传送的数据加密发给服务器。 这一步至关重要，我们先看DES的加密代码 12345678910111213141516171819202122232425262728293031+(NSString *) encryptUseDES:(NSString *)clearText key:(NSString *)key andiv:(NSString *)iv&#123; //这个iv 是DES加密的初始化向量，可以用和密钥一样的MD5字符 NSData * date = [iv dataUsingEncoding:NSUTF8StringEncoding]; NSString *ciphertext = nil; NSUInteger dataLength = [clearText length]; NSData *textData = [clearText dataUsingEncoding:NSUTF8StringEncoding]; unsigned char buffer[1024]; memset(buffer, 0, sizeof(char)); size_t numBytesEncrypted = 0; CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,//加密模式 kCCDecrypt 代表解密 kCCAlgorithmDES,//加密方式 kCCOptionPKCS7Padding,//填充算法 [key UTF8String], //密钥字符串 kCCKeySizeDES,//加密位数 [date bytes],//初始化向量 [textData bytes] , dataLength, buffer, 1024, &amp;numBytesEncrypted); if (cryptStatus == kCCSuccess) &#123; NSLog(@&quot;DES加密成功&quot;); NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted]; Byte* bb = (Byte*)[data bytes]; ciphertext = [Base64 parseByteArray2HexString:bb]; &#125;else&#123; NSLog(@&quot;DES加密失败&quot;); &#125; return ciphertext;&#125; 几点注意： （1）加密方式，IOS官方提供的是如下几种 12345678910enum &#123; kCCAlgorithmAES128 = 0, kCCAlgorithmAES = 0, kCCAlgorithmDES, kCCAlgorithm3DES, kCCAlgorithmCAST, kCCAlgorithmRC4, kCCAlgorithmRC2, kCCAlgorithmBlowfish &#125;; （2）填充算法 123456enum &#123; /* options for block ciphers */ kCCOptionPKCS7Padding = 0x0001, kCCOptionECBMode = 0x0002 /* stream ciphers currently have no options */&#125;; 我们可以发现，官方提供的只有这两种，然而JAVA使用的却是 1kCCOptionPKCS7Padding 但是不用担心，在密钥是8位的时候，这两种填充算法加密出来的结果试一模一样的。 4、服务器通过相同的方式，解密出密文，通配安卓端。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"加密","slug":"加密","permalink":"http://huishao.cc/tags/加密/"},{"name":"DES","slug":"DES","permalink":"http://huishao.cc/tags/DES/"},{"name":"MD5","slug":"MD5","permalink":"http://huishao.cc/tags/MD5/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]},{"title":"AFNetWorking用法及缓存处理","slug":"01AF","date":"2015-04-01T16:00:00.000Z","updated":"2018-12-10T04:40:27.696Z","comments":true,"path":"2015/04/02/01AF/","link":"","permalink":"http://huishao.cc/2015/04/02/01AF/","excerpt":"","text":"AFNetWorking 在IOS开发中是一个经常会用的第三方开源库，其最好处是维护及时，源码开源。 常用GET与POST请求方法： POST请求： 123456789//初始化一个请求对象 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; //dic 为参数字典 [manager POST:url parameters:dic success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; GET请求： 1234567AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; NSString * url = @&quot;你的请求地址&quot;; [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //请求成功的回调 &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //请求失败的回调 &#125;]; 这里有一个地方需要注意， 1[AFHTTPRequestOperationManager manager] 这个类方法我们点进源码可以发现： 123+ (instancetype)manager &#123; return [[self alloc] initWithBaseURL:nil];&#125; 这里初始化了一个返回了一个新的对象，并不是单例。 使用这样的下载方法，下载完成后的数据AFNetWorking会帮我们自动解析，但是有时候服务器给的数据并不标准，这时我们需要加上这个设置： manager.responseSerializer = [AFHTTPResponseSerializer serializer]; 这样我们将得到原始的HTTP返回给我们数据。 我们再来探究一下，下载成功后，回调方法里的参数到底是什么东西 1success:^(AFHTTPRequestOperation *operation, id responseObject) 其中，第二个参数 responseObject 是下载下来的data数据，可直接进行JSON等解析。 第一个参数，是个AFHTTPRequestOperation对象，来看源文件 123456789@interface AFHTTPRequestOperation : AFURLConnectionOperation@property (readonly, nonatomic, strong) NSHTTPURLResponse *response;@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;@property (readonly, nonatomic, strong) id responseObject;@end 可以发现，里面有一个成员便是responseObject，同时，AFHTTPRequestOperation是继承于AFURLConnectionOperation,我们在看看AFURLConnectionOperation这个类： 123456789101112131415161718192021222324252627282930313233343536373839@interface AFURLConnectionOperation : NSOperation &lt;NSURLConnectionDelegate, NSURLConnectionDataDelegate, NSSecureCoding, NSCopying&gt;@property (nonatomic, strong) NSSet *runLoopModes;@property (readonly, nonatomic, strong) NSURLRequest *request;@property (readonly, nonatomic, strong) NSURLResponse *response;@property (readonly, nonatomic, strong) NSError *error;@property (readonly, nonatomic, strong) NSData *responseData;@property (readonly, nonatomic, copy) NSString *responseString;@property (readonly, nonatomic, assign) NSStringEncoding responseStringEncoding;@property (nonatomic, assign) BOOL shouldUseCredentialStorage;@property (nonatomic, strong) NSURLCredential *credential;@property (nonatomic, strong) AFSecurityPolicy *securityPolicy;@property (nonatomic, strong) NSInputStream *inputStream;@property (nonatomic, strong) NSOutputStream *outputStream;@property (nonatomic, strong) dispatch_queue_t completionQueue;@property (nonatomic, strong) dispatch_group_t completionGroup;@property (nonatomic, strong) NSDictionary *userInfo;- (instancetype)initWithRequest:(NSURLRequest *)urlRequest NS_DESIGNATED_INITIALIZER;- (void)pause;- (BOOL)isPaused;- (void)resume; 看到这里，就离AFNETWorking封装的源头很近了，里面的成员非常多，其中包含了大部分我们需要的信息，可以通过点语法取到，其中有输入输出流，错误信息，请求到的Data数据，以及请求到的字符串数据 1responseString 我们可以通过 1NSLog ( @&quot;operation: %@&quot; , operation. responseString ); 来打印查看请求到的原始信息。 几点注意： 1.关于崩溃url为nil 大多数这样的原因是url中有特殊字符或者中文字符，AFNETWorking并没有做UTF8的转码，需要： 1url = [url stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 2.添加HttpHead字段的方法 1234 //为这个下载任务HTTP头添加@&quot;User-Agent&quot;字段 [manager.requestSerializer setValue:_scrData forHTTPHeaderField:@&quot;User-Agent&quot;]; //打印头信息 NSLog(@&quot;%@&quot;,manager.requestSerializer.HTTPRequestHeaders); 在下载请求中，经常会请求一些不长变化的数据，如果每次APP启动都进行请求，会消耗许多资源，并且有时候缓存的处理，可以大大改善用户体验。 在AFNETWorking中，并没有提供现成的缓存方案，我们可以通过写文件的方式，自行做缓存。 在下载方法中： 1234567[manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //写缓存 NSString *cachePath = @&quot;你的缓存路径&quot;;// /Library/Caches/MyCache [data writeToFile:cachePath atomically:YES]; succsee(data); &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; &#125;]; 然后在每次下载前，进行如下判断： 12345 NSString * cachePath = @&quot;你的缓存路径&quot;; if ([[NSFileManager defaultManager] fileExistsAtPath:cachePath]) &#123; //从本地读缓存文件 NSData *data = [NSData dataWithContentsOfFile:cachePath]; &#125; 有时，我们的下载请求可能是用户的动作触发的，比如一个按钮。我们还应该做一个保护机制的处理， 123456789101112131415//初始化一个下载请求数组NSArray * requestArray=[[NSMutableArray alloc]init];//每次开始下载任务前做如下判断for (NSString * request in requestArray) &#123; if ([url isEqualToString:request]) &#123; return; &#125; &#125; [requestArray addObject:url]; //下载成功或失败后 [manager GET:url parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; [requestArray removeObject:url] &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; [requestArray removeObject:url] &#125;]; 至此，一个比较完成AFNETWorking请求使用流程就完成了。 专注技术，热爱生活，交流技术，也做朋友。 ——珲少 QQ群：203317592","categories":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://huishao.cc/tags/网络/"},{"name":"iOS编程","slug":"iOS编程","permalink":"http://huishao.cc/tags/iOS编程/"},{"name":"AFNetWorking","slug":"AFNetWorking","permalink":"http://huishao.cc/tags/AFNetWorking/"}],"keywords":[{"name":"iOS编程技巧","slug":"iOS编程技巧","permalink":"http://huishao.cc/categories/iOS编程技巧/"}]}]}