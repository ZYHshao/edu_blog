<script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script> 
<script>
　　let models = [
    "https://unpkg.com/live2d-widget-model-chitose@1.0.5/assets/chitose.model.json",
    "https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json",
    "https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json",
    "https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json",
    "https://unpkg.com/live2d-widget-model-miku@1.0.5/assets/miku.model.json",
    "https://unpkg.com/live2d-widget-model-z16@1.0.5/assets/z16.model.json"
];
let m = models[Math.round(Math.random()*5)];
　　L2Dwidget.init({ 
　　"model": {jsonPath:m,"scale": 1 }, 
　　"display": { "position": "left", "width": 200, "height": 300,"hOffset": 0, "vOffset": -20 }, 
　　"mobile": { "show": true, "scale": 0.5 }, 
　　"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });
</script> 
<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="珲少的技术博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://huishao.cc">
    <meta name="referrer" content="no-referrer">
    <!--SEO-->

<meta name="description" content="珲少的技术博客">



<meta name="keywords" content="珲少">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>动态的Objective-C——关于消息机制与运行时的探讨 | 珲少的技术博客</title>


    <link rel="alternate" href="/atom.xml" title="珲少的技术博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    





    
</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner.png)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='珲少'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 学如逆水行舟 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://huishao.cc">珲少的技术博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>主页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>归档</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="动态的Objective-C——关于消息机制与运行时的探讨">
            
	            动态的Objective-C——关于消息机制与运行时的探讨
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/iOS逻辑初窥">
            iOS逻辑初窥
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2017/05/05</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h2 id="动态的Objective-C——关于消息机制与运行时的探讨"><a href="#动态的Objective-C——关于消息机制与运行时的探讨" class="headerlink" title="动态的Objective-C——关于消息机制与运行时的探讨"></a>动态的Objective-C——关于消息机制与运行时的探讨</h2><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><pre><code>Objective-C是一种很优美的语言，至少在我使用其进行编程的过程中，是很享受他那近乎自然语言的函数命名、灵活多样的方法调用方式以及配合IDE流顺畅快编写体验。Objective-C是扩展与C面向对象的编程语言，然而其方法的调用方式又和大多面向对象语言大有不同，其采用的是消息传递、转发的方式进行方法的调用。因此在Objective-C中对象的真正行为往往是在运行时确定而非在编译时确定，所以Objective-C又被称为是一种运行时的动态语言。

本篇博客既不介绍iOS开发，也不提及MacOS开发，只对Objective-C语言的这种消息机制与运行时动态进行探讨，所提及的内容也都是我开发中的个人积累与经验，如果偏颇之处，欢迎讨论指正。
</code></pre><h3 id="二、消息发送与转发机制"><a href="#二、消息发送与转发机制" class="headerlink" title="二、消息发送与转发机制"></a>二、消息发送与转发机制</h3><h4 id="1-初窥消息发送机制"><a href="#1-初窥消息发送机制" class="headerlink" title="1.初窥消息发送机制"></a>1.初窥消息发送机制</h4><pre><code>许多面向对象语言中方法的调用都是采用obj.function这样的方式，在Objective-C语言中却是采用中括号包裹的方式进行方法调用，例如\[obj function\]。实际上，Objective-C中的每一句方法调用最后都会转换成一条消息进行发送。一条消息包含3部分内容：方法选择器、接收消息的对象以及参数。objc_msgSend函数就是用来发送这种消息。例如，创建一个Xcode命令行工程，我们创建一个类，命名为MyObject，如下：
</code></pre><p>MyObject.h文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyObject.m文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)showSelf&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyObject"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>首先在MyObject.h文件中并没有暴漏任何方法，MyObject.m文件中添加了一个showSelf方法，这个方法只是做了简单的打印操作。</p>
<pre><code>将main.m文件修改如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyObject.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObject * obj = [[MyObject alloc]init];</span><br><span class="line">        [obj <span class="keyword">class</span>];</span><br><span class="line"><span class="comment">//为了消除未定义选择器的警告</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored<span class="meta-string">"-Wundeclared-selector"</span></span></span><br><span class="line">        <span class="comment">//进行消息发送</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(<span class="keyword">id</span>,SEL))objc_msgSend)(obj,<span class="keyword">@selector</span>(showSelf));</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行工程，可以看到控制台执行了MyObject类的示例方法showSelf。如果要进行传参，在objc_msgSend方法中继续添加参数，并且指定对应的函数类型即可，例如：</p>
<p>MyObject.m文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)showSelf:(<span class="built_in">NSString</span>*)name age:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyObject:%@,%d"</span>,name,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>main.m文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyObject.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObject * obj = [[MyObject alloc]init];</span><br><span class="line">        [obj <span class="keyword">class</span>];</span><br><span class="line"><span class="comment">//为了消除未定义选择器的警告</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored<span class="meta-string">"-Wundeclared-selector"</span></span></span><br><span class="line">        <span class="comment">//进行消息发送</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(<span class="keyword">id</span>,SEL,<span class="built_in">NSString</span>*,<span class="keyword">int</span>))objc_msgSend)(obj,<span class="keyword">@selector</span>(showSelf:age:),<span class="string">@"珲少"</span>,<span class="number">25</span>);</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行工程可以看到方法被调用，参数被正确传入。</p>
<h4 id="2-消息传递是基于继承链的"><a href="#2-消息传递是基于继承链的" class="headerlink" title="2.消息传递是基于继承链的"></a>2.消息传递是基于继承链的</h4><pre><code>上面代码只是简单演示了消息发送的效果，下面我们来剖析下消息发送的过程与原理，明白了这个原理，对Objective-C中许多神奇的现象你将会豁然开朗，后面我会再具体向你介绍这些现象。

在介绍消息机制之前，我还是要再啰嗦一点，关于@selector()我们还需要深入理解一下，通过@selector(方法名)可以获取到一个SEL类型的对象，SEL实际上是objc\_selector结构体指针，在Objective-C库头文件中没有找到objc\_selector结构体的定义，但我们可以合理猜测，其中很有可能包含的是一个函数指针。因此SEL也可以理解为函数签名，在程序的编译阶段，我们定义类中所有所发会生成一个方法签名列表，这个列表时类直接关联的(原则上来说，类的本质也是对象，它是一个单例对象)，在运行时通过方法签名表来找到具体要执行的函数。

我们再来看objc_msgSend()函数，前面说过，它的第一个参数为接收消息的对象，第2个参数为方法签名，之后为传递的参数。那么Objective-C运行时是如何根据一个对象实例来找到方法签名表，再找到要执行的方法呢，看似麻烦的事情其实原理也非常简单，细心观察，你会发现所有的NSObject子类对象中都包含一个isa成员变量，请看NSObject类的定义：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个isa变量是Class类型，我们的主角终于来了，Class顾名思义就是“类”类型，其实质是objc_class结构体指针：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>有些蒙圈了吧，不用着急，拨开层层迷雾，你就会发现Objective-C中类本质上只是结构体而已，下面是objc_class结构体的定义：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    <span class="comment">//元类指针</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    <span class="comment">//父类</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//类的版本</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//信息</span></span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//内存布局</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//变量列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//函数列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//缓存方式</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//协议列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>每一个“类”对象是也有一个isa指针，这个指针指向的类实际上是元类，即构造“类”的类。现在你无须纠结这些概念，举一个例子你就能明白，在Objective-C开发中有加方法与减方法，减方法是实例对象调用的方法，每一个“类”中都包含一个函数列表，就是上面的objc_method_list结构体数组指针，同样如果调用加方法，实际上是从类的元类中找到对应的方法列表，这个列表就是我们前面提到的方法签名列表，进行方法的执行。关于实例对象，“类”对象和元类，下图很好的表现了他们之间的关系：</p>
<p><img src="https://static.oschina.net/uploads/space/2017/0503/150418_6vvT_2340880.png" alt></p>
<blockquote>
<p>需要注意，使用LLDB调试器我们是可以拿到对象的isa指针的，并且可以看出它的确为Class类型，但是我们缺无法通过isa指针继续向下取抓取更多类的信息，其所在的内存是禁止我们访问的。但是Objective-C运行时提供了一些方法可以获取到这些信息，后面我们会一一介绍。</p>
</blockquote>
<pre><code>上面我们介绍的消息发送机制其实十分不完整，首先Objective-C是支持继承的，因此如果在当前对象的类的方法列表中没有找到此消息对应的方法签名，系统会通过super_class一层层继续向上，直到找到相应的方法或者到达继承链的顶端。

有了上面的理论知识作为基础，我们就可以更深入的分析消息传递的过程了，首先，如果消息的接收对象刚好可以处理这个消息，即其isa指针对应的类中可以查找到这个方法，那么万事大吉，找到对应方法直接执行就大功告成，可以如果接收对象无法处理，其父类，父父类...等都无法处理，那么该怎么办呢，Objective-C为了增强语言的动态性，如果真的出现了这种情况，程序并不会马上crash，在crash前，有3次机会可以挽救本条消息的命运。
</code></pre><h4 id="3-拯救未知消息的3根救命稻草"><a href="#3-拯救未知消息的3根救命稻草" class="headerlink" title="3.拯救未知消息的3根救命稻草"></a>3.拯救未知消息的3根救命稻草</h4><p>第一根救命稻草：</p>
<pre><code>如上所说，如果对象整个继承链都无法处理当前消息，那么首先会调用接收对象所属类的resolveInstanceMethod方法(这个对应实例方法，如果是无法处理的类方法消息，则会调用resolveClassMethod方法)，在这个方法中，开发者有机会为类动态添加方法，如果动态添加了方法，可以在这个方法中返回YES，那么此条消息依然会被成功处理。例如我们将main.m文件修改如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyObject.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObject * obj = [[MyObject alloc]init];</span><br><span class="line">        [obj <span class="keyword">class</span>];</span><br><span class="line"><span class="comment">//为了消除未定义选择器的警告</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored<span class="meta-string">"-Wundeclared-selector"</span></span></span><br><span class="line">        <span class="comment">//进行消息发送</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(<span class="keyword">id</span>,SEL))objc_msgSend)(obj,<span class="keyword">@selector</span>(showSelf));</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyObject类不做任何修改，当我们运行程序，程序会直接crash掉，现在我们在MyObject类中添加如下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"resolveInstanceMethod"</span>);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"showSelf"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, newFunc, <span class="string">"v@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中class_addMethod函数用来向类中动态添加方法，第一个参数为Class对象，第二个参数为方法选择器，第三个参数为IMP类型的函数指针，第四个参数为指定方法的返回值和参数类型。这个参数采用的是C字符串的形式来指定返回值和参数的类型，第1个字符为返回值类型，其后都为参数类型，需要注意，使用这种方式添加方法的时候系统会默认传入两个参数，分别是调用此方法的实例对象和方法选择器，上面示例代码中的”@”表示第1个id类型的参数，”:”表示第2个选择器类型的参数，后面我会把字符所表示的参数类型映射表提供给大家。</p>
<pre><code>抽丝剥茧一下，IMP和SEL并不同，SEL可以理解为函数签名，其与函数名相关联，而IMP是函数所在地址的指针，其定义如下：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*IMP)(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> );</span><br></pre></td></tr></table></figure>
<p>简单理解，通过IMP我们可以直接拿到函数的地址，后面会对函数做更深入的剖析，到时候你能就能豁然你开朗。   </p>
<pre><code>运行工程，根据打印信息可以看到showSelf方法被添加并正常执行了。
</code></pre><p>第二根救命稻草：</p>
<pre><code>抛开运行时添加方法这一手段，将resolveInstanceMethod方法删去，是不是我们的程序就必然走进crash的深渊了，其实不然，上帝还会给你另一根救命稻草，当通过运行时添加方法被否定后，系统会接着调用forwardingTargetForSelector方法，这个方法用来对消息进行转发，没错，重点来了，Objective-C中强大的消息转发机制的奥妙就在这里。forwardingTargetForSelector方法需要返回一个id类型的对象，系统会将当前对象服务处理的消息转发给这个方法返回的对象，如果这个返回的对象可以处理，那么程序依然可以很好的执行下去。

例如，在我们的命令行工程中新添加一个类，命名为SubObject，实现如下：
</code></pre><p>SubObject.h文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>SubObject.m文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SubObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubObject</span></span></span><br><span class="line">-(<span class="keyword">void</span>)showSelf&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subObject"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在MyObject类中实现如下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"showSelf"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [SubObject new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>forwardingTargetForSelector方法可以返回一个对象，Objective-C会将当前对象无法处理的消息转发给这个方法返回的对象，如果返回nil，则表示不进行消息转发，这时你如果还想挽救此次crash，你就需要用到第三根救命稻草了。我们可以这种消息转发的机制来模拟Objective-C中的多继承。</p>
<p>第三根救命稻草：</p>
<pre><code>如果你不幸错过了前两次拯救未知消息的机会，那么你还有最后一次机会(中国有句古话，事不过三，世间万事也果真如此...)。当消息转发策略也被否定后，系统会调用methodSignatureForSelector方法，这个方法的主要用途是询问这个选择器是否是有效的，我们需要返回一个NSMethodSignature，顾名思义，这个对象是函数签名的抽象。如果我们返回了有效的函数签名，那么接着系统会调用forwardInvocation方法，这里是拯救应用程序的最后一根稻草了，这个函数会直接将消息包装成NSInvocation对象传入，我们直接将其发送给可以处理此消息的对象即可(当然你也可以直接抛弃，不理会这条未知的消息)。

例如，在MyObject类中将forwardingTargetForSelector方法删去，实现如下两个方法：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//询问此选择器是否是有效的</span></span><br><span class="line">-(<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"methodSignatureForSelector"</span>);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"showSelf"</span>]) &#123;</span><br><span class="line">       <span class="keyword">return</span> [[SubObject new] methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理消息</span></span><br><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardInvocation"</span>);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(anInvocation.selector) isEqualToString:<span class="string">@"showSelf"</span>]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:[SubObject new]];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行工程，程序又被你挽救了一次。</p>
<p>你真的需要救命稻草么？</p>
<pre><code>通过上面的三根救命稻草，我相信你一定对Objective-C消息机制有了全面而深入的了解，上面的代码也只是为了示例所用，正常情况下，你都不会使用到这些函数(毕竟如果你需要救命稻草，说明你已经落水了)。除非某些特殊需求或者做一些调试框架的开发，否则尽量不要介入消息的发送机制，就像生病就医，发现问题总比逃避治疗要好。顺便说一下，如果你没有使用任何救命稻草，当向某个对象发送了无法处理的消息时，系统会最终调用到NSObject类的doesNotRecognizeSelector方法，这个方法会抛出异常信息，正因如此，你在Xcode的控制台会经常看到如下图所示的crash信息：
</code></pre><p><img src="https://static.oschina.net/uploads/space/2017/0504/114108_Hat9_2340880.png" alt></p>
<p>你也可以重写这个方法来自定义输出信息，例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"doesNotRecognizeSelector"</span>);</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(aSelector) isEqualToString:<span class="string">@"showSelf"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"not have a method named showSelf"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> doesNotRecognizeSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图完整展示了Objective-C整个消息发送与转发机制：</p>
<p><img src="https://static.oschina.net/uploads/space/2017/0504/114310_hJpC_2340880.png" alt></p>
<h3 id="三、发送消息的几个函数"><a href="#三、发送消息的几个函数" class="headerlink" title="三、发送消息的几个函数"></a>三、发送消息的几个函数</h3><h4 id="1-最重要的两个发送消息函数"><a href="#1-最重要的两个发送消息函数" class="headerlink" title="1.最重要的两个发送消息函数"></a>1.最重要的两个发送消息函数</h4><pre><code>既然Objective-C函数最终的调用都是要转换成消息发送，那么了解下面这些消息发送函数是十分必要的，这些方法都定义在objc/message.h文件中，其中最重要的两个方法是：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息的函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">self:消息的接收对象</span></span><br><span class="line"><span class="comment">op:方法选择器</span></span><br><span class="line"><span class="comment">...:参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...);</span><br><span class="line"><span class="comment">//发送消息给父类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super:父类对象结构体 </span></span><br><span class="line"><span class="comment">op:方法选择器</span></span><br><span class="line"><span class="comment">...:参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...);</span><br></pre></td></tr></table></figure>
<p>objc_msgSend函数前面已经有过介绍，objc_msgSendSuper函数则是从父类中找方法的实现进行执行。需要注意，这个函数非常重要，理解了这个这个函数进行消息发送的原理，你就明白super关键字的某些令人疑惑的行为了。</p>
<h4 id="2-super关键字到底做了什么"><a href="#2-super关键字到底做了什么" class="headerlink" title="2.super关键字到底做了什么"></a>2.super关键字到底做了什么</h4><pre><code>做了这么久的Objective-C开发，你是否真的理解super关键字的含义？你一定会说，这很简单啊，self调用本类的方法，super调用父类的方法。那么我们来看一个小案例：

在前面创建的命令行工程中新建一个类，使其继承于MyObject类，命名为MyObjectSon，在其中提供两个方法，如下：
</code></pre><p>MyObjectSon.h文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyObject.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObjectSon</span> : <span class="title">MyObject</span></span></span><br><span class="line">-(<span class="keyword">void</span>)showClass;</span><br><span class="line">-(<span class="keyword">void</span>)showSuperClass;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>MyObjectSon.m文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyObjectSon.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObjectSon</span></span></span><br><span class="line">-(<span class="keyword">void</span>)showClass&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="keyword">self</span> className]);</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)showSuperClass&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="keyword">super</span> className]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>分别调用两个方法，你会惊奇的发现，打印结构都是“MyObjectSon”，super关键字失效了么？非也非也，下面我们来用消息发送机制重新模拟这两个方法的调用。</p>
<pre><code>首先\[self className\]在调用时会采用前面介绍的消息发送机制先从当前类中找className函数，当前类中并没有提供className函数，所以消息会随着继承链向上传递，找到MyObject类中也没有className函数的实现，会继续向上，最终在NSObject类中找到这个方法，记住，这条消息处理的两个要素是：当前MyObjectSon实例对象作为接收者，NSObject类中的className方法作为调用函数。

当调用\[super className\]时，首先会使用objc_msgSendSuper方法进行消息的发送，等价于如下代码：
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)showSuperClass&#123;</span><br><span class="line">    <span class="comment">//创建父类接收对象结构体</span></span><br><span class="line">    <span class="keyword">struct</span> objc_super superObj = &#123;<span class="keyword">self</span>, object_getClass([MyObject new])&#125;;</span><br><span class="line">    <span class="built_in">NSString</span> * name = ((<span class="keyword">id</span>(*)(<span class="keyword">struct</span> objc_super*,SEL))objc_msgSendSuper)(&amp;superObj,<span class="keyword">@selector</span>(className));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_msgSendSuper函数第一个参数为一个父类接收者结构体指针，objc_super结构体定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">//接收者</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver;</span><br><span class="line">    <span class="comment">//接收者类型</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在构造objc_super这个结构体时，receive为接收消息的对象，super_class为从哪个类中查方法。如此来看一些都清楚了，系统首先从MyObject类中找className方法，没有相应的实现，会继续向上直到找到NSObject类中的className方法，之后进行执行。这条消息处理的两个要素是：当前MyObjectSon实例对象作为接收者，NSObject类中的className方法作为调用函数。这样分析下来，无论是使用self执行的className方法还是使用super执行的className方法，行为实质上是完全一致的！</p>
<h4 id="3-一些辅助的消息发送函数"><a href="#3-一些辅助的消息发送函数" class="headerlink" title="3.一些辅助的消息发送函数"></a>3.一些辅助的消息发送函数</h4><p>特殊返回值类型对应不同的发送消息函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值为结构体时使用此方法发送消息</span></span><br><span class="line"><span class="keyword">void</span> objc_msgSend_stret(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...);</span><br><span class="line"><span class="keyword">void</span> objc_msgSendSuper_stret(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...);</span><br><span class="line"><span class="comment">//返回值为浮点数时使用此方法发送消息</span></span><br><span class="line"><span class="keyword">double</span> objc_msgSend_fpret(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...);</span><br></pre></td></tr></table></figure>
<p>除了使用SEL方法选择器来发送消息，也可以直接使用Method来发送消息：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行函数的调用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">receiver:接收者</span></span><br><span class="line"><span class="comment">m:函数</span></span><br><span class="line"><span class="comment">...:参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">id</span> method_invoke(<span class="keyword">id</span> receiver, Method m, ...);</span><br><span class="line"><span class="comment">//返回结构体数据的函数调用</span></span><br><span class="line"><span class="keyword">void</span> method_invoke_stret(<span class="keyword">id</span> receiver, Method m, ...);</span><br></pre></td></tr></table></figure>
<p>Method也是一种结构体指针，其定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    <span class="comment">//选择器</span></span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//参数类型</span></span><br><span class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">//函数地址</span></span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyObject * obj = [[MyObject alloc]init];</span><br><span class="line">        [obj <span class="keyword">class</span>];</span><br><span class="line"><span class="comment">//为了消除未定义选择器的警告</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored<span class="meta-string">"-Wundeclared-selector"</span></span></span><br><span class="line">        <span class="comment">//进行消息发送</span></span><br><span class="line">        Method method = class_getInstanceMethod([MyObject <span class="keyword">class</span>], <span class="keyword">@selector</span>(showSelf:age:));</span><br><span class="line">        ((<span class="keyword">void</span>(*)(<span class="keyword">id</span>,Method,<span class="built_in">NSString</span> *,<span class="keyword">int</span>))method_invoke)(obj,method,<span class="string">@"珲少"</span>,<span class="number">25</span>);</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这些方法可以跳过当前对象，直接进行消息转发：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳过当前对象直接进行消息转发机制</span></span><br><span class="line"><span class="keyword">id</span> _objc_msgForward(<span class="keyword">id</span> receiver, SEL sel, ...);</span><br><span class="line"><span class="keyword">void</span> _objc_msgForward_stret(<span class="keyword">id</span> receiver, SEL sel, ...);</span><br></pre></td></tr></table></figure>
<p>一点建议，上面两个方法都是以下划线开头，这也表明设计者并不想让你直接调用这个方法，确实如此，这两个方法会直接出发对象的消息转发流程，即便当前对象类已经实现了相应的方法也不会进行查找。</p>
<h3 id="四、是时候来重温下Runtime了"><a href="#四、是时候来重温下Runtime了" class="headerlink" title="四、是时候来重温下Runtime了"></a>四、是时候来重温下Runtime了</h3><pre><code>所谓运行时是针对于编译时而言的，本篇文章的开头，我们就说过Objective-C是一种极动态的运行时语言。对象的行为是在运行时被决定的，我们前边也了解了有关isa指针即Class的内容，虽然我们并不能直接访问isa指针，但是我们可以通过objc/runtime.h文件中定义的运行时方法来获取或改变类与对象的行为。
</code></pre><h4 id="1-类相关操作函数"><a href="#1-类相关操作函数" class="headerlink" title="1.类相关操作函数"></a>1.类相关操作函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对OC对象进行内存拷贝 在ARC环境下不可用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">obj:要拷贝的对象</span></span><br><span class="line"><span class="comment">size:内存大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">id</span> object_copy(<span class="keyword">id</span> obj, size_t size);</span><br><span class="line"><span class="comment">//进行OC对象内存的释放 在ARC环境下不可用</span></span><br><span class="line"><span class="keyword">id</span> object_dispose(<span class="keyword">id</span> obj);</span><br><span class="line"><span class="comment">//获取OC对象的类 注意 这个返回值和isa指针并不是同一个指针</span></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> obj); </span><br><span class="line"><span class="comment">//重建对象的类</span></span><br><span class="line">Class object_setClass(<span class="keyword">id</span> obj, Class cls); </span><br><span class="line"><span class="comment">//判断一个OC对象是否是类或元类(前面说过类实际上也是对象)</span></span><br><span class="line"><span class="built_in">BOOL</span> object_isClass(<span class="keyword">id</span> obj);</span><br><span class="line"><span class="comment">//获取OC对象的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *object_getClassName(<span class="keyword">id</span> obj);</span><br><span class="line"><span class="comment">//通过类名获取“类”对象</span></span><br><span class="line">Class objc_getClass(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//通过类名获取元类对象</span></span><br><span class="line">Class objc_getMetaClass(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//这个方法也是返回类的定义 只是如果是未注册的 会返回nil</span></span><br><span class="line">Class objc_lookUpClass(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//这个方法也是返回类的定义 只是如果是未注册的 会直接杀死进程</span></span><br><span class="line">Class objc_getRequiredClass(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取所有已经注册的类 会返回已经注册的类的个数</span></span><br><span class="line"><span class="comment">通常使用如下示例代码：</span></span><br><span class="line"><span class="comment">int numClasses;</span></span><br><span class="line"><span class="comment">        Class * classes = NULL;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        numClasses = objc_getClassList(NULL, 0);</span></span><br><span class="line"><span class="comment">        if (numClasses &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">            classes = (Class*)malloc(sizeof(Class) * numClasses);</span></span><br><span class="line"><span class="comment">            numClasses = objc_getClassList(classes, numClasses);</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            NSLog(@"number of classes: %d", numClasses);</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            for (int i = 0; i &lt; numClasses; i++) &#123;</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                Class cls = classes[i];</span></span><br><span class="line"><span class="comment">                NSLog(@"class name: %s", class_getName(cls));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            free(classes);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> objc_getClassList(Class *buffer, <span class="keyword">int</span> bufferCount);</span><br><span class="line"><span class="comment">//拷贝所有注册过的类列表 参数为输出类的个数</span></span><br><span class="line">Class *objc_copyClassList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//获取Class类名字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *class_getName(Class cls);</span><br><span class="line"><span class="comment">//判断一个Class是否为元类</span></span><br><span class="line"><span class="built_in">BOOL</span> class_isMetaClass(Class cls);</span><br><span class="line"><span class="comment">//获取一个类的父类</span></span><br><span class="line">Class class_getSuperclass(Class cls);</span><br><span class="line"><span class="comment">//修改一个类的父类</span></span><br><span class="line">Class class_setSuperclass(Class cls, Class newSuper);</span><br><span class="line"><span class="comment">//获取一个类的版本</span></span><br><span class="line"><span class="keyword">int</span> class_getVersion(Class cls);</span><br><span class="line"><span class="comment">//设置一个类的版本</span></span><br><span class="line"><span class="keyword">void</span> class_setVersion(Class cls, <span class="keyword">int</span> version);</span><br><span class="line"><span class="comment">//获取类的内存布局</span></span><br><span class="line">size_t class_getInstanceSize(Class cls);</span><br></pre></td></tr></table></figure>
<p>上面列举的方法都和类相关，你没看错，通过object_setClass()动态改变对象所属的类，但是需要注意，对象的成员变量并不会受到影响，方法则全部替换为新类的方法。如果你喜欢，你甚至可以运行时动态修改类的父类，这十分酷吧。下面这些方法则与类中的变量有关：</p>
<h4 id="2-变量属性相关操作函数"><a href="#2-变量属性相关操作函数" class="headerlink" title="2.变量属性相关操作函数"></a>2.变量属性相关操作函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取类额外分配内存的指针</span></span><br><span class="line"><span class="keyword">void</span> *object_getIndexedIvars(<span class="keyword">id</span> obj);</span><br><span class="line"><span class="comment">//根据变量名获取实例变量指针</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Ivar实质上是一个结构体指针，存放变量信息，如下：</span></span><br><span class="line"><span class="comment">struct objc_ivar &#123;</span></span><br><span class="line"><span class="comment">    //变量名</span></span><br><span class="line"><span class="comment">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    //变量类型</span></span><br><span class="line"><span class="comment">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">#ifdef __LP64__</span></span><br><span class="line"><span class="comment">    int space                                                OBJC2_UNAVAILABLE;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">&#125;   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Ivar class_getInstanceVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//根据变量名获取类变量指针</span></span><br><span class="line">Ivar class_getClassVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//获取所有实例变量指针 outCount输出实例变量个数</span></span><br><span class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//通过变量指针获取具体变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar(<span class="keyword">id</span> obj, Ivar ivar);</span><br><span class="line"><span class="comment">//通过变量指针设置具体变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar(<span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value);</span><br><span class="line"><span class="comment">//通过变量指针设置变量的值 并进行强引用</span></span><br><span class="line"><span class="keyword">void</span> object_setIvarWithStrongDefault(<span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value);</span><br><span class="line"><span class="comment">//直接通过变量名修改实例变量的值 会返回变量指针</span></span><br><span class="line">Ivar object_setInstanceVariable(<span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value);</span><br><span class="line"><span class="comment">//用法同上</span></span><br><span class="line">Ivar object_setInstanceVariableWithStrongDefault(<span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value);</span><br><span class="line"><span class="comment">//通过变量名直接获取示例变量的值</span></span><br><span class="line">Ivar object_getInstanceVariable(<span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue);</span><br><span class="line"><span class="comment">//获取类变量内存布局</span></span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getIvarLayout(Class cls);</span><br><span class="line"><span class="comment">//设置类变量内存布局</span></span><br><span class="line"><span class="keyword">void</span> class_setIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout);</span><br><span class="line"><span class="comment">//获取类变量布局 弱引用</span></span><br><span class="line"><span class="keyword">const</span> uint8_t *class_getWeakIvarLayout(Class cls);</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="keyword">void</span> class_setWeakIvarLayout(Class cls, <span class="keyword">const</span> uint8_t *layout);</span><br><span class="line"><span class="comment">//通过属性名获取属性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">属性特指使用@prototype定义的</span></span><br><span class="line"><span class="comment">objc_property_t是一个结构体指针，其描述的是属性的信息，如下：</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">    const char *name;           /**属性名 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">/**属性值 */</span></span><br><span class="line">&#125; objc_property_attribute_t;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">objc_property_t class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//获取所有属性列表</span></span><br><span class="line">objc_property_t *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//向类添加一个实例变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要注意，已经注册存在的类是不能通过这个方法追加实例变量的</span></span><br><span class="line"><span class="comment">这个方法只能在objc_allocateClassPair函数执行后并且objc_registerClassPair执行前进行调用</span></span><br><span class="line"><span class="comment">即这个函数是用来动态生成类的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, </span><br><span class="line">                               uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types);</span><br><span class="line"><span class="comment">//向类中添加属性</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount);</span><br><span class="line"><span class="comment">//进行类属性的替换</span></span><br><span class="line"><span class="keyword">void</span> class_replaceProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount);</span><br><span class="line"><span class="comment">//获取变量指针对应的变量名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getName(Ivar v);</span><br><span class="line"><span class="comment">//获取编码后的变量类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getTypeEncoding(Ivar v);</span><br><span class="line"><span class="comment">//获取属性名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getName(objc_property_t property);</span><br><span class="line"><span class="comment">//获取属性attribute</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *property_getAttributes(objc_property_t property);</span><br><span class="line"><span class="keyword">char</span> *property_copyAttributeValue(objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName);</span><br><span class="line"><span class="comment">//获取属性attribute列表</span></span><br><span class="line">objc_property_attribute_t *property_copyAttributeList(objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//进行属性关联 这种方式可以为已经存在的类的实例扩展属性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">object:要添加属性的对象</span></span><br><span class="line"><span class="comment">key:关联的键</span></span><br><span class="line"><span class="comment">value:添加的属性的值</span></span><br><span class="line"><span class="comment">policy:添加属性的策略</span></span><br><span class="line"><span class="comment">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span></span><br><span class="line"><span class="comment">    //assign</span></span><br><span class="line"><span class="comment">    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    <span class="comment">//retain nonatimic</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    <span class="comment">//copy nonatomic</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    <span class="comment">//retain</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    <span class="comment">//copy</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</span><br><span class="line"><span class="comment">//获取关联属性的值</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line"><span class="comment">//移除一个关联的属性</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object);</span><br></pre></td></tr></table></figure>
<h4 id="3-方法操作相关函数"><a href="#3-方法操作相关函数" class="headerlink" title="3.方法操作相关函数"></a>3.方法操作相关函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过选择器获取某个类的实例方法</span></span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name);</span><br><span class="line"><span class="comment">//通过选择器定义某个类的类方法</span></span><br><span class="line">Method class_getClassMethod(Class cls, SEL name);</span><br><span class="line"><span class="comment">//通过选择器获取某个类的方法函数指针</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL name);</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">IMP class_getMethodImplementation_stret(Class cls, SEL name);</span><br><span class="line"><span class="comment">//判断某个类是否可以相应选择器</span></span><br><span class="line"><span class="built_in">BOOL</span> class_respondsToSelector(Class cls, SEL sel);</span><br><span class="line"><span class="comment">//获取某个类的实例方法列表</span></span><br><span class="line">Method *class_copyMethodList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//为某个类动态添加一个实例方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cls:添加方法的类</span></span><br><span class="line"><span class="comment">SEL：添加的方法选择器</span></span><br><span class="line"><span class="comment">IMP:方法实现</span></span><br><span class="line"><span class="comment">types:参数类型字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types); </span><br><span class="line"><span class="comment">//替换一个方法的实现</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cls:类</span></span><br><span class="line"><span class="comment">SEL:要替换实现的选择器</span></span><br><span class="line"><span class="comment">IMP:实现</span></span><br><span class="line"><span class="comment">types:参数类型字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types);</span><br><span class="line"><span class="comment">//获取函数的选择器</span></span><br><span class="line">SEL method_getName(Method m);</span><br><span class="line"><span class="comment">//获取函数的实现</span></span><br><span class="line">IMP method_getImplementation(Method m);</span><br><span class="line"><span class="comment">//获取函数的参数类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *method_getTypeEncoding(Method m);</span><br><span class="line"><span class="comment">//获取函数的参数个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments(Method m);</span><br><span class="line"><span class="comment">//获取函数的返回值类型</span></span><br><span class="line"><span class="keyword">char</span> *method_copyReturnType(Method m);</span><br><span class="line"><span class="comment">//拷贝参数类型列表</span></span><br><span class="line"><span class="keyword">char</span> *method_copyArgumentType(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br><span class="line"><span class="comment">//获取返回值类型</span></span><br><span class="line"><span class="keyword">void</span> method_getReturnType(Method m, <span class="keyword">char</span> *dst, size_t dst_len) ;</span><br><span class="line"><span class="comment">//获取参数类型</span></span><br><span class="line"><span class="keyword">void</span> method_getArgumentType(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len);</span><br><span class="line"><span class="comment">//获取函数描述信息</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">objc_method_description结构体描述函数信息 如下：</span></span><br><span class="line"><span class="comment">struct objc_method_description &#123;</span></span><br><span class="line"><span class="comment">    //函数名</span></span><br><span class="line"><span class="comment">    SEL name;               /**&lt; The name of the method */</span></span><br><span class="line">    <span class="comment">//参数类型</span></span><br><span class="line">    <span class="keyword">char</span> *types;            <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"><span class="keyword">struct</span> objc_method_description *method_getDescription(Method m);</span><br><span class="line"><span class="comment">//修改某个函数的实现</span></span><br><span class="line">IMP method_setImplementation(Method m, IMP imp);</span><br><span class="line"><span class="comment">//交换两个函数的实现</span></span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2);</span><br><span class="line"><span class="comment">//获取选择器名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sel_getName(SEL sel);</span><br><span class="line"><span class="comment">//通过名称获取选择器</span></span><br><span class="line">SEL sel_getUid(<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line"><span class="comment">//注册一个选择器</span></span><br><span class="line">SEL sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *str);</span><br><span class="line"><span class="comment">//判断两个选择器是否相等</span></span><br><span class="line"><span class="built_in">BOOL</span> sel_isEqual(SEL lhs, SEL rhs);</span><br><span class="line"><span class="comment">//将block作为IMP的实现</span></span><br><span class="line">IMP imp_implementationWithBlock(<span class="keyword">id</span> block);</span><br><span class="line"><span class="comment">//获取IMP的实现block</span></span><br><span class="line"><span class="keyword">id</span> imp_getBlock(IMP anImp);</span><br><span class="line"><span class="comment">//删除IMP的block实现</span></span><br><span class="line"><span class="built_in">BOOL</span> imp_removeBlock(IMP anImp);</span><br></pre></td></tr></table></figure>
<p>上面列举的函数中很多都用到参数类型的指定，types需要设置为C风格的字符数组，即C字符串，其中第1个字符表示返回值类型，其余字符依次表示参数类型，参数类型与字符的映射表如下：</p>
<p><img src="https://static.oschina.net/uploads/space/2017/0505/103650_6rxS_2340880.png" alt></p>
<h4 id="4-协议相关操作函数"><a href="#4-协议相关操作函数" class="headerlink" title="4.协议相关操作函数"></a>4.协议相关操作函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断某个类是否遵守某个协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol(Class cls, Protocol *protocol);</span><br><span class="line"><span class="comment">//拷贝某个类的协议列表</span></span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *class_copyProtocolList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//动态向类中添加协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProtocol(Class cls, Protocol *protocol);</span><br><span class="line"><span class="comment">//通过协议名获取某个协议指针</span></span><br><span class="line">Protocol *objc_getProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//拷贝所有协议列表</span></span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *objc_copyProtocolList(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//判断某个协议是否继承于另一个协议</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol(Protocol *proto, Protocol *other);</span><br><span class="line"><span class="comment">//判断两个协议是否相同</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_isEqual(Protocol *proto, Protocol *other);</span><br><span class="line"><span class="comment">//获取协议名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *protocol_getName(Protocol *p);</span><br><span class="line"><span class="comment">//获取协议中某个函数的描述</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p:协议指针</span></span><br><span class="line"><span class="comment">aSel:方法选择器</span></span><br><span class="line"><span class="comment">isRequiredMethod:是否是必实现的</span></span><br><span class="line"><span class="comment">isInstanceMehod:是否是实例方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod);</span><br><span class="line"><span class="comment">//获取协议方法描述列表</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description *protocol_copyMethodDescriptionList(Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//获取协议中的属性描述</span></span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty);</span><br><span class="line"><span class="comment">//获取协议中的属性描述列表</span></span><br><span class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">objc_property_t *protocol_copyPropertyList2(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty);</span><br><span class="line"><span class="comment">//获取适配协议列表</span></span><br><span class="line">Protocol * __<span class="keyword">unsafe_unretained</span> *protocol_copyProtocolList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br><span class="line"><span class="comment">//创建一个协议</span></span><br><span class="line">Protocol *objc_allocateProtocol(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//进行协议注册</span></span><br><span class="line"><span class="keyword">void</span> objc_registerProtocol(Protocol *proto);</span><br><span class="line"><span class="comment">//向协议中添加一个方法描述</span></span><br><span class="line"><span class="keyword">void</span> protocol_addMethodDescription(Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod);</span><br><span class="line"><span class="comment">//向协议中添加另一个协议</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProtocol(Protocol *proto, Protocol *addition);</span><br><span class="line"><span class="comment">//向协议中添加属性描述</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProperty(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty);</span><br></pre></td></tr></table></figure>
<p>协议实质也是一个Objective-C对象。</p>
<h4 id="5-动态构建类实例相关函数"><a href="#5-动态构建类实例相关函数" class="headerlink" title="5.动态构建类实例相关函数"></a>5.动态构建类实例相关函数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建一个类实例</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cls:类名</span></span><br><span class="line"><span class="comment">size_t:分配额外的内存 用来存放类定义之外的变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">id</span> class_createInstance(Class cls, size_t extraBytes);</span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="keyword">id</span> objc_constructInstance(Class cls, <span class="keyword">void</span> *bytes);</span><br><span class="line"><span class="comment">//销毁一个实例</span></span><br><span class="line"><span class="keyword">void</span> *objc_destructInstance(<span class="keyword">id</span> obj);</span><br><span class="line"><span class="comment">//动态定义一个类 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">superClass:指定父类</span></span><br><span class="line"><span class="comment">name:类名</span></span><br><span class="line"><span class="comment">extraBytes:额外的内存空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name,size_t extraBytes);</span><br><span class="line"><span class="comment">//进行类的注册 需要注意 要添加属性 必须在注册类之前添加</span></span><br><span class="line"><span class="keyword">void</span> objc_registerClassPair(Class cls);</span><br><span class="line"><span class="comment">//销毁一个类</span></span><br><span class="line"><span class="keyword">void</span> objc_disposeClassPair(Class cls);</span><br></pre></td></tr></table></figure>
<h3 id="五、运行时的几点应用扩展"><a href="#五、运行时的几点应用扩展" class="headerlink" title="五、运行时的几点应用扩展"></a>五、运行时的几点应用扩展</h3><pre><code>到此本篇文章终于要告一段落了，相信你如果能看到这里，你一定有超凡的耐心。但是切记Objective-C的消息机制配合运行时是可以给开发者极大的元编程自由，但是不适当的使用也会造成破坏性的后果。下面几篇博客从一些方面介绍了Runtime的几点应用，你可以从中管中窥豹，可见一斑。
</code></pre><p>1.runtime基础应用：<a href="https://my.oschina.net/u/2340880/blog/489072" target="_blank" rel="noopener">https://my.oschina.net/u/2340880/blog/489072</a></p>
<p>2.使用runtime全局修改UILabel字体：<a href="https://my.oschina.net/u/2340880/blog/538356" target="_blank" rel="noopener">https://my.oschina.net/u/2340880/blog/538356</a></p>
<p>3.使用runtime自动化归档：<a href="https://my.oschina.net/u/2340880/blog/514330" target="_blank" rel="noopener">https://my.oschina.net/u/2340880/blog/514330</a></p>
<p>4.代码调试框架的设计：<a href="https://my.oschina.net/u/2340880/blog/504675" target="_blank" rel="noopener">https://my.oschina.net/u/2340880/blog/504675</a></p>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © 微信：15137348047
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2017/05/15/328iOS开发中活动视图控制器UIActivityViewController的应用/" class="pre-post btn btn-default" title='iOS开发中活动视图控制器UIActivityViewController的应用'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">iOS开发中活动视图控制器UIActivityViewController的应用</span>
        </a>
    
    
        <a href="/2017/04/27/326NSTextField控件应用详解/" class="next-post btn btn-default" title='NSTextField控件应用详解'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">NSTextField控件应用详解</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
<div id="lv-container" data-id="city" data-uid="MTAyMC8zNzY0Ny8xNDE3OA==">
  <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];
         if (typeof LivereTower === 'function') { return; }
         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;
         e.parentNode.insertBefore(j, e);
     })(document, 'script');
  </script>
</div>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态的Objective-C——关于消息机制与运行时的探讨"><span class="toc-text">动态的Objective-C——关于消息机制与运行时的探讨</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、引言"><span class="toc-text">一、引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、消息发送与转发机制"><span class="toc-text">二、消息发送与转发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-初窥消息发送机制"><span class="toc-text">1.初窥消息发送机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-消息传递是基于继承链的"><span class="toc-text">2.消息传递是基于继承链的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-拯救未知消息的3根救命稻草"><span class="toc-text">3.拯救未知消息的3根救命稻草</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、发送消息的几个函数"><span class="toc-text">三、发送消息的几个函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-最重要的两个发送消息函数"><span class="toc-text">1.最重要的两个发送消息函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-super关键字到底做了什么"><span class="toc-text">2.super关键字到底做了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-一些辅助的消息发送函数"><span class="toc-text">3.一些辅助的消息发送函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、是时候来重温下Runtime了"><span class="toc-text">四、是时候来重温下Runtime了</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-类相关操作函数"><span class="toc-text">1.类相关操作函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-变量属性相关操作函数"><span class="toc-text">2.变量属性相关操作函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-方法操作相关函数"><span class="toc-text">3.方法操作相关函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-协议相关操作函数"><span class="toc-text">4.协议相关操作函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-动态构建类实例相关函数"><span class="toc-text">5.动态构建类实例相关函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、运行时的几点应用扩展"><span class="toc-text">五、运行时的几点应用扩展</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2018
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>