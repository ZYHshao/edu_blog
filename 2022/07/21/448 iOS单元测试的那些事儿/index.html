<script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script> 
<script>
　　let models = [
    "https://unpkg.com/live2d-widget-model-chitose@1.0.5/assets/chitose.model.json",
    "https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json",
    "https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json",
    "https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json",
    "https://unpkg.com/live2d-widget-model-miku@1.0.5/assets/miku.model.json",
    "https://unpkg.com/live2d-widget-model-z16@1.0.5/assets/z16.model.json"
];
let m = models[Math.round(Math.random()*5)];
　　L2Dwidget.init({ 
　　"model": {jsonPath:m,"scale": 1 }, 
　　"display": { "position": "left", "width": 200, "height": 300,"hOffset": 0, "vOffset": -20 }, 
　　"mobile": { "show": true, "scale": 0.5 }, 
　　"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });
</script> 
<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="珲少的技术博客">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://huishao.cc">
    <meta name="referrer" content="no-referrer">
    <!--SEO-->

<meta name="description" content="珲少的技术博客">



<meta name="keywords" content="珲少">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>iOS单元测试的那些事儿 | 珲少的技术博客</title>


    <link rel="alternate" href="/atom.xml" title="珲少的技术博客" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    





    
</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://7xpw2b.com1.z0.glb.clouddn.com/hexo-sinppet/img/banner.png)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='珲少'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 学如逆水行舟 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://huishao.cc">珲少的技术博客</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>主页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>归档</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="iOS单元测试的那些事儿">
            
	            iOS单元测试的那些事儿
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/编程珠玑">
            编程珠玑
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2022/07/21</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="iOS单元测试的那些事儿"><a href="#iOS单元测试的那些事儿" class="headerlink" title="iOS单元测试的那些事儿"></a>iOS单元测试的那些事儿</h1><p>作为客户端开发，很多时候我们过多的关注于功能的测试，而忽略标准的单元测试。其实，单元测试是保障项目稳定性的最有效且成本最低的测试方式。越偏向底层服务的代码，越需要使用单元测试来对可靠性进行保障。一旦单元测试覆盖完成，则之后再进行代码优化和迭代的时候则会有引入新问题的几率会大为减小。</p>
<p>Xcode提供了完整的单元测试功能，系统预置的单元测试类和断言也非常方便开发者编写测试代码。除了函数功能测试，性能测试外，也支持进行UI上的单元测试。本篇文章，我们就将介绍iOS中关于单元测试的那些事。</p>
<h2 id="一-先看一个简单的单元测试例子"><a href="#一-先看一个简单的单元测试例子" class="headerlink" title="一 先看一个简单的单元测试例子"></a>一 先看一个简单的单元测试例子</h2><p>首先可以新建一个iOS测试工程，在工程中任意添加一个示例类文件，例如命名为ViewModel类，实现如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewModel.h文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)getSegementCount:(<span class="built_in">NSString</span> *)string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewModel.m文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewModel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewModel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)getSegementCount:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="keyword">return</span> [string componentsSeparatedByString:<span class="string">@":"</span>].count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这个类本身非常简单，只提供了一个获取字符串分段数的方法。此方法只要有明确的输入就会有明确的输出，非常适合用来做单元测试。之后，使用Xcode新建一个Unit Testing Bundle的Target模块，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f819d444ef0b092139383ba56f6ccc3e6b4.png" alt></p>
<p>之后默认会生成一个测试文件，其只有.m文件，没有.h文件，我们的主要测试代码也都将编写到这个.m文件中。</p>
<p>生成的测试文件中默认实现了setUp，tearDown，testExample和testPerformanceExample这些方法，等下我们会对这些方法进行介绍，修改此测试文件如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;XCTest/XCTest.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewModel.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UnitTestDemoTests</span> : <span class="title">XCTestCase</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ViewModel *viewModel;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UnitTestDemoTests</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setUp &#123;</span><br><span class="line">    <span class="keyword">self</span>.viewModel = [[ViewModel alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)tearDown &#123;</span><br><span class="line">    <span class="keyword">self</span>.viewModel = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testExample &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> count = [<span class="keyword">self</span>.viewModel getSegementCount:<span class="string">@"127:0:0:1"</span>];</span><br><span class="line">    <span class="built_in">XCTAssertEqual</span>(count, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">    [<span class="keyword">self</span> measureBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"---"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>其中setUp方法是当前测试类的初始化方法，我们可以将一些资源准备工作在这个方法中完成，tearDown方式在测试结束后会调用，用来进行资源的清理。测试函数都需要以text开头，testExample是默认生成的一个测试用例函数，我们在其中检查getSegmentCount方法的工作是否正常，XCTAssertEqual是XCTest框架提供的众多测试断言中的一种，用来进行相等断言，如果getSegmentCount方法执行的结果与我们预期不一致，则会命中此断言，从而使当前测试用例失败。testPerformanceExample是性能测试的一个案例，其内的measureBlock里的代码会被默认执行10次，最终输出每次执行的时间消耗报告。</p>
<p>下面，我们可以执行下此测试类，在Xcode的测试导航中点击此测试类右边的执行按钮即可：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2108710e0314310c7e6619d4a35e1351437.png" alt></p>
<p>每个测试方法的结果会在右侧展示，绿的的对号表示此测试用例通过。也可以直接在测试类文件中执行单个的测试用例，如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d69a9944798abef580f60f9397ae890de79.png" alt></p>
<p>对于性能测试用例，其测试完成后会自动生成一个性能报告，对每个性能测试函数，我们都可以为其设置一个基准值，其会分析性能优于或劣于基准值多少。如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9e6377e7b4e7a6dcf581e3a074ed8d013f9.png" alt></p>
<h2 id="二-关于XCTestCase类"><a href="#二-关于XCTestCase类" class="headerlink" title="二 关于XCTestCase类"></a>二 关于XCTestCase类</h2><p>XCTestCase可以理解为一个测试用例类，其中可以定义多个测试用例函数。通常最佳的实践是一个功能类对应一个XCTestCase测试类，在此测试类中对相应的功能类进行覆盖测试。</p>
<p>要定义一个测试用例类非常简单，遵循如下的步骤即可：</p>
<p>1. 创建一个XCTestCase的子类。</p>
<p>2. 自定义以test开头的实例方法，作为独立的测试用例。</p>
<p>3. 可以定义一些需要保持状态的变量或属性作为测试物料。</p>
<p>4. 某些需要初始化的状态在setup方法中设置。</p>
<p>5. 测试完成后的清理工作在tearDown方法中设置。</p>
<p>对于自定义的测试实例方法，有3个非常重要的原则，符合这3个原则的方法才会被系统识别为测试用例，即：没有入参，没有返回值，以test开头。</p>
<p>XCTestCase也支持进行更多定制化配置，例如超时时间，测试异常的记录等。XCTestCase类中提供的初始化方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过invocation构造测试类</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)testCaseWithInvocation:(<span class="keyword">nullable</span> <span class="built_in">NSInvocation</span> *)invocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例的初始化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithInvocation:(<span class="keyword">nullable</span> <span class="built_in">NSInvocation</span> *)invocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过selector构造测试类</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)testCaseWithSelector:(SEL)selector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSelector:(SEL)selector;</span><br></pre></td></tr></table></figure>
<p>通常，如果我们需要定制XCTestCase的属性，可以在子类中重写initWithInvocation方法，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithInvocation:(<span class="keyword">nullable</span> <span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithInvocation:invocation];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.continueAfterFailure = <span class="literal">NO</span>;</span><br><span class="line">        [<span class="keyword">self</span> addTeardownBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"TTT"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XCTestCase类中封装的属性和方法解析如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试用例执行时 调用的invocation</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSInvocation</span> *invocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行测试，此方法应该由系统框架调用，不能主动调用</span></span><br><span class="line">- (<span class="keyword">void</span>)invokeTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当某个测试用例方法没通过时，是否继续执行其后的逻辑</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> continueAfterFailure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例不通过后，会回调此方法，子类可以重写来自定义异常报告</span></span><br><span class="line">- (<span class="keyword">void</span>)recordIssue:(<span class="built_in">XCTIssue</span> *)issue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个测试用例所对应的NSInvocation</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSInvocation</span> *&gt; *testInvocations;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个自定义的tearDown回调</span></span><br><span class="line">- (<span class="keyword">void</span>)addTeardownBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个异步执行的tearDown回调</span></span><br><span class="line">- (<span class="keyword">void</span>)addAsyncTeardownBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span> (^completion)(<span class="built_in">NSError</span> * _Nullable error)))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用例执行超时时间 默认10min</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> executionTimeAllowance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能测试方法，将要测试性能的逻辑代码放入block即可</span></span><br><span class="line">- (<span class="keyword">void</span>)measureBlock:(<span class="built_in">XCT_NOESCAPE</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 性能测试方法，在block中需要手动启动和结束性能测试 配套下面两个方法使用</span></span><br><span class="line">- (<span class="keyword">void</span>)measureMetrics:(<span class="built_in">NSArray</span>&lt;<span class="built_in">XCTPerformanceMetric</span>&gt; *)metrics automaticallyStartMeasuring:(<span class="built_in">BOOL</span>)automaticallyStartMeasuring forBlock:(<span class="built_in">XCT_NOESCAPE</span> <span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"><span class="comment">// 开启性能测试</span></span><br><span class="line">- (<span class="keyword">void</span>)startMeasuring;</span><br><span class="line"><span class="comment">// 结束性能测试</span></span><br><span class="line">- (<span class="keyword">void</span>)stopMeasuring;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的测试组，每个测试方法都是一个独立的测试用例，当前测试类可以定义一组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>, <span class="keyword">readonly</span>) <span class="built_in">XCTestSuite</span> *defaultTestSuite;</span><br><span class="line"><span class="comment">// 每个测试方法执行前都会执行的setup步骤</span></span><br><span class="line">+ (<span class="keyword">void</span>)setUp;</span><br><span class="line"><span class="comment">// 每个测试方法执行前都会执行的teardown步骤</span></span><br><span class="line">+ (<span class="keyword">void</span>)tearDown;</span><br></pre></td></tr></table></figure>
<p>XCTestCase也实现了XCTActivity协议，允许直接向测试用例对象中添加附件，方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addAttachment:(<span class="built_in">XCTAttachment</span> *)attachment;</span><br></pre></td></tr></table></figure>
<p>被添加的附件会被Xcode持有，并根据策略保存到测试报告中去。附件有时候对测试来说非常重要，例如要保存失败测试的案例数据，以便开发进行追溯，这是就可以将数据作为附件保存。例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testExample &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> count = [<span class="keyword">self</span>.viewModel getSegementCount:<span class="string">@"127:0:0:1"</span>];</span><br><span class="line">    <span class="built_in">XCTAssertEqual</span>(count, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">XCTAttachment</span> *attachment =  [<span class="built_in">XCTAttachment</span> attachmentWithString:<span class="string">@"我是附件"</span>];</span><br><span class="line">    attachment.lifetime = <span class="built_in">XCTAttachmentLifetimeKeepAlways</span>;</span><br><span class="line">    [<span class="keyword">self</span> addAttachment:attachment];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"xxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行测试后，在测试报告中可以查看用例的附件文件，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-405d4005bb051a00e371a0ee558be4e983f.png" alt></p>
<p>关于附件的相关内容，后面会在介绍。最后，关于XCTestCase的性能测试，可以通过设置Option参数来控制循环次数，例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testPerformanceExample &#123;</span><br><span class="line">    <span class="built_in">XCTMeasureOptions</span> *op = [[<span class="built_in">XCTMeasureOptions</span> alloc] init];</span><br><span class="line">    op.iterationCount = <span class="number">20</span>;</span><br><span class="line">    [<span class="keyword">self</span> measureWithOptions:op block:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"---"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，性能测试代码将被循环执行20次。</p>
<h2 id="三-测试附件"><a href="#三-测试附件" class="headerlink" title="三 测试附件"></a>三 测试附件</h2><p>前面说过，附件可以用来保存测试执行时的案例数据，帮助开发者后续回溯。XCTAttachment类封装的常用属性和方法列举如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 初始化相关</span><br><span class="line">- (instancetype)initWithUniformTypeIdentifier:(nullable NSString *)identifier</span><br><span class="line">                                         name:(nullable NSString *)name</span><br><span class="line">                                      payload:(nullable NSData *)payload</span><br><span class="line">                                     userInfo:(nullable NSDictionary *)userInfo;</span><br><span class="line">+ (instancetype)attachmentWithUniformTypeIdentifier:(nullable NSString *)identifier</span><br><span class="line">                                               name:(nullable NSString *)name</span><br><span class="line">                                            payload:(nullable NSData *)payload</span><br><span class="line">                                           userInfo:(nullable NSDictionary *)userInfo;</span><br><span class="line"></span><br><span class="line">// 文件标识符</span><br><span class="line">@property (readonly, copy) NSString *uniformTypeIdentifier;</span><br><span class="line">// 附件名</span><br><span class="line">@property (copy, nullable) NSString *name;</span><br><span class="line">// 用户附加数据</span><br><span class="line">@property (copy, nullable) NSDictionary *userInfo;</span><br><span class="line">// 附件的生存时间</span><br><span class="line">/*</span><br><span class="line">typedef NS_ENUM(NSInteger, XCTAttachmentLifetime) &#123;</span><br><span class="line">    // 一直存在</span><br><span class="line">    XCTAttachmentLifetimeKeepAlways = 0,</span><br><span class="line">    // 测试用例通过后将附件删除</span><br><span class="line">    XCTAttachmentLifetimeDeleteOnSuccess = 1</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">@property XCTAttachmentLifetime lifetime;</span><br><span class="line"></span><br><span class="line">// 通过指定类型的数据直接创建附件</span><br><span class="line">+ (instancetype)attachmentWithData:(NSData *)payload;</span><br><span class="line">+ (instancetype)attachmentWithData:(NSData *)payload uniformTypeIdentifier:(NSString *)identifier;</span><br><span class="line">+ (instancetype)attachmentWithString:(NSString *)string;</span><br><span class="line">+ (instancetype)attachmentWithArchivableObject:(id&lt;NSSecureCoding&gt;)object;</span><br><span class="line">+ (instancetype)attachmentWithArchivableObject:(id&lt;NSSecureCoding&gt;)object uniformTypeIdentifier:(NSString *)identifier;</span><br><span class="line">+ (instancetype)attachmentWithPlistObject:(id)object;</span><br><span class="line">+ (instancetype)attachmentWithContentsOfFileAtURL:(NSURL *)url;</span><br><span class="line">+ (instancetype)attachmentWithContentsOfFileAtURL:(NSURL *)url uniformTypeIdentifier:(NSString *)identifier;</span><br><span class="line">+ (instancetype)attachmentWithCompressedContentsOfDirectoryAtURL:(NSURL *)url;</span><br><span class="line">+ (instancetype)attachmentWithImage:(UIImage *)image;</span><br><span class="line">+ (instancetype)attachmentWithImage:(UIImage *)image quality:(XCTImageQuality)quality;</span><br></pre></td></tr></table></figure>
<h2 id="四-测试断言"><a href="#四-测试断言" class="headerlink" title="四 测试断言"></a>四 测试断言</h2><p>测试用例的通过与否是由断言决定的，XCTest框架中提供的断言宏列举如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 无条件的异常断言</span><br><span class="line">XCTFail(...)</span><br><span class="line">// 空断言，当表达式不是空时测试失败</span><br><span class="line">XCTAssertNil(expression, ...)</span><br><span class="line">// 非空断言，当表达式为空时测试失败</span><br><span class="line">XCTAssertNotNil(expression, ...)</span><br><span class="line">// 布尔断言，当表达式为false时测试失败</span><br><span class="line">XCTAssert(expression, ...)</span><br><span class="line">// 布尔断言，当表达式为false时测试失败</span><br><span class="line">XCTAssertTrue(expression, ...)</span><br><span class="line">// 布尔断言，当表达式为true时测试失败</span><br><span class="line">XCTAssertFalse(expression, ...)</span><br><span class="line">// 相等断言，当两个表达式结果不相等时测试失败 使用equal方法</span><br><span class="line">XCTAssertEqualObjects(expression1, expression2, ...)</span><br><span class="line">// 不相等断言，当两个表达式结果相等时测试失败 使用equal方法</span><br><span class="line">XCTAssertNotEqualObjects(expression1, expression2, ...)</span><br><span class="line">// 相等断言，当两个表达式结果不相等时测试失败 使用 ==</span><br><span class="line">XCTAssertEqual(expression1, expression2, ...)</span><br><span class="line">// 相等断言，当两个表达式结果相等时测试失败 使用 ==</span><br><span class="line">XCTAssertNotEqual(expression1, expression2, ...)</span><br><span class="line">// 实例断言，当两个表达式结果为不相同的类实例时，测试失败</span><br><span class="line">XCTAssertIdentical(expression1, expression2, ...)</span><br><span class="line">// 实例断言，当两个表达式结果为相同的类实例时，测试失败</span><br><span class="line">XCTAssertNotIdentical(expression1, expression2, ...) </span><br><span class="line">// 差异断言，两表达式结果的差异大于设置阈值时测试失败</span><br><span class="line">XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, ...)</span><br><span class="line">// 差异断言，两表达式结果的差异不大于设置阈值时测试失败</span><br><span class="line">XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, ...)</span><br><span class="line">// 大于断言，表达式1的值小于等于表达式2时测试失败</span><br><span class="line">XCTAssertGreaterThan(expression1, expression2, ...)</span><br><span class="line">// 大于等于断言，表达式1的值小于表达式2时测试失败</span><br><span class="line">XCTAssertGreaterThanOrEqual(expression1, expression2, ...)</span><br><span class="line">// 小于断言，表达式1的值大于等于表达式2时测试失败</span><br><span class="line">XCTAssertLessThan(expression1, expression2, ...)</span><br><span class="line">// 小于等于断言，表达式1的值大于表达式2时测试失败</span><br><span class="line">XCTAssertLessThanOrEqual(expression1, expression2, ...)</span><br><span class="line">// 异常断言，当表达式没有抛出异常时测试失败</span><br><span class="line">XCTAssertThrows(expression, ...)</span><br><span class="line">// 特殊异常断言，当表达式抛出的异常不是指定的类时测试失败</span><br><span class="line">XCTAssertThrowsSpecific(expression, exception_class, ...)</span><br><span class="line">// 特殊异常断言，当表达式抛出的异常不是指定的类和名字时测试失败</span><br><span class="line">XCTAssertThrowsSpecificNamed(expression, exception_class, exception_name, ...)</span><br><span class="line">// 无异常断言，当表达式有异常抛出时测试失败</span><br><span class="line">XCTAssertNoThrow(expression, ...)</span><br><span class="line">// 无特殊异常断言，当表达式有指定的异常抛出时测试失败</span><br><span class="line">XCTAssertNoThrowSpecific(expression, exception_class, ...)</span><br><span class="line">// 无特殊异常断言，当表达式有指定的异常抛出时测试失败</span><br><span class="line">XCTAssertNoThrowSpecificNamed(expression, exception_class, exception_name, ...)</span><br></pre></td></tr></table></figure>
<h2 id="五-代码覆盖率"><a href="#五-代码覆盖率" class="headerlink" title="五 代码覆盖率"></a>五 代码覆盖率</h2><p>与单元测试相关的，还有一个重要的概念：代码覆盖率。代码覆盖率是指在整个测试执行过程中，覆盖到的功能函数与所有功能函数的比例。覆盖率越高说明测试涉及的功能越全。</p>
<p>测试完成后，可以直接在Xcode中查看代码覆盖率，如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-92d08a4c086a880d1f10c796217d48e739b.png" alt></p>
<p>单元测试保持较高的覆盖率是非常重要的，其从另一个方面也是测试质量的保障。</p>
<h2 id="六-异步函数的测试"><a href="#六-异步函数的测试" class="headerlink" title="六 异步函数的测试"></a>六 异步函数的测试</h2><p>前面我们演示的测试用例所执行的逻辑都是同步的，但在实际的项目中，异步的操作很多，XCTest框架中也提供了异步逻辑的测试方式。例如对如下业务方法进行测试：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)requestData:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))complete &#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (complete) &#123;</span><br><span class="line">            complete(<span class="literal">YES</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testAsync &#123;</span><br><span class="line">    <span class="built_in">XCTestExpectation</span> *except = [<span class="keyword">self</span> expectationWithDescription:<span class="string">@"异步请求测试用例"</span>];</span><br><span class="line">    [<span class="keyword">self</span>.viewModel requestData:^(<span class="built_in">BOOL</span> success) &#123;</span><br><span class="line">        <span class="built_in">XCTAssertTrue</span>(success);</span><br><span class="line">        [except fulfill];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span> waitForExpectationsWithTimeout:<span class="number">10</span> handler:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XCTestExpectation可以理解为一个期望对象，当使用此对象调用fulfill方法后，表示异步逻辑完成，XCTestCase类本身与异步测试相关的方法列举如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个XCTestExpectation对象</span></span><br><span class="line">- (<span class="built_in">XCTestExpectation</span> *)expectationWithDescription:(<span class="built_in">NSString</span> *)description;</span><br><span class="line"><span class="comment">// 等待异步操作结果，可以设置超时时间</span></span><br><span class="line">- (<span class="keyword">void</span>)waitForExpectationsWithTimeout:(<span class="built_in">NSTimeInterval</span>)timeout handler:(<span class="keyword">nullable</span> <span class="built_in">XCWaitCompletionHandler</span>)handler;</span><br><span class="line">- (<span class="keyword">void</span>)waitForExpectations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">XCTestExpectation</span> *&gt; *)expectations timeout:(<span class="built_in">NSTimeInterval</span>)seconds;</span><br><span class="line">- (<span class="keyword">void</span>)waitForExpectations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">XCTestExpectation</span> *&gt; *)expectations timeout:(<span class="built_in">NSTimeInterval</span>)seconds enforceOrder:(<span class="built_in">BOOL</span>)enforceOrderOfFulfillment;</span><br></pre></td></tr></table></figure>
<p>XCTestExpectation类中封装的常用属性和方法列举如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化方法，描述参数会在测试报告中包含</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDescription:(<span class="built_in">NSString</span> *)expectationDescription;</span><br><span class="line"><span class="comment">// 描述文案</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSString</span> *expectationDescription;</span><br><span class="line"><span class="comment">// 设置是否行为反向</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isInverted) <span class="built_in">BOOL</span> inverted;</span><br><span class="line"><span class="comment">// 设置期望的完成次数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> expectedFulfillmentCount;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> assertForOverFulfill;</span><br><span class="line"><span class="comment">// 触发一次完成动作</span></span><br><span class="line">- (<span class="keyword">void</span>)fulfill;</span><br></pre></td></tr></table></figure>
<p>七 关于单元测试的几点建议</p>
<p>我们先不涉及到UI方面的自动化测试，只针对逻辑代码的单元测试，下面这些建议可供参考：</p>
<p>1. 在编码时，要尽量按照MVVM的模式进行开发，相比MVC模式，MVVM的逻辑代码都封装在VM里面，更利于进行脱离UI的测试。可以设想，如果将逻辑方法都写在View或ViewController中，则执行测试用例时就不得不引入很多额外的页面UI组件。</p>
<p>2. 编写测试用例时，有3个核心要考虑的点，即输入，输出和结果判定。我们通过输入来设置测试用例的初始状态，通过对输出的结果判定来决定测试用例是否通过。</p>
<p>3. 在开发中，编写的函数要尽量符合下面的特性：功能单一，有输入有输出。</p>
<p>4. 某些场景下，函数的功能是对输入的参数进行修改，而并没有返回值，则这种场景编写测试用例时，要判断的是执行函数操作后的原始变量是否符合预期。例如：</p>
<p>功能函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeAllObj:(<span class="built_in">NSMutableArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">if</span> ([array isKindOfClass:<span class="built_in">NSMutableArray</span>.class]) &#123;</span><br><span class="line">        [array removeAllObjects];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testRemoveObj &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"1"</span>, <span class="string">@"2"</span>, <span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.viewModel removeAllObj:array];</span><br><span class="line">    <span class="built_in">XCTAssertEqual</span>(array.count, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5. 某些场景下，功能函数可能没有参数也没有返回值，其作用只是执行一段逻辑操作，例如存储文件，修改文件等。这时我们可以修改下功能函数，在函数内返回操作成功或失败的结果，测试用例使用此结果来作为是否通过的标准。</p>
<h2 id="八-XCTest框架中的UI测试"><a href="#八-XCTest框架中的UI测试" class="headerlink" title="八 XCTest框架中的UI测试"></a>八 XCTest框架中的UI测试</h2><p>相比逻辑功能测试，UI测试通常会麻烦一些。XCTest框架中也集成了UI测试相关的接口。通常在编写测试用例时，我们会将功能测试和UI测试分开编写。创建UI Test Bundle如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-83830040ef698a56c949975b05e38640d4a.png" alt></p>
<p>生成的模板代码中会自带启动性能测试用例，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testLaunchPerformance &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(macOS <span class="number">10.15</span>, iOS <span class="number">13.0</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">7.0</span>, *)) &#123;</span><br><span class="line">        <span class="comment">// This measures how long it takes to launch your application.</span></span><br><span class="line">        [<span class="keyword">self</span> measureWithMetrics:@[[[<span class="built_in">XCTApplicationLaunchMetric</span> alloc] init]] block:^&#123;</span><br><span class="line">            [[[<span class="built_in">XCUIApplication</span> alloc] init] launch];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，XCTApplicationLaunchMetric对象配置为冷启动指标，其会计算从App启动到首帧渲染完成的时间。XCUIApplication用来实例化一个App应用实例，调用launch方法进行启动。默认其会启动当前应用，也可以通过设置bundleId来让其启动其他App进行测试，例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testLaunchPerformance &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(macOS <span class="number">10.15</span>, iOS <span class="number">13.0</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">7.0</span>, *)) &#123;</span><br><span class="line">        <span class="comment">// This measures how long it takes to launch your application.</span></span><br><span class="line">        [<span class="keyword">self</span> measureWithMetrics:@[[[<span class="built_in">XCTApplicationLaunchMetric</span> alloc] init]] block:^&#123;</span><br><span class="line">            <span class="built_in">XCUIApplication</span> *application = [[<span class="built_in">XCUIApplication</span> alloc] initWithBundleIdentifier:<span class="string">@"huishao.UnitTestDemo"</span>];</span><br><span class="line">            [application launch];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在UI测试中，我们通常会关注下面几项：</p>
<p>1. 检查页面某些元素是否存在</p>
<p>2.通过代码操作某些元素的交互</p>
<p>3.检查交互后的结果</p>
<p>因此，在UI测试中，如何查询到页面的元素是最重要的，这些工作由XCUIElementQuery类来完成，这个类相关的用法非常繁杂，例如我们要查找页面中标题为btn的按钮并进行点击操作，可以这么做：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testExample &#123;</span><br><span class="line">    <span class="comment">// UI tests must launch the application that they test.</span></span><br><span class="line">    <span class="built_in">XCUIApplication</span> *app = [[<span class="built_in">XCUIApplication</span> alloc] init];</span><br><span class="line">    [app launch];</span><br><span class="line">    <span class="built_in">XCUIElement</span> *btn = app.staticTexts[<span class="string">@"btn"</span>];</span><br><span class="line">    [btn tap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果页面查找不到此按钮，则此用例会执行失败。虽然页面元素的查找和定位非常繁琐，幸运的是Xcode提供了用户行为录制功能，我们可以将要测试的操作路径录制下来，点击Xcode的如下按钮即可：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-16a17006f7ef18fc64a9ebc3aac152484d7.png" alt></p>
<p>录制完成后，此测试用例中会自动生成查找元素和操作的相关代码，之后执行此用例时将按照录制的步骤进行，如果页面元素没有按照预期出现，则用例会失败。</p>
<h2 id="九-设备性能相关数据测试"><a href="#九-设备性能相关数据测试" class="headerlink" title="九 设备性能相关数据测试"></a>九 设备性能相关数据测试</h2><p>前面我们有提到一个冷启动时间性能测试的配置项：XCTApplicationLaunchMetric。除此之外，XCTest框架中也默认提供了如CPU，内存等设备性能测试配置。例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testCPUPerformance &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(macOS <span class="number">10.15</span>, iOS <span class="number">13.0</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">7.0</span>, *)) &#123;</span><br><span class="line">        <span class="comment">// This measures how long it takes to launch your application.</span></span><br><span class="line">        [<span class="keyword">self</span> measureWithMetrics:@[[[<span class="built_in">XCTCPUMetric</span> alloc] init]] block:^&#123;</span><br><span class="line">            <span class="built_in">XCUIApplication</span> *application = [[<span class="built_in">XCUIApplication</span> alloc] initWithBundleIdentifier:<span class="string">@"huishao.UnitTestDemo"</span>];</span><br><span class="line">            [application launch];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMemoryPerformance &#123;</span><br><span class="line">    <span class="keyword">if</span> (@available(macOS <span class="number">10.15</span>, iOS <span class="number">13.0</span>, tvOS <span class="number">13.0</span>, watchOS <span class="number">7.0</span>, *)) &#123;</span><br><span class="line">        <span class="comment">// This measures how long it takes to launch your application.</span></span><br><span class="line">        [<span class="keyword">self</span> measureWithMetrics:@[[[<span class="built_in">XCTMemoryMetric</span> alloc] init]] block:^&#123;</span><br><span class="line">            <span class="built_in">XCUIApplication</span> *application = [[<span class="built_in">XCUIApplication</span> alloc] initWithBundleIdentifier:<span class="string">@"huishao.UnitTestDemo"</span>];</span><br><span class="line">            [application launch];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试执行完成后，报告中会有详细的性能数据，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-33afcf6ade24368214439e5b92ff5eef8fe.png" alt></p>
<blockquote>
<p>专注技术，热爱生活，交流技术，也做朋友。</p>
<p>—— 珲少 QQ：316045346</p>
<p>同时，如果本篇文章让你觉得有用，欢迎分享给更多朋友，请标明出处。</p>
</blockquote>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © 微信：15137348047
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2022/08/05/449理解JavaScript中的“面向对象”/" class="pre-post btn btn-default" title='理解JavaScript中的“面向对象”'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">理解JavaScript中的“面向对象”</span>
        </a>
    
    
        <a href="/2022/07/17/447追根问底：Objective-C关联属性原理分析/" class="next-post btn btn-default" title='追根问底：Objective-C关联属性原理分析'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">追根问底：Objective-C关联属性原理分析</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
<div id="lv-container" data-id="city" data-uid="MTAyMC8zNzY0Ny8xNDE3OA==">
  <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];
         if (typeof LivereTower === 'function') { return; }
         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;
         e.parentNode.insertBefore(j, e);
     })(document, 'script');
  </script>
</div>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#iOS单元测试的那些事儿"><span class="toc-text">iOS单元测试的那些事儿</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一-先看一个简单的单元测试例子"><span class="toc-text">一 先看一个简单的单元测试例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二-关于XCTestCase类"><span class="toc-text">二 关于XCTestCase类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三-测试附件"><span class="toc-text">三 测试附件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四-测试断言"><span class="toc-text">四 测试断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五-代码覆盖率"><span class="toc-text">五 代码覆盖率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六-异步函数的测试"><span class="toc-text">六 异步函数的测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八-XCTest框架中的UI测试"><span class="toc-text">八 XCTest框架中的UI测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九-设备性能相关数据测试"><span class="toc-text">九 设备性能相关数据测试</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2018
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>